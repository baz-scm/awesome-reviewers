[
  {
    "discussion_id": "2212536028",
    "pr_number": 363,
    "pr_file": "packages/agents/src/tests/client.test.ts",
    "created_at": "2025-07-17T07:35:05+00:00",
    "commented_code": "+import { expect, describe, it, vi, beforeEach, afterEach } from \"vitest\";\n+import { AgentClient, agentFetch, camelCaseToKebabCase } from \"../client.ts\";\n+\n+class MockWebSocket {\n+  url: string;\n+  readyState = 0; // CONNECTING\n+  onopen?: (event: Event) => void;\n+  onmessage?: (event: MessageEvent) => void;\n+  onclose?: (event: CloseEvent) => void;\n+  onerror?: (event: Event) => void;\n+\n+  constructor(url: string) {\n+    this.url = url;\n+    setTimeout(() => {\n+      this.readyState = 1; // OPEN\n+      this.onopen?.(new Event(\"open\"));\n+    }, 0);\n+  }\n+\n+  send(_data: string) {}\n+\n+  close() {\n+    this.readyState = 3; // CLOSED\n+    this.onclose?.(new CloseEvent(\"close\"));\n+  }\n+}\n+\n+vi.mock(\"partysocket\", () => ({\n+  PartySocket: class MockPartySocket extends EventTarget {\n+    ws?: MockWebSocket;\n+    _options: Record<string, unknown>;\n+\n+    constructor(options: Record<string, unknown>) {\n+      super();\n+      this._options = options;\n+\n+      this.ws = new MockWebSocket(\n+        `ws://localhost/agents/${options.party}/${options.room}`\n+      );\n+    }\n+\n+    send(data: string) {\n+      this.ws?.send(data);\n+    }\n+\n+    static fetch(_opts: Record<string, unknown>, _init?: RequestInit) {\n+      return Promise.resolve(new Response(\"OK\", { status: 200 }));\n+    }\n+  }\n+}));\n+\n+describe(\"AgentClient\", () => {\n+  describe(\"Connection\", () => {\n+    it(\"should be able to connect to an agent with defaults\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\"); // Should convert to kebab-case\n+      expect(client.name).toBe(\"default\");\n+    });\n+\n+    it(\"should be able to connect to an agent with options\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        name: \"my-instance\",\n+        host: \"custom.host.com\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\");\n+      expect(client.name).toBe(\"my-instance\");\n+    });\n+\n+    it(\"should handle different agent name formats\", () => {\n+      const testCases = [\n+        { input: \"TestAgent\", expected: \"test-agent\" },\n+        { input: \"test-agent\", expected: \"test-agent\" },\n+        { input: \"TEST_AGENT\", expected: \"test-agent\" },\n+        { input: \"testAgent\", expected: \"test-agent\" }\n+      ];\n+\n+      testCases.forEach(({ input, expected }) => {\n+        const client = new AgentClient({\n+          agent: input,\n+          host: \"localhost:1999\"\n+        });\n+        expect(client.agent).toBe(expected);\n+      });\n+    });\n+  });\n+\n+  describe(\"State Management\", () => {\n+    it(\"should sync state from client to server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+      const newState = { count: 5, name: \"test\" };\n+\n+      client.setState(newState);\n+\n+      expect(sendSpy).toHaveBeenCalledWith(\n+        JSON.stringify({ state: newState, type: \"cf_agent_state\" })\n+      );\n+      expect(onStateUpdate).toHaveBeenCalledWith(newState, \"client\");\n+    });\n+\n+    it(\"should receive state updates from server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      // Simulate server state update\n+      const serverState = { count: 10, serverData: true };\n+      const event = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"cf_agent_state\",\n+          state: serverState\n+        })\n+      });\n+\n+      client.dispatchEvent(event);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(serverState, \"server\");\n+    });\n+\n+    it(\"should handle complex state objects\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient<{\n+        user: { id: number; name: string };\n+        settings: { theme: string };\n+      }>({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const complexState = {\n+        user: { id: 1, name: \"Alice\" },\n+        settings: { theme: \"dark\" }\n+      };\n+\n+      client.setState(complexState);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(complexState, \"client\");\n+    });\n+  });\n+\n+  describe(\"RPC Calls\", () => {\n+    it(\"should make RPC calls\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"testMethod\", [\"arg1\", \"arg2\"]);\n+\n+      expect(sendSpy).toHaveBeenCalled();\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+      expect(sentData).toMatchObject({\n+        type: \"rpc\",\n+        method: \"testMethod\",\n+        args: [\"arg1\", \"arg2\"]\n+      });\n+      expect(sentData.id).toBeDefined();\n+\n+      const response = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: { data: \"test result\" }\n+        })\n+      });\n+\n+      client.dispatchEvent(response);\n+\n+      const result = await callPromise;\n+      expect(result).toEqual({ data: \"test result\" });\n+    });\n+\n+    it(\"should handle RPC errors\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"failingMethod\");\n+\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+      const response = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: false,\n+          error: \"Method not found\"\n+        })\n+      });\n+\n+      client.dispatchEvent(response);\n+\n+      await expect(callPromise).rejects.toThrow(\"Method not found\");\n+    });\n+\n+    it(\"should handle streaming RPC responses\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const chunks: unknown[] = [];\n+      let finalResult: unknown;\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"streamingMethod\", [], {\n+        onChunk: (chunk) => chunks.push(chunk),\n+        onDone: (result) => {\n+          finalResult = result;\n+        }\n+      });\n+\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+\n+      const chunk1 = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: \"chunk1\",\n+          done: false\n+        })\n+      });\n+\n+      const chunk2 = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: \"chunk2\",\n+          done: false\n+        })\n+      });\n+\n+      const final = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: \"final\",\n+          done: true\n+        })\n+      });\n+\n+      client.dispatchEvent(chunk1);\n+      client.dispatchEvent(chunk2);\n+      client.dispatchEvent(final);\n+\n+      const result = await callPromise;\n+\n+      expect(chunks).toEqual([\"chunk1\", \"chunk2\"]);\n+      expect(finalResult).toBe(\"final\");\n+      expect(result).toBe(\"final\");\n+    });\n+\n+    it(\"should handle streaming errors\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const onError = vi.fn();\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"streamingMethod\", [], {\n+        onError\n+      });\n+\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+\n+      const errorResponse = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: false,\n+          error: \"Stream failed\"\n+        })\n+      });\n+\n+      client.dispatchEvent(errorResponse);\n+\n+      await expect(callPromise).rejects.toThrow(\"Stream failed\");\n+      expect(onError).toHaveBeenCalledWith(\"Stream failed\");\n+    });\n+  });",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2212536028",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 363,
        "pr_file": "packages/agents/src/tests/client.test.ts",
        "discussion_id": "2212536028",
        "commented_code": "@@ -0,0 +1,540 @@\n+import { expect, describe, it, vi, beforeEach, afterEach } from \"vitest\";\n+import { AgentClient, agentFetch, camelCaseToKebabCase } from \"../client.ts\";\n+\n+class MockWebSocket {\n+  url: string;\n+  readyState = 0; // CONNECTING\n+  onopen?: (event: Event) => void;\n+  onmessage?: (event: MessageEvent) => void;\n+  onclose?: (event: CloseEvent) => void;\n+  onerror?: (event: Event) => void;\n+\n+  constructor(url: string) {\n+    this.url = url;\n+    setTimeout(() => {\n+      this.readyState = 1; // OPEN\n+      this.onopen?.(new Event(\"open\"));\n+    }, 0);\n+  }\n+\n+  send(_data: string) {}\n+\n+  close() {\n+    this.readyState = 3; // CLOSED\n+    this.onclose?.(new CloseEvent(\"close\"));\n+  }\n+}\n+\n+vi.mock(\"partysocket\", () => ({\n+  PartySocket: class MockPartySocket extends EventTarget {\n+    ws?: MockWebSocket;\n+    _options: Record<string, unknown>;\n+\n+    constructor(options: Record<string, unknown>) {\n+      super();\n+      this._options = options;\n+\n+      this.ws = new MockWebSocket(\n+        `ws://localhost/agents/${options.party}/${options.room}`\n+      );\n+    }\n+\n+    send(data: string) {\n+      this.ws?.send(data);\n+    }\n+\n+    static fetch(_opts: Record<string, unknown>, _init?: RequestInit) {\n+      return Promise.resolve(new Response(\"OK\", { status: 200 }));\n+    }\n+  }\n+}));\n+\n+describe(\"AgentClient\", () => {\n+  describe(\"Connection\", () => {\n+    it(\"should be able to connect to an agent with defaults\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\"); // Should convert to kebab-case\n+      expect(client.name).toBe(\"default\");\n+    });\n+\n+    it(\"should be able to connect to an agent with options\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        name: \"my-instance\",\n+        host: \"custom.host.com\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\");\n+      expect(client.name).toBe(\"my-instance\");\n+    });\n+\n+    it(\"should handle different agent name formats\", () => {\n+      const testCases = [\n+        { input: \"TestAgent\", expected: \"test-agent\" },\n+        { input: \"test-agent\", expected: \"test-agent\" },\n+        { input: \"TEST_AGENT\", expected: \"test-agent\" },\n+        { input: \"testAgent\", expected: \"test-agent\" }\n+      ];\n+\n+      testCases.forEach(({ input, expected }) => {\n+        const client = new AgentClient({\n+          agent: input,\n+          host: \"localhost:1999\"\n+        });\n+        expect(client.agent).toBe(expected);\n+      });\n+    });\n+  });\n+\n+  describe(\"State Management\", () => {\n+    it(\"should sync state from client to server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+      const newState = { count: 5, name: \"test\" };\n+\n+      client.setState(newState);\n+\n+      expect(sendSpy).toHaveBeenCalledWith(\n+        JSON.stringify({ state: newState, type: \"cf_agent_state\" })\n+      );\n+      expect(onStateUpdate).toHaveBeenCalledWith(newState, \"client\");\n+    });\n+\n+    it(\"should receive state updates from server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      // Simulate server state update\n+      const serverState = { count: 10, serverData: true };\n+      const event = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"cf_agent_state\",\n+          state: serverState\n+        })\n+      });\n+\n+      client.dispatchEvent(event);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(serverState, \"server\");\n+    });\n+\n+    it(\"should handle complex state objects\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient<{\n+        user: { id: number; name: string };\n+        settings: { theme: string };\n+      }>({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const complexState = {\n+        user: { id: 1, name: \"Alice\" },\n+        settings: { theme: \"dark\" }\n+      };\n+\n+      client.setState(complexState);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(complexState, \"client\");\n+    });\n+  });\n+\n+  describe(\"RPC Calls\", () => {\n+    it(\"should make RPC calls\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"testMethod\", [\"arg1\", \"arg2\"]);\n+\n+      expect(sendSpy).toHaveBeenCalled();\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+      expect(sentData).toMatchObject({\n+        type: \"rpc\",\n+        method: \"testMethod\",\n+        args: [\"arg1\", \"arg2\"]\n+      });\n+      expect(sentData.id).toBeDefined();\n+\n+      const response = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: { data: \"test result\" }\n+        })\n+      });\n+\n+      client.dispatchEvent(response);\n+\n+      const result = await callPromise;\n+      expect(result).toEqual({ data: \"test result\" });\n+    });\n+\n+    it(\"should handle RPC errors\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"failingMethod\");\n+\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+      const response = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: false,\n+          error: \"Method not found\"\n+        })\n+      });\n+\n+      client.dispatchEvent(response);\n+\n+      await expect(callPromise).rejects.toThrow(\"Method not found\");\n+    });\n+\n+    it(\"should handle streaming RPC responses\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const chunks: unknown[] = [];\n+      let finalResult: unknown;\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"streamingMethod\", [], {\n+        onChunk: (chunk) => chunks.push(chunk),\n+        onDone: (result) => {\n+          finalResult = result;\n+        }\n+      });\n+\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+\n+      const chunk1 = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: \"chunk1\",\n+          done: false\n+        })\n+      });\n+\n+      const chunk2 = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: \"chunk2\",\n+          done: false\n+        })\n+      });\n+\n+      const final = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: true,\n+          result: \"final\",\n+          done: true\n+        })\n+      });\n+\n+      client.dispatchEvent(chunk1);\n+      client.dispatchEvent(chunk2);\n+      client.dispatchEvent(final);\n+\n+      const result = await callPromise;\n+\n+      expect(chunks).toEqual([\"chunk1\", \"chunk2\"]);\n+      expect(finalResult).toBe(\"final\");\n+      expect(result).toBe(\"final\");\n+    });\n+\n+    it(\"should handle streaming errors\", async () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      const onError = vi.fn();\n+      const sendSpy = vi.spyOn(client, \"send\");\n+\n+      const callPromise = client.call(\"streamingMethod\", [], {\n+        onError\n+      });\n+\n+      const sentData = JSON.parse(sendSpy.mock.calls[0][0] as string);\n+\n+      const errorResponse = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"rpc\",\n+          id: sentData.id,\n+          success: false,\n+          error: \"Stream failed\"\n+        })\n+      });\n+\n+      client.dispatchEvent(errorResponse);\n+\n+      await expect(callPromise).rejects.toThrow(\"Stream failed\");\n+      expect(onError).toHaveBeenCalledWith(\"Stream failed\");\n+    });\n+  });",
        "comment_created_at": "2025-07-17T07:35:05+00:00",
        "comment_author": "threepointone",
        "comment_body": "could you also add a couple of tests for the .stub.xyz version of calling rpc calls? I think we want to lean on that version more now, it's more user friendly that the .call version ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212548235",
    "pr_number": 363,
    "pr_file": "packages/agents/src/tests/index.test.ts",
    "created_at": "2025-07-17T07:40:30+00:00",
    "commented_code": "+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+\n+    it(\"should handle custom prefix option\", async () => {\n+      const request = new Request(\n+        \"http://localhost/custom-prefix/TestAgent/test\",\n+        {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env, {\n+        prefix: \"custom-prefix\",\n+        cors: true\n+      });\n+\n+      // Should return CORS response for OPTIONS request\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+    });\n+\n+    it(\"should return null for non-matching paths\", async () => {\n+      const request = new Request(\"http://localhost/api/other/endpoint\", {\n+        method: \"GET\"\n+      });\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeNull();\n+    });\n+  });\n+\n+  describe(\"Utility Functions\", () => {\n+    describe(\"camelCaseToKebabCase\", () => {\n+      it(\"should convert CamelCase to kebab-case\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"EmailAgent\")).toBe(\"email-agent\");\n+        expect(camelCaseToKebabCase(\"MyComplexAgentName\")).toBe(\n+          \"my-complex-agent-name\"\n+        );\n+      });\n+\n+      it(\"should handle already kebab-case strings\", () => {\n+        expect(camelCaseToKebabCase(\"test-agent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"email-agent\")).toBe(\"email-agent\");\n+      });\n+\n+      it(\"should handle single word\", () => {\n+        expect(camelCaseToKebabCase(\"Agent\")).toBe(\"agent\");\n+        expect(camelCaseToKebabCase(\"Test\")).toBe(\"test\");\n+      });\n+\n+      it(\"should handle empty string\", () => {\n+        expect(camelCaseToKebabCase(\"\")).toBe(\"\");\n+      });\n+\n+      it(\"should handle strings with numbers\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent123\")).toBe(\"test-agent123\");\n+        expect(camelCaseToKebabCase(\"Agent2Email\")).toBe(\"agent2-email\");\n+      });\n+    });\n+  });\n+\n+  describe(\"Agent with different namespaces\", () => {\n+    it(\"should handle MCP agents\", async () => {\n+      const id = env.MCP_OBJECT.idFromName(\"test-mcp\");\n+      const agent = env.MCP_OBJECT.get(id);\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle multiple agent types\", async () => {\n+      // Mock console to prevent queueMicrotask errors\n+      const logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n+      const errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n+\n+      try {\n+        const testAgent = await getAgentByName(env.TEST_AGENT, \"test1\");\n+        const emailAgent = await getAgentByName(env.EmailAgent, \"test2\");\n+\n+        expect(testAgent).toBeDefined();\n+        expect(emailAgent).toBeDefined();\n+\n+        // Each agent type has its own namespace\n+        expect(testAgent.fetch).toBeDefined();\n+        expect(emailAgent.fetch).toBeDefined();\n+      } finally {\n+        // Restore console mocks\n+        logSpy.mockRestore();\n+        errorSpy.mockRestore();\n+      }\n+    });\n+  });\n+\n+  describe(\"Error Handling\", () => {\n+    it(\"should handle undefined environment bindings gracefully\", async () => {\n+      const undefinedEnv = {} as Env;\n+\n+      await expect(async () => {\n+        await getAgentByName(undefinedEnv.TEST_AGENT, \"test\");\n+      }).rejects.toThrow();\n+    });\n+  });\n+\n+  describe(\"Integration Scenarios\", () => {\n+    it(\"should handle concurrent agent creation\", async () => {\n+      const promises = Array(5)\n+        .fill(null)\n+        .map((_, i) => getAgentByName(env.TEST_AGENT, `concurrent-agent-${i}`));\n+\n+      const agents = await Promise.all(promises);\n+\n+      expect(agents).toHaveLength(5);\n+      agents.forEach((agent) => {\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      });\n+    });\n+\n+    it(\"should handle agent names with various patterns\", async () => {\n+      const patterns = [\n+        \"simple\",\n+        \"with-dash\",\n+        \"with_underscore\",\n+        \"with123numbers\",\n+        \"UPPERCASE\",\n+        \"mixedCase\"\n+      ];\n+\n+      for (const pattern of patterns) {\n+        const agent = await getAgentByName(env.TEST_AGENT, pattern);\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent Direct Testing\", () => {\n+    it(\"should handle WebSocket upgrade\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"ws-test\");\n+\n+      const upgradeResponse = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\",\n+          headers: {\n+            Upgrade: \"websocket\"\n+          }\n+        })\n+      );\n+\n+      expect(upgradeResponse.status).toBe(101);\n+      expect(upgradeResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should handle basic HTTP requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"http-test\");\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\"\n+        })\n+      );\n+\n+      expect(response).toBeDefined();\n+      expect(response.status).toBe(200);\n+    });\n+  });\n+\n+  describe(\"StreamingResponse\", () => {\n+    it(\"should require connection and id parameters\", () => {\n+      expect(StreamingResponse).toBeDefined();\n+      expect(typeof StreamingResponse).toBe(\"function\");\n+    });\n+\n+    it(\"should be used for streaming RPC responses\", () => {\n+      const mockConnection = {\n+        id: \"test-connection-id\",\n+        state: {},\n+        setState: vi.fn(),\n+        server: \"test-server\",\n+        send: vi.fn()\n+      };\n+\n+      const response = new StreamingResponse(\n+        mockConnection as unknown as Connection,\n+        \"test-id\"\n+      );\n+      expect(response).toBeDefined();\n+\n+      response.send({ data: \"chunk1\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: false,\n+          id: \"test-id\",\n+          result: { data: \"chunk1\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      response.end({ data: \"final\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: true,\n+          id: \"test-id\",\n+          result: { data: \"final\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      expect(() => response.send({ data: \"after-end\" })).toThrow(\n+        \"StreamingResponse is already closed\"\n+      );\n+    });\n+  });\n+\n+  describe(\"Agent Class Features\", () => {\n+    it(\"should support callable decorator\", () => {\n+      const metadata = {\n+        description: \"Test method\",\n+        streaming: false\n+      };\n+\n+      const decorator = unstable_callable(metadata);\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle different agent namespaces\", async () => {\n+      const testAgent = await getAgentByName(env.TEST_AGENT, \"test-agent\");\n+      expect(testAgent).toBeDefined();\n+      expect(testAgent.fetch).toBeDefined();\n+\n+      const emailAgent = await getAgentByName(env.EmailAgent, \"email-agent\");\n+      expect(emailAgent).toBeDefined();\n+      expect(emailAgent.fetch).toBeDefined();\n+\n+      const caseSensitiveAgent = await getAgentByName(\n+        env.CaseSensitiveAgent,\n+        \"case-agent\"\n+      );\n+      expect(caseSensitiveAgent).toBeDefined();\n+      expect(caseSensitiveAgent.fetch).toBeDefined();\n+\n+      const notificationAgent = await getAgentByName(\n+        env.UserNotificationAgent,\n+        \"notification-agent\"\n+      );\n+      expect(notificationAgent).toBeDefined();\n+      expect(notificationAgent.fetch).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"getCurrentAgent\", () => {\n+    it(\"should return context when called\", () => {\n+      // getCurrentAgent returns the context object, not just the agent\n+      const context = getCurrentAgent();\n+\n+      if (context) {\n+        expect(context).toHaveProperty(\"agent\");\n+      } else {\n+        expect(context).toBeUndefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Route Pattern Matching\", () => {\n+    it(\"should return null for non-agent paths\", async () => {\n+      const nonAgentPaths = [\n+        \"/other/path\",\n+        \"/api/endpoint\",\n+        \"/\",\n+        \"/agents\",\n+        \"/agents/\"\n+      ];\n+\n+      for (const path of nonAgentPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"GET\"\n+        });\n+\n+        const response = await routeAgentRequest(request, env);\n+        expect(response).toBeNull();\n+      }\n+    });\n+\n+    it(\"should detect valid agent paths\", async () => {\n+      const validPaths = [\n+        \"/agents/TestAgent/instance\",\n+        \"/agents/test-agent/room-123\",\n+        \"/agents/EmailAgent/user@example.com\"\n+      ];\n+\n+      for (const path of validPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        });\n+\n+        const response = await routeAgentRequest(request, env, { cors: true });\n+\n+        expect(response).not.toBeNull();\n+        expect(response!.status).toBe(200);\n+        expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Advanced Integration\", () => {\n+    it(\"should handle kebab-case to CamelCase agent name resolution\", async () => {\n+      const request = new Request(\n+        \"http://localhost/agents/test-agent/my-instance\",\n+        {\n+          method: \"GET\"\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeDefined();\n+      expect(response).not.toBeNull();\n+    });\n+\n+    it(\"should support location hints\", async () => {\n+      const locationHints: DurableObjectLocationHint[] = [\n+        \"wnam\",\n+        \"enam\",\n+        \"weur\",\n+        \"eeur\",\n+        \"apac\"\n+      ];\n+\n+      for (const hint of locationHints) {\n+        const agent = await getAgentByName(env.TEST_AGENT, `location-${hint}`, {\n+          locationHint: hint\n+        });\n+        expect(agent).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent State Management\", () => {\n+    it(\"should persist state between requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-persist-test\");\n+\n+      const setResponse = await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({ count: 5, name: \"test\" })\n+        })\n+      );\n+\n+      expect(setResponse.status).toBe(200);\n+      const setResult = (await setResponse.json()) as { success: boolean };\n+      expect(setResult.success).toBe(true);\n+\n+      const getResponse = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      expect(getResponse.status).toBe(200);\n+      const state = (await getResponse.json()) as {\n+        count: number;\n+        name: string;\n+      };\n+      expect(state.count).toBe(5);\n+      expect(state.name).toBe(\"test\");\n+    });\n+\n+    it(\"should handle complex state updates\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-complex-test\");\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice\" },\n+            settings: { theme: \"dark\", notifications: true }\n+          })\n+        })\n+      );\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice Updated\" },\n+            lastUpdated: Date.now()\n+          })\n+        })\n+      );\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      const state = (await response.json()) as {\n+        user: { id: number; name: string };\n+        settings?: { theme: string; notifications: boolean };\n+        lastUpdated: number;\n+      };\n+      expect(state.user.name).toBe(\"Alice Updated\");\n+      expect(state.lastUpdated).toBeDefined();\n+    });\n+\n+    it(\"should broadcast state updates to connections\", async () => {\n+      const agent = await getAgentByName(\n+        env.TEST_AGENT,\n+        \"state-broadcast-test\"\n+      );\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      const ws = wsResponse.webSocket;\n+      expect(ws).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"RPC System\", () => {\n+    it(\"should support callable methods\", () => {\n+      const decorator = unstable_callable({ description: \"Test method\" });\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle RPC through WebSocket connection\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"rpc-ws-test\");\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      expect(wsResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should verify callable methods are marked correctly\", () => {\n+      class TestRPCAgent extends Agent<Env> {\n+        @unstable_callable()\n+        async callableMethod() {\n+          return \"result\";\n+        }\n+\n+        async nonCallableMethod() {\n+          return \"not callable\";\n+        }\n+      }\n+\n+      expect(TestRPCAgent.prototype.callableMethod).toBeDefined();\n+      expect(TestRPCAgent.prototype.nonCallableMethod).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Scheduling System\", () => {\n+    it(\"should support schedule method\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"schedule-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should handle different schedule types\", () => {\n+      const dateSchedule = new Date(Date.now() + 60000).toISOString();\n+      const delaySchedule = 30; // seconds\n+      const cronSchedule = \"*/5 * * * *\";\n+\n+      expect(typeof dateSchedule).toBe(\"string\");\n+      expect(typeof delaySchedule).toBe(\"number\");\n+      expect(typeof cronSchedule).toBe(\"string\");\n+    });\n+\n+    it(\"should test schedule concepts\", () => {\n+      type Schedule = {\n+        id: string;\n+        callback: string;\n+        time?: number;\n+        cron?: string;\n+        payload?: unknown;\n+      };\n+\n+      const testSchedule: Schedule = {\n+        id: \"test-123\",\n+        callback: \"processTask\",\n+        time: Date.now() + 60000,\n+        payload: { data: \"test\" }\n+      };\n+\n+      expect(testSchedule.id).toBeDefined();\n+      expect(testSchedule.callback).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Queue System\", () => {\n+    it(\"should support queue functionality\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"queue-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should understand queue concepts\", () => {\n+      // Test queue-related types\n+      type QueueItem = {\n+        id: string;\n+        callback: string;\n+        payload: unknown;\n+        retries?: number;\n+      };\n+\n+      const testQueueItem: QueueItem = {\n+        id: \"queue-123\",\n+        callback: \"processData\",\n+        payload: { data: \"test\" },\n+        retries: 0\n+      };\n+\n+      expect(testQueueItem.id).toBeDefined();\n+      expect(testQueueItem.callback).toBe(\"processData\");\n+      expect(testQueueItem.payload).toEqual({ data: \"test\" });",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2212548235",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 363,
        "pr_file": "packages/agents/src/tests/index.test.ts",
        "discussion_id": "2212548235",
        "commented_code": "@@ -0,0 +1,672 @@\n+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+\n+    it(\"should handle custom prefix option\", async () => {\n+      const request = new Request(\n+        \"http://localhost/custom-prefix/TestAgent/test\",\n+        {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env, {\n+        prefix: \"custom-prefix\",\n+        cors: true\n+      });\n+\n+      // Should return CORS response for OPTIONS request\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+    });\n+\n+    it(\"should return null for non-matching paths\", async () => {\n+      const request = new Request(\"http://localhost/api/other/endpoint\", {\n+        method: \"GET\"\n+      });\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeNull();\n+    });\n+  });\n+\n+  describe(\"Utility Functions\", () => {\n+    describe(\"camelCaseToKebabCase\", () => {\n+      it(\"should convert CamelCase to kebab-case\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"EmailAgent\")).toBe(\"email-agent\");\n+        expect(camelCaseToKebabCase(\"MyComplexAgentName\")).toBe(\n+          \"my-complex-agent-name\"\n+        );\n+      });\n+\n+      it(\"should handle already kebab-case strings\", () => {\n+        expect(camelCaseToKebabCase(\"test-agent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"email-agent\")).toBe(\"email-agent\");\n+      });\n+\n+      it(\"should handle single word\", () => {\n+        expect(camelCaseToKebabCase(\"Agent\")).toBe(\"agent\");\n+        expect(camelCaseToKebabCase(\"Test\")).toBe(\"test\");\n+      });\n+\n+      it(\"should handle empty string\", () => {\n+        expect(camelCaseToKebabCase(\"\")).toBe(\"\");\n+      });\n+\n+      it(\"should handle strings with numbers\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent123\")).toBe(\"test-agent123\");\n+        expect(camelCaseToKebabCase(\"Agent2Email\")).toBe(\"agent2-email\");\n+      });\n+    });\n+  });\n+\n+  describe(\"Agent with different namespaces\", () => {\n+    it(\"should handle MCP agents\", async () => {\n+      const id = env.MCP_OBJECT.idFromName(\"test-mcp\");\n+      const agent = env.MCP_OBJECT.get(id);\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle multiple agent types\", async () => {\n+      // Mock console to prevent queueMicrotask errors\n+      const logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n+      const errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n+\n+      try {\n+        const testAgent = await getAgentByName(env.TEST_AGENT, \"test1\");\n+        const emailAgent = await getAgentByName(env.EmailAgent, \"test2\");\n+\n+        expect(testAgent).toBeDefined();\n+        expect(emailAgent).toBeDefined();\n+\n+        // Each agent type has its own namespace\n+        expect(testAgent.fetch).toBeDefined();\n+        expect(emailAgent.fetch).toBeDefined();\n+      } finally {\n+        // Restore console mocks\n+        logSpy.mockRestore();\n+        errorSpy.mockRestore();\n+      }\n+    });\n+  });\n+\n+  describe(\"Error Handling\", () => {\n+    it(\"should handle undefined environment bindings gracefully\", async () => {\n+      const undefinedEnv = {} as Env;\n+\n+      await expect(async () => {\n+        await getAgentByName(undefinedEnv.TEST_AGENT, \"test\");\n+      }).rejects.toThrow();\n+    });\n+  });\n+\n+  describe(\"Integration Scenarios\", () => {\n+    it(\"should handle concurrent agent creation\", async () => {\n+      const promises = Array(5)\n+        .fill(null)\n+        .map((_, i) => getAgentByName(env.TEST_AGENT, `concurrent-agent-${i}`));\n+\n+      const agents = await Promise.all(promises);\n+\n+      expect(agents).toHaveLength(5);\n+      agents.forEach((agent) => {\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      });\n+    });\n+\n+    it(\"should handle agent names with various patterns\", async () => {\n+      const patterns = [\n+        \"simple\",\n+        \"with-dash\",\n+        \"with_underscore\",\n+        \"with123numbers\",\n+        \"UPPERCASE\",\n+        \"mixedCase\"\n+      ];\n+\n+      for (const pattern of patterns) {\n+        const agent = await getAgentByName(env.TEST_AGENT, pattern);\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent Direct Testing\", () => {\n+    it(\"should handle WebSocket upgrade\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"ws-test\");\n+\n+      const upgradeResponse = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\",\n+          headers: {\n+            Upgrade: \"websocket\"\n+          }\n+        })\n+      );\n+\n+      expect(upgradeResponse.status).toBe(101);\n+      expect(upgradeResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should handle basic HTTP requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"http-test\");\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\"\n+        })\n+      );\n+\n+      expect(response).toBeDefined();\n+      expect(response.status).toBe(200);\n+    });\n+  });\n+\n+  describe(\"StreamingResponse\", () => {\n+    it(\"should require connection and id parameters\", () => {\n+      expect(StreamingResponse).toBeDefined();\n+      expect(typeof StreamingResponse).toBe(\"function\");\n+    });\n+\n+    it(\"should be used for streaming RPC responses\", () => {\n+      const mockConnection = {\n+        id: \"test-connection-id\",\n+        state: {},\n+        setState: vi.fn(),\n+        server: \"test-server\",\n+        send: vi.fn()\n+      };\n+\n+      const response = new StreamingResponse(\n+        mockConnection as unknown as Connection,\n+        \"test-id\"\n+      );\n+      expect(response).toBeDefined();\n+\n+      response.send({ data: \"chunk1\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: false,\n+          id: \"test-id\",\n+          result: { data: \"chunk1\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      response.end({ data: \"final\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: true,\n+          id: \"test-id\",\n+          result: { data: \"final\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      expect(() => response.send({ data: \"after-end\" })).toThrow(\n+        \"StreamingResponse is already closed\"\n+      );\n+    });\n+  });\n+\n+  describe(\"Agent Class Features\", () => {\n+    it(\"should support callable decorator\", () => {\n+      const metadata = {\n+        description: \"Test method\",\n+        streaming: false\n+      };\n+\n+      const decorator = unstable_callable(metadata);\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle different agent namespaces\", async () => {\n+      const testAgent = await getAgentByName(env.TEST_AGENT, \"test-agent\");\n+      expect(testAgent).toBeDefined();\n+      expect(testAgent.fetch).toBeDefined();\n+\n+      const emailAgent = await getAgentByName(env.EmailAgent, \"email-agent\");\n+      expect(emailAgent).toBeDefined();\n+      expect(emailAgent.fetch).toBeDefined();\n+\n+      const caseSensitiveAgent = await getAgentByName(\n+        env.CaseSensitiveAgent,\n+        \"case-agent\"\n+      );\n+      expect(caseSensitiveAgent).toBeDefined();\n+      expect(caseSensitiveAgent.fetch).toBeDefined();\n+\n+      const notificationAgent = await getAgentByName(\n+        env.UserNotificationAgent,\n+        \"notification-agent\"\n+      );\n+      expect(notificationAgent).toBeDefined();\n+      expect(notificationAgent.fetch).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"getCurrentAgent\", () => {\n+    it(\"should return context when called\", () => {\n+      // getCurrentAgent returns the context object, not just the agent\n+      const context = getCurrentAgent();\n+\n+      if (context) {\n+        expect(context).toHaveProperty(\"agent\");\n+      } else {\n+        expect(context).toBeUndefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Route Pattern Matching\", () => {\n+    it(\"should return null for non-agent paths\", async () => {\n+      const nonAgentPaths = [\n+        \"/other/path\",\n+        \"/api/endpoint\",\n+        \"/\",\n+        \"/agents\",\n+        \"/agents/\"\n+      ];\n+\n+      for (const path of nonAgentPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"GET\"\n+        });\n+\n+        const response = await routeAgentRequest(request, env);\n+        expect(response).toBeNull();\n+      }\n+    });\n+\n+    it(\"should detect valid agent paths\", async () => {\n+      const validPaths = [\n+        \"/agents/TestAgent/instance\",\n+        \"/agents/test-agent/room-123\",\n+        \"/agents/EmailAgent/user@example.com\"\n+      ];\n+\n+      for (const path of validPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        });\n+\n+        const response = await routeAgentRequest(request, env, { cors: true });\n+\n+        expect(response).not.toBeNull();\n+        expect(response!.status).toBe(200);\n+        expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Advanced Integration\", () => {\n+    it(\"should handle kebab-case to CamelCase agent name resolution\", async () => {\n+      const request = new Request(\n+        \"http://localhost/agents/test-agent/my-instance\",\n+        {\n+          method: \"GET\"\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeDefined();\n+      expect(response).not.toBeNull();\n+    });\n+\n+    it(\"should support location hints\", async () => {\n+      const locationHints: DurableObjectLocationHint[] = [\n+        \"wnam\",\n+        \"enam\",\n+        \"weur\",\n+        \"eeur\",\n+        \"apac\"\n+      ];\n+\n+      for (const hint of locationHints) {\n+        const agent = await getAgentByName(env.TEST_AGENT, `location-${hint}`, {\n+          locationHint: hint\n+        });\n+        expect(agent).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent State Management\", () => {\n+    it(\"should persist state between requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-persist-test\");\n+\n+      const setResponse = await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({ count: 5, name: \"test\" })\n+        })\n+      );\n+\n+      expect(setResponse.status).toBe(200);\n+      const setResult = (await setResponse.json()) as { success: boolean };\n+      expect(setResult.success).toBe(true);\n+\n+      const getResponse = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      expect(getResponse.status).toBe(200);\n+      const state = (await getResponse.json()) as {\n+        count: number;\n+        name: string;\n+      };\n+      expect(state.count).toBe(5);\n+      expect(state.name).toBe(\"test\");\n+    });\n+\n+    it(\"should handle complex state updates\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-complex-test\");\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice\" },\n+            settings: { theme: \"dark\", notifications: true }\n+          })\n+        })\n+      );\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice Updated\" },\n+            lastUpdated: Date.now()\n+          })\n+        })\n+      );\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      const state = (await response.json()) as {\n+        user: { id: number; name: string };\n+        settings?: { theme: string; notifications: boolean };\n+        lastUpdated: number;\n+      };\n+      expect(state.user.name).toBe(\"Alice Updated\");\n+      expect(state.lastUpdated).toBeDefined();\n+    });\n+\n+    it(\"should broadcast state updates to connections\", async () => {\n+      const agent = await getAgentByName(\n+        env.TEST_AGENT,\n+        \"state-broadcast-test\"\n+      );\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      const ws = wsResponse.webSocket;\n+      expect(ws).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"RPC System\", () => {\n+    it(\"should support callable methods\", () => {\n+      const decorator = unstable_callable({ description: \"Test method\" });\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle RPC through WebSocket connection\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"rpc-ws-test\");\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      expect(wsResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should verify callable methods are marked correctly\", () => {\n+      class TestRPCAgent extends Agent<Env> {\n+        @unstable_callable()\n+        async callableMethod() {\n+          return \"result\";\n+        }\n+\n+        async nonCallableMethod() {\n+          return \"not callable\";\n+        }\n+      }\n+\n+      expect(TestRPCAgent.prototype.callableMethod).toBeDefined();\n+      expect(TestRPCAgent.prototype.nonCallableMethod).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Scheduling System\", () => {\n+    it(\"should support schedule method\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"schedule-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should handle different schedule types\", () => {\n+      const dateSchedule = new Date(Date.now() + 60000).toISOString();\n+      const delaySchedule = 30; // seconds\n+      const cronSchedule = \"*/5 * * * *\";\n+\n+      expect(typeof dateSchedule).toBe(\"string\");\n+      expect(typeof delaySchedule).toBe(\"number\");\n+      expect(typeof cronSchedule).toBe(\"string\");\n+    });\n+\n+    it(\"should test schedule concepts\", () => {\n+      type Schedule = {\n+        id: string;\n+        callback: string;\n+        time?: number;\n+        cron?: string;\n+        payload?: unknown;\n+      };\n+\n+      const testSchedule: Schedule = {\n+        id: \"test-123\",\n+        callback: \"processTask\",\n+        time: Date.now() + 60000,\n+        payload: { data: \"test\" }\n+      };\n+\n+      expect(testSchedule.id).toBeDefined();\n+      expect(testSchedule.callback).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Queue System\", () => {\n+    it(\"should support queue functionality\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"queue-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should understand queue concepts\", () => {\n+      // Test queue-related types\n+      type QueueItem = {\n+        id: string;\n+        callback: string;\n+        payload: unknown;\n+        retries?: number;\n+      };\n+\n+      const testQueueItem: QueueItem = {\n+        id: \"queue-123\",\n+        callback: \"processData\",\n+        payload: { data: \"test\" },\n+        retries: 0\n+      };\n+\n+      expect(testQueueItem.id).toBeDefined();\n+      expect(testQueueItem.callback).toBe(\"processData\");\n+      expect(testQueueItem.payload).toEqual({ data: \"test\" });",
        "comment_created_at": "2025-07-17T07:40:30+00:00",
        "comment_author": "threepointone",
        "comment_body": "add tests for queues",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212549229",
    "pr_number": 363,
    "pr_file": "packages/agents/src/tests/index.test.ts",
    "created_at": "2025-07-17T07:40:54+00:00",
    "commented_code": "+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+\n+    it(\"should handle custom prefix option\", async () => {\n+      const request = new Request(\n+        \"http://localhost/custom-prefix/TestAgent/test\",\n+        {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env, {\n+        prefix: \"custom-prefix\",\n+        cors: true\n+      });\n+\n+      // Should return CORS response for OPTIONS request\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+    });\n+\n+    it(\"should return null for non-matching paths\", async () => {\n+      const request = new Request(\"http://localhost/api/other/endpoint\", {\n+        method: \"GET\"\n+      });\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeNull();\n+    });\n+  });\n+\n+  describe(\"Utility Functions\", () => {\n+    describe(\"camelCaseToKebabCase\", () => {\n+      it(\"should convert CamelCase to kebab-case\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"EmailAgent\")).toBe(\"email-agent\");\n+        expect(camelCaseToKebabCase(\"MyComplexAgentName\")).toBe(\n+          \"my-complex-agent-name\"\n+        );\n+      });\n+\n+      it(\"should handle already kebab-case strings\", () => {\n+        expect(camelCaseToKebabCase(\"test-agent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"email-agent\")).toBe(\"email-agent\");\n+      });\n+\n+      it(\"should handle single word\", () => {\n+        expect(camelCaseToKebabCase(\"Agent\")).toBe(\"agent\");\n+        expect(camelCaseToKebabCase(\"Test\")).toBe(\"test\");\n+      });\n+\n+      it(\"should handle empty string\", () => {\n+        expect(camelCaseToKebabCase(\"\")).toBe(\"\");\n+      });\n+\n+      it(\"should handle strings with numbers\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent123\")).toBe(\"test-agent123\");\n+        expect(camelCaseToKebabCase(\"Agent2Email\")).toBe(\"agent2-email\");\n+      });\n+    });\n+  });\n+\n+  describe(\"Agent with different namespaces\", () => {\n+    it(\"should handle MCP agents\", async () => {\n+      const id = env.MCP_OBJECT.idFromName(\"test-mcp\");\n+      const agent = env.MCP_OBJECT.get(id);\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle multiple agent types\", async () => {\n+      // Mock console to prevent queueMicrotask errors\n+      const logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n+      const errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n+\n+      try {\n+        const testAgent = await getAgentByName(env.TEST_AGENT, \"test1\");\n+        const emailAgent = await getAgentByName(env.EmailAgent, \"test2\");\n+\n+        expect(testAgent).toBeDefined();\n+        expect(emailAgent).toBeDefined();\n+\n+        // Each agent type has its own namespace\n+        expect(testAgent.fetch).toBeDefined();\n+        expect(emailAgent.fetch).toBeDefined();\n+      } finally {\n+        // Restore console mocks\n+        logSpy.mockRestore();\n+        errorSpy.mockRestore();\n+      }\n+    });\n+  });\n+\n+  describe(\"Error Handling\", () => {\n+    it(\"should handle undefined environment bindings gracefully\", async () => {\n+      const undefinedEnv = {} as Env;\n+\n+      await expect(async () => {\n+        await getAgentByName(undefinedEnv.TEST_AGENT, \"test\");\n+      }).rejects.toThrow();\n+    });\n+  });\n+\n+  describe(\"Integration Scenarios\", () => {\n+    it(\"should handle concurrent agent creation\", async () => {\n+      const promises = Array(5)\n+        .fill(null)\n+        .map((_, i) => getAgentByName(env.TEST_AGENT, `concurrent-agent-${i}`));\n+\n+      const agents = await Promise.all(promises);\n+\n+      expect(agents).toHaveLength(5);\n+      agents.forEach((agent) => {\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      });\n+    });\n+\n+    it(\"should handle agent names with various patterns\", async () => {\n+      const patterns = [\n+        \"simple\",\n+        \"with-dash\",\n+        \"with_underscore\",\n+        \"with123numbers\",\n+        \"UPPERCASE\",\n+        \"mixedCase\"\n+      ];\n+\n+      for (const pattern of patterns) {\n+        const agent = await getAgentByName(env.TEST_AGENT, pattern);\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent Direct Testing\", () => {\n+    it(\"should handle WebSocket upgrade\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"ws-test\");\n+\n+      const upgradeResponse = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\",\n+          headers: {\n+            Upgrade: \"websocket\"\n+          }\n+        })\n+      );\n+\n+      expect(upgradeResponse.status).toBe(101);\n+      expect(upgradeResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should handle basic HTTP requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"http-test\");\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\"\n+        })\n+      );\n+\n+      expect(response).toBeDefined();\n+      expect(response.status).toBe(200);\n+    });\n+  });\n+\n+  describe(\"StreamingResponse\", () => {\n+    it(\"should require connection and id parameters\", () => {\n+      expect(StreamingResponse).toBeDefined();\n+      expect(typeof StreamingResponse).toBe(\"function\");\n+    });\n+\n+    it(\"should be used for streaming RPC responses\", () => {\n+      const mockConnection = {\n+        id: \"test-connection-id\",\n+        state: {},\n+        setState: vi.fn(),\n+        server: \"test-server\",\n+        send: vi.fn()\n+      };\n+\n+      const response = new StreamingResponse(\n+        mockConnection as unknown as Connection,\n+        \"test-id\"\n+      );\n+      expect(response).toBeDefined();\n+\n+      response.send({ data: \"chunk1\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: false,\n+          id: \"test-id\",\n+          result: { data: \"chunk1\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      response.end({ data: \"final\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: true,\n+          id: \"test-id\",\n+          result: { data: \"final\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      expect(() => response.send({ data: \"after-end\" })).toThrow(\n+        \"StreamingResponse is already closed\"\n+      );\n+    });\n+  });\n+\n+  describe(\"Agent Class Features\", () => {\n+    it(\"should support callable decorator\", () => {\n+      const metadata = {\n+        description: \"Test method\",\n+        streaming: false\n+      };\n+\n+      const decorator = unstable_callable(metadata);\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle different agent namespaces\", async () => {\n+      const testAgent = await getAgentByName(env.TEST_AGENT, \"test-agent\");\n+      expect(testAgent).toBeDefined();\n+      expect(testAgent.fetch).toBeDefined();\n+\n+      const emailAgent = await getAgentByName(env.EmailAgent, \"email-agent\");\n+      expect(emailAgent).toBeDefined();\n+      expect(emailAgent.fetch).toBeDefined();\n+\n+      const caseSensitiveAgent = await getAgentByName(\n+        env.CaseSensitiveAgent,\n+        \"case-agent\"\n+      );\n+      expect(caseSensitiveAgent).toBeDefined();\n+      expect(caseSensitiveAgent.fetch).toBeDefined();\n+\n+      const notificationAgent = await getAgentByName(\n+        env.UserNotificationAgent,\n+        \"notification-agent\"\n+      );\n+      expect(notificationAgent).toBeDefined();\n+      expect(notificationAgent.fetch).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"getCurrentAgent\", () => {\n+    it(\"should return context when called\", () => {\n+      // getCurrentAgent returns the context object, not just the agent\n+      const context = getCurrentAgent();\n+\n+      if (context) {\n+        expect(context).toHaveProperty(\"agent\");\n+      } else {\n+        expect(context).toBeUndefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Route Pattern Matching\", () => {\n+    it(\"should return null for non-agent paths\", async () => {\n+      const nonAgentPaths = [\n+        \"/other/path\",\n+        \"/api/endpoint\",\n+        \"/\",\n+        \"/agents\",\n+        \"/agents/\"\n+      ];\n+\n+      for (const path of nonAgentPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"GET\"\n+        });\n+\n+        const response = await routeAgentRequest(request, env);\n+        expect(response).toBeNull();\n+      }\n+    });\n+\n+    it(\"should detect valid agent paths\", async () => {\n+      const validPaths = [\n+        \"/agents/TestAgent/instance\",\n+        \"/agents/test-agent/room-123\",\n+        \"/agents/EmailAgent/user@example.com\"\n+      ];\n+\n+      for (const path of validPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        });\n+\n+        const response = await routeAgentRequest(request, env, { cors: true });\n+\n+        expect(response).not.toBeNull();\n+        expect(response!.status).toBe(200);\n+        expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Advanced Integration\", () => {\n+    it(\"should handle kebab-case to CamelCase agent name resolution\", async () => {\n+      const request = new Request(\n+        \"http://localhost/agents/test-agent/my-instance\",\n+        {\n+          method: \"GET\"\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeDefined();\n+      expect(response).not.toBeNull();\n+    });\n+\n+    it(\"should support location hints\", async () => {\n+      const locationHints: DurableObjectLocationHint[] = [\n+        \"wnam\",\n+        \"enam\",\n+        \"weur\",\n+        \"eeur\",\n+        \"apac\"\n+      ];\n+\n+      for (const hint of locationHints) {\n+        const agent = await getAgentByName(env.TEST_AGENT, `location-${hint}`, {\n+          locationHint: hint\n+        });\n+        expect(agent).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent State Management\", () => {\n+    it(\"should persist state between requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-persist-test\");\n+\n+      const setResponse = await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({ count: 5, name: \"test\" })\n+        })\n+      );\n+\n+      expect(setResponse.status).toBe(200);\n+      const setResult = (await setResponse.json()) as { success: boolean };\n+      expect(setResult.success).toBe(true);\n+\n+      const getResponse = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      expect(getResponse.status).toBe(200);\n+      const state = (await getResponse.json()) as {\n+        count: number;\n+        name: string;\n+      };\n+      expect(state.count).toBe(5);\n+      expect(state.name).toBe(\"test\");\n+    });\n+\n+    it(\"should handle complex state updates\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-complex-test\");\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice\" },\n+            settings: { theme: \"dark\", notifications: true }\n+          })\n+        })\n+      );\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice Updated\" },\n+            lastUpdated: Date.now()\n+          })\n+        })\n+      );\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      const state = (await response.json()) as {\n+        user: { id: number; name: string };\n+        settings?: { theme: string; notifications: boolean };\n+        lastUpdated: number;\n+      };\n+      expect(state.user.name).toBe(\"Alice Updated\");\n+      expect(state.lastUpdated).toBeDefined();\n+    });\n+\n+    it(\"should broadcast state updates to connections\", async () => {\n+      const agent = await getAgentByName(\n+        env.TEST_AGENT,\n+        \"state-broadcast-test\"\n+      );\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      const ws = wsResponse.webSocket;\n+      expect(ws).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"RPC System\", () => {\n+    it(\"should support callable methods\", () => {\n+      const decorator = unstable_callable({ description: \"Test method\" });\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle RPC through WebSocket connection\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"rpc-ws-test\");\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      expect(wsResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should verify callable methods are marked correctly\", () => {\n+      class TestRPCAgent extends Agent<Env> {\n+        @unstable_callable()\n+        async callableMethod() {\n+          return \"result\";\n+        }\n+\n+        async nonCallableMethod() {\n+          return \"not callable\";\n+        }\n+      }\n+\n+      expect(TestRPCAgent.prototype.callableMethod).toBeDefined();\n+      expect(TestRPCAgent.prototype.nonCallableMethod).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Scheduling System\", () => {\n+    it(\"should support schedule method\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"schedule-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should handle different schedule types\", () => {\n+      const dateSchedule = new Date(Date.now() + 60000).toISOString();\n+      const delaySchedule = 30; // seconds\n+      const cronSchedule = \"*/5 * * * *\";\n+\n+      expect(typeof dateSchedule).toBe(\"string\");\n+      expect(typeof delaySchedule).toBe(\"number\");\n+      expect(typeof cronSchedule).toBe(\"string\");\n+    });\n+\n+    it(\"should test schedule concepts\", () => {\n+      type Schedule = {\n+        id: string;\n+        callback: string;\n+        time?: number;\n+        cron?: string;\n+        payload?: unknown;\n+      };\n+\n+      const testSchedule: Schedule = {\n+        id: \"test-123\",\n+        callback: \"processTask\",\n+        time: Date.now() + 60000,\n+        payload: { data: \"test\" }\n+      };\n+\n+      expect(testSchedule.id).toBeDefined();\n+      expect(testSchedule.callback).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Queue System\", () => {\n+    it(\"should support queue functionality\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"queue-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should understand queue concepts\", () => {\n+      // Test queue-related types\n+      type QueueItem = {\n+        id: string;\n+        callback: string;\n+        payload: unknown;\n+        retries?: number;\n+      };\n+\n+      const testQueueItem: QueueItem = {\n+        id: \"queue-123\",\n+        callback: \"processData\",\n+        payload: { data: \"test\" },\n+        retries: 0\n+      };\n+\n+      expect(testQueueItem.id).toBeDefined();\n+      expect(testQueueItem.callback).toBe(\"processData\");\n+      expect(testQueueItem.payload).toEqual({ data: \"test\" });\n+    });\n+  });\n+\n+  describe(\"SQL Storage\", () => {\n+    it(\"should use SQL for state persistence\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"sql-state-test\");\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            sqlTest: true,\n+            timestamp: Date.now()\n+          })\n+        })\n+      );\n+\n+      // State is persisted in SQL storage\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      const state = (await response.json()) as {\n+        sqlTest: boolean;\n+        timestamp: number;\n+      };\n+      expect(state.sqlTest).toBe(true);\n+      expect(state.timestamp).toBeDefined();",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2212549229",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 363,
        "pr_file": "packages/agents/src/tests/index.test.ts",
        "discussion_id": "2212549229",
        "commented_code": "@@ -0,0 +1,672 @@\n+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+\n+    it(\"should handle custom prefix option\", async () => {\n+      const request = new Request(\n+        \"http://localhost/custom-prefix/TestAgent/test\",\n+        {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env, {\n+        prefix: \"custom-prefix\",\n+        cors: true\n+      });\n+\n+      // Should return CORS response for OPTIONS request\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+    });\n+\n+    it(\"should return null for non-matching paths\", async () => {\n+      const request = new Request(\"http://localhost/api/other/endpoint\", {\n+        method: \"GET\"\n+      });\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeNull();\n+    });\n+  });\n+\n+  describe(\"Utility Functions\", () => {\n+    describe(\"camelCaseToKebabCase\", () => {\n+      it(\"should convert CamelCase to kebab-case\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"EmailAgent\")).toBe(\"email-agent\");\n+        expect(camelCaseToKebabCase(\"MyComplexAgentName\")).toBe(\n+          \"my-complex-agent-name\"\n+        );\n+      });\n+\n+      it(\"should handle already kebab-case strings\", () => {\n+        expect(camelCaseToKebabCase(\"test-agent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"email-agent\")).toBe(\"email-agent\");\n+      });\n+\n+      it(\"should handle single word\", () => {\n+        expect(camelCaseToKebabCase(\"Agent\")).toBe(\"agent\");\n+        expect(camelCaseToKebabCase(\"Test\")).toBe(\"test\");\n+      });\n+\n+      it(\"should handle empty string\", () => {\n+        expect(camelCaseToKebabCase(\"\")).toBe(\"\");\n+      });\n+\n+      it(\"should handle strings with numbers\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent123\")).toBe(\"test-agent123\");\n+        expect(camelCaseToKebabCase(\"Agent2Email\")).toBe(\"agent2-email\");\n+      });\n+    });\n+  });\n+\n+  describe(\"Agent with different namespaces\", () => {\n+    it(\"should handle MCP agents\", async () => {\n+      const id = env.MCP_OBJECT.idFromName(\"test-mcp\");\n+      const agent = env.MCP_OBJECT.get(id);\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle multiple agent types\", async () => {\n+      // Mock console to prevent queueMicrotask errors\n+      const logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n+      const errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n+\n+      try {\n+        const testAgent = await getAgentByName(env.TEST_AGENT, \"test1\");\n+        const emailAgent = await getAgentByName(env.EmailAgent, \"test2\");\n+\n+        expect(testAgent).toBeDefined();\n+        expect(emailAgent).toBeDefined();\n+\n+        // Each agent type has its own namespace\n+        expect(testAgent.fetch).toBeDefined();\n+        expect(emailAgent.fetch).toBeDefined();\n+      } finally {\n+        // Restore console mocks\n+        logSpy.mockRestore();\n+        errorSpy.mockRestore();\n+      }\n+    });\n+  });\n+\n+  describe(\"Error Handling\", () => {\n+    it(\"should handle undefined environment bindings gracefully\", async () => {\n+      const undefinedEnv = {} as Env;\n+\n+      await expect(async () => {\n+        await getAgentByName(undefinedEnv.TEST_AGENT, \"test\");\n+      }).rejects.toThrow();\n+    });\n+  });\n+\n+  describe(\"Integration Scenarios\", () => {\n+    it(\"should handle concurrent agent creation\", async () => {\n+      const promises = Array(5)\n+        .fill(null)\n+        .map((_, i) => getAgentByName(env.TEST_AGENT, `concurrent-agent-${i}`));\n+\n+      const agents = await Promise.all(promises);\n+\n+      expect(agents).toHaveLength(5);\n+      agents.forEach((agent) => {\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      });\n+    });\n+\n+    it(\"should handle agent names with various patterns\", async () => {\n+      const patterns = [\n+        \"simple\",\n+        \"with-dash\",\n+        \"with_underscore\",\n+        \"with123numbers\",\n+        \"UPPERCASE\",\n+        \"mixedCase\"\n+      ];\n+\n+      for (const pattern of patterns) {\n+        const agent = await getAgentByName(env.TEST_AGENT, pattern);\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent Direct Testing\", () => {\n+    it(\"should handle WebSocket upgrade\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"ws-test\");\n+\n+      const upgradeResponse = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\",\n+          headers: {\n+            Upgrade: \"websocket\"\n+          }\n+        })\n+      );\n+\n+      expect(upgradeResponse.status).toBe(101);\n+      expect(upgradeResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should handle basic HTTP requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"http-test\");\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\"\n+        })\n+      );\n+\n+      expect(response).toBeDefined();\n+      expect(response.status).toBe(200);\n+    });\n+  });\n+\n+  describe(\"StreamingResponse\", () => {\n+    it(\"should require connection and id parameters\", () => {\n+      expect(StreamingResponse).toBeDefined();\n+      expect(typeof StreamingResponse).toBe(\"function\");\n+    });\n+\n+    it(\"should be used for streaming RPC responses\", () => {\n+      const mockConnection = {\n+        id: \"test-connection-id\",\n+        state: {},\n+        setState: vi.fn(),\n+        server: \"test-server\",\n+        send: vi.fn()\n+      };\n+\n+      const response = new StreamingResponse(\n+        mockConnection as unknown as Connection,\n+        \"test-id\"\n+      );\n+      expect(response).toBeDefined();\n+\n+      response.send({ data: \"chunk1\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: false,\n+          id: \"test-id\",\n+          result: { data: \"chunk1\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      response.end({ data: \"final\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: true,\n+          id: \"test-id\",\n+          result: { data: \"final\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      expect(() => response.send({ data: \"after-end\" })).toThrow(\n+        \"StreamingResponse is already closed\"\n+      );\n+    });\n+  });\n+\n+  describe(\"Agent Class Features\", () => {\n+    it(\"should support callable decorator\", () => {\n+      const metadata = {\n+        description: \"Test method\",\n+        streaming: false\n+      };\n+\n+      const decorator = unstable_callable(metadata);\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle different agent namespaces\", async () => {\n+      const testAgent = await getAgentByName(env.TEST_AGENT, \"test-agent\");\n+      expect(testAgent).toBeDefined();\n+      expect(testAgent.fetch).toBeDefined();\n+\n+      const emailAgent = await getAgentByName(env.EmailAgent, \"email-agent\");\n+      expect(emailAgent).toBeDefined();\n+      expect(emailAgent.fetch).toBeDefined();\n+\n+      const caseSensitiveAgent = await getAgentByName(\n+        env.CaseSensitiveAgent,\n+        \"case-agent\"\n+      );\n+      expect(caseSensitiveAgent).toBeDefined();\n+      expect(caseSensitiveAgent.fetch).toBeDefined();\n+\n+      const notificationAgent = await getAgentByName(\n+        env.UserNotificationAgent,\n+        \"notification-agent\"\n+      );\n+      expect(notificationAgent).toBeDefined();\n+      expect(notificationAgent.fetch).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"getCurrentAgent\", () => {\n+    it(\"should return context when called\", () => {\n+      // getCurrentAgent returns the context object, not just the agent\n+      const context = getCurrentAgent();\n+\n+      if (context) {\n+        expect(context).toHaveProperty(\"agent\");\n+      } else {\n+        expect(context).toBeUndefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Route Pattern Matching\", () => {\n+    it(\"should return null for non-agent paths\", async () => {\n+      const nonAgentPaths = [\n+        \"/other/path\",\n+        \"/api/endpoint\",\n+        \"/\",\n+        \"/agents\",\n+        \"/agents/\"\n+      ];\n+\n+      for (const path of nonAgentPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"GET\"\n+        });\n+\n+        const response = await routeAgentRequest(request, env);\n+        expect(response).toBeNull();\n+      }\n+    });\n+\n+    it(\"should detect valid agent paths\", async () => {\n+      const validPaths = [\n+        \"/agents/TestAgent/instance\",\n+        \"/agents/test-agent/room-123\",\n+        \"/agents/EmailAgent/user@example.com\"\n+      ];\n+\n+      for (const path of validPaths) {\n+        const request = new Request(`http://localhost${path}`, {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        });\n+\n+        const response = await routeAgentRequest(request, env, { cors: true });\n+\n+        expect(response).not.toBeNull();\n+        expect(response!.status).toBe(200);\n+        expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Advanced Integration\", () => {\n+    it(\"should handle kebab-case to CamelCase agent name resolution\", async () => {\n+      const request = new Request(\n+        \"http://localhost/agents/test-agent/my-instance\",\n+        {\n+          method: \"GET\"\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeDefined();\n+      expect(response).not.toBeNull();\n+    });\n+\n+    it(\"should support location hints\", async () => {\n+      const locationHints: DurableObjectLocationHint[] = [\n+        \"wnam\",\n+        \"enam\",\n+        \"weur\",\n+        \"eeur\",\n+        \"apac\"\n+      ];\n+\n+      for (const hint of locationHints) {\n+        const agent = await getAgentByName(env.TEST_AGENT, `location-${hint}`, {\n+          locationHint: hint\n+        });\n+        expect(agent).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent State Management\", () => {\n+    it(\"should persist state between requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-persist-test\");\n+\n+      const setResponse = await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({ count: 5, name: \"test\" })\n+        })\n+      );\n+\n+      expect(setResponse.status).toBe(200);\n+      const setResult = (await setResponse.json()) as { success: boolean };\n+      expect(setResult.success).toBe(true);\n+\n+      const getResponse = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      expect(getResponse.status).toBe(200);\n+      const state = (await getResponse.json()) as {\n+        count: number;\n+        name: string;\n+      };\n+      expect(state.count).toBe(5);\n+      expect(state.name).toBe(\"test\");\n+    });\n+\n+    it(\"should handle complex state updates\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"state-complex-test\");\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice\" },\n+            settings: { theme: \"dark\", notifications: true }\n+          })\n+        })\n+      );\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            user: { id: 1, name: \"Alice Updated\" },\n+            lastUpdated: Date.now()\n+          })\n+        })\n+      );\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      const state = (await response.json()) as {\n+        user: { id: number; name: string };\n+        settings?: { theme: string; notifications: boolean };\n+        lastUpdated: number;\n+      };\n+      expect(state.user.name).toBe(\"Alice Updated\");\n+      expect(state.lastUpdated).toBeDefined();\n+    });\n+\n+    it(\"should broadcast state updates to connections\", async () => {\n+      const agent = await getAgentByName(\n+        env.TEST_AGENT,\n+        \"state-broadcast-test\"\n+      );\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      const ws = wsResponse.webSocket;\n+      expect(ws).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"RPC System\", () => {\n+    it(\"should support callable methods\", () => {\n+      const decorator = unstable_callable({ description: \"Test method\" });\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle RPC through WebSocket connection\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"rpc-ws-test\");\n+\n+      const wsResponse = await agent.fetch(\n+        new Request(\"http://localhost/\", {\n+          method: \"GET\",\n+          headers: { Upgrade: \"websocket\" }\n+        })\n+      );\n+\n+      expect(wsResponse.status).toBe(101);\n+      expect(wsResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should verify callable methods are marked correctly\", () => {\n+      class TestRPCAgent extends Agent<Env> {\n+        @unstable_callable()\n+        async callableMethod() {\n+          return \"result\";\n+        }\n+\n+        async nonCallableMethod() {\n+          return \"not callable\";\n+        }\n+      }\n+\n+      expect(TestRPCAgent.prototype.callableMethod).toBeDefined();\n+      expect(TestRPCAgent.prototype.nonCallableMethod).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Scheduling System\", () => {\n+    it(\"should support schedule method\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"schedule-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should handle different schedule types\", () => {\n+      const dateSchedule = new Date(Date.now() + 60000).toISOString();\n+      const delaySchedule = 30; // seconds\n+      const cronSchedule = \"*/5 * * * *\";\n+\n+      expect(typeof dateSchedule).toBe(\"string\");\n+      expect(typeof delaySchedule).toBe(\"number\");\n+      expect(typeof cronSchedule).toBe(\"string\");\n+    });\n+\n+    it(\"should test schedule concepts\", () => {\n+      type Schedule = {\n+        id: string;\n+        callback: string;\n+        time?: number;\n+        cron?: string;\n+        payload?: unknown;\n+      };\n+\n+      const testSchedule: Schedule = {\n+        id: \"test-123\",\n+        callback: \"processTask\",\n+        time: Date.now() + 60000,\n+        payload: { data: \"test\" }\n+      };\n+\n+      expect(testSchedule.id).toBeDefined();\n+      expect(testSchedule.callback).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"Queue System\", () => {\n+    it(\"should support queue functionality\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"queue-test\");\n+\n+      expect(agent).toBeDefined();\n+    });\n+\n+    it(\"should understand queue concepts\", () => {\n+      // Test queue-related types\n+      type QueueItem = {\n+        id: string;\n+        callback: string;\n+        payload: unknown;\n+        retries?: number;\n+      };\n+\n+      const testQueueItem: QueueItem = {\n+        id: \"queue-123\",\n+        callback: \"processData\",\n+        payload: { data: \"test\" },\n+        retries: 0\n+      };\n+\n+      expect(testQueueItem.id).toBeDefined();\n+      expect(testQueueItem.callback).toBe(\"processData\");\n+      expect(testQueueItem.payload).toEqual({ data: \"test\" });\n+    });\n+  });\n+\n+  describe(\"SQL Storage\", () => {\n+    it(\"should use SQL for state persistence\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"sql-state-test\");\n+\n+      await agent.fetch(\n+        new Request(\"http://localhost/setState\", {\n+          method: \"POST\",\n+          headers: { \"Content-Type\": \"application/json\" },\n+          body: JSON.stringify({\n+            sqlTest: true,\n+            timestamp: Date.now()\n+          })\n+        })\n+      );\n+\n+      // State is persisted in SQL storage\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/getState\")\n+      );\n+      const state = (await response.json()) as {\n+        sqlTest: boolean;\n+        timestamp: number;\n+      };\n+      expect(state.sqlTest).toBe(true);\n+      expect(state.timestamp).toBeDefined();",
        "comment_created_at": "2025-07-17T07:40:54+00:00",
        "comment_author": "threepointone",
        "comment_body": "add tests for actual sql calls ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212558255",
    "pr_number": 363,
    "pr_file": "packages/agents/src/tests/client.test.ts",
    "created_at": "2025-07-17T07:43:35+00:00",
    "commented_code": "+import { expect, describe, it, vi, beforeEach, afterEach } from \"vitest\";\n+import { AgentClient, agentFetch, camelCaseToKebabCase } from \"../client.ts\";\n+\n+class MockWebSocket {\n+  url: string;\n+  readyState = 0; // CONNECTING\n+  onopen?: (event: Event) => void;\n+  onmessage?: (event: MessageEvent) => void;\n+  onclose?: (event: CloseEvent) => void;\n+  onerror?: (event: Event) => void;\n+\n+  constructor(url: string) {\n+    this.url = url;\n+    setTimeout(() => {\n+      this.readyState = 1; // OPEN\n+      this.onopen?.(new Event(\"open\"));\n+    }, 0);\n+  }\n+\n+  send(_data: string) {}\n+\n+  close() {\n+    this.readyState = 3; // CLOSED\n+    this.onclose?.(new CloseEvent(\"close\"));\n+  }\n+}\n+\n+vi.mock(\"partysocket\", () => ({\n+  PartySocket: class MockPartySocket extends EventTarget {\n+    ws?: MockWebSocket;\n+    _options: Record<string, unknown>;\n+\n+    constructor(options: Record<string, unknown>) {\n+      super();\n+      this._options = options;\n+\n+      this.ws = new MockWebSocket(\n+        `ws://localhost/agents/${options.party}/${options.room}`\n+      );\n+    }\n+\n+    send(data: string) {\n+      this.ws?.send(data);\n+    }\n+\n+    static fetch(_opts: Record<string, unknown>, _init?: RequestInit) {\n+      return Promise.resolve(new Response(\"OK\", { status: 200 }));\n+    }\n+  }\n+}));\n+\n+describe(\"AgentClient\", () => {\n+  describe(\"Connection\", () => {\n+    it(\"should be able to connect to an agent with defaults\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\"); // Should convert to kebab-case\n+      expect(client.name).toBe(\"default\");\n+    });\n+\n+    it(\"should be able to connect to an agent with options\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        name: \"my-instance\",\n+        host: \"custom.host.com\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\");\n+      expect(client.name).toBe(\"my-instance\");\n+    });\n+\n+    it(\"should handle different agent name formats\", () => {\n+      const testCases = [\n+        { input: \"TestAgent\", expected: \"test-agent\" },\n+        { input: \"test-agent\", expected: \"test-agent\" },\n+        { input: \"TEST_AGENT\", expected: \"test-agent\" },\n+        { input: \"testAgent\", expected: \"test-agent\" }\n+      ];\n+\n+      testCases.forEach(({ input, expected }) => {\n+        const client = new AgentClient({\n+          agent: input,\n+          host: \"localhost:1999\"\n+        });\n+        expect(client.agent).toBe(expected);\n+      });\n+    });\n+  });\n+\n+  describe(\"State Management\", () => {\n+    it(\"should sync state from client to server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+      const newState = { count: 5, name: \"test\" };\n+\n+      client.setState(newState);\n+\n+      expect(sendSpy).toHaveBeenCalledWith(\n+        JSON.stringify({ state: newState, type: \"cf_agent_state\" })\n+      );\n+      expect(onStateUpdate).toHaveBeenCalledWith(newState, \"client\");\n+    });\n+\n+    it(\"should receive state updates from server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      // Simulate server state update\n+      const serverState = { count: 10, serverData: true };\n+      const event = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"cf_agent_state\",\n+          state: serverState\n+        })\n+      });\n+\n+      client.dispatchEvent(event);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(serverState, \"server\");\n+    });\n+\n+    it(\"should handle complex state objects\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient<{\n+        user: { id: number; name: string };\n+        settings: { theme: string };\n+      }>({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const complexState = {\n+        user: { id: 1, name: \"Alice\" },\n+        settings: { theme: \"dark\" }\n+      };\n+\n+      client.setState(complexState);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(complexState, \"client\");\n+    });\n+  });",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2212558255",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 363,
        "pr_file": "packages/agents/src/tests/client.test.ts",
        "discussion_id": "2212558255",
        "commented_code": "@@ -0,0 +1,540 @@\n+import { expect, describe, it, vi, beforeEach, afterEach } from \"vitest\";\n+import { AgentClient, agentFetch, camelCaseToKebabCase } from \"../client.ts\";\n+\n+class MockWebSocket {\n+  url: string;\n+  readyState = 0; // CONNECTING\n+  onopen?: (event: Event) => void;\n+  onmessage?: (event: MessageEvent) => void;\n+  onclose?: (event: CloseEvent) => void;\n+  onerror?: (event: Event) => void;\n+\n+  constructor(url: string) {\n+    this.url = url;\n+    setTimeout(() => {\n+      this.readyState = 1; // OPEN\n+      this.onopen?.(new Event(\"open\"));\n+    }, 0);\n+  }\n+\n+  send(_data: string) {}\n+\n+  close() {\n+    this.readyState = 3; // CLOSED\n+    this.onclose?.(new CloseEvent(\"close\"));\n+  }\n+}\n+\n+vi.mock(\"partysocket\", () => ({\n+  PartySocket: class MockPartySocket extends EventTarget {\n+    ws?: MockWebSocket;\n+    _options: Record<string, unknown>;\n+\n+    constructor(options: Record<string, unknown>) {\n+      super();\n+      this._options = options;\n+\n+      this.ws = new MockWebSocket(\n+        `ws://localhost/agents/${options.party}/${options.room}`\n+      );\n+    }\n+\n+    send(data: string) {\n+      this.ws?.send(data);\n+    }\n+\n+    static fetch(_opts: Record<string, unknown>, _init?: RequestInit) {\n+      return Promise.resolve(new Response(\"OK\", { status: 200 }));\n+    }\n+  }\n+}));\n+\n+describe(\"AgentClient\", () => {\n+  describe(\"Connection\", () => {\n+    it(\"should be able to connect to an agent with defaults\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\"); // Should convert to kebab-case\n+      expect(client.name).toBe(\"default\");\n+    });\n+\n+    it(\"should be able to connect to an agent with options\", () => {\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        name: \"my-instance\",\n+        host: \"custom.host.com\"\n+      });\n+\n+      expect(client).toBeDefined();\n+      expect(client.agent).toBe(\"test-agent\");\n+      expect(client.name).toBe(\"my-instance\");\n+    });\n+\n+    it(\"should handle different agent name formats\", () => {\n+      const testCases = [\n+        { input: \"TestAgent\", expected: \"test-agent\" },\n+        { input: \"test-agent\", expected: \"test-agent\" },\n+        { input: \"TEST_AGENT\", expected: \"test-agent\" },\n+        { input: \"testAgent\", expected: \"test-agent\" }\n+      ];\n+\n+      testCases.forEach(({ input, expected }) => {\n+        const client = new AgentClient({\n+          agent: input,\n+          host: \"localhost:1999\"\n+        });\n+        expect(client.agent).toBe(expected);\n+      });\n+    });\n+  });\n+\n+  describe(\"State Management\", () => {\n+    it(\"should sync state from client to server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const sendSpy = vi.spyOn(client, \"send\");\n+      const newState = { count: 5, name: \"test\" };\n+\n+      client.setState(newState);\n+\n+      expect(sendSpy).toHaveBeenCalledWith(\n+        JSON.stringify({ state: newState, type: \"cf_agent_state\" })\n+      );\n+      expect(onStateUpdate).toHaveBeenCalledWith(newState, \"client\");\n+    });\n+\n+    it(\"should receive state updates from server\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      // Simulate server state update\n+      const serverState = { count: 10, serverData: true };\n+      const event = new MessageEvent(\"message\", {\n+        data: JSON.stringify({\n+          type: \"cf_agent_state\",\n+          state: serverState\n+        })\n+      });\n+\n+      client.dispatchEvent(event);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(serverState, \"server\");\n+    });\n+\n+    it(\"should handle complex state objects\", () => {\n+      const onStateUpdate = vi.fn();\n+      const client = new AgentClient<{\n+        user: { id: number; name: string };\n+        settings: { theme: string };\n+      }>({\n+        agent: \"TestAgent\",\n+        host: \"localhost:1999\",\n+        onStateUpdate\n+      });\n+\n+      const complexState = {\n+        user: { id: 1, name: \"Alice\" },\n+        settings: { theme: \"dark\" }\n+      };\n+\n+      client.setState(complexState);\n+\n+      expect(onStateUpdate).toHaveBeenCalledWith(complexState, \"client\");\n+    });\n+  });",
        "comment_created_at": "2025-07-17T07:43:35+00:00",
        "comment_author": "threepointone",
        "comment_body": "we should have a test here with 2 clients connected to the same agent, and sending a state update on one should trigger onStateUpdate on the other ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212583476",
    "pr_number": 363,
    "pr_file": "packages/agents/src/tests/index.test.ts",
    "created_at": "2025-07-17T07:52:22+00:00",
    "commented_code": "+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+\n+    it(\"should handle custom prefix option\", async () => {\n+      const request = new Request(\n+        \"http://localhost/custom-prefix/TestAgent/test\",\n+        {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env, {\n+        prefix: \"custom-prefix\",\n+        cors: true\n+      });\n+\n+      // Should return CORS response for OPTIONS request\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+    });\n+\n+    it(\"should return null for non-matching paths\", async () => {\n+      const request = new Request(\"http://localhost/api/other/endpoint\", {\n+        method: \"GET\"\n+      });\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeNull();\n+    });\n+  });\n+\n+  describe(\"Utility Functions\", () => {\n+    describe(\"camelCaseToKebabCase\", () => {\n+      it(\"should convert CamelCase to kebab-case\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"EmailAgent\")).toBe(\"email-agent\");\n+        expect(camelCaseToKebabCase(\"MyComplexAgentName\")).toBe(\n+          \"my-complex-agent-name\"\n+        );\n+      });\n+\n+      it(\"should handle already kebab-case strings\", () => {\n+        expect(camelCaseToKebabCase(\"test-agent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"email-agent\")).toBe(\"email-agent\");\n+      });\n+\n+      it(\"should handle single word\", () => {\n+        expect(camelCaseToKebabCase(\"Agent\")).toBe(\"agent\");\n+        expect(camelCaseToKebabCase(\"Test\")).toBe(\"test\");\n+      });\n+\n+      it(\"should handle empty string\", () => {\n+        expect(camelCaseToKebabCase(\"\")).toBe(\"\");\n+      });\n+\n+      it(\"should handle strings with numbers\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent123\")).toBe(\"test-agent123\");\n+        expect(camelCaseToKebabCase(\"Agent2Email\")).toBe(\"agent2-email\");\n+      });\n+    });\n+  });\n+\n+  describe(\"Agent with different namespaces\", () => {\n+    it(\"should handle MCP agents\", async () => {\n+      const id = env.MCP_OBJECT.idFromName(\"test-mcp\");\n+      const agent = env.MCP_OBJECT.get(id);\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle multiple agent types\", async () => {\n+      // Mock console to prevent queueMicrotask errors\n+      const logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n+      const errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n+\n+      try {\n+        const testAgent = await getAgentByName(env.TEST_AGENT, \"test1\");\n+        const emailAgent = await getAgentByName(env.EmailAgent, \"test2\");\n+\n+        expect(testAgent).toBeDefined();\n+        expect(emailAgent).toBeDefined();\n+\n+        // Each agent type has its own namespace\n+        expect(testAgent.fetch).toBeDefined();\n+        expect(emailAgent.fetch).toBeDefined();\n+      } finally {\n+        // Restore console mocks\n+        logSpy.mockRestore();\n+        errorSpy.mockRestore();\n+      }\n+    });\n+  });\n+\n+  describe(\"Error Handling\", () => {\n+    it(\"should handle undefined environment bindings gracefully\", async () => {\n+      const undefinedEnv = {} as Env;\n+\n+      await expect(async () => {\n+        await getAgentByName(undefinedEnv.TEST_AGENT, \"test\");\n+      }).rejects.toThrow();\n+    });\n+  });\n+\n+  describe(\"Integration Scenarios\", () => {\n+    it(\"should handle concurrent agent creation\", async () => {\n+      const promises = Array(5)\n+        .fill(null)\n+        .map((_, i) => getAgentByName(env.TEST_AGENT, `concurrent-agent-${i}`));\n+\n+      const agents = await Promise.all(promises);\n+\n+      expect(agents).toHaveLength(5);\n+      agents.forEach((agent) => {\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      });\n+    });\n+\n+    it(\"should handle agent names with various patterns\", async () => {\n+      const patterns = [\n+        \"simple\",\n+        \"with-dash\",\n+        \"with_underscore\",\n+        \"with123numbers\",\n+        \"UPPERCASE\",\n+        \"mixedCase\"\n+      ];\n+\n+      for (const pattern of patterns) {\n+        const agent = await getAgentByName(env.TEST_AGENT, pattern);\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent Direct Testing\", () => {\n+    it(\"should handle WebSocket upgrade\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"ws-test\");\n+\n+      const upgradeResponse = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\",\n+          headers: {\n+            Upgrade: \"websocket\"\n+          }\n+        })\n+      );\n+\n+      expect(upgradeResponse.status).toBe(101);\n+      expect(upgradeResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should handle basic HTTP requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"http-test\");\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\"\n+        })\n+      );\n+\n+      expect(response).toBeDefined();\n+      expect(response.status).toBe(200);\n+    });\n+  });\n+\n+  describe(\"StreamingResponse\", () => {\n+    it(\"should require connection and id parameters\", () => {\n+      expect(StreamingResponse).toBeDefined();\n+      expect(typeof StreamingResponse).toBe(\"function\");\n+    });\n+\n+    it(\"should be used for streaming RPC responses\", () => {\n+      const mockConnection = {\n+        id: \"test-connection-id\",\n+        state: {},\n+        setState: vi.fn(),\n+        server: \"test-server\",\n+        send: vi.fn()\n+      };\n+\n+      const response = new StreamingResponse(\n+        mockConnection as unknown as Connection,\n+        \"test-id\"\n+      );\n+      expect(response).toBeDefined();\n+\n+      response.send({ data: \"chunk1\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: false,\n+          id: \"test-id\",\n+          result: { data: \"chunk1\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      response.end({ data: \"final\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: true,\n+          id: \"test-id\",\n+          result: { data: \"final\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      expect(() => response.send({ data: \"after-end\" })).toThrow(\n+        \"StreamingResponse is already closed\"\n+      );\n+    });\n+  });\n+\n+  describe(\"Agent Class Features\", () => {\n+    it(\"should support callable decorator\", () => {\n+      const metadata = {\n+        description: \"Test method\",\n+        streaming: false\n+      };\n+\n+      const decorator = unstable_callable(metadata);\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle different agent namespaces\", async () => {\n+      const testAgent = await getAgentByName(env.TEST_AGENT, \"test-agent\");\n+      expect(testAgent).toBeDefined();\n+      expect(testAgent.fetch).toBeDefined();\n+\n+      const emailAgent = await getAgentByName(env.EmailAgent, \"email-agent\");\n+      expect(emailAgent).toBeDefined();\n+      expect(emailAgent.fetch).toBeDefined();\n+\n+      const caseSensitiveAgent = await getAgentByName(\n+        env.CaseSensitiveAgent,\n+        \"case-agent\"\n+      );\n+      expect(caseSensitiveAgent).toBeDefined();\n+      expect(caseSensitiveAgent.fetch).toBeDefined();\n+\n+      const notificationAgent = await getAgentByName(\n+        env.UserNotificationAgent,\n+        \"notification-agent\"\n+      );\n+      expect(notificationAgent).toBeDefined();\n+      expect(notificationAgent.fetch).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"getCurrentAgent\", () => {\n+    it(\"should return context when called\", () => {\n+      // getCurrentAgent returns the context object, not just the agent\n+      const context = getCurrentAgent();\n+\n+      if (context) {\n+        expect(context).toHaveProperty(\"agent\");\n+      } else {\n+        expect(context).toBeUndefined();",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2212583476",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 363,
        "pr_file": "packages/agents/src/tests/index.test.ts",
        "discussion_id": "2212583476",
        "commented_code": "@@ -0,0 +1,672 @@\n+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+\n+    it(\"should handle custom prefix option\", async () => {\n+      const request = new Request(\n+        \"http://localhost/custom-prefix/TestAgent/test\",\n+        {\n+          method: \"OPTIONS\",\n+          headers: {\n+            Origin: \"http://localhost:3000\"\n+          }\n+        }\n+      );\n+\n+      const response = await routeAgentRequest(request, env, {\n+        prefix: \"custom-prefix\",\n+        cors: true\n+      });\n+\n+      // Should return CORS response for OPTIONS request\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+    });\n+\n+    it(\"should return null for non-matching paths\", async () => {\n+      const request = new Request(\"http://localhost/api/other/endpoint\", {\n+        method: \"GET\"\n+      });\n+\n+      const response = await routeAgentRequest(request, env);\n+\n+      expect(response).toBeNull();\n+    });\n+  });\n+\n+  describe(\"Utility Functions\", () => {\n+    describe(\"camelCaseToKebabCase\", () => {\n+      it(\"should convert CamelCase to kebab-case\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"EmailAgent\")).toBe(\"email-agent\");\n+        expect(camelCaseToKebabCase(\"MyComplexAgentName\")).toBe(\n+          \"my-complex-agent-name\"\n+        );\n+      });\n+\n+      it(\"should handle already kebab-case strings\", () => {\n+        expect(camelCaseToKebabCase(\"test-agent\")).toBe(\"test-agent\");\n+        expect(camelCaseToKebabCase(\"email-agent\")).toBe(\"email-agent\");\n+      });\n+\n+      it(\"should handle single word\", () => {\n+        expect(camelCaseToKebabCase(\"Agent\")).toBe(\"agent\");\n+        expect(camelCaseToKebabCase(\"Test\")).toBe(\"test\");\n+      });\n+\n+      it(\"should handle empty string\", () => {\n+        expect(camelCaseToKebabCase(\"\")).toBe(\"\");\n+      });\n+\n+      it(\"should handle strings with numbers\", () => {\n+        expect(camelCaseToKebabCase(\"TestAgent123\")).toBe(\"test-agent123\");\n+        expect(camelCaseToKebabCase(\"Agent2Email\")).toBe(\"agent2-email\");\n+      });\n+    });\n+  });\n+\n+  describe(\"Agent with different namespaces\", () => {\n+    it(\"should handle MCP agents\", async () => {\n+      const id = env.MCP_OBJECT.idFromName(\"test-mcp\");\n+      const agent = env.MCP_OBJECT.get(id);\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle multiple agent types\", async () => {\n+      // Mock console to prevent queueMicrotask errors\n+      const logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n+      const errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n+\n+      try {\n+        const testAgent = await getAgentByName(env.TEST_AGENT, \"test1\");\n+        const emailAgent = await getAgentByName(env.EmailAgent, \"test2\");\n+\n+        expect(testAgent).toBeDefined();\n+        expect(emailAgent).toBeDefined();\n+\n+        // Each agent type has its own namespace\n+        expect(testAgent.fetch).toBeDefined();\n+        expect(emailAgent.fetch).toBeDefined();\n+      } finally {\n+        // Restore console mocks\n+        logSpy.mockRestore();\n+        errorSpy.mockRestore();\n+      }\n+    });\n+  });\n+\n+  describe(\"Error Handling\", () => {\n+    it(\"should handle undefined environment bindings gracefully\", async () => {\n+      const undefinedEnv = {} as Env;\n+\n+      await expect(async () => {\n+        await getAgentByName(undefinedEnv.TEST_AGENT, \"test\");\n+      }).rejects.toThrow();\n+    });\n+  });\n+\n+  describe(\"Integration Scenarios\", () => {\n+    it(\"should handle concurrent agent creation\", async () => {\n+      const promises = Array(5)\n+        .fill(null)\n+        .map((_, i) => getAgentByName(env.TEST_AGENT, `concurrent-agent-${i}`));\n+\n+      const agents = await Promise.all(promises);\n+\n+      expect(agents).toHaveLength(5);\n+      agents.forEach((agent) => {\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      });\n+    });\n+\n+    it(\"should handle agent names with various patterns\", async () => {\n+      const patterns = [\n+        \"simple\",\n+        \"with-dash\",\n+        \"with_underscore\",\n+        \"with123numbers\",\n+        \"UPPERCASE\",\n+        \"mixedCase\"\n+      ];\n+\n+      for (const pattern of patterns) {\n+        const agent = await getAgentByName(env.TEST_AGENT, pattern);\n+        expect(agent).toBeDefined();\n+        expect(agent).toHaveProperty(\"fetch\");\n+      }\n+    });\n+  });\n+\n+  describe(\"Agent Direct Testing\", () => {\n+    it(\"should handle WebSocket upgrade\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"ws-test\");\n+\n+      const upgradeResponse = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\",\n+          headers: {\n+            Upgrade: \"websocket\"\n+          }\n+        })\n+      );\n+\n+      expect(upgradeResponse.status).toBe(101);\n+      expect(upgradeResponse.webSocket).toBeDefined();\n+    });\n+\n+    it(\"should handle basic HTTP requests\", async () => {\n+      const agent = await getAgentByName(env.TEST_AGENT, \"http-test\");\n+\n+      const response = await agent.fetch(\n+        new Request(\"http://localhost/test\", {\n+          method: \"GET\"\n+        })\n+      );\n+\n+      expect(response).toBeDefined();\n+      expect(response.status).toBe(200);\n+    });\n+  });\n+\n+  describe(\"StreamingResponse\", () => {\n+    it(\"should require connection and id parameters\", () => {\n+      expect(StreamingResponse).toBeDefined();\n+      expect(typeof StreamingResponse).toBe(\"function\");\n+    });\n+\n+    it(\"should be used for streaming RPC responses\", () => {\n+      const mockConnection = {\n+        id: \"test-connection-id\",\n+        state: {},\n+        setState: vi.fn(),\n+        server: \"test-server\",\n+        send: vi.fn()\n+      };\n+\n+      const response = new StreamingResponse(\n+        mockConnection as unknown as Connection,\n+        \"test-id\"\n+      );\n+      expect(response).toBeDefined();\n+\n+      response.send({ data: \"chunk1\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: false,\n+          id: \"test-id\",\n+          result: { data: \"chunk1\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      response.end({ data: \"final\" });\n+      expect(mockConnection.send).toHaveBeenCalledWith(\n+        JSON.stringify({\n+          done: true,\n+          id: \"test-id\",\n+          result: { data: \"final\" },\n+          success: true,\n+          type: \"rpc\"\n+        })\n+      );\n+\n+      expect(() => response.send({ data: \"after-end\" })).toThrow(\n+        \"StreamingResponse is already closed\"\n+      );\n+    });\n+  });\n+\n+  describe(\"Agent Class Features\", () => {\n+    it(\"should support callable decorator\", () => {\n+      const metadata = {\n+        description: \"Test method\",\n+        streaming: false\n+      };\n+\n+      const decorator = unstable_callable(metadata);\n+      expect(typeof decorator).toBe(\"function\");\n+    });\n+\n+    it(\"should handle different agent namespaces\", async () => {\n+      const testAgent = await getAgentByName(env.TEST_AGENT, \"test-agent\");\n+      expect(testAgent).toBeDefined();\n+      expect(testAgent.fetch).toBeDefined();\n+\n+      const emailAgent = await getAgentByName(env.EmailAgent, \"email-agent\");\n+      expect(emailAgent).toBeDefined();\n+      expect(emailAgent.fetch).toBeDefined();\n+\n+      const caseSensitiveAgent = await getAgentByName(\n+        env.CaseSensitiveAgent,\n+        \"case-agent\"\n+      );\n+      expect(caseSensitiveAgent).toBeDefined();\n+      expect(caseSensitiveAgent.fetch).toBeDefined();\n+\n+      const notificationAgent = await getAgentByName(\n+        env.UserNotificationAgent,\n+        \"notification-agent\"\n+      );\n+      expect(notificationAgent).toBeDefined();\n+      expect(notificationAgent.fetch).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"getCurrentAgent\", () => {\n+    it(\"should return context when called\", () => {\n+      // getCurrentAgent returns the context object, not just the agent\n+      const context = getCurrentAgent();\n+\n+      if (context) {\n+        expect(context).toHaveProperty(\"agent\");\n+      } else {\n+        expect(context).toBeUndefined();",
        "comment_created_at": "2025-07-17T07:52:22+00:00",
        "comment_author": "threepointone",
        "comment_body": "this doesn't test anything, need more here. probably all scenarios: read from getCurrentAgent in well known methods, as well as custom methods, and assert that agent is defined and points to the object. also test request/connection/email",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215314840",
    "pr_number": 364,
    "pr_file": "packages/agents/src/tests/mcp/client/client-manager.test.ts",
    "created_at": "2025-07-18T08:00:20+00:00",
    "commented_code": "+import { describe, expect, it } from \"vitest\";\n+import { MCPClientManager } from \"../../../mcp/client\";\n+import { DurableObjectOAuthClientProvider } from \"../../../mcp/do-oauth-client-provider\";\n+\n+/**\n+ * Tests for MCP client-side functionality\n+ */\n+describe(\"MCP Client Manager\", () => {\n+  const mockServerUrl = \"http://localhost:3000/mcp\";\n+\n+  describe(\"Client Creation\", () => {\n+    it(\"should create a client manager\", () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+      expect(manager).toBeDefined();\n+      expect(manager.mcpConnections).toEqual({});\n+    });\n+  });\n+\n+  describe(\"Transport Configuration\", () => {\n+    it(\"should connect with streamable HTTP transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+        expect(typeof result.id).toBe(\"string\");\n+        expect(result.id.length).toBe(8);\n+      } catch (error) {\n+        // Expected to fail in test environment, but transport should be created\n+        expect(error).toBeDefined();",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2215314840",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 364,
        "pr_file": "packages/agents/src/tests/mcp/client/client-manager.test.ts",
        "discussion_id": "2215314840",
        "commented_code": "@@ -0,0 +1,224 @@\n+import { describe, expect, it } from \"vitest\";\n+import { MCPClientManager } from \"../../../mcp/client\";\n+import { DurableObjectOAuthClientProvider } from \"../../../mcp/do-oauth-client-provider\";\n+\n+/**\n+ * Tests for MCP client-side functionality\n+ */\n+describe(\"MCP Client Manager\", () => {\n+  const mockServerUrl = \"http://localhost:3000/mcp\";\n+\n+  describe(\"Client Creation\", () => {\n+    it(\"should create a client manager\", () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+      expect(manager).toBeDefined();\n+      expect(manager.mcpConnections).toEqual({});\n+    });\n+  });\n+\n+  describe(\"Transport Configuration\", () => {\n+    it(\"should connect with streamable HTTP transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+        expect(typeof result.id).toBe(\"string\");\n+        expect(result.id.length).toBe(8);\n+      } catch (error) {\n+        // Expected to fail in test environment, but transport should be created\n+        expect(error).toBeDefined();",
        "comment_created_at": "2025-07-18T08:00:20+00:00",
        "comment_author": "threepointone",
        "comment_body": "we should probably run a server during test and check against it ",
        "pr_file_module": null
      }
    ]
  }
]