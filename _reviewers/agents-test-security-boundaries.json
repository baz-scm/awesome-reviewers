[
  {
    "discussion_id": "2212573421",
    "pr_number": 363,
    "pr_file": "packages/agents/src/tests/index.test.ts",
    "created_at": "2025-07-17T07:47:53+00:00",
    "commented_code": "+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2212573421",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 363,
        "pr_file": "packages/agents/src/tests/index.test.ts",
        "discussion_id": "2212573421",
        "commented_code": "@@ -0,0 +1,672 @@\n+import { env } from \"cloudflare:test\";\n+import { expect, describe, it, vi } from \"vitest\";\n+import {\n+  getAgentByName,\n+  routeAgentRequest,\n+  getCurrentAgent,\n+  unstable_callable,\n+  Agent,\n+  StreamingResponse,\n+  type Connection\n+} from \"../index.ts\";\n+import { camelCaseToKebabCase } from \"../client.ts\";\n+import type { Env } from \"./worker\";\n+\n+declare module \"cloudflare:test\" {\n+  interface ProvidedEnv extends Env {}\n+}\n+\n+describe(\"Agent Core Functionality\", () => {\n+  describe(\"getAgentByName\", () => {\n+    it(\"should return an agent with specified name\", async () => {\n+      const agentName = \"test-agent\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+      expect(typeof agent.fetch).toBe(\"function\");\n+    });\n+\n+    it(\"should handle agent name with special characters\", async () => {\n+      const agentName = \"my-agent-with-special-chars-123!@#\";\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should handle options parameter\", async () => {\n+      const agentName = \"my-agent\";\n+      const options = { locationHint: \"wnam\" as DurableObjectLocationHint };\n+\n+      const agent = await getAgentByName(env.TEST_AGENT, agentName, options);\n+\n+      expect(agent).toBeDefined();\n+      expect(agent).toHaveProperty(\"fetch\");\n+    });\n+\n+    it(\"should create different agents for different names\", async () => {\n+      const agent1 = await getAgentByName(env.TEST_AGENT, \"agent1\");\n+      const agent2 = await getAgentByName(env.TEST_AGENT, \"agent2\");\n+\n+      expect(agent1).toBeDefined();\n+      expect(agent2).toBeDefined();\n+      // They should be different instances based on ID\n+      const id1 = env.TEST_AGENT.idFromName(\"agent1\");\n+      const id2 = env.TEST_AGENT.idFromName(\"agent2\");\n+      expect(id1.toString()).not.toBe(id2.toString());\n+    });\n+  });\n+\n+  describe(\"routeAgentRequest\", () => {\n+    it(\"should handle CORS preflight requests when cors is enabled\", async () => {\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"http://localhost:3000\",\n+          \"Access-Control-Request-Method\": \"POST\",\n+          \"Access-Control-Request-Headers\": \"Content-Type\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, { cors: true });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\"*\");\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST, HEAD, OPTIONS\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Credentials\")).toBe(\n+        \"true\"\n+      );\n+    });\n+\n+    it(\"should handle CORS with custom headers\", async () => {\n+      const customCorsHeaders = {\n+        \"Access-Control-Allow-Origin\": \"https://example.com\",\n+        \"Access-Control-Allow-Methods\": \"GET, POST\",\n+        \"Access-Control-Max-Age\": \"3600\"\n+      };\n+\n+      const request = new Request(\"http://localhost/agents/TestAgent/test\", {\n+        method: \"OPTIONS\",\n+        headers: {\n+          Origin: \"https://example.com\"\n+        }\n+      });\n+\n+      const response = await routeAgentRequest(request, env, {\n+        cors: customCorsHeaders\n+      });\n+\n+      expect(response).toBeDefined();\n+      expect(response!.status).toBe(200);\n+      expect(response!.headers.get(\"Access-Control-Allow-Origin\")).toBe(\n+        \"https://example.com\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Allow-Methods\")).toBe(\n+        \"GET, POST\"\n+      );\n+      expect(response!.headers.get(\"Access-Control-Max-Age\")).toBe(\"3600\");\n+    });\n+",
        "comment_created_at": "2025-07-17T07:47:53+00:00",
        "comment_author": "threepointone",
        "comment_body": "maybe have a test where it fails without cors headers for a diff domain request?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215339446",
    "pr_number": 364,
    "pr_file": "packages/agents/src/tests/mcp/client/client-manager.test.ts",
    "created_at": "2025-07-18T08:09:44+00:00",
    "commented_code": "+import { describe, expect, it } from \"vitest\";\n+import { MCPClientManager } from \"../../../mcp/client\";\n+import { DurableObjectOAuthClientProvider } from \"../../../mcp/do-oauth-client-provider\";\n+\n+/**\n+ * Tests for MCP client-side functionality\n+ */\n+describe(\"MCP Client Manager\", () => {\n+  const mockServerUrl = \"http://localhost:3000/mcp\";\n+\n+  describe(\"Client Creation\", () => {\n+    it(\"should create a client manager\", () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+      expect(manager).toBeDefined();\n+      expect(manager.mcpConnections).toEqual({});\n+    });\n+  });\n+\n+  describe(\"Transport Configuration\", () => {\n+    it(\"should connect with streamable HTTP transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+        expect(typeof result.id).toBe(\"string\");\n+        expect(result.id.length).toBe(8);\n+      } catch (error) {\n+        // Expected to fail in test environment, but transport should be created\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should connect with SSE transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"sse\"\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should default to streamable HTTP transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            // No type specified, should default to streamable-http\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Connection Management\", () => {\n+    it(\"should handle reconnection\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          reconnect: {\n+            id: \"existing-server-id\",\n+            oauthClientId: \"existing-client-id\",\n+            oauthCode: \"auth-code-123\"\n+          },\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBe(\"existing-server-id\");\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should maintain connection state\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      expect(Object.keys(manager.mcpConnections)).toHaveLength(0);\n+\n+      try {\n+        await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\"\n+          }\n+        });\n+      } catch (error) {\n+        // Expected to fail, but connection should be created\n+      }\n+\n+      expect(Object.keys(manager.mcpConnections)).toHaveLength(1);\n+    });\n+\n+    it(\"should close individual connections\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\"\n+          }\n+        });\n+\n+        expect(Object.keys(manager.mcpConnections)).toHaveLength(1);\n+\n+        await manager.closeConnection(result.id);\n+\n+        expect(Object.keys(manager.mcpConnections)).toHaveLength(0);\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should close all connections\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\"\n+          }\n+        });\n+\n+        await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"sse\"\n+          }\n+        });\n+\n+        expect(Object.keys(manager.mcpConnections).length).toBeGreaterThan(0);\n+\n+        await manager.closeAllConnections();\n+\n+        // Note: closeAllConnections closes clients but doesn't remove from connections object\n+        expect(Object.keys(manager.mcpConnections).length).toBeGreaterThan(0);\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"OAuth Integration\", () => {\n+    it(\"should handle OAuth callback requests\", () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      // Test with no registered callbacks\n+      const testRequest = new Request(\"http://localhost:3000/callback\");\n+      expect(manager.isCallbackRequest(testRequest)).toBe(false);\n+    });\n+\n+    it(\"should support authentication flow\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        // Should have auth-related properties when auth provider is present\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+  });",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2215339446",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 364,
        "pr_file": "packages/agents/src/tests/mcp/client/client-manager.test.ts",
        "discussion_id": "2215339446",
        "commented_code": "@@ -0,0 +1,224 @@\n+import { describe, expect, it } from \"vitest\";\n+import { MCPClientManager } from \"../../../mcp/client\";\n+import { DurableObjectOAuthClientProvider } from \"../../../mcp/do-oauth-client-provider\";\n+\n+/**\n+ * Tests for MCP client-side functionality\n+ */\n+describe(\"MCP Client Manager\", () => {\n+  const mockServerUrl = \"http://localhost:3000/mcp\";\n+\n+  describe(\"Client Creation\", () => {\n+    it(\"should create a client manager\", () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+      expect(manager).toBeDefined();\n+      expect(manager.mcpConnections).toEqual({});\n+    });\n+  });\n+\n+  describe(\"Transport Configuration\", () => {\n+    it(\"should connect with streamable HTTP transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+        expect(typeof result.id).toBe(\"string\");\n+        expect(result.id.length).toBe(8);\n+      } catch (error) {\n+        // Expected to fail in test environment, but transport should be created\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should connect with SSE transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"sse\"\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should default to streamable HTTP transport\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            // No type specified, should default to streamable-http\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"Connection Management\", () => {\n+    it(\"should handle reconnection\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          reconnect: {\n+            id: \"existing-server-id\",\n+            oauthClientId: \"existing-client-id\",\n+            oauthCode: \"auth-code-123\"\n+          },\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        expect(result).toBeDefined();\n+        expect(result.id).toBe(\"existing-server-id\");\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should maintain connection state\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      expect(Object.keys(manager.mcpConnections)).toHaveLength(0);\n+\n+      try {\n+        await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\"\n+          }\n+        });\n+      } catch (error) {\n+        // Expected to fail, but connection should be created\n+      }\n+\n+      expect(Object.keys(manager.mcpConnections)).toHaveLength(1);\n+    });\n+\n+    it(\"should close individual connections\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\"\n+          }\n+        });\n+\n+        expect(Object.keys(manager.mcpConnections)).toHaveLength(1);\n+\n+        await manager.closeConnection(result.id);\n+\n+        expect(Object.keys(manager.mcpConnections)).toHaveLength(0);\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+\n+    it(\"should close all connections\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      try {\n+        await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\"\n+          }\n+        });\n+\n+        await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"sse\"\n+          }\n+        });\n+\n+        expect(Object.keys(manager.mcpConnections).length).toBeGreaterThan(0);\n+\n+        await manager.closeAllConnections();\n+\n+        // Note: closeAllConnections closes clients but doesn't remove from connections object\n+        expect(Object.keys(manager.mcpConnections).length).toBeGreaterThan(0);\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+  });\n+\n+  describe(\"OAuth Integration\", () => {\n+    it(\"should handle OAuth callback requests\", () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      // Test with no registered callbacks\n+      const testRequest = new Request(\"http://localhost:3000/callback\");\n+      expect(manager.isCallbackRequest(testRequest)).toBe(false);\n+    });\n+\n+    it(\"should support authentication flow\", async () => {\n+      const manager = new MCPClientManager(\"test-client\", \"1.0.0\");\n+\n+      const mockAuthProvider = {\n+        serverId: \"test-server\",\n+        clientId: \"test-client\",\n+        authUrl: \"http://localhost:3000/auth\",\n+        redirectUrl: new URL(\"http://localhost:3000/callback\"),\n+        tokens: () => Promise.resolve({ access_token: \"test-token\" })\n+      } as unknown as DurableObjectOAuthClientProvider;\n+\n+      try {\n+        const result = await manager.connect(mockServerUrl, {\n+          transport: {\n+            type: \"streamable-http\",\n+            authProvider: mockAuthProvider\n+          }\n+        });\n+\n+        // Should have auth-related properties when auth provider is present\n+        expect(result).toBeDefined();\n+        expect(result.id).toBeDefined();\n+      } catch (error) {\n+        // Expected to fail in test environment\n+        expect(error).toBeDefined();\n+      }\n+    });\n+  });",
        "comment_created_at": "2025-07-18T08:09:44+00:00",
        "comment_author": "threepointone",
        "comment_body": "the auth stuff is super involved, probably worth adding a whole other test suite for all of it ",
        "pr_file_module": null
      }
    ]
  }
]