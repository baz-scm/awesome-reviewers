[
  {
    "discussion_id": "2055055421",
    "pr_number": 185,
    "pr_file": "packages/agents/src/mcp/index.ts",
    "created_at": "2025-04-22T23:52:14+00:00",
    "commented_code": "}\n \n     const url = new URL(request.url);\n-    const sessionId = url.searchParams.get(\"sessionId\");\n-    if (!sessionId) {\n-      return new Response(\"Missing sessionId\", { status: 400 });\n-    }\n-\n-    // For now, each agent can only have one connection\n-    // If we get an upgrade while already connected, we should error\n-    if (this.#connected) {\n-      return new Response(\"WebSocket already connected\", { status: 400 });\n-    }\n-\n-    // Defer to the Agent's fetch method to handle the WebSocket connection\n-    // PartyServer does a lot to manage the connections under the hood\n-    const response = await this.#agent.fetch(request);\n+    const path = url.pathname;\n+\n+    switch (path) {\n+      // This session is going to communicate via the SSE protocol\n+      case \"/sse\": {",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2055055421",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 185,
        "pr_file": "packages/agents/src/mcp/index.ts",
        "discussion_id": "2055055421",
        "commented_code": "@@ -194,28 +211,36 @@ export abstract class McpAgent<\n     }\n \n     const url = new URL(request.url);\n-    const sessionId = url.searchParams.get(\"sessionId\");\n-    if (!sessionId) {\n-      return new Response(\"Missing sessionId\", { status: 400 });\n-    }\n-\n-    // For now, each agent can only have one connection\n-    // If we get an upgrade while already connected, we should error\n-    if (this.#connected) {\n-      return new Response(\"WebSocket already connected\", { status: 400 });\n-    }\n-\n-    // Defer to the Agent's fetch method to handle the WebSocket connection\n-    // PartyServer does a lot to manage the connections under the hood\n-    const response = await this.#agent.fetch(request);\n+    const path = url.pathname;\n+\n+    switch (path) {\n+      // This session is going to communicate via the SSE protocol\n+      case \"/sse\": {",
        "comment_created_at": "2025-04-22T23:52:14+00:00",
        "comment_author": "irvinebroque",
        "comment_body": "Does this end up meaning that you _must_ mount your API handler specifically on `/sse`?\r\n\r\nhttps://github.com/cloudflare/ai/blob/main/demos/remote-mcp-server/src/index.ts#L25",
        "pr_file_module": null
      },
      {
        "comment_id": "2055100895",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 185,
        "pr_file": "packages/agents/src/mcp/index.ts",
        "discussion_id": "2055055421",
        "commented_code": "@@ -194,28 +211,36 @@ export abstract class McpAgent<\n     }\n \n     const url = new URL(request.url);\n-    const sessionId = url.searchParams.get(\"sessionId\");\n-    if (!sessionId) {\n-      return new Response(\"Missing sessionId\", { status: 400 });\n-    }\n-\n-    // For now, each agent can only have one connection\n-    // If we get an upgrade while already connected, we should error\n-    if (this.#connected) {\n-      return new Response(\"WebSocket already connected\", { status: 400 });\n-    }\n-\n-    // Defer to the Agent's fetch method to handle the WebSocket connection\n-    // PartyServer does a lot to manage the connections under the hood\n-    const response = await this.#agent.fetch(request);\n+    const path = url.pathname;\n+\n+    switch (path) {\n+      // This session is going to communicate via the SSE protocol\n+      case \"/sse\": {",
        "comment_created_at": "2025-04-23T01:09:22+00:00",
        "comment_author": "jmorrell-cloudflare",
        "comment_body": "Not in this case since this is the request coming from the worker to the DO, not the request from the user to the worker. The user never sees this.\r\n\r\nWe use the path the DO receives to understand which protocol we'll be serving: https://github.com/jmorrell-cloudflare/agents/blob/jmorrell/01-streaming-transport-support/packages/agents/src/mcp/index.ts#L412-L413\r\n\r\nWe have to use one `fetch` method to serve both since only `fetch` can return a websocket connection. This seemed like a logical way to implement it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2055110656",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 185,
        "pr_file": "packages/agents/src/mcp/index.ts",
        "discussion_id": "2055055421",
        "commented_code": "@@ -194,28 +211,36 @@ export abstract class McpAgent<\n     }\n \n     const url = new URL(request.url);\n-    const sessionId = url.searchParams.get(\"sessionId\");\n-    if (!sessionId) {\n-      return new Response(\"Missing sessionId\", { status: 400 });\n-    }\n-\n-    // For now, each agent can only have one connection\n-    // If we get an upgrade while already connected, we should error\n-    if (this.#connected) {\n-      return new Response(\"WebSocket already connected\", { status: 400 });\n-    }\n-\n-    // Defer to the Agent's fetch method to handle the WebSocket connection\n-    // PartyServer does a lot to manage the connections under the hood\n-    const response = await this.#agent.fetch(request);\n+    const path = url.pathname;\n+\n+    switch (path) {\n+      // This session is going to communicate via the SSE protocol\n+      case \"/sse\": {",
        "comment_created_at": "2025-04-23T01:25:11+00:00",
        "comment_author": "irvinebroque",
        "comment_body": "Makes sense thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2023498638",
    "pr_number": 128,
    "pr_file": "packages/agents/src/mcp/index.ts",
    "created_at": "2025-04-01T18:46:04+00:00",
    "commented_code": "onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n     // override this to handle state updates\n   }\n+  async onStart() {\n+    this.props = (await this.ctx.storage.get(\"props\")) as Props;\n+    this.init?.();\n+\n+    // Connect to the MCP server\n+    this.#transport = new McpTransport(() => this.getWebSocket());\n+    await this.server.connect(this.#transport);\n+  }\n \n   /**\n    * McpAgent API\n    */\n   abstract server: McpServer;\n-  private transport!: SSEEdgeServerTransport;\n   props!: Props;\n   initRun = false;\n \n   abstract init(): Promise<void>;\n \n   async _init(props: Props) {\n+    this.ctx.storage.put(\"props\", props);\n     this.props = props;\n     if (!this.initRun) {\n       this.initRun = true;\n       await this.init();\n     }\n   }\n \n-  async onSSE(path: string): Promise<Response> {\n-    this.transport = new SSEEdgeServerTransport(\n-      `${path}/message`,\n-      this.ctx.id.toString()\n-    );\n-    await this.server.connect(this.transport);\n-    return this.transport.sseResponse;\n+  async #initialize(): Promise<void> {\n+    await this.ctx.blockConcurrencyWhile(async () => {\n+      this.#status = \"starting\";\n+      await this.onStart();\n+      this.#status = \"started\";\n+    });\n   }\n \n-  async onMCPMessage(request: Request): Promise<Response> {\n-    return this.transport.handlePostMessage(request);\n+  // Allow the worker to fetch a websocket connection to the agent\n+  async fetch(request: Request): Promise<Response> {\n+    if (this.#status !== \"started\") {\n+      // This means the server \"woke up\" after hibernation\n+      // so we need to hydrate it again\n+      await this.#initialize();\n+    }\n+\n+    // Only handle WebSocket upgrade requests\n+    if (request.headers.get(\"Upgrade\") !== \"websocket\") {\n+      return new Response(\"Expected WebSocket Upgrade request\", {\n+        status: 400,\n+      });\n+    }\n+\n+    const url = new URL(request.url);\n+    const sessionId = url.searchParams.get(\"sessionId\");\n+    if (!sessionId) {\n+      return new Response(\"Missing sessionId\", { status: 400 });\n+    }\n+\n+    // Create a WebSocket pair\n+    const webSocketPair = new WebSocketPair();\n+    const [client, server] = Object.values(webSocketPair);\n+\n+    // Accept the WebSocket with hibernation support\n+    this.ctx.acceptWebSocket(server);",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2023498638",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 128,
        "pr_file": "packages/agents/src/mcp/index.ts",
        "discussion_id": "2023498638",
        "commented_code": "@@ -82,36 +133,192 @@ export abstract class McpAgent<\n   onStateUpdate(state: State | undefined, source: Connection | \"server\") {\n     // override this to handle state updates\n   }\n+  async onStart() {\n+    this.props = (await this.ctx.storage.get(\"props\")) as Props;\n+    this.init?.();\n+\n+    // Connect to the MCP server\n+    this.#transport = new McpTransport(() => this.getWebSocket());\n+    await this.server.connect(this.#transport);\n+  }\n \n   /**\n    * McpAgent API\n    */\n   abstract server: McpServer;\n-  private transport!: SSEEdgeServerTransport;\n   props!: Props;\n   initRun = false;\n \n   abstract init(): Promise<void>;\n \n   async _init(props: Props) {\n+    this.ctx.storage.put(\"props\", props);\n     this.props = props;\n     if (!this.initRun) {\n       this.initRun = true;\n       await this.init();\n     }\n   }\n \n-  async onSSE(path: string): Promise<Response> {\n-    this.transport = new SSEEdgeServerTransport(\n-      `${path}/message`,\n-      this.ctx.id.toString()\n-    );\n-    await this.server.connect(this.transport);\n-    return this.transport.sseResponse;\n+  async #initialize(): Promise<void> {\n+    await this.ctx.blockConcurrencyWhile(async () => {\n+      this.#status = \"starting\";\n+      await this.onStart();\n+      this.#status = \"started\";\n+    });\n   }\n \n-  async onMCPMessage(request: Request): Promise<Response> {\n-    return this.transport.handlePostMessage(request);\n+  // Allow the worker to fetch a websocket connection to the agent\n+  async fetch(request: Request): Promise<Response> {\n+    if (this.#status !== \"started\") {\n+      // This means the server \"woke up\" after hibernation\n+      // so we need to hydrate it again\n+      await this.#initialize();\n+    }\n+\n+    // Only handle WebSocket upgrade requests\n+    if (request.headers.get(\"Upgrade\") !== \"websocket\") {\n+      return new Response(\"Expected WebSocket Upgrade request\", {\n+        status: 400,\n+      });\n+    }\n+\n+    const url = new URL(request.url);\n+    const sessionId = url.searchParams.get(\"sessionId\");\n+    if (!sessionId) {\n+      return new Response(\"Missing sessionId\", { status: 400 });\n+    }\n+\n+    // Create a WebSocket pair\n+    const webSocketPair = new WebSocketPair();\n+    const [client, server] = Object.values(webSocketPair);\n+\n+    // Accept the WebSocket with hibernation support\n+    this.ctx.acceptWebSocket(server);",
        "comment_created_at": "2025-04-01T18:46:04+00:00",
        "comment_author": "threepointone",
        "comment_body": "if we only care about the first websocket that's connected, do you want to throw an error if this is the second one?",
        "pr_file_module": null
      }
    ]
  }
]