[
  {
    "discussion_id": "2189304568",
    "pr_number": 342,
    "pr_file": "packages/agents/src/index.ts",
    "created_at": "2025-07-07T08:06:27+00:00",
    "commented_code": "return response;\n }\n \n-/**\n- * Route an email to the appropriate Agent\n- * @param email Email message to route\n- * @param env Environment containing Agent bindings\n- * @param options Routing options\n- */\n+export type EmailResolver<Env> = (\n+  email: ForwardableEmailMessage,\n+  env: Env\n+) => Promise<{\n+  agentName: string;\n+  agentId: string;\n+} | null>;\n+\n+async function defaultEmailResolver<Env>(\n+  email: ForwardableEmailMessage,\n+  _env: Env\n+): Promise<{ agentName: string; agentId: string } | null> {\n+  const messageId = email.headers.get(\"message-id\");\n+  if (messageId) {\n+    const messageIdMatch = messageId.match(/<([^@]+)@([^>]+)>/);\n+    if (messageIdMatch) {\n+      const [, agentId, domain] = messageIdMatch;\n+      const agentName = domain.split(\".\")[0];\n+      return { agentName, agentId };\n+    }\n+  }\n+\n+  const references = email.headers.get(\"references\");\n+  if (references) {\n+    const referencesMatch = references.match(/<([A-Za-z0-9+\\/]{43}=)@([^>]+)>/);\n+    if (referencesMatch) {\n+      const [, base64Id, domain] = referencesMatch;\n+      const agentId = Buffer.from(base64Id, \"base64\").toString(\"hex\");\n+      const agentName = domain.split(\".\")[0];\n+      return { agentName, agentId };\n+    }\n+  }\n+\n+  const agentName = email.headers.get(\"x-agent-name\");\n+  const agentId = email.headers.get(\"x-agent-id\");\n+  if (agentName && agentId) {\n+    return { agentName, agentId };\n+  }\n+\n+  return null;\n+}\n+\n+export function createEmailAddressResolver<Env>(\n+  defaultAgentName: string\n+): EmailResolver<Env> {\n+  return async (email: ForwardableEmailMessage, _env: Env) => {\n+    const emailMatch = email.to.match(/^([^+@]+)(?:\\+([^@]+))?@(.+)$/);\n+    if (!emailMatch) {\n+      return null;\n+    }\n+\n+    const [, localPart, subAddress] = emailMatch;\n+\n+    if (subAddress) {\n+      return {\n+        agentName: localPart,\n+        agentId: subAddress,\n+      };\n+    }\n+\n+    // Option 2: Use defaultAgentName namespace, localPart as agentId\n+    // Common for catch-all email routing to a single EmailAgent namespace\n+    return {\n+      agentName: defaultAgentName,\n+      agentId: localPart,\n+    };\n+  };\n+}\n+\n+export function createCatchAllResolver<Env>(\n+  agentName: string,\n+  agentId: string\n+): EmailResolver<Env> {\n+  return async () => ({ agentName, agentId });\n+}\n+\n+export type EmailRoutingOptions<Env> = AgentOptions<Env> & {\n+  resolver?: EmailResolver<Env>;\n+  defaultAgentName?: string;\n+  defaultAgentId?: string;\n+};\n+\n export async function routeAgentEmail<Env>(\n-  _email: ForwardableEmailMessage,\n-  _env: Env,\n-  _options?: AgentOptions<Env>\n-): Promise<void> {}\n+  email: ForwardableEmailMessage,\n+  env: Env,\n+  options?: EmailRoutingOptions<Env>\n+): Promise<void> {\n+  let routingInfo: { agentName: string; agentId: string } | null = null;\n+\n+  if (options?.resolver) {\n+    routingInfo = await options.resolver(email, env);\n+  } else {\n+    routingInfo = await defaultEmailResolver(email, env);\n+  }\n+\n+  if (!routingInfo && options?.defaultAgentName && options?.defaultAgentId) {\n+    routingInfo = {\n+      agentName: options.defaultAgentName,\n+      agentId: options.defaultAgentId,\n+    };\n+  }\n+\n+  if (!routingInfo) {\n+    console.warn(\"No routing information found for email, dropping message\");\n+    return;\n+  }\n+\n+  const namespace = env[routingInfo.agentName as keyof Env] as AgentNamespace<\n+    Agent<Env>\n+  >;\n+  if (!namespace) {\n+    console.error(\n+      `Agent namespace '${routingInfo.agentName}' not found in environment`\n+    );\n+    return;\n+  }\n+\n+  const agent = await getAgentByName(namespace, routingInfo.agentId);\n+  await agent.onEmail(email);\n+}\n+\n+export type EmailSendOptions = {\n+  to: string;\n+  subject: string;\n+  body: string;\n+  contentType?: string;\n+  headers?: Record<string, string>;\n+  includeRoutingHeaders?: boolean;\n+  agentName?: string;\n+  agentId?: string;\n+  domain?: string;\n+};\n+\n+export async function sendEmailWithRouting(\n+  emailBinding: SendEmail,\n+  from: string,\n+  fromName: string,\n+  options: EmailSendOptions\n+): Promise<void> {\n+  const { createMimeMessage } = await import(\"mimetext\");\n+  // biome-ignore lint/suspicious/noExplicitAny: EmailMessage type is dynamically imported from cloudflare:email\n+  let EmailMessage: any;\n+  try {\n+    const cloudflareEmail = await import(\"cloudflare:email\");\n+    // biome-ignore lint/suspicious/noExplicitAny: EmailMessage constructor is dynamically imported\n+    EmailMessage = cloudflareEmail.EmailMessage;\n+  } catch (error) {\n+    throw new Error(\n+      \"cloudflare:email module not available. This function must be called in a Cloudflare Workers environment.\"\n+    );\n+  }",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2189304568",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 342,
        "pr_file": "packages/agents/src/index.ts",
        "discussion_id": "2189304568",
        "commented_code": "@@ -1173,17 +1193,183 @@ export async function routeAgentRequest<Env>(\n   return response;\n }\n \n-/**\n- * Route an email to the appropriate Agent\n- * @param email Email message to route\n- * @param env Environment containing Agent bindings\n- * @param options Routing options\n- */\n+export type EmailResolver<Env> = (\n+  email: ForwardableEmailMessage,\n+  env: Env\n+) => Promise<{\n+  agentName: string;\n+  agentId: string;\n+} | null>;\n+\n+async function defaultEmailResolver<Env>(\n+  email: ForwardableEmailMessage,\n+  _env: Env\n+): Promise<{ agentName: string; agentId: string } | null> {\n+  const messageId = email.headers.get(\"message-id\");\n+  if (messageId) {\n+    const messageIdMatch = messageId.match(/<([^@]+)@([^>]+)>/);\n+    if (messageIdMatch) {\n+      const [, agentId, domain] = messageIdMatch;\n+      const agentName = domain.split(\".\")[0];\n+      return { agentName, agentId };\n+    }\n+  }\n+\n+  const references = email.headers.get(\"references\");\n+  if (references) {\n+    const referencesMatch = references.match(/<([A-Za-z0-9+\\/]{43}=)@([^>]+)>/);\n+    if (referencesMatch) {\n+      const [, base64Id, domain] = referencesMatch;\n+      const agentId = Buffer.from(base64Id, \"base64\").toString(\"hex\");\n+      const agentName = domain.split(\".\")[0];\n+      return { agentName, agentId };\n+    }\n+  }\n+\n+  const agentName = email.headers.get(\"x-agent-name\");\n+  const agentId = email.headers.get(\"x-agent-id\");\n+  if (agentName && agentId) {\n+    return { agentName, agentId };\n+  }\n+\n+  return null;\n+}\n+\n+export function createEmailAddressResolver<Env>(\n+  defaultAgentName: string\n+): EmailResolver<Env> {\n+  return async (email: ForwardableEmailMessage, _env: Env) => {\n+    const emailMatch = email.to.match(/^([^+@]+)(?:\\+([^@]+))?@(.+)$/);\n+    if (!emailMatch) {\n+      return null;\n+    }\n+\n+    const [, localPart, subAddress] = emailMatch;\n+\n+    if (subAddress) {\n+      return {\n+        agentName: localPart,\n+        agentId: subAddress,\n+      };\n+    }\n+\n+    // Option 2: Use defaultAgentName namespace, localPart as agentId\n+    // Common for catch-all email routing to a single EmailAgent namespace\n+    return {\n+      agentName: defaultAgentName,\n+      agentId: localPart,\n+    };\n+  };\n+}\n+\n+export function createCatchAllResolver<Env>(\n+  agentName: string,\n+  agentId: string\n+): EmailResolver<Env> {\n+  return async () => ({ agentName, agentId });\n+}\n+\n+export type EmailRoutingOptions<Env> = AgentOptions<Env> & {\n+  resolver?: EmailResolver<Env>;\n+  defaultAgentName?: string;\n+  defaultAgentId?: string;\n+};\n+\n export async function routeAgentEmail<Env>(\n-  _email: ForwardableEmailMessage,\n-  _env: Env,\n-  _options?: AgentOptions<Env>\n-): Promise<void> {}\n+  email: ForwardableEmailMessage,\n+  env: Env,\n+  options?: EmailRoutingOptions<Env>\n+): Promise<void> {\n+  let routingInfo: { agentName: string; agentId: string } | null = null;\n+\n+  if (options?.resolver) {\n+    routingInfo = await options.resolver(email, env);\n+  } else {\n+    routingInfo = await defaultEmailResolver(email, env);\n+  }\n+\n+  if (!routingInfo && options?.defaultAgentName && options?.defaultAgentId) {\n+    routingInfo = {\n+      agentName: options.defaultAgentName,\n+      agentId: options.defaultAgentId,\n+    };\n+  }\n+\n+  if (!routingInfo) {\n+    console.warn(\"No routing information found for email, dropping message\");\n+    return;\n+  }\n+\n+  const namespace = env[routingInfo.agentName as keyof Env] as AgentNamespace<\n+    Agent<Env>\n+  >;\n+  if (!namespace) {\n+    console.error(\n+      `Agent namespace '${routingInfo.agentName}' not found in environment`\n+    );\n+    return;\n+  }\n+\n+  const agent = await getAgentByName(namespace, routingInfo.agentId);\n+  await agent.onEmail(email);\n+}\n+\n+export type EmailSendOptions = {\n+  to: string;\n+  subject: string;\n+  body: string;\n+  contentType?: string;\n+  headers?: Record<string, string>;\n+  includeRoutingHeaders?: boolean;\n+  agentName?: string;\n+  agentId?: string;\n+  domain?: string;\n+};\n+\n+export async function sendEmailWithRouting(\n+  emailBinding: SendEmail,\n+  from: string,\n+  fromName: string,\n+  options: EmailSendOptions\n+): Promise<void> {\n+  const { createMimeMessage } = await import(\"mimetext\");\n+  // biome-ignore lint/suspicious/noExplicitAny: EmailMessage type is dynamically imported from cloudflare:email\n+  let EmailMessage: any;\n+  try {\n+    const cloudflareEmail = await import(\"cloudflare:email\");\n+    // biome-ignore lint/suspicious/noExplicitAny: EmailMessage constructor is dynamically imported\n+    EmailMessage = cloudflareEmail.EmailMessage;\n+  } catch (error) {\n+    throw new Error(\n+      \"cloudflare:email module not available. This function must be called in a Cloudflare Workers environment.\"\n+    );\n+  }",
        "comment_created_at": "2025-07-07T08:06:27+00:00",
        "comment_author": "ghostwriternr",
        "comment_body": "This currently throws this error:\r\n```sh\r\n[wrangler:info] Ready on http://localhost:8787\r\n\u2394 Starting local server...\r\n\ud83d\udcee Email received via email handler\r\n\ud83d\udce7 Received email from: sender@example.com to: recipient@example.com\r\n\ud83d\udce7 Parsed email: {\r\n  from: 'sender@example.com',\r\n  subject: 'Testing Email Workers Local Dev',\r\n  textLength: 0\r\n}\r\n\ud83d\udcca Agent state updated: { emailCount: 2, totalEmails: 2 }\r\n\ud83e\udd16 Sending auto-reply to: sender@example.com\r\n\u2718 [ERROR] \u274c Failed to send auto-reply: Error: Dynamic require of \"path\" is not supported\r\n\r\n      at __require\r\n  (file:///Users/naresh/github/cloudflare/agents/examples/email-agent/.wrangler/tmp/dev-m3G3q1/index.js:12:9)\r\n      at ../../node_modules/mime-types/index.js\r\n  (file:///Users/naresh/github/cloudflare/agents/node_modules/mime-types/index.js:16:15)\r\n      at __require2\r\n  (file:///Users/naresh/github/cloudflare/agents/packages/agents/dist/chunk-KEXKKQVW.js:15:48)\r\n      at ../../packages/agents/dist/mimetext.node.es-657RU4ZP.js\r\n  (file:///Users/naresh/github/cloudflare/agents/examples/email-agent/.wrangler/tmp/dev-m3G3q1/index.js:17371:18)\r\n      at __init\r\n  (file:///Users/naresh/github/cloudflare/agents/examples/email-agent/.wrangler/tmp/dev-m3G3q1/index.js:15:56)\r\n      at null.<anonymous>\r\n  (file:///Users/naresh/github/cloudflare/agents/packages/agents/src/index.ts:1335:39)\r\n      at async sendEmailWithRouting\r\n  (file:///Users/naresh/github/cloudflare/agents/packages/agents/src/index.ts:1335:33)\r\n```\r\n\r\nwhen hitting:\r\n```sh\r\ncurl --request POST 'http://localhost:8787/cdn-cgi/handler/email' \\\r\n  --url-query 'from=sender@example.com' \\\r\n  --url-query 'to=recipient@example.com' \\\r\n  --header 'Content-Type: application/json' \\\r\n  --data-raw 'Received: from smtp.example.com (127.0.0.1)\r\n        by cloudflare-email.com (unknown) id 4fwwffRXOpyR\r\n        for <recipient@example.com>; Tue, 27 Aug 2024 15:50:20 +0000\r\nFrom: \"John\" <sender@example.com>\r\nReply-To: sender@example.com\r\nTo: recipient@example.com\r\nSubject: Testing Email Workers Local Dev\r\nContent-Type: text/html; charset=\"windows-1252\"\r\nX-Mailer: Curl\r\nDate: Tue, 27 Aug 2024 08:49:44 -0700\r\nMessage-ID: <6114391943504294873000@ZSH-GHOSTTY>\r\n\r\nHi there'\r\n```\r\n\r\nLooks like the fix requires 3 things:\r\n1. Updating `packages/agents/scripts/build.ts`, `packages/hono-agents/scripts/build.ts` to include \"cloudflare:email\" in the list of external packages.\r\n2. Changing these dynamic imports to top-level imports and completely remove this highlighted block.\r\n```ts\r\nimport { createMimeMessage } from \"mimetext\";\r\nimport { EmailMessage } from \"cloudflare:email\";\r\n```\r\n```suggestion\r\n```\r\n3. Add `\"mimetext\": \"^3.0.27\",` to `packages/agents/package.json`. `npm run build` works without this, but its only because we are using mimetext in one of the examples and so this monorepo package-lock.json still sees it. But there is an obtuse runtime error about 'path' being dynamically imported, which recursively comes from this package being missing in the agents package dependencies.",
        "pr_file_module": null
      },
      {
        "comment_id": "2189632207",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 342,
        "pr_file": "packages/agents/src/index.ts",
        "discussion_id": "2189304568",
        "commented_code": "@@ -1173,17 +1193,183 @@ export async function routeAgentRequest<Env>(\n   return response;\n }\n \n-/**\n- * Route an email to the appropriate Agent\n- * @param email Email message to route\n- * @param env Environment containing Agent bindings\n- * @param options Routing options\n- */\n+export type EmailResolver<Env> = (\n+  email: ForwardableEmailMessage,\n+  env: Env\n+) => Promise<{\n+  agentName: string;\n+  agentId: string;\n+} | null>;\n+\n+async function defaultEmailResolver<Env>(\n+  email: ForwardableEmailMessage,\n+  _env: Env\n+): Promise<{ agentName: string; agentId: string } | null> {\n+  const messageId = email.headers.get(\"message-id\");\n+  if (messageId) {\n+    const messageIdMatch = messageId.match(/<([^@]+)@([^>]+)>/);\n+    if (messageIdMatch) {\n+      const [, agentId, domain] = messageIdMatch;\n+      const agentName = domain.split(\".\")[0];\n+      return { agentName, agentId };\n+    }\n+  }\n+\n+  const references = email.headers.get(\"references\");\n+  if (references) {\n+    const referencesMatch = references.match(/<([A-Za-z0-9+\\/]{43}=)@([^>]+)>/);\n+    if (referencesMatch) {\n+      const [, base64Id, domain] = referencesMatch;\n+      const agentId = Buffer.from(base64Id, \"base64\").toString(\"hex\");\n+      const agentName = domain.split(\".\")[0];\n+      return { agentName, agentId };\n+    }\n+  }\n+\n+  const agentName = email.headers.get(\"x-agent-name\");\n+  const agentId = email.headers.get(\"x-agent-id\");\n+  if (agentName && agentId) {\n+    return { agentName, agentId };\n+  }\n+\n+  return null;\n+}\n+\n+export function createEmailAddressResolver<Env>(\n+  defaultAgentName: string\n+): EmailResolver<Env> {\n+  return async (email: ForwardableEmailMessage, _env: Env) => {\n+    const emailMatch = email.to.match(/^([^+@]+)(?:\\+([^@]+))?@(.+)$/);\n+    if (!emailMatch) {\n+      return null;\n+    }\n+\n+    const [, localPart, subAddress] = emailMatch;\n+\n+    if (subAddress) {\n+      return {\n+        agentName: localPart,\n+        agentId: subAddress,\n+      };\n+    }\n+\n+    // Option 2: Use defaultAgentName namespace, localPart as agentId\n+    // Common for catch-all email routing to a single EmailAgent namespace\n+    return {\n+      agentName: defaultAgentName,\n+      agentId: localPart,\n+    };\n+  };\n+}\n+\n+export function createCatchAllResolver<Env>(\n+  agentName: string,\n+  agentId: string\n+): EmailResolver<Env> {\n+  return async () => ({ agentName, agentId });\n+}\n+\n+export type EmailRoutingOptions<Env> = AgentOptions<Env> & {\n+  resolver?: EmailResolver<Env>;\n+  defaultAgentName?: string;\n+  defaultAgentId?: string;\n+};\n+\n export async function routeAgentEmail<Env>(\n-  _email: ForwardableEmailMessage,\n-  _env: Env,\n-  _options?: AgentOptions<Env>\n-): Promise<void> {}\n+  email: ForwardableEmailMessage,\n+  env: Env,\n+  options?: EmailRoutingOptions<Env>\n+): Promise<void> {\n+  let routingInfo: { agentName: string; agentId: string } | null = null;\n+\n+  if (options?.resolver) {\n+    routingInfo = await options.resolver(email, env);\n+  } else {\n+    routingInfo = await defaultEmailResolver(email, env);\n+  }\n+\n+  if (!routingInfo && options?.defaultAgentName && options?.defaultAgentId) {\n+    routingInfo = {\n+      agentName: options.defaultAgentName,\n+      agentId: options.defaultAgentId,\n+    };\n+  }\n+\n+  if (!routingInfo) {\n+    console.warn(\"No routing information found for email, dropping message\");\n+    return;\n+  }\n+\n+  const namespace = env[routingInfo.agentName as keyof Env] as AgentNamespace<\n+    Agent<Env>\n+  >;\n+  if (!namespace) {\n+    console.error(\n+      `Agent namespace '${routingInfo.agentName}' not found in environment`\n+    );\n+    return;\n+  }\n+\n+  const agent = await getAgentByName(namespace, routingInfo.agentId);\n+  await agent.onEmail(email);\n+}\n+\n+export type EmailSendOptions = {\n+  to: string;\n+  subject: string;\n+  body: string;\n+  contentType?: string;\n+  headers?: Record<string, string>;\n+  includeRoutingHeaders?: boolean;\n+  agentName?: string;\n+  agentId?: string;\n+  domain?: string;\n+};\n+\n+export async function sendEmailWithRouting(\n+  emailBinding: SendEmail,\n+  from: string,\n+  fromName: string,\n+  options: EmailSendOptions\n+): Promise<void> {\n+  const { createMimeMessage } = await import(\"mimetext\");\n+  // biome-ignore lint/suspicious/noExplicitAny: EmailMessage type is dynamically imported from cloudflare:email\n+  let EmailMessage: any;\n+  try {\n+    const cloudflareEmail = await import(\"cloudflare:email\");\n+    // biome-ignore lint/suspicious/noExplicitAny: EmailMessage constructor is dynamically imported\n+    EmailMessage = cloudflareEmail.EmailMessage;\n+  } catch (error) {\n+    throw new Error(\n+      \"cloudflare:email module not available. This function must be called in a Cloudflare Workers environment.\"\n+    );\n+  }",
        "comment_created_at": "2025-07-07T10:32:05+00:00",
        "comment_author": "whoiskatrin",
        "comment_body": "fixed, will push soon",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2060488762",
    "pr_number": 219,
    "pr_file": "packages/agents/src/mcp/index.ts",
    "created_at": "2025-04-25T15:48:22+00:00",
    "commented_code": "const messagePattern = new URLPattern({ pathname: `${pathname}/message` });\n \n     return {\n-      fetch: async (\n+      async fetch<Env>(\n         request: Request,\n-        env: Record<string, DurableObjectNamespace<McpAgent>>,\n+        env: Env,\n         ctx: ExecutionContext\n-      ): Promise<Response> => {\n+      ): Promise<Response> {\n         // Handle CORS preflight\n         const corsResponse = handleCORS(request, corsOptions);\n         if (corsResponse) return corsResponse;\n \n         const url = new URL(request.url);\n-        const namespace = env[binding];\n+        const bindingValue = env[binding as keyof typeof env] as unknown;\n+\n+        // Ensure we have a binding of some sort\n+        if (bindingValue == null || typeof bindingValue !== \"object\") {\n+          console.error(\n+            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n+          );\n+          return new Response(\"Invalid binding\", { status: 500 });\n+        }\n+\n+        // Ensure that the biding is to a DurableObject\n+        if (bindingValue.toString() !== \"[object DurableObjectNamespace]\") {\n+          return new Response(\"Invalid binding\", { status: 500 });\n+        }\n+\n+        const namespace = bindingValue as DurableObjectNamespace<McpAgent>;",
    "repo_full_name": "cloudflare/agents",
    "discussion_comments": [
      {
        "comment_id": "2060488762",
        "repo_full_name": "cloudflare/agents",
        "pr_number": 219,
        "pr_file": "packages/agents/src/mcp/index.ts",
        "discussion_id": "2060488762",
        "commented_code": "@@ -532,17 +532,32 @@ export abstract class McpAgent<\n     const messagePattern = new URLPattern({ pathname: `${pathname}/message` });\n \n     return {\n-      fetch: async (\n+      async fetch<Env>(\n         request: Request,\n-        env: Record<string, DurableObjectNamespace<McpAgent>>,\n+        env: Env,\n         ctx: ExecutionContext\n-      ): Promise<Response> => {\n+      ): Promise<Response> {\n         // Handle CORS preflight\n         const corsResponse = handleCORS(request, corsOptions);\n         if (corsResponse) return corsResponse;\n \n         const url = new URL(request.url);\n-        const namespace = env[binding];\n+        const bindingValue = env[binding as keyof typeof env] as unknown;\n+\n+        // Ensure we have a binding of some sort\n+        if (bindingValue == null || typeof bindingValue !== \"object\") {\n+          console.error(\n+            `Could not find McpAgent binding for ${binding}. Did you update your wrangler configuration?`\n+          );\n+          return new Response(\"Invalid binding\", { status: 500 });\n+        }\n+\n+        // Ensure that the biding is to a DurableObject\n+        if (bindingValue.toString() !== \"[object DurableObjectNamespace]\") {\n+          return new Response(\"Invalid binding\", { status: 500 });\n+        }\n+\n+        const namespace = bindingValue as DurableObjectNamespace<McpAgent>;",
        "comment_created_at": "2025-04-25T15:48:22+00:00",
        "comment_author": "jmorrell-cloudflare",
        "comment_body": "This checks to make sure we have a binding, and that it's a DO binding, but then assumes that it must be an `McpAgent` because I couldn't figure out how to dynamically test that.\r\n\r\nNot perfect, but a lot better than what we have now.",
        "pr_file_module": null
      }
    ]
  }
]