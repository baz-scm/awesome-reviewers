[
  {
    "discussion_id": "2066234402",
    "pr_number": 6028,
    "pr_file": "packages/ai/core/generate-object/output-strategy.ts",
    "created_at": "2025-04-29T12:38:23+00:00",
    "commented_code": "};\n     },\n \n-    validatePartialResult() {\n-      // no streaming in enum mode\n-      throw new UnsupportedFunctionalityError({\n-        functionality: 'partial results in enum mode',\n-      });\n+    async validatePartialResult({ value, textDelta }) {\n+      if (!isJSONObject(value) || typeof value.result !== 'string') {\n+        return {\n+          success: false,\n+          error: new TypeValidationError({\n+            value,\n+            cause:\n+              'value must be an object that contains a string in the \"result\" property.',\n+          }),\n+        };\n+      }\n+\n+      const result = value.result as string;\n+      const possibleEnumValues = enumValues.filter(enumValue =>\n+        enumValue.startsWith(result),\n+      );\n+\n+      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n+        return {\n+          success: false,\n+          error: new TypeValidationError({\n+            value,\n+            cause: 'value must be a string in the enum',\n+          }),\n+        };\n+      }\n+\n+      return {\n+        success: true,\n+        value: {\n+          partial:\n+            possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n+          textDelta,\n+        },\n+      };",
    "repo_full_name": "vercel/ai",
    "discussion_comments": [
      {
        "comment_id": "2066234402",
        "repo_full_name": "vercel/ai",
        "pr_number": 6028,
        "pr_file": "packages/ai/core/generate-object/output-strategy.ts",
        "discussion_id": "2066234402",
        "commented_code": "@@ -335,11 +335,41 @@ const enumOutputStrategy = <ENUM extends string>(\n           };\n     },\n \n-    validatePartialResult() {\n-      // no streaming in enum mode\n-      throw new UnsupportedFunctionalityError({\n-        functionality: 'partial results in enum mode',\n-      });\n+    async validatePartialResult({ value, textDelta }) {\n+      if (!isJSONObject(value) || typeof value.result !== 'string') {\n+        return {\n+          success: false,\n+          error: new TypeValidationError({\n+            value,\n+            cause:\n+              'value must be an object that contains a string in the \"result\" property.',\n+          }),\n+        };\n+      }\n+\n+      const result = value.result as string;\n+      const possibleEnumValues = enumValues.filter(enumValue =>\n+        enumValue.startsWith(result),\n+      );\n+\n+      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n+        return {\n+          success: false,\n+          error: new TypeValidationError({\n+            value,\n+            cause: 'value must be a string in the enum',\n+          }),\n+        };\n+      }\n+\n+      return {\n+        success: true,\n+        value: {\n+          partial:\n+            possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n+          textDelta,\n+        },\n+      };",
        "comment_created_at": "2025-04-29T12:38:23+00:00",
        "comment_author": "lgrammel",
        "comment_body": "this can lead to issues where the wrong enum value is selected as a partial result, leading to changing enum values. i'd prefer a solution where that cannot happen (either by only returning fully matched enum values, or (more complicated) by returning enum values for which only one value is possible per prefix)",
        "pr_file_module": null
      },
      {
        "comment_id": "2066257595",
        "repo_full_name": "vercel/ai",
        "pr_number": 6028,
        "pr_file": "packages/ai/core/generate-object/output-strategy.ts",
        "discussion_id": "2066234402",
        "commented_code": "@@ -335,11 +335,41 @@ const enumOutputStrategy = <ENUM extends string>(\n           };\n     },\n \n-    validatePartialResult() {\n-      // no streaming in enum mode\n-      throw new UnsupportedFunctionalityError({\n-        functionality: 'partial results in enum mode',\n-      });\n+    async validatePartialResult({ value, textDelta }) {\n+      if (!isJSONObject(value) || typeof value.result !== 'string') {\n+        return {\n+          success: false,\n+          error: new TypeValidationError({\n+            value,\n+            cause:\n+              'value must be an object that contains a string in the \"result\" property.',\n+          }),\n+        };\n+      }\n+\n+      const result = value.result as string;\n+      const possibleEnumValues = enumValues.filter(enumValue =>\n+        enumValue.startsWith(result),\n+      );\n+\n+      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n+        return {\n+          success: false,\n+          error: new TypeValidationError({\n+            value,\n+            cause: 'value must be a string in the enum',\n+          }),\n+        };\n+      }\n+\n+      return {\n+        success: true,\n+        value: {\n+          partial:\n+            possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n+          textDelta,\n+        },\n+      };",
        "comment_created_at": "2025-04-29T12:47:17+00:00",
        "comment_author": "samdenty",
        "comment_body": "yep good call out - I added tests to test for these cases. In this case I check for `possibleEnumValues.length > 1` which means there's more than one match, in that case i return just the partial value. If there's only one possible enum per prefix, i return the full value preemptively",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2040695274",
    "pr_number": 5718,
    "pr_file": "packages/ai/core/util/detect-mimetype.ts",
    "created_at": "2025-04-12T16:50:53+00:00",
    "commented_code": "},\n ] as const;\n \n+const getID3v2TagSize = (header: Uint8Array) => {\n+  const size =\n+    ((header[6] & 0x7f) << 21) |\n+    ((header[7] & 0x7f) << 14) |\n+    ((header[8] & 0x7f) << 7) |\n+    (header[9] & 0x7f);\n+\n+  return size + 10; // add header size\n+};\n+\n+const stripID3 = (arrayBuffer: Uint8Array) => {\n+  const bytes = new Uint8Array(arrayBuffer);\n+\n+  if (\n+    bytes[0] === 0x49 && // 'I'\n+    bytes[1] === 0x44 && // 'D'\n+    bytes[2] === 0x33 // '3'\n+  ) {\n+    const id3Size = getID3v2TagSize(bytes);\n+    return bytes.slice(id3Size); // The raw MP3 starts here\n+  }\n+\n+  return bytes; // No ID3 tag, return as-is\n+};\n+\n export function detectMimeType({\n   data,\n   signatures,\n }: {\n   data: Uint8Array | string;\n   signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n }): (typeof signatures)[number]['mimeType'] | undefined {\n+  // Handle MP3 files with ID3 tags",
    "repo_full_name": "vercel/ai",
    "discussion_comments": [
      {
        "comment_id": "2040695274",
        "repo_full_name": "vercel/ai",
        "pr_number": 5718,
        "pr_file": "packages/ai/core/util/detect-mimetype.ts",
        "discussion_id": "2040695274",
        "commented_code": "@@ -83,13 +85,58 @@ export const audioMimeTypeSignatures = [\n   },\n ] as const;\n \n+const getID3v2TagSize = (header: Uint8Array) => {\n+  const size =\n+    ((header[6] & 0x7f) << 21) |\n+    ((header[7] & 0x7f) << 14) |\n+    ((header[8] & 0x7f) << 7) |\n+    (header[9] & 0x7f);\n+\n+  return size + 10; // add header size\n+};\n+\n+const stripID3 = (arrayBuffer: Uint8Array) => {\n+  const bytes = new Uint8Array(arrayBuffer);\n+\n+  if (\n+    bytes[0] === 0x49 && // 'I'\n+    bytes[1] === 0x44 && // 'D'\n+    bytes[2] === 0x33 // '3'\n+  ) {\n+    const id3Size = getID3v2TagSize(bytes);\n+    return bytes.slice(id3Size); // The raw MP3 starts here\n+  }\n+\n+  return bytes; // No ID3 tag, return as-is\n+};\n+\n export function detectMimeType({\n   data,\n   signatures,\n }: {\n   data: Uint8Array | string;\n   signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n }): (typeof signatures)[number]['mimeType'] | undefined {\n+  // Handle MP3 files with ID3 tags",
        "comment_created_at": "2025-04-12T16:50:53+00:00",
        "comment_author": "lgrammel",
        "comment_body": "What is this for? Can we do this more elegantly?",
        "pr_file_module": null
      },
      {
        "comment_id": "2040695498",
        "repo_full_name": "vercel/ai",
        "pr_number": 5718,
        "pr_file": "packages/ai/core/util/detect-mimetype.ts",
        "discussion_id": "2040695274",
        "commented_code": "@@ -83,13 +85,58 @@ export const audioMimeTypeSignatures = [\n   },\n ] as const;\n \n+const getID3v2TagSize = (header: Uint8Array) => {\n+  const size =\n+    ((header[6] & 0x7f) << 21) |\n+    ((header[7] & 0x7f) << 14) |\n+    ((header[8] & 0x7f) << 7) |\n+    (header[9] & 0x7f);\n+\n+  return size + 10; // add header size\n+};\n+\n+const stripID3 = (arrayBuffer: Uint8Array) => {\n+  const bytes = new Uint8Array(arrayBuffer);\n+\n+  if (\n+    bytes[0] === 0x49 && // 'I'\n+    bytes[1] === 0x44 && // 'D'\n+    bytes[2] === 0x33 // '3'\n+  ) {\n+    const id3Size = getID3v2TagSize(bytes);\n+    return bytes.slice(id3Size); // The raw MP3 starts here\n+  }\n+\n+  return bytes; // No ID3 tag, return as-is\n+};\n+\n export function detectMimeType({\n   data,\n   signatures,\n }: {\n   data: Uint8Array | string;\n   signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n }): (typeof signatures)[number]['mimeType'] | undefined {\n+  // Handle MP3 files with ID3 tags",
        "comment_created_at": "2025-04-12T16:51:44+00:00",
        "comment_author": "haydenbleasel",
        "comment_body": "So this was a bit of a rabbit hole! Turns out some mp3 files contain id3 tags at the start of the buffer (metadata basically) so i have to check for and strip that, otherwise the byte prefixes are different.",
        "pr_file_module": null
      },
      {
        "comment_id": "2040710888",
        "repo_full_name": "vercel/ai",
        "pr_number": 5718,
        "pr_file": "packages/ai/core/util/detect-mimetype.ts",
        "discussion_id": "2040695274",
        "commented_code": "@@ -83,13 +85,58 @@ export const audioMimeTypeSignatures = [\n   },\n ] as const;\n \n+const getID3v2TagSize = (header: Uint8Array) => {\n+  const size =\n+    ((header[6] & 0x7f) << 21) |\n+    ((header[7] & 0x7f) << 14) |\n+    ((header[8] & 0x7f) << 7) |\n+    (header[9] & 0x7f);\n+\n+  return size + 10; // add header size\n+};\n+\n+const stripID3 = (arrayBuffer: Uint8Array) => {\n+  const bytes = new Uint8Array(arrayBuffer);\n+\n+  if (\n+    bytes[0] === 0x49 && // 'I'\n+    bytes[1] === 0x44 && // 'D'\n+    bytes[2] === 0x33 // '3'\n+  ) {\n+    const id3Size = getID3v2TagSize(bytes);\n+    return bytes.slice(id3Size); // The raw MP3 starts here\n+  }\n+\n+  return bytes; // No ID3 tag, return as-is\n+};\n+\n export function detectMimeType({\n   data,\n   signatures,\n }: {\n   data: Uint8Array | string;\n   signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n }): (typeof signatures)[number]['mimeType'] | undefined {\n+  // Handle MP3 files with ID3 tags",
        "comment_created_at": "2025-04-12T18:04:39+00:00",
        "comment_author": "samdenty",
        "comment_body": "ooh cool i love hacking with file encodings 👀",
        "pr_file_module": null
      },
      {
        "comment_id": "2041062488",
        "repo_full_name": "vercel/ai",
        "pr_number": 5718,
        "pr_file": "packages/ai/core/util/detect-mimetype.ts",
        "discussion_id": "2040695274",
        "commented_code": "@@ -83,13 +85,58 @@ export const audioMimeTypeSignatures = [\n   },\n ] as const;\n \n+const getID3v2TagSize = (header: Uint8Array) => {\n+  const size =\n+    ((header[6] & 0x7f) << 21) |\n+    ((header[7] & 0x7f) << 14) |\n+    ((header[8] & 0x7f) << 7) |\n+    (header[9] & 0x7f);\n+\n+  return size + 10; // add header size\n+};\n+\n+const stripID3 = (arrayBuffer: Uint8Array) => {\n+  const bytes = new Uint8Array(arrayBuffer);\n+\n+  if (\n+    bytes[0] === 0x49 && // 'I'\n+    bytes[1] === 0x44 && // 'D'\n+    bytes[2] === 0x33 // '3'\n+  ) {\n+    const id3Size = getID3v2TagSize(bytes);\n+    return bytes.slice(id3Size); // The raw MP3 starts here\n+  }\n+\n+  return bytes; // No ID3 tag, return as-is\n+};\n+\n export function detectMimeType({\n   data,\n   signatures,\n }: {\n   data: Uint8Array | string;\n   signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n }): (typeof signatures)[number]['mimeType'] | undefined {\n+  // Handle MP3 files with ID3 tags",
        "comment_created_at": "2025-04-13T07:05:52+00:00",
        "comment_author": "lgrammel",
        "comment_body": "interesting - looks like this is not going to work for base64? we need tests around this and make it work for base 64 as well. Also it might be good to have some way of opting (or flagging on the signatures) since this removal won't be needed for images presumably.",
        "pr_file_module": null
      },
      {
        "comment_id": "2041062611",
        "repo_full_name": "vercel/ai",
        "pr_number": 5718,
        "pr_file": "packages/ai/core/util/detect-mimetype.ts",
        "discussion_id": "2040695274",
        "commented_code": "@@ -83,13 +85,58 @@ export const audioMimeTypeSignatures = [\n   },\n ] as const;\n \n+const getID3v2TagSize = (header: Uint8Array) => {\n+  const size =\n+    ((header[6] & 0x7f) << 21) |\n+    ((header[7] & 0x7f) << 14) |\n+    ((header[8] & 0x7f) << 7) |\n+    (header[9] & 0x7f);\n+\n+  return size + 10; // add header size\n+};\n+\n+const stripID3 = (arrayBuffer: Uint8Array) => {\n+  const bytes = new Uint8Array(arrayBuffer);\n+\n+  if (\n+    bytes[0] === 0x49 && // 'I'\n+    bytes[1] === 0x44 && // 'D'\n+    bytes[2] === 0x33 // '3'\n+  ) {\n+    const id3Size = getID3v2TagSize(bytes);\n+    return bytes.slice(id3Size); // The raw MP3 starts here\n+  }\n+\n+  return bytes; // No ID3 tag, return as-is\n+};\n+\n export function detectMimeType({\n   data,\n   signatures,\n }: {\n   data: Uint8Array | string;\n   signatures: typeof audioMimeTypeSignatures | typeof imageMimeTypeSignatures;\n }): (typeof signatures)[number]['mimeType'] | undefined {\n+  // Handle MP3 files with ID3 tags",
        "comment_created_at": "2025-04-13T07:07:05+00:00",
        "comment_author": "lgrammel",
        "comment_body": "btw, is this a separate bugfix that should be extracted into a standalone PR?",
        "pr_file_module": null
      }
    ]
  }
]