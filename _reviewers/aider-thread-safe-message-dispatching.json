[
  {
    "discussion_id": "2020191901",
    "pr_number": 3672,
    "pr_file": "aider/mcp/mcp_manager.py",
    "created_at": "2025-03-30T16:08:01+00:00",
    "commented_code": "+from contextlib import AsyncExitStack\n+from dataclasses import dataclass\n+import re\n+import shlex\n+import threading\n+import queue\n+from typing import Dict, List, Optional\n+import asyncio\n+\n+from mcp import ClientSession, StdioServerParameters, stdio_client\n+\n+from aider.mcp.mcp_server import McpServer\n+from aider.mcp.mcp_tool import McpTool\n+\n+@dataclass\n+class CallArguments:\n+    server_name: str\n+    function: str\n+    args: dict\n+\n+@dataclass\n+class CallResponse:\n+    error: str | None\n+    response: str | None\n+\n+class McpManager:\n+    \"\"\"Manages MCP servers and tools configuration.\"\"\"\n+\n+    def __init__(self):\n+        self.servers: Dict[str, McpServer] = {}\n+        self.enabled: bool = False\n+        self.message_queue = queue.Queue()\n+        self.result_queue = queue.Queue()\n+\n+    def _get_event_loop(self) -> asyncio.AbstractEventLoop:\n+        \"\"\"Get the current event loop or create a new one if none exists.\"\"\"\n+        try:\n+            return asyncio.get_event_loop()\n+        except RuntimeError:\n+            return asyncio.new_event_loop()\n+\n+    def _call(self, io, server_name, function, args: dict = {}):\n+        \"\"\"Sync call to the thread with queues.\"\"\"\n+\n+        self.message_queue.put(CallArguments(server_name, function, args))\n+        result = self.result_queue.get()",
    "repo_full_name": "Aider-AI/aider",
    "discussion_comments": [
      {
        "comment_id": "2020191901",
        "repo_full_name": "Aider-AI/aider",
        "pr_number": 3672,
        "pr_file": "aider/mcp/mcp_manager.py",
        "discussion_id": "2020191901",
        "commented_code": "@@ -0,0 +1,289 @@\n+from contextlib import AsyncExitStack\n+from dataclasses import dataclass\n+import re\n+import shlex\n+import threading\n+import queue\n+from typing import Dict, List, Optional\n+import asyncio\n+\n+from mcp import ClientSession, StdioServerParameters, stdio_client\n+\n+from aider.mcp.mcp_server import McpServer\n+from aider.mcp.mcp_tool import McpTool\n+\n+@dataclass\n+class CallArguments:\n+    server_name: str\n+    function: str\n+    args: dict\n+\n+@dataclass\n+class CallResponse:\n+    error: str | None\n+    response: str | None\n+\n+class McpManager:\n+    \"\"\"Manages MCP servers and tools configuration.\"\"\"\n+\n+    def __init__(self):\n+        self.servers: Dict[str, McpServer] = {}\n+        self.enabled: bool = False\n+        self.message_queue = queue.Queue()\n+        self.result_queue = queue.Queue()\n+\n+    def _get_event_loop(self) -> asyncio.AbstractEventLoop:\n+        \"\"\"Get the current event loop or create a new one if none exists.\"\"\"\n+        try:\n+            return asyncio.get_event_loop()\n+        except RuntimeError:\n+            return asyncio.new_event_loop()\n+\n+    def _call(self, io, server_name, function, args: dict = {}):\n+        \"\"\"Sync call to the thread with queues.\"\"\"\n+\n+        self.message_queue.put(CallArguments(server_name, function, args))\n+        result = self.result_queue.get()",
        "comment_created_at": "2025-03-30T16:08:01+00:00",
        "comment_author": "lutzleonhardt",
        "comment_body": "IMO I see a potential problem here.\r\nAll server threads read from the same `message_queue`. Whichever thread calls `get()` first, gets the message. If the server name does not match, that thread just calls `task_done()` and discards it.\r\nThis means the correct server thread might never see that message—it’s already been consumed by the wrong thread.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2020195499",
    "pr_number": 3672,
    "pr_file": "aider/mcp/mcp_manager.py",
    "created_at": "2025-03-30T16:27:47+00:00",
    "commented_code": "+from contextlib import AsyncExitStack\n+from dataclasses import dataclass\n+import re\n+import shlex\n+import threading\n+import queue\n+from typing import Dict, List, Optional\n+import asyncio\n+\n+from mcp import ClientSession, StdioServerParameters, stdio_client\n+\n+from aider.mcp.mcp_server import McpServer\n+from aider.mcp.mcp_tool import McpTool\n+\n+@dataclass\n+class CallArguments:\n+    server_name: str\n+    function: str\n+    args: dict\n+\n+@dataclass\n+class CallResponse:\n+    error: str | None\n+    response: str | None\n+\n+class McpManager:\n+    \"\"\"Manages MCP servers and tools configuration.\"\"\"\n+\n+    def __init__(self):\n+        self.servers: Dict[str, McpServer] = {}\n+        self.enabled: bool = False\n+        self.message_queue = queue.Queue()\n+        self.result_queue = queue.Queue()\n+\n+    def _get_event_loop(self) -> asyncio.AbstractEventLoop:\n+        \"\"\"Get the current event loop or create a new one if none exists.\"\"\"\n+        try:\n+            return asyncio.get_event_loop()\n+        except RuntimeError:\n+            return asyncio.new_event_loop()\n+\n+    def _call(self, io, server_name, function, args: dict = {}):\n+        \"\"\"Sync call to the thread with queues.\"\"\"\n+\n+        self.message_queue.put(CallArguments(server_name, function, args))\n+        result = self.result_queue.get()\n+        self.result_queue.task_done()\n+\n+        if result.error:\n+            if io:\n+                io.tool_error(result.error)\n+            return None\n+\n+        return result.response\n+\n+    async def _async_server_loop(self, server: McpServer) -> None:\n+        \"\"\"Run the async server loop for a given server.\"\"\"\n+\n+        # Parse the server exec command\n+        command_parts = shlex.split(server.command)\n+        executable = command_parts[0]\n+        args = command_parts[1:]\n+\n+        server_params = StdioServerParameters(\n+            command=executable,\n+            args=args,\n+            env=server.env_vars,\n+        )\n+\n+        # Run the async server loop\n+        exit_stack = AsyncExitStack()\n+\n+        stdio_transport = await exit_stack.enter_async_context(stdio_client(server_params))\n+        stdio, write = stdio_transport\n+        session = await exit_stack.enter_async_context(ClientSession(stdio, write))\n+\n+        await session.initialize()\n+\n+        while True:\n+            msg: CallArguments = self.message_queue.get()\n+\n+            # Exit the loop if the exit message is received\n+            if msg.function == \"exit\":\n+                break\n+\n+            # Ignore messages for other servers\n+            if msg.server_name != server.name:\n+                self.message_queue.task_done()\n+                continue\n+\n+            try:\n+                if msg.function == \"call_tool\":\n+                    response = await session.call_tool(**msg.args)\n+                    self.result_queue.put(CallResponse(None, response))\n+                elif msg.function == \"list_tools\":\n+                    response = await session.list_tools()\n+                    self.result_queue.put(CallResponse(None, response))\n+            except Exception as e:\n+                self.result_queue.put(CallResponse(str(e), None))\n+            finally:\n+                self.message_queue.task_done()\n+\n+    def _server_loop(self, server: McpServer, loop: asyncio.AbstractEventLoop) -> None:\n+        \"\"\"Wrap the async server loop for a given server.\"\"\"\n+        loop.run_until_complete(self._async_server_loop(server))\n+\n+    def configure_from_args(self, args) -> None:\n+        \"\"\"Configure MCP from command-line arguments.\"\"\"\n+        self.enabled = args.mcp\n+\n+        # If MCP is not enabled, don't process further\n+        if not self.enabled:\n+            return\n+\n+        # Add servers specified in --mcp-servers\n+        for server_name in args.mcp_servers:\n+            self.add_server(server_name)\n+            self.servers[server_name].enabled = True\n+\n+        # Process server commands\n+        for cmd_spec in args.mcp_server_command:\n+            parts = cmd_spec.split(\":\", 1)\n+            if len(parts) != 2:\n+                continue\n+            server_name, command = parts\n+            self.add_server(server_name)\n+            self.servers[server_name].command = command\n+\n+        # Process server environment variables\n+        for env_spec in args.mcp_server_env:\n+            match = re.match(r\"([^:]+):([^=]+)=(.*)\", env_spec)\n+            if not match:\n+                continue\n+            server_name, env_var, value = match.groups()\n+            self.add_server(server_name)\n+            self.servers[server_name].env_vars[env_var] = value\n+\n+        # Process tool permissions\n+        for perm_spec in args.mcp_tool_permission:\n+            match = re.match(r\"([^:]+):([^=]+)=(.*)\", perm_spec)\n+            if not match:\n+                continue\n+            server_name, tool_name, permission = match.groups()\n+            if permission not in [\"manual\", \"auto\"]:\n+                continue\n+            self.add_server(server_name)\n+            if tool_name not in self.servers[server_name].tools:\n+                self.servers[server_name].add_tool(tool_name)\n+            self.servers[server_name].set_tool_permission(tool_name, permission)\n+\n+    def add_server(self, server_name: str) -> McpServer:\n+        \"\"\"Add a new server if it doesn't exist, or return the existing one.\"\"\"\n+        if server_name not in self.servers:\n+            self.servers[server_name] = McpServer(server_name)\n+        return self.servers[server_name]\n+\n+    def get_server(self, server_name: str) -> Optional[McpServer]:\n+        \"\"\"Get a server by name, or None if it doesn't exist.\"\"\"\n+        return self.servers.get(server_name)\n+\n+    def get_enabled_servers(self) -> List[McpServer]:\n+        \"\"\"Get a list of all enabled servers.\"\"\"\n+        return [server for server in self.servers.values() if server.enabled]\n+\n+    def list_servers(self) -> List[McpServer]:\n+        \"\"\"Get a list of all servers.\"\"\"\n+        return list(self.servers.values())\n+\n+    def list_tools(self) -> Dict[str, List[McpTool]]:\n+        \"\"\"Get a dictionary of server names to lists of tools.\"\"\"\n+        result = {}\n+        for server_name, server in self.servers.items():\n+            if server.tools:\n+                result[server_name] = list(server.tools.values())\n+        return result\n+\n+    def initialize_servers(self, io) -> None:\n+        \"\"\"Initialize and start all enabled MCP servers.\n+\n+        Args:\n+            io: InputOutput object for logging messages\n+        \"\"\"\n+        if not self.enabled:\n+            return\n+\n+        loop = self._get_event_loop()\n+\n+        for server in self.get_enabled_servers():\n+            if server.command:\n+                t = threading.Thread(target=self._server_loop, args=(server, loop))",
    "repo_full_name": "Aider-AI/aider",
    "discussion_comments": [
      {
        "comment_id": "2020195499",
        "repo_full_name": "Aider-AI/aider",
        "pr_number": 3672,
        "pr_file": "aider/mcp/mcp_manager.py",
        "discussion_id": "2020195499",
        "commented_code": "@@ -0,0 +1,289 @@\n+from contextlib import AsyncExitStack\n+from dataclasses import dataclass\n+import re\n+import shlex\n+import threading\n+import queue\n+from typing import Dict, List, Optional\n+import asyncio\n+\n+from mcp import ClientSession, StdioServerParameters, stdio_client\n+\n+from aider.mcp.mcp_server import McpServer\n+from aider.mcp.mcp_tool import McpTool\n+\n+@dataclass\n+class CallArguments:\n+    server_name: str\n+    function: str\n+    args: dict\n+\n+@dataclass\n+class CallResponse:\n+    error: str | None\n+    response: str | None\n+\n+class McpManager:\n+    \"\"\"Manages MCP servers and tools configuration.\"\"\"\n+\n+    def __init__(self):\n+        self.servers: Dict[str, McpServer] = {}\n+        self.enabled: bool = False\n+        self.message_queue = queue.Queue()\n+        self.result_queue = queue.Queue()\n+\n+    def _get_event_loop(self) -> asyncio.AbstractEventLoop:\n+        \"\"\"Get the current event loop or create a new one if none exists.\"\"\"\n+        try:\n+            return asyncio.get_event_loop()\n+        except RuntimeError:\n+            return asyncio.new_event_loop()\n+\n+    def _call(self, io, server_name, function, args: dict = {}):\n+        \"\"\"Sync call to the thread with queues.\"\"\"\n+\n+        self.message_queue.put(CallArguments(server_name, function, args))\n+        result = self.result_queue.get()\n+        self.result_queue.task_done()\n+\n+        if result.error:\n+            if io:\n+                io.tool_error(result.error)\n+            return None\n+\n+        return result.response\n+\n+    async def _async_server_loop(self, server: McpServer) -> None:\n+        \"\"\"Run the async server loop for a given server.\"\"\"\n+\n+        # Parse the server exec command\n+        command_parts = shlex.split(server.command)\n+        executable = command_parts[0]\n+        args = command_parts[1:]\n+\n+        server_params = StdioServerParameters(\n+            command=executable,\n+            args=args,\n+            env=server.env_vars,\n+        )\n+\n+        # Run the async server loop\n+        exit_stack = AsyncExitStack()\n+\n+        stdio_transport = await exit_stack.enter_async_context(stdio_client(server_params))\n+        stdio, write = stdio_transport\n+        session = await exit_stack.enter_async_context(ClientSession(stdio, write))\n+\n+        await session.initialize()\n+\n+        while True:\n+            msg: CallArguments = self.message_queue.get()\n+\n+            # Exit the loop if the exit message is received\n+            if msg.function == \"exit\":\n+                break\n+\n+            # Ignore messages for other servers\n+            if msg.server_name != server.name:\n+                self.message_queue.task_done()\n+                continue\n+\n+            try:\n+                if msg.function == \"call_tool\":\n+                    response = await session.call_tool(**msg.args)\n+                    self.result_queue.put(CallResponse(None, response))\n+                elif msg.function == \"list_tools\":\n+                    response = await session.list_tools()\n+                    self.result_queue.put(CallResponse(None, response))\n+            except Exception as e:\n+                self.result_queue.put(CallResponse(str(e), None))\n+            finally:\n+                self.message_queue.task_done()\n+\n+    def _server_loop(self, server: McpServer, loop: asyncio.AbstractEventLoop) -> None:\n+        \"\"\"Wrap the async server loop for a given server.\"\"\"\n+        loop.run_until_complete(self._async_server_loop(server))\n+\n+    def configure_from_args(self, args) -> None:\n+        \"\"\"Configure MCP from command-line arguments.\"\"\"\n+        self.enabled = args.mcp\n+\n+        # If MCP is not enabled, don't process further\n+        if not self.enabled:\n+            return\n+\n+        # Add servers specified in --mcp-servers\n+        for server_name in args.mcp_servers:\n+            self.add_server(server_name)\n+            self.servers[server_name].enabled = True\n+\n+        # Process server commands\n+        for cmd_spec in args.mcp_server_command:\n+            parts = cmd_spec.split(\":\", 1)\n+            if len(parts) != 2:\n+                continue\n+            server_name, command = parts\n+            self.add_server(server_name)\n+            self.servers[server_name].command = command\n+\n+        # Process server environment variables\n+        for env_spec in args.mcp_server_env:\n+            match = re.match(r\"([^:]+):([^=]+)=(.*)\", env_spec)\n+            if not match:\n+                continue\n+            server_name, env_var, value = match.groups()\n+            self.add_server(server_name)\n+            self.servers[server_name].env_vars[env_var] = value\n+\n+        # Process tool permissions\n+        for perm_spec in args.mcp_tool_permission:\n+            match = re.match(r\"([^:]+):([^=]+)=(.*)\", perm_spec)\n+            if not match:\n+                continue\n+            server_name, tool_name, permission = match.groups()\n+            if permission not in [\"manual\", \"auto\"]:\n+                continue\n+            self.add_server(server_name)\n+            if tool_name not in self.servers[server_name].tools:\n+                self.servers[server_name].add_tool(tool_name)\n+            self.servers[server_name].set_tool_permission(tool_name, permission)\n+\n+    def add_server(self, server_name: str) -> McpServer:\n+        \"\"\"Add a new server if it doesn't exist, or return the existing one.\"\"\"\n+        if server_name not in self.servers:\n+            self.servers[server_name] = McpServer(server_name)\n+        return self.servers[server_name]\n+\n+    def get_server(self, server_name: str) -> Optional[McpServer]:\n+        \"\"\"Get a server by name, or None if it doesn't exist.\"\"\"\n+        return self.servers.get(server_name)\n+\n+    def get_enabled_servers(self) -> List[McpServer]:\n+        \"\"\"Get a list of all enabled servers.\"\"\"\n+        return [server for server in self.servers.values() if server.enabled]\n+\n+    def list_servers(self) -> List[McpServer]:\n+        \"\"\"Get a list of all servers.\"\"\"\n+        return list(self.servers.values())\n+\n+    def list_tools(self) -> Dict[str, List[McpTool]]:\n+        \"\"\"Get a dictionary of server names to lists of tools.\"\"\"\n+        result = {}\n+        for server_name, server in self.servers.items():\n+            if server.tools:\n+                result[server_name] = list(server.tools.values())\n+        return result\n+\n+    def initialize_servers(self, io) -> None:\n+        \"\"\"Initialize and start all enabled MCP servers.\n+\n+        Args:\n+            io: InputOutput object for logging messages\n+        \"\"\"\n+        if not self.enabled:\n+            return\n+\n+        loop = self._get_event_loop()\n+\n+        for server in self.get_enabled_servers():\n+            if server.command:\n+                t = threading.Thread(target=self._server_loop, args=(server, loop))",
        "comment_created_at": "2025-03-30T16:27:47+00:00",
        "comment_author": "lutzleonhardt",
        "comment_body": "You have one thread per MCP server, but because of the blocking behaviour of the queues the tool calls are made sync because the main thread is blocked. In addition there is the problem that all threads read from one queue (which leads to the problem only one thread can receive it atm).\r\n\r\nAlternatives (provided by sonnet):\r\n\r\n1.  Single AsyncIO Event Loop in a Background Thread\r\n```python\r\nclass AsyncioManager:\r\n    def __init__(self):\r\n        self.loop = asyncio.new_event_loop()\r\n        self.thread = threading.Thread(target=self._run_event_loop, daemon=True)\r\n        self.thread.start()\r\n        self.servers = {}\r\n\r\n    def _run_event_loop(self):\r\n        asyncio.set_event_loop(self.loop)\r\n        self.loop.run_forever()\r\n        \r\n    def call_async(self, coro):\r\n        future = concurrent.futures.Future()\r\n        \r\n        async def wrapper():\r\n            try:\r\n                result = await coro\r\n                future.set_result(result)\r\n            except Exception as e:\r\n                future.set_exception(e)\r\n                \r\n        asyncio.run_coroutine_threadsafe(wrapper(), self.loop)\r\n        return future.result()  # This blocks until result is available\r\n```\r\n\r\n\r\n2. Asynchronous API with Callbacks\r\n```python\r\nclass AsyncToolManager:\r\n    def __init__(self):\r\n        self.loop = asyncio.new_event_loop()\r\n        self.thread = threading.Thread(target=self._run_event_loop, daemon=True)\r\n        self.thread.start()\r\n        \r\n    def execute_tool(self, server_name, tool_name, arguments, callback):\r\n        \"\"\"Non-blocking tool execution with callback\"\"\"\r\n        \r\n        async def run_tool():\r\n            result = await self._async_execute_tool(server_name, tool_name, arguments)\r\n            # Call the callback in the main thread\r\n            callback(result)\r\n            \r\n        asyncio.run_coroutine_threadsafe(run_tool(), self.loop)\r\n```\r\n\r\n\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]