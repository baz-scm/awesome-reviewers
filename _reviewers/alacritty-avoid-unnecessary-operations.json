[
  {
    "discussion_id": "1895044378",
    "pr_number": 8374,
    "pr_file": "alacritty/src/event.rs",
    "created_at": "2024-12-22T20:12:16+00:00",
    "commented_code": "}\n \n         // Handle events which don't mandate the WindowId.\n-        match (&event.payload, event.window_id.as_ref()) {\n+        match (event.payload, event.window_id.as_ref()) {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1895044378",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 8374,
        "pr_file": "alacritty/src/event.rs",
        "discussion_id": "1895044378",
        "commented_code": "@@ -276,7 +278,7 @@ impl ApplicationHandler<Event> for Processor {\n         }\n \n         // Handle events which don't mandate the WindowId.\n-        match (&event.payload, event.window_id.as_ref()) {\n+        match (event.payload, event.window_id.as_ref()) {",
        "comment_created_at": "2024-12-22T20:12:16+00:00",
        "comment_author": "kchibisov",
        "comment_body": "why this got changed?",
        "pr_file_module": null
      },
      {
        "comment_id": "1895048263",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 8374,
        "pr_file": "alacritty/src/event.rs",
        "discussion_id": "1895044378",
        "commented_code": "@@ -276,7 +278,7 @@ impl ApplicationHandler<Event> for Processor {\n         }\n \n         // Handle events which don't mandate the WindowId.\n-        match (&event.payload, event.window_id.as_ref()) {\n+        match (event.payload, event.window_id.as_ref()) {",
        "comment_created_at": "2024-12-22T20:27:47+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "To avoid unnecessary clones.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1518677359",
    "pr_number": 7824,
    "pr_file": "alacritty/src/input/mod.rs",
    "created_at": "2024-03-09T22:52:28+00:00",
    "commented_code": "let point = self.ctx.mouse().point(&self.ctx.size_info(), display_offset);\n         let hyperlink = self.ctx.terminal().grid()[point].hyperlink();\n \n-        // Function to check if mouse is on top of a hint.\n-        let hint_highlighted = |hint: &HintMatch| hint.should_highlight(point, hyperlink.as_ref());\n-\n         if let Some(mouse_state) = self.message_bar_cursor_state() {\n             mouse_state\n-        } else if self.ctx.display().highlighted_hint.as_ref().map_or(false, hint_highlighted) {\n+        } else if hyperlink.is_some() {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1518677359",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/input/mod.rs",
        "discussion_id": "1518677359",
        "commented_code": "@@ -1050,12 +1050,9 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         let point = self.ctx.mouse().point(&self.ctx.size_info(), display_offset);\n         let hyperlink = self.ctx.terminal().grid()[point].hyperlink();\n \n-        // Function to check if mouse is on top of a hint.\n-        let hint_highlighted = |hint: &HintMatch| hint.should_highlight(point, hyperlink.as_ref());\n-\n         if let Some(mouse_state) = self.message_bar_cursor_state() {\n             mouse_state\n-        } else if self.ctx.display().highlighted_hint.as_ref().map_or(false, hint_highlighted) {\n+        } else if hyperlink.is_some() {",
        "comment_created_at": "2024-03-09T22:52:28+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "This change isn't strictly necessary, but it seems to just work so why not?",
        "pr_file_module": null
      },
      {
        "comment_id": "1519734256",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/input/mod.rs",
        "discussion_id": "1518677359",
        "commented_code": "@@ -1050,12 +1050,9 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         let point = self.ctx.mouse().point(&self.ctx.size_info(), display_offset);\n         let hyperlink = self.ctx.terminal().grid()[point].hyperlink();\n \n-        // Function to check if mouse is on top of a hint.\n-        let hint_highlighted = |hint: &HintMatch| hint.should_highlight(point, hyperlink.as_ref());\n-\n         if let Some(mouse_state) = self.message_bar_cursor_state() {\n             mouse_state\n-        } else if self.ctx.display().highlighted_hint.as_ref().map_or(false, hint_highlighted) {\n+        } else if hyperlink.is_some() {",
        "comment_created_at": "2024-03-11T13:38:51+00:00",
        "comment_author": "kchibisov",
        "comment_body": "Hm, the reason this works is because the logic is bit inconsistent. We basically set the cursor from the renderer and from this function, so that's why the code here works even though it doesn't check the regular region anyway.\r\n\r\nIn the current state of things you can remove all the logic around `hyperlink` and `::Pointer` and it'll still work. \r\n\r\nI don't really like that it's like that though since it's a bit error prone?",
        "pr_file_module": null
      },
      {
        "comment_id": "1520356793",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/input/mod.rs",
        "discussion_id": "1518677359",
        "commented_code": "@@ -1050,12 +1050,9 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         let point = self.ctx.mouse().point(&self.ctx.size_info(), display_offset);\n         let hyperlink = self.ctx.terminal().grid()[point].hyperlink();\n \n-        // Function to check if mouse is on top of a hint.\n-        let hint_highlighted = |hint: &HintMatch| hint.should_highlight(point, hyperlink.as_ref());\n-\n         if let Some(mouse_state) = self.message_bar_cursor_state() {\n             mouse_state\n-        } else if self.ctx.display().highlighted_hint.as_ref().map_or(false, hint_highlighted) {\n+        } else if hyperlink.is_some() {",
        "comment_created_at": "2024-03-11T19:57:51+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "But it was relying on the same thing before, just in a more verbose manner?",
        "pr_file_module": null
      },
      {
        "comment_id": "1520365003",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/input/mod.rs",
        "discussion_id": "1518677359",
        "commented_code": "@@ -1050,12 +1050,9 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         let point = self.ctx.mouse().point(&self.ctx.size_info(), display_offset);\n         let hyperlink = self.ctx.terminal().grid()[point].hyperlink();\n \n-        // Function to check if mouse is on top of a hint.\n-        let hint_highlighted = |hint: &HintMatch| hint.should_highlight(point, hyperlink.as_ref());\n-\n         if let Some(mouse_state) = self.message_bar_cursor_state() {\n             mouse_state\n-        } else if self.ctx.display().highlighted_hint.as_ref().map_or(false, hint_highlighted) {\n+        } else if hyperlink.is_some() {",
        "comment_created_at": "2024-03-11T20:05:29+00:00",
        "comment_author": "kchibisov",
        "comment_body": "Pretty much yes. I'm not sure what to do about this function though, because clearly the check could be removed, though, maybe there's an edge case...",
        "pr_file_module": null
      },
      {
        "comment_id": "1520385892",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/input/mod.rs",
        "discussion_id": "1518677359",
        "commented_code": "@@ -1050,12 +1050,9 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         let point = self.ctx.mouse().point(&self.ctx.size_info(), display_offset);\n         let hyperlink = self.ctx.terminal().grid()[point].hyperlink();\n \n-        // Function to check if mouse is on top of a hint.\n-        let hint_highlighted = |hint: &HintMatch| hint.should_highlight(point, hyperlink.as_ref());\n-\n         if let Some(mouse_state) = self.message_bar_cursor_state() {\n             mouse_state\n-        } else if self.ctx.display().highlighted_hint.as_ref().map_or(false, hint_highlighted) {\n+        } else if hyperlink.is_some() {",
        "comment_created_at": "2024-03-11T20:23:25+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Yeah honestly I was kinda worried that this patch would only change the mouse cursor when on a hyperlink escape, but that doesn't seem to be the case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1520388937",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/input/mod.rs",
        "discussion_id": "1518677359",
        "commented_code": "@@ -1050,12 +1050,9 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         let point = self.ctx.mouse().point(&self.ctx.size_info(), display_offset);\n         let hyperlink = self.ctx.terminal().grid()[point].hyperlink();\n \n-        // Function to check if mouse is on top of a hint.\n-        let hint_highlighted = |hint: &HintMatch| hint.should_highlight(point, hyperlink.as_ref());\n-\n         if let Some(mouse_state) = self.message_bar_cursor_state() {\n             mouse_state\n-        } else if self.ctx.display().highlighted_hint.as_ref().map_or(false, hint_highlighted) {\n+        } else if hyperlink.is_some() {",
        "comment_created_at": "2024-03-11T20:25:34+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Actually I found why this is necessary and my changes broke things:\r\n\r\nIf you're in mouse mode and hover over a URL, this will change mouse shape without shift.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1398810257",
    "pr_number": 7367,
    "pr_file": "alacritty/src/display/damage.rs",
    "created_at": "2023-11-20T08:34:28+00:00",
    "commented_code": "-use std::cmp;\n use std::iter::Peekable;\n+use std::{cmp, mem};\n \n use glutin::surface::Rect;\n \n+use alacritty_terminal::index::Point;\n+use alacritty_terminal::selection::SelectionRange;\n use alacritty_terminal::term::{LineDamageBounds, TermDamageIterator};\n \n use crate::display::SizeInfo;\n \n+/// State of the damage tracking for the [`Display`].\n+///\n+/// [`Display`]: crate::display::Display\n+#[derive(Debug)]\n+pub struct DamageTracker {\n+    /// The damage for the frames.\n+    frames: [FrameDamage; 2],\n+    /// Position of the previously drawn Vi cursor.\n+    pub old_vi_cursor: Option<Point<usize>>,\n+    /// The location of the old selection.\n+    pub old_selection: Option<SelectionRange>,\n+    /// Highlight damage submitted for the compositor.\n+    pub debug: bool,\n+\n+    screen_lines: usize,\n+    columns: usize,\n+}\n+\n+impl DamageTracker {\n+    pub fn new(screen_lines: usize, columns: usize) -> Self {\n+        let mut tracker = Self {\n+            columns,\n+            screen_lines,\n+            debug: false,\n+            old_vi_cursor: None,\n+            old_selection: None,\n+            frames: Default::default(),\n+        };\n+        tracker.resize(screen_lines, columns);\n+        tracker\n+    }\n+\n+    #[inline]\n+    #[must_use]\n+    pub fn frame(&mut self) -> &mut FrameDamage {\n+        &mut self.frames[0]\n+    }\n+\n+    #[inline]\n+    #[must_use]\n+    pub fn next_frame(&mut self) -> &mut FrameDamage {\n+        &mut self.frames[1]\n+    }\n+\n+    /// Advance to the next frame resetting the state for the active frame.\n+    #[inline]\n+    pub fn swap_damage(&mut self) {\n+        let screen_lines = self.screen_lines;\n+        let columns = self.columns;\n+        self.frame().reset(screen_lines, columns);\n+        self.frames.swap(0, 1);\n+    }\n+\n+    /// Resize the damage information in the tracker.\n+    pub fn resize(&mut self, screen_lines: usize, columns: usize) {\n+        self.screen_lines = screen_lines;\n+        self.columns = columns;\n+        for frame in &mut self.frames {\n+            frame.reset(screen_lines, columns);\n+        }\n+        self.frame().damage_all = true;\n+    }\n+\n+    /// Damage vi cursor inside the viewport.\n+    pub fn damage_vi_cursor(&mut self, mut vi_cursor: Option<Point<usize>>) {\n+        mem::swap(&mut self.old_vi_cursor, &mut vi_cursor);\n+\n+        if self.frame().damage_all {\n+            return;\n+        }\n+\n+        if let Some(vi_cursor) = self.old_vi_cursor {\n+            self.frame().damage_point(vi_cursor);\n+        }\n+\n+        if let Some(vi_cursor) = vi_cursor {\n+            self.frame().damage_point(vi_cursor);\n+        }\n+    }\n+\n+    /// Get shaped frame damage for the active frame.\n+    pub fn shape_frame_damage(&self, size_info: SizeInfo<u32>) -> Vec<Rect> {\n+        if self.frames[0].damage_all {\n+            vec![Rect::new(0, 0, size_info.width() as i32, size_info.height() as i32)]\n+        } else {\n+            let lines_damage = RenderDamageIterator::new(\n+                TermDamageIterator::new(&self.frames[0].lines, 0),\n+                &size_info,\n+            );\n+            lines_damage.chain(self.frames[0].rects.iter().copied()).collect()\n+        }\n+    }\n+\n+    /// Set the selection adding the damage for the current frame.\n+    pub fn damage_selection(\n+        &mut self,\n+        mut selection: Option<SelectionRange>,\n+        display_offset: usize,\n+    ) {\n+        mem::swap(&mut self.old_selection, &mut selection);\n+\n+        if self.frame().damage_all {\n+            return;\n+        }\n+\n+        if selection != self.old_selection {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1398810257",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7367,
        "pr_file": "alacritty/src/display/damage.rs",
        "discussion_id": "1398810257",
        "commented_code": "@@ -1,20 +1,197 @@\n-use std::cmp;\n use std::iter::Peekable;\n+use std::{cmp, mem};\n \n use glutin::surface::Rect;\n \n+use alacritty_terminal::index::Point;\n+use alacritty_terminal::selection::SelectionRange;\n use alacritty_terminal::term::{LineDamageBounds, TermDamageIterator};\n \n use crate::display::SizeInfo;\n \n+/// State of the damage tracking for the [`Display`].\n+///\n+/// [`Display`]: crate::display::Display\n+#[derive(Debug)]\n+pub struct DamageTracker {\n+    /// The damage for the frames.\n+    frames: [FrameDamage; 2],\n+    /// Position of the previously drawn Vi cursor.\n+    pub old_vi_cursor: Option<Point<usize>>,\n+    /// The location of the old selection.\n+    pub old_selection: Option<SelectionRange>,\n+    /// Highlight damage submitted for the compositor.\n+    pub debug: bool,\n+\n+    screen_lines: usize,\n+    columns: usize,\n+}\n+\n+impl DamageTracker {\n+    pub fn new(screen_lines: usize, columns: usize) -> Self {\n+        let mut tracker = Self {\n+            columns,\n+            screen_lines,\n+            debug: false,\n+            old_vi_cursor: None,\n+            old_selection: None,\n+            frames: Default::default(),\n+        };\n+        tracker.resize(screen_lines, columns);\n+        tracker\n+    }\n+\n+    #[inline]\n+    #[must_use]\n+    pub fn frame(&mut self) -> &mut FrameDamage {\n+        &mut self.frames[0]\n+    }\n+\n+    #[inline]\n+    #[must_use]\n+    pub fn next_frame(&mut self) -> &mut FrameDamage {\n+        &mut self.frames[1]\n+    }\n+\n+    /// Advance to the next frame resetting the state for the active frame.\n+    #[inline]\n+    pub fn swap_damage(&mut self) {\n+        let screen_lines = self.screen_lines;\n+        let columns = self.columns;\n+        self.frame().reset(screen_lines, columns);\n+        self.frames.swap(0, 1);\n+    }\n+\n+    /// Resize the damage information in the tracker.\n+    pub fn resize(&mut self, screen_lines: usize, columns: usize) {\n+        self.screen_lines = screen_lines;\n+        self.columns = columns;\n+        for frame in &mut self.frames {\n+            frame.reset(screen_lines, columns);\n+        }\n+        self.frame().damage_all = true;\n+    }\n+\n+    /// Damage vi cursor inside the viewport.\n+    pub fn damage_vi_cursor(&mut self, mut vi_cursor: Option<Point<usize>>) {\n+        mem::swap(&mut self.old_vi_cursor, &mut vi_cursor);\n+\n+        if self.frame().damage_all {\n+            return;\n+        }\n+\n+        if let Some(vi_cursor) = self.old_vi_cursor {\n+            self.frame().damage_point(vi_cursor);\n+        }\n+\n+        if let Some(vi_cursor) = vi_cursor {\n+            self.frame().damage_point(vi_cursor);\n+        }\n+    }\n+\n+    /// Get shaped frame damage for the active frame.\n+    pub fn shape_frame_damage(&self, size_info: SizeInfo<u32>) -> Vec<Rect> {\n+        if self.frames[0].damage_all {\n+            vec![Rect::new(0, 0, size_info.width() as i32, size_info.height() as i32)]\n+        } else {\n+            let lines_damage = RenderDamageIterator::new(\n+                TermDamageIterator::new(&self.frames[0].lines, 0),\n+                &size_info,\n+            );\n+            lines_damage.chain(self.frames[0].rects.iter().copied()).collect()\n+        }\n+    }\n+\n+    /// Set the selection adding the damage for the current frame.\n+    pub fn damage_selection(\n+        &mut self,\n+        mut selection: Option<SelectionRange>,\n+        display_offset: usize,\n+    ) {\n+        mem::swap(&mut self.old_selection, &mut selection);\n+\n+        if self.frame().damage_all {\n+            return;\n+        }\n+\n+        if selection != self.old_selection {",
        "comment_created_at": "2023-11-20T08:34:28+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "```suggestion\r\n        if self.frame().damage_all || selection == self.old_selection {\r\n            return;\r\n        }\r\n\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1269628617",
    "pr_number": 7085,
    "pr_file": "alacritty/src/display/content.rs",
    "created_at": "2023-07-20T15:23:06+00:00",
    "commented_code": "}\n \n     /// Apply [`CellRgb`] colors to the cell's colors.\n-    fn compute_cell_rgb(\n-        cell_fg: &mut Rgb,\n-        cell_bg: &mut Rgb,\n-        bg_alpha: &mut f32,\n-        fg: CellRgb,\n-        bg: CellRgb,\n-    ) {\n+    fn compute_cell_rgb(cell_fg: &mut Rgb, cell_bg: &mut Rgb, fg: CellRgb, bg: CellRgb) {\n         let old_fg = mem::replace(cell_fg, fg.color(*cell_fg, *cell_bg));\n         *cell_bg = bg.color(old_fg, *cell_bg);\n-\n-        if bg != CellRgb::CellBackground {\n-            *bg_alpha = 1.0;\n-        }",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1269628617",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7085,
        "pr_file": "alacritty/src/display/content.rs",
        "discussion_id": "1269628617",
        "commented_code": "@@ -287,19 +286,9 @@ impl RenderableCell {\n     }\n \n     /// Apply [`CellRgb`] colors to the cell's colors.\n-    fn compute_cell_rgb(\n-        cell_fg: &mut Rgb,\n-        cell_bg: &mut Rgb,\n-        bg_alpha: &mut f32,\n-        fg: CellRgb,\n-        bg: CellRgb,\n-    ) {\n+    fn compute_cell_rgb(cell_fg: &mut Rgb, cell_bg: &mut Rgb, fg: CellRgb, bg: CellRgb) {\n         let old_fg = mem::replace(cell_fg, fg.color(*cell_fg, *cell_bg));\n         *cell_bg = bg.color(old_fg, *cell_bg);\n-\n-        if bg != CellRgb::CellBackground {\n-            *bg_alpha = 1.0;\n-        }",
        "comment_created_at": "2023-07-20T15:23:06+00:00",
        "comment_author": "SonuBardai",
        "comment_body": "Could you please explain the rationale behind this? I understand that the alpha is set to 1.0 if the background differs from the actual background.. but this was the main reason why hints, selections, and search matches were opaque",
        "pr_file_module": null
      },
      {
        "comment_id": "1271327256",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7085,
        "pr_file": "alacritty/src/display/content.rs",
        "discussion_id": "1269628617",
        "commented_code": "@@ -287,19 +286,9 @@ impl RenderableCell {\n     }\n \n     /// Apply [`CellRgb`] colors to the cell's colors.\n-    fn compute_cell_rgb(\n-        cell_fg: &mut Rgb,\n-        cell_bg: &mut Rgb,\n-        bg_alpha: &mut f32,\n-        fg: CellRgb,\n-        bg: CellRgb,\n-    ) {\n+    fn compute_cell_rgb(cell_fg: &mut Rgb, cell_bg: &mut Rgb, fg: CellRgb, bg: CellRgb) {\n         let old_fg = mem::replace(cell_fg, fg.color(*cell_fg, *cell_bg));\n         *cell_bg = bg.color(old_fg, *cell_bg);\n-\n-        if bg != CellRgb::CellBackground {\n-            *bg_alpha = 1.0;\n-        }",
        "comment_created_at": "2023-07-22T18:07:02+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "If the `bg_alpha` is zero, then it won't be rendered regardless of what color it is. So when changing the background color you also need to make sure you're setting alpha again.\r\n\r\nWhy is the bg alpha 0 when it's the same as the cell background? Performance. It's unnecessary to draw a background for every cell when the background is the same as the terminal background anyway.",
        "pr_file_module": null
      },
      {
        "comment_id": "1272240328",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7085,
        "pr_file": "alacritty/src/display/content.rs",
        "discussion_id": "1269628617",
        "commented_code": "@@ -287,19 +286,9 @@ impl RenderableCell {\n     }\n \n     /// Apply [`CellRgb`] colors to the cell's colors.\n-    fn compute_cell_rgb(\n-        cell_fg: &mut Rgb,\n-        cell_bg: &mut Rgb,\n-        bg_alpha: &mut f32,\n-        fg: CellRgb,\n-        bg: CellRgb,\n-    ) {\n+    fn compute_cell_rgb(cell_fg: &mut Rgb, cell_bg: &mut Rgb, fg: CellRgb, bg: CellRgb) {\n         let old_fg = mem::replace(cell_fg, fg.color(*cell_fg, *cell_bg));\n         *cell_bg = bg.color(old_fg, *cell_bg);\n-\n-        if bg != CellRgb::CellBackground {\n-            *bg_alpha = 1.0;\n-        }",
        "comment_created_at": "2023-07-24T13:08:06+00:00",
        "comment_author": "SonuBardai",
        "comment_body": "Thankyou for the explanation! ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1269630744",
    "pr_number": 7085,
    "pr_file": "alacritty/src/display/content.rs",
    "created_at": "2023-07-20T15:24:18+00:00",
    "commented_code": "/// is computed.\n     #[inline]\n     fn compute_bg_alpha(config: &UiConfig, bg: Color) -> f32 {\n-        if bg == Color::Named(NamedColor::Background) {\n-            0.\n-        } else if config.colors.transparent_background_colors {\n+        if config.colors.transparent_background_colors {\n             config.window_opacity()",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1269630744",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7085,
        "pr_file": "alacritty/src/display/content.rs",
        "discussion_id": "1269630744",
        "commented_code": "@@ -366,10 +355,10 @@ impl RenderableCell {\n     /// is computed.\n     #[inline]\n     fn compute_bg_alpha(config: &UiConfig, bg: Color) -> f32 {\n-        if bg == Color::Named(NamedColor::Background) {\n-            0.\n-        } else if config.colors.transparent_background_colors {\n+        if config.colors.transparent_background_colors {\n             config.window_opacity()",
        "comment_created_at": "2023-07-20T15:24:18+00:00",
        "comment_author": "SonuBardai",
        "comment_body": "Could you please help me understand the order of these checks? I wasn't sure if there's an edge case that led us to put it this way",
        "pr_file_module": null
      },
      {
        "comment_id": "1271327395",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7085,
        "pr_file": "alacritty/src/display/content.rs",
        "discussion_id": "1269630744",
        "commented_code": "@@ -366,10 +355,10 @@ impl RenderableCell {\n     /// is computed.\n     #[inline]\n     fn compute_bg_alpha(config: &UiConfig, bg: Color) -> f32 {\n-        if bg == Color::Named(NamedColor::Background) {\n-            0.\n-        } else if config.colors.transparent_background_colors {\n+        if config.colors.transparent_background_colors {\n             config.window_opacity()",
        "comment_created_at": "2023-07-22T18:08:23+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "If it's the same as the background color, we're not drawing anything anyway. So it doesn't matter what you set your `window_opacity` to. Making it *less* transparent than 0 will just cause it to be rendered, which is a waste of time since you can't see it anyway.",
        "pr_file_module": null
      }
    ]
  }
]