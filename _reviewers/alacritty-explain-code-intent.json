[
  {
    "discussion_id": "1911103771",
    "pr_number": 6530,
    "pr_file": "alacritty/src/display/mod.rs",
    "created_at": "2025-01-10T19:35:33+00:00",
    "commented_code": "}\n     }\n \n-    pub fn make_current(&self) {\n-        if !self.context.get().is_current() {\n-            self.context.make_current(&self.surface).expect(\"failed to make context current\")\n+    pub fn make_current(&mut self, recover: bool) {\n+        let is_current = self.context.get().is_current();\n+        if is_current && !recover {\n+            return;\n+        }\n+\n+        let mut was_context_reset = if is_current {\n+            false\n+        } else {\n+            match self.context.make_current(&self.surface) {\n+                Err(err) if err.error_kind() == ErrorKind::ContextLost => {\n+                    info!(\"Context lost for window {:?}\", self.window.id());\n+                    true\n+                },\n+                _ => false,\n+            }\n+        };",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1911103771",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6530,
        "pr_file": "alacritty/src/display/mod.rs",
        "discussion_id": "1911103771",
        "commented_code": "@@ -552,9 +558,59 @@ impl Display {\n         }\n     }\n \n-    pub fn make_current(&self) {\n-        if !self.context.get().is_current() {\n-            self.context.make_current(&self.surface).expect(\"failed to make context current\")\n+    pub fn make_current(&mut self, recover: bool) {\n+        let is_current = self.context.get().is_current();\n+        if is_current && !recover {\n+            return;\n+        }\n+\n+        let mut was_context_reset = if is_current {\n+            false\n+        } else {\n+            match self.context.make_current(&self.surface) {\n+                Err(err) if err.error_kind() == ErrorKind::ContextLost => {\n+                    info!(\"Context lost for window {:?}\", self.window.id());\n+                    true\n+                },\n+                _ => false,\n+            }\n+        };",
        "comment_created_at": "2025-01-10T19:35:33+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "```suggestion\r\n        // Attempt to make the context current, if it is not.\r\n        let mut was_context_reset = if is_current {\r\n            false\r\n        } else {\r\n            match self.context.make_current(&self.surface) {\r\n                Err(err) if err.error_kind() == ErrorKind::ContextLost => {\r\n                    info!(\"Context lost for window {:?}\", self.window.id());\r\n                    true\r\n                },\r\n                _ => false,\r\n            }\r\n        };\r\n```\r\n\r\nI think a comment here is nice to explain that our goal here is not just checking if the context was reset, but actually performing the make_current call.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1514153710",
    "pr_number": 7788,
    "pr_file": "alacritty_terminal/src/tty/windows/conpty.rs",
    "created_at": "2024-03-06T09:45:47+00:00",
    "commented_code": "Some(Pty::new(conpty, conout, conin, child_watcher))\n }\n \n+fn convert_custom_env(custom_env: &HashMap<String, String>) -> Option<Vec<u16>> {\n+    let mut result = Vec::new();\n+    if custom_env.is_empty() {\n+        return None;\n+    }\n+\n+    let mut all_env_keys = HashSet::new();\n+    for (custom_key, custom_value) in custom_env {\n+        let custom_key = OsStr::new(custom_key);\n+        if all_env_keys.insert(custom_key.to_ascii_uppercase()) {\n+            result.extend(custom_key.encode_wide());\n+            result.push('=' as u16);\n+            result.extend(OsStr::new(custom_value).encode_wide());\n+            result.push(0);\n+        }\n+    }\n+    for (inherited_key, inherited_value) in std::env::vars_os() {\n+        if all_env_keys.insert(inherited_key.to_ascii_uppercase()) {\n+            result.extend(inherited_key.encode_wide());\n+            result.push('=' as u16);\n+            result.extend(inherited_value.encode_wide());\n+            result.push(0);\n+        }\n+    }\n+    result.push(0);",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1514153710",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7788,
        "pr_file": "alacritty_terminal/src/tty/windows/conpty.rs",
        "discussion_id": "1514153710",
        "commented_code": "@@ -230,6 +241,35 @@ pub fn new(config: &Options, window_size: WindowSize) -> Option<Pty> {\n     Some(Pty::new(conpty, conout, conin, child_watcher))\n }\n \n+fn convert_custom_env(custom_env: &HashMap<String, String>) -> Option<Vec<u16>> {\n+    let mut result = Vec::new();\n+    if custom_env.is_empty() {\n+        return None;\n+    }\n+\n+    let mut all_env_keys = HashSet::new();\n+    for (custom_key, custom_value) in custom_env {\n+        let custom_key = OsStr::new(custom_key);\n+        if all_env_keys.insert(custom_key.to_ascii_uppercase()) {\n+            result.extend(custom_key.encode_wide());\n+            result.push('=' as u16);\n+            result.extend(OsStr::new(custom_value).encode_wide());\n+            result.push(0);\n+        }\n+    }\n+    for (inherited_key, inherited_value) in std::env::vars_os() {\n+        if all_env_keys.insert(inherited_key.to_ascii_uppercase()) {\n+            result.extend(inherited_key.encode_wide());\n+            result.push('=' as u16);\n+            result.extend(inherited_value.encode_wide());\n+            result.push(0);\n+        }\n+    }\n+    result.push(0);",
        "comment_created_at": "2024-03-06T09:45:47+00:00",
        "comment_author": "kchibisov",
        "comment_body": "Document why it's done like that. Like it's not really clear why you need `0`, `0` at the end.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1440451489",
    "pr_number": 7536,
    "pr_file": "alacritty/src/config/mod.rs",
    "created_at": "2024-01-03T13:26:42+00:00",
    "commented_code": "Ok(import_paths)\n }\n \n+/// Prune the nulls from the YAML.",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1440451489",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7536,
        "pr_file": "alacritty/src/config/mod.rs",
        "discussion_id": "1440451489",
        "commented_code": "@@ -318,6 +319,32 @@ pub fn imports(\n     Ok(import_paths)\n }\n \n+/// Prune the nulls from the YAML.",
        "comment_created_at": "2024-01-03T13:26:42+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Maybe we should add a comment *why* one would want to do this?\r\n\r\nSo something like \"to ensure toml compatibility\" or something.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1359078224",
    "pr_number": 7125,
    "pr_file": "alacritty/src/input.rs",
    "created_at": "2023-10-14T02:47:00+00:00",
    "commented_code": "/// Process key input.\n     pub fn key_input(&mut self, key: KeyEvent) {\n         // IME input will be applied on commit and shouldn't trigger key bindings.\n-        if key.state == ElementState::Released || self.ctx.display().ime.preedit().is_some() {\n+        if self.ctx.display().ime.preedit().is_some() {\n+            return;\n+        }\n+\n+        let mode = *self.ctx.terminal().mode();\n+        let mods = self.ctx.modifiers().state();\n+\n+        if key.state == ElementState::Released {\n+            if mode.contains(TermMode::KEYBOARD_REPORT_EVENT_TYPES)",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1359078224",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7125,
        "pr_file": "alacritty/src/input.rs",
        "discussion_id": "1359078224",
        "commented_code": "@@ -1002,7 +1002,33 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n     /// Process key input.\n     pub fn key_input(&mut self, key: KeyEvent) {\n         // IME input will be applied on commit and shouldn't trigger key bindings.\n-        if key.state == ElementState::Released || self.ctx.display().ime.preedit().is_some() {\n+        if self.ctx.display().ime.preedit().is_some() {\n+            return;\n+        }\n+\n+        let mode = *self.ctx.terminal().mode();\n+        let mods = self.ctx.modifiers().state();\n+\n+        if key.state == ElementState::Released {\n+            if mode.contains(TermMode::KEYBOARD_REPORT_EVENT_TYPES)",
        "comment_created_at": "2023-10-14T02:47:00+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "This method is getting very long, the least we should be doing is adding comments on all the individual code blocks for what they do.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1396569832",
    "pr_number": 7362,
    "pr_file": "alacritty/src/renderer/text/builtin_font.rs",
    "created_at": "2023-11-17T01:32:22+00:00",
    "commented_code": "fn powerline_drawing(character: char, metrics: &Metrics, offset: &Delta<i8>) -> RasterizedGlyph {\n     let height = (metrics.line_height as i32 + offset.y as i32) as usize;\n     let width = (metrics.average_advance as i32 + offset.x as i32) as usize;\n-    // Use one eight of the cell width, since this is used as a step size for block elements.\n-    let stroke_size = cmp::max((width as f32 / 8.).round() as usize, 1) as f32;\n+    let extra_thickness = calculate_stroke_size(width) as i32 - 1;\n \n     let mut canvas = Canvas::new(width, height);\n \n-    let y_center = (height - 1) as f32 / 2.;\n-    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n-    // g(x) = H - x + 1 lines. The intersection happens when f(x) = g(x), which is at\n-    // x = H/2 (`y_center`).\n-    let from_y = 1;\n-    let x_end = y_center.floor();\n-    let y_end = (height - from_y - 1) as f32;\n-\n-    // Pick the start point outside of the canvas to even-out the start.\n-    let from_x = 0.;\n-    let to_x = x_end;\n-    canvas.draw_line_grid(from_x, from_y as f32, to_x, y_center.floor());\n-    canvas.draw_line_grid(from_x, y_end, to_x, y_center.ceil());\n-\n-    // For regular arrows we handle thickness by drawing 2 angle arrows and then just filling\n-    // the contents between them.\n-    if (character == '\\u{e0b1}' || character == '\\u{e0b3}') && stroke_size > 1. {\n-        // The default line is of stroke size 1, so the 0.5 is computed by subtracting 1 from\n-        // stroke_size and then adding 0.5 to to put the target in the center of the cell.\n-        let to_x = x_end - stroke_size;\n-        canvas.draw_line_grid(from_x, from_y as f32 + stroke_size, to_x, y_center.floor());\n-        canvas.draw_line_grid(from_x, y_end - stroke_size, to_x, y_center.ceil());\n-    }\n+    let slope = 1;\n+    let f_y0 = 1;\n+    let g_y0 = height as i32 - f_y0 - 1;\n \n-    let buffer = canvas.buffer_mut();\n-    if character == '\\u{e0b0}' || character == '\\u{e0b2}' {\n-        for row in from_y..height - from_y {\n-            let row_offset = row * width;\n-            for index in 1..width {\n-                let index = row_offset + index;\n-                if buffer[index - 1]._r > buffer[index]._r && buffer[index]._r == 0 {\n-                    break;\n-                }\n-\n-                buffer[index - 1] = COLOR_FILL;\n-            }\n-        }\n-    } else if stroke_size > 1. {\n-        // Find the bottom/top most points of extra line we draw, so we can properly set the\n-        // `start`.\n-\n-        let mut y1 = 0;\n-        for row in (0..height / 2).rev() {\n-            if buffer[row * width]._r != 0 {\n-                y1 = row;\n-                break;\n-            }\n-        }\n-        let mut y2 = height / 2;\n-        for row in height / 2..height {\n-            if buffer[row * width]._r != 0 {\n-                y2 = row;\n+    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n+    // g(x) = H - x - 1 lines. The intersection happens when f(x) = g(x), which is at\n+    // x = H/2 - 1.\n+    let intersection = (height as i32 + 1) / 2 - 1;\n+\n+    let f_x = LineEquation::new(slope, f_y0, 0, intersection);\n+    let g_x = LineEquation::new(-slope, g_y0, 0, intersection);\n+\n+    // Inner functions to make arrows thicker.\n+    let mut f_x_inner =\n+        LineEquation::new(slope, f_y0 + extra_thickness, 0, intersection - extra_thickness);\n+    let mut g_x_inner =\n+        LineEquation::new(-slope, g_y0 - extra_thickness, 0, intersection - extra_thickness);\n+\n+    // NOTE f_x and g_x have the same amount of iterations.\n+    for (p1, p2) in iter::zip(f_x, g_x) {\n+        if character == POWERLINE_TRIANGLE || character == POWERLINE_TRIANGLE_FLIPPED {\n+            canvas.draw_rect(0., p1.1, p1.0 + 1., 1., COLOR_FILL);\n+            canvas.draw_rect(0., p2.1, p2.0 + 1., 1., COLOR_FILL);\n+        } else if character == POWERLINE_ARROW || character == POWERLINE_ARROW_FLIPPED {\n+            let p3 = f_x_inner.next().unwrap_or(p2);\n+            let p4 = g_x_inner.next().unwrap_or(p1);\n+\n+            // Once we reach the canvas end fill the area between f(x) and g(x) to make a proper\n+            // cut.",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1396569832",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7362,
        "pr_file": "alacritty/src/renderer/text/builtin_font.rs",
        "discussion_id": "1396569832",
        "commented_code": "@@ -500,106 +506,50 @@ fn box_drawing(character: char, metrics: &Metrics, offset: &Delta<i8>) -> Raster\n fn powerline_drawing(character: char, metrics: &Metrics, offset: &Delta<i8>) -> RasterizedGlyph {\n     let height = (metrics.line_height as i32 + offset.y as i32) as usize;\n     let width = (metrics.average_advance as i32 + offset.x as i32) as usize;\n-    // Use one eight of the cell width, since this is used as a step size for block elements.\n-    let stroke_size = cmp::max((width as f32 / 8.).round() as usize, 1) as f32;\n+    let extra_thickness = calculate_stroke_size(width) as i32 - 1;\n \n     let mut canvas = Canvas::new(width, height);\n \n-    let y_center = (height - 1) as f32 / 2.;\n-    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n-    // g(x) = H - x + 1 lines. The intersection happens when f(x) = g(x), which is at\n-    // x = H/2 (`y_center`).\n-    let from_y = 1;\n-    let x_end = y_center.floor();\n-    let y_end = (height - from_y - 1) as f32;\n-\n-    // Pick the start point outside of the canvas to even-out the start.\n-    let from_x = 0.;\n-    let to_x = x_end;\n-    canvas.draw_line_grid(from_x, from_y as f32, to_x, y_center.floor());\n-    canvas.draw_line_grid(from_x, y_end, to_x, y_center.ceil());\n-\n-    // For regular arrows we handle thickness by drawing 2 angle arrows and then just filling\n-    // the contents between them.\n-    if (character == '\\u{e0b1}' || character == '\\u{e0b3}') && stroke_size > 1. {\n-        // The default line is of stroke size 1, so the 0.5 is computed by subtracting 1 from\n-        // stroke_size and then adding 0.5 to to put the target in the center of the cell.\n-        let to_x = x_end - stroke_size;\n-        canvas.draw_line_grid(from_x, from_y as f32 + stroke_size, to_x, y_center.floor());\n-        canvas.draw_line_grid(from_x, y_end - stroke_size, to_x, y_center.ceil());\n-    }\n+    let slope = 1;\n+    let f_y0 = 1;\n+    let g_y0 = height as i32 - f_y0 - 1;\n \n-    let buffer = canvas.buffer_mut();\n-    if character == '\\u{e0b0}' || character == '\\u{e0b2}' {\n-        for row in from_y..height - from_y {\n-            let row_offset = row * width;\n-            for index in 1..width {\n-                let index = row_offset + index;\n-                if buffer[index - 1]._r > buffer[index]._r && buffer[index]._r == 0 {\n-                    break;\n-                }\n-\n-                buffer[index - 1] = COLOR_FILL;\n-            }\n-        }\n-    } else if stroke_size > 1. {\n-        // Find the bottom/top most points of extra line we draw, so we can properly set the\n-        // `start`.\n-\n-        let mut y1 = 0;\n-        for row in (0..height / 2).rev() {\n-            if buffer[row * width]._r != 0 {\n-                y1 = row;\n-                break;\n-            }\n-        }\n-        let mut y2 = height / 2;\n-        for row in height / 2..height {\n-            if buffer[row * width]._r != 0 {\n-                y2 = row;\n+    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n+    // g(x) = H - x - 1 lines. The intersection happens when f(x) = g(x), which is at\n+    // x = H/2 - 1.\n+    let intersection = (height as i32 + 1) / 2 - 1;\n+\n+    let f_x = LineEquation::new(slope, f_y0, 0, intersection);\n+    let g_x = LineEquation::new(-slope, g_y0, 0, intersection);\n+\n+    // Inner functions to make arrows thicker.\n+    let mut f_x_inner =\n+        LineEquation::new(slope, f_y0 + extra_thickness, 0, intersection - extra_thickness);\n+    let mut g_x_inner =\n+        LineEquation::new(-slope, g_y0 - extra_thickness, 0, intersection - extra_thickness);\n+\n+    // NOTE f_x and g_x have the same amount of iterations.\n+    for (p1, p2) in iter::zip(f_x, g_x) {\n+        if character == POWERLINE_TRIANGLE || character == POWERLINE_TRIANGLE_FLIPPED {\n+            canvas.draw_rect(0., p1.1, p1.0 + 1., 1., COLOR_FILL);\n+            canvas.draw_rect(0., p2.1, p2.0 + 1., 1., COLOR_FILL);\n+        } else if character == POWERLINE_ARROW || character == POWERLINE_ARROW_FLIPPED {\n+            let p3 = f_x_inner.next().unwrap_or(p2);\n+            let p4 = g_x_inner.next().unwrap_or(p1);\n+\n+            // Once we reach the canvas end fill the area between f(x) and g(x) to make a proper\n+            // cut.",
        "comment_created_at": "2023-11-17T01:32:22+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "This took me a second to figure out, I think it might be nice to be a little more verbose:\r\n\r\n```\r\n// If we can't fit the entire arrow in the cell, we cut off the tip of the arrow by drawing a rectangle between the two lines.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "909388187",
    "pr_number": 6139,
    "pr_file": "alacritty/src/display/hint.rs",
    "created_at": "2022-06-29T09:08:00+00:00",
    "commented_code": "return None;\n         }\n \n-        hint.regex.with_compiled(|regex| {\n-            // Setup search boundaries.\n-            let mut start = term.line_search_left(point);\n-            start.line = max(start.line, point.line - MAX_SEARCH_LINES);\n-            let mut end = term.line_search_right(point);\n-            end.line = min(end.line, point.line + MAX_SEARCH_LINES);\n+        if let Some((hyperlink, bounds)) =\n+            hint.content.hyperlinks.then(|| hyperlink_at(term, point)).flatten()\n+        {\n+            return Some(HintMatch::Hyperlink { bounds, action: hint.action.clone(), hyperlink });\n+        }\n \n-            // Function to verify that the specified point is inside the match.\n-            let at_point = |rm: &Match| *rm.end() >= point && *rm.start() <= point;\n+        if let Some(bounds) = hint.content.regex.as_ref().and_then(|regex| {\n+            regex.with_compiled(|regex| regex_match_at(term, point, regex, hint.post_processing))\n+        }) {\n+            return Some(HintMatch::Regex { bounds, action: hint.action.clone() });\n+        }\n \n-            // Check if there's any match at the specified point.\n-            let mut iter = RegexIter::new(start, end, Direction::Right, term, regex);\n-            let regex_match = iter.find(at_point)?;\n+        None\n+    })\n+}\n \n-            // Apply post-processing and search for sub-matches if necessary.\n-            let regex_match = if hint.post_processing {\n-                HintPostProcessor::new(term, regex, regex_match).find(at_point)\n-            } else {\n-                Some(regex_match)\n-            };\n+/// Retrive the hyperlink with its range, if there is one at the specified point.\n+fn hyperlink_at<T>(term: &Term<T>, point: Point) -> Option<(Hyperlink, Match)> {\n+    let hyperlink = term.grid()[point].hyperlink()?;\n+\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+\n+    let mut match_start = Point::new(point.line, Column(0));\n+    let mut match_end = Point::new(point.line, Column(term.columns() - 1));\n+    let grid = term.grid();\n+\n+    // Find start and end line containing the same hyperlink inside viewport that is adjustsent to\n+    // the requested point's line.\n+\n+    // Find start.\n+    loop {\n+        let next_line = match_start.line - 1i32;\n+        if next_line < viewport_start\n+            || !grid[next_line]\n+                .into_iter()\n+                .any(|cell| cell.hyperlink().map(|h| h == hyperlink).unwrap_or(false))",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "909388187",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/hint.rs",
        "discussion_id": "909388187",
        "commented_code": "@@ -258,30 +381,65 @@ pub fn highlighted_at<T>(\n             return None;\n         }\n \n-        hint.regex.with_compiled(|regex| {\n-            // Setup search boundaries.\n-            let mut start = term.line_search_left(point);\n-            start.line = max(start.line, point.line - MAX_SEARCH_LINES);\n-            let mut end = term.line_search_right(point);\n-            end.line = min(end.line, point.line + MAX_SEARCH_LINES);\n+        if let Some((hyperlink, bounds)) =\n+            hint.content.hyperlinks.then(|| hyperlink_at(term, point)).flatten()\n+        {\n+            return Some(HintMatch::Hyperlink { bounds, action: hint.action.clone(), hyperlink });\n+        }\n \n-            // Function to verify that the specified point is inside the match.\n-            let at_point = |rm: &Match| *rm.end() >= point && *rm.start() <= point;\n+        if let Some(bounds) = hint.content.regex.as_ref().and_then(|regex| {\n+            regex.with_compiled(|regex| regex_match_at(term, point, regex, hint.post_processing))\n+        }) {\n+            return Some(HintMatch::Regex { bounds, action: hint.action.clone() });\n+        }\n \n-            // Check if there's any match at the specified point.\n-            let mut iter = RegexIter::new(start, end, Direction::Right, term, regex);\n-            let regex_match = iter.find(at_point)?;\n+        None\n+    })\n+}\n \n-            // Apply post-processing and search for sub-matches if necessary.\n-            let regex_match = if hint.post_processing {\n-                HintPostProcessor::new(term, regex, regex_match).find(at_point)\n-            } else {\n-                Some(regex_match)\n-            };\n+/// Retrive the hyperlink with its range, if there is one at the specified point.\n+fn hyperlink_at<T>(term: &Term<T>, point: Point) -> Option<(Hyperlink, Match)> {\n+    let hyperlink = term.grid()[point].hyperlink()?;\n+\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+\n+    let mut match_start = Point::new(point.line, Column(0));\n+    let mut match_end = Point::new(point.line, Column(term.columns() - 1));\n+    let grid = term.grid();\n+\n+    // Find start and end line containing the same hyperlink inside viewport that is adjustsent to\n+    // the requested point's line.\n+\n+    // Find start.\n+    loop {\n+        let next_line = match_start.line - 1i32;\n+        if next_line < viewport_start\n+            || !grid[next_line]\n+                .into_iter()\n+                .any(|cell| cell.hyperlink().map(|h| h == hyperlink).unwrap_or(false))",
        "comment_created_at": "2022-06-29T09:08:00+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "It's not immediately clear what this does, should be documented, probably extracted in a separate variable with a nice name.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "909388278",
    "pr_number": 6139,
    "pr_file": "alacritty/src/display/hint.rs",
    "created_at": "2022-06-29T09:08:06+00:00",
    "commented_code": "return None;\n         }\n \n-        hint.regex.with_compiled(|regex| {\n-            // Setup search boundaries.\n-            let mut start = term.line_search_left(point);\n-            start.line = max(start.line, point.line - MAX_SEARCH_LINES);\n-            let mut end = term.line_search_right(point);\n-            end.line = min(end.line, point.line + MAX_SEARCH_LINES);\n+        if let Some((hyperlink, bounds)) =\n+            hint.content.hyperlinks.then(|| hyperlink_at(term, point)).flatten()\n+        {\n+            return Some(HintMatch::Hyperlink { bounds, action: hint.action.clone(), hyperlink });\n+        }\n \n-            // Function to verify that the specified point is inside the match.\n-            let at_point = |rm: &Match| *rm.end() >= point && *rm.start() <= point;\n+        if let Some(bounds) = hint.content.regex.as_ref().and_then(|regex| {\n+            regex.with_compiled(|regex| regex_match_at(term, point, regex, hint.post_processing))\n+        }) {\n+            return Some(HintMatch::Regex { bounds, action: hint.action.clone() });\n+        }\n \n-            // Check if there's any match at the specified point.\n-            let mut iter = RegexIter::new(start, end, Direction::Right, term, regex);\n-            let regex_match = iter.find(at_point)?;\n+        None\n+    })\n+}\n \n-            // Apply post-processing and search for sub-matches if necessary.\n-            let regex_match = if hint.post_processing {\n-                HintPostProcessor::new(term, regex, regex_match).find(at_point)\n-            } else {\n-                Some(regex_match)\n-            };\n+/// Retrive the hyperlink with its range, if there is one at the specified point.\n+fn hyperlink_at<T>(term: &Term<T>, point: Point) -> Option<(Hyperlink, Match)> {\n+    let hyperlink = term.grid()[point].hyperlink()?;\n+\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+\n+    let mut match_start = Point::new(point.line, Column(0));\n+    let mut match_end = Point::new(point.line, Column(term.columns() - 1));\n+    let grid = term.grid();\n+\n+    // Find start and end line containing the same hyperlink inside viewport that is adjustsent to\n+    // the requested point's line.\n+\n+    // Find start.\n+    loop {\n+        let next_line = match_start.line - 1i32;\n+        if next_line < viewport_start\n+            || !grid[next_line]\n+                .into_iter()\n+                .any(|cell| cell.hyperlink().map(|h| h == hyperlink).unwrap_or(false))\n+        {\n+            break;\n+        }\n \n-            regex_match.map(|bounds| HintMatch { action: hint.action.clone(), bounds })\n-        })\n-    })\n+        match_start.line = next_line;\n+    }\n+\n+    // Find end.\n+    loop {\n+        let next_line = match_end.line + 1i32;\n+        if next_line >= viewport_end\n+            || !grid[next_line]\n+                .into_iter()\n+                .any(|cell| cell.hyperlink().map(|h| h == hyperlink).unwrap_or(false))",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "909388278",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/hint.rs",
        "discussion_id": "909388278",
        "commented_code": "@@ -258,30 +381,65 @@ pub fn highlighted_at<T>(\n             return None;\n         }\n \n-        hint.regex.with_compiled(|regex| {\n-            // Setup search boundaries.\n-            let mut start = term.line_search_left(point);\n-            start.line = max(start.line, point.line - MAX_SEARCH_LINES);\n-            let mut end = term.line_search_right(point);\n-            end.line = min(end.line, point.line + MAX_SEARCH_LINES);\n+        if let Some((hyperlink, bounds)) =\n+            hint.content.hyperlinks.then(|| hyperlink_at(term, point)).flatten()\n+        {\n+            return Some(HintMatch::Hyperlink { bounds, action: hint.action.clone(), hyperlink });\n+        }\n \n-            // Function to verify that the specified point is inside the match.\n-            let at_point = |rm: &Match| *rm.end() >= point && *rm.start() <= point;\n+        if let Some(bounds) = hint.content.regex.as_ref().and_then(|regex| {\n+            regex.with_compiled(|regex| regex_match_at(term, point, regex, hint.post_processing))\n+        }) {\n+            return Some(HintMatch::Regex { bounds, action: hint.action.clone() });\n+        }\n \n-            // Check if there's any match at the specified point.\n-            let mut iter = RegexIter::new(start, end, Direction::Right, term, regex);\n-            let regex_match = iter.find(at_point)?;\n+        None\n+    })\n+}\n \n-            // Apply post-processing and search for sub-matches if necessary.\n-            let regex_match = if hint.post_processing {\n-                HintPostProcessor::new(term, regex, regex_match).find(at_point)\n-            } else {\n-                Some(regex_match)\n-            };\n+/// Retrive the hyperlink with its range, if there is one at the specified point.\n+fn hyperlink_at<T>(term: &Term<T>, point: Point) -> Option<(Hyperlink, Match)> {\n+    let hyperlink = term.grid()[point].hyperlink()?;\n+\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+\n+    let mut match_start = Point::new(point.line, Column(0));\n+    let mut match_end = Point::new(point.line, Column(term.columns() - 1));\n+    let grid = term.grid();\n+\n+    // Find start and end line containing the same hyperlink inside viewport that is adjustsent to\n+    // the requested point's line.\n+\n+    // Find start.\n+    loop {\n+        let next_line = match_start.line - 1i32;\n+        if next_line < viewport_start\n+            || !grid[next_line]\n+                .into_iter()\n+                .any(|cell| cell.hyperlink().map(|h| h == hyperlink).unwrap_or(false))\n+        {\n+            break;\n+        }\n \n-            regex_match.map(|bounds| HintMatch { action: hint.action.clone(), bounds })\n-        })\n-    })\n+        match_start.line = next_line;\n+    }\n+\n+    // Find end.\n+    loop {\n+        let next_line = match_end.line + 1i32;\n+        if next_line >= viewport_end\n+            || !grid[next_line]\n+                .into_iter()\n+                .any(|cell| cell.hyperlink().map(|h| h == hyperlink).unwrap_or(false))",
        "comment_created_at": "2022-06-29T09:08:06+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "It's not immediately clear what this does, should be documented, probably extracted in a separate variable with a nice name.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "909390510",
    "pr_number": 6139,
    "pr_file": "alacritty_terminal/src/ansi.rs",
    "created_at": "2022-06-29T09:10:12+00:00",
    "commented_code": "}\n             },\n \n+            // Hyperlink.\n+            b\"8\" if params.len() > 2 => {\n+                let link_params = params[1];\n+                let uri = str::from_utf8(params[2]).unwrap_or_default();\n+                if uri.is_empty() {\n+                    self.handler.set_hyperlink(None);\n+                    return;\n+                }",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "909390510",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty_terminal/src/ansi.rs",
        "discussion_id": "909390510",
        "commented_code": "@@ -1007,6 +1011,25 @@ where\n                 }\n             },\n \n+            // Hyperlink.\n+            b\"8\" if params.len() > 2 => {\n+                let link_params = params[1];\n+                let uri = str::from_utf8(params[2]).unwrap_or_default();\n+                if uri.is_empty() {\n+                    self.handler.set_hyperlink(None);\n+                    return;\n+                }",
        "comment_created_at": "2022-06-29T09:10:12+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "This should be made more clear, probably by adding a comment and newline as separation. It's not just some error handling, this is how hyperlinks are stopped.",
        "pr_file_module": null
      }
    ]
  }
]