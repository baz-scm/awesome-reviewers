[
  {
    "discussion_id": "2202007317",
    "pr_number": 8622,
    "pr_file": "alacritty_terminal/src/grid/mod.rs",
    "created_at": "2025-07-11T22:38:39+00:00",
    "commented_code": "match self.point {\n             Point { column, .. } if column == self.grid.last_column() => {\n                 self.point.column = Column(0);\n-                self.point.line += 1;\n+                self.point.line += Line(1);\n             },\n             _ => self.point.column += Column(1),\n         }\n \n         Some(Indexed { cell: &self.grid[self.point], point: self.point })\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.point >= self.end {\n+            return (0, Some(0));\n+        }\n+\n+        let size = if self.point.line == self.end.line {\n+            self.end.column.saturating_sub(self.point.column.0)\n+        } else {\n+            let first_line = self.grid.columns.saturating_sub(self.point.column.0);\n+\n+            // How many lines in total separate start from end?\n+            let total_lines = (self.end.line - self.point.line).0 as usize;\n+            let middle_lines = total_lines.saturating_sub(1);",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "2202007317",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 8622,
        "pr_file": "alacritty_terminal/src/grid/mod.rs",
        "discussion_id": "2202007317",
        "commented_code": "@@ -601,13 +601,34 @@ impl<'a, T> Iterator for GridIterator<'a, T> {\n         match self.point {\n             Point { column, .. } if column == self.grid.last_column() => {\n                 self.point.column = Column(0);\n-                self.point.line += 1;\n+                self.point.line += Line(1);\n             },\n             _ => self.point.column += Column(1),\n         }\n \n         Some(Indexed { cell: &self.grid[self.point], point: self.point })\n     }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.point >= self.end {\n+            return (0, Some(0));\n+        }\n+\n+        let size = if self.point.line == self.end.line {\n+            self.end.column.saturating_sub(self.point.column.0)\n+        } else {\n+            let first_line = self.grid.columns.saturating_sub(self.point.column.0);\n+\n+            // How many lines in total separate start from end?\n+            let total_lines = (self.end.line - self.point.line).0 as usize;\n+            let middle_lines = total_lines.saturating_sub(1);",
        "comment_created_at": "2025-07-11T22:38:39+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "No need for saturating here, point.line cannot be bigger than end.line. At that point it's probably also fine to just put it all on a single line.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1519735406",
    "pr_number": 7824,
    "pr_file": "alacritty/src/display/hint.rs",
    "created_at": "2024-03-11T13:39:34+00:00",
    "commented_code": "impl HintMatch {\n     #[inline]\n     pub fn should_highlight(&self, point: Point, pointed_hyperlink: Option<&Hyperlink>) -> bool {\n-        self.bounds.contains(&point) && self.hyperlink.as_ref() == pointed_hyperlink\n+        self.hyperlink.as_ref() == pointed_hyperlink\n+            && (self.hyperlink.is_some() || self.bounds.contains(&point))",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1519735406",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/display/hint.rs",
        "discussion_id": "1519735406",
        "commented_code": "@@ -204,7 +204,8 @@ pub struct HintMatch {\n impl HintMatch {\n     #[inline]\n     pub fn should_highlight(&self, point: Point, pointed_hyperlink: Option<&Hyperlink>) -> bool {\n-        self.bounds.contains(&point) && self.hyperlink.as_ref() == pointed_hyperlink\n+        self.hyperlink.as_ref() == pointed_hyperlink\n+            && (self.hyperlink.is_some() || self.bounds.contains(&point))",
        "comment_created_at": "2024-03-11T13:39:34+00:00",
        "comment_author": "kchibisov",
        "comment_body": "What the reason to check `is_some`, I think it's already covered? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1520357730",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7824,
        "pr_file": "alacritty/src/display/hint.rs",
        "discussion_id": "1519735406",
        "commented_code": "@@ -204,7 +204,8 @@ pub struct HintMatch {\n impl HintMatch {\n     #[inline]\n     pub fn should_highlight(&self, point: Point, pointed_hyperlink: Option<&Hyperlink>) -> bool {\n-        self.bounds.contains(&point) && self.hyperlink.as_ref() == pointed_hyperlink\n+        self.hyperlink.as_ref() == pointed_hyperlink\n+            && (self.hyperlink.is_some() || self.bounds.contains(&point))",
        "comment_created_at": "2024-03-11T19:58:43+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "If it's a hyperlink escape, we ALWAYS highlight regardless of the bounds. If we don't check for `is_some`, we'd only highlight within bounds.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1396568138",
    "pr_number": 7362,
    "pr_file": "alacritty/src/renderer/text/builtin_font.rs",
    "created_at": "2023-11-17T01:29:23+00:00",
    "commented_code": "fn powerline_drawing(character: char, metrics: &Metrics, offset: &Delta<i8>) -> RasterizedGlyph {\n     let height = (metrics.line_height as i32 + offset.y as i32) as usize;\n     let width = (metrics.average_advance as i32 + offset.x as i32) as usize;\n-    // Use one eight of the cell width, since this is used as a step size for block elements.\n-    let stroke_size = cmp::max((width as f32 / 8.).round() as usize, 1) as f32;\n+    let extra_thickness = calculate_stroke_size(width) as i32 - 1;\n \n     let mut canvas = Canvas::new(width, height);\n \n-    let y_center = (height - 1) as f32 / 2.;\n-    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n-    // g(x) = H - x + 1 lines. The intersection happens when f(x) = g(x), which is at\n-    // x = H/2 (`y_center`).\n-    let from_y = 1;\n-    let x_end = y_center.floor();\n-    let y_end = (height - from_y - 1) as f32;\n-\n-    // Pick the start point outside of the canvas to even-out the start.\n-    let from_x = 0.;\n-    let to_x = x_end;\n-    canvas.draw_line_grid(from_x, from_y as f32, to_x, y_center.floor());\n-    canvas.draw_line_grid(from_x, y_end, to_x, y_center.ceil());\n-\n-    // For regular arrows we handle thickness by drawing 2 angle arrows and then just filling\n-    // the contents between them.\n-    if (character == '\\u{e0b1}' || character == '\\u{e0b3}') && stroke_size > 1. {\n-        // The default line is of stroke size 1, so the 0.5 is computed by subtracting 1 from\n-        // stroke_size and then adding 0.5 to to put the target in the center of the cell.\n-        let to_x = x_end - stroke_size;\n-        canvas.draw_line_grid(from_x, from_y as f32 + stroke_size, to_x, y_center.floor());\n-        canvas.draw_line_grid(from_x, y_end - stroke_size, to_x, y_center.ceil());\n-    }\n+    let slope = 1;\n+    let f_y0 = 1;\n+    let g_y0 = height as i32 - f_y0 - 1;\n \n-    let buffer = canvas.buffer_mut();\n-    if character == '\\u{e0b0}' || character == '\\u{e0b2}' {\n-        for row in from_y..height - from_y {\n-            let row_offset = row * width;\n-            for index in 1..width {\n-                let index = row_offset + index;\n-                if buffer[index - 1]._r > buffer[index]._r && buffer[index]._r == 0 {\n-                    break;\n-                }\n-\n-                buffer[index - 1] = COLOR_FILL;\n-            }\n-        }\n-    } else if stroke_size > 1. {\n-        // Find the bottom/top most points of extra line we draw, so we can properly set the\n-        // `start`.\n-\n-        let mut y1 = 0;\n-        for row in (0..height / 2).rev() {\n-            if buffer[row * width]._r != 0 {\n-                y1 = row;\n-                break;\n-            }\n-        }\n-        let mut y2 = height / 2;\n-        for row in height / 2..height {\n-            if buffer[row * width]._r != 0 {\n-                y2 = row;\n+    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n+    // g(x) = H - x - 1 lines. The intersection happens when f(x) = g(x), which is at\n+    // x = H/2 - 1.\n+    let intersection = (height as i32 + 1) / 2 - 1;\n+\n+    let f_x = LineEquation::new(slope, f_y0, 0, intersection);\n+    let g_x = LineEquation::new(-slope, g_y0, 0, intersection);\n+\n+    // Inner functions to make arrows thicker.\n+    let mut f_x_inner =\n+        LineEquation::new(slope, f_y0 + extra_thickness, 0, intersection - extra_thickness);\n+    let mut g_x_inner =\n+        LineEquation::new(-slope, g_y0 - extra_thickness, 0, intersection - extra_thickness);\n+\n+    // NOTE f_x and g_x have the same amount of iterations.\n+    for (p1, p2) in iter::zip(f_x, g_x) {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1396568138",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7362,
        "pr_file": "alacritty/src/renderer/text/builtin_font.rs",
        "discussion_id": "1396568138",
        "commented_code": "@@ -500,106 +506,50 @@ fn box_drawing(character: char, metrics: &Metrics, offset: &Delta<i8>) -> Raster\n fn powerline_drawing(character: char, metrics: &Metrics, offset: &Delta<i8>) -> RasterizedGlyph {\n     let height = (metrics.line_height as i32 + offset.y as i32) as usize;\n     let width = (metrics.average_advance as i32 + offset.x as i32) as usize;\n-    // Use one eight of the cell width, since this is used as a step size for block elements.\n-    let stroke_size = cmp::max((width as f32 / 8.).round() as usize, 1) as f32;\n+    let extra_thickness = calculate_stroke_size(width) as i32 - 1;\n \n     let mut canvas = Canvas::new(width, height);\n \n-    let y_center = (height - 1) as f32 / 2.;\n-    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n-    // g(x) = H - x + 1 lines. The intersection happens when f(x) = g(x), which is at\n-    // x = H/2 (`y_center`).\n-    let from_y = 1;\n-    let x_end = y_center.floor();\n-    let y_end = (height - from_y - 1) as f32;\n-\n-    // Pick the start point outside of the canvas to even-out the start.\n-    let from_x = 0.;\n-    let to_x = x_end;\n-    canvas.draw_line_grid(from_x, from_y as f32, to_x, y_center.floor());\n-    canvas.draw_line_grid(from_x, y_end, to_x, y_center.ceil());\n-\n-    // For regular arrows we handle thickness by drawing 2 angle arrows and then just filling\n-    // the contents between them.\n-    if (character == '\\u{e0b1}' || character == '\\u{e0b3}') && stroke_size > 1. {\n-        // The default line is of stroke size 1, so the 0.5 is computed by subtracting 1 from\n-        // stroke_size and then adding 0.5 to to put the target in the center of the cell.\n-        let to_x = x_end - stroke_size;\n-        canvas.draw_line_grid(from_x, from_y as f32 + stroke_size, to_x, y_center.floor());\n-        canvas.draw_line_grid(from_x, y_end - stroke_size, to_x, y_center.ceil());\n-    }\n+    let slope = 1;\n+    let f_y0 = 1;\n+    let g_y0 = height as i32 - f_y0 - 1;\n \n-    let buffer = canvas.buffer_mut();\n-    if character == '\\u{e0b0}' || character == '\\u{e0b2}' {\n-        for row in from_y..height - from_y {\n-            let row_offset = row * width;\n-            for index in 1..width {\n-                let index = row_offset + index;\n-                if buffer[index - 1]._r > buffer[index]._r && buffer[index]._r == 0 {\n-                    break;\n-                }\n-\n-                buffer[index - 1] = COLOR_FILL;\n-            }\n-        }\n-    } else if stroke_size > 1. {\n-        // Find the bottom/top most points of extra line we draw, so we can properly set the\n-        // `start`.\n-\n-        let mut y1 = 0;\n-        for row in (0..height / 2).rev() {\n-            if buffer[row * width]._r != 0 {\n-                y1 = row;\n-                break;\n-            }\n-        }\n-        let mut y2 = height / 2;\n-        for row in height / 2..height {\n-            if buffer[row * width]._r != 0 {\n-                y2 = row;\n+    // Start with offset `1` and draw until the intersection of the f(x) = x + 1 and\n+    // g(x) = H - x - 1 lines. The intersection happens when f(x) = g(x), which is at\n+    // x = H/2 - 1.\n+    let intersection = (height as i32 + 1) / 2 - 1;\n+\n+    let f_x = LineEquation::new(slope, f_y0, 0, intersection);\n+    let g_x = LineEquation::new(-slope, g_y0, 0, intersection);\n+\n+    // Inner functions to make arrows thicker.\n+    let mut f_x_inner =\n+        LineEquation::new(slope, f_y0 + extra_thickness, 0, intersection - extra_thickness);\n+    let mut g_x_inner =\n+        LineEquation::new(-slope, g_y0 - extra_thickness, 0, intersection - extra_thickness);\n+\n+    // NOTE f_x and g_x have the same amount of iterations.\n+    for (p1, p2) in iter::zip(f_x, g_x) {",
        "comment_created_at": "2023-11-17T01:29:23+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "```suggestion\r\n    for (p1, p2) in f_x.zip(g_x) {\r\n```\r\n\r\nI think this should just work since `LineEquation` implements iterator and it's shorter?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1365662322",
    "pr_number": 7300,
    "pr_file": "alacritty/src/input.rs",
    "created_at": "2023-10-19T14:40:03+00:00",
    "commented_code": "let mode = BindingMode::new(self.ctx.terminal().mode(), self.ctx.search_active());\n         let mouse_mode = self.ctx.mouse_mode();\n         let mods = self.ctx.modifiers().state();\n+        let mut actions = vec![];\n \n-        for i in 0..self.ctx.config().mouse_bindings().len() {\n-            let mut binding = self.ctx.config().mouse_bindings()[i].clone();\n-\n-            // Require shift for all modifiers when mouse mode is active.\n-            if mouse_mode {\n-                binding.mods |= ModifiersState::SHIFT;\n-            }\n+        // If mouse mode is active, also look for bindings without Shift\n+        let fallback_mods = mods & !ModifiersState::SHIFT;\n+        let mut use_fallback = mouse_mode && mods.contains(ModifiersState::SHIFT);\n \n+        for binding in self.ctx.config().mouse_bindings() {\n             if binding.is_triggered_by(mode, mods, &button) {\n-                binding.action.execute(&mut self.ctx);\n+                if use_fallback {\n+                    // Throw away fallback actions, stop looking for them\n+                    actions.clear();\n+                    use_fallback = false;\n+                }\n+                actions.push(binding.action.clone());\n             }\n+            if use_fallback && binding.is_triggered_by(mode, fallback_mods, &button) {\n+                actions.push(binding.action.clone());\n+            }\n+        }\n+\n+        for action in actions {\n+            action.execute(&mut self.ctx);",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1365662322",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7300,
        "pr_file": "alacritty/src/input.rs",
        "discussion_id": "1365662322",
        "commented_code": "@@ -984,18 +984,28 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         let mode = BindingMode::new(self.ctx.terminal().mode(), self.ctx.search_active());\n         let mouse_mode = self.ctx.mouse_mode();\n         let mods = self.ctx.modifiers().state();\n+        let mut actions = vec![];\n \n-        for i in 0..self.ctx.config().mouse_bindings().len() {\n-            let mut binding = self.ctx.config().mouse_bindings()[i].clone();\n-\n-            // Require shift for all modifiers when mouse mode is active.\n-            if mouse_mode {\n-                binding.mods |= ModifiersState::SHIFT;\n-            }\n+        // If mouse mode is active, also look for bindings without Shift\n+        let fallback_mods = mods & !ModifiersState::SHIFT;\n+        let mut use_fallback = mouse_mode && mods.contains(ModifiersState::SHIFT);\n \n+        for binding in self.ctx.config().mouse_bindings() {\n             if binding.is_triggered_by(mode, mods, &button) {\n-                binding.action.execute(&mut self.ctx);\n+                if use_fallback {\n+                    // Throw away fallback actions, stop looking for them\n+                    actions.clear();\n+                    use_fallback = false;\n+                }\n+                actions.push(binding.action.clone());\n             }\n+            if use_fallback && binding.is_triggered_by(mode, fallback_mods, &button) {\n+                actions.push(binding.action.clone());\n+            }\n+        }\n+\n+        for action in actions {\n+            action.execute(&mut self.ctx);",
        "comment_created_at": "2023-10-19T14:40:03+00:00",
        "comment_author": "kchibisov",
        "comment_body": "Could you simply take the code which was there before and do 2 loops? The amount of bindings is very low so it's better than `vec` approach.\r\n\r\nJust do normal loop without `mouse_mode` part and set some flag to `true` when you actually triggered some binding.\r\n\r\nAnd then, `if mouse_mode && !sent_binding` do the ho the same loop, but with `SHIFT` applied? First loop won't need to `clone` even, I think.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "186076102",
    "pr_number": 1290,
    "pr_file": "src/display.rs",
    "created_at": "2018-05-04T13:08:00+00:00",
    "commented_code": "height: viewport_size.height.0 as f32,\n             cell_width: cell_width as f32,\n             cell_height: cell_height as f32,\n-            padding_x: config.padding().x as f32,\n-            padding_y: config.padding().y as f32,\n+            padding: padding.clone(),",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "186076102",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 1290,
        "pr_file": "src/display.rs",
        "discussion_id": "186076102",
        "commented_code": "@@ -178,8 +180,7 @@ impl Display {\n             height: viewport_size.height.0 as f32,\n             cell_width: cell_width as f32,\n             cell_height: cell_height as f32,\n-            padding_x: config.padding().x as f32,\n-            padding_y: config.padding().y as f32,\n+            padding: padding.clone(),",
        "comment_created_at": "2018-05-04T13:08:00+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Cloning the padding seems like a waste. It should be perfectly fine for padding to implement `Copy`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "251208224",
    "pr_number": 2037,
    "pr_file": "src/url.rs",
    "created_at": "2019-01-26T18:27:57+00:00",
    "commented_code": "/// Returns the URL if the parser has found any.\n     pub fn url(mut self) -> Option<String> {\n-        // Remove non-alphabetical characters before scheme\n-        if let Some(index) = self.state.find(\"://\") {\n+        // Remove non-alphabetical characters before the scheme\n+        // https://tools.ietf.org/html/rfc3986#section-3.1\n+        if let Some(mut index) = self.state.find(\"://\") {\n+            // Find returns the byte index, but we need the char index.\n+            for (char_index, (byte_index, _)) in self.state.char_indices().enumerate() {\n+                if byte_index == index {\n+                    index = char_index;\n+                    break;\n+                }\n+            }\n             for i in (0..index - 1).rev() {\n                 match self.state.chars().nth(i).unwrap() {\n                     'a'...'z' | 'A'...'Z' => (),\n                     _ => {\n-                        self.state = self.state.split_off(i + 1);\n+                        self.state = self.state.chars().skip(i+1).collect::<String>();",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "251208224",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 2037,
        "pr_file": "src/url.rs",
        "discussion_id": "251208224",
        "commented_code": "@@ -45,13 +45,21 @@ impl UrlParser {\n \n     /// Returns the URL if the parser has found any.\n     pub fn url(mut self) -> Option<String> {\n-        // Remove non-alphabetical characters before scheme\n-        if let Some(index) = self.state.find(\"://\") {\n+        // Remove non-alphabetical characters before the scheme\n+        // https://tools.ietf.org/html/rfc3986#section-3.1\n+        if let Some(mut index) = self.state.find(\"://\") {\n+            // Find returns the byte index, but we need the char index.\n+            for (char_index, (byte_index, _)) in self.state.char_indices().enumerate() {\n+                if byte_index == index {\n+                    index = char_index;\n+                    break;\n+                }\n+            }\n             for i in (0..index - 1).rev() {\n                 match self.state.chars().nth(i).unwrap() {\n                     'a'...'z' | 'A'...'Z' => (),\n                     _ => {\n-                        self.state = self.state.split_off(i + 1);\n+                        self.state = self.state.chars().skip(i+1).collect::<String>();",
        "comment_created_at": "2019-01-26T18:27:57+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Currently you're iterating twice to get to the point where things need to be split off. However the `char_indices` iterator is already an iterator which provides everything necessary to get to the split-off point.\r\n\r\nI'd propose something like this:\r\n```\r\n        // Remove non-alphabetical characters before the scheme\r\n        // https://tools.ietf.org/html/rfc3986#section-3.1\r\n        if let Some(index) = self.state.find(\"://\") {\r\n            let iter = self\r\n                .state\r\n                .char_indices()\r\n                .rev()\r\n                .skip_while(|(byte_index, _)| byte_index >= &index);\r\n            for (byte_index, c) in iter {\r\n                match c {\r\n                    'a'...'z' | 'A'...'Z' => (),\r\n                    _ => {\r\n                        self.state = self.state.split_off(byte_index + c.len_utf8());\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n```\r\n\r\nThis should work fine, though I haven't manually tested it. But the automatic tests don't seem to complain.",
        "pr_file_module": null
      },
      {
        "comment_id": "251211197",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 2037,
        "pr_file": "src/url.rs",
        "discussion_id": "251208224",
        "commented_code": "@@ -45,13 +45,21 @@ impl UrlParser {\n \n     /// Returns the URL if the parser has found any.\n     pub fn url(mut self) -> Option<String> {\n-        // Remove non-alphabetical characters before scheme\n-        if let Some(index) = self.state.find(\"://\") {\n+        // Remove non-alphabetical characters before the scheme\n+        // https://tools.ietf.org/html/rfc3986#section-3.1\n+        if let Some(mut index) = self.state.find(\"://\") {\n+            // Find returns the byte index, but we need the char index.\n+            for (char_index, (byte_index, _)) in self.state.char_indices().enumerate() {\n+                if byte_index == index {\n+                    index = char_index;\n+                    break;\n+                }\n+            }\n             for i in (0..index - 1).rev() {\n                 match self.state.chars().nth(i).unwrap() {\n                     'a'...'z' | 'A'...'Z' => (),\n                     _ => {\n-                        self.state = self.state.split_off(i + 1);\n+                        self.state = self.state.chars().skip(i+1).collect::<String>();",
        "comment_created_at": "2019-01-26T20:09:34+00:00",
        "comment_author": "svanharmelen",
        "comment_body": "That is a very nice and clean solution indeed. Manually tested it and as the tests already indicated, it works as expected. Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "909376900",
    "pr_number": 6139,
    "pr_file": "alacritty/src/display/hint.rs",
    "created_at": "2022-06-29T08:57:01+00:00",
    "commented_code": "}\n }\n \n+/// Iterate over all visible regex matches.\n+pub fn visible_regex_match_iter<'a, T>(\n+    term: &'a Term<T>,\n+    regex: &'a RegexSearch,\n+) -> impl Iterator<Item = Match> + 'a {\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+    let mut start = term.line_search_left(Point::new(viewport_start, Column(0)));\n+    let mut end = term.line_search_right(Point::new(viewport_end, Column(0)));\n+    start.line = start.line.max(viewport_start - MAX_SEARCH_LINES);\n+    end.line = end.line.min(viewport_start + MAX_SEARCH_LINES);\n+\n+    RegexIter::new(start, end, Direction::Right, term, regex)\n+        .skip_while(move |rm| rm.end().line < viewport_start)\n+        .take_while(move |rm| rm.start().line <= viewport_end)\n+}\n+\n+/// Iterate over all visible hyperlinks, yanking only unique ones.\n+pub fn visible_unique_hyperlink_iter<T>(term: &Term<T>) -> impl Iterator<Item = Match> + '_ {\n+    let mut display_iter = term.grid().display_iter().peekable();\n+\n+    // Avoid creating hints for the same hyperlinks, but from a different places.\n+    let mut uniq_hyperlinks = HashSet::new();\n+\n+    std::iter::from_fn(move || {\n+        let (cell, hyperlink) = display_iter.find_map(|cell| {\n+            let hyperlink = cell.hyperlink()?;\n+            if uniq_hyperlinks.contains(&hyperlink) {\n+                return None;\n+            }\n+\n+            uniq_hyperlinks.insert(hyperlink.clone());\n+            Some((cell, hyperlink))",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "909376900",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/hint.rs",
        "discussion_id": "909376900",
        "commented_code": "@@ -238,6 +293,74 @@ impl HintLabels {\n     }\n }\n \n+/// Iterate over all visible regex matches.\n+pub fn visible_regex_match_iter<'a, T>(\n+    term: &'a Term<T>,\n+    regex: &'a RegexSearch,\n+) -> impl Iterator<Item = Match> + 'a {\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+    let mut start = term.line_search_left(Point::new(viewport_start, Column(0)));\n+    let mut end = term.line_search_right(Point::new(viewport_end, Column(0)));\n+    start.line = start.line.max(viewport_start - MAX_SEARCH_LINES);\n+    end.line = end.line.min(viewport_start + MAX_SEARCH_LINES);\n+\n+    RegexIter::new(start, end, Direction::Right, term, regex)\n+        .skip_while(move |rm| rm.end().line < viewport_start)\n+        .take_while(move |rm| rm.start().line <= viewport_end)\n+}\n+\n+/// Iterate over all visible hyperlinks, yanking only unique ones.\n+pub fn visible_unique_hyperlink_iter<T>(term: &Term<T>) -> impl Iterator<Item = Match> + '_ {\n+    let mut display_iter = term.grid().display_iter().peekable();\n+\n+    // Avoid creating hints for the same hyperlinks, but from a different places.\n+    let mut uniq_hyperlinks = HashSet::new();\n+\n+    std::iter::from_fn(move || {\n+        let (cell, hyperlink) = display_iter.find_map(|cell| {\n+            let hyperlink = cell.hyperlink()?;\n+            if uniq_hyperlinks.contains(&hyperlink) {\n+                return None;\n+            }\n+\n+            uniq_hyperlinks.insert(hyperlink.clone());\n+            Some((cell, hyperlink))",
        "comment_created_at": "2022-06-29T08:57:01+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "```suggestion\r\n            if !uniq_hyperlinks.contains(&hyperlink) {\r\n                uniq_hyperlinks.insert(hyperlink.clone());\r\n                Some((cell, hyperlink))\r\n            } else {\r\n                None\r\n            }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "909379237",
    "pr_number": 6139,
    "pr_file": "alacritty/src/display/hint.rs",
    "created_at": "2022-06-29T08:59:07+00:00",
    "commented_code": "}\n }\n \n+/// Iterate over all visible regex matches.\n+pub fn visible_regex_match_iter<'a, T>(\n+    term: &'a Term<T>,\n+    regex: &'a RegexSearch,\n+) -> impl Iterator<Item = Match> + 'a {\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+    let mut start = term.line_search_left(Point::new(viewport_start, Column(0)));\n+    let mut end = term.line_search_right(Point::new(viewport_end, Column(0)));\n+    start.line = start.line.max(viewport_start - MAX_SEARCH_LINES);\n+    end.line = end.line.min(viewport_start + MAX_SEARCH_LINES);\n+\n+    RegexIter::new(start, end, Direction::Right, term, regex)\n+        .skip_while(move |rm| rm.end().line < viewport_start)\n+        .take_while(move |rm| rm.start().line <= viewport_end)\n+}\n+\n+/// Iterate over all visible hyperlinks, yanking only unique ones.\n+pub fn visible_unique_hyperlink_iter<T>(term: &Term<T>) -> impl Iterator<Item = Match> + '_ {\n+    let mut display_iter = term.grid().display_iter().peekable();\n+\n+    // Avoid creating hints for the same hyperlinks, but from a different places.\n+    let mut uniq_hyperlinks = HashSet::new();\n+\n+    std::iter::from_fn(move || {\n+        let (cell, hyperlink) = display_iter.find_map(|cell| {\n+            let hyperlink = cell.hyperlink()?;\n+            if uniq_hyperlinks.contains(&hyperlink) {\n+                return None;\n+            }\n+\n+            uniq_hyperlinks.insert(hyperlink.clone());\n+            Some((cell, hyperlink))\n+        })?;\n+\n+        let start = cell.point;\n+        let mut end = start;\n+\n+        while let Some(next_cell) = display_iter.peek() {\n+            if next_cell.hyperlink().as_ref() != Some(&hyperlink) {\n+                break;\n+            }\n+\n+            end = next_cell.point;\n+            let _ = display_iter.next();\n+        }",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "909379237",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/hint.rs",
        "discussion_id": "909379237",
        "commented_code": "@@ -238,6 +293,74 @@ impl HintLabels {\n     }\n }\n \n+/// Iterate over all visible regex matches.\n+pub fn visible_regex_match_iter<'a, T>(\n+    term: &'a Term<T>,\n+    regex: &'a RegexSearch,\n+) -> impl Iterator<Item = Match> + 'a {\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+    let mut start = term.line_search_left(Point::new(viewport_start, Column(0)));\n+    let mut end = term.line_search_right(Point::new(viewport_end, Column(0)));\n+    start.line = start.line.max(viewport_start - MAX_SEARCH_LINES);\n+    end.line = end.line.min(viewport_start + MAX_SEARCH_LINES);\n+\n+    RegexIter::new(start, end, Direction::Right, term, regex)\n+        .skip_while(move |rm| rm.end().line < viewport_start)\n+        .take_while(move |rm| rm.start().line <= viewport_end)\n+}\n+\n+/// Iterate over all visible hyperlinks, yanking only unique ones.\n+pub fn visible_unique_hyperlink_iter<T>(term: &Term<T>) -> impl Iterator<Item = Match> + '_ {\n+    let mut display_iter = term.grid().display_iter().peekable();\n+\n+    // Avoid creating hints for the same hyperlinks, but from a different places.\n+    let mut uniq_hyperlinks = HashSet::new();\n+\n+    std::iter::from_fn(move || {\n+        let (cell, hyperlink) = display_iter.find_map(|cell| {\n+            let hyperlink = cell.hyperlink()?;\n+            if uniq_hyperlinks.contains(&hyperlink) {\n+                return None;\n+            }\n+\n+            uniq_hyperlinks.insert(hyperlink.clone());\n+            Some((cell, hyperlink))\n+        })?;\n+\n+        let start = cell.point;\n+        let mut end = start;\n+\n+        while let Some(next_cell) = display_iter.peek() {\n+            if next_cell.hyperlink().as_ref() != Some(&hyperlink) {\n+                break;\n+            }\n+\n+            end = next_cell.point;\n+            let _ = display_iter.next();\n+        }",
        "comment_created_at": "2022-06-29T08:59:07+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "This definitely needs a comment, seems like you use this to skip over cells that contain already existing hyperlinks, but doesn't `if uniq_hyperlinks.contains(&hyperlink) {` already do this? Seems like it's kinda duplicate work?",
        "pr_file_module": null
      },
      {
        "comment_id": "909459195",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/hint.rs",
        "discussion_id": "909379237",
        "commented_code": "@@ -238,6 +293,74 @@ impl HintLabels {\n     }\n }\n \n+/// Iterate over all visible regex matches.\n+pub fn visible_regex_match_iter<'a, T>(\n+    term: &'a Term<T>,\n+    regex: &'a RegexSearch,\n+) -> impl Iterator<Item = Match> + 'a {\n+    let viewport_start = Line(-(term.grid().display_offset() as i32));\n+    let viewport_end = viewport_start + term.bottommost_line();\n+    let mut start = term.line_search_left(Point::new(viewport_start, Column(0)));\n+    let mut end = term.line_search_right(Point::new(viewport_end, Column(0)));\n+    start.line = start.line.max(viewport_start - MAX_SEARCH_LINES);\n+    end.line = end.line.min(viewport_start + MAX_SEARCH_LINES);\n+\n+    RegexIter::new(start, end, Direction::Right, term, regex)\n+        .skip_while(move |rm| rm.end().line < viewport_start)\n+        .take_while(move |rm| rm.start().line <= viewport_end)\n+}\n+\n+/// Iterate over all visible hyperlinks, yanking only unique ones.\n+pub fn visible_unique_hyperlink_iter<T>(term: &Term<T>) -> impl Iterator<Item = Match> + '_ {\n+    let mut display_iter = term.grid().display_iter().peekable();\n+\n+    // Avoid creating hints for the same hyperlinks, but from a different places.\n+    let mut uniq_hyperlinks = HashSet::new();\n+\n+    std::iter::from_fn(move || {\n+        let (cell, hyperlink) = display_iter.find_map(|cell| {\n+            let hyperlink = cell.hyperlink()?;\n+            if uniq_hyperlinks.contains(&hyperlink) {\n+                return None;\n+            }\n+\n+            uniq_hyperlinks.insert(hyperlink.clone());\n+            Some((cell, hyperlink))\n+        })?;\n+\n+        let start = cell.point;\n+        let mut end = start;\n+\n+        while let Some(next_cell) = display_iter.peek() {\n+            if next_cell.hyperlink().as_ref() != Some(&hyperlink) {\n+                break;\n+            }\n+\n+            end = next_cell.point;\n+            let _ = display_iter.next();\n+        }",
        "comment_created_at": "2022-06-29T10:19:54+00:00",
        "comment_author": "kchibisov",
        "comment_body": "The `find_map` finds next unique hyperlink, the `while let` loop finds the end of that particular hyperlink, the point here is to compute meaningful bounds.\r\n\r\nHowever what we can do if we don't care about bounds at all is to always use `find_map` and report ranges for hint as 1 cell. That should probably make some sense, I guess?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "912606600",
    "pr_number": 6139,
    "pr_file": "alacritty/src/display/mod.rs",
    "created_at": "2022-07-04T03:49:45+00:00",
    "commented_code": "bar_text\n     }\n \n-    /// Draw current search regex.\n-    fn draw_search(&mut self, config: &UiConfig, size_info: &SizeInfo, text: &str) {\n-        let glyph_cache = &mut self.glyph_cache;\n-        let num_cols = size_info.columns();\n+    /// Format hyperlink preview to make it fit into the terminal.\n+    fn format_hyperlink_preview(text: &str, max_chars: usize) -> Vec<char> {\n+        let mut result = Vec::with_capacity(cmp::min(max_chars, text.len()));\n+        let mut num_chars = 0;\n+\n+        // Place it when the highlighted hyperlink's uri text is too long for preview.\n+        const HYPERLINK_SHORTENER: char = '\u2026';\n+\n+        for ch in text.chars() {\n+            result.push(ch);\n+            num_chars += 1;\n+\n+            if ch.width() == Some(2) {\n+                result.push(' ');\n+                num_chars += 1;\n+            }\n+\n+            if num_chars > max_chars {\n+                // Truncate uri in the preview.\n+                let index = if result.get(max_chars - 2).and_then(|ch| ch.width()) == Some(2) {\n+                    max_chars - 2\n+                } else {\n+                    max_chars - 1\n+                };\n+\n+                if let Some(ch) = result.get_mut(index) {\n+                    *ch = HYPERLINK_SHORTENER;\n+                }\n+\n+                break;\n+            }\n+        }\n+\n+        result\n+    }\n \n+    /// Draw preview for the currently highlighted `Hyperlink`.\n+    #[inline(never)]\n+    fn draw_hyperlink_preview(\n+        &mut self,\n+        config: &UiConfig,\n+        vi_cursor_point: Option<Point>,\n+        display_offset: usize,\n+    ) {\n+        let num_cols = self.size_info.columns();\n+        let uris: Vec<Vec<char>> = self\n+            .highlighted_hint\n+            .iter()\n+            .chain(&self.vi_highlighted_hint)\n+            .filter_map(|hint| hint.hyperlink().map(|hyperlink| hyperlink.uri()))\n+            .map(|uri| Self::format_hyperlink_preview(uri, num_cols))\n+            .collect();",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "912606600",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/mod.rs",
        "discussion_id": "912606600",
        "commented_code": "@@ -1010,44 +1046,155 @@ impl Display {\n         bar_text\n     }\n \n-    /// Draw current search regex.\n-    fn draw_search(&mut self, config: &UiConfig, size_info: &SizeInfo, text: &str) {\n-        let glyph_cache = &mut self.glyph_cache;\n-        let num_cols = size_info.columns();\n+    /// Format hyperlink preview to make it fit into the terminal.\n+    fn format_hyperlink_preview(text: &str, max_chars: usize) -> Vec<char> {\n+        let mut result = Vec::with_capacity(cmp::min(max_chars, text.len()));\n+        let mut num_chars = 0;\n+\n+        // Place it when the highlighted hyperlink's uri text is too long for preview.\n+        const HYPERLINK_SHORTENER: char = '\u2026';\n+\n+        for ch in text.chars() {\n+            result.push(ch);\n+            num_chars += 1;\n+\n+            if ch.width() == Some(2) {\n+                result.push(' ');\n+                num_chars += 1;\n+            }\n+\n+            if num_chars > max_chars {\n+                // Truncate uri in the preview.\n+                let index = if result.get(max_chars - 2).and_then(|ch| ch.width()) == Some(2) {\n+                    max_chars - 2\n+                } else {\n+                    max_chars - 1\n+                };\n+\n+                if let Some(ch) = result.get_mut(index) {\n+                    *ch = HYPERLINK_SHORTENER;\n+                }\n+\n+                break;\n+            }\n+        }\n+\n+        result\n+    }\n \n+    /// Draw preview for the currently highlighted `Hyperlink`.\n+    #[inline(never)]\n+    fn draw_hyperlink_preview(\n+        &mut self,\n+        config: &UiConfig,\n+        vi_cursor_point: Option<Point>,\n+        display_offset: usize,\n+    ) {\n+        let num_cols = self.size_info.columns();\n+        let uris: Vec<Vec<char>> = self\n+            .highlighted_hint\n+            .iter()\n+            .chain(&self.vi_highlighted_hint)\n+            .filter_map(|hint| hint.hyperlink().map(|hyperlink| hyperlink.uri()))\n+            .map(|uri| Self::format_hyperlink_preview(uri, num_cols))\n+            .collect();",
        "comment_created_at": "2022-07-04T03:49:45+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Why use a dynamic Vec for something that will have at most two elements? Can't we just use a fixed-size slice with two elements for it?",
        "pr_file_module": null
      },
      {
        "comment_id": "912807241",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/mod.rs",
        "discussion_id": "912606600",
        "commented_code": "@@ -1010,44 +1046,155 @@ impl Display {\n         bar_text\n     }\n \n-    /// Draw current search regex.\n-    fn draw_search(&mut self, config: &UiConfig, size_info: &SizeInfo, text: &str) {\n-        let glyph_cache = &mut self.glyph_cache;\n-        let num_cols = size_info.columns();\n+    /// Format hyperlink preview to make it fit into the terminal.\n+    fn format_hyperlink_preview(text: &str, max_chars: usize) -> Vec<char> {\n+        let mut result = Vec::with_capacity(cmp::min(max_chars, text.len()));\n+        let mut num_chars = 0;\n+\n+        // Place it when the highlighted hyperlink's uri text is too long for preview.\n+        const HYPERLINK_SHORTENER: char = '\u2026';\n+\n+        for ch in text.chars() {\n+            result.push(ch);\n+            num_chars += 1;\n+\n+            if ch.width() == Some(2) {\n+                result.push(' ');\n+                num_chars += 1;\n+            }\n+\n+            if num_chars > max_chars {\n+                // Truncate uri in the preview.\n+                let index = if result.get(max_chars - 2).and_then(|ch| ch.width()) == Some(2) {\n+                    max_chars - 2\n+                } else {\n+                    max_chars - 1\n+                };\n+\n+                if let Some(ch) = result.get_mut(index) {\n+                    *ch = HYPERLINK_SHORTENER;\n+                }\n+\n+                break;\n+            }\n+        }\n+\n+        result\n+    }\n \n+    /// Draw preview for the currently highlighted `Hyperlink`.\n+    #[inline(never)]\n+    fn draw_hyperlink_preview(\n+        &mut self,\n+        config: &UiConfig,\n+        vi_cursor_point: Option<Point>,\n+        display_offset: usize,\n+    ) {\n+        let num_cols = self.size_info.columns();\n+        let uris: Vec<Vec<char>> = self\n+            .highlighted_hint\n+            .iter()\n+            .chain(&self.vi_highlighted_hint)\n+            .filter_map(|hint| hint.hyperlink().map(|hyperlink| hyperlink.uri()))\n+            .map(|uri| Self::format_hyperlink_preview(uri, num_cols))\n+            .collect();",
        "comment_created_at": "2022-07-04T09:24:20+00:00",
        "comment_author": "kchibisov",
        "comment_body": "We can, but of form `Option<Vec<char>>; 2`, since we should occupy the entire it? I can adjust that, I think.",
        "pr_file_module": null
      },
      {
        "comment_id": "912876944",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/mod.rs",
        "discussion_id": "912606600",
        "commented_code": "@@ -1010,44 +1046,155 @@ impl Display {\n         bar_text\n     }\n \n-    /// Draw current search regex.\n-    fn draw_search(&mut self, config: &UiConfig, size_info: &SizeInfo, text: &str) {\n-        let glyph_cache = &mut self.glyph_cache;\n-        let num_cols = size_info.columns();\n+    /// Format hyperlink preview to make it fit into the terminal.\n+    fn format_hyperlink_preview(text: &str, max_chars: usize) -> Vec<char> {\n+        let mut result = Vec::with_capacity(cmp::min(max_chars, text.len()));\n+        let mut num_chars = 0;\n+\n+        // Place it when the highlighted hyperlink's uri text is too long for preview.\n+        const HYPERLINK_SHORTENER: char = '\u2026';\n+\n+        for ch in text.chars() {\n+            result.push(ch);\n+            num_chars += 1;\n+\n+            if ch.width() == Some(2) {\n+                result.push(' ');\n+                num_chars += 1;\n+            }\n+\n+            if num_chars > max_chars {\n+                // Truncate uri in the preview.\n+                let index = if result.get(max_chars - 2).and_then(|ch| ch.width()) == Some(2) {\n+                    max_chars - 2\n+                } else {\n+                    max_chars - 1\n+                };\n+\n+                if let Some(ch) = result.get_mut(index) {\n+                    *ch = HYPERLINK_SHORTENER;\n+                }\n+\n+                break;\n+            }\n+        }\n+\n+        result\n+    }\n \n+    /// Draw preview for the currently highlighted `Hyperlink`.\n+    #[inline(never)]\n+    fn draw_hyperlink_preview(\n+        &mut self,\n+        config: &UiConfig,\n+        vi_cursor_point: Option<Point>,\n+        display_offset: usize,\n+    ) {\n+        let num_cols = self.size_info.columns();\n+        let uris: Vec<Vec<char>> = self\n+            .highlighted_hint\n+            .iter()\n+            .chain(&self.vi_highlighted_hint)\n+            .filter_map(|hint| hint.hyperlink().map(|hyperlink| hyperlink.uri()))\n+            .map(|uri| Self::format_hyperlink_preview(uri, num_cols))\n+            .collect();",
        "comment_created_at": "2022-07-04T10:44:52+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "The `draw_string` method now takes an iterator, right? So do we need a `Vec` here?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1057673231",
    "pr_number": 6585,
    "pr_file": "alacritty/src/display/mod.rs",
    "created_at": "2022-12-27T13:14:59+00:00",
    "commented_code": "}\n \n     /// Requst a new frame for a window on Wayland.\n-    #[inline]\n-    #[cfg(all(feature = \"wayland\", not(any(target_os = \"macos\", windows))))]\n-    fn request_frame(&self, window: &Window) {\n-        let surface = match window.wayland_surface() {\n-            Some(surface) => surface,\n-            None => return,\n-        };\n+    fn request_frame(&mut self, scheduler: &mut Scheduler) {\n+        // Mark that we've used a frame.\n+        self.window.has_frame.store(false, Ordering::Relaxed);\n \n-        let should_draw = self.window.should_draw.clone();\n+        #[cfg(all(feature = \"wayland\", not(any(target_os = \"macos\", windows))))]\n+        if let Some(surface) = self.window.wayland_surface() {\n+            let has_frame = self.window.has_frame.clone();\n+            // Request a new frame.\n+            surface.frame().quick_assign(move |_, _, _| {\n+                has_frame.store(true, Ordering::Relaxed);\n+            });\n \n-        // Mark that window was drawn.\n-        should_draw.store(false, Ordering::Relaxed);\n+            return;\n+        }\n \n-        // Request a new frame.\n-        surface.frame().quick_assign(move |_, _, _| {\n-            should_draw.store(true, Ordering::Relaxed);\n-        });\n+        // Get the display vblank interval in micro seconds.\n+        let monitor_vblank_interval = Duration::from_micros(\n+            (1e6 / (self\n+                .window\n+                .current_monitor()\n+                .and_then(|monitor| monitor.refresh_rate_millihertz())\n+                .unwrap_or(60_000) as f64\n+                / 1e3)) as u64,",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1057673231",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6585,
        "pr_file": "alacritty/src/display/mod.rs",
        "discussion_id": "1057673231",
        "commented_code": "@@ -1371,23 +1377,38 @@ impl Display {\n     }\n \n     /// Requst a new frame for a window on Wayland.\n-    #[inline]\n-    #[cfg(all(feature = \"wayland\", not(any(target_os = \"macos\", windows))))]\n-    fn request_frame(&self, window: &Window) {\n-        let surface = match window.wayland_surface() {\n-            Some(surface) => surface,\n-            None => return,\n-        };\n+    fn request_frame(&mut self, scheduler: &mut Scheduler) {\n+        // Mark that we've used a frame.\n+        self.window.has_frame.store(false, Ordering::Relaxed);\n \n-        let should_draw = self.window.should_draw.clone();\n+        #[cfg(all(feature = \"wayland\", not(any(target_os = \"macos\", windows))))]\n+        if let Some(surface) = self.window.wayland_surface() {\n+            let has_frame = self.window.has_frame.clone();\n+            // Request a new frame.\n+            surface.frame().quick_assign(move |_, _, _| {\n+                has_frame.store(true, Ordering::Relaxed);\n+            });\n \n-        // Mark that window was drawn.\n-        should_draw.store(false, Ordering::Relaxed);\n+            return;\n+        }\n \n-        // Request a new frame.\n-        surface.frame().quick_assign(move |_, _, _| {\n-            should_draw.store(true, Ordering::Relaxed);\n-        });\n+        // Get the display vblank interval in micro seconds.\n+        let monitor_vblank_interval = Duration::from_micros(\n+            (1e6 / (self\n+                .window\n+                .current_monitor()\n+                .and_then(|monitor| monitor.refresh_rate_millihertz())\n+                .unwrap_or(60_000) as f64\n+                / 1e3)) as u64,",
        "comment_created_at": "2022-12-27T13:14:59+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "What's the point of this division? Wouldn't it be easier to just do `1_000_000_000 / 60_000` rather than `1_000_000 / (60_000 / 1000)`?",
        "pr_file_module": null
      }
    ]
  }
]