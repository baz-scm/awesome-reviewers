[
  {
    "discussion_id": "1589672105",
    "pr_number": 7935,
    "pr_file": "alacritty/src/event.rs",
    "created_at": "2024-05-03T19:54:44+00:00",
    "commented_code": "/// Touch zoom speed.\n const TOUCH_ZOOM_FACTOR: f32 = 0.01;\n \n+/// The event processor.\n+///\n+/// Stores some state from received events and dispatches actions when they are\n+/// triggered.\n+pub struct Processor {\n+    clipboard: Clipboard,\n+    scheduler: Scheduler,\n+    initial_window_options: Option<WindowOptions>,\n+    initial_window_error: Option<Box<dyn Error>>,\n+    windows: HashMap<WindowId, WindowContext, RandomState>,\n+    proxy: EventLoopProxy<Event>,\n+    gl_display: Option<GlutinDisplay>,\n+    #[cfg(unix)]\n+    global_ipc_options: ParsedOptions,\n+    cli_options: CliOptions,\n+    config: Rc<UiConfig>,\n+}\n+\n+impl Processor {\n+    /// Create a new event processor.\n+    ///\n+    /// Takes a writer which is expected to be hooked up to the write end of a PTY.\n+    pub fn new(\n+        config: UiConfig,\n+        cli_options: CliOptions,\n+        event_loop: &EventLoop<Event>,\n+    ) -> Processor {\n+        let proxy = event_loop.create_proxy();\n+        let scheduler = Scheduler::new(proxy.clone());\n+        let initial_window_options = Some(cli_options.window_options.clone());\n+\n+        // Disable all device events, since we don't care about them.\n+        event_loop.listen_device_events(DeviceEvents::Never);\n+\n+        // SAFETY: Since this takes a pointer to the winit event loop, it MUST be dropped first,\n+        // which is done in `loop_exiting`.\n+        let clipboard = unsafe { Clipboard::new(event_loop.raw_display_handle()) };\n+\n+        Processor {\n+            initial_window_options,\n+            initial_window_error: None,\n+            cli_options,\n+            proxy,\n+            scheduler,\n+            gl_display: None,\n+            config: Rc::new(config),\n+            clipboard,\n+            windows: Default::default(),\n+            #[cfg(unix)]\n+            global_ipc_options: Default::default(),\n+        }\n+    }\n+\n+    /// Create initial window and load GL platform.\n+    ///\n+    /// This will initialize the OpenGL Api and pick a config that\n+    /// will be used for the rest of the windows.\n+    pub fn create_initial_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window_context =\n+            WindowContext::initial(event_loop, self.proxy.clone(), self.config.clone(), options)?;\n+\n+        self.gl_display = Some(window_context.display.gl_context().display());\n+        self.windows.insert(window_context.id(), window_context);\n+\n+        Ok(())\n+    }\n+\n+    /// Create a new terminal window.\n+    pub fn create_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window = self.windows.iter().next().as_ref().unwrap().1;\n+\n+        // Overide config with CLI/IPC options.\n+        let mut config_overrides = options.config_overrides();\n+        #[cfg(unix)]\n+        config_overrides.extend_from_slice(&self.global_ipc_options);\n+        let mut config = self.config.clone();\n+        config = config_overrides.override_config_rc(config);\n+\n+        #[allow(unused_mut)]\n+        let mut window_context =\n+            window.additional(event_loop, self.proxy.clone(), config, options, config_overrides)?;\n+\n+        self.windows.insert(window_context.id(), window_context);\n+        Ok(())\n+    }\n+\n+    /// Run the event loop.\n+    ///\n+    /// The result is exit code generate from the loop.\n+    pub fn run(mut self, event_loop: EventLoop<Event>) -> Result<(), Box<dyn Error>> {\n+        let result = event_loop.run_app(&mut self);\n+        if let Some(initial_window_error) = self.initial_window_error.take() {\n+            Err(initial_window_error)\n+        } else {\n+            result.map_err(Into::into)\n+        }\n+    }\n+\n+    /// Check if an event is irrelevant and can be skipped.\n+    fn skip_window_event(event: &WindowEvent) -> bool {\n+        matches!(\n+            event,\n+            WindowEvent::KeyboardInput { is_synthetic: true, .. }\n+                | WindowEvent::ActivationTokenDone { .. }\n+                | WindowEvent::DoubleTapGesture { .. }\n+                | WindowEvent::TouchpadPressure { .. }\n+                | WindowEvent::RotationGesture { .. }\n+                | WindowEvent::CursorEntered { .. }\n+                | WindowEvent::PinchGesture { .. }\n+                | WindowEvent::AxisMotion { .. }\n+                | WindowEvent::PanGesture { .. }\n+                | WindowEvent::HoveredFileCancelled\n+                | WindowEvent::Destroyed\n+                | WindowEvent::ThemeChanged(_)\n+                | WindowEvent::HoveredFile(_)\n+                | WindowEvent::Moved(_)\n+        )\n+    }\n+}\n+\n+impl ApplicationHandler<Event> for Processor {\n+    fn resumed(&mut self, _event_loop: &ActiveEventLoop) {\n+        // We use `new_events` because we target only desktop.\n+    }\n+\n+    fn new_events(&mut self, event_loop: &ActiveEventLoop, cause: StartCause) {\n+        if cause == StartCause::Init {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1589672105",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7935,
        "pr_file": "alacritty/src/event.rs",
        "discussion_id": "1589672105",
        "commented_code": "@@ -66,6 +65,374 @@ const MAX_SEARCH_HISTORY_SIZE: usize = 255;\n /// Touch zoom speed.\n const TOUCH_ZOOM_FACTOR: f32 = 0.01;\n \n+/// The event processor.\n+///\n+/// Stores some state from received events and dispatches actions when they are\n+/// triggered.\n+pub struct Processor {\n+    clipboard: Clipboard,\n+    scheduler: Scheduler,\n+    initial_window_options: Option<WindowOptions>,\n+    initial_window_error: Option<Box<dyn Error>>,\n+    windows: HashMap<WindowId, WindowContext, RandomState>,\n+    proxy: EventLoopProxy<Event>,\n+    gl_display: Option<GlutinDisplay>,\n+    #[cfg(unix)]\n+    global_ipc_options: ParsedOptions,\n+    cli_options: CliOptions,\n+    config: Rc<UiConfig>,\n+}\n+\n+impl Processor {\n+    /// Create a new event processor.\n+    ///\n+    /// Takes a writer which is expected to be hooked up to the write end of a PTY.\n+    pub fn new(\n+        config: UiConfig,\n+        cli_options: CliOptions,\n+        event_loop: &EventLoop<Event>,\n+    ) -> Processor {\n+        let proxy = event_loop.create_proxy();\n+        let scheduler = Scheduler::new(proxy.clone());\n+        let initial_window_options = Some(cli_options.window_options.clone());\n+\n+        // Disable all device events, since we don't care about them.\n+        event_loop.listen_device_events(DeviceEvents::Never);\n+\n+        // SAFETY: Since this takes a pointer to the winit event loop, it MUST be dropped first,\n+        // which is done in `loop_exiting`.\n+        let clipboard = unsafe { Clipboard::new(event_loop.raw_display_handle()) };\n+\n+        Processor {\n+            initial_window_options,\n+            initial_window_error: None,\n+            cli_options,\n+            proxy,\n+            scheduler,\n+            gl_display: None,\n+            config: Rc::new(config),\n+            clipboard,\n+            windows: Default::default(),\n+            #[cfg(unix)]\n+            global_ipc_options: Default::default(),\n+        }\n+    }\n+\n+    /// Create initial window and load GL platform.\n+    ///\n+    /// This will initialize the OpenGL Api and pick a config that\n+    /// will be used for the rest of the windows.\n+    pub fn create_initial_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window_context =\n+            WindowContext::initial(event_loop, self.proxy.clone(), self.config.clone(), options)?;\n+\n+        self.gl_display = Some(window_context.display.gl_context().display());\n+        self.windows.insert(window_context.id(), window_context);\n+\n+        Ok(())\n+    }\n+\n+    /// Create a new terminal window.\n+    pub fn create_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window = self.windows.iter().next().as_ref().unwrap().1;\n+\n+        // Overide config with CLI/IPC options.\n+        let mut config_overrides = options.config_overrides();\n+        #[cfg(unix)]\n+        config_overrides.extend_from_slice(&self.global_ipc_options);\n+        let mut config = self.config.clone();\n+        config = config_overrides.override_config_rc(config);\n+\n+        #[allow(unused_mut)]\n+        let mut window_context =\n+            window.additional(event_loop, self.proxy.clone(), config, options, config_overrides)?;\n+\n+        self.windows.insert(window_context.id(), window_context);\n+        Ok(())\n+    }\n+\n+    /// Run the event loop.\n+    ///\n+    /// The result is exit code generate from the loop.\n+    pub fn run(mut self, event_loop: EventLoop<Event>) -> Result<(), Box<dyn Error>> {\n+        let result = event_loop.run_app(&mut self);\n+        if let Some(initial_window_error) = self.initial_window_error.take() {\n+            Err(initial_window_error)\n+        } else {\n+            result.map_err(Into::into)\n+        }\n+    }\n+\n+    /// Check if an event is irrelevant and can be skipped.\n+    fn skip_window_event(event: &WindowEvent) -> bool {\n+        matches!(\n+            event,\n+            WindowEvent::KeyboardInput { is_synthetic: true, .. }\n+                | WindowEvent::ActivationTokenDone { .. }\n+                | WindowEvent::DoubleTapGesture { .. }\n+                | WindowEvent::TouchpadPressure { .. }\n+                | WindowEvent::RotationGesture { .. }\n+                | WindowEvent::CursorEntered { .. }\n+                | WindowEvent::PinchGesture { .. }\n+                | WindowEvent::AxisMotion { .. }\n+                | WindowEvent::PanGesture { .. }\n+                | WindowEvent::HoveredFileCancelled\n+                | WindowEvent::Destroyed\n+                | WindowEvent::ThemeChanged(_)\n+                | WindowEvent::HoveredFile(_)\n+                | WindowEvent::Moved(_)\n+        )\n+    }\n+}\n+\n+impl ApplicationHandler<Event> for Processor {\n+    fn resumed(&mut self, _event_loop: &ActiveEventLoop) {\n+        // We use `new_events` because we target only desktop.\n+    }\n+\n+    fn new_events(&mut self, event_loop: &ActiveEventLoop, cause: StartCause) {\n+        if cause == StartCause::Init {",
        "comment_created_at": "2024-05-03T19:54:44+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Early return for a lil less indentation?",
        "pr_file_module": null
      },
      {
        "comment_id": "1589683242",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7935,
        "pr_file": "alacritty/src/event.rs",
        "discussion_id": "1589672105",
        "commented_code": "@@ -66,6 +65,374 @@ const MAX_SEARCH_HISTORY_SIZE: usize = 255;\n /// Touch zoom speed.\n const TOUCH_ZOOM_FACTOR: f32 = 0.01;\n \n+/// The event processor.\n+///\n+/// Stores some state from received events and dispatches actions when they are\n+/// triggered.\n+pub struct Processor {\n+    clipboard: Clipboard,\n+    scheduler: Scheduler,\n+    initial_window_options: Option<WindowOptions>,\n+    initial_window_error: Option<Box<dyn Error>>,\n+    windows: HashMap<WindowId, WindowContext, RandomState>,\n+    proxy: EventLoopProxy<Event>,\n+    gl_display: Option<GlutinDisplay>,\n+    #[cfg(unix)]\n+    global_ipc_options: ParsedOptions,\n+    cli_options: CliOptions,\n+    config: Rc<UiConfig>,\n+}\n+\n+impl Processor {\n+    /// Create a new event processor.\n+    ///\n+    /// Takes a writer which is expected to be hooked up to the write end of a PTY.\n+    pub fn new(\n+        config: UiConfig,\n+        cli_options: CliOptions,\n+        event_loop: &EventLoop<Event>,\n+    ) -> Processor {\n+        let proxy = event_loop.create_proxy();\n+        let scheduler = Scheduler::new(proxy.clone());\n+        let initial_window_options = Some(cli_options.window_options.clone());\n+\n+        // Disable all device events, since we don't care about them.\n+        event_loop.listen_device_events(DeviceEvents::Never);\n+\n+        // SAFETY: Since this takes a pointer to the winit event loop, it MUST be dropped first,\n+        // which is done in `loop_exiting`.\n+        let clipboard = unsafe { Clipboard::new(event_loop.raw_display_handle()) };\n+\n+        Processor {\n+            initial_window_options,\n+            initial_window_error: None,\n+            cli_options,\n+            proxy,\n+            scheduler,\n+            gl_display: None,\n+            config: Rc::new(config),\n+            clipboard,\n+            windows: Default::default(),\n+            #[cfg(unix)]\n+            global_ipc_options: Default::default(),\n+        }\n+    }\n+\n+    /// Create initial window and load GL platform.\n+    ///\n+    /// This will initialize the OpenGL Api and pick a config that\n+    /// will be used for the rest of the windows.\n+    pub fn create_initial_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window_context =\n+            WindowContext::initial(event_loop, self.proxy.clone(), self.config.clone(), options)?;\n+\n+        self.gl_display = Some(window_context.display.gl_context().display());\n+        self.windows.insert(window_context.id(), window_context);\n+\n+        Ok(())\n+    }\n+\n+    /// Create a new terminal window.\n+    pub fn create_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window = self.windows.iter().next().as_ref().unwrap().1;\n+\n+        // Overide config with CLI/IPC options.\n+        let mut config_overrides = options.config_overrides();\n+        #[cfg(unix)]\n+        config_overrides.extend_from_slice(&self.global_ipc_options);\n+        let mut config = self.config.clone();\n+        config = config_overrides.override_config_rc(config);\n+\n+        #[allow(unused_mut)]\n+        let mut window_context =\n+            window.additional(event_loop, self.proxy.clone(), config, options, config_overrides)?;\n+\n+        self.windows.insert(window_context.id(), window_context);\n+        Ok(())\n+    }\n+\n+    /// Run the event loop.\n+    ///\n+    /// The result is exit code generate from the loop.\n+    pub fn run(mut self, event_loop: EventLoop<Event>) -> Result<(), Box<dyn Error>> {\n+        let result = event_loop.run_app(&mut self);\n+        if let Some(initial_window_error) = self.initial_window_error.take() {\n+            Err(initial_window_error)\n+        } else {\n+            result.map_err(Into::into)\n+        }\n+    }\n+\n+    /// Check if an event is irrelevant and can be skipped.\n+    fn skip_window_event(event: &WindowEvent) -> bool {\n+        matches!(\n+            event,\n+            WindowEvent::KeyboardInput { is_synthetic: true, .. }\n+                | WindowEvent::ActivationTokenDone { .. }\n+                | WindowEvent::DoubleTapGesture { .. }\n+                | WindowEvent::TouchpadPressure { .. }\n+                | WindowEvent::RotationGesture { .. }\n+                | WindowEvent::CursorEntered { .. }\n+                | WindowEvent::PinchGesture { .. }\n+                | WindowEvent::AxisMotion { .. }\n+                | WindowEvent::PanGesture { .. }\n+                | WindowEvent::HoveredFileCancelled\n+                | WindowEvent::Destroyed\n+                | WindowEvent::ThemeChanged(_)\n+                | WindowEvent::HoveredFile(_)\n+                | WindowEvent::Moved(_)\n+        )\n+    }\n+}\n+\n+impl ApplicationHandler<Event> for Processor {\n+    fn resumed(&mut self, _event_loop: &ActiveEventLoop) {\n+        // We use `new_events` because we target only desktop.\n+    }\n+\n+    fn new_events(&mut self, event_loop: &ActiveEventLoop, cause: StartCause) {\n+        if cause == StartCause::Init {",
        "comment_created_at": "2024-05-03T20:09:23+00:00",
        "comment_author": "kchibisov",
        "comment_body": "Last time the style for thing like that was the one I picked.\r\n\r\nI can do early return, but I don't think in this particular case it's really needed, because indention is low.",
        "pr_file_module": null
      },
      {
        "comment_id": "1589784776",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7935,
        "pr_file": "alacritty/src/event.rs",
        "discussion_id": "1589672105",
        "commented_code": "@@ -66,6 +65,374 @@ const MAX_SEARCH_HISTORY_SIZE: usize = 255;\n /// Touch zoom speed.\n const TOUCH_ZOOM_FACTOR: f32 = 0.01;\n \n+/// The event processor.\n+///\n+/// Stores some state from received events and dispatches actions when they are\n+/// triggered.\n+pub struct Processor {\n+    clipboard: Clipboard,\n+    scheduler: Scheduler,\n+    initial_window_options: Option<WindowOptions>,\n+    initial_window_error: Option<Box<dyn Error>>,\n+    windows: HashMap<WindowId, WindowContext, RandomState>,\n+    proxy: EventLoopProxy<Event>,\n+    gl_display: Option<GlutinDisplay>,\n+    #[cfg(unix)]\n+    global_ipc_options: ParsedOptions,\n+    cli_options: CliOptions,\n+    config: Rc<UiConfig>,\n+}\n+\n+impl Processor {\n+    /// Create a new event processor.\n+    ///\n+    /// Takes a writer which is expected to be hooked up to the write end of a PTY.\n+    pub fn new(\n+        config: UiConfig,\n+        cli_options: CliOptions,\n+        event_loop: &EventLoop<Event>,\n+    ) -> Processor {\n+        let proxy = event_loop.create_proxy();\n+        let scheduler = Scheduler::new(proxy.clone());\n+        let initial_window_options = Some(cli_options.window_options.clone());\n+\n+        // Disable all device events, since we don't care about them.\n+        event_loop.listen_device_events(DeviceEvents::Never);\n+\n+        // SAFETY: Since this takes a pointer to the winit event loop, it MUST be dropped first,\n+        // which is done in `loop_exiting`.\n+        let clipboard = unsafe { Clipboard::new(event_loop.raw_display_handle()) };\n+\n+        Processor {\n+            initial_window_options,\n+            initial_window_error: None,\n+            cli_options,\n+            proxy,\n+            scheduler,\n+            gl_display: None,\n+            config: Rc::new(config),\n+            clipboard,\n+            windows: Default::default(),\n+            #[cfg(unix)]\n+            global_ipc_options: Default::default(),\n+        }\n+    }\n+\n+    /// Create initial window and load GL platform.\n+    ///\n+    /// This will initialize the OpenGL Api and pick a config that\n+    /// will be used for the rest of the windows.\n+    pub fn create_initial_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window_context =\n+            WindowContext::initial(event_loop, self.proxy.clone(), self.config.clone(), options)?;\n+\n+        self.gl_display = Some(window_context.display.gl_context().display());\n+        self.windows.insert(window_context.id(), window_context);\n+\n+        Ok(())\n+    }\n+\n+    /// Create a new terminal window.\n+    pub fn create_window(\n+        &mut self,\n+        event_loop: &ActiveEventLoop,\n+        options: WindowOptions,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let window = self.windows.iter().next().as_ref().unwrap().1;\n+\n+        // Overide config with CLI/IPC options.\n+        let mut config_overrides = options.config_overrides();\n+        #[cfg(unix)]\n+        config_overrides.extend_from_slice(&self.global_ipc_options);\n+        let mut config = self.config.clone();\n+        config = config_overrides.override_config_rc(config);\n+\n+        #[allow(unused_mut)]\n+        let mut window_context =\n+            window.additional(event_loop, self.proxy.clone(), config, options, config_overrides)?;\n+\n+        self.windows.insert(window_context.id(), window_context);\n+        Ok(())\n+    }\n+\n+    /// Run the event loop.\n+    ///\n+    /// The result is exit code generate from the loop.\n+    pub fn run(mut self, event_loop: EventLoop<Event>) -> Result<(), Box<dyn Error>> {\n+        let result = event_loop.run_app(&mut self);\n+        if let Some(initial_window_error) = self.initial_window_error.take() {\n+            Err(initial_window_error)\n+        } else {\n+            result.map_err(Into::into)\n+        }\n+    }\n+\n+    /// Check if an event is irrelevant and can be skipped.\n+    fn skip_window_event(event: &WindowEvent) -> bool {\n+        matches!(\n+            event,\n+            WindowEvent::KeyboardInput { is_synthetic: true, .. }\n+                | WindowEvent::ActivationTokenDone { .. }\n+                | WindowEvent::DoubleTapGesture { .. }\n+                | WindowEvent::TouchpadPressure { .. }\n+                | WindowEvent::RotationGesture { .. }\n+                | WindowEvent::CursorEntered { .. }\n+                | WindowEvent::PinchGesture { .. }\n+                | WindowEvent::AxisMotion { .. }\n+                | WindowEvent::PanGesture { .. }\n+                | WindowEvent::HoveredFileCancelled\n+                | WindowEvent::Destroyed\n+                | WindowEvent::ThemeChanged(_)\n+                | WindowEvent::HoveredFile(_)\n+                | WindowEvent::Moved(_)\n+        )\n+    }\n+}\n+\n+impl ApplicationHandler<Event> for Processor {\n+    fn resumed(&mut self, _event_loop: &ActiveEventLoop) {\n+        // We use `new_events` because we target only desktop.\n+    }\n+\n+    fn new_events(&mut self, event_loop: &ActiveEventLoop, cause: StartCause) {\n+        if cause == StartCause::Init {",
        "comment_created_at": "2024-05-03T22:44:01+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "I mean it's 4 levels of indentation already. With kernel indentation rules that would be 32 columns of indentation alone for the deepest level. I wouldn't call that \"low\".\r\n\r\nIf there were plans to handle different causes in the future, it might be different. But I don't see any immediate reason why we **ever** would handle different causes, and if we did, we'd probably switch to a match anyway. So I fail to see how an early return isn't the best option here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1501255928",
    "pr_number": 7729,
    "pr_file": "alacritty_config_derive/src/serde_replace.rs",
    "created_at": "2024-02-23T23:09:13+00:00",
    "commented_code": "crate::generics_streams(&generics.params);\n     let replace_arms = match_arms(&fields);\n \n-    quote! {\n-        #[allow(clippy::extra_unused_lifetimes)]\n-        impl <'de, #constrained> alacritty_config::SerdeReplace for #ident <#unconstrained> {\n-            fn replace(&mut self, value: toml::Value) -> Result<(), Box<dyn std::error::Error>> {\n-                match value.as_table() {\n-                    Some(table) => {\n-                        for (field, next_value) in table {\n-                            let next_value = next_value.clone();\n-                            let value = value.clone();\n-\n-                            match field.as_str() {\n-                                #replace_arms\n-                                _ => {\n-                                    let error = format!(\"Field \\\"{}\\\" does not exist\", field);\n-                                    return Err(error.into());\n-                                },\n-                            }\n+    match replace_arms {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1501255928",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7729,
        "pr_file": "alacritty_config_derive/src/serde_replace.rs",
        "discussion_id": "1501255928",
        "commented_code": "@@ -46,36 +46,41 @@ pub fn derive_recursive<T>(\n         crate::generics_streams(&generics.params);\n     let replace_arms = match_arms(&fields);\n \n-    quote! {\n-        #[allow(clippy::extra_unused_lifetimes)]\n-        impl <'de, #constrained> alacritty_config::SerdeReplace for #ident <#unconstrained> {\n-            fn replace(&mut self, value: toml::Value) -> Result<(), Box<dyn std::error::Error>> {\n-                match value.as_table() {\n-                    Some(table) => {\n-                        for (field, next_value) in table {\n-                            let next_value = next_value.clone();\n-                            let value = value.clone();\n-\n-                            match field.as_str() {\n-                                #replace_arms\n-                                _ => {\n-                                    let error = format!(\"Field \\\"{}\\\" does not exist\", field);\n-                                    return Err(error.into());\n-                                },\n-                            }\n+    match replace_arms {",
        "comment_created_at": "2024-02-23T23:09:13+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "This is going to be **far** cleaner if you early return on error. Just to deal with the already ridiculous amount of indentation.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1419673283",
    "pr_number": 7424,
    "pr_file": "alacritty/src/input/keyboard.rs",
    "created_at": "2023-12-07T21:19:49+00:00",
    "commented_code": "mods: ModifiersState,\n     ) -> bool {\n         if mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC) {\n-            true\n-        } else if mode.contains(TermMode::DISAMBIGUATE_ESC_CODES) {\n+            return true;\n+        }\n+\n+        let disambiguate = if mode.contains(TermMode::DISAMBIGUATE_ESC_CODES) {\n             let on_numpad = key.location == KeyLocation::Numpad;\n             let is_escape = key.logical_key == Key::Named(NamedKey::Escape);\n             is_escape || (!mods.is_empty() && mods != ModifiersState::SHIFT) || on_numpad\n         } else {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1419673283",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7424,
        "pr_file": "alacritty/src/input/keyboard.rs",
        "discussion_id": "1419673283",
        "commented_code": "@@ -107,15 +107,22 @@ impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n         mods: ModifiersState,\n     ) -> bool {\n         if mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC) {\n-            true\n-        } else if mode.contains(TermMode::DISAMBIGUATE_ESC_CODES) {\n+            return true;\n+        }\n+\n+        let disambiguate = if mode.contains(TermMode::DISAMBIGUATE_ESC_CODES) {\n             let on_numpad = key.location == KeyLocation::Numpad;\n             let is_escape = key.logical_key == Key::Named(NamedKey::Escape);\n             is_escape || (!mods.is_empty() && mods != ModifiersState::SHIFT) || on_numpad\n         } else {",
        "comment_created_at": "2023-12-07T21:19:49+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "The else branch is just `false`, so this can probably be written as a single conditional?\r\n\r\nYou could still keep the variables extracted for documentation purposes, but they're also pretty self-documenting.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "909402246",
    "pr_number": 6139,
    "pr_file": "alacritty_terminal/src/term/cell.rs",
    "created_at": "2022-06-29T09:21:57+00:00",
    "commented_code": "pub fn underline_color(&self) -> Option<Color> {\n         self.extra.as_ref()?.underline_color\n     }\n+\n+    /// Set hyperlink.\n+    pub fn set_hyperlink(&mut self, hyperlink: Option<Hyperlink>) {\n+        let drop_hyperlink = hyperlink.is_none()\n+            && self.extra.as_ref().map_or(true, |extra| {\n+                !extra.zerowidth.is_empty() || extra.underline_color.is_some()\n+            });\n+\n+        if drop_hyperlink {\n+            self.extra = None;\n+            return;\n+        }\n+\n+        let extra = self.extra.get_or_insert(Default::default());\n+        Arc::make_mut(extra).hyperlink = hyperlink;",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "909402246",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty_terminal/src/term/cell.rs",
        "discussion_id": "909402246",
        "commented_code": "@@ -128,6 +182,28 @@ impl Cell {\n     pub fn underline_color(&self) -> Option<Color> {\n         self.extra.as_ref()?.underline_color\n     }\n+\n+    /// Set hyperlink.\n+    pub fn set_hyperlink(&mut self, hyperlink: Option<Hyperlink>) {\n+        let drop_hyperlink = hyperlink.is_none()\n+            && self.extra.as_ref().map_or(true, |extra| {\n+                !extra.zerowidth.is_empty() || extra.underline_color.is_some()\n+            });\n+\n+        if drop_hyperlink {\n+            self.extra = None;\n+            return;\n+        }\n+\n+        let extra = self.extra.get_or_insert(Default::default());\n+        Arc::make_mut(extra).hyperlink = hyperlink;",
        "comment_created_at": "2022-06-29T09:21:57+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "```suggestion\r\n        if drop_hyperlink {\r\n            self.extra = None;\r\n        } else {\r\n            let extra = self.extra.get_or_insert(Default::default());\r\n            Arc::make_mut(extra).hyperlink = hyperlink;\r\n        }\r\n```\r\n\r\nShould avoid the extra return, just complicates control flow.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "915468894",
    "pr_number": 6139,
    "pr_file": "alacritty/src/display/mod.rs",
    "created_at": "2022-07-07T05:21:17+00:00",
    "commented_code": "}\n \n     /// Format search regex to account for the cursor and fullwidth characters.\n-    fn format_search(size_info: &SizeInfo, search_regex: &str, search_label: &str) -> String {\n-        // Add spacers for wide chars.\n-        let mut formatted_regex = String::with_capacity(search_regex.len());\n-        for c in search_regex.chars() {\n-            formatted_regex.push(c);\n-            if c.width() == Some(2) {\n-                formatted_regex.push(' ');\n+    fn format_search(search_regex: &str, search_label: &str, max_width: usize) -> String {\n+        let label_len = search_label.len();\n+\n+        // If the label doesn't fit into screen return.\n+        if label_len > max_width {\n+            return search_label[..max_width].to_owned();\n+        }\n+\n+        // The search string consists of `search_label` + `search_regex` + `cursor`.\n+        let mut bar_text = String::from(search_label);\n+        bar_text.extend(\n+            Self::format_visible_text(\n+                iter::once('_').chain(search_regex.chars().rev()),\n+                max_width - label_len,\n+                None,\n+            )\n+            .into_iter()\n+            .rev(),\n+        );\n+\n+        bar_text\n+    }\n+\n+    /// Format text to fit into visible on-screen element, like `footer_bar`.\n+    pub fn format_visible_text(\n+        chars: impl Iterator<Item = char>,\n+        max_width: usize,\n+        shortener: Option<char>,\n+    ) -> Vec<char> {\n+        let mut visible_text = Vec::<char>::with_capacity(max_width);\n+        let mut num_chars = 0;\n+\n+        for ch in chars {\n+            let char_width = ch.width().unwrap_or(1);\n+\n+            // If the text doesn't fit into `max_width` terminate iteration.\n+            if num_chars + char_width > max_width {\n+                // Put shortener if it was provided to indicate that text got shortened.\n+                let shortener = match shortener {\n+                    Some(shortener) => shortener,\n+                    None => break,\n+                };\n+\n+                let shortener_position = if num_chars < max_width {\n+                    // Allocate space for the char we're about to write.\n+                    visible_text.push(' ');\n+                    num_chars\n+                } else if num_chars > 1\n+                    && visible_text.get(num_chars - 2).and_then(|ch| ch.width()) == Some(2)\n+                {\n+                    // Remove the trailing space.\n+                    let _ = visible_text.pop();\n+                    num_chars - 2\n+                } else {\n+                    num_chars - 1\n+                };\n+\n+                visible_text[shortener_position] = shortener;\n+\n+                break;\n             }\n+\n+            visible_text.push(ch);\n+\n+            // Add spacers for wide chars.\n+            if char_width == 2 {\n+                visible_text.push(' ');\n+            }\n+\n+            num_chars += char_width;",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "915468894",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 6139,
        "pr_file": "alacritty/src/display/mod.rs",
        "discussion_id": "915468894",
        "commented_code": "@@ -980,74 +1020,203 @@ impl Display {\n     }\n \n     /// Format search regex to account for the cursor and fullwidth characters.\n-    fn format_search(size_info: &SizeInfo, search_regex: &str, search_label: &str) -> String {\n-        // Add spacers for wide chars.\n-        let mut formatted_regex = String::with_capacity(search_regex.len());\n-        for c in search_regex.chars() {\n-            formatted_regex.push(c);\n-            if c.width() == Some(2) {\n-                formatted_regex.push(' ');\n+    fn format_search(search_regex: &str, search_label: &str, max_width: usize) -> String {\n+        let label_len = search_label.len();\n+\n+        // If the label doesn't fit into screen return.\n+        if label_len > max_width {\n+            return search_label[..max_width].to_owned();\n+        }\n+\n+        // The search string consists of `search_label` + `search_regex` + `cursor`.\n+        let mut bar_text = String::from(search_label);\n+        bar_text.extend(\n+            Self::format_visible_text(\n+                iter::once('_').chain(search_regex.chars().rev()),\n+                max_width - label_len,\n+                None,\n+            )\n+            .into_iter()\n+            .rev(),\n+        );\n+\n+        bar_text\n+    }\n+\n+    /// Format text to fit into visible on-screen element, like `footer_bar`.\n+    pub fn format_visible_text(\n+        chars: impl Iterator<Item = char>,\n+        max_width: usize,\n+        shortener: Option<char>,\n+    ) -> Vec<char> {\n+        let mut visible_text = Vec::<char>::with_capacity(max_width);\n+        let mut num_chars = 0;\n+\n+        for ch in chars {\n+            let char_width = ch.width().unwrap_or(1);\n+\n+            // If the text doesn't fit into `max_width` terminate iteration.\n+            if num_chars + char_width > max_width {\n+                // Put shortener if it was provided to indicate that text got shortened.\n+                let shortener = match shortener {\n+                    Some(shortener) => shortener,\n+                    None => break,\n+                };\n+\n+                let shortener_position = if num_chars < max_width {\n+                    // Allocate space for the char we're about to write.\n+                    visible_text.push(' ');\n+                    num_chars\n+                } else if num_chars > 1\n+                    && visible_text.get(num_chars - 2).and_then(|ch| ch.width()) == Some(2)\n+                {\n+                    // Remove the trailing space.\n+                    let _ = visible_text.pop();\n+                    num_chars - 2\n+                } else {\n+                    num_chars - 1\n+                };\n+\n+                visible_text[shortener_position] = shortener;\n+\n+                break;\n             }\n+\n+            visible_text.push(ch);\n+\n+            // Add spacers for wide chars.\n+            if char_width == 2 {\n+                visible_text.push(' ');\n+            }\n+\n+            num_chars += char_width;",
        "comment_created_at": "2022-07-07T05:21:17+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "I recommend putting this in an `else` block rather than `break`ing, it's way too big of a conditional block with the early return to put an early return just to skip 5 lines.",
        "pr_file_module": null
      }
    ]
  }
]