[
  {
    "discussion_id": "1405468938",
    "pr_number": 7125,
    "pr_file": "alacritty/src/input/keyboard.rs",
    "created_at": "2023-11-26T20:03:19+00:00",
    "commented_code": "+use std::borrow::Cow;\n+use std::mem;\n+\n+use winit::event::{ElementState, KeyEvent};\n+#[cfg(target_os = \"macos\")]\n+use winit::keyboard::ModifiersKeyState;\n+use winit::keyboard::{Key, KeyLocation, ModifiersState, NamedKey};\n+#[cfg(target_os = \"macos\")]\n+use winit::platform::macos::OptionAsAlt;\n+\n+use alacritty_terminal::event::EventListener;\n+use alacritty_terminal::term::TermMode;\n+use winit::platform::modifier_supplement::KeyEventExtModifierSupplement;\n+\n+use crate::config::{Action, BindingKey, BindingMode};\n+use crate::event::TYPING_SEARCH_DELAY;\n+use crate::input::{ActionContext, Execute, Processor};\n+use crate::scheduler::{TimerId, Topic};\n+\n+impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n+    /// Process key input.\n+    pub fn key_input(&mut self, key: KeyEvent) {\n+        // IME input will be applied on commit and shouldn't trigger key bindings.\n+        if self.ctx.display().ime.preedit().is_some() {\n+            return;\n+        }\n+\n+        let mode = *self.ctx.terminal().mode();\n+        let mods = self.ctx.modifiers().state();\n+\n+        if key.state == ElementState::Released {\n+            self.key_release(key, mode, mods);\n+            return;\n+        }\n+\n+        let text = key.text_with_all_modifiers().unwrap_or_default();\n+\n+        // All key bindings are disabled while a hint is being selected.\n+        if self.ctx.display().hint_state.active() {\n+            for character in text.chars() {\n+                self.ctx.hint_input(character);\n+            }\n+            return;\n+        }\n+\n+        // First key after inline search is captured.\n+        let inline_state = self.ctx.inline_search_state();\n+        if mem::take(&mut inline_state.char_pending) {\n+            if let Some(c) = text.chars().next() {\n+                inline_state.character = Some(c);\n+\n+                // Immediately move to the captured character.\n+                self.ctx.inline_search_next();\n+            }\n+\n+            // Ignore all other characters in `text`.\n+            return;\n+        }\n+\n+        // Reset search delay when the user is still typing.\n+        self.reset_search_delay();\n+\n+        // Key bindings suppress the character input.\n+        if self.process_key_bindings(&key) {\n+            return;\n+        }\n+\n+        if self.ctx.search_active() {\n+            for character in text.chars() {\n+                self.ctx.search_input(character);\n+            }\n+\n+            return;\n+        }\n+\n+        // Vi mode on its own doesn't have any input, the search input was done before.\n+        if mode.contains(TermMode::VI) {\n+            return;\n+        }\n+\n+        let build_key_sequence = Self::should_build_esc_key_sequence(&key, text, mode, mods);\n+\n+        let bytes = if build_key_sequence {\n+            build_key_esc_sequence(key, mods, mode)\n+        } else {\n+            let mut bytes = Vec::with_capacity(text.len() + 1);\n+            if self.alt_send_esc() && text.len() == 1 {\n+                bytes.push(b'\\x1b');\n+            }\n+\n+            bytes.extend_from_slice(text.as_bytes());\n+            bytes\n+        };\n+\n+        // Write only if we have something to write.\n+        if !bytes.is_empty() {\n+            self.ctx.on_terminal_input_start();\n+            self.ctx.write_to_pty(bytes);\n+        }\n+    }\n+\n+    /// Check whether we should try to build escape sequence for the [`KeyEvent`].\n+    fn should_build_esc_key_sequence(\n+        key: &KeyEvent,\n+        text: &str,\n+        mode: TermMode,\n+        mods: ModifiersState,\n+    ) -> bool {\n+        if mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC) {\n+            true\n+        } else if mode.contains(TermMode::DISAMBIGUATE_ESC_CODES) {\n+            let on_numpad = key.location == KeyLocation::Numpad;\n+            let is_escape = key.logical_key == Key::Named(NamedKey::Escape);\n+            is_escape || (!mods.is_empty() && mods != ModifiersState::SHIFT) || on_numpad\n+        } else {\n+            // `Delete` key always has text attached to it, but it's a named key, thus needs to be\n+            // excluded here as well.\n+            text.is_empty() || key.logical_key == Key::Named(NamedKey::Delete)\n+        }\n+    }\n+\n+    /// Whether we should send `ESC` due to `Alt` being pressed.\n+    #[cfg(not(target_os = \"macos\"))]\n+    fn alt_send_esc(&mut self) -> bool {\n+        self.ctx.modifiers().state().alt_key()\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    fn alt_send_esc(&mut self) -> bool {\n+        let option_as_alt = self.ctx.config().window.option_as_alt();\n+        self.ctx.modifiers().state().alt_key()\n+            && (option_as_alt == OptionAsAlt::Both\n+                || (option_as_alt == OptionAsAlt::OnlyLeft\n+                    && self.ctx.modifiers().lalt_state() == ModifiersKeyState::Pressed)\n+                || (option_as_alt == OptionAsAlt::OnlyRight\n+                    && self.ctx.modifiers().ralt_state() == ModifiersKeyState::Pressed))\n+    }\n+\n+    /// Attempt to find a binding and execute its action.\n+    ///\n+    /// The provided mode, mods, and key must match what is allowed by a binding\n+    /// for its action to be executed.\n+    fn process_key_bindings(&mut self, key: &KeyEvent) -> bool {\n+        let mode = BindingMode::new(self.ctx.terminal().mode(), self.ctx.search_active());\n+        let mods = self.ctx.modifiers().state();\n+\n+        // Don't suppress char if no bindings were triggered.\n+        let mut suppress_chars = None;\n+\n+        for i in 0..self.ctx.config().key_bindings().len() {\n+            let binding = &self.ctx.config().key_bindings()[i];\n+\n+            // We don't want the key without modifier, because it means something else most of\n+            // the time. However what we want is to manually lowercase the character to account\n+            // for both small and capital letters on regular characters at the same time.\n+            let logical_key = if let Key::Character(ch) = key.logical_key.as_ref() {\n+                Key::Character(ch.to_lowercase().into())\n+            } else {\n+                key.logical_key.clone()\n+            };\n+\n+            let key = match (&binding.trigger, logical_key) {\n+                (BindingKey::Scancode(_), _) => BindingKey::Scancode(key.physical_key),\n+                (_, code) => BindingKey::Keycode { key: code, location: key.location.into() },\n+            };\n+\n+            if binding.is_triggered_by(mode, mods, &key) {\n+                // Pass through the key if any of the bindings has the `ReceiveChar` action.\n+                *suppress_chars.get_or_insert(true) &= binding.action != Action::ReceiveChar;\n+\n+                // Binding was triggered; run the action.\n+                binding.action.clone().execute(&mut self.ctx);\n+            }\n+        }\n+\n+        suppress_chars.unwrap_or(false)\n+    }\n+\n+    /// Handle key release.\n+    fn key_release(&mut self, key: KeyEvent, mode: TermMode, mods: ModifiersState) {\n+        if mode.contains(TermMode::REPORT_EVENT_TYPES)\n+            && !mode.contains(TermMode::VI)\n+            && !self.ctx.search_active()\n+            && !self.ctx.display().hint_state.active()\n+        {\n+            let bytes: Cow<'static, [u8]> = match key.logical_key.as_ref() {\n+                // NOTE echo the key back on release to follow kitty/foot behavior. When\n+                // KEYBOARD_REPORT_ALL_KEYS_AS_ESC is used, we build proper escapes for\n+                // the keys below.\n+                _ if mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC) => {\n+                    build_key_esc_sequence(key, mods, mode).into()\n+                },\n+                // Winit uses different keys for `Backspace` so we expliictly specify the\n+                // values, instead of using what was passed to us from it.\n+                Key::Named(NamedKey::Tab) => [b'\\t'].as_slice().into(),\n+                Key::Named(NamedKey::Enter) => [b'\\r'].as_slice().into(),\n+                Key::Named(NamedKey::Backspace) => [b'\\x7f'].as_slice().into(),\n+                Key::Named(NamedKey::Escape) => [b'\\x1b'].as_slice().into(),\n+                _ => build_key_esc_sequence(key, mods, mode).into(),\n+            };\n+\n+            self.ctx.write_to_pty(bytes);\n+        }\n+    }\n+\n+    /// Reset search delay.\n+    fn reset_search_delay(&mut self) {\n+        if self.ctx.search_active() {\n+            let timer_id = TimerId::new(Topic::DelayedSearch, self.ctx.window().id());\n+            let scheduler = self.ctx.scheduler_mut();\n+            if let Some(timer) = scheduler.unschedule(timer_id) {\n+                scheduler.schedule(timer.event, TYPING_SEARCH_DELAY, false, timer.id);\n+            }\n+        }\n+    }\n+}\n+\n+/// Build a key's keyboard escape sequence based on the given `key`, `mods`, and `mode`.\n+///\n+/// The key sequences for `APP_KEYPAD` and alike are handled inside the bindings.\n+#[inline(never)]\n+fn build_key_esc_sequence(key: KeyEvent, mods: ModifiersState, mode: TermMode) -> Vec<u8> {\n+    let modifiers = mods.into();\n+\n+    let kitty_seq = mode.intersects(\n+        TermMode::REPORT_ALL_KEYS_AS_ESC\n+            | TermMode::DISAMBIGUATE_ESC_CODES\n+            | TermMode::REPORT_EVENT_TYPES,\n+    );\n+\n+    let kitty_encode_all = mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC);\n+    // The `Press` is ignored here, since it's a default and no need to report it.\n+    let kitty_event_type = mode.contains(TermMode::REPORT_EVENT_TYPES)\n+        && (key.repeat || key.state == ElementState::Released);\n+\n+    let context = KeyEscSequenceBuildingContext {\n+        mode,\n+        modifiers,\n+        kitty_seq,\n+        kitty_encode_all,\n+        kitty_event_type,\n+    };\n+\n+    let sequence_base = context\n+        .prepare_numpad_base(&key)\n+        .or_else(|| context.prepare_named_base(&key))\n+        .or_else(|| context.prepare_control_and_mods(&key))\n+        .or_else(|| context.prepare_text_base(&key));\n+\n+    let (payload, terminator) = match sequence_base {\n+        Some(KeyEscSequenceBase { payload, terminator }) => (payload, terminator),\n+        _ => return Vec::new(),\n+    };\n+\n+    let mut payload = format!(\"\\x1b[{}\", payload);\n+\n+    // Add modifiers information.\n+    if kitty_event_type\n+        || !modifiers.is_empty()\n+        || (mode.contains(TermMode::REPORT_ASSOCIATED_TEXT) && key.text.is_some())\n+    {\n+        payload.push_str(&format!(\";{}\", modifiers.esc_sequence_encoded()));\n+    }\n+\n+    // Push event type.\n+    if kitty_event_type {\n+        payload.push(':');\n+        let event_type = match key.state {\n+            _ if key.repeat => '2',\n+            ElementState::Pressed => '1',\n+            ElementState::Released => '3',\n+        };\n+        payload.push(event_type);\n+    }\n+\n+    // Associated text is not reported for the control/alt/logo key presses.\n+    if mode.contains(TermMode::REPORT_ASSOCIATED_TEXT)\n+        && key.state != ElementState::Released\n+        && (modifiers.is_empty() || modifiers == EscSequenceModifiers::SHIFT)\n+    {\n+        if let Some(text) = key.text {\n+            let mut codepoints = text.chars().map(u32::from);\n+            if let Some(codepoint) = codepoints.next() {\n+                payload.push_str(&format!(\";{codepoint}\"));\n+            }\n+            // Push the rest of the chars.\n+            for codepoint in codepoints {\n+                payload.push_str(&format!(\":{codepoint}\"));\n+            }\n+        }\n+    }\n+\n+    payload.push(terminator);\n+\n+    payload.into_bytes()\n+}\n+\n+/// Helper to create esc sequence payloads from [`KeyEvent`].\n+pub struct KeyEscSequenceBuildingContext {\n+    mode: TermMode,\n+    /// The emitted sequence should follow the kitty keyboard protocol.\n+    kitty_seq: bool,\n+    /// Encode all the keys according to the protocol.\n+    kitty_encode_all: bool,\n+    /// Report event types.\n+    kitty_event_type: bool,\n+    modifiers: EscSequenceModifiers,\n+}\n+\n+impl KeyEscSequenceBuildingContext {\n+    /// Prepare key with the text attached to it.\n+    fn prepare_text_base(&self, key: &KeyEvent) -> Option<KeyEscSequenceBase> {\n+        let character = match key.logical_key.as_ref() {\n+            Key::Character(character) => character,\n+            _ => return None,\n+        };\n+\n+        // Character from winit is non-empty.\n+        if character.chars().count() == 1 {\n+            let character = character.chars().next().unwrap();\n+            let base_character = character.to_lowercase().next().unwrap();\n+\n+            let codepoint = u32::from(character);\n+            let base_codepoint = u32::from(base_character);\n+\n+            // NOTE: Base layouts are ignored, since winit doesn't expose this information\n+            // yet.\n+            let payload = if self.mode.contains(TermMode::REPORT_ALTERNATE_KEYS)\n+                && codepoint != base_codepoint\n+            {\n+                format!(\"{codepoint}:{base_codepoint}\")\n+            } else {\n+                codepoint.to_string()\n+            };\n+\n+            Some(KeyEscSequenceBase::new(payload.into(), 'u'))\n+        } else if self.kitty_encode_all\n+            && self.mode.contains(TermMode::REPORT_ASSOCIATED_TEXT)\n+            && key.text.is_some()\n+        {\n+            // When associated text is requested along the encode all and we have more than one\n+            // character, we should use codepoint '0' with 'u' suffix.\n+            Some(KeyEscSequenceBase::new(\"0\".into(), 'u'))",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1405468938",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7125,
        "pr_file": "alacritty/src/input/keyboard.rs",
        "discussion_id": "1405468938",
        "commented_code": "@@ -0,0 +1,600 @@\n+use std::borrow::Cow;\n+use std::mem;\n+\n+use winit::event::{ElementState, KeyEvent};\n+#[cfg(target_os = \"macos\")]\n+use winit::keyboard::ModifiersKeyState;\n+use winit::keyboard::{Key, KeyLocation, ModifiersState, NamedKey};\n+#[cfg(target_os = \"macos\")]\n+use winit::platform::macos::OptionAsAlt;\n+\n+use alacritty_terminal::event::EventListener;\n+use alacritty_terminal::term::TermMode;\n+use winit::platform::modifier_supplement::KeyEventExtModifierSupplement;\n+\n+use crate::config::{Action, BindingKey, BindingMode};\n+use crate::event::TYPING_SEARCH_DELAY;\n+use crate::input::{ActionContext, Execute, Processor};\n+use crate::scheduler::{TimerId, Topic};\n+\n+impl<T: EventListener, A: ActionContext<T>> Processor<T, A> {\n+    /// Process key input.\n+    pub fn key_input(&mut self, key: KeyEvent) {\n+        // IME input will be applied on commit and shouldn't trigger key bindings.\n+        if self.ctx.display().ime.preedit().is_some() {\n+            return;\n+        }\n+\n+        let mode = *self.ctx.terminal().mode();\n+        let mods = self.ctx.modifiers().state();\n+\n+        if key.state == ElementState::Released {\n+            self.key_release(key, mode, mods);\n+            return;\n+        }\n+\n+        let text = key.text_with_all_modifiers().unwrap_or_default();\n+\n+        // All key bindings are disabled while a hint is being selected.\n+        if self.ctx.display().hint_state.active() {\n+            for character in text.chars() {\n+                self.ctx.hint_input(character);\n+            }\n+            return;\n+        }\n+\n+        // First key after inline search is captured.\n+        let inline_state = self.ctx.inline_search_state();\n+        if mem::take(&mut inline_state.char_pending) {\n+            if let Some(c) = text.chars().next() {\n+                inline_state.character = Some(c);\n+\n+                // Immediately move to the captured character.\n+                self.ctx.inline_search_next();\n+            }\n+\n+            // Ignore all other characters in `text`.\n+            return;\n+        }\n+\n+        // Reset search delay when the user is still typing.\n+        self.reset_search_delay();\n+\n+        // Key bindings suppress the character input.\n+        if self.process_key_bindings(&key) {\n+            return;\n+        }\n+\n+        if self.ctx.search_active() {\n+            for character in text.chars() {\n+                self.ctx.search_input(character);\n+            }\n+\n+            return;\n+        }\n+\n+        // Vi mode on its own doesn't have any input, the search input was done before.\n+        if mode.contains(TermMode::VI) {\n+            return;\n+        }\n+\n+        let build_key_sequence = Self::should_build_esc_key_sequence(&key, text, mode, mods);\n+\n+        let bytes = if build_key_sequence {\n+            build_key_esc_sequence(key, mods, mode)\n+        } else {\n+            let mut bytes = Vec::with_capacity(text.len() + 1);\n+            if self.alt_send_esc() && text.len() == 1 {\n+                bytes.push(b'\\x1b');\n+            }\n+\n+            bytes.extend_from_slice(text.as_bytes());\n+            bytes\n+        };\n+\n+        // Write only if we have something to write.\n+        if !bytes.is_empty() {\n+            self.ctx.on_terminal_input_start();\n+            self.ctx.write_to_pty(bytes);\n+        }\n+    }\n+\n+    /// Check whether we should try to build escape sequence for the [`KeyEvent`].\n+    fn should_build_esc_key_sequence(\n+        key: &KeyEvent,\n+        text: &str,\n+        mode: TermMode,\n+        mods: ModifiersState,\n+    ) -> bool {\n+        if mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC) {\n+            true\n+        } else if mode.contains(TermMode::DISAMBIGUATE_ESC_CODES) {\n+            let on_numpad = key.location == KeyLocation::Numpad;\n+            let is_escape = key.logical_key == Key::Named(NamedKey::Escape);\n+            is_escape || (!mods.is_empty() && mods != ModifiersState::SHIFT) || on_numpad\n+        } else {\n+            // `Delete` key always has text attached to it, but it's a named key, thus needs to be\n+            // excluded here as well.\n+            text.is_empty() || key.logical_key == Key::Named(NamedKey::Delete)\n+        }\n+    }\n+\n+    /// Whether we should send `ESC` due to `Alt` being pressed.\n+    #[cfg(not(target_os = \"macos\"))]\n+    fn alt_send_esc(&mut self) -> bool {\n+        self.ctx.modifiers().state().alt_key()\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    fn alt_send_esc(&mut self) -> bool {\n+        let option_as_alt = self.ctx.config().window.option_as_alt();\n+        self.ctx.modifiers().state().alt_key()\n+            && (option_as_alt == OptionAsAlt::Both\n+                || (option_as_alt == OptionAsAlt::OnlyLeft\n+                    && self.ctx.modifiers().lalt_state() == ModifiersKeyState::Pressed)\n+                || (option_as_alt == OptionAsAlt::OnlyRight\n+                    && self.ctx.modifiers().ralt_state() == ModifiersKeyState::Pressed))\n+    }\n+\n+    /// Attempt to find a binding and execute its action.\n+    ///\n+    /// The provided mode, mods, and key must match what is allowed by a binding\n+    /// for its action to be executed.\n+    fn process_key_bindings(&mut self, key: &KeyEvent) -> bool {\n+        let mode = BindingMode::new(self.ctx.terminal().mode(), self.ctx.search_active());\n+        let mods = self.ctx.modifiers().state();\n+\n+        // Don't suppress char if no bindings were triggered.\n+        let mut suppress_chars = None;\n+\n+        for i in 0..self.ctx.config().key_bindings().len() {\n+            let binding = &self.ctx.config().key_bindings()[i];\n+\n+            // We don't want the key without modifier, because it means something else most of\n+            // the time. However what we want is to manually lowercase the character to account\n+            // for both small and capital letters on regular characters at the same time.\n+            let logical_key = if let Key::Character(ch) = key.logical_key.as_ref() {\n+                Key::Character(ch.to_lowercase().into())\n+            } else {\n+                key.logical_key.clone()\n+            };\n+\n+            let key = match (&binding.trigger, logical_key) {\n+                (BindingKey::Scancode(_), _) => BindingKey::Scancode(key.physical_key),\n+                (_, code) => BindingKey::Keycode { key: code, location: key.location.into() },\n+            };\n+\n+            if binding.is_triggered_by(mode, mods, &key) {\n+                // Pass through the key if any of the bindings has the `ReceiveChar` action.\n+                *suppress_chars.get_or_insert(true) &= binding.action != Action::ReceiveChar;\n+\n+                // Binding was triggered; run the action.\n+                binding.action.clone().execute(&mut self.ctx);\n+            }\n+        }\n+\n+        suppress_chars.unwrap_or(false)\n+    }\n+\n+    /// Handle key release.\n+    fn key_release(&mut self, key: KeyEvent, mode: TermMode, mods: ModifiersState) {\n+        if mode.contains(TermMode::REPORT_EVENT_TYPES)\n+            && !mode.contains(TermMode::VI)\n+            && !self.ctx.search_active()\n+            && !self.ctx.display().hint_state.active()\n+        {\n+            let bytes: Cow<'static, [u8]> = match key.logical_key.as_ref() {\n+                // NOTE echo the key back on release to follow kitty/foot behavior. When\n+                // KEYBOARD_REPORT_ALL_KEYS_AS_ESC is used, we build proper escapes for\n+                // the keys below.\n+                _ if mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC) => {\n+                    build_key_esc_sequence(key, mods, mode).into()\n+                },\n+                // Winit uses different keys for `Backspace` so we expliictly specify the\n+                // values, instead of using what was passed to us from it.\n+                Key::Named(NamedKey::Tab) => [b'\\t'].as_slice().into(),\n+                Key::Named(NamedKey::Enter) => [b'\\r'].as_slice().into(),\n+                Key::Named(NamedKey::Backspace) => [b'\\x7f'].as_slice().into(),\n+                Key::Named(NamedKey::Escape) => [b'\\x1b'].as_slice().into(),\n+                _ => build_key_esc_sequence(key, mods, mode).into(),\n+            };\n+\n+            self.ctx.write_to_pty(bytes);\n+        }\n+    }\n+\n+    /// Reset search delay.\n+    fn reset_search_delay(&mut self) {\n+        if self.ctx.search_active() {\n+            let timer_id = TimerId::new(Topic::DelayedSearch, self.ctx.window().id());\n+            let scheduler = self.ctx.scheduler_mut();\n+            if let Some(timer) = scheduler.unschedule(timer_id) {\n+                scheduler.schedule(timer.event, TYPING_SEARCH_DELAY, false, timer.id);\n+            }\n+        }\n+    }\n+}\n+\n+/// Build a key's keyboard escape sequence based on the given `key`, `mods`, and `mode`.\n+///\n+/// The key sequences for `APP_KEYPAD` and alike are handled inside the bindings.\n+#[inline(never)]\n+fn build_key_esc_sequence(key: KeyEvent, mods: ModifiersState, mode: TermMode) -> Vec<u8> {\n+    let modifiers = mods.into();\n+\n+    let kitty_seq = mode.intersects(\n+        TermMode::REPORT_ALL_KEYS_AS_ESC\n+            | TermMode::DISAMBIGUATE_ESC_CODES\n+            | TermMode::REPORT_EVENT_TYPES,\n+    );\n+\n+    let kitty_encode_all = mode.contains(TermMode::REPORT_ALL_KEYS_AS_ESC);\n+    // The `Press` is ignored here, since it's a default and no need to report it.\n+    let kitty_event_type = mode.contains(TermMode::REPORT_EVENT_TYPES)\n+        && (key.repeat || key.state == ElementState::Released);\n+\n+    let context = KeyEscSequenceBuildingContext {\n+        mode,\n+        modifiers,\n+        kitty_seq,\n+        kitty_encode_all,\n+        kitty_event_type,\n+    };\n+\n+    let sequence_base = context\n+        .prepare_numpad_base(&key)\n+        .or_else(|| context.prepare_named_base(&key))\n+        .or_else(|| context.prepare_control_and_mods(&key))\n+        .or_else(|| context.prepare_text_base(&key));\n+\n+    let (payload, terminator) = match sequence_base {\n+        Some(KeyEscSequenceBase { payload, terminator }) => (payload, terminator),\n+        _ => return Vec::new(),\n+    };\n+\n+    let mut payload = format!(\"\\x1b[{}\", payload);\n+\n+    // Add modifiers information.\n+    if kitty_event_type\n+        || !modifiers.is_empty()\n+        || (mode.contains(TermMode::REPORT_ASSOCIATED_TEXT) && key.text.is_some())\n+    {\n+        payload.push_str(&format!(\";{}\", modifiers.esc_sequence_encoded()));\n+    }\n+\n+    // Push event type.\n+    if kitty_event_type {\n+        payload.push(':');\n+        let event_type = match key.state {\n+            _ if key.repeat => '2',\n+            ElementState::Pressed => '1',\n+            ElementState::Released => '3',\n+        };\n+        payload.push(event_type);\n+    }\n+\n+    // Associated text is not reported for the control/alt/logo key presses.\n+    if mode.contains(TermMode::REPORT_ASSOCIATED_TEXT)\n+        && key.state != ElementState::Released\n+        && (modifiers.is_empty() || modifiers == EscSequenceModifiers::SHIFT)\n+    {\n+        if let Some(text) = key.text {\n+            let mut codepoints = text.chars().map(u32::from);\n+            if let Some(codepoint) = codepoints.next() {\n+                payload.push_str(&format!(\";{codepoint}\"));\n+            }\n+            // Push the rest of the chars.\n+            for codepoint in codepoints {\n+                payload.push_str(&format!(\":{codepoint}\"));\n+            }\n+        }\n+    }\n+\n+    payload.push(terminator);\n+\n+    payload.into_bytes()\n+}\n+\n+/// Helper to create esc sequence payloads from [`KeyEvent`].\n+pub struct KeyEscSequenceBuildingContext {\n+    mode: TermMode,\n+    /// The emitted sequence should follow the kitty keyboard protocol.\n+    kitty_seq: bool,\n+    /// Encode all the keys according to the protocol.\n+    kitty_encode_all: bool,\n+    /// Report event types.\n+    kitty_event_type: bool,\n+    modifiers: EscSequenceModifiers,\n+}\n+\n+impl KeyEscSequenceBuildingContext {\n+    /// Prepare key with the text attached to it.\n+    fn prepare_text_base(&self, key: &KeyEvent) -> Option<KeyEscSequenceBase> {\n+        let character = match key.logical_key.as_ref() {\n+            Key::Character(character) => character,\n+            _ => return None,\n+        };\n+\n+        // Character from winit is non-empty.\n+        if character.chars().count() == 1 {\n+            let character = character.chars().next().unwrap();\n+            let base_character = character.to_lowercase().next().unwrap();\n+\n+            let codepoint = u32::from(character);\n+            let base_codepoint = u32::from(base_character);\n+\n+            // NOTE: Base layouts are ignored, since winit doesn't expose this information\n+            // yet.\n+            let payload = if self.mode.contains(TermMode::REPORT_ALTERNATE_KEYS)\n+                && codepoint != base_codepoint\n+            {\n+                format!(\"{codepoint}:{base_codepoint}\")\n+            } else {\n+                codepoint.to_string()\n+            };\n+\n+            Some(KeyEscSequenceBase::new(payload.into(), 'u'))\n+        } else if self.kitty_encode_all\n+            && self.mode.contains(TermMode::REPORT_ASSOCIATED_TEXT)\n+            && key.text.is_some()\n+        {\n+            // When associated text is requested along the encode all and we have more than one\n+            // character, we should use codepoint '0' with 'u' suffix.\n+            Some(KeyEscSequenceBase::new(\"0\".into(), 'u'))",
        "comment_created_at": "2023-11-26T20:03:19+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "This function's API doesn't really make sense, the arguments here are seemingly arbitrary. This makes it look like any parameter is accepted for these parameters but that's just incorrect. The API should represent the accepted values and use enums where appropriate to prevent incorrect usage.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1514134846",
    "pr_number": 7794,
    "pr_file": "alacritty_terminal/src/tty/windows/child.rs",
    "created_at": "2024-03-06T09:32:42+00:00",
    "commented_code": "}\n \n     let event_tx: Box<_> = unsafe { Box::from_raw(ctx as *mut ChildExitSender) };\n-    let _ = event_tx.sender.send(ChildEvent::Exited);\n+    let child_handle = event_tx.child_handle.load(Ordering::Relaxed) as HANDLE;\n+    let mut exit_code = 0_u32;",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "1514134846",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7794,
        "pr_file": "alacritty_terminal/src/tty/windows/child.rs",
        "discussion_id": "1514134846",
        "commented_code": "@@ -31,7 +32,11 @@ extern \"system\" fn child_exit_callback(ctx: *mut c_void, timed_out: BOOLEAN) {\n     }\n \n     let event_tx: Box<_> = unsafe { Box::from_raw(ctx as *mut ChildExitSender) };\n-    let _ = event_tx.sender.send(ChildEvent::Exited);\n+    let child_handle = event_tx.child_handle.load(Ordering::Relaxed) as HANDLE;\n+    let mut exit_code = 0_u32;",
        "comment_created_at": "2024-03-06T09:32:42+00:00",
        "comment_author": "kchibisov",
        "comment_body": "Could you use the actual type of this value? `LPDWORD` or however windows-sys calls it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1515345364",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7794,
        "pr_file": "alacritty_terminal/src/tty/windows/child.rs",
        "discussion_id": "1514134846",
        "commented_code": "@@ -31,7 +32,11 @@ extern \"system\" fn child_exit_callback(ctx: *mut c_void, timed_out: BOOLEAN) {\n     }\n \n     let event_tx: Box<_> = unsafe { Box::from_raw(ctx as *mut ChildExitSender) };\n-    let _ = event_tx.sender.send(ChildEvent::Exited);\n+    let child_handle = event_tx.child_handle.load(Ordering::Relaxed) as HANDLE;\n+    let mut exit_code = 0_u32;",
        "comment_created_at": "2024-03-07T00:58:10+00:00",
        "comment_author": "SomeoneToIgnore",
        "comment_body": "There seems to be no `LPDWORD` or even `DWORD` type in the `windows_sys` crate, and looks like tjeu use `*mut u32` directly:\r\n\r\n* https://docs.rs/windows-sys/latest/windows_sys/Win32/System/Threading/fn.GetExitCodeProcess.html\r\n\r\n* https://github.com/microsoft/windows-rs/blob/1f40da8ffc44adba3f9a866287108e80223d0a81/crates/libs/sys/src/Windows/Win32/System/Threading/mod.rs#L140\r\n\r\n* https://github.com/microsoft/windows-rs/blob/1f40da8ffc44adba3f9a866287108e80223d0a81/crates/libs/windows/src/Windows/Win32/System/Threading/mod.rs#L840",
        "pr_file_module": null
      },
      {
        "comment_id": "1515781996",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 7794,
        "pr_file": "alacritty_terminal/src/tty/windows/child.rs",
        "discussion_id": "1514134846",
        "commented_code": "@@ -31,7 +32,11 @@ extern \"system\" fn child_exit_callback(ctx: *mut c_void, timed_out: BOOLEAN) {\n     }\n \n     let event_tx: Box<_> = unsafe { Box::from_raw(ctx as *mut ChildExitSender) };\n-    let _ = event_tx.sender.send(ChildEvent::Exited);\n+    let child_handle = event_tx.child_handle.load(Ordering::Relaxed) as HANDLE;\n+    let mut exit_code = 0_u32;",
        "comment_created_at": "2024-03-07T08:57:09+00:00",
        "comment_author": "kchibisov",
        "comment_body": "then it's fine.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "688848795",
    "pr_number": 5403,
    "pr_file": "alacritty/src/ipc.rs",
    "created_at": "2021-08-14T02:09:57+00:00",
    "commented_code": "+//! Alacritty socket IPC.\n+\n+use std::env;\n+use std::fs;\n+use std::io;\n+use std::os::unix::net::UnixDatagram;\n+use std::path::PathBuf;\n+use std::process;\n+use std::ffi::OsStr;\n+\n+use glutin::event_loop::EventLoopProxy;\n+\n+use alacritty_terminal::thread;\n+\n+use crate::event::{Event, EventType};\n+\n+/// IPC socket message for creating a new window.\n+pub const SOCKET_MESSAGE_CREATE_WINDOW: [u8; 1] = [1];\n+\n+/// Environment variable name for the IPC socket path.\n+const ALACRITTY_SOCKET_ENV: &str = \"ALACRITTY_SOCKET\";\n+\n+/// Create an IPC socket.\n+pub fn spawn_ipc_socket(event_proxy: EventLoopProxy<Event>) -> Option<PathBuf> {\n+    // Create the IPC socket and export its path as env variable if necessary.\n+    let socket_path = match env::var(ALACRITTY_SOCKET_ENV) {\n+        Ok(path) => PathBuf::from(path),\n+        Err(_) => {\n+            let mut path = env::temp_dir();\n+            path.push(format!(\"Alacritty-{}.sock\", process::id()));\n+            env::set_var(ALACRITTY_SOCKET_ENV, path.as_os_str());\n+            path\n+        },\n+    };\n+\n+    let socket = match UnixDatagram::bind(&socket_path) {\n+        Ok(socket) => socket,\n+        Err(_) => return None,\n+    };\n+\n+    // Spawn a thread to listen on the IPC socket.\n+    thread::spawn_named(\"socket listener\", move || {\n+        // Accept up to 2 bytes to ensure only one byte is received.\n+        // This ensures forward-compatibility.\n+        let mut buf = [0; 2];\n+\n+        loop {\n+            let received = match socket.recv(&mut buf) {\n+                Ok(received) => received,\n+                Err(_) => break,\n+            };\n+\n+            if &buf[..received] == SOCKET_MESSAGE_CREATE_WINDOW {\n+                let _ = event_proxy.send_event(Event::new(EventType::CreateWindow, None));\n+            }\n+        }\n+    });\n+\n+    Some(socket_path)\n+}\n+\n+/// Send a message to the active Alacritty socket.\n+pub fn send_message(message: &[u8]) -> io::Result<()> {",
    "repo_full_name": "alacritty/alacritty",
    "discussion_comments": [
      {
        "comment_id": "688848795",
        "repo_full_name": "alacritty/alacritty",
        "pr_number": 5403,
        "pr_file": "alacritty/src/ipc.rs",
        "discussion_id": "688848795",
        "commented_code": "@@ -0,0 +1,95 @@\n+//! Alacritty socket IPC.\n+\n+use std::env;\n+use std::fs;\n+use std::io;\n+use std::os::unix::net::UnixDatagram;\n+use std::path::PathBuf;\n+use std::process;\n+use std::ffi::OsStr;\n+\n+use glutin::event_loop::EventLoopProxy;\n+\n+use alacritty_terminal::thread;\n+\n+use crate::event::{Event, EventType};\n+\n+/// IPC socket message for creating a new window.\n+pub const SOCKET_MESSAGE_CREATE_WINDOW: [u8; 1] = [1];\n+\n+/// Environment variable name for the IPC socket path.\n+const ALACRITTY_SOCKET_ENV: &str = \"ALACRITTY_SOCKET\";\n+\n+/// Create an IPC socket.\n+pub fn spawn_ipc_socket(event_proxy: EventLoopProxy<Event>) -> Option<PathBuf> {\n+    // Create the IPC socket and export its path as env variable if necessary.\n+    let socket_path = match env::var(ALACRITTY_SOCKET_ENV) {\n+        Ok(path) => PathBuf::from(path),\n+        Err(_) => {\n+            let mut path = env::temp_dir();\n+            path.push(format!(\"Alacritty-{}.sock\", process::id()));\n+            env::set_var(ALACRITTY_SOCKET_ENV, path.as_os_str());\n+            path\n+        },\n+    };\n+\n+    let socket = match UnixDatagram::bind(&socket_path) {\n+        Ok(socket) => socket,\n+        Err(_) => return None,\n+    };\n+\n+    // Spawn a thread to listen on the IPC socket.\n+    thread::spawn_named(\"socket listener\", move || {\n+        // Accept up to 2 bytes to ensure only one byte is received.\n+        // This ensures forward-compatibility.\n+        let mut buf = [0; 2];\n+\n+        loop {\n+            let received = match socket.recv(&mut buf) {\n+                Ok(received) => received,\n+                Err(_) => break,\n+            };\n+\n+            if &buf[..received] == SOCKET_MESSAGE_CREATE_WINDOW {\n+                let _ = event_proxy.send_event(Event::new(EventType::CreateWindow, None));\n+            }\n+        }\n+    });\n+\n+    Some(socket_path)\n+}\n+\n+/// Send a message to the active Alacritty socket.\n+pub fn send_message(message: &[u8]) -> io::Result<()> {",
        "comment_created_at": "2021-08-14T02:09:57+00:00",
        "comment_author": "chrisduerr",
        "comment_body": "Taking a `&[u8]` here definitely sucks, but I think constants are the best option with events that don't have any payload. Should there be a necessity for a payload at some point, pulling in a crate like `bincode` that does the translation is likely the correct choice.",
        "pr_file_module": null
      }
    ]
  }
]