[
  {
    "discussion_id": "2198803802",
    "pr_number": 62528,
    "pr_file": "packages/compiler/src/template_parser/binding_parser.ts",
    "created_at": "2025-07-10T21:38:10+00:00",
    "commented_code": "targetEvents,\n         keySpan,\n       );\n+    } else if (name.startsWith(ANIMATE_PREFIX)) {\n+      const ast = this.parseBinding(expression, false, handlerSpan || sourceSpan, absoluteOffset);\n+\n+      if (!(ast.ast instanceof Call)) {\n+        this._reportError('The animation event handler must be a function call', sourceSpan);",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2198803802",
        "repo_full_name": "angular/angular",
        "pr_number": 62528,
        "pr_file": "packages/compiler/src/template_parser/binding_parser.ts",
        "discussion_id": "2198803802",
        "commented_code": "@@ -648,6 +679,43 @@ export class BindingParser {\n         targetEvents,\n         keySpan,\n       );\n+    } else if (name.startsWith(ANIMATE_PREFIX)) {\n+      const ast = this.parseBinding(expression, false, handlerSpan || sourceSpan, absoluteOffset);\n+\n+      if (!(ast.ast instanceof Call)) {\n+        this._reportError('The animation event handler must be a function call', sourceSpan);",
        "comment_created_at": "2025-07-10T21:38:10+00:00",
        "comment_author": "alxhub",
        "comment_body": "There shouldn't be any constraints on the handler of an animation event. It should have the same expressivity / shape as a normal event handler.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2282962102",
    "pr_number": 63148,
    "pr_file": "packages/forms/experimental/src/api/structure.ts",
    "created_at": "2025-08-18T17:01:07+00:00",
    "commented_code": "*/\n export async function submit<TValue>(\n   form: Field<TValue>,\n-  action: (form: Field<TValue>) => Promise<(ValidationError | WithField<ValidationError>)[] | void>,\n+  action: (form: Field<TValue>) => Promise<WithOptionalField<ValidationError>[] | void>,",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2282962102",
        "repo_full_name": "angular/angular",
        "pr_number": 63148,
        "pr_file": "packages/forms/experimental/src/api/structure.ts",
        "discussion_id": "2282962102",
        "commented_code": "@@ -348,7 +348,7 @@ export function applyWhenValue(\n  */\n export async function submit<TValue>(\n   form: Field<TValue>,\n-  action: (form: Field<TValue>) => Promise<(ValidationError | WithField<ValidationError>)[] | void>,\n+  action: (form: Field<TValue>) => Promise<WithOptionalField<ValidationError>[] | void>,",
        "comment_created_at": "2025-08-18T17:01:07+00:00",
        "comment_author": "mmalerba",
        "comment_body": "Should this be `OneOrMany` (I know it was already like this, but just noticing that it feels different than most of our other APIs which allow single or array). Also either way we should make the array readonly",
        "pr_file_module": null
      },
      {
        "comment_id": "2283161601",
        "repo_full_name": "angular/angular",
        "pr_number": 63148,
        "pr_file": "packages/forms/experimental/src/api/structure.ts",
        "discussion_id": "2282962102",
        "commented_code": "@@ -348,7 +348,7 @@ export function applyWhenValue(\n  */\n export async function submit<TValue>(\n   form: Field<TValue>,\n-  action: (form: Field<TValue>) => Promise<(ValidationError | WithField<ValidationError>)[] | void>,\n+  action: (form: Field<TValue>) => Promise<WithOptionalField<ValidationError>[] | void>,",
        "comment_created_at": "2025-08-18T18:39:03+00:00",
        "comment_author": "leonsenft",
        "comment_body": "I had the same thought when I was fixing the type but was just trying to keep the required changes as minimal as possible.\n\nDo you want to expand it `TreeValidationResult` (meaning that we can return `null` or  `undefined` as well?",
        "pr_file_module": null
      },
      {
        "comment_id": "2283215778",
        "repo_full_name": "angular/angular",
        "pr_number": 63148,
        "pr_file": "packages/forms/experimental/src/api/structure.ts",
        "discussion_id": "2282962102",
        "commented_code": "@@ -348,7 +348,7 @@ export function applyWhenValue(\n  */\n export async function submit<TValue>(\n   form: Field<TValue>,\n-  action: (form: Field<TValue>) => Promise<(ValidationError | WithField<ValidationError>)[] | void>,\n+  action: (form: Field<TValue>) => Promise<WithOptionalField<ValidationError>[] | void>,",
        "comment_created_at": "2025-08-18T19:08:29+00:00",
        "comment_author": "leonsenft",
        "comment_body": "I made the change (to include `TreeValidationResult`) since it was simple enough. If you think we should restrict it instead to `OneOrMany<WithOptionalField<ValidationError>>` let me know.",
        "pr_file_module": null
      },
      {
        "comment_id": "2285513504",
        "repo_full_name": "angular/angular",
        "pr_number": 63148,
        "pr_file": "packages/forms/experimental/src/api/structure.ts",
        "discussion_id": "2282962102",
        "commented_code": "@@ -348,7 +348,7 @@ export function applyWhenValue(\n  */\n export async function submit<TValue>(\n   form: Field<TValue>,\n-  action: (form: Field<TValue>) => Promise<(ValidationError | WithField<ValidationError>)[] | void>,\n+  action: (form: Field<TValue>) => Promise<WithOptionalField<ValidationError>[] | void>,",
        "comment_created_at": "2025-08-19T14:46:52+00:00",
        "comment_author": "mmalerba",
        "comment_body": "Yeah, `TreeValidationResult` makes sense here. Should we leave the `| void` on there? drop it? move it into `ValidationSuccess`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2286072024",
        "repo_full_name": "angular/angular",
        "pr_number": 63148,
        "pr_file": "packages/forms/experimental/src/api/structure.ts",
        "discussion_id": "2282962102",
        "commented_code": "@@ -348,7 +348,7 @@ export function applyWhenValue(\n  */\n export async function submit<TValue>(\n   form: Field<TValue>,\n-  action: (form: Field<TValue>) => Promise<(ValidationError | WithField<ValidationError>)[] | void>,\n+  action: (form: Field<TValue>) => Promise<WithOptionalField<ValidationError>[] | void>,",
        "comment_created_at": "2025-08-19T18:51:36+00:00",
        "comment_author": "leonsenft",
        "comment_body": "I moved it into `ValidationSuccess`. Consequently I had to include `void` in the generic return type for the array merge logic, but I think that's fine since it already guards against `undefined` values (which a `void` function implicitly returns).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2208635686",
    "pr_number": 62653,
    "pr_file": "packages/forms/experimental/src/api/metadata.ts",
    "created_at": "2025-07-15T20:46:46+00:00",
    "commented_code": "*/\n \n export class MetadataKey<TValue> {\n-  constructor(\n-    readonly defaultValue: () => TValue,\n-    readonly merge: (prev: TValue, next: TValue) => TValue,\n-  ) {}\n-}\n-\n-export const REQUIRED = new MetadataKey(\n-  () => false,\n-  (prev, next) => prev || next,\n-);\n-\n-export const MIN = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n-\n-    if (next === undefined) {\n-      return prev;\n-    }\n-    return Math.max(prev, next);\n-  },\n-);\n+  /** @internal */\n+  protected __type!: TValue;\n \n-export const MAX = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n+  static reduce<TValue>(merge: (prev: TValue, next: TValue) => TValue, defaultValue: () => TValue) {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2208635686",
        "repo_full_name": "angular/angular",
        "pr_number": 62653,
        "pr_file": "packages/forms/experimental/src/api/metadata.ts",
        "discussion_id": "2208635686",
        "commented_code": "@@ -7,76 +7,77 @@\n  */\n \n export class MetadataKey<TValue> {\n-  constructor(\n-    readonly defaultValue: () => TValue,\n-    readonly merge: (prev: TValue, next: TValue) => TValue,\n-  ) {}\n-}\n-\n-export const REQUIRED = new MetadataKey(\n-  () => false,\n-  (prev, next) => prev || next,\n-);\n-\n-export const MIN = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n-\n-    if (next === undefined) {\n-      return prev;\n-    }\n-    return Math.max(prev, next);\n-  },\n-);\n+  /** @internal */\n+  protected __type!: TValue;\n \n-export const MAX = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n+  static reduce<TValue>(merge: (prev: TValue, next: TValue) => TValue, defaultValue: () => TValue) {",
        "comment_created_at": "2025-07-15T20:46:46+00:00",
        "comment_author": "leonsenft",
        "comment_body": "This looks unused, and is essentially the same as the `ReactiveMetadataKey` constructor is it not? Is there a reason to have both?",
        "pr_file_module": null
      },
      {
        "comment_id": "2208674525",
        "repo_full_name": "angular/angular",
        "pr_number": 62653,
        "pr_file": "packages/forms/experimental/src/api/metadata.ts",
        "discussion_id": "2208635686",
        "commented_code": "@@ -7,76 +7,77 @@\n  */\n \n export class MetadataKey<TValue> {\n-  constructor(\n-    readonly defaultValue: () => TValue,\n-    readonly merge: (prev: TValue, next: TValue) => TValue,\n-  ) {}\n-}\n-\n-export const REQUIRED = new MetadataKey(\n-  () => false,\n-  (prev, next) => prev || next,\n-);\n-\n-export const MIN = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n-\n-    if (next === undefined) {\n-      return prev;\n-    }\n-    return Math.max(prev, next);\n-  },\n-);\n+  /** @internal */\n+  protected __type!: TValue;\n \n-export const MAX = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n+  static reduce<TValue>(merge: (prev: TValue, next: TValue) => TValue, defaultValue: () => TValue) {",
        "comment_created_at": "2025-07-15T21:03:27+00:00",
        "comment_author": "mmalerba",
        "comment_body": "It is the same, I just didn't want people to have to switch between `new ReactiveMetadataKey()` and `MetadataKey.someFactory`, this is so they can always use the static factory functions to create their keys. I also think naming it `reduce` gives a good hint as to what the parameters should be (default is admittedly a little different than standard `reduce` since its a function to create the default rather than a constant default value, but its the same basic idea)",
        "pr_file_module": null
      },
      {
        "comment_id": "2210822352",
        "repo_full_name": "angular/angular",
        "pr_number": 62653,
        "pr_file": "packages/forms/experimental/src/api/metadata.ts",
        "discussion_id": "2208635686",
        "commented_code": "@@ -7,76 +7,77 @@\n  */\n \n export class MetadataKey<TValue> {\n-  constructor(\n-    readonly defaultValue: () => TValue,\n-    readonly merge: (prev: TValue, next: TValue) => TValue,\n-  ) {}\n-}\n-\n-export const REQUIRED = new MetadataKey(\n-  () => false,\n-  (prev, next) => prev || next,\n-);\n-\n-export const MIN = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n-\n-    if (next === undefined) {\n-      return prev;\n-    }\n-    return Math.max(prev, next);\n-  },\n-);\n+  /** @internal */\n+  protected __type!: TValue;\n \n-export const MAX = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n+  static reduce<TValue>(merge: (prev: TValue, next: TValue) => TValue, defaultValue: () => TValue) {",
        "comment_created_at": "2025-07-16T15:48:25+00:00",
        "comment_author": "leonsenft",
        "comment_body": "Is it possible to make the constructor for `ReactiveMetadataKey` private just to enforce consistency in how users will use this API? Or is that not possible in TypeScript since users could just dynamically `new` any expression with a constructor?",
        "pr_file_module": null
      },
      {
        "comment_id": "2210828363",
        "repo_full_name": "angular/angular",
        "pr_number": 62653,
        "pr_file": "packages/forms/experimental/src/api/metadata.ts",
        "discussion_id": "2208635686",
        "commented_code": "@@ -7,76 +7,77 @@\n  */\n \n export class MetadataKey<TValue> {\n-  constructor(\n-    readonly defaultValue: () => TValue,\n-    readonly merge: (prev: TValue, next: TValue) => TValue,\n-  ) {}\n-}\n-\n-export const REQUIRED = new MetadataKey(\n-  () => false,\n-  (prev, next) => prev || next,\n-);\n-\n-export const MIN = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n-\n-    if (next === undefined) {\n-      return prev;\n-    }\n-    return Math.max(prev, next);\n-  },\n-);\n+  /** @internal */\n+  protected __type!: TValue;\n \n-export const MAX = new MetadataKey<number | undefined>(\n-  () => undefined,\n-  (prev, next) => {\n-    if (prev === undefined) {\n-      return next;\n-    }\n+  static reduce<TValue>(merge: (prev: TValue, next: TValue) => TValue, defaultValue: () => TValue) {",
        "comment_created_at": "2025-07-16T15:51:05+00:00",
        "comment_author": "mmalerba",
        "comment_body": "Yeah that's a good idea, I can make the constructor protected which will prevent people from newing it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2246698637",
    "pr_number": 62933,
    "pr_file": "packages/forms/experimental/src/controls/control.ts",
    "created_at": "2025-08-01T01:35:32+00:00",
    "commented_code": "return this.cvaArray?.[0] ?? this._ngControl?.valueAccessor ?? undefined;\n   }\n \n-  ngOnInit() {\n+  private initialize() {\n+    this.initialized = true;\n     const injector = this.injector;\n     const cmp = illegallyGetComponentInstance(injector);\n \n-    if (cmp && isUiControl<T>(cmp)) {\n+    if (cmp && isBaseUiControl(cmp)) {\n       this.setupCustomUiControl(cmp);\n     } else if (",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2246698637",
        "repo_full_name": "angular/angular",
        "pr_number": 62933,
        "pr_file": "packages/forms/experimental/src/controls/control.ts",
        "discussion_id": "2246698637",
        "commented_code": "@@ -61,11 +85,12 @@ export class Control<T> {\n     return this.cvaArray?.[0] ?? this._ngControl?.valueAccessor ?? undefined;\n   }\n \n-  ngOnInit() {\n+  private initialize() {\n+    this.initialized = true;\n     const injector = this.injector;\n     const cmp = illegallyGetComponentInstance(injector);\n \n-    if (cmp && isUiControl<T>(cmp)) {\n+    if (cmp && isBaseUiControl(cmp)) {\n       this.setupCustomUiControl(cmp);\n     } else if (",
        "comment_created_at": "2025-08-01T01:35:32+00:00",
        "comment_author": "mmalerba",
        "comment_body": "Hmm, so if its a custom UI control that also has a `control` input, we set all the value, disabled, etc. inputs. But if its native input that also has a `control` we don't set any of the attributes?\n\nThat doesn't really feel consistent, would it be better to just let the user handle everything in both cases if we see the `control` input?",
        "pr_file_module": null
      },
      {
        "comment_id": "2246701841",
        "repo_full_name": "angular/angular",
        "pr_number": 62933,
        "pr_file": "packages/forms/experimental/src/controls/control.ts",
        "discussion_id": "2246698637",
        "commented_code": "@@ -61,11 +85,12 @@ export class Control<T> {\n     return this.cvaArray?.[0] ?? this._ngControl?.valueAccessor ?? undefined;\n   }\n \n-  ngOnInit() {\n+  private initialize() {\n+    this.initialized = true;\n     const injector = this.injector;\n     const cmp = illegallyGetComponentInstance(injector);\n \n-    if (cmp && isUiControl<T>(cmp)) {\n+    if (cmp && isBaseUiControl(cmp)) {\n       this.setupCustomUiControl(cmp);\n     } else if (",
        "comment_created_at": "2025-08-01T01:39:49+00:00",
        "comment_author": "mmalerba",
        "comment_body": "I'm also wondering about the ordering of the CVA case. If its a native input with a CVA, shouldn't we respect the CVA rather than just setting the native input directly?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2292310956",
    "pr_number": 63293,
    "pr_file": "packages/forms/signals/test/node/api/validators/required.spec.ts",
    "created_at": "2025-08-21T23:10:05+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injector, signal} from '@angular/core';\n+import {TestBed} from '@angular/core/testing';\n+import {form, required} from '../../../../public_api';\n+import {ValidationError} from '../../../../src/api/validation_errors';",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2292310956",
        "repo_full_name": "angular/angular",
        "pr_number": 63293,
        "pr_file": "packages/forms/signals/test/node/api/validators/required.spec.ts",
        "discussion_id": "2292310956",
        "commented_code": "@@ -0,0 +1,115 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injector, signal} from '@angular/core';\n+import {TestBed} from '@angular/core/testing';\n+import {form, required} from '../../../../public_api';\n+import {ValidationError} from '../../../../src/api/validation_errors';",
        "comment_created_at": "2025-08-21T23:10:05+00:00",
        "comment_author": "josephperrott",
        "comment_body": "Is there reasoning behind why `form` and `required` are coming from `..../public-api`, but `ValidationError` is not?",
        "pr_file_module": null
      },
      {
        "comment_id": "2292374124",
        "repo_full_name": "angular/angular",
        "pr_number": 63293,
        "pr_file": "packages/forms/signals/test/node/api/validators/required.spec.ts",
        "discussion_id": "2292310956",
        "commented_code": "@@ -0,0 +1,115 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injector, signal} from '@angular/core';\n+import {TestBed} from '@angular/core/testing';\n+import {form, required} from '../../../../public_api';\n+import {ValidationError} from '../../../../src/api/validation_errors';",
        "comment_created_at": "2025-08-21T23:54:42+00:00",
        "comment_author": "mmalerba",
        "comment_body": "I think `ValidationError` must've accidentally been left out of public api at some point which resulted in it always being imported from elsewhere. Its in there now though, so there's no reason it can't come from public_api",
        "pr_file_module": null
      }
    ]
  }
]