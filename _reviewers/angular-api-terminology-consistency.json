[
  {
    "discussion_id": "2238061954",
    "pr_number": 62750,
    "pr_file": "adev/src/content/tutorials/signals/steps/5-managing-async-signals-with-resources-api/README.md",
    "created_at": "2025-07-29T00:15:48+00:00",
    "commented_code": "+# Managing async signals with Resources API",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2238061954",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/5-managing-async-signals-with-resources-api/README.md",
        "discussion_id": "2238061954",
        "commented_code": "@@ -0,0 +1,106 @@\n+# Managing async signals with Resources API",
        "comment_created_at": "2025-07-29T00:15:48+00:00",
        "comment_author": "jelbourn",
        "comment_body": "I think we probably wouldn't want to use the term \"async signals\", since we want to be clear that signals are _always_ synchronous. It's more that `resource` gives you a pattern for dealing with async data with signal APIs (i.e., the _data_ is async, but the _signals_ are always sync) ",
        "pr_file_module": null
      },
      {
        "comment_id": "2255221446",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/5-managing-async-signals-with-resources-api/README.md",
        "discussion_id": "2238061954",
        "commented_code": "@@ -0,0 +1,106 @@\n+# Managing async signals with Resources API",
        "comment_created_at": "2025-08-05T20:00:23+00:00",
        "comment_author": "bencodezen",
        "comment_body": "Ahhh excellent callout. I think that's what I actually originally intended and it somehow came out as \"async signals.\" \ud83d\ude05",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2139091002",
    "pr_number": 61993,
    "pr_file": "adev/src/content/guide/http/http-resource.md",
    "created_at": "2025-06-11T02:49:27+00:00",
    "commented_code": "+# Data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Fetching data is by nature an asynchronous task. You can use a [`Resource`](/api/core/resource) to perform any kind of async operation.\n+\n+<!-- mention reactive ?-->\n+\n+`httpResource` is built on top of the `resource` primitive and uses `HttpClient` as loader. It acts as a frontend for `@angular/common/http`. It makes HTTP requests through the Angular HTTP stack, including interceptors. \n+\n+## Reactive HTTP requests  \n+\n+`httpResource` makes a reactive HTTP request and exposes the request status and response value as a [`WritableResource`](/api/core/WritableResource). By default, it assumes that the backend will return JSON data. Like `resource`, it configures a reactive request. If any of the source signals in the request computation change, a new HTTP request will be made.\n+\n+You can define an http resource by returning a url: \n+\n+```ts\n+userId = input.required<string>();\n+\n+user = httpResource(() => `/api/user/${userId()}`); // A reactive function as argument\n+```\n+\n+IMPORTANT: `httpResource` differs from the `HttpClient` as it initiates the request eagerly (unlike the `HttpClient` `Observable`-based requests which must be subscribed).\n+\n+For more advanced requests, it is possible to define a request object similar to `HttpClient`\u2018s request.\n+\n+```ts\n+user = httpResource(() => ({\n+  url: `/api/user/${userId()}`,\n+  method: 'GET',\n+  headers: {\n+    'X-Special': 'true',\n+  },\n+  params: {\n+    'fast': 'yes',\n+  },\n+  reportProgress: true,\n+  withCredentials: true,\n+  transferCache: true,\n+}));\n+```\n+\n+While the resource pattern is meant only for retrieving asynchronous data, `httpResource` will allow any request method (like `POST` in the previous example). This still doesn\u2019t mean that you should be using `httpResource` to change data on the server. For instance, if you need to submit form data, use the `HttpClient` methods.\n+\n+### Response types \n+\n+An `httpResource` will return and parse the response as JSON but it is possible to use it for other return types.\n+\n+The API has multiple dedicated methods available for other response types:\n+\n+```ts\n+httpResource.text(() => ({ \u2026 })); // returns a string in value()\n+\n+httpResource.blob(() => ({ \u2026 })); // returns a Blob object in value()\n+\n+httpResource.arrayBuffer(() => ({ \u2026 })); // returns an ArrayBuffer in value()\n+```\n+\n+## Shape of an HttpResource\n+\n+An httpResource , similar to other `resource`, exposes several signals:\n+\n+- `value()` \u2014 which contains the result of the http request (when successful) and is programmatically overwritable\n+- `status()` \u2014 with the status of the resource (idle, loading, error etc)\n+- `error()` \u2014 with the request error / parsing error\n+- `isLoading()` \u2014 which is `true` while the request is pending\n+\n+It also includes dedicated signals for metadata about the response:\n+\n+- `\u200b\u200bheaders()` \u2014 with the response\u2019s headers\n+- `statusCode()` \u2014 with the response\u2019s status code\n+- `progress()` \u2014 with the progress of the request (if required in the request object)\n+\n+## Parsing typesafety \n+\n+When performing http requests you often want to ensure that the data we receive conforms the shape that we expect. This is commonly known as schema validation.\n+\n+In the JavaScript ecosystem it is common to reach out for battle-tested libraries like [Zod](https://zod.dev/) or [Valibot](https://valibot.dev/) for schema validation. `httpResource` offers direct integration for those libraries by using the `parse` parameter. The returned type of this parse function will provide the type to the resource itself, ensuring type safety alongside the schema validation.",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2139091002",
        "repo_full_name": "angular/angular",
        "pr_number": 61993,
        "pr_file": "adev/src/content/guide/http/http-resource.md",
        "discussion_id": "2139091002",
        "commented_code": "@@ -0,0 +1,126 @@\n+# Data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Fetching data is by nature an asynchronous task. You can use a [`Resource`](/api/core/resource) to perform any kind of async operation.\n+\n+<!-- mention reactive ?-->\n+\n+`httpResource` is built on top of the `resource` primitive and uses `HttpClient` as loader. It acts as a frontend for `@angular/common/http`. It makes HTTP requests through the Angular HTTP stack, including interceptors. \n+\n+## Reactive HTTP requests  \n+\n+`httpResource` makes a reactive HTTP request and exposes the request status and response value as a [`WritableResource`](/api/core/WritableResource). By default, it assumes that the backend will return JSON data. Like `resource`, it configures a reactive request. If any of the source signals in the request computation change, a new HTTP request will be made.\n+\n+You can define an http resource by returning a url: \n+\n+```ts\n+userId = input.required<string>();\n+\n+user = httpResource(() => `/api/user/${userId()}`); // A reactive function as argument\n+```\n+\n+IMPORTANT: `httpResource` differs from the `HttpClient` as it initiates the request eagerly (unlike the `HttpClient` `Observable`-based requests which must be subscribed).\n+\n+For more advanced requests, it is possible to define a request object similar to `HttpClient`\u2018s request.\n+\n+```ts\n+user = httpResource(() => ({\n+  url: `/api/user/${userId()}`,\n+  method: 'GET',\n+  headers: {\n+    'X-Special': 'true',\n+  },\n+  params: {\n+    'fast': 'yes',\n+  },\n+  reportProgress: true,\n+  withCredentials: true,\n+  transferCache: true,\n+}));\n+```\n+\n+While the resource pattern is meant only for retrieving asynchronous data, `httpResource` will allow any request method (like `POST` in the previous example). This still doesn\u2019t mean that you should be using `httpResource` to change data on the server. For instance, if you need to submit form data, use the `HttpClient` methods.\n+\n+### Response types \n+\n+An `httpResource` will return and parse the response as JSON but it is possible to use it for other return types.\n+\n+The API has multiple dedicated methods available for other response types:\n+\n+```ts\n+httpResource.text(() => ({ \u2026 })); // returns a string in value()\n+\n+httpResource.blob(() => ({ \u2026 })); // returns a Blob object in value()\n+\n+httpResource.arrayBuffer(() => ({ \u2026 })); // returns an ArrayBuffer in value()\n+```\n+\n+## Shape of an HttpResource\n+\n+An httpResource , similar to other `resource`, exposes several signals:\n+\n+- `value()` \u2014 which contains the result of the http request (when successful) and is programmatically overwritable\n+- `status()` \u2014 with the status of the resource (idle, loading, error etc)\n+- `error()` \u2014 with the request error / parsing error\n+- `isLoading()` \u2014 which is `true` while the request is pending\n+\n+It also includes dedicated signals for metadata about the response:\n+\n+- `\u200b\u200bheaders()` \u2014 with the response\u2019s headers\n+- `statusCode()` \u2014 with the response\u2019s status code\n+- `progress()` \u2014 with the progress of the request (if required in the request object)\n+\n+## Parsing typesafety \n+\n+When performing http requests you often want to ensure that the data we receive conforms the shape that we expect. This is commonly known as schema validation.\n+\n+In the JavaScript ecosystem it is common to reach out for battle-tested libraries like [Zod](https://zod.dev/) or [Valibot](https://valibot.dev/) for schema validation. `httpResource` offers direct integration for those libraries by using the `parse` parameter. The returned type of this parse function will provide the type to the resource itself, ensuring type safety alongside the schema validation.",
        "comment_created_at": "2025-06-11T02:49:27+00:00",
        "comment_author": "jelbourn",
        "comment_body": "```suggestion\r\nWhen fetching data, you may want to validate responses against a predefined schema, often using popular open-source libraries like [Zod](https://zod.dev) or [Valibot](https://valibot.dev). You can integrate validation libraries like this with `httpResource` by specifying a `parse` option. The return type of the `parse` function determines the type of the resource's `value`.\r\n```\r\nminor nits: \r\n* avoid first-person (I, we, us)\r\n* We'd generally want to avoid idioms like \"battle-tested\" \r\n(and also some edits for brevity) \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2141242946",
    "pr_number": 61993,
    "pr_file": "adev/src/content/guide/http/http-resource.md",
    "created_at": "2025-06-11T23:04:59+00:00",
    "commented_code": "+# Reactive data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+`httpResource` is a reactive wrapper around `HttpClient` that gives you the request status and response as signals. You can thus use these signals with `computed`, `effect`, `linkedSignal`, or any other reactive API. Because it's built on top of `HttpClient`, `httpResource` supports all the same features, such as interceptors.\n+\n+For more about Angular's `resource` pattern, see [Async reactivity with `resource`](/guide/signals/resource).\n+\n+## `Using httpResource`\n+\n+You can define an http resource by returning a url:",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2141242946",
        "repo_full_name": "angular/angular",
        "pr_number": 61993,
        "pr_file": "adev/src/content/guide/http/http-resource.md",
        "discussion_id": "2141242946",
        "commented_code": "@@ -0,0 +1,120 @@\n+# Reactive data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+`httpResource` is a reactive wrapper around `HttpClient` that gives you the request status and response as signals. You can thus use these signals with `computed`, `effect`, `linkedSignal`, or any other reactive API. Because it's built on top of `HttpClient`, `httpResource` supports all the same features, such as interceptors.\n+\n+For more about Angular's `resource` pattern, see [Async reactivity with `resource`](/guide/signals/resource).\n+\n+## `Using httpResource`\n+\n+You can define an http resource by returning a url: ",
        "comment_created_at": "2025-06-11T23:04:59+00:00",
        "comment_author": "jelbourn",
        "comment_body": "```suggestion\r\nYou can define an HTTP resource by returning a url: \r\n```\r\nnit: we should consistently capitalize \"HTTP\" when not part of an identifier ",
        "pr_file_module": null
      }
    ]
  }
]