[
  {
    "discussion_id": "2251855890",
    "pr_number": 62976,
    "pr_file": "packages/router/src/directives/router_link_active.ts",
    "created_at": "2025-08-04T15:35:50+00:00",
    "commented_code": "private router: Router,\n     private element: ElementRef,\n     private renderer: Renderer2,\n-    private readonly cdr: ChangeDetectorRef,\n+    private destroyRef: DestroyRef,\n     @Optional() private link?: RouterLink,\n   ) {\n-    this.routerEventsSubscription = router.events.subscribe((s: Event) => {\n+    const subscription = router.events.subscribe((s: Event) => {\n       if (s instanceof NavigationEnd) {\n         this.update();\n       }\n     });\n-  }\n+    this.destroyRef.onDestroy(() => subscription.unsubscribe());",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2251855890",
        "repo_full_name": "angular/angular",
        "pr_number": 62976,
        "pr_file": "packages/router/src/directives/router_link_active.ts",
        "discussion_id": "2251855890",
        "commented_code": "@@ -156,87 +191,53 @@ export class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit\n     private router: Router,\n     private element: ElementRef,\n     private renderer: Renderer2,\n-    private readonly cdr: ChangeDetectorRef,\n+    private destroyRef: DestroyRef,\n     @Optional() private link?: RouterLink,\n   ) {\n-    this.routerEventsSubscription = router.events.subscribe((s: Event) => {\n+    const subscription = router.events.subscribe((s: Event) => {\n       if (s instanceof NavigationEnd) {\n         this.update();\n       }\n     });\n-  }\n+    this.destroyRef.onDestroy(() => subscription.unsubscribe());",
        "comment_created_at": "2025-08-04T15:35:50+00:00",
        "comment_author": "eneajaho",
        "comment_body": "```suggestion\n@Optional() private link?: RouterLink,\n) {\n    router.events.pipe(takeUntilDestroyed()).subscribe((s: Event) => {\nif (s instanceof NavigationEnd) {\nthis.update();\n}\n});\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2251863087",
        "repo_full_name": "angular/angular",
        "pr_number": 62976,
        "pr_file": "packages/router/src/directives/router_link_active.ts",
        "discussion_id": "2251855890",
        "commented_code": "@@ -156,87 +191,53 @@ export class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit\n     private router: Router,\n     private element: ElementRef,\n     private renderer: Renderer2,\n-    private readonly cdr: ChangeDetectorRef,\n+    private destroyRef: DestroyRef,\n     @Optional() private link?: RouterLink,\n   ) {\n-    this.routerEventsSubscription = router.events.subscribe((s: Event) => {\n+    const subscription = router.events.subscribe((s: Event) => {\n       if (s instanceof NavigationEnd) {\n         this.update();\n       }\n     });\n-  }\n+    this.destroyRef.onDestroy(() => subscription.unsubscribe());",
        "comment_created_at": "2025-08-04T15:39:16+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "router wasn't pulling `rxjs-interop` ATM, went without it. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214473954",
    "pr_number": 62682,
    "pr_file": "packages/core/src/animation.ts",
    "created_at": "2025-07-17T23:14:37+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const ANIMATION_TIMEOUT = 4000;\n+\n+/**\n+ * The function type for `animate.enter` and `animate.leave` when they are used with\n+ * function callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationFunction = (event: AnimationCallbackEvent) => void;\n+\n+export type AnimationEventFunction = (\n+  el: Element,\n+  value: AnimationFunction,\n+) => AnimationRemoveFunction;\n+export type AnimationClassFunction = (\n+  el: Element,\n+  value: Set<string> | null,\n+  resolvers: Function[] | undefined,\n+) => AnimationRemoveFunction;\n+export type AnimationRemoveFunction = (removeFn: VoidFunction) => void;\n+\n+export interface LongestAnimation {\n+  animationName: string | undefined;\n+  propertyName: string | undefined;\n+  duration: number;\n+}\n+\n+export interface AnimationDetails {\n+  classes: Set<string> | null;\n+  classFns?: Function[];\n+  animateFn: AnimationRemoveFunction;\n+}\n+\n+/**\n+ * Registers elements for delayed removal action for animation in the case\n+ * that `animate.leave` is used. This stores the target element and any\n+ * classes, class resolvers, and callback functions that may be needed\n+ * to apply the removal animation, and then stashes the actual element\n+ * removal function from the dom renderer to be called after the\n+ * animation is finished.\n+ */\n+@Injectable({providedIn: 'root'})\n+export class ElementRegistry {\n+  private outElements = new Map<Element, AnimationDetails>();\n+\n+  remove(el: Element): void {\n+    this.outElements.delete(el);\n+  }\n+\n+  /** Used when animate.leave is only applying classes */\n+  addClasses(details: AnimationDetails, classes: string | string[]): void {\n+    const classList = typeof classes === 'string' ? [classes] : classes;\n+    for (let klass of classList) {\n+      details.classes?.add(klass);\n+    }\n+  }\n+\n+  /** Used when animate.leave is applying classes via a bound attribute\n+   *  which requires resolving the binding function at the right time\n+   *  to get the proper class list. There may be multiple resolvers due\n+   *  to composition via host bindings.\n+   */\n+  addResolver(details: AnimationDetails, resolver: Function): void {\n+    if (!details.classFns) {\n+      details.classFns = [resolver];\n+    } else {\n+      details.classFns?.push(resolver);\n+    }\n+  }\n+\n+  /** Used when `animate.leave` is using the function signature and will have a\n+   *  callback function, rather than a list of classes.\n+   */\n+  addCallback(\n+    el: Element,\n+    value: AnimationFunction,\n+    animateWrapperFn: AnimationEventFunction,\n+  ): void {\n+    const details = this.outElements.get(el) ?? {classes: null, animateFn: () => {}};\n+    details.animateFn = animateWrapperFn(el, value);\n+    this.outElements.set(el, details);\n+  }\n+\n+  /** Used when `animate.leave` is using classes. */\n+  add(el: Element, value: string | string[] | Function, animateWrapperFn: AnimationClassFunction) {\n+    const details = this.outElements.get(el) ?? {\n+      classes: new Set<string>(),\n+      animateFn: (): void => {},\n+    };\n+    if (typeof value === 'function') {\n+      this.addResolver(details, value);\n+    } else {\n+      this.addClasses(details, value);\n+    }\n+    details.animateFn = animateWrapperFn(el, details.classes, details.classFns);\n+    this.outElements.set(el, details);\n+  }\n+\n+  has(el: Element): boolean {\n+    return this.outElements.has(el);\n+  }\n+\n+  /** This is called by the dom renderer to actually initiate the animation\n+   *  using the animateFn stored in the registry. The DOM renderer passes in\n+   *  the removal function to be fired off when the animation finishes.\n+   */\n+  animate(el: Element, removeFn: Function): void {\n+    if (!this.outElements.has(el)) return;\n+    const details = this.outElements.get(el)!;\n+    const timeout = setTimeout(() => removeFn(), ANIMATION_TIMEOUT);\n+    details.animateFn(() => removeFn(timeout));",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2214473954",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/animation.ts",
        "discussion_id": "2214473954",
        "commented_code": "@@ -0,0 +1,137 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const ANIMATION_TIMEOUT = 4000;\n+\n+/**\n+ * The function type for `animate.enter` and `animate.leave` when they are used with\n+ * function callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationFunction = (event: AnimationCallbackEvent) => void;\n+\n+export type AnimationEventFunction = (\n+  el: Element,\n+  value: AnimationFunction,\n+) => AnimationRemoveFunction;\n+export type AnimationClassFunction = (\n+  el: Element,\n+  value: Set<string> | null,\n+  resolvers: Function[] | undefined,\n+) => AnimationRemoveFunction;\n+export type AnimationRemoveFunction = (removeFn: VoidFunction) => void;\n+\n+export interface LongestAnimation {\n+  animationName: string | undefined;\n+  propertyName: string | undefined;\n+  duration: number;\n+}\n+\n+export interface AnimationDetails {\n+  classes: Set<string> | null;\n+  classFns?: Function[];\n+  animateFn: AnimationRemoveFunction;\n+}\n+\n+/**\n+ * Registers elements for delayed removal action for animation in the case\n+ * that `animate.leave` is used. This stores the target element and any\n+ * classes, class resolvers, and callback functions that may be needed\n+ * to apply the removal animation, and then stashes the actual element\n+ * removal function from the dom renderer to be called after the\n+ * animation is finished.\n+ */\n+@Injectable({providedIn: 'root'})\n+export class ElementRegistry {\n+  private outElements = new Map<Element, AnimationDetails>();\n+\n+  remove(el: Element): void {\n+    this.outElements.delete(el);\n+  }\n+\n+  /** Used when animate.leave is only applying classes */\n+  addClasses(details: AnimationDetails, classes: string | string[]): void {\n+    const classList = typeof classes === 'string' ? [classes] : classes;\n+    for (let klass of classList) {\n+      details.classes?.add(klass);\n+    }\n+  }\n+\n+  /** Used when animate.leave is applying classes via a bound attribute\n+   *  which requires resolving the binding function at the right time\n+   *  to get the proper class list. There may be multiple resolvers due\n+   *  to composition via host bindings.\n+   */\n+  addResolver(details: AnimationDetails, resolver: Function): void {\n+    if (!details.classFns) {\n+      details.classFns = [resolver];\n+    } else {\n+      details.classFns?.push(resolver);\n+    }\n+  }\n+\n+  /** Used when `animate.leave` is using the function signature and will have a\n+   *  callback function, rather than a list of classes.\n+   */\n+  addCallback(\n+    el: Element,\n+    value: AnimationFunction,\n+    animateWrapperFn: AnimationEventFunction,\n+  ): void {\n+    const details = this.outElements.get(el) ?? {classes: null, animateFn: () => {}};\n+    details.animateFn = animateWrapperFn(el, value);\n+    this.outElements.set(el, details);\n+  }\n+\n+  /** Used when `animate.leave` is using classes. */\n+  add(el: Element, value: string | string[] | Function, animateWrapperFn: AnimationClassFunction) {\n+    const details = this.outElements.get(el) ?? {\n+      classes: new Set<string>(),\n+      animateFn: (): void => {},\n+    };\n+    if (typeof value === 'function') {\n+      this.addResolver(details, value);\n+    } else {\n+      this.addClasses(details, value);\n+    }\n+    details.animateFn = animateWrapperFn(el, details.classes, details.classFns);\n+    this.outElements.set(el, details);\n+  }\n+\n+  has(el: Element): boolean {\n+    return this.outElements.has(el);\n+  }\n+\n+  /** This is called by the dom renderer to actually initiate the animation\n+   *  using the animateFn stored in the registry. The DOM renderer passes in\n+   *  the removal function to be fired off when the animation finishes.\n+   */\n+  animate(el: Element, removeFn: Function): void {\n+    if (!this.outElements.has(el)) return;\n+    const details = this.outElements.get(el)!;\n+    const timeout = setTimeout(() => removeFn(), ANIMATION_TIMEOUT);\n+    details.animateFn(() => removeFn(timeout));",
        "comment_created_at": "2025-07-17T23:14:37+00:00",
        "comment_author": "AndrewKushnir",
        "comment_body": "Should we also call `clearTimeout` here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2215387529",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/animation.ts",
        "discussion_id": "2214473954",
        "commented_code": "@@ -0,0 +1,137 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const ANIMATION_TIMEOUT = 4000;\n+\n+/**\n+ * The function type for `animate.enter` and `animate.leave` when they are used with\n+ * function callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationFunction = (event: AnimationCallbackEvent) => void;\n+\n+export type AnimationEventFunction = (\n+  el: Element,\n+  value: AnimationFunction,\n+) => AnimationRemoveFunction;\n+export type AnimationClassFunction = (\n+  el: Element,\n+  value: Set<string> | null,\n+  resolvers: Function[] | undefined,\n+) => AnimationRemoveFunction;\n+export type AnimationRemoveFunction = (removeFn: VoidFunction) => void;\n+\n+export interface LongestAnimation {\n+  animationName: string | undefined;\n+  propertyName: string | undefined;\n+  duration: number;\n+}\n+\n+export interface AnimationDetails {\n+  classes: Set<string> | null;\n+  classFns?: Function[];\n+  animateFn: AnimationRemoveFunction;\n+}\n+\n+/**\n+ * Registers elements for delayed removal action for animation in the case\n+ * that `animate.leave` is used. This stores the target element and any\n+ * classes, class resolvers, and callback functions that may be needed\n+ * to apply the removal animation, and then stashes the actual element\n+ * removal function from the dom renderer to be called after the\n+ * animation is finished.\n+ */\n+@Injectable({providedIn: 'root'})\n+export class ElementRegistry {\n+  private outElements = new Map<Element, AnimationDetails>();\n+\n+  remove(el: Element): void {\n+    this.outElements.delete(el);\n+  }\n+\n+  /** Used when animate.leave is only applying classes */\n+  addClasses(details: AnimationDetails, classes: string | string[]): void {\n+    const classList = typeof classes === 'string' ? [classes] : classes;\n+    for (let klass of classList) {\n+      details.classes?.add(klass);\n+    }\n+  }\n+\n+  /** Used when animate.leave is applying classes via a bound attribute\n+   *  which requires resolving the binding function at the right time\n+   *  to get the proper class list. There may be multiple resolvers due\n+   *  to composition via host bindings.\n+   */\n+  addResolver(details: AnimationDetails, resolver: Function): void {\n+    if (!details.classFns) {\n+      details.classFns = [resolver];\n+    } else {\n+      details.classFns?.push(resolver);\n+    }\n+  }\n+\n+  /** Used when `animate.leave` is using the function signature and will have a\n+   *  callback function, rather than a list of classes.\n+   */\n+  addCallback(\n+    el: Element,\n+    value: AnimationFunction,\n+    animateWrapperFn: AnimationEventFunction,\n+  ): void {\n+    const details = this.outElements.get(el) ?? {classes: null, animateFn: () => {}};\n+    details.animateFn = animateWrapperFn(el, value);\n+    this.outElements.set(el, details);\n+  }\n+\n+  /** Used when `animate.leave` is using classes. */\n+  add(el: Element, value: string | string[] | Function, animateWrapperFn: AnimationClassFunction) {\n+    const details = this.outElements.get(el) ?? {\n+      classes: new Set<string>(),\n+      animateFn: (): void => {},\n+    };\n+    if (typeof value === 'function') {\n+      this.addResolver(details, value);\n+    } else {\n+      this.addClasses(details, value);\n+    }\n+    details.animateFn = animateWrapperFn(el, details.classes, details.classFns);\n+    this.outElements.set(el, details);\n+  }\n+\n+  has(el: Element): boolean {\n+    return this.outElements.has(el);\n+  }\n+\n+  /** This is called by the dom renderer to actually initiate the animation\n+   *  using the animateFn stored in the registry. The DOM renderer passes in\n+   *  the removal function to be fired off when the animation finishes.\n+   */\n+  animate(el: Element, removeFn: Function): void {\n+    if (!this.outElements.has(el)) return;\n+    const details = this.outElements.get(el)!;\n+    const timeout = setTimeout(() => removeFn(), ANIMATION_TIMEOUT);\n+    details.animateFn(() => removeFn(timeout));",
        "comment_created_at": "2025-07-18T08:27:16+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "The timeout is cleared inside the `animateFn`. We wouldn't want to clear it here as that would prevent the behavior of the max timeout we're looking for.",
        "pr_file_module": null
      },
      {
        "comment_id": "2215394835",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/animation.ts",
        "discussion_id": "2214473954",
        "commented_code": "@@ -0,0 +1,137 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const ANIMATION_TIMEOUT = 4000;\n+\n+/**\n+ * The function type for `animate.enter` and `animate.leave` when they are used with\n+ * function callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationFunction = (event: AnimationCallbackEvent) => void;\n+\n+export type AnimationEventFunction = (\n+  el: Element,\n+  value: AnimationFunction,\n+) => AnimationRemoveFunction;\n+export type AnimationClassFunction = (\n+  el: Element,\n+  value: Set<string> | null,\n+  resolvers: Function[] | undefined,\n+) => AnimationRemoveFunction;\n+export type AnimationRemoveFunction = (removeFn: VoidFunction) => void;\n+\n+export interface LongestAnimation {\n+  animationName: string | undefined;\n+  propertyName: string | undefined;\n+  duration: number;\n+}\n+\n+export interface AnimationDetails {\n+  classes: Set<string> | null;\n+  classFns?: Function[];\n+  animateFn: AnimationRemoveFunction;\n+}\n+\n+/**\n+ * Registers elements for delayed removal action for animation in the case\n+ * that `animate.leave` is used. This stores the target element and any\n+ * classes, class resolvers, and callback functions that may be needed\n+ * to apply the removal animation, and then stashes the actual element\n+ * removal function from the dom renderer to be called after the\n+ * animation is finished.\n+ */\n+@Injectable({providedIn: 'root'})\n+export class ElementRegistry {\n+  private outElements = new Map<Element, AnimationDetails>();\n+\n+  remove(el: Element): void {\n+    this.outElements.delete(el);\n+  }\n+\n+  /** Used when animate.leave is only applying classes */\n+  addClasses(details: AnimationDetails, classes: string | string[]): void {\n+    const classList = typeof classes === 'string' ? [classes] : classes;\n+    for (let klass of classList) {\n+      details.classes?.add(klass);\n+    }\n+  }\n+\n+  /** Used when animate.leave is applying classes via a bound attribute\n+   *  which requires resolving the binding function at the right time\n+   *  to get the proper class list. There may be multiple resolvers due\n+   *  to composition via host bindings.\n+   */\n+  addResolver(details: AnimationDetails, resolver: Function): void {\n+    if (!details.classFns) {\n+      details.classFns = [resolver];\n+    } else {\n+      details.classFns?.push(resolver);\n+    }\n+  }\n+\n+  /** Used when `animate.leave` is using the function signature and will have a\n+   *  callback function, rather than a list of classes.\n+   */\n+  addCallback(\n+    el: Element,\n+    value: AnimationFunction,\n+    animateWrapperFn: AnimationEventFunction,\n+  ): void {\n+    const details = this.outElements.get(el) ?? {classes: null, animateFn: () => {}};\n+    details.animateFn = animateWrapperFn(el, value);\n+    this.outElements.set(el, details);\n+  }\n+\n+  /** Used when `animate.leave` is using classes. */\n+  add(el: Element, value: string | string[] | Function, animateWrapperFn: AnimationClassFunction) {\n+    const details = this.outElements.get(el) ?? {\n+      classes: new Set<string>(),\n+      animateFn: (): void => {},\n+    };\n+    if (typeof value === 'function') {\n+      this.addResolver(details, value);\n+    } else {\n+      this.addClasses(details, value);\n+    }\n+    details.animateFn = animateWrapperFn(el, details.classes, details.classFns);\n+    this.outElements.set(el, details);\n+  }\n+\n+  has(el: Element): boolean {\n+    return this.outElements.has(el);\n+  }\n+\n+  /** This is called by the dom renderer to actually initiate the animation\n+   *  using the animateFn stored in the registry. The DOM renderer passes in\n+   *  the removal function to be fired off when the animation finishes.\n+   */\n+  animate(el: Element, removeFn: Function): void {\n+    if (!this.outElements.has(el)) return;\n+    const details = this.outElements.get(el)!;\n+    const timeout = setTimeout(() => removeFn(), ANIMATION_TIMEOUT);\n+    details.animateFn(() => removeFn(timeout));",
        "comment_created_at": "2025-07-18T08:29:51+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "I've added a comment here to clarify when this happens.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218531371",
    "pr_number": 62682,
    "pr_file": "packages/core/src/render3/instructions/animation.ts",
    "created_at": "2025-07-21T08:37:26+00:00",
    "commented_code": "* found in the LICENSE file at https://angular.dev/license\n  */\n \n-export function \u0275\u0275animateLeave(): typeof \u0275\u0275animateLeave {\n-  throw new Error('Not Implemented');\n+import {stringify} from '../../util/stringify'; // Adjust imports as per actual location\n+import {ANIMATIONS_DISABLED} from '../../application/application_tokens';\n+import {\n+  AnimationCallbackEvent,\n+  AnimationClassFunction,\n+  AnimationEventFunction,\n+  AnimationFunction,\n+  AnimationRemoveFunction,\n+  ElementRegistry,\n+  LongestAnimation,\n+} from '../../animation';\n+import {getLView, getCurrentTNode, getTView} from '../state';\n+import {RENDERER, INJECTOR, CONTEXT} from '../interfaces/view';\n+import {RuntimeError, RuntimeErrorCode} from '../../errors';\n+import {getNativeByTNode, storeCleanupWithContext} from '../util/view_utils';\n+import {performanceMarkFeature} from '../../util/performance';\n+import {Renderer} from '../interfaces/renderer';\n+import {RElement} from '../interfaces/renderer_dom';\n+\n+const DEFAULT_ANIMATIONS_DISABLED = false;\n+const WS_REGEXP = /\\s+/;\n+const areAnimationSupported =\n+  (typeof ngServerMode === 'undefined' || !ngServerMode) &&\n+  typeof document !== 'undefined' &&\n+  // tslint:disable-next-line:no-toplevel-property-access\n+  typeof document.body.getAnimations === 'function';\n+\n+/**\n+ * Instruction to handle the `animate.enter` behavior for class bindings.\n+ *\n+ * @param value The value bound to `animate.enter`, which is a string or a string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnter(value: string | Function): typeof \u0275\u0275animateEnter {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnter;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.enter');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnter;\n+  }\n+\n+  const renderer = lView[RENDERER];\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  // Retrieve the actual class list from the value. This will resolve any resolver functions from\n+  // bindings.\n+  const activeClasses = getClassListFromValue(value);\n+\n+  let longestAnimation: LongestAnimation | undefined;\n+  const cleanupFns: Function[] = [];\n+\n+  // In the case where multiple animations are happening on the element, we need\n+  // to get the longest animation to ensure we don't complete animations early.\n+  // This also allows us to setup cancellation of animations in progress if the\n+  // gets removed early.\n+  const handleAnimationStart = (event: AnimationEvent | TransitionEvent) => {\n+    setupAnimationCancel(event, activeClasses, renderer);\n+    longestAnimation = getLongestAnimation(event);\n+  };\n+\n+  // When the longest animation ends, we can remove all the classes\n+  const handleInAnimationEnd = (event: AnimationEvent | TransitionEvent) => {\n+    animationEnd(event, nativeElement, longestAnimation, activeClasses, renderer, cleanupFns);\n+  };\n+\n+  // We only need to add these event listeners if there are actual classes to apply\n+  if (activeClasses && activeClasses.length > 0) {\n+    renderer.listen(nativeElement, 'animationstart', handleAnimationStart, {once: true});\n+    renderer.listen(nativeElement, 'transitionstart', handleAnimationStart, {once: true});\n+    cleanupFns.push(renderer.listen(nativeElement, 'animationend', handleInAnimationEnd));\n+    cleanupFns.push(renderer.listen(nativeElement, 'transitionend', handleInAnimationEnd));\n+\n+    for (const klass of activeClasses) {\n+      renderer.addClass(nativeElement as HTMLElement, klass);\n+    }\n+  }\n+\n+  if (animationsDisabled) {\n+    // The animations will only be disabled in a test environment, and adding a microtask here\n+    // will allow the tests to be able to tick forward to resolve the next phase of animation\n+    // in their tests.\n+    new Promise<void>((resolve) => {\n+      if (activeClasses !== null) {\n+        for (const klass of activeClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+      for (const fn of cleanupFns) {\n+        fn();\n+      }\n+      // Classes remain, no animation, no automatic cleanup of these classes by this instruction.\n+      resolve();\n+    });\n+  }\n+\n+  return \u0275\u0275animateEnter; // For chaining\n+}\n+\n+/**\n+ * Instruction to handle the `(animate.enter)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class.\n+ *\n+ * @param value The value bound to `(animate.enter)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnterListener(value: AnimationFunction): typeof \u0275\u0275animateEnterListener {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnterListener;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.enter');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnterListener;\n+  }\n+\n+  value.call(lView[CONTEXT], {target: nativeElement, animationComplete: () => {}});\n+\n+  return \u0275\u0275animateEnterListener;\n+}\n+\n+/**\n+ * Instruction to handle the `animate.leave` behavior for class animations.\n+ * It registers an animation with the ElementRegistry to be run when the element\n+ * is scheduled for removal from the DOM.\n+ *\n+ * @param value The value bound to `animate.leave`, which can be a string or string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeave(value: string | Function): typeof \u0275\u0275animateLeave {\n+  performanceMarkFeature('NgAnimateLeave');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeave;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.leave');\n+\n+  const lView = getLView();\n+  const tView = getTView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeave;\n+  }\n+\n+  // This instruction is called in the update pass.\n+  const renderer = lView[RENDERER];\n+  const injector = lView[INJECTOR]!;\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const elementRegistry = injector.get(ElementRegistry);\n+  const animationsDisabled = injector.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  // This function gets stashed in the registry to be used once the element removal process\n+  // begins. We pass in the values and resolvers so as to evaluate the resolved classes\n+  // at the latest possible time, meaning we evaluate them right before the animation\n+  // begins.\n+  const animate: AnimationClassFunction = (\n+    el: Element,\n+    value: Set<string> | null,\n+    resolvers: Function[] | undefined,\n+  ): AnimationRemoveFunction => {\n+    return (removalFn: VoidFunction) => {\n+      animateLeaveClassRunner(\n+        el as HTMLElement,\n+        getClassList(value, resolvers),\n+        removalFn,\n+        renderer,\n+        animationsDisabled,\n+      );\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+\n+  elementRegistry.add(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeave; // For chaining\n+}\n+\n+/**\n+ * Instruction to handle the `(animate.leave)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class. It registers\n+ * an animation with the ElementRegistry to be run when the element is scheduled for\n+ * removal from the DOM.\n+ *\n+ * @param value The value bound to `(animate.leave)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeaveListener(value: AnimationFunction): typeof \u0275\u0275animateLeaveListener {\n+  performanceMarkFeature('NgAnimateLeave');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeaveListener;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.leave');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const tView = getTView();\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeaveListener;\n+  }\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const injector = lView[INJECTOR]!;\n+  const elementRegistry = injector!.get(ElementRegistry);\n+  const animationsDisabled = injector!.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  const animate: AnimationEventFunction = (\n+    el: Element,\n+    value: AnimationFunction,\n+  ): AnimationRemoveFunction => {\n+    return (removeFn: VoidFunction): void => {\n+      const event: AnimationCallbackEvent = {\n+        target: nativeElement,\n+        animationComplete: () => {\n+          removeFn();\n+        },\n+      };\n+      if (animationsDisabled) {\n+        removeFn();\n+      } else {\n+        value.call(lView[CONTEXT], event);\n+      }\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+  elementRegistry.addCallback(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeaveListener; // For chaining\n+}\n+\n+/**\n+ * Builds the list of classes to apply to an element based on either the passed in list of strings\n+ * or the set of resolver functions that are coming from bindings. Those resolver functions should\n+ * resolve into either a string or a string array. There may be multiple to support composition.\n+ */\n+function getClassList(value: Set<string> | null, resolvers: Function[] | undefined): Set<string> {\n+  const classList = new Set<string>(value);\n+  if (resolvers && resolvers.length) {\n+    for (const resolverFn of resolvers) {\n+      const resolvedValue = resolverFn();\n+      if (resolvedValue instanceof Array) {\n+        for (const rv of resolvedValue) {\n+          classList.add(rv);\n+        }\n+      } else {\n+        classList.add(resolvedValue);\n+      }\n+    }\n+  }\n+  return classList;\n+}\n+\n+function cancelAnimationsIfRunning(element: HTMLElement): void {\n+  if (areAnimationSupported) {\n+    for (const animation of element.getAnimations()) {\n+      if (animation.playState === 'running') {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2218531371",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2218531371",
        "commented_code": "@@ -6,18 +6,468 @@\n  * found in the LICENSE file at https://angular.dev/license\n  */\n \n-export function \u0275\u0275animateLeave(): typeof \u0275\u0275animateLeave {\n-  throw new Error('Not Implemented');\n+import {stringify} from '../../util/stringify'; // Adjust imports as per actual location\n+import {ANIMATIONS_DISABLED} from '../../application/application_tokens';\n+import {\n+  AnimationCallbackEvent,\n+  AnimationClassFunction,\n+  AnimationEventFunction,\n+  AnimationFunction,\n+  AnimationRemoveFunction,\n+  ElementRegistry,\n+  LongestAnimation,\n+} from '../../animation';\n+import {getLView, getCurrentTNode, getTView} from '../state';\n+import {RENDERER, INJECTOR, CONTEXT} from '../interfaces/view';\n+import {RuntimeError, RuntimeErrorCode} from '../../errors';\n+import {getNativeByTNode, storeCleanupWithContext} from '../util/view_utils';\n+import {performanceMarkFeature} from '../../util/performance';\n+import {Renderer} from '../interfaces/renderer';\n+import {RElement} from '../interfaces/renderer_dom';\n+\n+const DEFAULT_ANIMATIONS_DISABLED = false;\n+const WS_REGEXP = /\\s+/;\n+const areAnimationSupported =\n+  (typeof ngServerMode === 'undefined' || !ngServerMode) &&\n+  typeof document !== 'undefined' &&\n+  // tslint:disable-next-line:no-toplevel-property-access\n+  typeof document.body.getAnimations === 'function';\n+\n+/**\n+ * Instruction to handle the `animate.enter` behavior for class bindings.\n+ *\n+ * @param value The value bound to `animate.enter`, which is a string or a string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnter(value: string | Function): typeof \u0275\u0275animateEnter {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnter;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.enter');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnter;\n+  }\n+\n+  const renderer = lView[RENDERER];\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  // Retrieve the actual class list from the value. This will resolve any resolver functions from\n+  // bindings.\n+  const activeClasses = getClassListFromValue(value);\n+\n+  let longestAnimation: LongestAnimation | undefined;\n+  const cleanupFns: Function[] = [];\n+\n+  // In the case where multiple animations are happening on the element, we need\n+  // to get the longest animation to ensure we don't complete animations early.\n+  // This also allows us to setup cancellation of animations in progress if the\n+  // gets removed early.\n+  const handleAnimationStart = (event: AnimationEvent | TransitionEvent) => {\n+    setupAnimationCancel(event, activeClasses, renderer);\n+    longestAnimation = getLongestAnimation(event);\n+  };\n+\n+  // When the longest animation ends, we can remove all the classes\n+  const handleInAnimationEnd = (event: AnimationEvent | TransitionEvent) => {\n+    animationEnd(event, nativeElement, longestAnimation, activeClasses, renderer, cleanupFns);\n+  };\n+\n+  // We only need to add these event listeners if there are actual classes to apply\n+  if (activeClasses && activeClasses.length > 0) {\n+    renderer.listen(nativeElement, 'animationstart', handleAnimationStart, {once: true});\n+    renderer.listen(nativeElement, 'transitionstart', handleAnimationStart, {once: true});\n+    cleanupFns.push(renderer.listen(nativeElement, 'animationend', handleInAnimationEnd));\n+    cleanupFns.push(renderer.listen(nativeElement, 'transitionend', handleInAnimationEnd));\n+\n+    for (const klass of activeClasses) {\n+      renderer.addClass(nativeElement as HTMLElement, klass);\n+    }\n+  }\n+\n+  if (animationsDisabled) {\n+    // The animations will only be disabled in a test environment, and adding a microtask here\n+    // will allow the tests to be able to tick forward to resolve the next phase of animation\n+    // in their tests.\n+    new Promise<void>((resolve) => {\n+      if (activeClasses !== null) {\n+        for (const klass of activeClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+      for (const fn of cleanupFns) {\n+        fn();\n+      }\n+      // Classes remain, no animation, no automatic cleanup of these classes by this instruction.\n+      resolve();\n+    });\n+  }\n+\n+  return \u0275\u0275animateEnter; // For chaining\n+}\n+\n+/**\n+ * Instruction to handle the `(animate.enter)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class.\n+ *\n+ * @param value The value bound to `(animate.enter)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnterListener(value: AnimationFunction): typeof \u0275\u0275animateEnterListener {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnterListener;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.enter');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnterListener;\n+  }\n+\n+  value.call(lView[CONTEXT], {target: nativeElement, animationComplete: () => {}});\n+\n+  return \u0275\u0275animateEnterListener;\n+}\n+\n+/**\n+ * Instruction to handle the `animate.leave` behavior for class animations.\n+ * It registers an animation with the ElementRegistry to be run when the element\n+ * is scheduled for removal from the DOM.\n+ *\n+ * @param value The value bound to `animate.leave`, which can be a string or string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeave(value: string | Function): typeof \u0275\u0275animateLeave {\n+  performanceMarkFeature('NgAnimateLeave');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeave;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.leave');\n+\n+  const lView = getLView();\n+  const tView = getTView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeave;\n+  }\n+\n+  // This instruction is called in the update pass.\n+  const renderer = lView[RENDERER];\n+  const injector = lView[INJECTOR]!;\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const elementRegistry = injector.get(ElementRegistry);\n+  const animationsDisabled = injector.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  // This function gets stashed in the registry to be used once the element removal process\n+  // begins. We pass in the values and resolvers so as to evaluate the resolved classes\n+  // at the latest possible time, meaning we evaluate them right before the animation\n+  // begins.\n+  const animate: AnimationClassFunction = (\n+    el: Element,\n+    value: Set<string> | null,\n+    resolvers: Function[] | undefined,\n+  ): AnimationRemoveFunction => {\n+    return (removalFn: VoidFunction) => {\n+      animateLeaveClassRunner(\n+        el as HTMLElement,\n+        getClassList(value, resolvers),\n+        removalFn,\n+        renderer,\n+        animationsDisabled,\n+      );\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+\n+  elementRegistry.add(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeave; // For chaining\n+}\n+\n+/**\n+ * Instruction to handle the `(animate.leave)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class. It registers\n+ * an animation with the ElementRegistry to be run when the element is scheduled for\n+ * removal from the DOM.\n+ *\n+ * @param value The value bound to `(animate.leave)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeaveListener(value: AnimationFunction): typeof \u0275\u0275animateLeaveListener {\n+  performanceMarkFeature('NgAnimateLeave');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeaveListener;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.leave');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const tView = getTView();\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeaveListener;\n+  }\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const injector = lView[INJECTOR]!;\n+  const elementRegistry = injector!.get(ElementRegistry);\n+  const animationsDisabled = injector!.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  const animate: AnimationEventFunction = (\n+    el: Element,\n+    value: AnimationFunction,\n+  ): AnimationRemoveFunction => {\n+    return (removeFn: VoidFunction): void => {\n+      const event: AnimationCallbackEvent = {\n+        target: nativeElement,\n+        animationComplete: () => {\n+          removeFn();\n+        },\n+      };\n+      if (animationsDisabled) {\n+        removeFn();\n+      } else {\n+        value.call(lView[CONTEXT], event);\n+      }\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+  elementRegistry.addCallback(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeaveListener; // For chaining\n+}\n+\n+/**\n+ * Builds the list of classes to apply to an element based on either the passed in list of strings\n+ * or the set of resolver functions that are coming from bindings. Those resolver functions should\n+ * resolve into either a string or a string array. There may be multiple to support composition.\n+ */\n+function getClassList(value: Set<string> | null, resolvers: Function[] | undefined): Set<string> {\n+  const classList = new Set<string>(value);\n+  if (resolvers && resolvers.length) {\n+    for (const resolverFn of resolvers) {\n+      const resolvedValue = resolverFn();\n+      if (resolvedValue instanceof Array) {\n+        for (const rv of resolvedValue) {\n+          classList.add(rv);\n+        }\n+      } else {\n+        classList.add(resolvedValue);\n+      }\n+    }\n+  }\n+  return classList;\n+}\n+\n+function cancelAnimationsIfRunning(element: HTMLElement): void {\n+  if (areAnimationSupported) {\n+    for (const animation of element.getAnimations()) {\n+      if (animation.playState === 'running') {",
        "comment_created_at": "2025-07-21T08:37:26+00:00",
        "comment_author": "crisbeto",
        "comment_body": "Aren't we running the risk here that we can cancel one of the user's animations that we didn't initiate?",
        "pr_file_module": null
      },
      {
        "comment_id": "2218684600",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2218531371",
        "commented_code": "@@ -6,18 +6,468 @@\n  * found in the LICENSE file at https://angular.dev/license\n  */\n \n-export function \u0275\u0275animateLeave(): typeof \u0275\u0275animateLeave {\n-  throw new Error('Not Implemented');\n+import {stringify} from '../../util/stringify'; // Adjust imports as per actual location\n+import {ANIMATIONS_DISABLED} from '../../application/application_tokens';\n+import {\n+  AnimationCallbackEvent,\n+  AnimationClassFunction,\n+  AnimationEventFunction,\n+  AnimationFunction,\n+  AnimationRemoveFunction,\n+  ElementRegistry,\n+  LongestAnimation,\n+} from '../../animation';\n+import {getLView, getCurrentTNode, getTView} from '../state';\n+import {RENDERER, INJECTOR, CONTEXT} from '../interfaces/view';\n+import {RuntimeError, RuntimeErrorCode} from '../../errors';\n+import {getNativeByTNode, storeCleanupWithContext} from '../util/view_utils';\n+import {performanceMarkFeature} from '../../util/performance';\n+import {Renderer} from '../interfaces/renderer';\n+import {RElement} from '../interfaces/renderer_dom';\n+\n+const DEFAULT_ANIMATIONS_DISABLED = false;\n+const WS_REGEXP = /\\s+/;\n+const areAnimationSupported =\n+  (typeof ngServerMode === 'undefined' || !ngServerMode) &&\n+  typeof document !== 'undefined' &&\n+  // tslint:disable-next-line:no-toplevel-property-access\n+  typeof document.body.getAnimations === 'function';\n+\n+/**\n+ * Instruction to handle the `animate.enter` behavior for class bindings.\n+ *\n+ * @param value The value bound to `animate.enter`, which is a string or a string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnter(value: string | Function): typeof \u0275\u0275animateEnter {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnter;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.enter');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnter;\n+  }\n+\n+  const renderer = lView[RENDERER];\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  // Retrieve the actual class list from the value. This will resolve any resolver functions from\n+  // bindings.\n+  const activeClasses = getClassListFromValue(value);\n+\n+  let longestAnimation: LongestAnimation | undefined;\n+  const cleanupFns: Function[] = [];\n+\n+  // In the case where multiple animations are happening on the element, we need\n+  // to get the longest animation to ensure we don't complete animations early.\n+  // This also allows us to setup cancellation of animations in progress if the\n+  // gets removed early.\n+  const handleAnimationStart = (event: AnimationEvent | TransitionEvent) => {\n+    setupAnimationCancel(event, activeClasses, renderer);\n+    longestAnimation = getLongestAnimation(event);\n+  };\n+\n+  // When the longest animation ends, we can remove all the classes\n+  const handleInAnimationEnd = (event: AnimationEvent | TransitionEvent) => {\n+    animationEnd(event, nativeElement, longestAnimation, activeClasses, renderer, cleanupFns);\n+  };\n+\n+  // We only need to add these event listeners if there are actual classes to apply\n+  if (activeClasses && activeClasses.length > 0) {\n+    renderer.listen(nativeElement, 'animationstart', handleAnimationStart, {once: true});\n+    renderer.listen(nativeElement, 'transitionstart', handleAnimationStart, {once: true});\n+    cleanupFns.push(renderer.listen(nativeElement, 'animationend', handleInAnimationEnd));\n+    cleanupFns.push(renderer.listen(nativeElement, 'transitionend', handleInAnimationEnd));\n+\n+    for (const klass of activeClasses) {\n+      renderer.addClass(nativeElement as HTMLElement, klass);\n+    }\n+  }\n+\n+  if (animationsDisabled) {\n+    // The animations will only be disabled in a test environment, and adding a microtask here\n+    // will allow the tests to be able to tick forward to resolve the next phase of animation\n+    // in their tests.\n+    new Promise<void>((resolve) => {\n+      if (activeClasses !== null) {\n+        for (const klass of activeClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+      for (const fn of cleanupFns) {\n+        fn();\n+      }\n+      // Classes remain, no animation, no automatic cleanup of these classes by this instruction.\n+      resolve();\n+    });\n+  }\n+\n+  return \u0275\u0275animateEnter; // For chaining\n+}\n+\n+/**\n+ * Instruction to handle the `(animate.enter)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class.\n+ *\n+ * @param value The value bound to `(animate.enter)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnterListener(value: AnimationFunction): typeof \u0275\u0275animateEnterListener {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnterListener;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.enter');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnterListener;\n+  }\n+\n+  value.call(lView[CONTEXT], {target: nativeElement, animationComplete: () => {}});\n+\n+  return \u0275\u0275animateEnterListener;\n+}\n+\n+/**\n+ * Instruction to handle the `animate.leave` behavior for class animations.\n+ * It registers an animation with the ElementRegistry to be run when the element\n+ * is scheduled for removal from the DOM.\n+ *\n+ * @param value The value bound to `animate.leave`, which can be a string or string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeave(value: string | Function): typeof \u0275\u0275animateLeave {\n+  performanceMarkFeature('NgAnimateLeave');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeave;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.leave');\n+\n+  const lView = getLView();\n+  const tView = getTView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeave;\n+  }\n+\n+  // This instruction is called in the update pass.\n+  const renderer = lView[RENDERER];\n+  const injector = lView[INJECTOR]!;\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const elementRegistry = injector.get(ElementRegistry);\n+  const animationsDisabled = injector.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  // This function gets stashed in the registry to be used once the element removal process\n+  // begins. We pass in the values and resolvers so as to evaluate the resolved classes\n+  // at the latest possible time, meaning we evaluate them right before the animation\n+  // begins.\n+  const animate: AnimationClassFunction = (\n+    el: Element,\n+    value: Set<string> | null,\n+    resolvers: Function[] | undefined,\n+  ): AnimationRemoveFunction => {\n+    return (removalFn: VoidFunction) => {\n+      animateLeaveClassRunner(\n+        el as HTMLElement,\n+        getClassList(value, resolvers),\n+        removalFn,\n+        renderer,\n+        animationsDisabled,\n+      );\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+\n+  elementRegistry.add(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeave; // For chaining\n+}\n+\n+/**\n+ * Instruction to handle the `(animate.leave)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class. It registers\n+ * an animation with the ElementRegistry to be run when the element is scheduled for\n+ * removal from the DOM.\n+ *\n+ * @param value The value bound to `(animate.leave)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeaveListener(value: AnimationFunction): typeof \u0275\u0275animateLeaveListener {\n+  performanceMarkFeature('NgAnimateLeave');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeaveListener;\n+  }\n+\n+  ngDevMode && assertAnimationTypes(value, 'animate.leave');\n+\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const tView = getTView();\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeaveListener;\n+  }\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const injector = lView[INJECTOR]!;\n+  const elementRegistry = injector!.get(ElementRegistry);\n+  const animationsDisabled = injector!.get(ANIMATIONS_DISABLED, DEFAULT_ANIMATIONS_DISABLED);\n+\n+  const animate: AnimationEventFunction = (\n+    el: Element,\n+    value: AnimationFunction,\n+  ): AnimationRemoveFunction => {\n+    return (removeFn: VoidFunction): void => {\n+      const event: AnimationCallbackEvent = {\n+        target: nativeElement,\n+        animationComplete: () => {\n+          removeFn();\n+        },\n+      };\n+      if (animationsDisabled) {\n+        removeFn();\n+      } else {\n+        value.call(lView[CONTEXT], event);\n+      }\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+  elementRegistry.addCallback(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeaveListener; // For chaining\n+}\n+\n+/**\n+ * Builds the list of classes to apply to an element based on either the passed in list of strings\n+ * or the set of resolver functions that are coming from bindings. Those resolver functions should\n+ * resolve into either a string or a string array. There may be multiple to support composition.\n+ */\n+function getClassList(value: Set<string> | null, resolvers: Function[] | undefined): Set<string> {\n+  const classList = new Set<string>(value);\n+  if (resolvers && resolvers.length) {\n+    for (const resolverFn of resolvers) {\n+      const resolvedValue = resolverFn();\n+      if (resolvedValue instanceof Array) {\n+        for (const rv of resolvedValue) {\n+          classList.add(rv);\n+        }\n+      } else {\n+        classList.add(resolvedValue);\n+      }\n+    }\n+  }\n+  return classList;\n+}\n+\n+function cancelAnimationsIfRunning(element: HTMLElement): void {\n+  if (areAnimationSupported) {\n+    for (const animation of element.getAnimations()) {\n+      if (animation.playState === 'running') {",
        "comment_created_at": "2025-07-21T09:50:05+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "Yes, this is a risk, but this is only used right before applying removal animations. It's essentially to prevent any existing animations from conflicting with the animations we're about to add for animating away. So I think it should be fine in this case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2282175010",
    "pr_number": 63216,
    "pr_file": "packages/core/src/render3/instructions/animation.ts",
    "created_at": "2025-08-18T11:50:05+00:00",
    "commented_code": "const event: AnimationCallbackEvent = {\n           target: nativeElement,\n           animationComplete: () => {\n+            clearLeavingNodes(tNode);\n             removeFn();\n           },\n         };\n+        trackLeavingNodes(tNode, _el as HTMLElement);\n+\n+        ngZone.runOutsideAngular(() => {\n+          renderer.listen(_el, 'animationend', () => removeFn());",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2282175010",
        "repo_full_name": "angular/angular",
        "pr_number": 63216,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2282175010",
        "commented_code": "@@ -333,9 +362,15 @@ export function \u0275\u0275animateLeaveListener(value: AnimationFunction): typeof \u0275\u0275a\n         const event: AnimationCallbackEvent = {\n           target: nativeElement,\n           animationComplete: () => {\n+            clearLeavingNodes(tNode);\n             removeFn();\n           },\n         };\n+        trackLeavingNodes(tNode, _el as HTMLElement);\n+\n+        ngZone.runOutsideAngular(() => {\n+          renderer.listen(_el, 'animationend', () => removeFn());",
        "comment_created_at": "2025-08-18T11:50:05+00:00",
        "comment_author": "crisbeto",
        "comment_body": "Do we need to clean this listener up?",
        "pr_file_module": null
      },
      {
        "comment_id": "2282178757",
        "repo_full_name": "angular/angular",
        "pr_number": 63216,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2282175010",
        "commented_code": "@@ -333,9 +362,15 @@ export function \u0275\u0275animateLeaveListener(value: AnimationFunction): typeof \u0275\u0275a\n         const event: AnimationCallbackEvent = {\n           target: nativeElement,\n           animationComplete: () => {\n+            clearLeavingNodes(tNode);\n             removeFn();\n           },\n         };\n+        trackLeavingNodes(tNode, _el as HTMLElement);\n+\n+        ngZone.runOutsideAngular(() => {\n+          renderer.listen(_el, 'animationend', () => removeFn());",
        "comment_created_at": "2025-08-18T11:51:45+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "Na, this is on the leave. So when this element is removed, this will disappear with it.",
        "pr_file_module": null
      }
    ]
  }
]