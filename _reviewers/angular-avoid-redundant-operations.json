[
  {
    "discussion_id": "2214508175",
    "pr_number": 62682,
    "pr_file": "packages/core/src/render3/instructions/animation.ts",
    "created_at": "2025-07-17T23:47:08+00:00",
    "commented_code": "* found in the LICENSE file at https://angular.dev/license\n  */\n \n-export function \u0275\u0275animateLeave(): typeof \u0275\u0275animateLeave {\n-  throw new Error('Not Implemented');\n+import {stringify} from '../../util/stringify'; // Adjust imports as per actual location\n+import {ANIMATIONS_DISABLED} from '../../application/application_tokens';\n+import {\n+  AnimationCallbackEvent,\n+  AnimationClassFunction,\n+  AnimationEventFunction,\n+  AnimationFunction,\n+  AnimationRemoveFunction,\n+  ElementRegistry,\n+  LongestAnimation,\n+} from '../../animation';\n+import {getLView, getCurrentTNode, getTView} from '../state';\n+import {RENDERER, INJECTOR, CONTEXT} from '../interfaces/view';\n+import {RuntimeError} from '../../errors';\n+import {getNativeByTNode, storeCleanupWithContext} from '../util/view_utils';\n+import {performanceMarkFeature} from '../../util/performance';\n+\n+const WS_REGEXP = /\\s+/;\n+\n+/**\n+ * Instruction to handle the `animate.enter` behavior for class bindings.\n+ *\n+ * @param value The value bound to `animate.enter`, which is a string or a string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnter(value: string | Function): typeof \u0275\u0275animateEnter {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnter; // SSR, do nothing and allow chaining\n+  }\n+  const lView = getLView();\n+\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnter; // SSR, do nothing and allow chaining\n+  }\n+\n+  const renderer = lView[RENDERER];\n+\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, false);\n+  const classes = typeof value === 'function' ? value() : value;\n+  let activeEnterClasses: string[] | null = classes instanceof Array ? classes : null;\n+  if (typeof classes === 'string') {\n+    activeEnterClasses = classes\n+      .trim()\n+      .split(WS_REGEXP)\n+      .filter((k) => k);\n+  }\n+  let longestAnimation: LongestAnimation | undefined;\n+\n+  const cleanup = () => {\n+    nativeElement.removeEventListener('animationstart', determineLongestAnimation);\n+    nativeElement.removeEventListener('transitionstart', determineLongestAnimation);\n+    nativeElement.removeEventListener('animationend', handleInAnimationEnd);\n+    nativeElement.removeEventListener('transitionend', handleInAnimationEnd);\n+  };\n+\n+  const determineLongestAnimation = (event: AnimationEvent | TransitionEvent) => {\n+    setupAnimationCancel(event);\n+    longestAnimation = getLongestAnimation(event);\n+  };\n+\n+  const setupAnimationCancel = (event: Event) => {\n+    if (!(event.target instanceof Element)) return;\n+    const nativeElement = event.target;\n+    if (typeof nativeElement.getAnimations === 'function') {\n+      const animations = nativeElement.getAnimations();\n+      if (animations.length === 0) return;\n+      for (let animation of animations) {\n+        animation.addEventListener('cancel', cancel);\n+      }\n+    }\n+  };\n+\n+  const cancel = (event: Event) => {\n+    if (nativeElement === event.target) {\n+      cleanup();\n+      if (activeEnterClasses !== null) {\n+        for (const klass of activeEnterClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+    }\n+  };\n+\n+  const handleInAnimationEnd = (event: Event) => {\n+    if (\n+      (nativeElement === event.target &&\n+        longestAnimation?.animationName &&\n+        (event as AnimationEvent).animationName === longestAnimation.animationName) ||\n+      (event as TransitionEvent).propertyName === longestAnimation?.propertyName\n+    ) {\n+      event.stopImmediatePropagation();\n+      if (activeEnterClasses !== null) {\n+        for (const klass of activeEnterClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+      cleanup();\n+    }\n+  };\n+\n+  if (activeEnterClasses) {\n+    if (activeEnterClasses.length === 0) {\n+      return \u0275\u0275animateEnter; // No classes to apply\n+    }\n+\n+    nativeElement.addEventListener('animationstart', determineLongestAnimation);\n+    nativeElement.addEventListener('transitionstart', determineLongestAnimation);\n+    nativeElement.addEventListener('animationend', handleInAnimationEnd);\n+    nativeElement.addEventListener('transitionend', handleInAnimationEnd);\n+\n+    for (const klass of activeEnterClasses) {\n+      renderer.addClass(nativeElement as HTMLElement, klass);\n+    }\n+  } else {\n+    if (ngDevMode) {\n+      throw new RuntimeError(\n+        901, // Placeholder error code for animateEnter\n+        `[animate.enter] value must be a string of CSS classes or an animation function, got ${stringify(value)}`,\n+      );\n+    }\n+  }\n+\n+  if (animationsDisabled) {\n+    // add microtask\n+    new Promise<void>((resolve) => {\n+      if (activeEnterClasses !== null) {\n+        for (const klass of activeEnterClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+      // Classes remain, no animation, no automatic cleanup of these classes by this instruction.\n+      resolve();\n+    });\n+  }\n+\n+  return \u0275\u0275animateEnter; // For chaining\n }\n \n-export function \u0275\u0275animateLeaveListener(): typeof \u0275\u0275animateLeaveListener {\n-  throw new Error('Not Implemented');\n+/**\n+ * Instruction to handle the `(animate.enter)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class.\n+ *\n+ * @param value The value bound to `(animate.enter)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnterListener(value: AnimationFunction): typeof \u0275\u0275animateEnterListener {\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnterListener; // SSR, do nothing and allow chaining\n+  }\n+\n+  value.call(lView[CONTEXT], {target: nativeElement, animationComplete: () => {}});\n+  return \u0275\u0275animateEnterListener;\n }\n \n-export function \u0275\u0275animateEnter(): typeof \u0275\u0275animateEnter {\n-  throw new Error('Not Implemented');\n+/**\n+ * Instruction to handle the `animate.leave` behavior for class animations.\n+ * It registers an animation with the ElementRegistry to be run when the element\n+ * is scheduled for removal from the DOM.\n+ *\n+ * @param value The value bound to `animate.leave`, which can be a string or string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeave(value: string | Function): typeof \u0275\u0275animateLeave {\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeave; // SSR, do nothing and allow chaining\n+  }\n+\n+  const lView = getLView();\n+  const tView = getTView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeave; // SSR, do nothing and allow chaining\n+  }\n+\n+  // This instruction is called in the update pass.\n+  const renderer = lView[RENDERER];\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const elementRegistry = lView[INJECTOR]!.get(ElementRegistry);\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, false);\n+  let longestAnimation: LongestAnimation | undefined;\n+\n+  let removeFn: VoidFunction = () => {};\n+\n+  const animate: AnimationClassFunction = (\n+    el: Element,\n+    value: Set<string> | null,\n+    resolvers: Function[] | undefined,\n+  ): AnimationRemoveFunction => {\n+    return (removeFn: VoidFunction) => {\n+      animateClassRunner(el as HTMLElement, getClassList(value, resolvers), removeFn);\n+    };\n+  };\n+\n+  const determineLongestAnimation = (event: AnimationEvent | TransitionEvent) => {\n+    longestAnimation = getLongestAnimation(event);\n+  };\n+\n+  const handleOutAnimationEnd = (event: AnimationEvent | TransitionEvent) => {\n+    if (\n+      (nativeElement === event.target &&\n+        longestAnimation?.animationName &&\n+        (event as AnimationEvent).animationName === longestAnimation.animationName) ||\n+      (event as TransitionEvent).propertyName === longestAnimation?.propertyName\n+    ) {\n+      event.stopImmediatePropagation();\n+      removeFn();\n+    }\n+  };\n+\n+  const animateClassRunner = (\n+    el: HTMLElement,\n+    classList: Set<string>,\n+    finalRemoveFn: VoidFunction,\n+  ) => {\n+    if (isAnimationRunning(el)) {\n+      cancelAnimations(el);\n+    }\n+\n+    removeFn = finalRemoveFn;\n+    el.addEventListener('animationstart', determineLongestAnimation);\n+    el.addEventListener('transitionstart', determineLongestAnimation);\n+    el.addEventListener('animationend', handleOutAnimationEnd);\n+    el.addEventListener('transitionend', handleOutAnimationEnd);\n+    for (const item of classList) {\n+      renderer.addClass(el, item);\n+    }\n+    if (animationsDisabled) {\n+      finalRemoveFn();\n+    }\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+  elementRegistry.add(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeave; // For chaining\n }\n \n-export function \u0275\u0275animateEnterListener(): typeof \u0275\u0275animateEnterListener {\n-  throw new Error('Not Implemented');\n+/**\n+ * Instruction to handle the `(animate.leave)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class. It registers\n+ * an animation with the ElementRegistry to be run when the element is scheduled for\n+ * removal from the DOM.\n+ *\n+ * @param value The value bound to `(animate.leave)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeaveListener(value: AnimationFunction): typeof \u0275\u0275animateLeaveListener {\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeaveListener; // SSR, do nothing and allow chaining\n+  }\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const tView = getTView();\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeaveListener; // SSR, do nothing and allow chaining\n+  }\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const elementRegistry = lView[INJECTOR]!.get(ElementRegistry);\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, false);\n+\n+  const animate: AnimationEventFunction = (\n+    el: Element,\n+    value: AnimationFunction,\n+  ): AnimationRemoveFunction => {\n+    return (removeFn: VoidFunction): void => {\n+      const event: AnimationCallbackEvent = {\n+        target: nativeElement,\n+        animationComplete: () => {\n+          removeFn();\n+        },\n+      };\n+      if (animationsDisabled) {\n+        removeFn();\n+      } else {\n+        value.call(lView[CONTEXT], event);\n+      }\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+  elementRegistry.addCallback(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeaveListener; // For chaining\n+}\n+\n+/**\n+ * Builds the list of classes to apply to an element based on either the passed in list of strings\n+ * or the set of resolver functions that are coming from bindings. Those resolver functions should\n+ * resolve into either a string or a string array. There may be multiple to support composition.\n+ */\n+function getClassList(value: Set<string> | null, resolvers: Function[] | undefined): Set<string> {\n+  const classList = new Set<string>();\n+  if (resolvers && resolvers.length) {\n+    for (const resolverFn of resolvers) {\n+      const resolvedValue = resolverFn();\n+      if (resolvedValue instanceof Array) {\n+        for (const rv of resolvedValue) {\n+          classList.add(rv);\n+        }\n+      } else {\n+        classList.add(resolvedValue);\n+      }\n+    }\n+  }\n+  if (value instanceof Set) {\n+    for (const val of value) {\n+      classList.add(val);\n+    }\n+  }\n+  return classList;\n+}\n+\n+function isAnimationRunning(element: HTMLElement): boolean {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2214508175",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2214508175",
        "commented_code": "@@ -6,18 +6,409 @@\n  * found in the LICENSE file at https://angular.dev/license\n  */\n \n-export function \u0275\u0275animateLeave(): typeof \u0275\u0275animateLeave {\n-  throw new Error('Not Implemented');\n+import {stringify} from '../../util/stringify'; // Adjust imports as per actual location\n+import {ANIMATIONS_DISABLED} from '../../application/application_tokens';\n+import {\n+  AnimationCallbackEvent,\n+  AnimationClassFunction,\n+  AnimationEventFunction,\n+  AnimationFunction,\n+  AnimationRemoveFunction,\n+  ElementRegistry,\n+  LongestAnimation,\n+} from '../../animation';\n+import {getLView, getCurrentTNode, getTView} from '../state';\n+import {RENDERER, INJECTOR, CONTEXT} from '../interfaces/view';\n+import {RuntimeError} from '../../errors';\n+import {getNativeByTNode, storeCleanupWithContext} from '../util/view_utils';\n+import {performanceMarkFeature} from '../../util/performance';\n+\n+const WS_REGEXP = /\\s+/;\n+\n+/**\n+ * Instruction to handle the `animate.enter` behavior for class bindings.\n+ *\n+ * @param value The value bound to `animate.enter`, which is a string or a string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnter(value: string | Function): typeof \u0275\u0275animateEnter {\n+  performanceMarkFeature('NgAnimateEnter');\n+\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateEnter; // SSR, do nothing and allow chaining\n+  }\n+  const lView = getLView();\n+\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnter; // SSR, do nothing and allow chaining\n+  }\n+\n+  const renderer = lView[RENDERER];\n+\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, false);\n+  const classes = typeof value === 'function' ? value() : value;\n+  let activeEnterClasses: string[] | null = classes instanceof Array ? classes : null;\n+  if (typeof classes === 'string') {\n+    activeEnterClasses = classes\n+      .trim()\n+      .split(WS_REGEXP)\n+      .filter((k) => k);\n+  }\n+  let longestAnimation: LongestAnimation | undefined;\n+\n+  const cleanup = () => {\n+    nativeElement.removeEventListener('animationstart', determineLongestAnimation);\n+    nativeElement.removeEventListener('transitionstart', determineLongestAnimation);\n+    nativeElement.removeEventListener('animationend', handleInAnimationEnd);\n+    nativeElement.removeEventListener('transitionend', handleInAnimationEnd);\n+  };\n+\n+  const determineLongestAnimation = (event: AnimationEvent | TransitionEvent) => {\n+    setupAnimationCancel(event);\n+    longestAnimation = getLongestAnimation(event);\n+  };\n+\n+  const setupAnimationCancel = (event: Event) => {\n+    if (!(event.target instanceof Element)) return;\n+    const nativeElement = event.target;\n+    if (typeof nativeElement.getAnimations === 'function') {\n+      const animations = nativeElement.getAnimations();\n+      if (animations.length === 0) return;\n+      for (let animation of animations) {\n+        animation.addEventListener('cancel', cancel);\n+      }\n+    }\n+  };\n+\n+  const cancel = (event: Event) => {\n+    if (nativeElement === event.target) {\n+      cleanup();\n+      if (activeEnterClasses !== null) {\n+        for (const klass of activeEnterClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+    }\n+  };\n+\n+  const handleInAnimationEnd = (event: Event) => {\n+    if (\n+      (nativeElement === event.target &&\n+        longestAnimation?.animationName &&\n+        (event as AnimationEvent).animationName === longestAnimation.animationName) ||\n+      (event as TransitionEvent).propertyName === longestAnimation?.propertyName\n+    ) {\n+      event.stopImmediatePropagation();\n+      if (activeEnterClasses !== null) {\n+        for (const klass of activeEnterClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+      cleanup();\n+    }\n+  };\n+\n+  if (activeEnterClasses) {\n+    if (activeEnterClasses.length === 0) {\n+      return \u0275\u0275animateEnter; // No classes to apply\n+    }\n+\n+    nativeElement.addEventListener('animationstart', determineLongestAnimation);\n+    nativeElement.addEventListener('transitionstart', determineLongestAnimation);\n+    nativeElement.addEventListener('animationend', handleInAnimationEnd);\n+    nativeElement.addEventListener('transitionend', handleInAnimationEnd);\n+\n+    for (const klass of activeEnterClasses) {\n+      renderer.addClass(nativeElement as HTMLElement, klass);\n+    }\n+  } else {\n+    if (ngDevMode) {\n+      throw new RuntimeError(\n+        901, // Placeholder error code for animateEnter\n+        `[animate.enter] value must be a string of CSS classes or an animation function, got ${stringify(value)}`,\n+      );\n+    }\n+  }\n+\n+  if (animationsDisabled) {\n+    // add microtask\n+    new Promise<void>((resolve) => {\n+      if (activeEnterClasses !== null) {\n+        for (const klass of activeEnterClasses) {\n+          renderer.removeClass(nativeElement, klass);\n+        }\n+      }\n+      // Classes remain, no animation, no automatic cleanup of these classes by this instruction.\n+      resolve();\n+    });\n+  }\n+\n+  return \u0275\u0275animateEnter; // For chaining\n }\n \n-export function \u0275\u0275animateLeaveListener(): typeof \u0275\u0275animateLeaveListener {\n-  throw new Error('Not Implemented');\n+/**\n+ * Instruction to handle the `(animate.enter)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class.\n+ *\n+ * @param value The value bound to `(animate.enter)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateEnterListener(value: AnimationFunction): typeof \u0275\u0275animateEnterListener {\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as HTMLElement;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateEnterListener; // SSR, do nothing and allow chaining\n+  }\n+\n+  value.call(lView[CONTEXT], {target: nativeElement, animationComplete: () => {}});\n+  return \u0275\u0275animateEnterListener;\n }\n \n-export function \u0275\u0275animateEnter(): typeof \u0275\u0275animateEnter {\n-  throw new Error('Not Implemented');\n+/**\n+ * Instruction to handle the `animate.leave` behavior for class animations.\n+ * It registers an animation with the ElementRegistry to be run when the element\n+ * is scheduled for removal from the DOM.\n+ *\n+ * @param value The value bound to `animate.leave`, which can be a string or string array.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeave(value: string | Function): typeof \u0275\u0275animateLeave {\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeave; // SSR, do nothing and allow chaining\n+  }\n+\n+  const lView = getLView();\n+  const tView = getTView();\n+  const tNode = getCurrentTNode()!;\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeave; // SSR, do nothing and allow chaining\n+  }\n+\n+  // This instruction is called in the update pass.\n+  const renderer = lView[RENDERER];\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const elementRegistry = lView[INJECTOR]!.get(ElementRegistry);\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, false);\n+  let longestAnimation: LongestAnimation | undefined;\n+\n+  let removeFn: VoidFunction = () => {};\n+\n+  const animate: AnimationClassFunction = (\n+    el: Element,\n+    value: Set<string> | null,\n+    resolvers: Function[] | undefined,\n+  ): AnimationRemoveFunction => {\n+    return (removeFn: VoidFunction) => {\n+      animateClassRunner(el as HTMLElement, getClassList(value, resolvers), removeFn);\n+    };\n+  };\n+\n+  const determineLongestAnimation = (event: AnimationEvent | TransitionEvent) => {\n+    longestAnimation = getLongestAnimation(event);\n+  };\n+\n+  const handleOutAnimationEnd = (event: AnimationEvent | TransitionEvent) => {\n+    if (\n+      (nativeElement === event.target &&\n+        longestAnimation?.animationName &&\n+        (event as AnimationEvent).animationName === longestAnimation.animationName) ||\n+      (event as TransitionEvent).propertyName === longestAnimation?.propertyName\n+    ) {\n+      event.stopImmediatePropagation();\n+      removeFn();\n+    }\n+  };\n+\n+  const animateClassRunner = (\n+    el: HTMLElement,\n+    classList: Set<string>,\n+    finalRemoveFn: VoidFunction,\n+  ) => {\n+    if (isAnimationRunning(el)) {\n+      cancelAnimations(el);\n+    }\n+\n+    removeFn = finalRemoveFn;\n+    el.addEventListener('animationstart', determineLongestAnimation);\n+    el.addEventListener('transitionstart', determineLongestAnimation);\n+    el.addEventListener('animationend', handleOutAnimationEnd);\n+    el.addEventListener('transitionend', handleOutAnimationEnd);\n+    for (const item of classList) {\n+      renderer.addClass(el, item);\n+    }\n+    if (animationsDisabled) {\n+      finalRemoveFn();\n+    }\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+  elementRegistry.add(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeave; // For chaining\n }\n \n-export function \u0275\u0275animateEnterListener(): typeof \u0275\u0275animateEnterListener {\n-  throw new Error('Not Implemented');\n+/**\n+ * Instruction to handle the `(animate.leave)` behavior for event bindings, aka when\n+ * a user wants to use a custom animation function rather than a class. It registers\n+ * an animation with the ElementRegistry to be run when the element is scheduled for\n+ * removal from the DOM.\n+ *\n+ * @param value The value bound to `(animate.leave)`, an AnimationFunction.\n+ * @returns This function returns itself so that it may be chained.\n+ *\n+ * @codeGenApi\n+ */\n+export function \u0275\u0275animateLeaveListener(value: AnimationFunction): typeof \u0275\u0275animateLeaveListener {\n+  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n+    return \u0275\u0275animateLeaveListener; // SSR, do nothing and allow chaining\n+  }\n+  const lView = getLView();\n+  const tNode = getCurrentTNode()!;\n+  const tView = getTView();\n+  const nativeElement = getNativeByTNode(tNode, lView) as Element;\n+\n+  if ((nativeElement as Node).nodeType !== Node.ELEMENT_NODE) {\n+    return \u0275\u0275animateLeaveListener; // SSR, do nothing and allow chaining\n+  }\n+\n+  // Assume ElementRegistry and ANIMATIONS_DISABLED are injectable services.\n+  const elementRegistry = lView[INJECTOR]!.get(ElementRegistry);\n+  const animationsDisabled = lView[INJECTOR]!.get(ANIMATIONS_DISABLED, false);\n+\n+  const animate: AnimationEventFunction = (\n+    el: Element,\n+    value: AnimationFunction,\n+  ): AnimationRemoveFunction => {\n+    return (removeFn: VoidFunction): void => {\n+      const event: AnimationCallbackEvent = {\n+        target: nativeElement,\n+        animationComplete: () => {\n+          removeFn();\n+        },\n+      };\n+      if (animationsDisabled) {\n+        removeFn();\n+      } else {\n+        value.call(lView[CONTEXT], event);\n+      }\n+    };\n+  };\n+\n+  // Ensure cleanup if the LView is destroyed before the animation runs.\n+  if (tView.firstCreatePass) {\n+    storeCleanupWithContext(tView, lView, nativeElement, (elToClean: Element) => {\n+      elementRegistry.remove(elToClean);\n+    });\n+  }\n+  elementRegistry.addCallback(nativeElement, value, animate);\n+\n+  return \u0275\u0275animateLeaveListener; // For chaining\n+}\n+\n+/**\n+ * Builds the list of classes to apply to an element based on either the passed in list of strings\n+ * or the set of resolver functions that are coming from bindings. Those resolver functions should\n+ * resolve into either a string or a string array. There may be multiple to support composition.\n+ */\n+function getClassList(value: Set<string> | null, resolvers: Function[] | undefined): Set<string> {\n+  const classList = new Set<string>();\n+  if (resolvers && resolvers.length) {\n+    for (const resolverFn of resolvers) {\n+      const resolvedValue = resolverFn();\n+      if (resolvedValue instanceof Array) {\n+        for (const rv of resolvedValue) {\n+          classList.add(rv);\n+        }\n+      } else {\n+        classList.add(resolvedValue);\n+      }\n+    }\n+  }\n+  if (value instanceof Set) {\n+    for (const val of value) {\n+      classList.add(val);\n+    }\n+  }\n+  return classList;\n+}\n+\n+function isAnimationRunning(element: HTMLElement): boolean {",
        "comment_created_at": "2025-07-17T23:47:08+00:00",
        "comment_author": "AndrewKushnir",
        "comment_body": "I think the `isAnimationRunning` and `cancelAnimations` functions can be combined for code size and also to avoid 2 lookups to find animations that are in the \"running\" state.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2194685293",
    "pr_number": 62465,
    "pr_file": "devtools/projects/ng-devtools/src/lib/devtools-tabs/transfer-state/transfer-state.component.ts",
    "created_at": "2025-07-09T10:41:27+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Component, inject, signal, computed, ChangeDetectionStrategy} from '@angular/core';\n+import {Clipboard} from '@angular/cdk/clipboard';\n+import {MatIcon} from '@angular/material/icon';\n+import {MatTooltip} from '@angular/material/tooltip';\n+import {\n+  MatTable,\n+  MatHeaderCell,\n+  MatCell,\n+  MatHeaderRow,\n+  MatRow,\n+  MatColumnDef,\n+  MatHeaderCellDef,\n+  MatCellDef,\n+  MatHeaderRowDef,\n+  MatRowDef,\n+} from '@angular/material/table';\n+import {CommonModule} from '@angular/common';\n+import {ButtonComponent} from '../../shared/button/button.component';\n+import {Events, MessageBus, TransferStateValue} from '../../../../../protocol';\n+\n+interface TransferStateItem {\n+  key: string;\n+  value: TransferStateValue;\n+  type: string;\n+  size: string;\n+  isExpanded?: boolean;\n+  isCopied?: boolean;\n+}\n+\n+@Component({\n+  selector: 'ng-transfer-state',\n+  standalone: true,\n+  imports: [\n+    CommonModule,\n+    MatIcon,\n+    MatTooltip,\n+    MatTable,\n+    MatHeaderCell,\n+    MatCell,\n+    MatHeaderRow,\n+    MatRow,\n+    MatColumnDef,\n+    MatHeaderCellDef,\n+    MatCellDef,\n+    MatHeaderRowDef,\n+    MatRowDef,\n+    ButtonComponent,\n+  ],\n+  templateUrl: './transfer-state.component.html',\n+  styleUrls: ['./transfer-state.component.scss'],\n+  changeDetection: ChangeDetectionStrategy.OnPush,\n+})\n+export class TransferStateComponent {\n+  private _messageBus = inject(MessageBus) as MessageBus<Events>;\n+  private _clipboard = inject(Clipboard);\n+  readonly MAX_DISPLAY_LENGTH = 200;\n+\n+  readonly transferStateData = signal<Record<string, TransferStateValue> | null>(null);\n+  readonly error = signal<string | null>(null);\n+  readonly isLoading = signal(false);\n+\n+  readonly transferStateItems = computed<TransferStateItem[]>(() => {\n+    const data = this.transferStateData();\n+    if (!data) return [];\n+\n+    return Object.entries(data).map(([key, value]) => ({\n+      key,\n+      value,\n+      type: this.getValueType(value),\n+      size: this.getValueSize(value),\n+      isExpanded: false,\n+      isCopied: false,\n+    }));\n+  });\n+\n+  readonly hasData = computed(() => this.transferStateItems().length > 0);\n+\n+  readonly totalSize = computed(() => {\n+    const items = this.transferStateItems();\n+    if (items.length === 0) return '0 B';\n+\n+    let totalBytes = 0;\n+    for (const item of items) {\n+      const str = typeof item.value === 'string' ? item.value : JSON.stringify(item.value);\n+      totalBytes += new Blob([str]).size;\n+    }\n+\n+    if (totalBytes < 1024) return `${totalBytes} B`;\n+    if (totalBytes < 1024 * 1024) return `${(totalBytes / 1024).toFixed(1)} KB`;\n+    return `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;\n+  });\n+\n+  displayedColumns: string[] = ['key', 'type', 'size', 'value'];\n+\n+  constructor() {\n+    this.loadTransferState();\n+  }\n+\n+  private getValueType(value: TransferStateValue): string {\n+    if (value === null) return 'null';\n+    if (Array.isArray(value)) return 'array';\n+    return typeof value;\n+  }\n+\n+  getValueSize(value: TransferStateValue): string {\n+    try {\n+      const str = JSON.stringify(value);\n+      const bytes = new Blob([str]).size;\n+      if (bytes < 1024) return `${bytes} B`;\n+      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n+      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n+    } catch {\n+      return 'unknown';\n+    }\n+  }\n+\n+  private formatValue(value: TransferStateValue, isExpanded = false): string {\n+    const formatters = {\n+      null: () => 'null',\n+      undefined: () => 'undefined',\n+      string: (val: string) => `\"${val}\"`,\n+      object: (val: object) => JSON.stringify(val, null, 2),\n+      default: (val: unknown) => String(val),\n+    };\n+\n+    const getFormattedValue = (val: TransferStateValue): string => {\n+      if (val === null) return formatters.null();\n+      if (val === undefined) return formatters.undefined();\n+      if (typeof val === 'string') return formatters.string(val);\n+      if (typeof val === 'object') return formatters.object(val);\n+      return formatters.default(val);\n+    };",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2194685293",
        "repo_full_name": "angular/angular",
        "pr_number": 62465,
        "pr_file": "devtools/projects/ng-devtools/src/lib/devtools-tabs/transfer-state/transfer-state.component.ts",
        "discussion_id": "2194685293",
        "commented_code": "@@ -0,0 +1,211 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Component, inject, signal, computed, ChangeDetectionStrategy} from '@angular/core';\n+import {Clipboard} from '@angular/cdk/clipboard';\n+import {MatIcon} from '@angular/material/icon';\n+import {MatTooltip} from '@angular/material/tooltip';\n+import {\n+  MatTable,\n+  MatHeaderCell,\n+  MatCell,\n+  MatHeaderRow,\n+  MatRow,\n+  MatColumnDef,\n+  MatHeaderCellDef,\n+  MatCellDef,\n+  MatHeaderRowDef,\n+  MatRowDef,\n+} from '@angular/material/table';\n+import {CommonModule} from '@angular/common';\n+import {ButtonComponent} from '../../shared/button/button.component';\n+import {Events, MessageBus, TransferStateValue} from '../../../../../protocol';\n+\n+interface TransferStateItem {\n+  key: string;\n+  value: TransferStateValue;\n+  type: string;\n+  size: string;\n+  isExpanded?: boolean;\n+  isCopied?: boolean;\n+}\n+\n+@Component({\n+  selector: 'ng-transfer-state',\n+  standalone: true,\n+  imports: [\n+    CommonModule,\n+    MatIcon,\n+    MatTooltip,\n+    MatTable,\n+    MatHeaderCell,\n+    MatCell,\n+    MatHeaderRow,\n+    MatRow,\n+    MatColumnDef,\n+    MatHeaderCellDef,\n+    MatCellDef,\n+    MatHeaderRowDef,\n+    MatRowDef,\n+    ButtonComponent,\n+  ],\n+  templateUrl: './transfer-state.component.html',\n+  styleUrls: ['./transfer-state.component.scss'],\n+  changeDetection: ChangeDetectionStrategy.OnPush,\n+})\n+export class TransferStateComponent {\n+  private _messageBus = inject(MessageBus) as MessageBus<Events>;\n+  private _clipboard = inject(Clipboard);\n+  readonly MAX_DISPLAY_LENGTH = 200;\n+\n+  readonly transferStateData = signal<Record<string, TransferStateValue> | null>(null);\n+  readonly error = signal<string | null>(null);\n+  readonly isLoading = signal(false);\n+\n+  readonly transferStateItems = computed<TransferStateItem[]>(() => {\n+    const data = this.transferStateData();\n+    if (!data) return [];\n+\n+    return Object.entries(data).map(([key, value]) => ({\n+      key,\n+      value,\n+      type: this.getValueType(value),\n+      size: this.getValueSize(value),\n+      isExpanded: false,\n+      isCopied: false,\n+    }));\n+  });\n+\n+  readonly hasData = computed(() => this.transferStateItems().length > 0);\n+\n+  readonly totalSize = computed(() => {\n+    const items = this.transferStateItems();\n+    if (items.length === 0) return '0 B';\n+\n+    let totalBytes = 0;\n+    for (const item of items) {\n+      const str = typeof item.value === 'string' ? item.value : JSON.stringify(item.value);\n+      totalBytes += new Blob([str]).size;\n+    }\n+\n+    if (totalBytes < 1024) return `${totalBytes} B`;\n+    if (totalBytes < 1024 * 1024) return `${(totalBytes / 1024).toFixed(1)} KB`;\n+    return `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;\n+  });\n+\n+  displayedColumns: string[] = ['key', 'type', 'size', 'value'];\n+\n+  constructor() {\n+    this.loadTransferState();\n+  }\n+\n+  private getValueType(value: TransferStateValue): string {\n+    if (value === null) return 'null';\n+    if (Array.isArray(value)) return 'array';\n+    return typeof value;\n+  }\n+\n+  getValueSize(value: TransferStateValue): string {\n+    try {\n+      const str = JSON.stringify(value);\n+      const bytes = new Blob([str]).size;\n+      if (bytes < 1024) return `${bytes} B`;\n+      if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n+      return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n+    } catch {\n+      return 'unknown';\n+    }\n+  }\n+\n+  private formatValue(value: TransferStateValue, isExpanded = false): string {\n+    const formatters = {\n+      null: () => 'null',\n+      undefined: () => 'undefined',\n+      string: (val: string) => `\"${val}\"`,\n+      object: (val: object) => JSON.stringify(val, null, 2),\n+      default: (val: unknown) => String(val),\n+    };\n+\n+    const getFormattedValue = (val: TransferStateValue): string => {\n+      if (val === null) return formatters.null();\n+      if (val === undefined) return formatters.undefined();\n+      if (typeof val === 'string') return formatters.string(val);\n+      if (typeof val === 'object') return formatters.object(val);\n+      return formatters.default(val);\n+    };",
        "comment_created_at": "2025-07-09T10:41:27+00:00",
        "comment_author": "hawkgs",
        "comment_body": "This object and function are created on each `formatValue` call but they don't seem to rely on the method parameters so they just add an extra execution overhead. I think it makes sense to extract and move them in a utility function as well.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2208959453",
    "pr_number": 62659,
    "pr_file": "packages/forms/experimental/src/api/validators/max_length.ts",
    "created_at": "2025-07-16T00:40:09+00:00",
    "commented_code": "/**\n  * Validator requiring a field value's length to be smaller than or equal to a maximum length.\n+ * This validator can oly be used with string or array fields.\n+ * This validator adds `MAX_LENGTH` metadata to the field.\n  *\n- * @param path Path to the target field (currently string or array).\n- * @param maxLength The maximum length, or a LogicFn returning it.\n- * @param config Optional, currently allows providing custom errors function.\n+ * @param path Path of the field to validate\n+ * @param maxLength The maximum length, or a LogicFn that returns the maximum length.\n+ * @param config Optional, allows providing any of the following options:\n+ *  - `errors`: A function that recevies the `FieldContext` and returns custom validation error(s)\n+ *    to be used instead of the default `ValidationError.maxlength(maxLength)`\n+ * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n  */\n+// TODO: We should decide whether we want to use camel case or all-lowercase, to create an error we\n+// have ValidationError.maxlength (applied to minLength as well)\n export function maxLength<TPathKind extends PathKind = PathKind.Root>(\n   path: FieldPath<ValueWithLength, TPathKind>,\n   maxLength: number | LogicFn<ValueWithLength, number | undefined, TPathKind>,\n   config?: BaseValidatorConfig<ValueWithLength, TPathKind>,\n ) {\n+  // TODO: should we memoize this in a computed? (applies to other metadata validators as well)",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2208959453",
        "repo_full_name": "angular/angular",
        "pr_number": 62659,
        "pr_file": "packages/forms/experimental/src/api/validators/max_length.ts",
        "discussion_id": "2208959453",
        "commented_code": "@@ -14,16 +14,24 @@ import {BaseValidatorConfig, ValueWithLength} from './types';\n \n /**\n  * Validator requiring a field value's length to be smaller than or equal to a maximum length.\n+ * This validator can oly be used with string or array fields.\n+ * This validator adds `MAX_LENGTH` metadata to the field.\n  *\n- * @param path Path to the target field (currently string or array).\n- * @param maxLength The maximum length, or a LogicFn returning it.\n- * @param config Optional, currently allows providing custom errors function.\n+ * @param path Path of the field to validate\n+ * @param maxLength The maximum length, or a LogicFn that returns the maximum length.\n+ * @param config Optional, allows providing any of the following options:\n+ *  - `errors`: A function that recevies the `FieldContext` and returns custom validation error(s)\n+ *    to be used instead of the default `ValidationError.maxlength(maxLength)`\n+ * @template TPathKind The kind of path the logic is bound to (a root path, child path, or item of an array)\n  */\n+// TODO: We should decide whether we want to use camel case or all-lowercase, to create an error we\n+// have ValidationError.maxlength (applied to minLength as well)\n export function maxLength<TPathKind extends PathKind = PathKind.Root>(\n   path: FieldPath<ValueWithLength, TPathKind>,\n   maxLength: number | LogicFn<ValueWithLength, number | undefined, TPathKind>,\n   config?: BaseValidatorConfig<ValueWithLength, TPathKind>,\n ) {\n+  // TODO: should we memoize this in a computed? (applies to other metadata validators as well)",
        "comment_created_at": "2025-07-16T00:40:09+00:00",
        "comment_author": "mmalerba",
        "comment_body": "We don't know what the user is doing in their logic function, it could potentially be expensive so my feeling is yes we probably should memoize this?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2242171032",
    "pr_number": 62723,
    "pr_file": "packages/core/src/hydration/annotate.ts",
    "created_at": "2025-07-30T10:14:56+00:00",
    "commented_code": "function componentUsesShadowDomEncapsulation(lView: LView): boolean {\n   const instance = lView[CONTEXT];\n   return instance?.constructor\n-    ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.ShadowDom\n+    ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.ShadowDom ||\n+        getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.IsolatedShadowDom",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2242171032",
        "repo_full_name": "angular/angular",
        "pr_number": 62723,
        "pr_file": "packages/core/src/hydration/annotate.ts",
        "discussion_id": "2242171032",
        "commented_code": "@@ -793,7 +793,8 @@ function conditionallyAnnotateNodePath(\n function componentUsesShadowDomEncapsulation(lView: LView): boolean {\n   const instance = lView[CONTEXT];\n   return instance?.constructor\n-    ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.ShadowDom\n+    ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.ShadowDom ||\n+        getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.IsolatedShadowDom",
        "comment_created_at": "2025-07-30T10:14:56+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "We can probably refactor this to only invoke `getComponentDef` once. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2242239059",
        "repo_full_name": "angular/angular",
        "pr_number": 62723,
        "pr_file": "packages/core/src/hydration/annotate.ts",
        "discussion_id": "2242171032",
        "commented_code": "@@ -793,7 +793,8 @@ function conditionallyAnnotateNodePath(\n function componentUsesShadowDomEncapsulation(lView: LView): boolean {\n   const instance = lView[CONTEXT];\n   return instance?.constructor\n-    ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.ShadowDom\n+    ? getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.ShadowDom ||\n+        getComponentDef(instance.constructor)?.encapsulation === ViewEncapsulation.IsolatedShadowDom",
        "comment_created_at": "2025-07-30T10:43:28+00:00",
        "comment_author": "ryan-bendel",
        "comment_body": "Updated if you could re-review?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "633077239",
    "pr_number": 42112,
    "pr_file": "packages/platform-browser/src/dom/dom_renderer.ts",
    "created_at": "2021-05-16T11:03:54+00:00",
    "commented_code": "return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n       default: {\n+        // If the element is inside of the shadow DOM, we have to use a `ShadowDomRenderer`, even\n+        // though its encapsulation isn't explicitly `ShadowDom`, in order to avoid having its\n+        // styles leak out into the document.\n+        const rootNode = element.getRootNode?.();\n+        if (typeof ShadowRoot !== 'undefined' && rootNode instanceof ShadowRoot) {\n+          return new ShadowDomRenderer(",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "633077239",
        "repo_full_name": "angular/angular",
        "pr_number": 42112,
        "pr_file": "packages/platform-browser/src/dom/dom_renderer.ts",
        "discussion_id": "633077239",
        "commented_code": "@@ -114,6 +114,14 @@ export class DomRendererFactory2 implements RendererFactory2 {\n \n         return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n       default: {\n+        // If the element is inside of the shadow DOM, we have to use a `ShadowDomRenderer`, even\n+        // though its encapsulation isn't explicitly `ShadowDom`, in order to avoid having its\n+        // styles leak out into the document.\n+        const rootNode = element.getRootNode?.();\n+        if (typeof ShadowRoot !== 'undefined' && rootNode instanceof ShadowRoot) {\n+          return new ShadowDomRenderer(",
        "comment_created_at": "2021-05-16T11:03:54+00:00",
        "comment_author": "JoostK",
        "comment_body": "I noticed that `ShadowDomRenderer` is doing style flattening in its constructor for every instantiation, instead of doing it only once and caching the result somewhere. This includes the regex replace for the `%COMP%` pattern, but that won't even be present as that is only applied by the compiler for components that use emulated style encapsulation. We can probably optimize this a bit, which has become more relevant now that the shadow DOM renderer is used more often (also because this can now trigger usage of `ShadowDomRenderer` even if not used in the Angular app itself, but bootstrapped into a shadow tree).",
        "pr_file_module": null
      },
      {
        "comment_id": "727104697",
        "repo_full_name": "angular/angular",
        "pr_number": 42112,
        "pr_file": "packages/platform-browser/src/dom/dom_renderer.ts",
        "discussion_id": "633077239",
        "commented_code": "@@ -114,6 +114,14 @@ export class DomRendererFactory2 implements RendererFactory2 {\n \n         return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n       default: {\n+        // If the element is inside of the shadow DOM, we have to use a `ShadowDomRenderer`, even\n+        // though its encapsulation isn't explicitly `ShadowDom`, in order to avoid having its\n+        // styles leak out into the document.\n+        const rootNode = element.getRootNode?.();\n+        if (typeof ShadowRoot !== 'undefined' && rootNode instanceof ShadowRoot) {\n+          return new ShadowDomRenderer(",
        "comment_created_at": "2021-10-12T12:49:55+00:00",
        "comment_author": "pkozlowski-opensource",
        "comment_body": "Agreed. Similar flattening is done in the `EmulatedEncapsulationDomRenderer2` but there it is less of an issue as rendered instances are cached per component.id. I wonder why the \"flattening\" isn't done in the compiler, TBH.\r\n\r\nAlso \"flatten\" is confusing right now as it does _both_ flattening and `%COMP%` replacement - we should probably split those 2 different responsibilities. \r\n\r\nHaving said this I think that it is not strictly related to this PR - we can do those improvements in a separate PR (I'm tempted to do it so it is clearer what is going on....)  ",
        "pr_file_module": null
      }
    ]
  }
]