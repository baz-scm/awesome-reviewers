[
  {
    "discussion_id": "2293574340",
    "pr_number": 63328,
    "pr_file": "packages/core/src/render3/instructions/animation.ts",
    "created_at": "2025-08-22T12:19:56+00:00",
    "commented_code": "// from an `@if` or `@for`.\n const leavingNodes = new WeakMap<TNode, HTMLElement[]>();\n \n-function clearLeavingNodes(tNode: TNode): void {\n-  if (leavingNodes.get(tNode)?.length === 0) {\n+function clearLeavingNodes(tNode: TNode, el: HTMLElement): void {\n+  const nodes = leavingNodes.get(tNode);\n+  if (nodes && nodes.length > 0) {\n+    const ix = nodes.findIndex((node) => node === el);\n+    if (ix > -1) nodes.splice(ix, 1);\n+  }\n+  if (nodes?.length === 0) {\n     leavingNodes.delete(tNode);\n   }\n }\n \n+/**\n+ * In the case that we have an existing node that's animating away, like when\n+ * an `@if` toggles quickly, we need to end the animation for the former node\n+ * and remove it right away to prevent duplicate nodes showing up.\n+ */\n+function cancelLeavingNodes(tNode: TNode, lView: LView): void {\n+  const leavingEl = leavingNodes.get(tNode)?.shift();\n+  const lContainer = lView[DECLARATION_LCONTAINER];\n+  if (lContainer) {\n+    // this is the insertion point for the new TNode element.\n+    // it will be inserted before the declaring containers anchor.\n+    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);\n+    // here we need to check the previous sibling of that anchor\n+    const previousNode = (beforeNode as Node)?.previousSibling;",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2293574340",
        "repo_full_name": "angular/angular",
        "pr_number": 63328,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2293574340",
        "commented_code": "@@ -88,12 +98,40 @@ const longestAnimations = new WeakMap<HTMLElement, LongestAnimation>();\n // from an `@if` or `@for`.\n const leavingNodes = new WeakMap<TNode, HTMLElement[]>();\n \n-function clearLeavingNodes(tNode: TNode): void {\n-  if (leavingNodes.get(tNode)?.length === 0) {\n+function clearLeavingNodes(tNode: TNode, el: HTMLElement): void {\n+  const nodes = leavingNodes.get(tNode);\n+  if (nodes && nodes.length > 0) {\n+    const ix = nodes.findIndex((node) => node === el);\n+    if (ix > -1) nodes.splice(ix, 1);\n+  }\n+  if (nodes?.length === 0) {\n     leavingNodes.delete(tNode);\n   }\n }\n \n+/**\n+ * In the case that we have an existing node that's animating away, like when\n+ * an `@if` toggles quickly, we need to end the animation for the former node\n+ * and remove it right away to prevent duplicate nodes showing up.\n+ */\n+function cancelLeavingNodes(tNode: TNode, lView: LView): void {\n+  const leavingEl = leavingNodes.get(tNode)?.shift();\n+  const lContainer = lView[DECLARATION_LCONTAINER];\n+  if (lContainer) {\n+    // this is the insertion point for the new TNode element.\n+    // it will be inserted before the declaring containers anchor.\n+    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);\n+    // here we need to check the previous sibling of that anchor\n+    const previousNode = (beforeNode as Node)?.previousSibling;",
        "comment_created_at": "2025-08-22T12:19:56+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "If we go with this fix, should add `previousSibling` to `RNode` instead ? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2293588674",
        "repo_full_name": "angular/angular",
        "pr_number": 63328,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2293574340",
        "commented_code": "@@ -88,12 +98,40 @@ const longestAnimations = new WeakMap<HTMLElement, LongestAnimation>();\n // from an `@if` or `@for`.\n const leavingNodes = new WeakMap<TNode, HTMLElement[]>();\n \n-function clearLeavingNodes(tNode: TNode): void {\n-  if (leavingNodes.get(tNode)?.length === 0) {\n+function clearLeavingNodes(tNode: TNode, el: HTMLElement): void {\n+  const nodes = leavingNodes.get(tNode);\n+  if (nodes && nodes.length > 0) {\n+    const ix = nodes.findIndex((node) => node === el);\n+    if (ix > -1) nodes.splice(ix, 1);\n+  }\n+  if (nodes?.length === 0) {\n     leavingNodes.delete(tNode);\n   }\n }\n \n+/**\n+ * In the case that we have an existing node that's animating away, like when\n+ * an `@if` toggles quickly, we need to end the animation for the former node\n+ * and remove it right away to prevent duplicate nodes showing up.\n+ */\n+function cancelLeavingNodes(tNode: TNode, lView: LView): void {\n+  const leavingEl = leavingNodes.get(tNode)?.shift();\n+  const lContainer = lView[DECLARATION_LCONTAINER];\n+  if (lContainer) {\n+    // this is the insertion point for the new TNode element.\n+    // it will be inserted before the declaring containers anchor.\n+    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);\n+    // here we need to check the previous sibling of that anchor\n+    const previousNode = (beforeNode as Node)?.previousSibling;",
        "comment_created_at": "2025-08-22T12:24:24+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "I don't know the context as to why `RNode` doesn't have it. There may be some node types that don't have `previousSibling`. Feels risky.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293599450",
        "repo_full_name": "angular/angular",
        "pr_number": 63328,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2293574340",
        "commented_code": "@@ -88,12 +98,40 @@ const longestAnimations = new WeakMap<HTMLElement, LongestAnimation>();\n // from an `@if` or `@for`.\n const leavingNodes = new WeakMap<TNode, HTMLElement[]>();\n \n-function clearLeavingNodes(tNode: TNode): void {\n-  if (leavingNodes.get(tNode)?.length === 0) {\n+function clearLeavingNodes(tNode: TNode, el: HTMLElement): void {\n+  const nodes = leavingNodes.get(tNode);\n+  if (nodes && nodes.length > 0) {\n+    const ix = nodes.findIndex((node) => node === el);\n+    if (ix > -1) nodes.splice(ix, 1);\n+  }\n+  if (nodes?.length === 0) {\n     leavingNodes.delete(tNode);\n   }\n }\n \n+/**\n+ * In the case that we have an existing node that's animating away, like when\n+ * an `@if` toggles quickly, we need to end the animation for the former node\n+ * and remove it right away to prevent duplicate nodes showing up.\n+ */\n+function cancelLeavingNodes(tNode: TNode, lView: LView): void {\n+  const leavingEl = leavingNodes.get(tNode)?.shift();\n+  const lContainer = lView[DECLARATION_LCONTAINER];\n+  if (lContainer) {\n+    // this is the insertion point for the new TNode element.\n+    // it will be inserted before the declaring containers anchor.\n+    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);\n+    // here we need to check the previous sibling of that anchor\n+    const previousNode = (beforeNode as Node)?.previousSibling;",
        "comment_created_at": "2025-08-22T12:28:50+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "That said, acceptance tests pass when adding it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293603761",
        "repo_full_name": "angular/angular",
        "pr_number": 63328,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2293574340",
        "commented_code": "@@ -88,12 +98,40 @@ const longestAnimations = new WeakMap<HTMLElement, LongestAnimation>();\n // from an `@if` or `@for`.\n const leavingNodes = new WeakMap<TNode, HTMLElement[]>();\n \n-function clearLeavingNodes(tNode: TNode): void {\n-  if (leavingNodes.get(tNode)?.length === 0) {\n+function clearLeavingNodes(tNode: TNode, el: HTMLElement): void {\n+  const nodes = leavingNodes.get(tNode);\n+  if (nodes && nodes.length > 0) {\n+    const ix = nodes.findIndex((node) => node === el);\n+    if (ix > -1) nodes.splice(ix, 1);\n+  }\n+  if (nodes?.length === 0) {\n     leavingNodes.delete(tNode);\n   }\n }\n \n+/**\n+ * In the case that we have an existing node that's animating away, like when\n+ * an `@if` toggles quickly, we need to end the animation for the former node\n+ * and remove it right away to prevent duplicate nodes showing up.\n+ */\n+function cancelLeavingNodes(tNode: TNode, lView: LView): void {\n+  const leavingEl = leavingNodes.get(tNode)?.shift();\n+  const lContainer = lView[DECLARATION_LCONTAINER];\n+  if (lContainer) {\n+    // this is the insertion point for the new TNode element.\n+    // it will be inserted before the declaring containers anchor.\n+    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);\n+    // here we need to check the previous sibling of that anchor\n+    const previousNode = (beforeNode as Node)?.previousSibling;",
        "comment_created_at": "2025-08-22T12:30:38+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "afaik `RNode` is just a sub-ensemble of `Node` keys and its RNode already has `nextSibling`, it seemed fair to me to add it. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2293608206",
        "repo_full_name": "angular/angular",
        "pr_number": 63328,
        "pr_file": "packages/core/src/render3/instructions/animation.ts",
        "discussion_id": "2293574340",
        "commented_code": "@@ -88,12 +98,40 @@ const longestAnimations = new WeakMap<HTMLElement, LongestAnimation>();\n // from an `@if` or `@for`.\n const leavingNodes = new WeakMap<TNode, HTMLElement[]>();\n \n-function clearLeavingNodes(tNode: TNode): void {\n-  if (leavingNodes.get(tNode)?.length === 0) {\n+function clearLeavingNodes(tNode: TNode, el: HTMLElement): void {\n+  const nodes = leavingNodes.get(tNode);\n+  if (nodes && nodes.length > 0) {\n+    const ix = nodes.findIndex((node) => node === el);\n+    if (ix > -1) nodes.splice(ix, 1);\n+  }\n+  if (nodes?.length === 0) {\n     leavingNodes.delete(tNode);\n   }\n }\n \n+/**\n+ * In the case that we have an existing node that's animating away, like when\n+ * an `@if` toggles quickly, we need to end the animation for the former node\n+ * and remove it right away to prevent duplicate nodes showing up.\n+ */\n+function cancelLeavingNodes(tNode: TNode, lView: LView): void {\n+  const leavingEl = leavingNodes.get(tNode)?.shift();\n+  const lContainer = lView[DECLARATION_LCONTAINER];\n+  if (lContainer) {\n+    // this is the insertion point for the new TNode element.\n+    // it will be inserted before the declaring containers anchor.\n+    const beforeNode = getBeforeNodeForView(tNode.index, lContainer);\n+    // here we need to check the previous sibling of that anchor\n+    const previousNode = (beforeNode as Node)?.previousSibling;",
        "comment_created_at": "2025-08-22T12:32:49+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143335761",
    "pr_number": 61971,
    "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/util.ts",
    "created_at": "2025-06-12T17:56:24+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {HtmlParser, ParseTreeResult, visitAll, RecursiveVisitor, Element} from '@angular/compiler';\n+\n+export function migrateNgClassBindings(template: string): {\n+  replacementCount: number;\n+  migrated: string;\n+  changed: boolean;\n+} {\n+  const parsed = parseHtmlTemplate(template);\n+  if (!parsed.tree || !parsed.tree.rootNodes.length) {\n+    return {migrated: template, changed: false, replacementCount: 0};\n+  }\n+\n+  const visitor = new NgClassCollector(template);\n+  visitAll(visitor, parsed.tree.rootNodes);\n+\n+  let newTemplate = template;\n+  let changedOffset = 0;\n+  let replacementCount = 0;\n+\n+  for (const {start, end, replacement} of visitor.replacements) {\n+    const currentLength = newTemplate.length;\n+\n+    newTemplate = replaceTemplate(newTemplate, replacement, start, end, changedOffset);\n+    changedOffset += newTemplate.length - currentLength;\n+    replacementCount++;\n+  }\n+\n+  return {migrated: newTemplate, changed: changedOffset !== 0, replacementCount};\n+}\n+\n+function parseHtmlTemplate(template: string): {tree: ParseTreeResult | undefined; errors: any[]} {\n+  let parsed: ParseTreeResult;\n+  try {\n+    parsed = new HtmlParser().parse(template, '', {\n+      tokenizeExpansionForms: true,\n+      tokenizeBlocks: true,\n+      preserveLineEndings: true,\n+    });\n+\n+    if (parsed.errors && parsed.errors.length > 0) {\n+      const errors = parsed.errors.map((e) => ({type: 'parse', error: e}));\n+      return {tree: undefined, errors};\n+    }\n+  } catch (e: any) {\n+    return {tree: undefined, errors: [{type: 'parse', error: e}]};\n+  }\n+  return {tree: parsed, errors: []};\n+}\n+\n+function replaceTemplate(\n+  template: string,\n+  replaceValue: string,\n+  start: number,\n+  end: number,\n+  offset: number,\n+) {\n+  return template.slice(0, start + offset) + replaceValue + template.slice(end + offset);\n+}\n+\n+/**\n+ * Visitor class that scans Angular templates and collects replacements\n+ * for [ngClass] bindings that use static object literals.\n+ *\n+ * Converts:\n+ *   <div [ngClass]=\"{foo: isFoo, bar: isBar}\">\n+ * Into:\n+ *   <div [class.foo]=\"isFoo\" [class.bar]=\"isBar\">\n+ */\n+export class NgClassCollector extends RecursiveVisitor {\n+  // Stores the set of transformations to apply to the template\n+  readonly replacements: {start: number; end: number; replacement: string}[] = [];\n+  private originalTemplate: string;\n+\n+  constructor(template: string) {\n+    super();\n+    this.originalTemplate = template;\n+  }\n+\n+  override visitElement(element: Element, context: any) {\n+    for (const attr of element.attrs) {\n+      // Check for [ngClass] attribute with a bound expression\n+      if (attr.name === '[ngClass]' && attr.valueSpan) {\n+        // Extract the full text of the binding expression\n+        const expr = this.originalTemplate.slice(\n+          attr.valueSpan.start.offset,\n+          attr.valueSpan.end.offset,\n+        );\n+\n+        // Attempt to statically parse the expression as an object literal\n+        const staticMatch = tryParseStaticObjectLiteral(expr);\n+\n+        // Only continue if we got a valid, non-empty set of class conditions\n+        if (staticMatch && staticMatch.length > 0) {\n+          // Convert each key-value pair into an individual [class.className] binding\n+          const replacement = staticMatch\n+            .map(({key, value}) => `[class.${key}]=\"${value}\"`)\n+            .join(' ');\n+\n+          // Save the replacement operation for this attribute span\n+          this.replacements.push({\n+            start: attr.sourceSpan.start.offset,\n+            end: attr.sourceSpan.end.offset,\n+            replacement,\n+          });\n+        }\n+      }\n+    }\n+\n+    // Continue traversing child elements\n+    return super.visitElement(element, context);\n+  }\n+}\n+\n+/**\n+ * Attempts to parse a [ngClass] expression string that uses a static object literal.\n+ *\n+ * Example:\n+ *   Input:  \"{ foo: isFoo, 'bar baz': condition }\"\n+ *   Output: [\n+ *     { key: 'foo', value: 'isFoo' },\n+ *     { key: 'bar', value: 'condition' },\n+ *     { key: 'baz', value: 'condition' }\n+ *   ]\n+ *\n+ * Returns null if:\n+ *   - The expression isn't an object literal\n+ *   - Any entry is missing a key or value\n+ *   - The format is invalid\n+ */\n+function tryParseStaticObjectLiteral(expr: string): {key: string; value: string}[] | null {\n+  // Basic object literal regex: matches `{ key: value, ... }`\n+  const objectLiteralRegex = /^\\s*\\{\\s*([^}]*)\\s*\\}\\s*$/;\n+  const match = expr.match(objectLiteralRegex);\n+  if (!match) return null;",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2143335761",
        "repo_full_name": "angular/angular",
        "pr_number": 61971,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/util.ts",
        "discussion_id": "2143335761",
        "commented_code": "@@ -0,0 +1,174 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {HtmlParser, ParseTreeResult, visitAll, RecursiveVisitor, Element} from '@angular/compiler';\n+\n+export function migrateNgClassBindings(template: string): {\n+  replacementCount: number;\n+  migrated: string;\n+  changed: boolean;\n+} {\n+  const parsed = parseHtmlTemplate(template);\n+  if (!parsed.tree || !parsed.tree.rootNodes.length) {\n+    return {migrated: template, changed: false, replacementCount: 0};\n+  }\n+\n+  const visitor = new NgClassCollector(template);\n+  visitAll(visitor, parsed.tree.rootNodes);\n+\n+  let newTemplate = template;\n+  let changedOffset = 0;\n+  let replacementCount = 0;\n+\n+  for (const {start, end, replacement} of visitor.replacements) {\n+    const currentLength = newTemplate.length;\n+\n+    newTemplate = replaceTemplate(newTemplate, replacement, start, end, changedOffset);\n+    changedOffset += newTemplate.length - currentLength;\n+    replacementCount++;\n+  }\n+\n+  return {migrated: newTemplate, changed: changedOffset !== 0, replacementCount};\n+}\n+\n+function parseHtmlTemplate(template: string): {tree: ParseTreeResult | undefined; errors: any[]} {\n+  let parsed: ParseTreeResult;\n+  try {\n+    parsed = new HtmlParser().parse(template, '', {\n+      tokenizeExpansionForms: true,\n+      tokenizeBlocks: true,\n+      preserveLineEndings: true,\n+    });\n+\n+    if (parsed.errors && parsed.errors.length > 0) {\n+      const errors = parsed.errors.map((e) => ({type: 'parse', error: e}));\n+      return {tree: undefined, errors};\n+    }\n+  } catch (e: any) {\n+    return {tree: undefined, errors: [{type: 'parse', error: e}]};\n+  }\n+  return {tree: parsed, errors: []};\n+}\n+\n+function replaceTemplate(\n+  template: string,\n+  replaceValue: string,\n+  start: number,\n+  end: number,\n+  offset: number,\n+) {\n+  return template.slice(0, start + offset) + replaceValue + template.slice(end + offset);\n+}\n+\n+/**\n+ * Visitor class that scans Angular templates and collects replacements\n+ * for [ngClass] bindings that use static object literals.\n+ *\n+ * Converts:\n+ *   <div [ngClass]=\"{foo: isFoo, bar: isBar}\">\n+ * Into:\n+ *   <div [class.foo]=\"isFoo\" [class.bar]=\"isBar\">\n+ */\n+export class NgClassCollector extends RecursiveVisitor {\n+  // Stores the set of transformations to apply to the template\n+  readonly replacements: {start: number; end: number; replacement: string}[] = [];\n+  private originalTemplate: string;\n+\n+  constructor(template: string) {\n+    super();\n+    this.originalTemplate = template;\n+  }\n+\n+  override visitElement(element: Element, context: any) {\n+    for (const attr of element.attrs) {\n+      // Check for [ngClass] attribute with a bound expression\n+      if (attr.name === '[ngClass]' && attr.valueSpan) {\n+        // Extract the full text of the binding expression\n+        const expr = this.originalTemplate.slice(\n+          attr.valueSpan.start.offset,\n+          attr.valueSpan.end.offset,\n+        );\n+\n+        // Attempt to statically parse the expression as an object literal\n+        const staticMatch = tryParseStaticObjectLiteral(expr);\n+\n+        // Only continue if we got a valid, non-empty set of class conditions\n+        if (staticMatch && staticMatch.length > 0) {\n+          // Convert each key-value pair into an individual [class.className] binding\n+          const replacement = staticMatch\n+            .map(({key, value}) => `[class.${key}]=\"${value}\"`)\n+            .join(' ');\n+\n+          // Save the replacement operation for this attribute span\n+          this.replacements.push({\n+            start: attr.sourceSpan.start.offset,\n+            end: attr.sourceSpan.end.offset,\n+            replacement,\n+          });\n+        }\n+      }\n+    }\n+\n+    // Continue traversing child elements\n+    return super.visitElement(element, context);\n+  }\n+}\n+\n+/**\n+ * Attempts to parse a [ngClass] expression string that uses a static object literal.\n+ *\n+ * Example:\n+ *   Input:  \"{ foo: isFoo, 'bar baz': condition }\"\n+ *   Output: [\n+ *     { key: 'foo', value: 'isFoo' },\n+ *     { key: 'bar', value: 'condition' },\n+ *     { key: 'baz', value: 'condition' }\n+ *   ]\n+ *\n+ * Returns null if:\n+ *   - The expression isn't an object literal\n+ *   - Any entry is missing a key or value\n+ *   - The format is invalid\n+ */\n+function tryParseStaticObjectLiteral(expr: string): {key: string; value: string}[] | null {\n+  // Basic object literal regex: matches `{ key: value, ... }`\n+  const objectLiteralRegex = /^\\s*\\{\\s*([^}]*)\\s*\\}\\s*$/;\n+  const match = expr.match(objectLiteralRegex);\n+  if (!match) return null;",
        "comment_created_at": "2025-06-12T17:56:24+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "This should be done using the AST, not a regex. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2238052368",
    "pr_number": 62719,
    "pr_file": "devtools/projects/ng-devtools-backend/src/lib/directive-forest/index.ts",
    "created_at": "2025-07-29T00:03:20+00:00",
    "commented_code": "return null;\n };\n \n-export const buildDirectiveTree = (element: Element) => {\n-  if (!strategy) {\n-    strategy = selectStrategy(element);\n-  }\n-  if (!strategy) {\n-    console.error('Unable to parse the component tree');\n+export const buildDirectiveForestWithStrategy = (elements: Element[]) => {\n+  if (!elements || !elements.length) {\n     return [];\n   }\n-  return strategy.build(element);\n+\n+  // Different roots can have different Angular versions.\n+  // Diffent versions depend on different component tree discovery strategies.\n+  const strategies: {\n+    strategy: RTreeStrategy | LTreeStrategy;\n+    element: Element;\n+  }[] = elements\n+    .map((element) => {\n+      const strategy = selectStrategy(element);\n+      if (!strategy) {\n+        return null;\n+      }\n+\n+      return {strategy, element};\n+    })\n+    .filter((s) => s !== null);\n+\n+  const result: ComponentTreeNode[][] = [];\n+  for (const [index, {strategy, element}] of strategies.entries()) {\n+    if (strategy === rTreeStrategy) {\n+      result.push(rTreeStrategy.build(element, index));\n+    } else if (strategy === lTreeStrategy) {\n+      result.push(lTreeStrategy.build(element));",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2238052368",
        "repo_full_name": "angular/angular",
        "pr_number": 62719,
        "pr_file": "devtools/projects/ng-devtools-backend/src/lib/directive-forest/index.ts",
        "discussion_id": "2238052368",
        "commented_code": "@@ -29,13 +30,35 @@ const selectStrategy = (element: Element) => {\n   return null;\n };\n \n-export const buildDirectiveTree = (element: Element) => {\n-  if (!strategy) {\n-    strategy = selectStrategy(element);\n-  }\n-  if (!strategy) {\n-    console.error('Unable to parse the component tree');\n+export const buildDirectiveForestWithStrategy = (elements: Element[]) => {\n+  if (!elements || !elements.length) {\n     return [];\n   }\n-  return strategy.build(element);\n+\n+  // Different roots can have different Angular versions.\n+  // Diffent versions depend on different component tree discovery strategies.\n+  const strategies: {\n+    strategy: RTreeStrategy | LTreeStrategy;\n+    element: Element;\n+  }[] = elements\n+    .map((element) => {\n+      const strategy = selectStrategy(element);\n+      if (!strategy) {\n+        return null;\n+      }\n+\n+      return {strategy, element};\n+    })\n+    .filter((s) => s !== null);\n+\n+  const result: ComponentTreeNode[][] = [];\n+  for (const [index, {strategy, element}] of strategies.entries()) {\n+    if (strategy === rTreeStrategy) {\n+      result.push(rTreeStrategy.build(element, index));\n+    } else if (strategy === lTreeStrategy) {\n+      result.push(lTreeStrategy.build(element));",
        "comment_created_at": "2025-07-29T00:03:20+00:00",
        "comment_author": "dgp1130",
        "comment_body": "Consider: Can we update `LTreeStrategy` and `RTreeStrategy` to use a shared interface (with `supports` and `build` accepting an index). Then `LTreeStrategy` can just ignore the index, but the caller can just always provide it. That way we don't need to disambiguate between the two here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "633075768",
    "pr_number": 42112,
    "pr_file": "packages/platform-browser/src/dom/shared_styles_host.ts",
    "created_at": "2021-05-16T10:48:08+00:00",
    "commented_code": "@Injectable()\n export class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n-  // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n-  private _hostNodes = new Map<Node, Node[]>();\n+  // Mapping of component host nodes to the nodes in which their styles are inserted.\n+  private _hostNodes = new Map<Node, Map<Node, Node[]>>();",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "633075768",
        "repo_full_name": "angular/angular",
        "pr_number": 42112,
        "pr_file": "packages/platform-browser/src/dom/shared_styles_host.ts",
        "discussion_id": "633075768",
        "commented_code": "@@ -34,44 +34,61 @@ export class SharedStylesHost {\n \n @Injectable()\n export class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n-  // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n-  private _hostNodes = new Map<Node, Node[]>();\n+  // Mapping of component host nodes to the nodes in which their styles are inserted.\n+  private _hostNodes = new Map<Node, Map<Node, Node[]>>();",
        "comment_created_at": "2021-05-16T10:48:08+00:00",
        "comment_author": "JoostK",
        "comment_body": "Is there really a need to store a 1:n mapping from host node to insertion node? Isn't there always a single insertion node per host node?\r\n\r\nIIUC, there are now multiple host nodes associated with a single insertion node (either the shadow root or the document head) but this mapping stores the reverse relation; from host node to their insertion point, which I think is singular.",
        "pr_file_module": null
      },
      {
        "comment_id": "633080881",
        "repo_full_name": "angular/angular",
        "pr_number": 42112,
        "pr_file": "packages/platform-browser/src/dom/shared_styles_host.ts",
        "discussion_id": "633075768",
        "commented_code": "@@ -34,44 +34,61 @@ export class SharedStylesHost {\n \n @Injectable()\n export class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n-  // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n-  private _hostNodes = new Map<Node, Node[]>();\n+  // Mapping of component host nodes to the nodes in which their styles are inserted.\n+  private _hostNodes = new Map<Node, Map<Node, Node[]>>();",
        "comment_created_at": "2021-05-16T11:40:25+00:00",
        "comment_author": "crisbeto",
        "comment_body": "There is, but how would we distinguish which styles belong to which host node? I was trying to solve the issue where multiple host nodes point to a single insertion node and then one of the hosts is removed. In this case we don't want to clear the entire insertion node.",
        "pr_file_module": null
      },
      {
        "comment_id": "633081669",
        "repo_full_name": "angular/angular",
        "pr_number": 42112,
        "pr_file": "packages/platform-browser/src/dom/shared_styles_host.ts",
        "discussion_id": "633075768",
        "commented_code": "@@ -34,44 +34,61 @@ export class SharedStylesHost {\n \n @Injectable()\n export class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n-  // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n-  private _hostNodes = new Map<Node, Node[]>();\n+  // Mapping of component host nodes to the nodes in which their styles are inserted.\n+  private _hostNodes = new Map<Node, Map<Node, Node[]>>();",
        "comment_created_at": "2021-05-16T11:47:43+00:00",
        "comment_author": "JoostK",
        "comment_body": "Would this be sufficient:\r\n\r\n```ts\r\nprivate _hostNodes = new Map<Node, { insertionPoint: Node; styles: Node[] }>();\r\n```\r\n\r\nThen removing a host node can remove the corresponding styles from its insertion point. But I realize that the above is still insufficient when there's multiple host nodes that share styles that they have attached into the same insertion point; that is a bit harder to track.",
        "pr_file_module": null
      },
      {
        "comment_id": "633083928",
        "repo_full_name": "angular/angular",
        "pr_number": 42112,
        "pr_file": "packages/platform-browser/src/dom/shared_styles_host.ts",
        "discussion_id": "633075768",
        "commented_code": "@@ -34,44 +34,61 @@ export class SharedStylesHost {\n \n @Injectable()\n export class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n-  // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n-  private _hostNodes = new Map<Node, Node[]>();\n+  // Mapping of component host nodes to the nodes in which their styles are inserted.\n+  private _hostNodes = new Map<Node, Map<Node, Node[]>>();",
        "comment_created_at": "2021-05-16T12:11:05+00:00",
        "comment_author": "crisbeto",
        "comment_body": "So I think that we could do it by changing `SharedStylesHost._stylesSet` to a `Map<string, Set<Node>>` where the keys are the inserted styles and the set is the insertion nodes that have received the styles. My concern is that this will slow down cleanup, because we'd have to look through all the styles in order to remove the insertion node reference.",
        "pr_file_module": null
      },
      {
        "comment_id": "633087186",
        "repo_full_name": "angular/angular",
        "pr_number": 42112,
        "pr_file": "packages/platform-browser/src/dom/shared_styles_host.ts",
        "discussion_id": "633075768",
        "commented_code": "@@ -34,44 +34,61 @@ export class SharedStylesHost {\n \n @Injectable()\n export class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n-  // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n-  private _hostNodes = new Map<Node, Node[]>();\n+  // Mapping of component host nodes to the nodes in which their styles are inserted.\n+  private _hostNodes = new Map<Node, Map<Node, Node[]>>();",
        "comment_created_at": "2021-05-16T12:45:17+00:00",
        "comment_author": "crisbeto",
        "comment_body": "I pushed a change that should simplify this and resolve the issue where the same styles are inserted multiple times. It uses the insertion node as the key and keeps a counter of host nodes associated with the insertion node. The only downside is that we'll only clear the styles once every host node has been destroyed, but that doesn't seem like it would be too much of an issue?",
        "pr_file_module": null
      }
    ]
  }
]