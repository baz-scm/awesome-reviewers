[
  {
    "discussion_id": "2139073560",
    "pr_number": 61993,
    "pr_file": "adev/src/content/guide/http/http-resource.md",
    "created_at": "2025-06-11T02:41:45+00:00",
    "commented_code": "+# Data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Fetching data is by nature an asynchronous task. You can use a [`Resource`](/api/core/resource) to perform any kind of async operation.\n+\n+<!-- mention reactive ?-->\n+\n+`httpResource` is built on top of the `resource` primitive and uses `HttpClient` as loader. It acts as a frontend for `@angular/common/http`. It makes HTTP requests through the Angular HTTP stack, including interceptors. \n+\n+## Reactive HTTP requests  \n+\n+`httpResource` makes a reactive HTTP request and exposes the request status and response value as a [`WritableResource`](/api/core/WritableResource). By default, it assumes that the backend will return JSON data. Like `resource`, it configures a reactive request. If any of the source signals in the request computation change, a new HTTP request will be made.\n+\n+You can define an http resource by returning a url: \n+\n+```ts\n+userId = input.required<string>();\n+\n+user = httpResource(() => `/api/user/${userId()}`); // A reactive function as argument\n+```\n+\n+IMPORTANT: `httpResource` differs from the `HttpClient` as it initiates the request eagerly (unlike the `HttpClient` `Observable`-based requests which must be subscribed).\n+\n+For more advanced requests, it is possible to define a request object similar to `HttpClient`\u2018s request.\n+\n+```ts\n+user = httpResource(() => ({\n+  url: `/api/user/${userId()}`,\n+  method: 'GET',\n+  headers: {\n+    'X-Special': 'true',\n+  },\n+  params: {\n+    'fast': 'yes',\n+  },\n+  reportProgress: true,\n+  withCredentials: true,\n+  transferCache: true,\n+}));\n+```\n+\n+While the resource pattern is meant only for retrieving asynchronous data, `httpResource` will allow any request method (like `POST` in the previous example). This still doesn\u2019t mean that you should be using `httpResource` to change data on the server. For instance, if you need to submit form data, use the `HttpClient` methods.\n+\n+### Response types \n+\n+An `httpResource` will return and parse the response as JSON but it is possible to use it for other return types.\n+\n+The API has multiple dedicated methods available for other response types:\n+\n+```ts\n+httpResource.text(() => ({ \u2026 })); // returns a string in value()\n+\n+httpResource.blob(() => ({ \u2026 })); // returns a Blob object in value()\n+\n+httpResource.arrayBuffer(() => ({ \u2026 })); // returns an ArrayBuffer in value()\n+```\n+\n+## Shape of an HttpResource\n+\n+An httpResource , similar to other `resource`, exposes several signals:\n+\n+- `value()` \u2014 which contains the result of the http request (when successful) and is programmatically overwritable\n+- `status()` \u2014 with the status of the resource (idle, loading, error etc)\n+- `error()` \u2014 with the request error / parsing error\n+- `isLoading()` \u2014 which is `true` while the request is pending\n+\n+It also includes dedicated signals for metadata about the response:\n+\n+- `\u200b\u200bheaders()` \u2014 with the response\u2019s headers\n+- `statusCode()` \u2014 with the response\u2019s status code\n+- `progress()` \u2014 with the progress of the request (if required in the request object)",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2139073560",
        "repo_full_name": "angular/angular",
        "pr_number": 61993,
        "pr_file": "adev/src/content/guide/http/http-resource.md",
        "discussion_id": "2139073560",
        "commented_code": "@@ -0,0 +1,126 @@\n+# Data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Fetching data is by nature an asynchronous task. You can use a [`Resource`](/api/core/resource) to perform any kind of async operation.\n+\n+<!-- mention reactive ?-->\n+\n+`httpResource` is built on top of the `resource` primitive and uses `HttpClient` as loader. It acts as a frontend for `@angular/common/http`. It makes HTTP requests through the Angular HTTP stack, including interceptors. \n+\n+## Reactive HTTP requests  \n+\n+`httpResource` makes a reactive HTTP request and exposes the request status and response value as a [`WritableResource`](/api/core/WritableResource). By default, it assumes that the backend will return JSON data. Like `resource`, it configures a reactive request. If any of the source signals in the request computation change, a new HTTP request will be made.\n+\n+You can define an http resource by returning a url: \n+\n+```ts\n+userId = input.required<string>();\n+\n+user = httpResource(() => `/api/user/${userId()}`); // A reactive function as argument\n+```\n+\n+IMPORTANT: `httpResource` differs from the `HttpClient` as it initiates the request eagerly (unlike the `HttpClient` `Observable`-based requests which must be subscribed).\n+\n+For more advanced requests, it is possible to define a request object similar to `HttpClient`\u2018s request.\n+\n+```ts\n+user = httpResource(() => ({\n+  url: `/api/user/${userId()}`,\n+  method: 'GET',\n+  headers: {\n+    'X-Special': 'true',\n+  },\n+  params: {\n+    'fast': 'yes',\n+  },\n+  reportProgress: true,\n+  withCredentials: true,\n+  transferCache: true,\n+}));\n+```\n+\n+While the resource pattern is meant only for retrieving asynchronous data, `httpResource` will allow any request method (like `POST` in the previous example). This still doesn\u2019t mean that you should be using `httpResource` to change data on the server. For instance, if you need to submit form data, use the `HttpClient` methods.\n+\n+### Response types \n+\n+An `httpResource` will return and parse the response as JSON but it is possible to use it for other return types.\n+\n+The API has multiple dedicated methods available for other response types:\n+\n+```ts\n+httpResource.text(() => ({ \u2026 })); // returns a string in value()\n+\n+httpResource.blob(() => ({ \u2026 })); // returns a Blob object in value()\n+\n+httpResource.arrayBuffer(() => ({ \u2026 })); // returns an ArrayBuffer in value()\n+```\n+\n+## Shape of an HttpResource\n+\n+An httpResource , similar to other `resource`, exposes several signals:\n+\n+- `value()` \u2014 which contains the result of the http request (when successful) and is programmatically overwritable\n+- `status()` \u2014 with the status of the resource (idle, loading, error etc)\n+- `error()` \u2014 with the request error / parsing error\n+- `isLoading()` \u2014 which is `true` while the request is pending\n+\n+It also includes dedicated signals for metadata about the response:\n+\n+- `\u200b\u200bheaders()` \u2014 with the response\u2019s headers\n+- `statusCode()` \u2014 with the response\u2019s status code\n+- `progress()` \u2014 with the progress of the request (if required in the request object)",
        "comment_created_at": "2025-06-11T02:41:45+00:00",
        "comment_author": "jelbourn",
        "comment_body": "IMO this section is too duplicative of the API reference; I would either cut it, or expand the topic with more examples that show these APIs in action. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2274615528",
    "pr_number": 63141,
    "pr_file": "adev/src/content/ai/mcp-server-setup.md",
    "created_at": "2025-08-13T20:59:20+00:00",
    "commented_code": "```\n \n ### Other IDEs\n+\n For these IDEs, create a configuration file and add the following snippet. Note the use of the `mcpServers` property.\n-*   **Cursor:** Create a file named `.cursor/mcp.json` in your project's root. You can also configure it globally in `~/.cursor/mcp.json`.\n-*   **Other IDEs:** Check your IDE's documentation for the proper location of the MCP configuration file (often `mcp.json`).\n+\n+- **Cursor:** Create a file named `.cursor/mcp.json` in your project's root. You can also configure it globally in `~/.cursor/mcp.json`.\n+- **Other IDEs:** Check your IDE's documentation for the proper location of the MCP configuration file (often `mcp.json`).",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2274615528",
        "repo_full_name": "angular/angular",
        "pr_number": 63141,
        "pr_file": "adev/src/content/ai/mcp-server-setup.md",
        "discussion_id": "2274615528",
        "commented_code": "@@ -51,9 +71,11 @@ Create a file named `.idx/mcp.json` in your project's root and add the following\n ```\n \n ### Other IDEs\n+\n For these IDEs, create a configuration file and add the following snippet. Note the use of the `mcpServers` property.\n-*   **Cursor:** Create a file named `.cursor/mcp.json` in your project's root. You can also configure it globally in `~/.cursor/mcp.json`.\n-*   **Other IDEs:** Check your IDE's documentation for the proper location of the MCP configuration file (often `mcp.json`).\n+\n+- **Cursor:** Create a file named `.cursor/mcp.json` in your project's root. You can also configure it globally in `~/.cursor/mcp.json`.\n+- **Other IDEs:** Check your IDE's documentation for the proper location of the MCP configuration file (often `mcp.json`).",
        "comment_created_at": "2025-08-13T20:59:20+00:00",
        "comment_author": "jelbourn",
        "comment_body": "This section is kind of weird- the header is \"Other IDEs\", but then it specifically lists Cursor and Other IDEs side-by-side. Should we just have a full section for Cursor? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2277007335",
    "pr_number": 63141,
    "pr_file": "adev/src/content/ai/mcp-server-setup.md",
    "created_at": "2025-08-14T15:44:14+00:00",
    "commented_code": "}\n ```\n \n-## Available Tools\n-\n-The Angular CLI MCP server provides several tools to assist you in your development workflow. Here's an overview of the available tools:\n-\n-### Get Angular Coding Best Practices Guide (`get_best_practices`)\n-\n-This tool provides a guide on modern Angular coding best practices. Before you start writing or modifying code, you can use this tool to ensure your work aligns with current standards, such as using standalone components, typed forms, and the latest control flow syntax.\n+## Command Options\n \n-*   **Outputs:** The content of the best practices guide.\n+The `mcp` command can be configured with the following options passed as arguments in your IDE's MCP configuration:\n \n-### Search Angular Documentation (`search_documentation`)\n+- `--read-only`: (boolean, default: `false`) Only register tools that do not make changes to the project. Your editor or coding agent may still perform edits.\n+- `--local-only`: (boolean, default: `false`) Only register tools that do not require an internet connection. Your editor or coding agent may still send data over the network.",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2277007335",
        "repo_full_name": "angular/angular",
        "pr_number": 63141,
        "pr_file": "adev/src/content/ai/mcp-server-setup.md",
        "discussion_id": "2277007335",
        "commented_code": "@@ -66,27 +100,35 @@ For these IDEs, create a configuration file and add the following snippet. Note\n }\n ```\n \n-## Available Tools\n-\n-The Angular CLI MCP server provides several tools to assist you in your development workflow. Here's an overview of the available tools:\n-\n-### Get Angular Coding Best Practices Guide (`get_best_practices`)\n-\n-This tool provides a guide on modern Angular coding best practices. Before you start writing or modifying code, you can use this tool to ensure your work aligns with current standards, such as using standalone components, typed forms, and the latest control flow syntax.\n+## Command Options\n \n-*   **Outputs:** The content of the best practices guide.\n+The `mcp` command can be configured with the following options passed as arguments in your IDE's MCP configuration:\n \n-### Search Angular Documentation (`search_documentation`)\n+- `--read-only`: (boolean, default: `false`) Only register tools that do not make changes to the project. Your editor or coding agent may still perform edits.\n+- `--local-only`: (boolean, default: `false`) Only register tools that do not require an internet connection. Your editor or coding agent may still send data over the network.",
        "comment_created_at": "2025-08-14T15:44:14+00:00",
        "comment_author": "jelbourn",
        "comment_body": "Looking at this the second time, I realize would probably be better as a table (flag | type | default | description)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2238577559",
    "pr_number": 62859,
    "pr_file": "adev/src/content/guide/routing/rendering-strategies.md",
    "created_at": "2025-07-29T05:33:23+00:00",
    "commented_code": "+# Rendering strategies in Angular\n+\n+Angular provides flexible rendering strategies that allow you to optimize different parts of your application based on their specific requirements. You can configure rendering strategies at the [route level](guide/routing/define-routes), giving you fine-grained control over how content is delivered to users.\n+\n+This guide takes a progressive approach, starting with Angular's default client-side rendering and building up to more advanced server-side and hybrid strategies.\n+\n+## What are rendering strategies?\n+\n+Rendering strategies determine when and where your Angular application's HTML content is generated. Each strategy offers different trade-offs between initial page load performance, interactivity, SEO capabilities, and server resource usage.\n+\n+Angular supports three primary rendering strategies:\n+\n+- **Client-Side Rendering (CSR)** - Content is rendered entirely in the browser\n+- **Static Site Generation (SSG/Prerendering)** - Content is pre-rendered at build time\n+- **Server-Side Rendering (SSR)** - Content is rendered on the server for each request\n+\n+## Client-Side Rendering (CSR) - The Default\n+\n+**CSR is Angular's default rendering strategy.** When you create a new Angular application with [`ng new`](tools/cli/new), all [routes](guide/routing/define-routes) automatically use client-side rendering without any additional configuration.\n+\n+### How CSR works\n+\n+With your standard `app.routes.ts` file:\n+\n+```typescript\n+import { Routes } from '@angular/router';\n+import { HomeComponent } from './home';\n+import { AboutComponent } from './about';\n+import { ProductListComponent } from './product-list';\n+\n+export const routes: Routes = [\n+  { path: '', component: HomeComponent },\n+  { path: 'about', component: AboutComponent },\n+  { path: 'products', component: ProductListComponent },\n+  { path: '**', redirectTo: '/' }\n+];\n+```\n+\n+All these routes automatically use CSR. Here's what happens:\n+\n+1. The browser downloads the initial HTML shell\n+2. JavaScript bundles are loaded and executed\n+3. Angular bootstraps and renders the application\n+4. The DOM is created and managed entirely on the client\n+5. [Navigation between routes](guide/routing/navigate-to-routes) happens instantly without page reloads\n+\n+### When CSR works well\n+\n+CSR is ideal for:\n+\n+- **Interactive applications** with complex user interfaces\n+- **Real-time applications** that need frequent updates\n+- **Dashboard-style applications** with heavy client-side state\n+- **Single-page applications** where navigation speed is crucial\n+- **Applications where SEO isn't critical** (internal tools, admin panels)\n+\n+### CSR characteristics\n+\n+| Aspect                  | Details                                                |\n+| :---------------------- | :----------------------------------------------------- |\n+| **SEO**                 | Limited - slower indexing, may miss dynamic content |\n+| **Initial load**        | Slower - requires JavaScript download and execution    |\n+| **Interactivity**       | Immediate once loaded                                  |\n+| **Server requirements** | Minimal - only serves static assets                    |\n+| **Caching**             | Excellent for static assets                            |\n+| **Setup complexity**    | None - works out of the box                            |\n+\n+### Deploying CSR applications\n+\n+CSR applications can be deployed to any static hosting service. Configure your `angular.json` for static deployment:\n+\n+```json\n+{\n+  \"projects\": {\n+    \"my-app\": {\n+      \"architect\": {\n+        \"build\": {\n+          \"options\": {\n+            \"outputMode\": \"static\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+## Adding Static Site Generation (SSG)\n+\n+As your application grows, you might want to **improve SEO and performance for static content** like marketing pages, blogs, or documentation. This is where Static Site Generation (SSG) comes in.\n+\n+### Setting up SSG\n+\n+First, add Angular SSR support to your project:\n+\n+```bash\n+ng add @angular/ssr\n+```\n+\n+This command adds the necessary dependencies and creates server-side configuration files.\n+\n+### How SSG works\n+\n+SSG pre-renders HTML content at build time. Angular creates static HTML files during the build process rather than generating pages when users request them.\n+\n+To configure SSG, create an `app.routes.server.ts` file that defines [`ServerRoute`](api/ssr/ServerRoute) configurations:\n+\n+```typescript\n+import { RenderMode, ServerRoute } from '@angular/ssr';\n+\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: '',\n+    renderMode: RenderMode.Prerender, // Homepage as static HTML\n+  },\n+  {\n+    path: 'about',\n+    renderMode: RenderMode.Prerender, // About page as static HTML\n+  },\n+  {\n+    path: 'blog',\n+    renderMode: RenderMode.Prerender, // Blog listing as static HTML\n+  },\n+];\n+```\n+\n+### Building with SSG\n+\n+Generate static files using the [Angular CLI](tools/cli):\n+\n+```bash\n+ng build --prerender\n+```\n+\n+This creates static HTML files for each specified route in your `dist/` folder.\n+\n+### Dynamic routes with SSG\n+\n+For [routes with parameters](guide/routing/define-routes#define-url-paths-with-route-parameters) (like blog posts), use `getPrerenderParams`:\n+\n+```typescript\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: 'blog/:slug',\n+    renderMode: RenderMode.Prerender,\n+    getPrerenderParams: async () => {\n+      // Fetch your blog posts at build time\n+      const posts = await fetch('https://api.myblog.com/posts').then(res => res.json());\n+      return posts.map(post => ({ slug: post.slug }));\n+    },\n+  },\n+];\n+```\n+\n+This generates static HTML files for each blog post: `blog/first-post/index.html`, `blog/second-post/index.html`, etc.\n+\n+### SSG characteristics",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2238577559",
        "repo_full_name": "angular/angular",
        "pr_number": 62859,
        "pr_file": "adev/src/content/guide/routing/rendering-strategies.md",
        "discussion_id": "2238577559",
        "commented_code": "@@ -0,0 +1,558 @@\n+# Rendering strategies in Angular\n+\n+Angular provides flexible rendering strategies that allow you to optimize different parts of your application based on their specific requirements. You can configure rendering strategies at the [route level](guide/routing/define-routes), giving you fine-grained control over how content is delivered to users.\n+\n+This guide takes a progressive approach, starting with Angular's default client-side rendering and building up to more advanced server-side and hybrid strategies.\n+\n+## What are rendering strategies?\n+\n+Rendering strategies determine when and where your Angular application's HTML content is generated. Each strategy offers different trade-offs between initial page load performance, interactivity, SEO capabilities, and server resource usage.\n+\n+Angular supports three primary rendering strategies:\n+\n+- **Client-Side Rendering (CSR)** - Content is rendered entirely in the browser\n+- **Static Site Generation (SSG/Prerendering)** - Content is pre-rendered at build time\n+- **Server-Side Rendering (SSR)** - Content is rendered on the server for each request\n+\n+## Client-Side Rendering (CSR) - The Default\n+\n+**CSR is Angular's default rendering strategy.** When you create a new Angular application with [`ng new`](tools/cli/new), all [routes](guide/routing/define-routes) automatically use client-side rendering without any additional configuration.\n+\n+### How CSR works\n+\n+With your standard `app.routes.ts` file:\n+\n+```typescript\n+import { Routes } from '@angular/router';\n+import { HomeComponent } from './home';\n+import { AboutComponent } from './about';\n+import { ProductListComponent } from './product-list';\n+\n+export const routes: Routes = [\n+  { path: '', component: HomeComponent },\n+  { path: 'about', component: AboutComponent },\n+  { path: 'products', component: ProductListComponent },\n+  { path: '**', redirectTo: '/' }\n+];\n+```\n+\n+All these routes automatically use CSR. Here's what happens:\n+\n+1. The browser downloads the initial HTML shell\n+2. JavaScript bundles are loaded and executed\n+3. Angular bootstraps and renders the application\n+4. The DOM is created and managed entirely on the client\n+5. [Navigation between routes](guide/routing/navigate-to-routes) happens instantly without page reloads\n+\n+### When CSR works well\n+\n+CSR is ideal for:\n+\n+- **Interactive applications** with complex user interfaces\n+- **Real-time applications** that need frequent updates\n+- **Dashboard-style applications** with heavy client-side state\n+- **Single-page applications** where navigation speed is crucial\n+- **Applications where SEO isn't critical** (internal tools, admin panels)\n+\n+### CSR characteristics\n+\n+| Aspect                  | Details                                                |\n+| :---------------------- | :----------------------------------------------------- |\n+| **SEO**                 | Limited - slower indexing, may miss dynamic content |\n+| **Initial load**        | Slower - requires JavaScript download and execution    |\n+| **Interactivity**       | Immediate once loaded                                  |\n+| **Server requirements** | Minimal - only serves static assets                    |\n+| **Caching**             | Excellent for static assets                            |\n+| **Setup complexity**    | None - works out of the box                            |\n+\n+### Deploying CSR applications\n+\n+CSR applications can be deployed to any static hosting service. Configure your `angular.json` for static deployment:\n+\n+```json\n+{\n+  \"projects\": {\n+    \"my-app\": {\n+      \"architect\": {\n+        \"build\": {\n+          \"options\": {\n+            \"outputMode\": \"static\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+## Adding Static Site Generation (SSG)\n+\n+As your application grows, you might want to **improve SEO and performance for static content** like marketing pages, blogs, or documentation. This is where Static Site Generation (SSG) comes in.\n+\n+### Setting up SSG\n+\n+First, add Angular SSR support to your project:\n+\n+```bash\n+ng add @angular/ssr\n+```\n+\n+This command adds the necessary dependencies and creates server-side configuration files.\n+\n+### How SSG works\n+\n+SSG pre-renders HTML content at build time. Angular creates static HTML files during the build process rather than generating pages when users request them.\n+\n+To configure SSG, create an `app.routes.server.ts` file that defines [`ServerRoute`](api/ssr/ServerRoute) configurations:\n+\n+```typescript\n+import { RenderMode, ServerRoute } from '@angular/ssr';\n+\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: '',\n+    renderMode: RenderMode.Prerender, // Homepage as static HTML\n+  },\n+  {\n+    path: 'about',\n+    renderMode: RenderMode.Prerender, // About page as static HTML\n+  },\n+  {\n+    path: 'blog',\n+    renderMode: RenderMode.Prerender, // Blog listing as static HTML\n+  },\n+];\n+```\n+\n+### Building with SSG\n+\n+Generate static files using the [Angular CLI](tools/cli):\n+\n+```bash\n+ng build --prerender\n+```\n+\n+This creates static HTML files for each specified route in your `dist/` folder.\n+\n+### Dynamic routes with SSG\n+\n+For [routes with parameters](guide/routing/define-routes#define-url-paths-with-route-parameters) (like blog posts), use `getPrerenderParams`:\n+\n+```typescript\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: 'blog/:slug',\n+    renderMode: RenderMode.Prerender,\n+    getPrerenderParams: async () => {\n+      // Fetch your blog posts at build time\n+      const posts = await fetch('https://api.myblog.com/posts').then(res => res.json());\n+      return posts.map(post => ({ slug: post.slug }));\n+    },\n+  },\n+];\n+```\n+\n+This generates static HTML files for each blog post: `blog/first-post/index.html`, `blog/second-post/index.html`, etc.\n+\n+### SSG characteristics",
        "comment_created_at": "2025-07-29T05:33:23+00:00",
        "comment_author": "jnizet",
        "comment_body": "A section like the one in CSR starting with \"All these routes automatically use CSR. Here's what happens:\" would be welcome. It's critical, IMHO, to understand that once the initial page is loaded from the server, everything happens like in a CSR application (routing, http requests, etc.)",
        "pr_file_module": null
      }
    ]
  }
]