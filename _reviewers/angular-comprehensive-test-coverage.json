[
  {
    "discussion_id": "2205612845",
    "pr_number": 62630,
    "pr_file": "packages/core/test/acceptance/property_binding_spec.ts",
    "created_at": "2025-07-14T19:03:38+00:00",
    "commented_code": "},\n   );\n \n+  it('should bind ARIA properties to their corresponding attributes', () => {\n+    @Component({\n+      template: '<button [ariaLabel]=\"label\"></button>',",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2205612845",
        "repo_full_name": "angular/angular",
        "pr_number": 62630,
        "pr_file": "packages/core/test/acceptance/property_binding_spec.ts",
        "discussion_id": "2205612845",
        "commented_code": "@@ -129,6 +129,117 @@ describe('property bindings', () => {\n     },\n   );\n \n+  it('should bind ARIA properties to their corresponding attributes', () => {\n+    @Component({\n+      template: '<button [ariaLabel]=\"label\"></button>',",
        "comment_created_at": "2025-07-14T19:03:38+00:00",
        "comment_author": "AndrewKushnir",
        "comment_body": "I think it'd be great to add a few more tests to cover:\n\n- Interpolation within an attribute value, e.g. `aria-label=\"Hello {{ name }}!\"`\n- ARIA names that consist of 2 words, e.g. `aria-errormessage`\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219996532",
    "pr_number": 62630,
    "pr_file": "packages/core/test/acceptance/property_binding_spec.ts",
    "created_at": "2025-07-21T18:51:58+00:00",
    "commented_code": "},\n   );\n \n+  it('should bind ARIA properties to their corresponding attributes', () => {\n+    @Component({\n+      template: '<button [ariaLabel]=\"label\" [ariaHasPopup]=\"hasPopup\"></button>',\n+    })\n+    class MyComp {\n+      label?: string;\n+      hasPopup?: string;\n+    }\n+\n+    const fixture = TestBed.createComponent(MyComp);\n+    const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+    fixture.componentInstance.label = 'Open';\n+    fixture.componentInstance.hasPopup = 'menu';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Open');\n+    expect(button.getAttribute('aria-haspopup')).toBe('menu');\n+\n+    fixture.componentInstance.label = 'Close';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Close');\n+  });\n+\n+  it('should bind interpolated ARIA attributes', () => {\n+    @Component({\n+      template: '<button aria-label=\"{{label}} menu\"></button>',\n+    })\n+    class MyComp {\n+      label?: string;\n+    }\n+\n+    const fixture = TestBed.createComponent(MyComp);\n+    const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+    fixture.componentInstance.label = 'Open';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Open menu');\n+\n+    fixture.componentInstance.label = 'Close';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Close menu');\n+  });\n+\n+  describe('should bind to ARIA attribute names', () => {\n+    it('on HTML elements', () => {\n+      @Component({\n+        template: '<button [aria-label]=\"label\"></button>',\n+      })\n+      class MyComp {\n+        label?: string;\n+      }\n+\n+      const fixture = TestBed.createComponent(MyComp);\n+      const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+      fixture.componentInstance.label = 'Open';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Open');\n+\n+      fixture.componentInstance.label = 'Close';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Close');\n+    });\n+\n+    it('on component elements', () => {\n+      @Component({\n+        selector: 'button[fancy]',\n+      })\n+      class FancyButton {}\n+\n+      @Component({\n+        template: '<button fancy [aria-label]=\"label\"></button>',\n+        imports: [FancyButton],\n+      })\n+      class MyComp {\n+        label?: string;\n+      }\n+\n+      const fixture = TestBed.createComponent(MyComp);\n+      const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+      fixture.componentInstance.label = 'Open';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Open');\n+\n+      fixture.componentInstance.label = 'Close';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Close');\n+    });\n+  });\n+\n+  it(",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2219996532",
        "repo_full_name": "angular/angular",
        "pr_number": 62630,
        "pr_file": "packages/core/test/acceptance/property_binding_spec.ts",
        "discussion_id": "2219996532",
        "commented_code": "@@ -129,6 +129,142 @@ describe('property bindings', () => {\n     },\n   );\n \n+  it('should bind ARIA properties to their corresponding attributes', () => {\n+    @Component({\n+      template: '<button [ariaLabel]=\"label\" [ariaHasPopup]=\"hasPopup\"></button>',\n+    })\n+    class MyComp {\n+      label?: string;\n+      hasPopup?: string;\n+    }\n+\n+    const fixture = TestBed.createComponent(MyComp);\n+    const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+    fixture.componentInstance.label = 'Open';\n+    fixture.componentInstance.hasPopup = 'menu';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Open');\n+    expect(button.getAttribute('aria-haspopup')).toBe('menu');\n+\n+    fixture.componentInstance.label = 'Close';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Close');\n+  });\n+\n+  it('should bind interpolated ARIA attributes', () => {\n+    @Component({\n+      template: '<button aria-label=\"{{label}} menu\"></button>',\n+    })\n+    class MyComp {\n+      label?: string;\n+    }\n+\n+    const fixture = TestBed.createComponent(MyComp);\n+    const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+    fixture.componentInstance.label = 'Open';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Open menu');\n+\n+    fixture.componentInstance.label = 'Close';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Close menu');\n+  });\n+\n+  describe('should bind to ARIA attribute names', () => {\n+    it('on HTML elements', () => {\n+      @Component({\n+        template: '<button [aria-label]=\"label\"></button>',\n+      })\n+      class MyComp {\n+        label?: string;\n+      }\n+\n+      const fixture = TestBed.createComponent(MyComp);\n+      const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+      fixture.componentInstance.label = 'Open';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Open');\n+\n+      fixture.componentInstance.label = 'Close';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Close');\n+    });\n+\n+    it('on component elements', () => {\n+      @Component({\n+        selector: 'button[fancy]',\n+      })\n+      class FancyButton {}\n+\n+      @Component({\n+        template: '<button fancy [aria-label]=\"label\"></button>',\n+        imports: [FancyButton],\n+      })\n+      class MyComp {\n+        label?: string;\n+      }\n+\n+      const fixture = TestBed.createComponent(MyComp);\n+      const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+      fixture.componentInstance.label = 'Open';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Open');\n+\n+      fixture.componentInstance.label = 'Close';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Close');\n+    });\n+  });\n+\n+  it(",
        "comment_created_at": "2025-07-21T18:51:58+00:00",
        "comment_author": "jelbourn",
        "comment_body": "Also add a test case where a component has an input named `ariaLabel`? (no hyphen) ",
        "pr_file_module": null
      },
      {
        "comment_id": "2220467186",
        "repo_full_name": "angular/angular",
        "pr_number": 62630,
        "pr_file": "packages/core/test/acceptance/property_binding_spec.ts",
        "discussion_id": "2219996532",
        "commented_code": "@@ -129,6 +129,142 @@ describe('property bindings', () => {\n     },\n   );\n \n+  it('should bind ARIA properties to their corresponding attributes', () => {\n+    @Component({\n+      template: '<button [ariaLabel]=\"label\" [ariaHasPopup]=\"hasPopup\"></button>',\n+    })\n+    class MyComp {\n+      label?: string;\n+      hasPopup?: string;\n+    }\n+\n+    const fixture = TestBed.createComponent(MyComp);\n+    const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+    fixture.componentInstance.label = 'Open';\n+    fixture.componentInstance.hasPopup = 'menu';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Open');\n+    expect(button.getAttribute('aria-haspopup')).toBe('menu');\n+\n+    fixture.componentInstance.label = 'Close';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Close');\n+  });\n+\n+  it('should bind interpolated ARIA attributes', () => {\n+    @Component({\n+      template: '<button aria-label=\"{{label}} menu\"></button>',\n+    })\n+    class MyComp {\n+      label?: string;\n+    }\n+\n+    const fixture = TestBed.createComponent(MyComp);\n+    const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+    fixture.componentInstance.label = 'Open';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Open menu');\n+\n+    fixture.componentInstance.label = 'Close';\n+    fixture.detectChanges();\n+\n+    expect(button.getAttribute('aria-label')).toBe('Close menu');\n+  });\n+\n+  describe('should bind to ARIA attribute names', () => {\n+    it('on HTML elements', () => {\n+      @Component({\n+        template: '<button [aria-label]=\"label\"></button>',\n+      })\n+      class MyComp {\n+        label?: string;\n+      }\n+\n+      const fixture = TestBed.createComponent(MyComp);\n+      const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+      fixture.componentInstance.label = 'Open';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Open');\n+\n+      fixture.componentInstance.label = 'Close';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Close');\n+    });\n+\n+    it('on component elements', () => {\n+      @Component({\n+        selector: 'button[fancy]',\n+      })\n+      class FancyButton {}\n+\n+      @Component({\n+        template: '<button fancy [aria-label]=\"label\"></button>',\n+        imports: [FancyButton],\n+      })\n+      class MyComp {\n+        label?: string;\n+      }\n+\n+      const fixture = TestBed.createComponent(MyComp);\n+      const button = fixture.debugElement.query(By.css('button')).nativeElement;\n+\n+      fixture.componentInstance.label = 'Open';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Open');\n+\n+      fixture.componentInstance.label = 'Close';\n+      fixture.detectChanges();\n+\n+      expect(button.getAttribute('aria-label')).toBe('Close');\n+    });\n+  });\n+\n+  it(",
        "comment_created_at": "2025-07-21T22:13:57+00:00",
        "comment_author": "leonsenft",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2254777473",
    "pr_number": 62983,
    "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
    "created_at": "2025-08-05T16:21:28+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2254777473",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2254777473",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
        "comment_created_at": "2025-08-05T16:21:28+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "We're missing tests that ensure we remove the unused imports. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2266189986",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2254777473",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
        "comment_created_at": "2025-08-11T09:50:40+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "We're still missing those tests. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2266233736",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2254777473",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
        "comment_created_at": "2025-08-11T10:09:14+00:00",
        "comment_author": "aparzi",
        "comment_body": "I currently have this test case written in the PR: `I currently have this test case written in the pr: should remove NgClass import when no longer needed`\r\nWhat type of test do you prefer to include?",
        "pr_file_module": null
      },
      {
        "comment_id": "2266238180",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2254777473",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
        "comment_created_at": "2025-08-11T10:11:09+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "I'm talking about the standalone `imports` property. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2266542338",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2254777473",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
        "comment_created_at": "2025-08-11T12:23:14+00:00",
        "comment_author": "aparzi",
        "comment_body": "To do this, we should check if there are any directives related to CommonModule. For example:\r\n```\r\nconst commonModuleDirectives = [\r\n'ngClass',\r\n'ngStyle',\r\n'ngIf',\r\n'ngFor',\r\n'ngSwitch',\r\n'ngSwitchCase'\r\n];\r\n```\r\n\r\nIf none of these are present, we could potentially remove the module from the import array. Does that make sense?",
        "pr_file_module": null
      },
      {
        "comment_id": "2266546245",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2254777473",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
        "comment_created_at": "2025-08-11T12:24:49+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "I'd say it's fine to not remove the CommonModule (as it won't trigger the extended diagnostic for unused imports). ",
        "pr_file_module": null
      },
      {
        "comment_id": "2266719571",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2254777473",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'': condition}\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"[]\"></div>`,\n+        after: `<div [class]=\"\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace for multiple conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    await verifyDeclaration({\n+      before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+      after: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+    });\n+  });\n+});\n+\n+describe('migrateSpaceSeparatedKey option', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  it('should split and migrate multiple classes in one key', async () => {\n+    await verifyDeclaration(\n+      {\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      },\n+      {migrateSpaceSeparatedKey: true},\n+    );\n+  });\n+});\n+",
        "comment_created_at": "2025-08-11T13:11:36+00:00",
        "comment_author": "aparzi",
        "comment_body": "I added a new test case for standalone `imports` property",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2255466039",
    "pr_number": 62983,
    "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
    "created_at": "2025-08-05T22:28:30+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2255466039",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2255466039",
        "commented_code": "@@ -0,0 +1,184 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {MigrationConfig, NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });",
        "comment_created_at": "2025-08-05T22:28:30+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "We're missing a test that shows that `ngClass=\"foo\"` is migrated to `class=foo`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2269784053",
    "pr_number": 62983,
    "pr_file": "packages/core/schematics/test/ngclass-to-class-migration.spec.ts",
    "created_at": "2025-08-12T13:05:26+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import {normalize, virtualFs} from '@angular-devkit/core';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing/index.js';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {resolve} from 'path';\n+\n+describe('ngClass migrator', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration(options?: {path?: string; migrateSpaceSeparatedKey?: boolean}) {\n+    return runner.runSchematic('ngclass-to-class', options, tree);\n+  }\n+\n+  const collectionJsonPath = resolve('../collection.json');\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', collectionJsonPath);\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+    initMockFileSystem('Native');\n+    writeFile('/tsconfig.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {t: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}}},\n+      }),\n+    );\n+  });\n+\n+  it('should handle a file that is present in multiple projects', async () => {\n+    writeFile('/tsconfig-2.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {\n+          a: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}},\n+          b: {root: '', architect: {build: {options: {tsConfig: './tsconfig-2.json'}}}},\n+        },\n+      }),\n+    );\n+\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/core';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain('<div [class.admin]=\"isAdmin\">');\n+  });\n+\n+  it('should remove NgClass import when no longer needed', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain('[class.admin]=\"isAdmin\"');\n+    expect(content).not.toContain(\"import {NgClass} from '@angular/common';\");\n+    expect(content).not.toContain('imports:');\n+  });\n+\n+  it('should remove import standalone when no longer needed', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).not.toContain('imports:');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <button id=\"123\"></button>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<button id=\"123\"></button>');\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [class.active]=\"isActive\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class.active]=\"isActive\"></div>');\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class]=\"\"></div>');\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'': condition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class]=\"\"></div>');\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"[]\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class]=\"\"></div>');\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'active': isActive}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class.active]=\"isActive\"></div>');\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+\n+      expect(content).toContain(\n+        `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(\n+        `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate single condition', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div ngClass=\"foo\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div class=\"foo\"></div>`);\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(\n+        `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate keys with extra whitespace for multiple conditions', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(\n+        `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+          <div [ngClass]=\"{'class3': condition3}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+\n+      expect(content).toContain(`\n+          <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+          <div [class.class3]=\"condition3\"></div>\n+      `);\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{foo isActive}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"'class1 class2'\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"dynamicClassObject\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({ template: \\`\n+          <div [ngClass]=\"getClasses()\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1 class2': condition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration({migrateSpaceSeparatedKey: false});\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain(`<div [ngClass]=\"{'class1 class2': condition}\"></div>`);\n+  });\n+});",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2269784053",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/test/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2269784053",
        "commented_code": "@@ -0,0 +1,560 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import {normalize, virtualFs} from '@angular-devkit/core';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing/index.js';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {resolve} from 'path';\n+\n+describe('ngClass migrator', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration(options?: {path?: string; migrateSpaceSeparatedKey?: boolean}) {\n+    return runner.runSchematic('ngclass-to-class', options, tree);\n+  }\n+\n+  const collectionJsonPath = resolve('../collection.json');\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', collectionJsonPath);\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+    initMockFileSystem('Native');\n+    writeFile('/tsconfig.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {t: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}}},\n+      }),\n+    );\n+  });\n+\n+  it('should handle a file that is present in multiple projects', async () => {\n+    writeFile('/tsconfig-2.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {\n+          a: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}},\n+          b: {root: '', architect: {build: {options: {tsConfig: './tsconfig-2.json'}}}},\n+        },\n+      }),\n+    );\n+\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/core';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain('<div [class.admin]=\"isAdmin\">');\n+  });\n+\n+  it('should remove NgClass import when no longer needed', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain('[class.admin]=\"isAdmin\"');\n+    expect(content).not.toContain(\"import {NgClass} from '@angular/common';\");\n+    expect(content).not.toContain('imports:');\n+  });\n+\n+  it('should remove import standalone when no longer needed', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).not.toContain('imports:');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <button id=\"123\"></button>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<button id=\"123\"></button>');\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [class.active]=\"isActive\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class.active]=\"isActive\"></div>');\n+    });\n+\n+    it('should change empty ngClass binding', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class]=\"\"></div>');\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'': condition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class]=\"\"></div>');\n+    });\n+\n+    it('should change ngClass with empty array', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"[]\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class]=\"\"></div>');\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'active': isActive}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain('<div [class.active]=\"isActive\"></div>');\n+    });\n+\n+    it('should migrate a binded object with multiple keys to class bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+\n+      expect(content).toContain(\n+        `<div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate quoted class names for multiple conditions', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(\n+        `<div [class]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate single condition', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div ngClass=\"foo\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div class=\"foo\"></div>`);\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys to [class] binding', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(\n+        `<div [class]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate keys with extra whitespace for multiple conditions', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(\n+        `<div [class]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+      );\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+          <div [ngClass]=\"{'class3': condition3}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+\n+      expect(content).toContain(`\n+          <div [class]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+          <div [class.class3]=\"condition3\"></div>\n+      `);\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{foo isActive}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"'class1 class2'\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"dynamicClassObject\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      writeFile(\n+        '/app.component.ts',\n+        `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({ template: \\`\n+          <div [ngClass]=\"getClasses()\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+      );\n+\n+      await runMigration();\n+\n+      const content = tree.readContent('/app.component.ts');\n+      expect(content).toContain(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+  });\n+\n+  it('should not migrate key separated with space', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'class1 class2': condition}\"></div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration({migrateSpaceSeparatedKey: false});\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain(`<div [ngClass]=\"{'class1 class2': condition}\"></div>`);\n+  });\n+});",
        "comment_created_at": "2025-08-12T13:05:26+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "Can we also have a test that shows that if the import is missing, the migration won't detect `ngClass` as an instance of the directive ? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2280639093",
    "pr_number": 62983,
    "pr_file": "packages/core/schematics/test/ngclass-to-class-migration.spec.ts",
    "created_at": "2025-08-16T23:05:45+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import {normalize, virtualFs} from '@angular-devkit/core';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing/index.js';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {resolve} from 'path';\n+\n+describe('NgClass migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration(options?: {path?: string; migrateSpaceSeparatedKey?: boolean}) {\n+    return runner.runSchematic('ngclass-to-class', options, tree);\n+  }\n+\n+  const collectionJsonPath = resolve('../collection.json');\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', collectionJsonPath);\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+    initMockFileSystem('Native');\n+    writeFile('/tsconfig.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {t: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}}},\n+      }),\n+    );\n+  });\n+\n+  it('should handle a file that is present in multiple projects', async () => {\n+    writeFile('/tsconfig-2.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {\n+          a: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}},\n+          b: {root: '', architect: {build: {options: {tsConfig: './tsconfig-2.json'}}}},\n+        },\n+      }),\n+    );\n+\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain('<div [class.admin]=\"isAdmin\">');\n+  });\n+\n+  it('should remove NgClass import when no longer needed', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2280639093",
        "repo_full_name": "angular/angular",
        "pr_number": 62983,
        "pr_file": "packages/core/schematics/test/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2280639093",
        "commented_code": "@@ -0,0 +1,628 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+import {normalize, virtualFs} from '@angular-devkit/core';\n+import {SchematicTestRunner, UnitTestTree} from '@angular-devkit/schematics/testing/index.js';\n+import {TempScopedNodeJsSyncHost} from '@angular-devkit/core/node/testing';\n+import {HostTree} from '@angular-devkit/schematics';\n+import {resolve} from 'path';\n+\n+describe('NgClass migration', () => {\n+  let runner: SchematicTestRunner;\n+  let host: TempScopedNodeJsSyncHost;\n+  let tree: UnitTestTree;\n+\n+  function writeFile(filePath: string, contents: string) {\n+    host.sync.write(normalize(filePath), virtualFs.stringToFileBuffer(contents));\n+  }\n+\n+  function runMigration(options?: {path?: string; migrateSpaceSeparatedKey?: boolean}) {\n+    return runner.runSchematic('ngclass-to-class', options, tree);\n+  }\n+\n+  const collectionJsonPath = resolve('../collection.json');\n+  beforeEach(() => {\n+    runner = new SchematicTestRunner('test', collectionJsonPath);\n+    host = new TempScopedNodeJsSyncHost();\n+    tree = new UnitTestTree(new HostTree(host));\n+    initMockFileSystem('Native');\n+    writeFile('/tsconfig.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {t: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}}},\n+      }),\n+    );\n+  });\n+\n+  it('should handle a file that is present in multiple projects', async () => {\n+    writeFile('/tsconfig-2.json', '{}');\n+    writeFile(\n+      '/angular.json',\n+      JSON.stringify({\n+        version: 1,\n+        projects: {\n+          a: {root: '', architect: {build: {options: {tsConfig: './tsconfig.json'}}}},\n+          b: {root: '', architect: {build: {options: {tsConfig: './tsconfig-2.json'}}}},\n+        },\n+      }),\n+    );\n+\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],\n+        template: \\`\n+          <div [ngClass]=\"{'admin': isAdmin}\">\n+            <p>it works</p>\n+          </div>\n+        \\` })\n+        export class Cmp {}\n+      `,\n+    );\n+\n+    await runMigration();\n+\n+    const content = tree.readContent('/app.component.ts');\n+\n+    expect(content).toContain('<div [class.admin]=\"isAdmin\">');\n+  });\n+\n+  it('should remove NgClass import when no longer needed', async () => {\n+    writeFile(\n+      '/app.component.ts',\n+      `\n+        import {Component} from '@angular/core';\n+        import {NgClass} from '@angular/common';\n+        @Component({\n+        imports: [NgClass],",
        "comment_created_at": "2025-08-16T23:05:45+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "We're missing test cases for \r\n* when [CommonModule] is imported. \r\n* When we have multiple imports (and thus we don't remove the `imports` prop",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143502190",
    "pr_number": 61971,
    "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
    "created_at": "2025-06-12T19:33:57+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should not change empty ngClass binding', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{}\"></div>`);\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{'': condition}\"></div>`);\n+    });\n+\n+    it('should not change ngClass with empty array', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"[]\"></div>`);\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple class conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class.class1]=\"condition1\" [class.class2]=\"condition2\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class.admin-panel]=\"isAdmin\" [class.user-dense]=\"isDense\"></div>`,\n+      });\n+    });\n+\n+    it('should split and migrate multiple classes in one key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\" [class.class3]=\"anotherCondition\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"anotherCondition\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class.class1]=\"condition1\" [class.class2]=\"condition2\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+\n+    it('should not migrate object with spread syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo: true, ...other}\"></div>`);\n+    });\n+  });\n+});",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2143502190",
        "repo_full_name": "angular/angular",
        "pr_number": 61971,
        "pr_file": "packages/core/schematics/migrations/ngclass-to-class-migration/ngclass-to-class-migration.spec.ts",
        "discussion_id": "2143502190",
        "commented_code": "@@ -0,0 +1,157 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {absoluteFrom} from '@angular/compiler-cli';\n+import {diffText, runTsurgeMigration} from '../../utils/tsurge/testing';\n+import {NgClassMigration} from './ngclass-to-class-migration';\n+import {initMockFileSystem} from '@angular/compiler-cli/src/ngtsc/file_system/testing';\n+\n+describe('ngClass migrator', () => {\n+  beforeEach(() => {\n+    initMockFileSystem('Native');\n+  });\n+\n+  describe('No change cases', () => {\n+    it('should not change static HTML elements', async () => {\n+      await verifyDeclarationNoChange(`<button id=\"123\"></button>`);\n+    });\n+\n+    it('should not change existing [class] bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [class.active]=\"isActive\"></div>`);\n+    });\n+\n+    it('should not change empty ngClass binding', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{}\"></div>`);\n+    });\n+\n+    it('should not change ngClass with empty string key', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{'': condition}\"></div>`);\n+    });\n+\n+    it('should not change ngClass with empty array', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"[]\"></div>`);\n+    });\n+  });\n+\n+  describe('Simple ngClass object migrations', () => {\n+    it('should migrate single condition', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'active': isActive}\"></div>`,\n+        after: `<div [class.active]=\"isActive\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple class conditions', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>`,\n+        after: `<div [class.class1]=\"condition1\" [class.class2]=\"condition2\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate quoted class names', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'admin-panel': isAdmin, 'user-dense': isDense}\"></div>`,\n+        after: `<div [class.admin-panel]=\"isAdmin\" [class.user-dense]=\"isDense\"></div>`,\n+      });\n+    });\n+\n+    it('should split and migrate multiple classes in one key', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Complex and multi-element migrations', () => {\n+    it('should migrate complex object literals with mixed class keys', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'class1 class2': condition, 'class3': anotherCondition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"condition\" [class.class3]=\"anotherCondition\"></div>`,\n+      });\n+    });\n+\n+    it('should trim and migrate keys with extra whitespace', async () => {\n+      await verifyDeclaration({\n+        before: `<div [ngClass]=\"{'  class1  ': condition, 'class2': anotherCondition}\"></div>`,\n+        after: `<div [class.class1]=\"condition\" [class.class2]=\"anotherCondition\"></div>`,\n+      });\n+    });\n+\n+    it('should migrate multiple ngClass bindings across multiple elements', async () => {\n+      await verifyDeclaration({\n+        before: `\n+        <div [ngClass]=\"{'class1': condition1, 'class2': condition2}\"></div>\n+        <div [ngClass]=\"{'class3': condition3}\"></div>`,\n+        after: `\n+        <div [class.class1]=\"condition1\" [class.class2]=\"condition2\"></div>\n+        <div [class.class3]=\"condition3\"></div>`,\n+      });\n+    });\n+  });\n+\n+  describe('Non-migratable and edge cases', () => {\n+    it('should not migrate invalid object literal syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo isActive}\"></div>`);\n+    });\n+\n+    it('should not migrate string literal class list', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"'class1 class2'\"></div>`);\n+    });\n+\n+    it('should not migrate dynamic variable bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"dynamicClassObject\"></div>`);\n+    });\n+\n+    it('should not migrate function call bindings', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"getClasses()\"></div>`);\n+    });\n+\n+    it('should not migrate object with spread syntax', async () => {\n+      await verifyDeclarationNoChange(`<div [ngClass]=\"{foo: true, ...other}\"></div>`);\n+    });\n+  });\n+});",
        "comment_created_at": "2025-06-12T19:33:57+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "Can we also have unit tests that cover the removal of unused `NgClass` imports ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1885114997",
    "pr_number": 59191,
    "pr_file": "packages/compiler-cli/src/ngtsc/typecheck/extended/test/checks/uninvoked_function_in_text_interpolation/uninvoked_function_in_text_interpolation_spec.ts",
    "created_at": "2024-12-14T16:33:59+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import ts from 'typescript';\n+import {runInEachFileSystem} from '../../../../../file_system/testing';\n+import {factory as uninvokedFunctionInTextInterpolationFactory} from '../../../checks/uninvoked_function_in_text_interpolation';\n+import {ErrorCode, ExtendedTemplateDiagnosticName, ngErrorCode} from '../../../../../diagnostics';\n+import {absoluteFrom, getSourceFileOrError} from '../../../../../file_system';\n+import {getClass, setup} from '../../../../testing';\n+import {ExtendedTemplateCheckerImpl} from '../../../src/extended_template_checker';\n+import {getSourceCodeForDiagnostic} from '../../../../../testing';\n+\n+runInEachFileSystem(() => {\n+  describe('UninvokedFunctionInTextInterpolationFactoryCheck', () => {\n+    it('binds the error code to its extended template diagnostic name', () => {\n+      expect(uninvokedFunctionInTextInterpolationFactory.code).toBe(\n+        ErrorCode.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,\n+      );\n+      expect(uninvokedFunctionInTextInterpolationFactory.name).toBe(\n+        ExtendedTemplateDiagnosticName.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,\n+      );\n+    });\n+  });\n+\n+  describe('Uninvoked function in text interpolation compiler check', () => {\n+    it('should not produce a warning when a function is invoked in text interpolation', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+      const {program, templateTypeChecker} = setup([\n+        {\n+          fileName,\n+          templates: {\n+            'TestCmp': `<p> {{ firstName() }} </p>`,\n+          },\n+          source: `\n+          export class TestCmp {\n+            protected firstName() {\n+              return 'Morgan';\n+            }\n+          }`,\n+        },\n+      ]);\n+      const sf = getSourceFileOrError(program, fileName);\n+      const component = getClass(sf, 'TestCmp');\n+      const extendedTemplateChecker = new ExtendedTemplateCheckerImpl(\n+        templateTypeChecker,\n+        program.getTypeChecker(),\n+        [uninvokedFunctionInTextInterpolationFactory],\n+        {},\n+        /* options */\n+      );\n+      const diags = extendedTemplateChecker.getDiagnosticsForComponent(component);\n+      expect(diags.length).toBe(0);\n+    });\n+\n+    it('should produce a warning when a function is not invoked in text interpolation', () => {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "1885114997",
        "repo_full_name": "angular/angular",
        "pr_number": 59191,
        "pr_file": "packages/compiler-cli/src/ngtsc/typecheck/extended/test/checks/uninvoked_function_in_text_interpolation/uninvoked_function_in_text_interpolation_spec.ts",
        "discussion_id": "1885114997",
        "commented_code": "@@ -0,0 +1,92 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import ts from 'typescript';\n+import {runInEachFileSystem} from '../../../../../file_system/testing';\n+import {factory as uninvokedFunctionInTextInterpolationFactory} from '../../../checks/uninvoked_function_in_text_interpolation';\n+import {ErrorCode, ExtendedTemplateDiagnosticName, ngErrorCode} from '../../../../../diagnostics';\n+import {absoluteFrom, getSourceFileOrError} from '../../../../../file_system';\n+import {getClass, setup} from '../../../../testing';\n+import {ExtendedTemplateCheckerImpl} from '../../../src/extended_template_checker';\n+import {getSourceCodeForDiagnostic} from '../../../../../testing';\n+\n+runInEachFileSystem(() => {\n+  describe('UninvokedFunctionInTextInterpolationFactoryCheck', () => {\n+    it('binds the error code to its extended template diagnostic name', () => {\n+      expect(uninvokedFunctionInTextInterpolationFactory.code).toBe(\n+        ErrorCode.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,\n+      );\n+      expect(uninvokedFunctionInTextInterpolationFactory.name).toBe(\n+        ExtendedTemplateDiagnosticName.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,\n+      );\n+    });\n+  });\n+\n+  describe('Uninvoked function in text interpolation compiler check', () => {\n+    it('should not produce a warning when a function is invoked in text interpolation', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+      const {program, templateTypeChecker} = setup([\n+        {\n+          fileName,\n+          templates: {\n+            'TestCmp': `<p> {{ firstName() }} </p>`,\n+          },\n+          source: `\n+          export class TestCmp {\n+            protected firstName() {\n+              return 'Morgan';\n+            }\n+          }`,\n+        },\n+      ]);\n+      const sf = getSourceFileOrError(program, fileName);\n+      const component = getClass(sf, 'TestCmp');\n+      const extendedTemplateChecker = new ExtendedTemplateCheckerImpl(\n+        templateTypeChecker,\n+        program.getTypeChecker(),\n+        [uninvokedFunctionInTextInterpolationFactory],\n+        {},\n+        /* options */\n+      );\n+      const diags = extendedTemplateChecker.getDiagnosticsForComponent(component);\n+      expect(diags.length).toBe(0);\n+    });\n+\n+    it('should produce a warning when a function is not invoked in text interpolation', () => {",
        "comment_created_at": "2024-12-14T16:33:59+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "Could we maybe add a test to cover getters ? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1890913635",
        "repo_full_name": "angular/angular",
        "pr_number": 59191,
        "pr_file": "packages/compiler-cli/src/ngtsc/typecheck/extended/test/checks/uninvoked_function_in_text_interpolation/uninvoked_function_in_text_interpolation_spec.ts",
        "discussion_id": "1885114997",
        "commented_code": "@@ -0,0 +1,92 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import ts from 'typescript';\n+import {runInEachFileSystem} from '../../../../../file_system/testing';\n+import {factory as uninvokedFunctionInTextInterpolationFactory} from '../../../checks/uninvoked_function_in_text_interpolation';\n+import {ErrorCode, ExtendedTemplateDiagnosticName, ngErrorCode} from '../../../../../diagnostics';\n+import {absoluteFrom, getSourceFileOrError} from '../../../../../file_system';\n+import {getClass, setup} from '../../../../testing';\n+import {ExtendedTemplateCheckerImpl} from '../../../src/extended_template_checker';\n+import {getSourceCodeForDiagnostic} from '../../../../../testing';\n+\n+runInEachFileSystem(() => {\n+  describe('UninvokedFunctionInTextInterpolationFactoryCheck', () => {\n+    it('binds the error code to its extended template diagnostic name', () => {\n+      expect(uninvokedFunctionInTextInterpolationFactory.code).toBe(\n+        ErrorCode.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,\n+      );\n+      expect(uninvokedFunctionInTextInterpolationFactory.name).toBe(\n+        ExtendedTemplateDiagnosticName.UNINVOKED_FUNCTION_IN_TEXT_INTERPOLATION,\n+      );\n+    });\n+  });\n+\n+  describe('Uninvoked function in text interpolation compiler check', () => {\n+    it('should not produce a warning when a function is invoked in text interpolation', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+      const {program, templateTypeChecker} = setup([\n+        {\n+          fileName,\n+          templates: {\n+            'TestCmp': `<p> {{ firstName() }} </p>`,\n+          },\n+          source: `\n+          export class TestCmp {\n+            protected firstName() {\n+              return 'Morgan';\n+            }\n+          }`,\n+        },\n+      ]);\n+      const sf = getSourceFileOrError(program, fileName);\n+      const component = getClass(sf, 'TestCmp');\n+      const extendedTemplateChecker = new ExtendedTemplateCheckerImpl(\n+        templateTypeChecker,\n+        program.getTypeChecker(),\n+        [uninvokedFunctionInTextInterpolationFactory],\n+        {},\n+        /* options */\n+      );\n+      const diags = extendedTemplateChecker.getDiagnosticsForComponent(component);\n+      expect(diags.length).toBe(0);\n+    });\n+\n+    it('should produce a warning when a function is not invoked in text interpolation', () => {",
        "comment_created_at": "2024-12-18T22:32:13+00:00",
        "comment_author": "RafaelJCamara",
        "comment_body": "I've added a test to showcase that using a getter wouldn't throw any errors we would find in the \"other\" function invocations. I think it does the job well for now :)\r\n\r\nPlease let me know if you think otherwise.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2258472503",
    "pr_number": 62962,
    "pr_file": "packages/core/test/render3/projected_signal_spec.ts",
    "created_at": "2025-08-06T22:52:04+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {computed, effect, Injector, Signal, signal} from '../../src/core';\n+import {TestBed} from '../../testing';\n+import {ReactiveNode, SIGNAL} from '@angular/core/primitives/signals';\n+import {projectedSignal} from '../../src/render3/reactivity/projected_signal/projected_signal';\n+import {structuralSignal} from '../../src/render3/reactivity/projected_signal/structural_signal';\n+\n+describe('projectedSignal', () => {\n+  it('propagates an update from parent -> child correctly', () => {\n+    const parent = signal({name: 'John'});\n+    const child = projectedSignal(parent, 'name');\n+\n+    parent.set({name: 'Jane'});\n+    expect(child()).toBe('Jane');\n+  });\n+\n+  it('propagates an update from child -> parent correctly', () => {\n+    const parent = signal({name: 'John'});\n+    const child = projectedSignal(parent, 'name');\n+\n+    child.set('Jane');\n+    expect(parent().name).toBe('Jane');\n+  });\n+\n+  it('does not block updates to normal computed children', () => {\n+    const parent = signal({name: 'John'});\n+    const nestedName = projectedSignal(parent, 'name');\n+    const nameLog = log(computed(() => parent().name));\n+    expect(nameLog).toEqual(['John']);\n+\n+    act(() => nestedName.set('Jane'));\n+    expect(nameLog).toEqual(['John', 'Jane']);\n+  });\n+\n+  it('blocks updates to siblings of a parent', () => {\n+    const parent = signal({first: 'John', last: 'Wick'});\n+    const first = projectedSignal(parent, 'first', {debugName: 'first'});\n+    const last = projectedSignal(parent, 'last', {debugName: 'last'});\n+\n+    // Keep `last` live, ensuring it gets dirty notifications.\n+    act(() => log(last));\n+    expect(isDirty(last)).toBeFalse();\n+\n+    // Update first via the nested signal write path.\n+    first.set('James');\n+\n+    // `last` should not become dirty.\n+    expect(isDirty(last)).toBeFalse();\n+  });\n+\n+  it('deeply blocks updates to unaffected parts of the tree', () => {\n+    const parent = signal({name: {first: 'John', last: 'Wick'}, status: 'Retired'});\n+    const name = projectedSignal(parent, 'name', {debugName: 'name'});\n+    const first = projectedSignal(name, 'first', {debugName: 'first'});\n+    const last = projectedSignal(name, 'last', {debugName: 'last'});\n+    const status = projectedSignal(parent, 'status', {debugName: 'status'});\n+\n+    // Keep `last` and `status` live, ensuring they get dirty notifications.\n+    act(() => {\n+      log(last);\n+      log(status);\n+    });\n+    expect(isDirty(last)).toBeFalse();\n+    expect(isDirty(status)).toBeFalse();\n+\n+    // Update `first` via the nested signal write path.\n+    first.set('James');\n+\n+    // `last` and `status` should not become dirty.\n+    expect(isDirty(last)).toBeFalse();\n+    expect(isDirty(status)).toBeFalse();\n+  });\n+\n+  it('updates siblings targeting the same property', () => {\n+    const parent = signal({first: 'John', last: 'Wick'});\n+    const first1 = projectedSignal(parent, 'first', {debugName: 'first1'});\n+    const first2 = projectedSignal(parent, 'first', {debugName: 'first2'});\n+\n+    // Keep `first2` live, ensuring it gets dirty notifications.\n+    act(() => log(first2));\n+    expect(isDirty(first2)).toBeFalse();\n+\n+    // Update first via the nested signal write path.\n+    first1.set('James');\n+\n+    // `first2` should become dirty.\n+    expect(isDirty(first2)).toBeTrue();\n+    expect(first2()).toBe('James');\n+  });\n+\n+  it('blocks updates when the property name is dynamic but stable', () => {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2258472503",
        "repo_full_name": "angular/angular",
        "pr_number": 62962,
        "pr_file": "packages/core/test/render3/projected_signal_spec.ts",
        "discussion_id": "2258472503",
        "commented_code": "@@ -0,0 +1,172 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {computed, effect, Injector, Signal, signal} from '../../src/core';\n+import {TestBed} from '../../testing';\n+import {ReactiveNode, SIGNAL} from '@angular/core/primitives/signals';\n+import {projectedSignal} from '../../src/render3/reactivity/projected_signal/projected_signal';\n+import {structuralSignal} from '../../src/render3/reactivity/projected_signal/structural_signal';\n+\n+describe('projectedSignal', () => {\n+  it('propagates an update from parent -> child correctly', () => {\n+    const parent = signal({name: 'John'});\n+    const child = projectedSignal(parent, 'name');\n+\n+    parent.set({name: 'Jane'});\n+    expect(child()).toBe('Jane');\n+  });\n+\n+  it('propagates an update from child -> parent correctly', () => {\n+    const parent = signal({name: 'John'});\n+    const child = projectedSignal(parent, 'name');\n+\n+    child.set('Jane');\n+    expect(parent().name).toBe('Jane');\n+  });\n+\n+  it('does not block updates to normal computed children', () => {\n+    const parent = signal({name: 'John'});\n+    const nestedName = projectedSignal(parent, 'name');\n+    const nameLog = log(computed(() => parent().name));\n+    expect(nameLog).toEqual(['John']);\n+\n+    act(() => nestedName.set('Jane'));\n+    expect(nameLog).toEqual(['John', 'Jane']);\n+  });\n+\n+  it('blocks updates to siblings of a parent', () => {\n+    const parent = signal({first: 'John', last: 'Wick'});\n+    const first = projectedSignal(parent, 'first', {debugName: 'first'});\n+    const last = projectedSignal(parent, 'last', {debugName: 'last'});\n+\n+    // Keep `last` live, ensuring it gets dirty notifications.\n+    act(() => log(last));\n+    expect(isDirty(last)).toBeFalse();\n+\n+    // Update first via the nested signal write path.\n+    first.set('James');\n+\n+    // `last` should not become dirty.\n+    expect(isDirty(last)).toBeFalse();\n+  });\n+\n+  it('deeply blocks updates to unaffected parts of the tree', () => {\n+    const parent = signal({name: {first: 'John', last: 'Wick'}, status: 'Retired'});\n+    const name = projectedSignal(parent, 'name', {debugName: 'name'});\n+    const first = projectedSignal(name, 'first', {debugName: 'first'});\n+    const last = projectedSignal(name, 'last', {debugName: 'last'});\n+    const status = projectedSignal(parent, 'status', {debugName: 'status'});\n+\n+    // Keep `last` and `status` live, ensuring they get dirty notifications.\n+    act(() => {\n+      log(last);\n+      log(status);\n+    });\n+    expect(isDirty(last)).toBeFalse();\n+    expect(isDirty(status)).toBeFalse();\n+\n+    // Update `first` via the nested signal write path.\n+    first.set('James');\n+\n+    // `last` and `status` should not become dirty.\n+    expect(isDirty(last)).toBeFalse();\n+    expect(isDirty(status)).toBeFalse();\n+  });\n+\n+  it('updates siblings targeting the same property', () => {\n+    const parent = signal({first: 'John', last: 'Wick'});\n+    const first1 = projectedSignal(parent, 'first', {debugName: 'first1'});\n+    const first2 = projectedSignal(parent, 'first', {debugName: 'first2'});\n+\n+    // Keep `first2` live, ensuring it gets dirty notifications.\n+    act(() => log(first2));\n+    expect(isDirty(first2)).toBeFalse();\n+\n+    // Update first via the nested signal write path.\n+    first1.set('James');\n+\n+    // `first2` should become dirty.\n+    expect(isDirty(first2)).toBeTrue();\n+    expect(first2()).toBe('James');\n+  });\n+\n+  it('blocks updates when the property name is dynamic but stable', () => {",
        "comment_created_at": "2025-08-06T22:52:04+00:00",
        "comment_author": "leonsenft",
        "comment_body": "Should we have test cases for a truly dynamic (changing) property name?",
        "pr_file_module": null
      }
    ]
  }
]