[
  {
    "discussion_id": "2236551204",
    "pr_number": 62750,
    "pr_file": "adev/src/content/tutorials/signals/steps/5-managing-async-signals-with-resources-api/README.md",
    "created_at": "2025-07-28T13:45:48+00:00",
    "commented_code": "+# Managing async signals with Resources API\n+\n+Now that you've learned [how to derive state with linked signals](/tutorials/signals/4-deriving-state-with-linked-signals), let's explore how to handle asynchronous data with the Resource API. The Resource API provides a powerful way to manage async operations using signals, with built-in loading states, error handling, and request management.\n+\n+In this activity, you'll learn how to use the `resource()` function to load data asynchronously and how to handle different states of async operations.\n+\n+<hr />\n+\n+Let's build a user profile loader that demonstrates the Resource API in action.\n+\n+<docs-workflow>\n+\n+<docs-step title=\"Import resource function and API\">\n+Add `resource` to your existing imports and import the mock API function.\n+\n+```ts\n+// Add resource to existing imports\n+import {Component, signal, computed, resource} from '@angular/core';\n+// Import mock API function\n+import {loadUser} from './user-api';\n+```\n+\n+</docs-step>\n+\n+<docs-step title=\"Create a resource for user data\">\n+Add a property in the component class that creates a resource to load user data based on a user ID signal.\n+\n+```ts\n+userId = signal(1);\n+\n+userResource = resource({\n+  params: () => ({ id: this.userId() }),\n+  loader: (params) => loadUser(params.params.id)\n+});\n+```\n+\n+</docs-step>\n+\n+<docs-step title=\"Add methods to interact with the resource\">\n+Add methods to change the user ID and reload the resource.\n+\n+```ts\n+loadUser(id: number) {\n+  this.userId.set(id);\n+}\n+\n+reloadUser() {\n+  this.userResource.reload();\n+}\n+```\n+\n+Changing the params signal automatically triggers a reload, or you can manually reload with `reload()`.\n+</docs-step>\n+\n+<docs-step title=\"Create computed signals for resource states\">\n+Add computed signals to access different states of the resource.\n+\n+```ts\n+isLoading = computed(() => this.userResource.status() === 'loading');\n+hasError = computed(() => this.userResource.status() === 'error');\n+userData = computed(() => this.userResource.value());",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2236551204",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/5-managing-async-signals-with-resources-api/README.md",
        "discussion_id": "2236551204",
        "commented_code": "@@ -0,0 +1,107 @@\n+# Managing async signals with Resources API\n+\n+Now that you've learned [how to derive state with linked signals](/tutorials/signals/4-deriving-state-with-linked-signals), let's explore how to handle asynchronous data with the Resource API. The Resource API provides a powerful way to manage async operations using signals, with built-in loading states, error handling, and request management.\n+\n+In this activity, you'll learn how to use the `resource()` function to load data asynchronously and how to handle different states of async operations.\n+\n+<hr />\n+\n+Let's build a user profile loader that demonstrates the Resource API in action.\n+\n+<docs-workflow>\n+\n+<docs-step title=\"Import resource function and API\">\n+Add `resource` to your existing imports and import the mock API function.\n+\n+```ts\n+// Add resource to existing imports\n+import {Component, signal, computed, resource} from '@angular/core';\n+// Import mock API function\n+import {loadUser} from './user-api';\n+```\n+\n+</docs-step>\n+\n+<docs-step title=\"Create a resource for user data\">\n+Add a property in the component class that creates a resource to load user data based on a user ID signal.\n+\n+```ts\n+userId = signal(1);\n+\n+userResource = resource({\n+  params: () => ({ id: this.userId() }),\n+  loader: (params) => loadUser(params.params.id)\n+});\n+```\n+\n+</docs-step>\n+\n+<docs-step title=\"Add methods to interact with the resource\">\n+Add methods to change the user ID and reload the resource.\n+\n+```ts\n+loadUser(id: number) {\n+  this.userId.set(id);\n+}\n+\n+reloadUser() {\n+  this.userResource.reload();\n+}\n+```\n+\n+Changing the params signal automatically triggers a reload, or you can manually reload with `reload()`.\n+</docs-step>\n+\n+<docs-step title=\"Create computed signals for resource states\">\n+Add computed signals to access different states of the resource.\n+\n+```ts\n+isLoading = computed(() => this.userResource.status() === 'loading');\n+hasError = computed(() => this.userResource.status() === 'error');\n+userData = computed(() => this.userResource.value());",
        "comment_created_at": "2025-07-28T13:45:48+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "I'm not sure we should recommend that : \r\n* value() might throw if the resource is in error. \r\n* in the template we can use `userResource.hasValue()` to guard against 1. and also it is a ts type guard that narrows the typing to drop the `undefined`. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2236628444",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/5-managing-async-signals-with-resources-api/README.md",
        "discussion_id": "2236551204",
        "commented_code": "@@ -0,0 +1,107 @@\n+# Managing async signals with Resources API\n+\n+Now that you've learned [how to derive state with linked signals](/tutorials/signals/4-deriving-state-with-linked-signals), let's explore how to handle asynchronous data with the Resource API. The Resource API provides a powerful way to manage async operations using signals, with built-in loading states, error handling, and request management.\n+\n+In this activity, you'll learn how to use the `resource()` function to load data asynchronously and how to handle different states of async operations.\n+\n+<hr />\n+\n+Let's build a user profile loader that demonstrates the Resource API in action.\n+\n+<docs-workflow>\n+\n+<docs-step title=\"Import resource function and API\">\n+Add `resource` to your existing imports and import the mock API function.\n+\n+```ts\n+// Add resource to existing imports\n+import {Component, signal, computed, resource} from '@angular/core';\n+// Import mock API function\n+import {loadUser} from './user-api';\n+```\n+\n+</docs-step>\n+\n+<docs-step title=\"Create a resource for user data\">\n+Add a property in the component class that creates a resource to load user data based on a user ID signal.\n+\n+```ts\n+userId = signal(1);\n+\n+userResource = resource({\n+  params: () => ({ id: this.userId() }),\n+  loader: (params) => loadUser(params.params.id)\n+});\n+```\n+\n+</docs-step>\n+\n+<docs-step title=\"Add methods to interact with the resource\">\n+Add methods to change the user ID and reload the resource.\n+\n+```ts\n+loadUser(id: number) {\n+  this.userId.set(id);\n+}\n+\n+reloadUser() {\n+  this.userResource.reload();\n+}\n+```\n+\n+Changing the params signal automatically triggers a reload, or you can manually reload with `reload()`.\n+</docs-step>\n+\n+<docs-step title=\"Create computed signals for resource states\">\n+Add computed signals to access different states of the resource.\n+\n+```ts\n+isLoading = computed(() => this.userResource.status() === 'loading');\n+hasError = computed(() => this.userResource.status() === 'error');\n+userData = computed(() => this.userResource.value());",
        "comment_created_at": "2025-07-28T14:03:50+00:00",
        "comment_author": "bencodezen",
        "comment_body": "That's totally fair. I've updated the tutorial accordingly!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219828693",
    "pr_number": 62708,
    "pr_file": "adev/src/content/guide/signals/resource.md",
    "created_at": "2025-07-21T17:31:40+00:00",
    "commented_code": "});\n \n // Create a computed signal based on the result of the resource's loader function.\n-const firstName = computed(() => userResource.value().firstName);\n+const firstName = computed(() => {\n+  if(useResource.hasValue()) {\n+    // value() can throw if the resource loading resulted in an error\n+    return userResource.value().firstName\n+  }\n+\n+  return undefined // fallback in case of resource error",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2219828693",
        "repo_full_name": "angular/angular",
        "pr_number": 62708,
        "pr_file": "adev/src/content/guide/signals/resource.md",
        "discussion_id": "2219828693",
        "commented_code": "@@ -24,7 +24,14 @@ const userResource = resource({\n });\n \n // Create a computed signal based on the result of the resource's loader function.\n-const firstName = computed(() => userResource.value().firstName);\n+const firstName = computed(() => {\n+  if(useResource.hasValue()) {\n+    // value() can throw if the resource loading resulted in an error\n+    return userResource.value().firstName\n+  }\n+\n+  return undefined // fallback in case of resource error",
        "comment_created_at": "2025-07-21T17:31:40+00:00",
        "comment_author": "atscott",
        "comment_body": "```suggestion\r\n    return userResource.value().firstName;\r\n  }\r\n\r\n  return undefined; // fallback in case of resource error\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219829733",
    "pr_number": 62708,
    "pr_file": "adev/src/content/guide/signals/resource.md",
    "created_at": "2025-07-21T17:32:18+00:00",
    "commented_code": "});\n \n // Create a computed signal based on the result of the resource's loader function.\n-const firstName = computed(() => userResource.value().firstName);\n+const firstName = computed(() => {\n+  if(useResource.hasValue()) {\n+    // value() can throw if the resource loading resulted in an error\n+    return userResource.value().firstName\n+  }\n+\n+  return undefined // fallback in case of resource error",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2219829733",
        "repo_full_name": "angular/angular",
        "pr_number": 62708,
        "pr_file": "adev/src/content/guide/signals/resource.md",
        "discussion_id": "2219829733",
        "commented_code": "@@ -24,7 +24,14 @@ const userResource = resource({\n });\n \n // Create a computed signal based on the result of the resource's loader function.\n-const firstName = computed(() => userResource.value().firstName);\n+const firstName = computed(() => {\n+  if(useResource.hasValue()) {\n+    // value() can throw if the resource loading resulted in an error\n+    return userResource.value().firstName\n+  }\n+\n+  return undefined // fallback in case of resource error",
        "comment_created_at": "2025-07-21T17:32:18+00:00",
        "comment_author": "atscott",
        "comment_body": "Why not `hasError` above if this is protecting against errors?",
        "pr_file_module": null
      },
      {
        "comment_id": "2223993220",
        "repo_full_name": "angular/angular",
        "pr_number": 62708,
        "pr_file": "adev/src/content/guide/signals/resource.md",
        "discussion_id": "2219829733",
        "commented_code": "@@ -24,7 +24,14 @@ const userResource = resource({\n });\n \n // Create a computed signal based on the result of the resource's loader function.\n-const firstName = computed(() => userResource.value().firstName);\n+const firstName = computed(() => {\n+  if(useResource.hasValue()) {\n+    // value() can throw if the resource loading resulted in an error\n+    return userResource.value().firstName\n+  }\n+\n+  return undefined // fallback in case of resource error",
        "comment_created_at": "2025-07-22T23:12:01+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "`hasValue()` also acts as a type guard and strips the `undefined` (which is part of the default value). ",
        "pr_file_module": null
      },
      {
        "comment_id": "2224010652",
        "repo_full_name": "angular/angular",
        "pr_number": 62708,
        "pr_file": "adev/src/content/guide/signals/resource.md",
        "discussion_id": "2219829733",
        "commented_code": "@@ -24,7 +24,14 @@ const userResource = resource({\n });\n \n // Create a computed signal based on the result of the resource's loader function.\n-const firstName = computed(() => userResource.value().firstName);\n+const firstName = computed(() => {\n+  if(useResource.hasValue()) {\n+    // value() can throw if the resource loading resulted in an error\n+    return userResource.value().firstName\n+  }\n+\n+  return undefined // fallback in case of resource error",
        "comment_created_at": "2025-07-22T23:30:41+00:00",
        "comment_author": "atscott",
        "comment_body": "Can you update the comment then to indicate it's not just an error fallback?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195519939",
    "pr_number": 62250,
    "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
    "created_at": "2025-07-09T17:02:43+00:00",
    "commented_code": "+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInputBinding\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(App, {\n+  providers: [\n+    provideRouter(routes, withComponentInputBinding())\n+  ]\n+});\n+```\n+\n+With this configuration, you can define inputs in your component that match the resolver keys using the [`input`](api/core/input) function and [`input.required`](api/core/input#required) for required inputs:\n+\n+```angular-ts\n+import { Component, input } from '@angular/core';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2195519939",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195519939",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInputBinding\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(App, {\n+  providers: [\n+    provideRouter(routes, withComponentInputBinding())\n+  ]\n+});\n+```\n+\n+With this configuration, you can define inputs in your component that match the resolver keys using the [`input`](api/core/input) function and [`input.required`](api/core/input#required) for required inputs:\n+\n+```angular-ts\n+import { Component, input } from '@angular/core';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>",
        "comment_created_at": "2025-07-09T17:02:43+00:00",
        "comment_author": "atscott",
        "comment_body": "If settings isn't `.required`, this could be `undefined` and should be `settings()?.theme`. Likely it should just be made required, otherwise you have to manually handle `undefined` being set by the Router anyways  if it's not present.",
        "pr_file_module": null
      },
      {
        "comment_id": "2195715446",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195519939",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInputBinding\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(App, {\n+  providers: [\n+    provideRouter(routes, withComponentInputBinding())\n+  ]\n+});\n+```\n+\n+With this configuration, you can define inputs in your component that match the resolver keys using the [`input`](api/core/input) function and [`input.required`](api/core/input#required) for required inputs:\n+\n+```angular-ts\n+import { Component, input } from '@angular/core';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>",
        "comment_created_at": "2025-07-09T18:28:30+00:00",
        "comment_author": "bencodezen",
        "comment_body": "Excellent point!",
        "pr_file_module": null
      }
    ]
  }
]