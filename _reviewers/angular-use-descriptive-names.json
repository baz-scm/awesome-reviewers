[
  {
    "discussion_id": "2252652297",
    "pr_number": 62750,
    "pr_file": "adev/src/content/tutorials/signals/steps/7-using-signals-with-services/answer/src/app/cart-service.ts",
    "created_at": "2025-08-04T21:55:01+00:00",
    "commented_code": "+import {Injectable, signal, computed} from '@angular/core';\n+import {CartItem} from './cart-types';\n+\n+@Injectable({\n+  providedIn: 'root',\n+})\n+export class CartService {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2252652297",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/7-using-signals-with-services/answer/src/app/cart-service.ts",
        "discussion_id": "2252652297",
        "commented_code": "@@ -0,0 +1,54 @@\n+import {Injectable, signal, computed} from '@angular/core';\n+import {CartItem} from './cart-types';\n+\n+@Injectable({\n+  providedIn: 'root',\n+})\n+export class CartService {",
        "comment_created_at": "2025-08-04T21:55:01+00:00",
        "comment_author": "jelbourn",
        "comment_body": "nit: just `Cart`? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2255243382",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/7-using-signals-with-services/answer/src/app/cart-service.ts",
        "discussion_id": "2252652297",
        "commented_code": "@@ -0,0 +1,54 @@\n+import {Injectable, signal, computed} from '@angular/core';\n+import {CartItem} from './cart-types';\n+\n+@Injectable({\n+  providedIn: 'root',\n+})\n+export class CartService {",
        "comment_created_at": "2025-08-05T20:12:19+00:00",
        "comment_author": "bencodezen",
        "comment_body": "Ah rats this one escaped me. It's such a habit for me to do this since I saw / see it in so many codebases, but would `CartApi` be acceptable instead?\r\n\r\n(Side note: curious what your thoughts are on one word file names)",
        "pr_file_module": null
      },
      {
        "comment_id": "2317184404",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/7-using-signals-with-services/answer/src/app/cart-service.ts",
        "discussion_id": "2252652297",
        "commented_code": "@@ -0,0 +1,54 @@\n+import {Injectable, signal, computed} from '@angular/core';\n+import {CartItem} from './cart-types';\n+\n+@Injectable({\n+  providedIn: 'root',\n+})\n+export class CartService {",
        "comment_created_at": "2025-09-02T21:11:21+00:00",
        "comment_author": "jelbourn",
        "comment_body": "IMO `Api` doesn't really tell you anything- everything is an API. If you wanted another noun in there, I could see something like `CartStore` or `CartSession`. But for a tutorial I think there's nothing wrong with just `Cart`.\r\n\r\nI have no problems with single word file names. My naming philosophy in general would be to choose the shortest name that unambiguously and meaningfully describes a thing. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2237540547",
    "pr_number": 62845,
    "pr_file": "packages/forms/experimental/src/api/validators/standard_schema.ts",
    "created_at": "2025-07-28T18:38:30+00:00",
    "commented_code": "*/\n \n import {computed, resource, \u0275isPromise} from '@angular/core';\n-import {validateAsync} from './async';\n-import {property, validateTree} from './logic';\n import type {StandardSchemaV1} from '@standard-schema/spec';\n-import {Field, FieldPath} from './types';\n-import {StandardSchemaValidationError, ValidationError, WithField} from './validation_errors';\n+import {validateAsync} from '../async';\n+import {property, validateTree} from '../logic';\n+import {Field, FieldPath} from '../types';\n+import {StandardSchemaValidationError, ValidationError, WithField} from '../validation_errors';\n \n /**\n- * Validates a field using a `StandardSchemaV1` compatible validator (e.g. a zod validator).\n+ * Utility type that removes `{[key: string]: unknown}` from a given type, recursively.\n+ * We strip this out of the `TSchema` type in `validateStandardSchema` in order to accomodate Zod's\n+ * `looseObject` which includes `{[key: string]: unknown}` as part of the type.\n+ */\n+export type DeepStripStringIndexUnknown<T> =\n+  T extends Record<PropertyKey, unknown>\n+    ? {\n+        [K in keyof T as string extends K\n+          ? unknown extends T[K]\n+            ? never\n+            : K\n+          : K]: DeepStripStringIndexUnknown<T[K]>;\n+      }\n+    : T;",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2237540547",
        "repo_full_name": "angular/angular",
        "pr_number": 62845,
        "pr_file": "packages/forms/experimental/src/api/validators/standard_schema.ts",
        "discussion_id": "2237540547",
        "commented_code": "@@ -7,25 +7,42 @@\n  */\n \n import {computed, resource, \u0275isPromise} from '@angular/core';\n-import {validateAsync} from './async';\n-import {property, validateTree} from './logic';\n import type {StandardSchemaV1} from '@standard-schema/spec';\n-import {Field, FieldPath} from './types';\n-import {StandardSchemaValidationError, ValidationError, WithField} from './validation_errors';\n+import {validateAsync} from '../async';\n+import {property, validateTree} from '../logic';\n+import {Field, FieldPath} from '../types';\n+import {StandardSchemaValidationError, ValidationError, WithField} from '../validation_errors';\n \n /**\n- * Validates a field using a `StandardSchemaV1` compatible validator (e.g. a zod validator).\n+ * Utility type that removes `{[key: string]: unknown}` from a given type, recursively.\n+ * We strip this out of the `TSchema` type in `validateStandardSchema` in order to accomodate Zod's\n+ * `looseObject` which includes `{[key: string]: unknown}` as part of the type.\n+ */\n+export type DeepStripStringIndexUnknown<T> =\n+  T extends Record<PropertyKey, unknown>\n+    ? {\n+        [K in keyof T as string extends K\n+          ? unknown extends T[K]\n+            ? never\n+            : K\n+          : K]: DeepStripStringIndexUnknown<T[K]>;\n+      }\n+    : T;",
        "comment_created_at": "2025-07-28T18:38:30+00:00",
        "comment_author": "leonsenft",
        "comment_body": "Not sure if this is obvious to more veteran TypeScript developers, but I took a minute to understand this type. It might help to split the filtering out into a subtype. Also, naming this type something a little more contextual rather than purely technical:\n\n```ts\ntype FilteredKey<K, V> =\n  string extends K\n    ? unknown extends V\n      ? never\n      : K\n    : K;\n\nexport type IgnoreUnknownProps<T> =\n  T extends Record<PropertyKey, unknown>\n    ? {\n        [K in keyof T as FilteredKey<K, T[K]>]: IgnoreUnknownProps<T[K]>;\n      }\n    : T;\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2238050045",
        "repo_full_name": "angular/angular",
        "pr_number": 62845,
        "pr_file": "packages/forms/experimental/src/api/validators/standard_schema.ts",
        "discussion_id": "2237540547",
        "commented_code": "@@ -7,25 +7,42 @@\n  */\n \n import {computed, resource, \u0275isPromise} from '@angular/core';\n-import {validateAsync} from './async';\n-import {property, validateTree} from './logic';\n import type {StandardSchemaV1} from '@standard-schema/spec';\n-import {Field, FieldPath} from './types';\n-import {StandardSchemaValidationError, ValidationError, WithField} from './validation_errors';\n+import {validateAsync} from '../async';\n+import {property, validateTree} from '../logic';\n+import {Field, FieldPath} from '../types';\n+import {StandardSchemaValidationError, ValidationError, WithField} from '../validation_errors';\n \n /**\n- * Validates a field using a `StandardSchemaV1` compatible validator (e.g. a zod validator).\n+ * Utility type that removes `{[key: string]: unknown}` from a given type, recursively.\n+ * We strip this out of the `TSchema` type in `validateStandardSchema` in order to accomodate Zod's\n+ * `looseObject` which includes `{[key: string]: unknown}` as part of the type.\n+ */\n+export type DeepStripStringIndexUnknown<T> =\n+  T extends Record<PropertyKey, unknown>\n+    ? {\n+        [K in keyof T as string extends K\n+          ? unknown extends T[K]\n+            ? never\n+            : K\n+          : K]: DeepStripStringIndexUnknown<T[K]>;\n+      }\n+    : T;",
        "comment_created_at": "2025-07-29T00:00:39+00:00",
        "comment_author": "mmalerba",
        "comment_body": "Its not just you, this type is fairly complex. Breaking it out seems like a good idea, although `FilteredKey` sounds way too generic for what that type is doing. I think it makes sense to give the type people will see in their intelisense a more intuitive name like `IgnoreUnknownProps` and then we can give `FilteredKey` a more precise name since the user doesn't really see it anyways.\r\n\r\nOne thing I wish we had in the framework somewhere is like a collection of common type utilities. I'm not sure these particular ones feel generic enough for that anyways, but I do feel like I frequently find myself writing some utility type and thinking \"someone must have had to do this already somewhere else in the framework\"\r\n\r\nAnyways, updated it and added a little more explanation in the comments",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214467950",
    "pr_number": 62682,
    "pr_file": "packages/core/src/animation.ts",
    "created_at": "2025-07-17T23:09:35+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const ANIMATION_TIMEOUT = 4000;",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2214467950",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/animation.ts",
        "discussion_id": "2214467950",
        "commented_code": "@@ -0,0 +1,137 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const ANIMATION_TIMEOUT = 4000;",
        "comment_created_at": "2025-07-17T23:09:35+00:00",
        "comment_author": "AndrewKushnir",
        "comment_body": "nit: more descriptive const name:\n```suggestion\nconst MAX_ANIMATION_DURATION = 4000;\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218507455",
    "pr_number": 62682,
    "pr_file": "packages/core/src/animation.ts",
    "created_at": "2025-07-21T08:25:02+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const MAX_ANIMATION_TIMEOUT = 4000;\n+\n+/**\n+ * The function type for `animate.enter` and `animate.leave` when they are used with\n+ * function callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationFunction = (event: AnimationCallbackEvent) => void;\n+\n+export type AnimationEventFunction = (\n+  el: Element,\n+  value: AnimationFunction,\n+) => AnimationRemoveFunction;\n+export type AnimationClassFunction = (\n+  el: Element,\n+  value: Set<string> | null,\n+  resolvers: Function[] | undefined,\n+) => AnimationRemoveFunction;\n+export type AnimationRemoveFunction = (removeFn: VoidFunction) => void;\n+\n+export interface LongestAnimation {\n+  animationName: string | undefined;\n+  propertyName: string | undefined;\n+  duration: number;\n+}\n+\n+export interface AnimationDetails {\n+  classes: Set<string> | null;\n+  classFns?: Function[];\n+  animateFn: AnimationRemoveFunction;\n+}\n+\n+/**\n+ * Registers elements for delayed removal action for animation in the case\n+ * that `animate.leave` is used. This stores the target element and any\n+ * classes, class resolvers, and callback functions that may be needed\n+ * to apply the removal animation, and then stashes the actual element\n+ * removal function from the dom renderer to be called after the\n+ * animation is finished.\n+ */\n+@Injectable({providedIn: 'root'})\n+export class ElementRegistry {\n+  private outElements = new WeakMap<Element, AnimationDetails>();\n+\n+  remove(el: Element): void {\n+    this.outElements.delete(el);\n+  }\n+\n+  /** Used when animate.leave is only applying classes */\n+  addClasses(details: AnimationDetails, classes: string | string[]): void {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2218507455",
        "repo_full_name": "angular/angular",
        "pr_number": 62682,
        "pr_file": "packages/core/src/animation.ts",
        "discussion_id": "2218507455",
        "commented_code": "@@ -0,0 +1,152 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {Injectable} from './di';\n+\n+/**\n+ * The event type for when `animate.enter` and `animate.leave` are used with function\n+ * callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationCallbackEvent = {target: Element; animationComplete: Function};\n+\n+/**\n+ * Animation removal functions have a four second long maximum duration timeout.\n+ * This value mirrors from Chrome's cross document navigation view transition timeout.\n+ * It's intended to prevent people from accidentally forgetting to call the removal\n+ * function in their callback.\n+ */\n+const MAX_ANIMATION_TIMEOUT = 4000;\n+\n+/**\n+ * The function type for `animate.enter` and `animate.leave` when they are used with\n+ * function callbacks.\n+ *\n+ * @publicApi 20.2\n+ */\n+export type AnimationFunction = (event: AnimationCallbackEvent) => void;\n+\n+export type AnimationEventFunction = (\n+  el: Element,\n+  value: AnimationFunction,\n+) => AnimationRemoveFunction;\n+export type AnimationClassFunction = (\n+  el: Element,\n+  value: Set<string> | null,\n+  resolvers: Function[] | undefined,\n+) => AnimationRemoveFunction;\n+export type AnimationRemoveFunction = (removeFn: VoidFunction) => void;\n+\n+export interface LongestAnimation {\n+  animationName: string | undefined;\n+  propertyName: string | undefined;\n+  duration: number;\n+}\n+\n+export interface AnimationDetails {\n+  classes: Set<string> | null;\n+  classFns?: Function[];\n+  animateFn: AnimationRemoveFunction;\n+}\n+\n+/**\n+ * Registers elements for delayed removal action for animation in the case\n+ * that `animate.leave` is used. This stores the target element and any\n+ * classes, class resolvers, and callback functions that may be needed\n+ * to apply the removal animation, and then stashes the actual element\n+ * removal function from the dom renderer to be called after the\n+ * animation is finished.\n+ */\n+@Injectable({providedIn: 'root'})\n+export class ElementRegistry {\n+  private outElements = new WeakMap<Element, AnimationDetails>();\n+\n+  remove(el: Element): void {\n+    this.outElements.delete(el);\n+  }\n+\n+  /** Used when animate.leave is only applying classes */\n+  addClasses(details: AnimationDetails, classes: string | string[]): void {",
        "comment_created_at": "2025-07-21T08:25:02+00:00",
        "comment_author": "crisbeto",
        "comment_body": "nit: maybe something like `trackClasses` would be more descriptive here? `addClasses` made me think that it's actually adding the classes to the DOM.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217935026",
    "pr_number": 62713,
    "pr_file": "packages/forms/experimental/test/node/resource.spec.ts",
    "created_at": "2025-07-20T19:48:34+00:00",
    "commented_code": "it('Takes a simple resource which reacts to data changes', async () => {\n     const s: SchemaOrSchemaFn<Cat> = function (p) {\n-      const res = define(p.name, ({value}) => {\n+      const RES = MetadataKey.create<Resource<string | undefined>>();\n+      const res = setMetadata(p.name, RES, ({value}) => {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2217935026",
        "repo_full_name": "angular/angular",
        "pr_number": 62713,
        "pr_file": "packages/forms/experimental/test/node/resource.spec.ts",
        "discussion_id": "2217935026",
        "commented_code": "@@ -48,17 +49,18 @@ describe('resources', () => {\n \n   it('Takes a simple resource which reacts to data changes', async () => {\n     const s: SchemaOrSchemaFn<Cat> = function (p) {\n-      const res = define(p.name, ({value}) => {\n+      const RES = MetadataKey.create<Resource<string | undefined>>();\n+      const res = setMetadata(p.name, RES, ({value}) => {",
        "comment_created_at": "2025-07-20T19:48:34+00:00",
        "comment_author": "michael-small",
        "comment_body": "```suggestion\r\n      setMetadata(p.name, RES, ({value}) => {\r\n```\r\nNoticed this while running locally and having confusion of `RES` vs `res`.\r\n\r\nAlso throwing in my 2 cents while I am at this:\r\n\r\n1. `metadata` > `property`. While both are generic sounding (but are fit for the \"meta\" nature of this), `property` is so much more generic. I can imagine saying \"check the property property\" out loud to someone and seeing the confusion. `metadata` seems more descriptive.\r\n2. `setMetadata` seems straight forward for `Metadatakey`. `addtoMetadata` seems like the progression beyond that for aggregates.\r\n3. I agree that the current `MetadataKey.create<...>()` is \"bleh\". Maybe the `define` type syntax would be better? I looked at a lot of before/after code for metadata and how `define` was used and it seems that there is a decent case for either. As for the typing, the other metadata related syntax that follows seems to make the type obvious. And if I am understanding the purpose of the metadata API, I wouldn't think it would be so common that people would yolo typing? This is mostly from only seeing it used as-is now mostly in existing validators/schema for the framework code, and the one use of `define` outside of that in the v2 doc. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2219520745",
        "repo_full_name": "angular/angular",
        "pr_number": 62713,
        "pr_file": "packages/forms/experimental/test/node/resource.spec.ts",
        "discussion_id": "2217935026",
        "commented_code": "@@ -48,17 +49,18 @@ describe('resources', () => {\n \n   it('Takes a simple resource which reacts to data changes', async () => {\n     const s: SchemaOrSchemaFn<Cat> = function (p) {\n-      const res = define(p.name, ({value}) => {\n+      const RES = MetadataKey.create<Resource<string | undefined>>();\n+      const res = setMetadata(p.name, RES, ({value}) => {",
        "comment_created_at": "2025-07-21T15:17:09+00:00",
        "comment_author": "mmalerba",
        "comment_body": "1. Noted. We'd probably refer to `FieldState.property` as the field's custom properties in documentation if we decide to go with the property naming, which might help a little. I definitely do see your point though\r\n2. Noted\r\n3. The two main use cases for metadata are: 1) I want to expose some data from the schema on the form 2) I want to share some data between multiple logic binding rules within my schema. Some examples would be things like: having schema define labels/placeholders to bind in the UI, custom validators that metadata (e.g. to gray out dates outside of an allowed range), creating computeds/resources that are used within the schema. It probably won't be the *most* used rule, but I expect to see it around",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2264627515",
    "pr_number": 63068,
    "pr_file": "packages/forms/experimental/src/api/control.ts",
    "created_at": "2025-08-09T09:21:25+00:00",
    "commented_code": "import {InputSignal, ModelSignal, OutputRef} from '@angular/core';\n import {ValidationError} from './validation_errors';\n \n-export interface BaseUiControl {\n+/** The base set of properties shared by all form control contracts. */\n+export interface FormUiControl {\n+  /**\n+   * An input to receive the errors for the field. If implemented, the `Control` directive will\n+   * automatically bind errors from the bound field to this input.\n+   */\n   readonly errors?: InputSignal<readonly ValidationError[] | undefined>;\n+  // TODO: should we have an input for binding disabled reason?\n+  /**\n+   * An input to receive the disabled status for the field. If implemented, the `Control` directive\n+   * will automatically bind the disabled status from the bound field to this input.\n+   */\n   readonly disabled?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the readonly status for the field. If implemented, the `Control` directive\n+   * will automatically bind the readonly status from the bound field to this input.\n+   */\n   readonly readonly?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the hidden status for the field. If implemented, the `Control` directive\n+   * will automatically bind the hidden status from the bound field to this input.\n+   */\n+  readonly hidden?: InputSignal<boolean | undefined>;\n+  // TODO: what do we do about the whole valid != invalid thing?\n+  // Should we bind both of them? neither? treat valid+pending as valid? some kind of combined tri-/quad-state?\n+  // Should we allow binding in the pending state?\n+  /**\n+   * An input to receive the valid status for the field. If implemented, the `Control` directive\n+   * will automatically bind the valid status from the bound field to this input.\n+   */\n   readonly valid?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the touched status for the field. If implemented, the `Control` directive\n+   * will automatically bind the touched status from the bound field to this input.\n+   */\n   readonly touched?: InputSignal<boolean | undefined>;\n-  readonly name?: InputSignal<string>;\n-\n-  readonly touch?: OutputRef<void>;\n-\n+  /**\n+   * An input to receive the dirty status for the field. If implemented, the `Control` directive\n+   * will automatically bind the dirty status from the bound field to this input.\n+   */\n+  readonly dirty?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the name for the field. If implemented, the `Control` directive will\n+   * automatically bind the name from the bound field to this input.\n+   */\n+  readonly name?: InputSignal<string | undefined>;\n+  /**\n+   * An input to receive the required status for the field. If implemented, the `Control` directive\n+   * will automatically bind the required status from the bound field to this input.\n+   */\n+  readonly required?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the min value for the field. If implemented, the `Control` directive will\n+   * automatically bind the min value from the bound field to this input.\n+   */\n   readonly min?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the min length for the field. If implemented, the `Control` directive will\n+   * automatically bind the min length from the bound field to this input.\n+   */\n   readonly minLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max value for the field. If implemented, the `Control` directive will\n+   * automatically bind the max value from the bound field to this input.\n+   */\n   readonly max?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max length for the field. If implemented, the `Control` directive will\n+   * automatically bind the max length from the bound field to this input.\n+   */\n   readonly maxLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the value patterns for the field. If implemented, the `Control` directive\n+   * will automatically bind the value patterns from the bound field to this input.\n+   */\n+  readonly pattern?: InputSignal<readonly RegExp[] | undefined>;\n+  // TODO: what should we name this output? `touch` feels weird. The rest of the inputs here are",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2264627515",
        "repo_full_name": "angular/angular",
        "pr_number": 63068,
        "pr_file": "packages/forms/experimental/src/api/control.ts",
        "discussion_id": "2264627515",
        "commented_code": "@@ -9,31 +9,148 @@\n import {InputSignal, ModelSignal, OutputRef} from '@angular/core';\n import {ValidationError} from './validation_errors';\n \n-export interface BaseUiControl {\n+/** The base set of properties shared by all form control contracts. */\n+export interface FormUiControl {\n+  /**\n+   * An input to receive the errors for the field. If implemented, the `Control` directive will\n+   * automatically bind errors from the bound field to this input.\n+   */\n   readonly errors?: InputSignal<readonly ValidationError[] | undefined>;\n+  // TODO: should we have an input for binding disabled reason?\n+  /**\n+   * An input to receive the disabled status for the field. If implemented, the `Control` directive\n+   * will automatically bind the disabled status from the bound field to this input.\n+   */\n   readonly disabled?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the readonly status for the field. If implemented, the `Control` directive\n+   * will automatically bind the readonly status from the bound field to this input.\n+   */\n   readonly readonly?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the hidden status for the field. If implemented, the `Control` directive\n+   * will automatically bind the hidden status from the bound field to this input.\n+   */\n+  readonly hidden?: InputSignal<boolean | undefined>;\n+  // TODO: what do we do about the whole valid != invalid thing?\n+  // Should we bind both of them? neither? treat valid+pending as valid? some kind of combined tri-/quad-state?\n+  // Should we allow binding in the pending state?\n+  /**\n+   * An input to receive the valid status for the field. If implemented, the `Control` directive\n+   * will automatically bind the valid status from the bound field to this input.\n+   */\n   readonly valid?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the touched status for the field. If implemented, the `Control` directive\n+   * will automatically bind the touched status from the bound field to this input.\n+   */\n   readonly touched?: InputSignal<boolean | undefined>;\n-  readonly name?: InputSignal<string>;\n-\n-  readonly touch?: OutputRef<void>;\n-\n+  /**\n+   * An input to receive the dirty status for the field. If implemented, the `Control` directive\n+   * will automatically bind the dirty status from the bound field to this input.\n+   */\n+  readonly dirty?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the name for the field. If implemented, the `Control` directive will\n+   * automatically bind the name from the bound field to this input.\n+   */\n+  readonly name?: InputSignal<string | undefined>;\n+  /**\n+   * An input to receive the required status for the field. If implemented, the `Control` directive\n+   * will automatically bind the required status from the bound field to this input.\n+   */\n+  readonly required?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the min value for the field. If implemented, the `Control` directive will\n+   * automatically bind the min value from the bound field to this input.\n+   */\n   readonly min?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the min length for the field. If implemented, the `Control` directive will\n+   * automatically bind the min length from the bound field to this input.\n+   */\n   readonly minLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max value for the field. If implemented, the `Control` directive will\n+   * automatically bind the max value from the bound field to this input.\n+   */\n   readonly max?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max length for the field. If implemented, the `Control` directive will\n+   * automatically bind the max length from the bound field to this input.\n+   */\n   readonly maxLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the value patterns for the field. If implemented, the `Control` directive\n+   * will automatically bind the value patterns from the bound field to this input.\n+   */\n+  readonly pattern?: InputSignal<readonly RegExp[] | undefined>;\n+  // TODO: what should we name this output? `touch` feels weird. The rest of the inputs here are",
        "comment_created_at": "2025-08-09T09:21:25+00:00",
        "comment_author": "mmalerba",
        "comment_body": "TODO callout: what should we name this output? `touch` feels weird. The rest of the inputs here are named after their corresponding DOM concept (when applicable). Following that pattern, `blur` might make sense, though maybe we consider this a separate thing that only happens to align with blur by default. Some alternative options:\r\n- `blur`\r\n- `touchEvent`\r\n- `touched` (overlaps with the input name, could make it a `InputSignal | ModelSignal | OutputRef`)\r\n- `onTouch`\r\n- just remove this and don't allow customization of this behavior",
        "pr_file_module": null
      },
      {
        "comment_id": "2268232632",
        "repo_full_name": "angular/angular",
        "pr_number": 63068,
        "pr_file": "packages/forms/experimental/src/api/control.ts",
        "discussion_id": "2264627515",
        "commented_code": "@@ -9,31 +9,148 @@\n import {InputSignal, ModelSignal, OutputRef} from '@angular/core';\n import {ValidationError} from './validation_errors';\n \n-export interface BaseUiControl {\n+/** The base set of properties shared by all form control contracts. */\n+export interface FormUiControl {\n+  /**\n+   * An input to receive the errors for the field. If implemented, the `Control` directive will\n+   * automatically bind errors from the bound field to this input.\n+   */\n   readonly errors?: InputSignal<readonly ValidationError[] | undefined>;\n+  // TODO: should we have an input for binding disabled reason?\n+  /**\n+   * An input to receive the disabled status for the field. If implemented, the `Control` directive\n+   * will automatically bind the disabled status from the bound field to this input.\n+   */\n   readonly disabled?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the readonly status for the field. If implemented, the `Control` directive\n+   * will automatically bind the readonly status from the bound field to this input.\n+   */\n   readonly readonly?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the hidden status for the field. If implemented, the `Control` directive\n+   * will automatically bind the hidden status from the bound field to this input.\n+   */\n+  readonly hidden?: InputSignal<boolean | undefined>;\n+  // TODO: what do we do about the whole valid != invalid thing?\n+  // Should we bind both of them? neither? treat valid+pending as valid? some kind of combined tri-/quad-state?\n+  // Should we allow binding in the pending state?\n+  /**\n+   * An input to receive the valid status for the field. If implemented, the `Control` directive\n+   * will automatically bind the valid status from the bound field to this input.\n+   */\n   readonly valid?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the touched status for the field. If implemented, the `Control` directive\n+   * will automatically bind the touched status from the bound field to this input.\n+   */\n   readonly touched?: InputSignal<boolean | undefined>;\n-  readonly name?: InputSignal<string>;\n-\n-  readonly touch?: OutputRef<void>;\n-\n+  /**\n+   * An input to receive the dirty status for the field. If implemented, the `Control` directive\n+   * will automatically bind the dirty status from the bound field to this input.\n+   */\n+  readonly dirty?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the name for the field. If implemented, the `Control` directive will\n+   * automatically bind the name from the bound field to this input.\n+   */\n+  readonly name?: InputSignal<string | undefined>;\n+  /**\n+   * An input to receive the required status for the field. If implemented, the `Control` directive\n+   * will automatically bind the required status from the bound field to this input.\n+   */\n+  readonly required?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the min value for the field. If implemented, the `Control` directive will\n+   * automatically bind the min value from the bound field to this input.\n+   */\n   readonly min?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the min length for the field. If implemented, the `Control` directive will\n+   * automatically bind the min length from the bound field to this input.\n+   */\n   readonly minLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max value for the field. If implemented, the `Control` directive will\n+   * automatically bind the max value from the bound field to this input.\n+   */\n   readonly max?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max length for the field. If implemented, the `Control` directive will\n+   * automatically bind the max length from the bound field to this input.\n+   */\n   readonly maxLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the value patterns for the field. If implemented, the `Control` directive\n+   * will automatically bind the value patterns from the bound field to this input.\n+   */\n+  readonly pattern?: InputSignal<readonly RegExp[] | undefined>;\n+  // TODO: what should we name this output? `touch` feels weird. The rest of the inputs here are",
        "comment_created_at": "2025-08-11T23:37:21+00:00",
        "comment_author": "leonsenft",
        "comment_body": "Since this isn't visible to the DOM, what about `onTouch`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2283110137",
        "repo_full_name": "angular/angular",
        "pr_number": 63068,
        "pr_file": "packages/forms/experimental/src/api/control.ts",
        "discussion_id": "2264627515",
        "commented_code": "@@ -9,31 +9,148 @@\n import {InputSignal, ModelSignal, OutputRef} from '@angular/core';\n import {ValidationError} from './validation_errors';\n \n-export interface BaseUiControl {\n+/** The base set of properties shared by all form control contracts. */\n+export interface FormUiControl {\n+  /**\n+   * An input to receive the errors for the field. If implemented, the `Control` directive will\n+   * automatically bind errors from the bound field to this input.\n+   */\n   readonly errors?: InputSignal<readonly ValidationError[] | undefined>;\n+  // TODO: should we have an input for binding disabled reason?\n+  /**\n+   * An input to receive the disabled status for the field. If implemented, the `Control` directive\n+   * will automatically bind the disabled status from the bound field to this input.\n+   */\n   readonly disabled?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the readonly status for the field. If implemented, the `Control` directive\n+   * will automatically bind the readonly status from the bound field to this input.\n+   */\n   readonly readonly?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the hidden status for the field. If implemented, the `Control` directive\n+   * will automatically bind the hidden status from the bound field to this input.\n+   */\n+  readonly hidden?: InputSignal<boolean | undefined>;\n+  // TODO: what do we do about the whole valid != invalid thing?\n+  // Should we bind both of them? neither? treat valid+pending as valid? some kind of combined tri-/quad-state?\n+  // Should we allow binding in the pending state?\n+  /**\n+   * An input to receive the valid status for the field. If implemented, the `Control` directive\n+   * will automatically bind the valid status from the bound field to this input.\n+   */\n   readonly valid?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the touched status for the field. If implemented, the `Control` directive\n+   * will automatically bind the touched status from the bound field to this input.\n+   */\n   readonly touched?: InputSignal<boolean | undefined>;\n-  readonly name?: InputSignal<string>;\n-\n-  readonly touch?: OutputRef<void>;\n-\n+  /**\n+   * An input to receive the dirty status for the field. If implemented, the `Control` directive\n+   * will automatically bind the dirty status from the bound field to this input.\n+   */\n+  readonly dirty?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the name for the field. If implemented, the `Control` directive will\n+   * automatically bind the name from the bound field to this input.\n+   */\n+  readonly name?: InputSignal<string | undefined>;\n+  /**\n+   * An input to receive the required status for the field. If implemented, the `Control` directive\n+   * will automatically bind the required status from the bound field to this input.\n+   */\n+  readonly required?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the min value for the field. If implemented, the `Control` directive will\n+   * automatically bind the min value from the bound field to this input.\n+   */\n   readonly min?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the min length for the field. If implemented, the `Control` directive will\n+   * automatically bind the min length from the bound field to this input.\n+   */\n   readonly minLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max value for the field. If implemented, the `Control` directive will\n+   * automatically bind the max value from the bound field to this input.\n+   */\n   readonly max?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max length for the field. If implemented, the `Control` directive will\n+   * automatically bind the max length from the bound field to this input.\n+   */\n   readonly maxLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the value patterns for the field. If implemented, the `Control` directive\n+   * will automatically bind the value patterns from the bound field to this input.\n+   */\n+  readonly pattern?: InputSignal<readonly RegExp[] | undefined>;\n+  // TODO: what should we name this output? `touch` feels weird. The rest of the inputs here are",
        "comment_created_at": "2025-08-18T18:10:34+00:00",
        "comment_author": "mmalerba",
        "comment_body": "Also an option, personally I'm leaning toward `touched` or remove it",
        "pr_file_module": null
      },
      {
        "comment_id": "2286360058",
        "repo_full_name": "angular/angular",
        "pr_number": 63068,
        "pr_file": "packages/forms/experimental/src/api/control.ts",
        "discussion_id": "2264627515",
        "commented_code": "@@ -9,31 +9,148 @@\n import {InputSignal, ModelSignal, OutputRef} from '@angular/core';\n import {ValidationError} from './validation_errors';\n \n-export interface BaseUiControl {\n+/** The base set of properties shared by all form control contracts. */\n+export interface FormUiControl {\n+  /**\n+   * An input to receive the errors for the field. If implemented, the `Control` directive will\n+   * automatically bind errors from the bound field to this input.\n+   */\n   readonly errors?: InputSignal<readonly ValidationError[] | undefined>;\n+  // TODO: should we have an input for binding disabled reason?\n+  /**\n+   * An input to receive the disabled status for the field. If implemented, the `Control` directive\n+   * will automatically bind the disabled status from the bound field to this input.\n+   */\n   readonly disabled?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the readonly status for the field. If implemented, the `Control` directive\n+   * will automatically bind the readonly status from the bound field to this input.\n+   */\n   readonly readonly?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the hidden status for the field. If implemented, the `Control` directive\n+   * will automatically bind the hidden status from the bound field to this input.\n+   */\n+  readonly hidden?: InputSignal<boolean | undefined>;\n+  // TODO: what do we do about the whole valid != invalid thing?\n+  // Should we bind both of them? neither? treat valid+pending as valid? some kind of combined tri-/quad-state?\n+  // Should we allow binding in the pending state?\n+  /**\n+   * An input to receive the valid status for the field. If implemented, the `Control` directive\n+   * will automatically bind the valid status from the bound field to this input.\n+   */\n   readonly valid?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the touched status for the field. If implemented, the `Control` directive\n+   * will automatically bind the touched status from the bound field to this input.\n+   */\n   readonly touched?: InputSignal<boolean | undefined>;\n-  readonly name?: InputSignal<string>;\n-\n-  readonly touch?: OutputRef<void>;\n-\n+  /**\n+   * An input to receive the dirty status for the field. If implemented, the `Control` directive\n+   * will automatically bind the dirty status from the bound field to this input.\n+   */\n+  readonly dirty?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the name for the field. If implemented, the `Control` directive will\n+   * automatically bind the name from the bound field to this input.\n+   */\n+  readonly name?: InputSignal<string | undefined>;\n+  /**\n+   * An input to receive the required status for the field. If implemented, the `Control` directive\n+   * will automatically bind the required status from the bound field to this input.\n+   */\n+  readonly required?: InputSignal<boolean | undefined>;\n+  /**\n+   * An input to receive the min value for the field. If implemented, the `Control` directive will\n+   * automatically bind the min value from the bound field to this input.\n+   */\n   readonly min?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the min length for the field. If implemented, the `Control` directive will\n+   * automatically bind the min length from the bound field to this input.\n+   */\n   readonly minLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max value for the field. If implemented, the `Control` directive will\n+   * automatically bind the max value from the bound field to this input.\n+   */\n   readonly max?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the max length for the field. If implemented, the `Control` directive will\n+   * automatically bind the max length from the bound field to this input.\n+   */\n   readonly maxLength?: InputSignal<number | undefined>;\n+  /**\n+   * An input to receive the value patterns for the field. If implemented, the `Control` directive\n+   * will automatically bind the value patterns from the bound field to this input.\n+   */\n+  readonly pattern?: InputSignal<readonly RegExp[] | undefined>;\n+  // TODO: what should we name this output? `touch` feels weird. The rest of the inputs here are",
        "comment_created_at": "2025-08-19T21:19:19+00:00",
        "comment_author": "mmalerba",
        "comment_body": "Going with `touched` for now, we can revisit if we don't like it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2191125088",
    "pr_number": 62429,
    "pr_file": "devtools/projects/ng-devtools/src/lib/application-services/settings_store_service.ts",
    "created_at": "2025-07-07T22:44:07+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {effect, inject, Injectable, Injector, signal, WritableSignal} from '@angular/core';\n+import {ApplicationOperations} from '../application-operations';\n+\n+export const SETTINGS_STORE_KEY = 'ng-dt-settings';\n+\n+@Injectable({providedIn: 'root'})\n+/** Provides an API for storing and preserving settings values. */\n+export class SettingsStoreService {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2191125088",
        "repo_full_name": "angular/angular",
        "pr_number": 62429,
        "pr_file": "devtools/projects/ng-devtools/src/lib/application-services/settings_store_service.ts",
        "discussion_id": "2191125088",
        "commented_code": "@@ -0,0 +1,74 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.dev/license\n+ */\n+\n+import {effect, inject, Injectable, Injector, signal, WritableSignal} from '@angular/core';\n+import {ApplicationOperations} from '../application-operations';\n+\n+export const SETTINGS_STORE_KEY = 'ng-dt-settings';\n+\n+@Injectable({providedIn: 'root'})\n+/** Provides an API for storing and preserving settings values. */\n+export class SettingsStoreService {",
        "comment_created_at": "2025-07-07T22:44:07+00:00",
        "comment_author": "dgp1130",
        "comment_body": "Style: In the interest of aligning with our current style guide, how would you feel about just calling this `SettingsStore` and naming the file `settings_store.ts`?",
        "pr_file_module": null
      }
    ]
  }
]