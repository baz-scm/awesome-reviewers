[
  {
    "discussion_id": "2317243192",
    "pr_number": 62750,
    "pr_file": "adev/src/content/tutorials/signals/steps/6-two-way-binding-with-model-signals/README.md",
    "created_at": "2025-09-02T21:47:47+00:00",
    "commented_code": "+# Two-way binding with model signals\n+\n+Now that you've learned [passing data to components with input signals](/tutorials/signals/5-component-communication-with-signals), let's explore Angular's `model()` API for two-way binding. Model signals are perfect for UI components like checkboxes, sliders, or custom form controls where the component needs to both receive a value AND update it.\n+\n+In this activity, you'll create a custom checkbox component that manages its own state while keeping the parent synchronized.\n+\n+<hr />\n+\n+<docs-workflow>\n+\n+<docs-step title=\"Set up the custom checkbox with model signal\">\n+Create a model signal in the `custom-checkbox` component that can both receive and update the parent's value.\n+\n+```ts\n+// Add imports for model signals\n+import {Component, model, input} from '@angular/core';\n+\n+// Model signal for two-way binding\n+checked = model.required<boolean>();\n+\n+// Optional input for label\n+label = input<string>('');\n+```\n+\n+Unlike `input()` signals which are read-only, `model()` signals can be both read and written to.\n+</docs-step>\n+\n+<docs-step title=\"Create the checkbox template\">\n+Build the checkbox template that responds to clicks and updates its own model.\n+\n+```html\n+<label class=\"custom-checkbox\">\n+  <input \n+    type=\"checkbox\" \n+    [checked]=\"checked()\" \n+    (change)=\"toggle()\">\n+  <span class=\"checkmark\"></span>\n+  {{ label() }}\n+</label>\n+```\n+\n+The component reads from its model signal and has a method to update it.\n+</docs-step>\n+\n+<docs-step title=\"Add the toggle method\">\n+Implement the toggle method that updates the model signal when the checkbox is clicked.\n+\n+```ts\n+toggle() {\n+  // This updates BOTH the component's state AND the parent's model!\n+  this.checked.set(!this.checked());\n+}\n+```\n+\n+When the child component calls `this.checked.set()`, it automatically propagates the change back to the parent. This is the key difference from `input()` signals.\n+</docs-step>\n+\n+<docs-step title=\"Set up two-way binding in the parent\">\n+Create a signal model in the parent `app.ts` and bind it to the custom checkbox.\n+\n+```ts\n+// Parent signal model\n+agreedToTerms = model(false);\n+enableNotifications = model(true);\n+\n+// Methods to test two-way binding\n+toggleTermsFromParent() {\n+  this.agreedToTerms.set(!this.agreedToTerms());\n+}\n+\n+resetAll() {\n+  this.agreedToTerms.set(false);\n+  this.enableNotifications.set(false);\n+}\n+```\n+\n+```html\n+<!-- Two-way binding with custom components -->\n+<custom-checkbox \n+  [(checked)]=\"agreedToTerms\" \n+  label=\"I agree to the terms\"\n+/>\n+\n+<custom-checkbox \n+  [(checked)]=\"enableNotifications\" \n+  label=\"Enable notifications\"\n+/>\n+\n+<!-- Controls to test two-way binding -->\n+<div class=\"controls\">\n+  <p>Terms agreed: \n+    @if (agreedToTerms()) {\n+      Yes\n+    } @else {\n+      No\n+    }\n+  </p>\n+  <p>Notifications: \n+    @if (enableNotifications()) {\n+      Enabled\n+    } @else {\n+      Disabled\n+    }\n+  </p>\n+  <button (click)=\"toggleTermsFromParent()\">Toggle Terms from Parent</button>\n+  <button (click)=\"resetAll()\">Reset All</button>\n+</div>\n+```\n+\n+The `[(checked)]` syntax creates two-way binding - data flows down to the component AND changes flow back up to the parent.",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2317243192",
        "repo_full_name": "angular/angular",
        "pr_number": 62750,
        "pr_file": "adev/src/content/tutorials/signals/steps/6-two-way-binding-with-model-signals/README.md",
        "discussion_id": "2317243192",
        "commented_code": "@@ -0,0 +1,136 @@\n+# Two-way binding with model signals\n+\n+Now that you've learned [passing data to components with input signals](/tutorials/signals/5-component-communication-with-signals), let's explore Angular's `model()` API for two-way binding. Model signals are perfect for UI components like checkboxes, sliders, or custom form controls where the component needs to both receive a value AND update it.\n+\n+In this activity, you'll create a custom checkbox component that manages its own state while keeping the parent synchronized.\n+\n+<hr />\n+\n+<docs-workflow>\n+\n+<docs-step title=\"Set up the custom checkbox with model signal\">\n+Create a model signal in the `custom-checkbox` component that can both receive and update the parent's value.\n+\n+```ts\n+// Add imports for model signals\n+import {Component, model, input} from '@angular/core';\n+\n+// Model signal for two-way binding\n+checked = model.required<boolean>();\n+\n+// Optional input for label\n+label = input<string>('');\n+```\n+\n+Unlike `input()` signals which are read-only, `model()` signals can be both read and written to.\n+</docs-step>\n+\n+<docs-step title=\"Create the checkbox template\">\n+Build the checkbox template that responds to clicks and updates its own model.\n+\n+```html\n+<label class=\"custom-checkbox\">\n+  <input \n+    type=\"checkbox\" \n+    [checked]=\"checked()\" \n+    (change)=\"toggle()\">\n+  <span class=\"checkmark\"></span>\n+  {{ label() }}\n+</label>\n+```\n+\n+The component reads from its model signal and has a method to update it.\n+</docs-step>\n+\n+<docs-step title=\"Add the toggle method\">\n+Implement the toggle method that updates the model signal when the checkbox is clicked.\n+\n+```ts\n+toggle() {\n+  // This updates BOTH the component's state AND the parent's model!\n+  this.checked.set(!this.checked());\n+}\n+```\n+\n+When the child component calls `this.checked.set()`, it automatically propagates the change back to the parent. This is the key difference from `input()` signals.\n+</docs-step>\n+\n+<docs-step title=\"Set up two-way binding in the parent\">\n+Create a signal model in the parent `app.ts` and bind it to the custom checkbox.\n+\n+```ts\n+// Parent signal model\n+agreedToTerms = model(false);\n+enableNotifications = model(true);\n+\n+// Methods to test two-way binding\n+toggleTermsFromParent() {\n+  this.agreedToTerms.set(!this.agreedToTerms());\n+}\n+\n+resetAll() {\n+  this.agreedToTerms.set(false);\n+  this.enableNotifications.set(false);\n+}\n+```\n+\n+```html\n+<!-- Two-way binding with custom components -->\n+<custom-checkbox \n+  [(checked)]=\"agreedToTerms\" \n+  label=\"I agree to the terms\"\n+/>\n+\n+<custom-checkbox \n+  [(checked)]=\"enableNotifications\" \n+  label=\"Enable notifications\"\n+/>\n+\n+<!-- Controls to test two-way binding -->\n+<div class=\"controls\">\n+  <p>Terms agreed: \n+    @if (agreedToTerms()) {\n+      Yes\n+    } @else {\n+      No\n+    }\n+  </p>\n+  <p>Notifications: \n+    @if (enableNotifications()) {\n+      Enabled\n+    } @else {\n+      Disabled\n+    }\n+  </p>\n+  <button (click)=\"toggleTermsFromParent()\">Toggle Terms from Parent</button>\n+  <button (click)=\"resetAll()\">Reset All</button>\n+</div>\n+```\n+\n+The `[(checked)]` syntax creates two-way binding - data flows down to the component AND changes flow back up to the parent.",
        "comment_created_at": "2025-09-02T21:47:47+00:00",
        "comment_author": "jelbourn",
        "comment_body": "I think it would be helpful to highlight the fact that two-way bindings reference the signal itself, and do _not_ call the signal getter. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195518234",
    "pr_number": 62250,
    "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
    "created_at": "2025-07-09T17:01:39+00:00",
    "commented_code": "+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2195518234",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195518234",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);",
        "comment_created_at": "2025-07-09T17:01:39+00:00",
        "comment_author": "atscott",
        "comment_body": "I might suggest using `toSignal` on `this.route.data['user']` (and 'settings') instead so the data isn't static and keeps up-to-date if the route changes and the component is reused",
        "pr_file_module": null
      },
      {
        "comment_id": "2195727046",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195518234",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);",
        "comment_created_at": "2025-07-09T18:35:25+00:00",
        "comment_author": "bencodezen",
        "comment_body": "Got it! What do you think of this instead?\r\n\r\n```ts\r\nexport class UserDetail {\r\n  private route = inject(ActivatedRoute);\r\n  private data = toSignal(this.route.data);\r\n  user = computed(() => this.data().user as User);\r\n  settings = computed(() => this.data().settings as Settings);\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2195731932",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195518234",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);",
        "comment_created_at": "2025-07-09T18:38:26+00:00",
        "comment_author": "atscott",
        "comment_body": "\ud83d\udc4c ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195530503",
    "pr_number": 62250,
    "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
    "created_at": "2025-07-09T17:09:35+00:00",
    "commented_code": "+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInputBinding\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(App, {\n+  providers: [\n+    provideRouter(routes, withComponentInputBinding())\n+  ]\n+});\n+```\n+\n+With this configuration, you can define inputs in your component that match the resolver keys using the [`input`](api/core/input) function and [`input.required`](api/core/input#required) for required inputs:\n+\n+```angular-ts\n+import { Component, input } from '@angular/core';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  user = input.required<User>();\n+  settings = input<Settings>();\n+}\n+```\n+\n+This approach provides better type safety and eliminates the need to inject `ActivatedRoute` just to access resolved data.\n+\n+## Error handling in resolvers\n+\n+In the event of navigation failures, it is important to handle errors gracefully in your data resolvers.\n+\n+Here's an updated example of the `userResolver` that logs the error and navigates back to the generic `/users` page using the [`Router`](api/router/Router) service:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { Router, ResolveFn } from '@angular/router';\n+import { catchError, EMPTY } from 'rxjs';\n+import { UserService } from './user-service';\n+import type { User } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route) => {\n+  const userService = inject(UserService);\n+  const router = inject(Router);\n+  const userId = route.paramMap.get('id')!;\n+\n+  return userService.getUser(userId).pipe(\n+    catchError(error => {\n+      console.error('Failed to load user:', error);\n+      router.navigate(['/users']);\n+      return EMPTY;\n+    })\n+  );\n+};\n+```\n+\n+## Navigation loading considerations\n+\n+While data resolvers prevent loading states within components, they introduce a different UX consideration: navigation is blocked while resolvers execute. Users may experience delays between clicking a link and seeing the new route, especially with slow network requests.\n+\n+### Providing navigation feedback\n+\n+To improve user experience during resolver execution, you can listen to router events and show loading indicators:\n+\n+```ts\n+import { Component, inject, signal } from '@angular/core';\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';\n+import { filter } from 'rxjs';\n+\n+@Component({\n+  selector: 'app-root',\n+  template: `\n+    @if (isNavigating()) {\n+      <div class=\"loading-bar\">Loading...</div>\n+    }\n+    <router-outlet />\n+  `\n+})\n+export class App {\n+  private router = inject(Router);\n+  isNavigating = signal(false);\n+\n+  constructor() {\n+    this.router.events.pipe(\n+      filter(event =>\n+        event instanceof NavigationStart ||\n+        event instanceof NavigationEnd ||\n+        event instanceof NavigationCancel ||\n+        event instanceof NavigationError\n+      )\n+    ).subscribe(event => {\n+      this.isNavigating.set(event instanceof NavigationStart);\n+    });",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2195530503",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195530503",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInputBinding\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(App, {\n+  providers: [\n+    provideRouter(routes, withComponentInputBinding())\n+  ]\n+});\n+```\n+\n+With this configuration, you can define inputs in your component that match the resolver keys using the [`input`](api/core/input) function and [`input.required`](api/core/input#required) for required inputs:\n+\n+```angular-ts\n+import { Component, input } from '@angular/core';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  user = input.required<User>();\n+  settings = input<Settings>();\n+}\n+```\n+\n+This approach provides better type safety and eliminates the need to inject `ActivatedRoute` just to access resolved data.\n+\n+## Error handling in resolvers\n+\n+In the event of navigation failures, it is important to handle errors gracefully in your data resolvers.\n+\n+Here's an updated example of the `userResolver` that logs the error and navigates back to the generic `/users` page using the [`Router`](api/router/Router) service:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { Router, ResolveFn } from '@angular/router';\n+import { catchError, EMPTY } from 'rxjs';\n+import { UserService } from './user-service';\n+import type { User } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route) => {\n+  const userService = inject(UserService);\n+  const router = inject(Router);\n+  const userId = route.paramMap.get('id')!;\n+\n+  return userService.getUser(userId).pipe(\n+    catchError(error => {\n+      console.error('Failed to load user:', error);\n+      router.navigate(['/users']);\n+      return EMPTY;\n+    })\n+  );\n+};\n+```\n+\n+## Navigation loading considerations\n+\n+While data resolvers prevent loading states within components, they introduce a different UX consideration: navigation is blocked while resolvers execute. Users may experience delays between clicking a link and seeing the new route, especially with slow network requests.\n+\n+### Providing navigation feedback\n+\n+To improve user experience during resolver execution, you can listen to router events and show loading indicators:\n+\n+```ts\n+import { Component, inject, signal } from '@angular/core';\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';\n+import { filter } from 'rxjs';\n+\n+@Component({\n+  selector: 'app-root',\n+  template: `\n+    @if (isNavigating()) {\n+      <div class=\"loading-bar\">Loading...</div>\n+    }\n+    <router-outlet />\n+  `\n+})\n+export class App {\n+  private router = inject(Router);\n+  isNavigating = signal(false);\n+\n+  constructor() {\n+    this.router.events.pipe(\n+      filter(event =>\n+        event instanceof NavigationStart ||\n+        event instanceof NavigationEnd ||\n+        event instanceof NavigationCancel ||\n+        event instanceof NavigationError\n+      )\n+    ).subscribe(event => {\n+      this.isNavigating.set(event instanceof NavigationStart);\n+    });",
        "comment_created_at": "2025-07-09T17:09:35+00:00",
        "comment_author": "atscott",
        "comment_body": "nit: You might also consider the change from one of the other PRs and make this `toSignal(router.events.pipe(map(() => !!this.router.getCurrentNavigation())))`",
        "pr_file_module": null
      },
      {
        "comment_id": "2195712915",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195530503",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetail,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInputBinding\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(App, {\n+  providers: [\n+    provideRouter(routes, withComponentInputBinding())\n+  ]\n+});\n+```\n+\n+With this configuration, you can define inputs in your component that match the resolver keys using the [`input`](api/core/input) function and [`input.required`](api/core/input#required) for required inputs:\n+\n+```angular-ts\n+import { Component, input } from '@angular/core';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetail {\n+  user = input.required<User>();\n+  settings = input<Settings>();\n+}\n+```\n+\n+This approach provides better type safety and eliminates the need to inject `ActivatedRoute` just to access resolved data.\n+\n+## Error handling in resolvers\n+\n+In the event of navigation failures, it is important to handle errors gracefully in your data resolvers.\n+\n+Here's an updated example of the `userResolver` that logs the error and navigates back to the generic `/users` page using the [`Router`](api/router/Router) service:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { Router, ResolveFn } from '@angular/router';\n+import { catchError, EMPTY } from 'rxjs';\n+import { UserService } from './user-service';\n+import type { User } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route) => {\n+  const userService = inject(UserService);\n+  const router = inject(Router);\n+  const userId = route.paramMap.get('id')!;\n+\n+  return userService.getUser(userId).pipe(\n+    catchError(error => {\n+      console.error('Failed to load user:', error);\n+      router.navigate(['/users']);\n+      return EMPTY;\n+    })\n+  );\n+};\n+```\n+\n+## Navigation loading considerations\n+\n+While data resolvers prevent loading states within components, they introduce a different UX consideration: navigation is blocked while resolvers execute. Users may experience delays between clicking a link and seeing the new route, especially with slow network requests.\n+\n+### Providing navigation feedback\n+\n+To improve user experience during resolver execution, you can listen to router events and show loading indicators:\n+\n+```ts\n+import { Component, inject, signal } from '@angular/core';\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';\n+import { filter } from 'rxjs';\n+\n+@Component({\n+  selector: 'app-root',\n+  template: `\n+    @if (isNavigating()) {\n+      <div class=\"loading-bar\">Loading...</div>\n+    }\n+    <router-outlet />\n+  `\n+})\n+export class App {\n+  private router = inject(Router);\n+  isNavigating = signal(false);\n+\n+  constructor() {\n+    this.router.events.pipe(\n+      filter(event =>\n+        event instanceof NavigationStart ||\n+        event instanceof NavigationEnd ||\n+        event instanceof NavigationCancel ||\n+        event instanceof NavigationError\n+      )\n+    ).subscribe(event => {\n+      this.isNavigating.set(event instanceof NavigationStart);\n+    });",
        "comment_created_at": "2025-07-09T18:26:52+00:00",
        "comment_author": "bencodezen",
        "comment_body": "Good call!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162536928",
    "pr_number": 62225,
    "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
    "created_at": "2025-06-23T21:09:08+00:00",
    "commented_code": "+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                            | Description                                                                                              |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)   | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized) | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart) | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)     | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)         | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)             | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)       | Final event when navigation completes successfully. The router updates the URL.                          |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+private readonly router = inject(Router);\n+constructor() {\n+  router.events.subscribe((event: Event) => {\n+    if (event instanceof NavigationStart) {\n+      // Navigation starting\n+      console.log('Navigation starting:', event.url);\n+    }\n+    if (event instanceof NavigationEnd) {\n+      // Navigation completed\n+      console.log('Navigation completed:', event.url);\n+    }\n+  });\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError, NavigationSkipped } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AppComponent {\n+  private router = inject(Router);\n+  loading = false;\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationStart) {\n+        this.loading = true;\n+      } else if (event instanceof NavigationEnd ||\n+                 event instanceof NavigationCancel ||\n+                 event instanceof NavigationError ||\n+                 event instanceof NavigationSkipped) {\n+        this.loading = false;\n+      }\n+    });",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2162536928",
        "repo_full_name": "angular/angular",
        "pr_number": 62225,
        "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
        "discussion_id": "2162536928",
        "commented_code": "@@ -0,0 +1,221 @@\n+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                            | Description                                                                                              |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)   | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized) | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart) | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)     | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)         | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)             | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)       | Final event when navigation completes successfully. The router updates the URL.                          |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+private readonly router = inject(Router);\n+constructor() {\n+  router.events.subscribe((event: Event) => {\n+    if (event instanceof NavigationStart) {\n+      // Navigation starting\n+      console.log('Navigation starting:', event.url);\n+    }\n+    if (event instanceof NavigationEnd) {\n+      // Navigation completed\n+      console.log('Navigation completed:', event.url);\n+    }\n+  });\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError, NavigationSkipped } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AppComponent {\n+  private router = inject(Router);\n+  loading = false;\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationStart) {\n+        this.loading = true;\n+      } else if (event instanceof NavigationEnd ||\n+                 event instanceof NavigationCancel ||\n+                 event instanceof NavigationError ||\n+                 event instanceof NavigationSkipped) {\n+        this.loading = false;\n+      }\n+    });",
        "comment_created_at": "2025-06-23T21:09:08+00:00",
        "comment_author": "atscott",
        "comment_body": "Not that this is a _bad_ example, but it this could actually be simplified to: `this.loading = toSignal(this.router.events.pipe(map(() => !!this.router.getCurrentNavigation()))`. \r\n\r\nBut maybe we don't want to imply that this loading example is actually as hard to do as is implied here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190686245",
        "repo_full_name": "angular/angular",
        "pr_number": 62225,
        "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
        "discussion_id": "2162536928",
        "commented_code": "@@ -0,0 +1,221 @@\n+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                            | Description                                                                                              |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)   | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized) | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart) | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)     | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)         | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)             | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)       | Final event when navigation completes successfully. The router updates the URL.                          |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+private readonly router = inject(Router);\n+constructor() {\n+  router.events.subscribe((event: Event) => {\n+    if (event instanceof NavigationStart) {\n+      // Navigation starting\n+      console.log('Navigation starting:', event.url);\n+    }\n+    if (event instanceof NavigationEnd) {\n+      // Navigation completed\n+      console.log('Navigation completed:', event.url);\n+    }\n+  });\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError, NavigationSkipped } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AppComponent {\n+  private router = inject(Router);\n+  loading = false;\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationStart) {\n+        this.loading = true;\n+      } else if (event instanceof NavigationEnd ||\n+                 event instanceof NavigationCancel ||\n+                 event instanceof NavigationError ||\n+                 event instanceof NavigationSkipped) {\n+        this.loading = false;\n+      }\n+    });",
        "comment_created_at": "2025-07-07T17:27:32+00:00",
        "comment_author": "bencodezen",
        "comment_body": "That's fair! I think your suggestion is better in terms of a more realistic production code model as well. Changes coming!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162542142",
    "pr_number": 62225,
    "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
    "created_at": "2025-06-23T21:13:02+00:00",
    "commented_code": "+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                            | Description                                                                                              |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)   | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized) | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart) | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)     | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)         | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)             | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)       | Final event when navigation completes successfully. The router updates the URL.                          |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+private readonly router = inject(Router);\n+constructor() {\n+  router.events.subscribe((event: Event) => {\n+    if (event instanceof NavigationStart) {\n+      // Navigation starting\n+      console.log('Navigation starting:', event.url);\n+    }\n+    if (event instanceof NavigationEnd) {\n+      // Navigation completed\n+      console.log('Navigation completed:', event.url);\n+    }\n+  });\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError, NavigationSkipped } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AppComponent {\n+  private router = inject(Router);\n+  loading = false;\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationStart) {\n+        this.loading = true;\n+      } else if (event instanceof NavigationEnd ||\n+                 event instanceof NavigationCancel ||\n+                 event instanceof NavigationError ||\n+                 event instanceof NavigationSkipped) {\n+        this.loading = false;\n+      }\n+    });\n+  }\n+}\n+```\n+\n+### Analytics tracking\n+\n+Track page views for analytics:\n+\n+```typescript\n+import { Router, NavigationEnd } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AnalyticsComponent {\n+  private router = inject(Router);\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationEnd) {\n+        // Send page view to analytics\n+        this.analytics.trackPageView(event.url);\n+      }\n+    });\n+  }\n+}\n+```\n+\n+### Error handling\n+\n+Handle navigation errors gracefully and provide user feedback:\n+\n+```typescript\n+import { Component, inject } from '@angular/core';\n+import { Router, NavigationError, NavigationCancel } from '@angular/router';\n+\n+@Component({\n+  selector: 'app-error-handler',\n+  standalone: true,\n+  template: `\n+    @if (errorMessage) {\n+      <div class=\"error-banner\">\n+        {{ errorMessage }}\n+        <button (click)=\"dismissError()\">Dismiss</button>\n+      </div>\n+    }\n+  `\n+})\n+export class ErrorHandlerComponent {\n+  private router = inject(Router);\n+  errorMessage = '';",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2162542142",
        "repo_full_name": "angular/angular",
        "pr_number": 62225,
        "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
        "discussion_id": "2162542142",
        "commented_code": "@@ -0,0 +1,221 @@\n+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                            | Description                                                                                              |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)   | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized) | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart) | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)     | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)         | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)             | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)       | Final event when navigation completes successfully. The router updates the URL.                          |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+private readonly router = inject(Router);\n+constructor() {\n+  router.events.subscribe((event: Event) => {\n+    if (event instanceof NavigationStart) {\n+      // Navigation starting\n+      console.log('Navigation starting:', event.url);\n+    }\n+    if (event instanceof NavigationEnd) {\n+      // Navigation completed\n+      console.log('Navigation completed:', event.url);\n+    }\n+  });\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError, NavigationSkipped } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AppComponent {\n+  private router = inject(Router);\n+  loading = false;\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationStart) {\n+        this.loading = true;\n+      } else if (event instanceof NavigationEnd ||\n+                 event instanceof NavigationCancel ||\n+                 event instanceof NavigationError ||\n+                 event instanceof NavigationSkipped) {\n+        this.loading = false;\n+      }\n+    });\n+  }\n+}\n+```\n+\n+### Analytics tracking\n+\n+Track page views for analytics:\n+\n+```typescript\n+import { Router, NavigationEnd } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AnalyticsComponent {\n+  private router = inject(Router);\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationEnd) {\n+        // Send page view to analytics\n+        this.analytics.trackPageView(event.url);\n+      }\n+    });\n+  }\n+}\n+```\n+\n+### Error handling\n+\n+Handle navigation errors gracefully and provide user feedback:\n+\n+```typescript\n+import { Component, inject } from '@angular/core';\n+import { Router, NavigationError, NavigationCancel } from '@angular/router';\n+\n+@Component({\n+  selector: 'app-error-handler',\n+  standalone: true,\n+  template: `\n+    @if (errorMessage) {\n+      <div class=\"error-banner\">\n+        {{ errorMessage }}\n+        <button (click)=\"dismissError()\">Dismiss</button>\n+      </div>\n+    }\n+  `\n+})\n+export class ErrorHandlerComponent {\n+  private router = inject(Router);\n+  errorMessage = '';",
        "comment_created_at": "2025-06-23T21:13:02+00:00",
        "comment_author": "atscott",
        "comment_body": "As in other examples, this should use a signal",
        "pr_file_module": null
      },
      {
        "comment_id": "2190676681",
        "repo_full_name": "angular/angular",
        "pr_number": 62225,
        "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
        "discussion_id": "2162542142",
        "commented_code": "@@ -0,0 +1,221 @@\n+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                            | Description                                                                                              |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)   | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized) | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart) | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)     | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)         | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)             | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)       | Final event when navigation completes successfully. The router updates the URL.                          |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+private readonly router = inject(Router);\n+constructor() {\n+  router.events.subscribe((event: Event) => {\n+    if (event instanceof NavigationStart) {\n+      // Navigation starting\n+      console.log('Navigation starting:', event.url);\n+    }\n+    if (event instanceof NavigationEnd) {\n+      // Navigation completed\n+      console.log('Navigation completed:', event.url);\n+    }\n+  });\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Router, NavigationStart, NavigationEnd, NavigationCancel, NavigationError, NavigationSkipped } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AppComponent {\n+  private router = inject(Router);\n+  loading = false;\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationStart) {\n+        this.loading = true;\n+      } else if (event instanceof NavigationEnd ||\n+                 event instanceof NavigationCancel ||\n+                 event instanceof NavigationError ||\n+                 event instanceof NavigationSkipped) {\n+        this.loading = false;\n+      }\n+    });\n+  }\n+}\n+```\n+\n+### Analytics tracking\n+\n+Track page views for analytics:\n+\n+```typescript\n+import { Router, NavigationEnd } from '@angular/router';\n+import { inject } from '@angular/core';\n+\n+export class AnalyticsComponent {\n+  private router = inject(Router);\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationEnd) {\n+        // Send page view to analytics\n+        this.analytics.trackPageView(event.url);\n+      }\n+    });\n+  }\n+}\n+```\n+\n+### Error handling\n+\n+Handle navigation errors gracefully and provide user feedback:\n+\n+```typescript\n+import { Component, inject } from '@angular/core';\n+import { Router, NavigationError, NavigationCancel } from '@angular/router';\n+\n+@Component({\n+  selector: 'app-error-handler',\n+  standalone: true,\n+  template: `\n+    @if (errorMessage) {\n+      <div class=\"error-banner\">\n+        {{ errorMessage }}\n+        <button (click)=\"dismissError()\">Dismiss</button>\n+      </div>\n+    }\n+  `\n+})\n+export class ErrorHandlerComponent {\n+  private router = inject(Router);\n+  errorMessage = '';",
        "comment_created_at": "2025-07-07T17:21:37+00:00",
        "comment_author": "bencodezen",
        "comment_body": "Got it!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2190770389",
    "pr_number": 62225,
    "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
    "created_at": "2025-07-07T18:20:22+00:00",
    "commented_code": "+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                              | Description                                                                                              |\n+| --------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)     | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized)   | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart)   | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)       | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)           | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)               | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)         | Final event when navigation completes successfully. The router updates the URL.                          |\n+| [`NavigationSkipped`](api/router/NavigationSkipped) | Occurs when the router skips navigation (e.g., same URL navigation).                                     |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Component, inject, signal, effect } from '@angular/core';\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+\n+@Component({\n+  selector: 'app-router-events',\n+  standalone: true,\n+  template: ''\n+})\n+export class RouterEventsComponent {\n+  private readonly router = inject(Router);\n+  \n+  // Signal to track current navigation event\n+  currentEvent = signal<Event | null>(null);\n+  \n+  constructor() {\n+    // Subscribe to router events and update signal\n+    this.router.events.subscribe((event: Event) => {\n+      this.currentEvent.set(event);\n+    });\n+    \n+    // React to event changes with effect\n+    effect(() => {\n+      const event = this.currentEvent();\n+      if (event instanceof NavigationStart) {\n+        // Navigation starting\n+        console.log('Navigation starting:', event.url);\n+      }\n+      if (event instanceof NavigationEnd) {\n+        // Navigation completed\n+        console.log('Navigation completed:', event.url);\n+      }\n+    });\n+  }\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Component, inject } from '@angular/core';\n+import { Router } from '@angular/router';\n+import { toSignal } from '@angular/core/rxjs-interop';\n+import { map } from 'rxjs/operators';\n+\n+@Component({\n+  selector: 'app-loading',\n+  standalone: true,\n+  template: `\n+    @if (loading()) {\n+      <div class=\"loading-spinner\">Loading...</div>\n+    }\n+  `\n+})\n+export class AppComponent {\n+  private router = inject(Router);\n+  \n+  loading = toSignal(\n+    this.router.events.pipe(\n+      map(() => !!this.router.getCurrentNavigation())\n+    ),\n+    { initialValue: false }\n+  );\n+}\n+```\n+\n+### Analytics tracking\n+\n+Track page views for analytics:\n+\n+```typescript\n+import { Component, inject, signal, effect } from '@angular/core';\n+import { Router, NavigationEnd } from '@angular/router';\n+\n+@Component({\n+  selector: 'app-analytics',\n+  standalone: true,\n+  template: ''\n+})\n+export class AnalyticsComponent {\n+  private router = inject(Router);\n+  private currentUrl = signal<string | null>(null);\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationEnd) {\n+        this.currentUrl.set(event.url);\n+      }\n+    });\n+\n+    // Track page views when URL changes\n+    effect(() => {\n+      const url = this.currentUrl();\n+      if (url) {\n+        // Send page view to analytics\n+        this.analytics.trackPageView(url);\n+      }\n+    });\n+  }",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2190770389",
        "repo_full_name": "angular/angular",
        "pr_number": 62225,
        "pr_file": "adev/src/content/guide/routing/lifecycle-and-events.md",
        "discussion_id": "2190770389",
        "commented_code": "@@ -0,0 +1,268 @@\n+# Router Lifecycle and Events\n+\n+Angular Router provides a comprehensive set of lifecycle hooks and events that allow you to respond to navigation changes and execute custom logic during the routing process.\n+\n+## Common router events\n+\n+The Angular Router emits navigation events that you can subscribe to in order to track the navigation lifecycle. These events are available through the `Router.events` observable. This section covers common routing lifecycle events for navigation and error tracking (in chronological order).\n+\n+| Events                                              | Description                                                                                              |\n+| --------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |\n+| [`NavigationStart`](api/router/NavigationStart)     | Occurs when navigation begins and contains the requested URL.                                            |\n+| [`RoutesRecognized`](api/router/RoutesRecognized)   | Occurs after the router determines which route matches the URL and contains the route state information. |\n+| [`GuardsCheckStart`](api/router/GuardsCheckStart)   | Begins the route guard phase. The router evaluates route guards like `canActivate` and `canDeactivate`.  |\n+| [`GuardsCheckEnd`](api/router/GuardsCheckEnd)       | Signals completion of guard evaluation. Contains the result (allowed/denied).                            |\n+| [`ResolveStart`](api/router/ResolveStart)           | Begins the data resolution phase. Route resolvers start fetching data.                                   |\n+| [`ResolveEnd`](api/router/ResolveEnd)               | Data resolution completes. All required data becomes available.                                          |\n+| [`NavigationEnd`](api/router/NavigationEnd)         | Final event when navigation completes successfully. The router updates the URL.                          |\n+| [`NavigationSkipped`](api/router/NavigationSkipped) | Occurs when the router skips navigation (e.g., same URL navigation).                                     |\n+\n+The following are common error events:\n+\n+| Event                                             | Description                                                                      |\n+| ------------------------------------------------- | -------------------------------------------------------------------------------- |\n+| [`NavigationCancel`](api/router/NavigationCancel) | Occurs when the router cancels navigation. Often due to a guard returning false. |\n+| [`NavigationError`](api/router/NavigationError)   | Occurs when navigation fails. Could be due to invalid routes or resolver errors. |\n+\n+For a list of all lifecycle events, check out the [complete table of this guide](#all-router-events).\n+\n+## How to subscribe to router events\n+\n+When you want to run code during specific navigation lifecycle events, you can do so by subscribing to the `router.events` and checking the instance of the event:\n+\n+```ts\n+// Example of subscribing to router events\n+import { Component, inject, signal, effect } from '@angular/core';\n+import { Event, Router, NavigationStart, NavigationEnd } from '@angular/router';\n+\n+@Component({\n+  selector: 'app-router-events',\n+  standalone: true,\n+  template: ''\n+})\n+export class RouterEventsComponent {\n+  private readonly router = inject(Router);\n+  \n+  // Signal to track current navigation event\n+  currentEvent = signal<Event | null>(null);\n+  \n+  constructor() {\n+    // Subscribe to router events and update signal\n+    this.router.events.subscribe((event: Event) => {\n+      this.currentEvent.set(event);\n+    });\n+    \n+    // React to event changes with effect\n+    effect(() => {\n+      const event = this.currentEvent();\n+      if (event instanceof NavigationStart) {\n+        // Navigation starting\n+        console.log('Navigation starting:', event.url);\n+      }\n+      if (event instanceof NavigationEnd) {\n+        // Navigation completed\n+        console.log('Navigation completed:', event.url);\n+      }\n+    });\n+  }\n+}\n+```\n+\n+Note: The [`Event`](api/router/Event) type from `@angular/router` is named the same as the regular global [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) type, but it is different from the [`RouterEvent`](api/router/RouterEvent) type.\n+\n+## How to debug routing events\n+\n+Debugging router navigation issues can be challenging without visibility into the event sequence. Angular provides a built-in debugging feature that logs all router events to the console, helping you understand the navigation flow and identify where issues occur.\n+\n+When you need to inspect a Router event sequence, you can enable logging for internal navigation events for debugging. You can configure this by passing a configuration option (`withDebugTracing()`) that enables detailed console logging of all routing events.\n+\n+```ts\n+import { provideRouter, withDebugTracing } from '@angular/router';\n+\n+const appRoutes: Routes = [];\n+bootstrapApplication(AppComponent,\n+  {\n+    providers: [\n+      provideRouter(appRoutes, withDebugTracing())\n+    ]\n+  }\n+);\n+```\n+\n+For more information, check out the official docs on [`withDebugTracing`](api/router/withDebugTracing).\n+\n+## Common use cases\n+\n+Router events enable many practical features in real-world applications. Here are some common patterns that are used with router events.\n+\n+### Loading indicators\n+\n+Show loading indicators during navigation:\n+\n+```typescript\n+import { Component, inject } from '@angular/core';\n+import { Router } from '@angular/router';\n+import { toSignal } from '@angular/core/rxjs-interop';\n+import { map } from 'rxjs/operators';\n+\n+@Component({\n+  selector: 'app-loading',\n+  standalone: true,\n+  template: `\n+    @if (loading()) {\n+      <div class=\"loading-spinner\">Loading...</div>\n+    }\n+  `\n+})\n+export class AppComponent {\n+  private router = inject(Router);\n+  \n+  loading = toSignal(\n+    this.router.events.pipe(\n+      map(() => !!this.router.getCurrentNavigation())\n+    ),\n+    { initialValue: false }\n+  );\n+}\n+```\n+\n+### Analytics tracking\n+\n+Track page views for analytics:\n+\n+```typescript\n+import { Component, inject, signal, effect } from '@angular/core';\n+import { Router, NavigationEnd } from '@angular/router';\n+\n+@Component({\n+  selector: 'app-analytics',\n+  standalone: true,\n+  template: ''\n+})\n+export class AnalyticsComponent {\n+  private router = inject(Router);\n+  private currentUrl = signal<string | null>(null);\n+\n+  constructor() {\n+    this.router.events.subscribe(event => {\n+      if (event instanceof NavigationEnd) {\n+        this.currentUrl.set(event.url);\n+      }\n+    });\n+\n+    // Track page views when URL changes\n+    effect(() => {\n+      const url = this.currentUrl();\n+      if (url) {\n+        // Send page view to analytics\n+        this.analytics.trackPageView(url);\n+      }\n+    });\n+  }",
        "comment_created_at": "2025-07-07T18:20:22+00:00",
        "comment_author": "eneajaho",
        "comment_body": "Also as suggested above, we dont need to introduce a signal just for the sake of it. Instead we can do things inside the subscribe callback. \n\n```suggestion\n  private destroyRef = inject(DestroyRef);\n\n  startTracking() {\n    this.router.events.pipe(takeUntilDestroyed(this.destroyRef))\n      .subscribe(event => {\n        // Track page views when URL changes\n        if (event instanceof NavigationEnd) {\n           // Send page view to analytics\n          this.analytics.trackPageView(url);\n        }\n      });\n  }\n```",
        "pr_file_module": null
      }
    ]
  }
]