[
  {
    "discussion_id": "2139096793",
    "pr_number": 61993,
    "pr_file": "adev/src/content/guide/http/http-resource.md",
    "created_at": "2025-06-11T02:53:42+00:00",
    "commented_code": "+# Data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Fetching data is by nature an asynchronous task. You can use a [`Resource`](/api/core/resource) to perform any kind of async operation.\n+\n+<!-- mention reactive ?-->\n+\n+`httpResource` is built on top of the `resource` primitive and uses `HttpClient` as loader. It acts as a frontend for `@angular/common/http`. It makes HTTP requests through the Angular HTTP stack, including interceptors. \n+\n+## Reactive HTTP requests  \n+\n+`httpResource` makes a reactive HTTP request and exposes the request status and response value as a [`WritableResource`](/api/core/WritableResource). By default, it assumes that the backend will return JSON data. Like `resource`, it configures a reactive request. If any of the source signals in the request computation change, a new HTTP request will be made.\n+\n+You can define an http resource by returning a url: \n+\n+```ts\n+userId = input.required<string>();\n+\n+user = httpResource(() => `/api/user/${userId()}`); // A reactive function as argument\n+```\n+\n+IMPORTANT: `httpResource` differs from the `HttpClient` as it initiates the request eagerly (unlike the `HttpClient` `Observable`-based requests which must be subscribed).\n+\n+For more advanced requests, it is possible to define a request object similar to `HttpClient`\u2018s request.\n+\n+```ts\n+user = httpResource(() => ({\n+  url: `/api/user/${userId()}`,\n+  method: 'GET',\n+  headers: {\n+    'X-Special': 'true',\n+  },\n+  params: {\n+    'fast': 'yes',\n+  },\n+  reportProgress: true,\n+  withCredentials: true,\n+  transferCache: true,\n+}));\n+```\n+\n+While the resource pattern is meant only for retrieving asynchronous data, `httpResource` will allow any request method (like `POST` in the previous example). This still doesn\u2019t mean that you should be using `httpResource` to change data on the server. For instance, if you need to submit form data, use the `HttpClient` methods.\n+\n+### Response types \n+\n+An `httpResource` will return and parse the response as JSON but it is possible to use it for other return types.\n+\n+The API has multiple dedicated methods available for other response types:\n+\n+```ts\n+httpResource.text(() => ({ \u2026 })); // returns a string in value()\n+\n+httpResource.blob(() => ({ \u2026 })); // returns a Blob object in value()\n+\n+httpResource.arrayBuffer(() => ({ \u2026 })); // returns an ArrayBuffer in value()\n+```\n+\n+## Shape of an HttpResource\n+\n+An httpResource , similar to other `resource`, exposes several signals:\n+\n+- `value()` \u2014 which contains the result of the http request (when successful) and is programmatically overwritable\n+- `status()` \u2014 with the status of the resource (idle, loading, error etc)\n+- `error()` \u2014 with the request error / parsing error\n+- `isLoading()` \u2014 which is `true` while the request is pending\n+\n+It also includes dedicated signals for metadata about the response:\n+\n+- `\u200b\u200bheaders()` \u2014 with the response\u2019s headers\n+- `statusCode()` \u2014 with the response\u2019s status code\n+- `progress()` \u2014 with the progress of the request (if required in the request object)\n+\n+## Parsing typesafety \n+\n+When performing http requests you often want to ensure that the data we receive conforms the shape that we expect. This is commonly known as schema validation.\n+\n+In the JavaScript ecosystem it is common to reach out for battle-tested libraries like [Zod](https://zod.dev/) or [Valibot](https://valibot.dev/) for schema validation. `httpResource` offers direct integration for those libraries by using the `parse` parameter. The returned type of this parse function will provide the type to the resource itself, ensuring type safety alongside the schema validation.\n+\n+The following example uses Zod to parse and validate the response from the [StarWars API](https://swapi.dev/). The resource is then typed the same as the output type of Zod\u2019s parsing.\n+\n+```ts\n+export class AppComponent {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2139096793",
        "repo_full_name": "angular/angular",
        "pr_number": 61993,
        "pr_file": "adev/src/content/guide/http/http-resource.md",
        "discussion_id": "2139096793",
        "commented_code": "@@ -0,0 +1,126 @@\n+# Data fetching with `httpResource`\n+\n+IMPORTANT: `httpResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Fetching data is by nature an asynchronous task. You can use a [`Resource`](/api/core/resource) to perform any kind of async operation.\n+\n+<!-- mention reactive ?-->\n+\n+`httpResource` is built on top of the `resource` primitive and uses `HttpClient` as loader. It acts as a frontend for `@angular/common/http`. It makes HTTP requests through the Angular HTTP stack, including interceptors. \n+\n+## Reactive HTTP requests  \n+\n+`httpResource` makes a reactive HTTP request and exposes the request status and response value as a [`WritableResource`](/api/core/WritableResource). By default, it assumes that the backend will return JSON data. Like `resource`, it configures a reactive request. If any of the source signals in the request computation change, a new HTTP request will be made.\n+\n+You can define an http resource by returning a url: \n+\n+```ts\n+userId = input.required<string>();\n+\n+user = httpResource(() => `/api/user/${userId()}`); // A reactive function as argument\n+```\n+\n+IMPORTANT: `httpResource` differs from the `HttpClient` as it initiates the request eagerly (unlike the `HttpClient` `Observable`-based requests which must be subscribed).\n+\n+For more advanced requests, it is possible to define a request object similar to `HttpClient`\u2018s request.\n+\n+```ts\n+user = httpResource(() => ({\n+  url: `/api/user/${userId()}`,\n+  method: 'GET',\n+  headers: {\n+    'X-Special': 'true',\n+  },\n+  params: {\n+    'fast': 'yes',\n+  },\n+  reportProgress: true,\n+  withCredentials: true,\n+  transferCache: true,\n+}));\n+```\n+\n+While the resource pattern is meant only for retrieving asynchronous data, `httpResource` will allow any request method (like `POST` in the previous example). This still doesn\u2019t mean that you should be using `httpResource` to change data on the server. For instance, if you need to submit form data, use the `HttpClient` methods.\n+\n+### Response types \n+\n+An `httpResource` will return and parse the response as JSON but it is possible to use it for other return types.\n+\n+The API has multiple dedicated methods available for other response types:\n+\n+```ts\n+httpResource.text(() => ({ \u2026 })); // returns a string in value()\n+\n+httpResource.blob(() => ({ \u2026 })); // returns a Blob object in value()\n+\n+httpResource.arrayBuffer(() => ({ \u2026 })); // returns an ArrayBuffer in value()\n+```\n+\n+## Shape of an HttpResource\n+\n+An httpResource , similar to other `resource`, exposes several signals:\n+\n+- `value()` \u2014 which contains the result of the http request (when successful) and is programmatically overwritable\n+- `status()` \u2014 with the status of the resource (idle, loading, error etc)\n+- `error()` \u2014 with the request error / parsing error\n+- `isLoading()` \u2014 which is `true` while the request is pending\n+\n+It also includes dedicated signals for metadata about the response:\n+\n+- `\u200b\u200bheaders()` \u2014 with the response\u2019s headers\n+- `statusCode()` \u2014 with the response\u2019s status code\n+- `progress()` \u2014 with the progress of the request (if required in the request object)\n+\n+## Parsing typesafety \n+\n+When performing http requests you often want to ensure that the data we receive conforms the shape that we expect. This is commonly known as schema validation.\n+\n+In the JavaScript ecosystem it is common to reach out for battle-tested libraries like [Zod](https://zod.dev/) or [Valibot](https://valibot.dev/) for schema validation. `httpResource` offers direct integration for those libraries by using the `parse` parameter. The returned type of this parse function will provide the type to the resource itself, ensuring type safety alongside the schema validation.\n+\n+The following example uses Zod to parse and validate the response from the [StarWars API](https://swapi.dev/). The resource is then typed the same as the output type of Zod\u2019s parsing.\n+\n+```ts\n+export class AppComponent {",
        "comment_created_at": "2025-06-11T02:53:42+00:00",
        "comment_author": "jelbourn",
        "comment_body": "nit: I encourage folks to pick more specific names for examples (so maybe something like `CharacterViewer`?)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182089556",
    "pr_number": 62250,
    "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
    "created_at": "2025-07-03T07:40:48+00:00",
    "commented_code": "+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetailComponent,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetailComponent {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2182089556",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2182089556",
        "commented_code": "@@ -0,0 +1,202 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetailComponent,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetailComponent {",
        "comment_created_at": "2025-07-03T07:40:48+00:00",
        "comment_author": "geromegrignon",
        "comment_body": "remove Component suffix to match the style guide",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182089888",
    "pr_number": 62250,
    "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
    "created_at": "2025-07-03T07:40:57+00:00",
    "commented_code": "+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetailComponent,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetailComponent {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInput\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(AppComponent, {",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2182089888",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2182089888",
        "commented_code": "@@ -0,0 +1,202 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering\n+\n+## Creating a resolver\n+\n+You create a resolver by writing a function with the [`ResolveFn`](api/router/ResolveFn) type.\n+\n+It receives the [`ActivatedRouteSnapshot`](api/router/ActivatedRouteSnapshot) and [`RouterStateSnapshot`](api/router/RouterStateSnapshot) as default parameters.\n+\n+Here is a resolver that gets the user information before rendering a route using the [`inject`](api/core/inject) function:\n+\n+```ts\n+import { inject } from '@angular/core';\n+import { UserService, SettingsService } from './user-service';\n+import type { ActivatedRouteSnapshot, ResolveFn, RouterStateSnapshot } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+export const userResolver: ResolveFn<User> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const userService = inject(UserService);\n+  const userId = route.paramMap.get('id')!;\n+  return userService.getUser(userId);\n+};\n+\n+export const settingsResolver: ResolveFn<Settings> = (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => {\n+  const settingsService = inject(SettingsService);\n+  const userId = route.paramMap.get('id')!;\n+  return settingsService.getUserSettings(userId);\n+};\n+```\n+\n+## Configuring routes with resolvers\n+\n+When you want to add one or more data resolvers to a route, you can add it under the `resolve` key in the route configuration. The [`Routes`](api/router/Routes) type defines the structure for route configurations:\n+\n+```ts\n+import { Routes } from '@angular/router';\n+\n+export const routes: Routes = [\n+  {\n+    path: 'user/:id',\n+    component: UserDetailComponent,\n+    resolve: {\n+      user: userResolver,\n+      settings: settingsResolver\n+    }\n+  }\n+];\n+```\n+\n+You can learn more about the [`resolve` configuration in the API docs](api/router/Route#resolve).\n+\n+## Accessing resolved data in components\n+\n+### Using ActivatedRoute\n+\n+You can access the resolved data in a component by accessing the snapshot data from the [`ActivatedRoute`](api/router/ActivatedRoute) using the [`signal`](api/core/signal) function:\n+\n+```angular-ts\n+import { Component, inject, signal } from '@angular/core';\n+import { ActivatedRoute } from '@angular/router';\n+import type { User, Settings } from './types';\n+\n+@Component({\n+  template: `\n+    <h1>{{ user().name }}</h1>\n+    <p>{{ user().email }}</p>\n+    <div>Theme: {{ settings().theme }}</div>\n+  `\n+})\n+export class UserDetailComponent {\n+  private route = inject(ActivatedRoute);\n+  user = signal<User>(this.route.snapshot.data['user']);\n+  settings = signal<Settings>(this.route.snapshot.data['settings']);\n+}\n+```\n+\n+### Using withComponentInput\n+\n+A different approach to accessing the resolved data is to use [`withComponentInputBinding()`](api/router/withComponentInputBinding) when configuring your router with [`provideRouter`](api/router/provideRouter). This allows resolved data to be passed directly as component inputs:\n+\n+```ts\n+import { bootstrapApplication } from '@angular/platform-browser';\n+import { provideRouter, withComponentInputBinding } from '@angular/router';\n+import { routes } from './app.routes';\n+\n+bootstrapApplication(AppComponent, {",
        "comment_created_at": "2025-07-03T07:40:57+00:00",
        "comment_author": "geromegrignon",
        "comment_body": "remove Component suffix to match the style guide",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2271578954",
    "pr_number": 63125,
    "pr_file": "adev/src/content/ecosystem/rxjs-interop/signals-interop.md",
    "created_at": "2025-08-12T23:29:22+00:00",
    "commented_code": "```\n \n Here, only the last value (3) will be logged.\n+\n+## Using `rxResource` for async data\n+\n+IMPORTANT: `rxResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Angular's [`resource` function](/guide/signals/resource) gives you a way to incorporate async data into your application's signal-based code. Building on top of this pattern, `rxResource` lets you define a resource where the source of your data is defined in terms of an RxJS `Observable`. Instead of accepting a `loader` function, `rxResource` accepts a `stream` function that accepts an RxJS `Observable`.\n+\n+```typescript\n+import {Component, inject} from '@angular/core';\n+import {rxResource} from '@angular/core/rxjs-interop';\n+\n+@Component(/* ... */)\n+export class UserProfile {\n+  // This component relies on a service that exposes data through an RxJS Observable.\n+  private userData = inject(MyUserDataClient);\n+\n+  protected userId = input<string>();\n+\n+  private userResource = rxResource({\n+    params: () => this.userId(),\n+\n+    // The `stream` property expects a factory function that returns\n+    // a data steam as an RxJS Observable.\n+    stream: ({userId}) => this.userData.fetch(userId),",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2271578954",
        "repo_full_name": "angular/angular",
        "pr_number": 63125,
        "pr_file": "adev/src/content/ecosystem/rxjs-interop/signals-interop.md",
        "discussion_id": "2271578954",
        "commented_code": "@@ -102,3 +102,34 @@ mySignal.set(3);\n ```\n \n Here, only the last value (3) will be logged.\n+\n+## Using `rxResource` for async data\n+\n+IMPORTANT: `rxResource` is [experimental](reference/releases#experimental). It's ready for you to try, but it might change before it is stable.\n+\n+Angular's [`resource` function](/guide/signals/resource) gives you a way to incorporate async data into your application's signal-based code. Building on top of this pattern, `rxResource` lets you define a resource where the source of your data is defined in terms of an RxJS `Observable`. Instead of accepting a `loader` function, `rxResource` accepts a `stream` function that accepts an RxJS `Observable`.\n+\n+```typescript\n+import {Component, inject} from '@angular/core';\n+import {rxResource} from '@angular/core/rxjs-interop';\n+\n+@Component(/* ... */)\n+export class UserProfile {\n+  // This component relies on a service that exposes data through an RxJS Observable.\n+  private userData = inject(MyUserDataClient);\n+\n+  protected userId = input<string>();\n+\n+  private userResource = rxResource({\n+    params: () => this.userId(),\n+\n+    // The `stream` property expects a factory function that returns\n+    // a data steam as an RxJS Observable.\n+    stream: ({userId}) => this.userData.fetch(userId),",
        "comment_created_at": "2025-08-12T23:29:22+00:00",
        "comment_author": "JeanMeche",
        "comment_body": "```suggestion\r\n    stream: ({userId}) => this.userData.load(userId),\r\n```\r\nI find `fetch` a bit to load bearing as a method name. It almost got me thinking if rxResource also supports Promises here (which it doesn't). Can we maybe have a less \"ambigous\" method name ? ",
        "pr_file_module": null
      }
    ]
  }
]