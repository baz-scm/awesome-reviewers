[
  {
    "discussion_id": "2238602810",
    "pr_number": 62859,
    "pr_file": "adev/src/content/guide/routing/rendering-strategies.md",
    "created_at": "2025-07-29T05:50:01+00:00",
    "commented_code": "+# Rendering strategies in Angular\n+\n+Angular provides flexible rendering strategies that allow you to optimize different parts of your application based on their specific requirements. You can configure rendering strategies at the [route level](guide/routing/define-routes), giving you fine-grained control over how content is delivered to users.\n+\n+This guide takes a progressive approach, starting with Angular's default client-side rendering and building up to more advanced server-side and hybrid strategies.\n+\n+## What are rendering strategies?\n+\n+Rendering strategies determine when and where your Angular application's HTML content is generated. Each strategy offers different trade-offs between initial page load performance, interactivity, SEO capabilities, and server resource usage.\n+\n+Angular supports three primary rendering strategies:\n+\n+- **Client-Side Rendering (CSR)** - Content is rendered entirely in the browser\n+- **Static Site Generation (SSG/Prerendering)** - Content is pre-rendered at build time\n+- **Server-Side Rendering (SSR)** - Content is rendered on the server for each request\n+\n+## Client-Side Rendering (CSR) - The Default\n+\n+**CSR is Angular's default rendering strategy.** When you create a new Angular application with [`ng new`](tools/cli/new), all [routes](guide/routing/define-routes) automatically use client-side rendering without any additional configuration.\n+\n+### How CSR works\n+\n+With your standard `app.routes.ts` file:\n+\n+```typescript\n+import { Routes } from '@angular/router';\n+import { HomeComponent } from './home';\n+import { AboutComponent } from './about';\n+import { ProductListComponent } from './product-list';\n+\n+export const routes: Routes = [\n+  { path: '', component: HomeComponent },\n+  { path: 'about', component: AboutComponent },\n+  { path: 'products', component: ProductListComponent },\n+  { path: '**', redirectTo: '/' }\n+];\n+```\n+\n+All these routes automatically use CSR. Here's what happens:\n+\n+1. The browser downloads the initial HTML shell\n+2. JavaScript bundles are loaded and executed\n+3. Angular bootstraps and renders the application\n+4. The DOM is created and managed entirely on the client\n+5. [Navigation between routes](guide/routing/navigate-to-routes) happens instantly without page reloads\n+\n+### When CSR works well\n+\n+CSR is ideal for:\n+\n+- **Interactive applications** with complex user interfaces\n+- **Real-time applications** that need frequent updates\n+- **Dashboard-style applications** with heavy client-side state\n+- **Single-page applications** where navigation speed is crucial\n+- **Applications where SEO isn't critical** (internal tools, admin panels)\n+\n+### CSR characteristics\n+\n+| Aspect                  | Details                                                |\n+| :---------------------- | :----------------------------------------------------- |\n+| **SEO**                 | Limited - slower indexing, may miss dynamic content |\n+| **Initial load**        | Slower - requires JavaScript download and execution    |\n+| **Interactivity**       | Immediate once loaded                                  |\n+| **Server requirements** | Minimal - only serves static assets                    |\n+| **Caching**             | Excellent for static assets                            |\n+| **Setup complexity**    | None - works out of the box                            |\n+\n+### Deploying CSR applications\n+\n+CSR applications can be deployed to any static hosting service. Configure your `angular.json` for static deployment:\n+\n+```json\n+{\n+  \"projects\": {\n+    \"my-app\": {\n+      \"architect\": {\n+        \"build\": {\n+          \"options\": {\n+            \"outputMode\": \"static\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+## Adding Static Site Generation (SSG)\n+\n+As your application grows, you might want to **improve SEO and performance for static content** like marketing pages, blogs, or documentation. This is where Static Site Generation (SSG) comes in.\n+\n+### Setting up SSG\n+\n+First, add Angular SSR support to your project:\n+\n+```bash\n+ng add @angular/ssr\n+```\n+\n+This command adds the necessary dependencies and creates server-side configuration files.\n+\n+### How SSG works\n+\n+SSG pre-renders HTML content at build time. Angular creates static HTML files during the build process rather than generating pages when users request them.\n+\n+To configure SSG, create an `app.routes.server.ts` file that defines [`ServerRoute`](api/ssr/ServerRoute) configurations:\n+\n+```typescript\n+import { RenderMode, ServerRoute } from '@angular/ssr';\n+\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: '',\n+    renderMode: RenderMode.Prerender, // Homepage as static HTML\n+  },\n+  {\n+    path: 'about',\n+    renderMode: RenderMode.Prerender, // About page as static HTML\n+  },\n+  {\n+    path: 'blog',\n+    renderMode: RenderMode.Prerender, // Blog listing as static HTML\n+  },\n+];\n+```\n+\n+### Building with SSG\n+\n+Generate static files using the [Angular CLI](tools/cli):\n+\n+```bash\n+ng build --prerender\n+```\n+\n+This creates static HTML files for each specified route in your `dist/` folder.\n+\n+### Dynamic routes with SSG\n+\n+For [routes with parameters](guide/routing/define-routes#define-url-paths-with-route-parameters) (like blog posts), use `getPrerenderParams`:\n+\n+```typescript\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: 'blog/:slug',\n+    renderMode: RenderMode.Prerender,\n+    getPrerenderParams: async () => {\n+      // Fetch your blog posts at build time\n+      const posts = await fetch('https://api.myblog.com/posts').then(res => res.json());\n+      return posts.map(post => ({ slug: post.slug }));\n+    },\n+  },\n+];\n+```\n+\n+This generates static HTML files for each blog post: `blog/first-post/index.html`, `blog/second-post/index.html`, etc.\n+\n+### SSG characteristics\n+\n+| Aspect                  | Details                                       |\n+| :---------------------- | :-------------------------------------------- |\n+| **SEO**                 | Excellent - static HTML available immediately |\n+| **Initial load**        | Very fast - pre-generated content             |\n+| **Interactivity**       | Immediate after hydration                     |\n+| **Server requirements** | Minimal - serves static files                 |\n+| **Build time**          | Longer - generates all routes at build time   |\n+| **Content freshness**   | Updated only when you rebuild                 |\n+\n+### When to use SSG\n+\n+SSG is perfect for:\n+\n+- **Marketing pages** that rarely change\n+- **Blog posts and articles**\n+- **Documentation sites**\n+- **Product catalogs** with stable content\n+- **Landing pages** that need excellent SEO\n+\n+## Adding Server-Side Rendering (SSR)\n+\n+For **dynamic, personalized content** that still needs good SEO, Server-Side Rendering (SSR) is the solution. SSR is more complex than CSR or SSG because it requires a server to generate HTML for each request.\n+\n+### How SSR works\n+\n+With SSR, Angular runs on the server for each request:\n+\n+```typescript\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: 'profile',\n+    renderMode: RenderMode.Server, // Generated fresh for each request\n+  },\n+  {\n+    path: 'products/:id',\n+    renderMode: RenderMode.Server, // Dynamic product pages\n+  },\n+];\n+```\n+\n+The SSR process:\n+\n+1. User requests a page\n+2. Server receives the request\n+3. Angular renders the application on the server\n+4. Fully-formed HTML is sent to the browser\n+5. Page is visible immediately\n+6. Angular hydrates the client-side application for interactivity\n+\n+### Server-side data access\n+\n+SSR allows you to execute server-only logic and pass data to your [components](essentials/components):\n+\n+```typescript\n+import { ChangeDetectionStrategy, Component, computed, inject, PLATFORM_ID, signal } from '@angular/core';\n+import { isPlatformServer } from '@angular/common';\n+import { TransferState, makeStateKey } from '@angular/platform-browser';\n+\n+const SERVER_DATA_KEY = makeStateKey<{ time: string }>('serverData');\n+\n+@Component({\n+  selector: 'app-profile',\n+  changeDetection: ChangeDetectionStrategy.OnPush,\n+  template: `\n+    <div>\n+      <h1>User Profile</h1>\n+      <p>Rendered on: {{ renderLocation() }}</p>\n+      <p>Server time: {{ serverTime() }}</p>\n+    </div>\n+  `,\n+})\n+export class ProfileComponent {\n+  private readonly platformId = inject(PLATFORM_ID);\n+  private readonly transferState = inject(TransferState);\n+\n+  protected readonly renderLocation = computed(() => \n+    isPlatformServer(this.platformId) ? 'Server' : 'Client'\n+  );\n+  \n+  protected readonly serverTime = signal(this.initializeServerTime());\n+\n+  private initializeServerTime(): string {\n+    if (isPlatformServer(this.platformId)) {\n+      const time = new Date().toISOString();\n+      this.transferState.set(SERVER_DATA_KEY, { time });\n+      return time;\n+    } else {\n+      const data = this.transferState.get(SERVER_DATA_KEY, { time: 'Unknown' });\n+      return data.time;\n+    }\n+  }\n+}\n+```\n+\n+### Building and serving SSR\n+\n+Build your application with SSR using this command:\n+\n+```bash\n+ng build --ssr\n+```\n+\n+This creates both static assets and server files. You'll need a Node.js server to serve the application.\n+\n+### SSR characteristics\n+\n+| Aspect                  | Details                                             |\n+| :---------------------- | :-------------------------------------------------- |\n+| **SEO**                 | Excellent - full HTML content available to crawlers |\n+| **Initial load**        | Fast - content visible immediately                  |\n+| **Interactivity**       | Delayed until hydration completes                   |\n+| **Server requirements** | Higher - needs Node.js server for rendering         |\n+| **Personalization**     | Full access to request context and user data        |\n+| **Scalability**         | Requires more server resources                      |\n+\n+### When to use SSR\n+\n+SSR is ideal for:\n+\n+- **User dashboards** that need personalization and SEO\n+- **E-commerce product pages** with dynamic pricing\n+- **Social media feeds** with personalized content\n+- **News sites** with frequently updated content\n+- **Any dynamic content** that needs search engine visibility\n+\n+## Hybrid Rendering - Mixing Strategies\n+\n+The real power of Angular's rendering strategies comes from **combining different approaches** for different parts of your application. This is called hybrid rendering.\n+\n+### Example hybrid application\n+\n+Here's how you might configure a complete application:\n+\n+```typescript\n+import { inject } from '@angular/core';\n+import { RenderMode, ServerRoute, PrerenderFallback } from '@angular/ssr';\n+\n+export const serverRoutes: ServerRoute[] = [\n+  // Marketing pages - Fast, SEO-optimized static content\n+  { path: '', renderMode: RenderMode.Prerender },\n+  { path: 'about', renderMode: RenderMode.Prerender },\n+  { path: 'pricing', renderMode: RenderMode.Prerender },\n+\n+  // Blog - Static content with fallback for new posts\n+  {\n+    path: 'blog/:slug',\n+    renderMode: RenderMode.Prerender,\n+    fallback: PrerenderFallback.Server, // SSR for new posts\n+    getPrerenderParams: async () => {\n+      const dataService = inject(PostService);\n+      const posts = await dataService.getFeaturedPosts();\n+      return posts.map(post => ({ slug: post.slug }));\n+    },\n+  },\n+\n+  // Product catalog - Dynamic content with SEO requirements\n+  { path: 'products', renderMode: RenderMode.Server },\n+  { path: 'products/:id', renderMode: RenderMode.Server },\n+\n+  // User areas - Interactive, personalized content\n+  { path: 'dashboard', renderMode: RenderMode.Client },\n+  { path: 'admin', renderMode: RenderMode.Client },\n+  { path: 'profile', renderMode: RenderMode.Server }, // Personalized but needs SEO\n+\n+  // Default fallback\n+  { path: '**', renderMode: RenderMode.Server },\n+];\n+```\n+\n+### Configuring server routes\n+\n+Add this configuration to your application using [`provideServerRendering`](api/ssr/provideServerRendering) with [`withRoutes`](api/ssr/withRoutes):\n+\n+```typescript\n+import { provideServerRendering, withRoutes } from '@angular/ssr';\n+import { serverRoutes } from './app.routes.server';\n+\n+// app.config.server.ts\n+const serverConfig: ApplicationConfig = {\n+  providers: [\n+    provideServerRendering(withRoutes(serverRoutes)),\n+    // ... other providers ...\n+  ]\n+};\n+```\n+\n+### Fallback strategies\n+\n+When using SSG, you can configure fallback behavior for routes that weren't pre-rendered using [`PrerenderFallback`](api/ssr/PrerenderFallback):\n+\n+| Fallback                   | Behavior                              |\n+| :------------------------- | :------------------------------------ |\n+| `PrerenderFallback.Server` | Use SSR for non-prerendered routes    |\n+| `PrerenderFallback.Client` | Use CSR for non-prerendered routes    |\n+| `PrerenderFallback.None`   | Return 404 for non-prerendered routes |\n+\n+### Choosing the right strategy for each route\n+\n+Consider these factors when deciding on rendering strategies:\n+\n+**Use CSR when:**\n+\n+- Interactivity is more important than initial load time\n+- SEO is not required\n+- Content is highly dynamic or user-specific\n+- You need real-time updates\n+\n+**Use SSG when:**\n+\n+- Content is mostly static\n+- SEO is critical\n+- You want the fastest possible load times\n+- Content doesn't change frequently\n+\n+**Use SSR when:**\n+\n+- You need both SEO and dynamic content\n+- Content is personalized but still needs search visibility\n+- You have frequently changing content that needs to be indexed\n+\n+## Hydration strategies\n+\n+When using SSR or SSG, Angular needs to \"hydrate\" the server-rendered HTML on the client side to make it interactive.\n+\n+### Full hydration\n+\n+The default strategy where the entire application is hydrated at once using [`provideClientHydration`](api/platform-browser/provideClientHydration):\n+\n+```typescript\n+import { provideClientHydration } from '@angular/platform-browser';\n+\n+export const appConfig = {\n+  providers: [\n+    provideClientHydration(),\n+    // other providers...\n+  ],\n+};\n+```\n+\n+### Incremental hydration\n+\n+Hydrate specific parts of the application when needed using [`withIncrementalHydration`](api/platform-browser/withIncrementalHydration):\n+\n+```typescript\n+import { provideClientHydration, withIncrementalHydration } from '@angular/platform-browser';\n+\n+export const appConfig = {\n+  providers: [\n+    provideClientHydration(withIncrementalHydration()),\n+    // other providers...\n+  ],\n+};\n+```\n+\n+Use [`@defer` blocks](guide/defer) to control when hydration occurs:\n+\n+```typescript\n+import { ChangeDetectionStrategy, Component } from '@angular/core';\n+\n+@Component({\n+  changeDetection: ChangeDetectionStrategy.OnPush,\n+  template: `\n+    <header>Static header content</header>\n+\n+    @defer (on interaction) {\n+      <interactive-widget />\n+    } @placeholder {\n+      <div>Loading widget...</div>\n+    }\n+\n+    <footer>Static footer content</footer>\n+  `,\n+})\n+export class PageComponent {}\n+```\n+\n+### Event replay\n+\n+Preserve user interactions during hydration using [`withEventReplay`](api/platform-browser/withEventReplay):\n+\n+```typescript\n+import { provideClientHydration, withEventReplay } from '@angular/platform-browser';\n+\n+export const appConfig = {\n+  providers: [\n+    provideClientHydration(withEventReplay()),\n+    // other providers...\n+  ],\n+};\n+```\n+\n+## Build configuration\n+\n+Configure different rendering strategies at build time:\n+\n+### Development\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"dev\": \"ng serve\",\n+    \"dev:ssr\": \"ng serve --ssr\"\n+  }\n+}\n+```\n+\n+### Production builds\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"build\": \"ng build\",\n+    \"build:ssr\": \"ng build --ssr\",\n+    \"build:prerender\": \"ng build --prerender\"\n+  }\n+}\n+```\n+\n+### Output modes\n+\n+Configure the build output format in `angular.json`:\n+\n+```json\n+{\n+  \"projects\": {\n+    \"my-app\": {\n+      \"architect\": {\n+        \"build\": {\n+          \"options\": {\n+            \"outputMode\": \"static\" // or \"server\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+| Mode       | Description                                      |\n+| :--------- | :----------------------------------------------- |\n+| `\"static\"` | Generates static files only (no server required) |\n+| `\"server\"` | Generates both static assets and server files    |\n+\n+## Performance considerations\n+\n+### Bundle size optimization\n+\n+Different strategies affect bundle size:\n+\n+- **CSR**: Full application bundle loaded upfront\n+- **SSR**: Initial bundle can be smaller with code splitting\n+- **SSG**: Optimal with incremental hydration and `@defer`",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2238602810",
        "repo_full_name": "angular/angular",
        "pr_number": 62859,
        "pr_file": "adev/src/content/guide/routing/rendering-strategies.md",
        "discussion_id": "2238602810",
        "commented_code": "@@ -0,0 +1,558 @@\n+# Rendering strategies in Angular\n+\n+Angular provides flexible rendering strategies that allow you to optimize different parts of your application based on their specific requirements. You can configure rendering strategies at the [route level](guide/routing/define-routes), giving you fine-grained control over how content is delivered to users.\n+\n+This guide takes a progressive approach, starting with Angular's default client-side rendering and building up to more advanced server-side and hybrid strategies.\n+\n+## What are rendering strategies?\n+\n+Rendering strategies determine when and where your Angular application's HTML content is generated. Each strategy offers different trade-offs between initial page load performance, interactivity, SEO capabilities, and server resource usage.\n+\n+Angular supports three primary rendering strategies:\n+\n+- **Client-Side Rendering (CSR)** - Content is rendered entirely in the browser\n+- **Static Site Generation (SSG/Prerendering)** - Content is pre-rendered at build time\n+- **Server-Side Rendering (SSR)** - Content is rendered on the server for each request\n+\n+## Client-Side Rendering (CSR) - The Default\n+\n+**CSR is Angular's default rendering strategy.** When you create a new Angular application with [`ng new`](tools/cli/new), all [routes](guide/routing/define-routes) automatically use client-side rendering without any additional configuration.\n+\n+### How CSR works\n+\n+With your standard `app.routes.ts` file:\n+\n+```typescript\n+import { Routes } from '@angular/router';\n+import { HomeComponent } from './home';\n+import { AboutComponent } from './about';\n+import { ProductListComponent } from './product-list';\n+\n+export const routes: Routes = [\n+  { path: '', component: HomeComponent },\n+  { path: 'about', component: AboutComponent },\n+  { path: 'products', component: ProductListComponent },\n+  { path: '**', redirectTo: '/' }\n+];\n+```\n+\n+All these routes automatically use CSR. Here's what happens:\n+\n+1. The browser downloads the initial HTML shell\n+2. JavaScript bundles are loaded and executed\n+3. Angular bootstraps and renders the application\n+4. The DOM is created and managed entirely on the client\n+5. [Navigation between routes](guide/routing/navigate-to-routes) happens instantly without page reloads\n+\n+### When CSR works well\n+\n+CSR is ideal for:\n+\n+- **Interactive applications** with complex user interfaces\n+- **Real-time applications** that need frequent updates\n+- **Dashboard-style applications** with heavy client-side state\n+- **Single-page applications** where navigation speed is crucial\n+- **Applications where SEO isn't critical** (internal tools, admin panels)\n+\n+### CSR characteristics\n+\n+| Aspect                  | Details                                                |\n+| :---------------------- | :----------------------------------------------------- |\n+| **SEO**                 | Limited - slower indexing, may miss dynamic content |\n+| **Initial load**        | Slower - requires JavaScript download and execution    |\n+| **Interactivity**       | Immediate once loaded                                  |\n+| **Server requirements** | Minimal - only serves static assets                    |\n+| **Caching**             | Excellent for static assets                            |\n+| **Setup complexity**    | None - works out of the box                            |\n+\n+### Deploying CSR applications\n+\n+CSR applications can be deployed to any static hosting service. Configure your `angular.json` for static deployment:\n+\n+```json\n+{\n+  \"projects\": {\n+    \"my-app\": {\n+      \"architect\": {\n+        \"build\": {\n+          \"options\": {\n+            \"outputMode\": \"static\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+## Adding Static Site Generation (SSG)\n+\n+As your application grows, you might want to **improve SEO and performance for static content** like marketing pages, blogs, or documentation. This is where Static Site Generation (SSG) comes in.\n+\n+### Setting up SSG\n+\n+First, add Angular SSR support to your project:\n+\n+```bash\n+ng add @angular/ssr\n+```\n+\n+This command adds the necessary dependencies and creates server-side configuration files.\n+\n+### How SSG works\n+\n+SSG pre-renders HTML content at build time. Angular creates static HTML files during the build process rather than generating pages when users request them.\n+\n+To configure SSG, create an `app.routes.server.ts` file that defines [`ServerRoute`](api/ssr/ServerRoute) configurations:\n+\n+```typescript\n+import { RenderMode, ServerRoute } from '@angular/ssr';\n+\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: '',\n+    renderMode: RenderMode.Prerender, // Homepage as static HTML\n+  },\n+  {\n+    path: 'about',\n+    renderMode: RenderMode.Prerender, // About page as static HTML\n+  },\n+  {\n+    path: 'blog',\n+    renderMode: RenderMode.Prerender, // Blog listing as static HTML\n+  },\n+];\n+```\n+\n+### Building with SSG\n+\n+Generate static files using the [Angular CLI](tools/cli):\n+\n+```bash\n+ng build --prerender\n+```\n+\n+This creates static HTML files for each specified route in your `dist/` folder.\n+\n+### Dynamic routes with SSG\n+\n+For [routes with parameters](guide/routing/define-routes#define-url-paths-with-route-parameters) (like blog posts), use `getPrerenderParams`:\n+\n+```typescript\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: 'blog/:slug',\n+    renderMode: RenderMode.Prerender,\n+    getPrerenderParams: async () => {\n+      // Fetch your blog posts at build time\n+      const posts = await fetch('https://api.myblog.com/posts').then(res => res.json());\n+      return posts.map(post => ({ slug: post.slug }));\n+    },\n+  },\n+];\n+```\n+\n+This generates static HTML files for each blog post: `blog/first-post/index.html`, `blog/second-post/index.html`, etc.\n+\n+### SSG characteristics\n+\n+| Aspect                  | Details                                       |\n+| :---------------------- | :-------------------------------------------- |\n+| **SEO**                 | Excellent - static HTML available immediately |\n+| **Initial load**        | Very fast - pre-generated content             |\n+| **Interactivity**       | Immediate after hydration                     |\n+| **Server requirements** | Minimal - serves static files                 |\n+| **Build time**          | Longer - generates all routes at build time   |\n+| **Content freshness**   | Updated only when you rebuild                 |\n+\n+### When to use SSG\n+\n+SSG is perfect for:\n+\n+- **Marketing pages** that rarely change\n+- **Blog posts and articles**\n+- **Documentation sites**\n+- **Product catalogs** with stable content\n+- **Landing pages** that need excellent SEO\n+\n+## Adding Server-Side Rendering (SSR)\n+\n+For **dynamic, personalized content** that still needs good SEO, Server-Side Rendering (SSR) is the solution. SSR is more complex than CSR or SSG because it requires a server to generate HTML for each request.\n+\n+### How SSR works\n+\n+With SSR, Angular runs on the server for each request:\n+\n+```typescript\n+export const serverRoutes: ServerRoute[] = [\n+  {\n+    path: 'profile',\n+    renderMode: RenderMode.Server, // Generated fresh for each request\n+  },\n+  {\n+    path: 'products/:id',\n+    renderMode: RenderMode.Server, // Dynamic product pages\n+  },\n+];\n+```\n+\n+The SSR process:\n+\n+1. User requests a page\n+2. Server receives the request\n+3. Angular renders the application on the server\n+4. Fully-formed HTML is sent to the browser\n+5. Page is visible immediately\n+6. Angular hydrates the client-side application for interactivity\n+\n+### Server-side data access\n+\n+SSR allows you to execute server-only logic and pass data to your [components](essentials/components):\n+\n+```typescript\n+import { ChangeDetectionStrategy, Component, computed, inject, PLATFORM_ID, signal } from '@angular/core';\n+import { isPlatformServer } from '@angular/common';\n+import { TransferState, makeStateKey } from '@angular/platform-browser';\n+\n+const SERVER_DATA_KEY = makeStateKey<{ time: string }>('serverData');\n+\n+@Component({\n+  selector: 'app-profile',\n+  changeDetection: ChangeDetectionStrategy.OnPush,\n+  template: `\n+    <div>\n+      <h1>User Profile</h1>\n+      <p>Rendered on: {{ renderLocation() }}</p>\n+      <p>Server time: {{ serverTime() }}</p>\n+    </div>\n+  `,\n+})\n+export class ProfileComponent {\n+  private readonly platformId = inject(PLATFORM_ID);\n+  private readonly transferState = inject(TransferState);\n+\n+  protected readonly renderLocation = computed(() => \n+    isPlatformServer(this.platformId) ? 'Server' : 'Client'\n+  );\n+  \n+  protected readonly serverTime = signal(this.initializeServerTime());\n+\n+  private initializeServerTime(): string {\n+    if (isPlatformServer(this.platformId)) {\n+      const time = new Date().toISOString();\n+      this.transferState.set(SERVER_DATA_KEY, { time });\n+      return time;\n+    } else {\n+      const data = this.transferState.get(SERVER_DATA_KEY, { time: 'Unknown' });\n+      return data.time;\n+    }\n+  }\n+}\n+```\n+\n+### Building and serving SSR\n+\n+Build your application with SSR using this command:\n+\n+```bash\n+ng build --ssr\n+```\n+\n+This creates both static assets and server files. You'll need a Node.js server to serve the application.\n+\n+### SSR characteristics\n+\n+| Aspect                  | Details                                             |\n+| :---------------------- | :-------------------------------------------------- |\n+| **SEO**                 | Excellent - full HTML content available to crawlers |\n+| **Initial load**        | Fast - content visible immediately                  |\n+| **Interactivity**       | Delayed until hydration completes                   |\n+| **Server requirements** | Higher - needs Node.js server for rendering         |\n+| **Personalization**     | Full access to request context and user data        |\n+| **Scalability**         | Requires more server resources                      |\n+\n+### When to use SSR\n+\n+SSR is ideal for:\n+\n+- **User dashboards** that need personalization and SEO\n+- **E-commerce product pages** with dynamic pricing\n+- **Social media feeds** with personalized content\n+- **News sites** with frequently updated content\n+- **Any dynamic content** that needs search engine visibility\n+\n+## Hybrid Rendering - Mixing Strategies\n+\n+The real power of Angular's rendering strategies comes from **combining different approaches** for different parts of your application. This is called hybrid rendering.\n+\n+### Example hybrid application\n+\n+Here's how you might configure a complete application:\n+\n+```typescript\n+import { inject } from '@angular/core';\n+import { RenderMode, ServerRoute, PrerenderFallback } from '@angular/ssr';\n+\n+export const serverRoutes: ServerRoute[] = [\n+  // Marketing pages - Fast, SEO-optimized static content\n+  { path: '', renderMode: RenderMode.Prerender },\n+  { path: 'about', renderMode: RenderMode.Prerender },\n+  { path: 'pricing', renderMode: RenderMode.Prerender },\n+\n+  // Blog - Static content with fallback for new posts\n+  {\n+    path: 'blog/:slug',\n+    renderMode: RenderMode.Prerender,\n+    fallback: PrerenderFallback.Server, // SSR for new posts\n+    getPrerenderParams: async () => {\n+      const dataService = inject(PostService);\n+      const posts = await dataService.getFeaturedPosts();\n+      return posts.map(post => ({ slug: post.slug }));\n+    },\n+  },\n+\n+  // Product catalog - Dynamic content with SEO requirements\n+  { path: 'products', renderMode: RenderMode.Server },\n+  { path: 'products/:id', renderMode: RenderMode.Server },\n+\n+  // User areas - Interactive, personalized content\n+  { path: 'dashboard', renderMode: RenderMode.Client },\n+  { path: 'admin', renderMode: RenderMode.Client },\n+  { path: 'profile', renderMode: RenderMode.Server }, // Personalized but needs SEO\n+\n+  // Default fallback\n+  { path: '**', renderMode: RenderMode.Server },\n+];\n+```\n+\n+### Configuring server routes\n+\n+Add this configuration to your application using [`provideServerRendering`](api/ssr/provideServerRendering) with [`withRoutes`](api/ssr/withRoutes):\n+\n+```typescript\n+import { provideServerRendering, withRoutes } from '@angular/ssr';\n+import { serverRoutes } from './app.routes.server';\n+\n+// app.config.server.ts\n+const serverConfig: ApplicationConfig = {\n+  providers: [\n+    provideServerRendering(withRoutes(serverRoutes)),\n+    // ... other providers ...\n+  ]\n+};\n+```\n+\n+### Fallback strategies\n+\n+When using SSG, you can configure fallback behavior for routes that weren't pre-rendered using [`PrerenderFallback`](api/ssr/PrerenderFallback):\n+\n+| Fallback                   | Behavior                              |\n+| :------------------------- | :------------------------------------ |\n+| `PrerenderFallback.Server` | Use SSR for non-prerendered routes    |\n+| `PrerenderFallback.Client` | Use CSR for non-prerendered routes    |\n+| `PrerenderFallback.None`   | Return 404 for non-prerendered routes |\n+\n+### Choosing the right strategy for each route\n+\n+Consider these factors when deciding on rendering strategies:\n+\n+**Use CSR when:**\n+\n+- Interactivity is more important than initial load time\n+- SEO is not required\n+- Content is highly dynamic or user-specific\n+- You need real-time updates\n+\n+**Use SSG when:**\n+\n+- Content is mostly static\n+- SEO is critical\n+- You want the fastest possible load times\n+- Content doesn't change frequently\n+\n+**Use SSR when:**\n+\n+- You need both SEO and dynamic content\n+- Content is personalized but still needs search visibility\n+- You have frequently changing content that needs to be indexed\n+\n+## Hydration strategies\n+\n+When using SSR or SSG, Angular needs to \"hydrate\" the server-rendered HTML on the client side to make it interactive.\n+\n+### Full hydration\n+\n+The default strategy where the entire application is hydrated at once using [`provideClientHydration`](api/platform-browser/provideClientHydration):\n+\n+```typescript\n+import { provideClientHydration } from '@angular/platform-browser';\n+\n+export const appConfig = {\n+  providers: [\n+    provideClientHydration(),\n+    // other providers...\n+  ],\n+};\n+```\n+\n+### Incremental hydration\n+\n+Hydrate specific parts of the application when needed using [`withIncrementalHydration`](api/platform-browser/withIncrementalHydration):\n+\n+```typescript\n+import { provideClientHydration, withIncrementalHydration } from '@angular/platform-browser';\n+\n+export const appConfig = {\n+  providers: [\n+    provideClientHydration(withIncrementalHydration()),\n+    // other providers...\n+  ],\n+};\n+```\n+\n+Use [`@defer` blocks](guide/defer) to control when hydration occurs:\n+\n+```typescript\n+import { ChangeDetectionStrategy, Component } from '@angular/core';\n+\n+@Component({\n+  changeDetection: ChangeDetectionStrategy.OnPush,\n+  template: `\n+    <header>Static header content</header>\n+\n+    @defer (on interaction) {\n+      <interactive-widget />\n+    } @placeholder {\n+      <div>Loading widget...</div>\n+    }\n+\n+    <footer>Static footer content</footer>\n+  `,\n+})\n+export class PageComponent {}\n+```\n+\n+### Event replay\n+\n+Preserve user interactions during hydration using [`withEventReplay`](api/platform-browser/withEventReplay):\n+\n+```typescript\n+import { provideClientHydration, withEventReplay } from '@angular/platform-browser';\n+\n+export const appConfig = {\n+  providers: [\n+    provideClientHydration(withEventReplay()),\n+    // other providers...\n+  ],\n+};\n+```\n+\n+## Build configuration\n+\n+Configure different rendering strategies at build time:\n+\n+### Development\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"dev\": \"ng serve\",\n+    \"dev:ssr\": \"ng serve --ssr\"\n+  }\n+}\n+```\n+\n+### Production builds\n+\n+```json\n+{\n+  \"scripts\": {\n+    \"build\": \"ng build\",\n+    \"build:ssr\": \"ng build --ssr\",\n+    \"build:prerender\": \"ng build --prerender\"\n+  }\n+}\n+```\n+\n+### Output modes\n+\n+Configure the build output format in `angular.json`:\n+\n+```json\n+{\n+  \"projects\": {\n+    \"my-app\": {\n+      \"architect\": {\n+        \"build\": {\n+          \"options\": {\n+            \"outputMode\": \"static\" // or \"server\"\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+```\n+\n+| Mode       | Description                                      |\n+| :--------- | :----------------------------------------------- |\n+| `\"static\"` | Generates static files only (no server required) |\n+| `\"server\"` | Generates both static assets and server files    |\n+\n+## Performance considerations\n+\n+### Bundle size optimization\n+\n+Different strategies affect bundle size:\n+\n+- **CSR**: Full application bundle loaded upfront\n+- **SSR**: Initial bundle can be smaller with code splitting\n+- **SSG**: Optimal with incremental hydration and `@defer`",
        "comment_created_at": "2025-07-29T05:50:01+00:00",
        "comment_author": "jnizet",
        "comment_body": "I might be missing something, but I don't see how SSR/SSG affects the bundle size. What affects the bundle size is lazy loading, isn't it? And lazy loading isn't affected by SSR/SSG.\r\nDeferred hydration I guess can impact bundle size, but I don't see why it would be different between SSR and SSG.\r\nThis section is too light to be really helpful, IMHO. I would skip it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2256377698",
    "pr_number": 62859,
    "pr_file": "adev/src/content/guide/routing/rendering-strategies.md",
    "created_at": "2025-08-06T08:33:27+00:00",
    "commented_code": "+# Rendering strategies in Angular\n+\n+This guide helps you choose the right rendering strategy for different parts of your Angular application. Each strategy offers different trade-offs between performance, SEO, and complexity.\n+\n+## What are rendering strategies?\n+\n+Rendering strategies determine when and where your Angular application's HTML content is generated. Each strategy offers different trade-offs between initial page load performance, interactivity, SEO capabilities, and server resource usage.\n+\n+Angular supports three primary rendering strategies:\n+\n+- **Client-Side Rendering (CSR)** - Content is rendered entirely in the browser\n+- **Static Site Generation (SSG/Prerendering)** - Content is pre-rendered at build time\n+- **Server-Side Rendering (SSR)** - Content is rendered on the server for each request",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2256377698",
        "repo_full_name": "angular/angular",
        "pr_number": 62859,
        "pr_file": "adev/src/content/guide/routing/rendering-strategies.md",
        "discussion_id": "2256377698",
        "commented_code": "@@ -0,0 +1,138 @@\n+# Rendering strategies in Angular\n+\n+This guide helps you choose the right rendering strategy for different parts of your Angular application. Each strategy offers different trade-offs between performance, SEO, and complexity.\n+\n+## What are rendering strategies?\n+\n+Rendering strategies determine when and where your Angular application's HTML content is generated. Each strategy offers different trade-offs between initial page load performance, interactivity, SEO capabilities, and server resource usage.\n+\n+Angular supports three primary rendering strategies:\n+\n+- **Client-Side Rendering (CSR)** - Content is rendered entirely in the browser\n+- **Static Site Generation (SSG/Prerendering)** - Content is pre-rendered at build time\n+- **Server-Side Rendering (SSR)** - Content is rendered on the server for each request",
        "comment_created_at": "2025-08-06T08:33:27+00:00",
        "comment_author": "thePunderWoman",
        "comment_body": "```suggestion\r\n- **Server-Side Rendering (SSR)** - Content is rendered on the server for the initial request\r\n```\r\n\r\nI'm mixed on my own suggestion here, but I don't think saying `each request` is correct either. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2261044631",
        "repo_full_name": "angular/angular",
        "pr_number": 62859,
        "pr_file": "adev/src/content/guide/routing/rendering-strategies.md",
        "discussion_id": "2256377698",
        "commented_code": "@@ -0,0 +1,138 @@\n+# Rendering strategies in Angular\n+\n+This guide helps you choose the right rendering strategy for different parts of your Angular application. Each strategy offers different trade-offs between performance, SEO, and complexity.\n+\n+## What are rendering strategies?\n+\n+Rendering strategies determine when and where your Angular application's HTML content is generated. Each strategy offers different trade-offs between initial page load performance, interactivity, SEO capabilities, and server resource usage.\n+\n+Angular supports three primary rendering strategies:\n+\n+- **Client-Side Rendering (CSR)** - Content is rendered entirely in the browser\n+- **Static Site Generation (SSG/Prerendering)** - Content is pre-rendered at build time\n+- **Server-Side Rendering (SSR)** - Content is rendered on the server for each request",
        "comment_created_at": "2025-08-07T17:47:51+00:00",
        "comment_author": "bencodezen",
        "comment_body": "Sounds good. I'll iterate on this!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195498501",
    "pr_number": 62250,
    "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
    "created_at": "2025-07-09T16:51:07+00:00",
    "commented_code": "+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering",
    "repo_full_name": "angular/angular",
    "discussion_comments": [
      {
        "comment_id": "2195498501",
        "repo_full_name": "angular/angular",
        "pr_number": 62250,
        "pr_file": "adev/src/content/guide/routing/data-resolvers.md",
        "discussion_id": "2195498501",
        "commented_code": "@@ -0,0 +1,206 @@\n+# Data resolvers\n+\n+Data resolvers allow you to fetch data before navigating to a route, ensuring that your components receive the data they need before rendering. This can help prevent the need for loading states and improve the user experience by pre-loading essential data.\n+\n+## What are data resolvers?\n+\n+A data resolver is a service that implements the [`Resolve`](api/router/Resolve) interface. It runs before a route activates and can fetch data from APIs, databases, or other sources. The resolved data becomes available to the component through the [`ActivatedRoute`](api/router/ActivatedRoute).\n+\n+## Why use data resolvers?\n+\n+Data resolvers solve common routing challenges:\n+\n+- **Prevent empty states**: Components receive data immediately upon loading\n+- **Better user experience**: No loading spinners for critical data\n+- **Error handling**: Handle data fetching errors before navigation\n+- **Data consistency**: Ensure required data is available before rendering",
        "comment_created_at": "2025-07-09T16:51:07+00:00",
        "comment_author": "atscott",
        "comment_body": "Might also mention SSR, since it ensures data is retrieved prior to the page being served",
        "pr_file_module": null
      }
    ]
  }
]