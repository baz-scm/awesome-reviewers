[
  {
    "discussion_id": "2218393516",
    "pr_number": 10176,
    "pr_file": "app/http.php",
    "created_at": "2025-07-21T07:22:14+00:00",
    "commented_code": "'orders' => $index['orders'],\n                 ]), $files['indexes']);\n \n-                $dbForPlatform->createCollection('bucket_' . $bucket->getInternalId(), $attributes, $indexes);\n+                $dbForPlatform->createCollection('bucket_' . $bucket->getSequence(), $attributes, $indexes);\n             }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2218393516",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 10176,
        "pr_file": "app/http.php",
        "discussion_id": "2218393516",
        "commented_code": "@@ -309,7 +309,7 @@ function createDatabase(App $app, string $resourceKey, string $dbName, array $co\n                     'orders' => $index['orders'],\n                 ]), $files['indexes']);\n \n-                $dbForPlatform->createCollection('bucket_' . $bucket->getInternalId(), $attributes, $indexes);\n+                $dbForPlatform->createCollection('bucket_' . $bucket->getSequence(), $attributes, $indexes);\n             }",
        "comment_created_at": "2025-07-21T07:22:14+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Backward-compatibility risk: collection name now derived from `getSequence()`**\n\nExisting installs have collections named `bucket_<internalId>`.  \nSwitching to `bucket_<sequence>` breaks reads/writes for pre-existing buckets unless a migration renames the collections or a compatibility shim is added.  \nConfirm a data-migration plan before merging.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/http.php around lines 312 to 313, the collection name is changed from\nusing the bucket's internal ID to using its sequence, which breaks compatibility\nwith existing installations. To fix this, revert the collection naming to use\nthe bucket's internal ID as before or implement a migration script that renames\nexisting collections from the old naming scheme to the new one. Ensure that\neither the naming remains consistent with existing data or a clear migration\npath is provided before merging.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:cougar -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218411324",
    "pr_number": 9897,
    "pr_file": "app/http.php",
    "created_at": "2025-07-21T07:33:42+00:00",
    "commented_code": "'orders' => $index['orders'],\n                 ]), $files['indexes']);\n \n-                $dbForPlatform->createCollection('bucket_' . $bucket->getInternalId(), $attributes, $indexes);\n+                $dbForPlatform->createCollection('bucket_' . $bucket->getSequence(), $attributes, $indexes);\n             }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2218411324",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9897,
        "pr_file": "app/http.php",
        "discussion_id": "2218411324",
        "commented_code": "@@ -309,7 +309,7 @@ function createDatabase(App $app, string $resourceKey, string $dbName, array $co\n                     'orders' => $index['orders'],\n                 ]), $files['indexes']);\n \n-                $dbForPlatform->createCollection('bucket_' . $bucket->getInternalId(), $attributes, $indexes);\n+                $dbForPlatform->createCollection('bucket_' . $bucket->getSequence(), $attributes, $indexes);\n             }",
        "comment_created_at": "2025-07-21T07:33:42+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Potential data loss due to collection name change**\n\nSwapping from `bucket_<internalId>` to `bucket_<sequence>` creates *new* collections instead of re-using the originals.  \nAfter an upgrade, all existing file documents will remain in the old collection and will no longer be returned by the API, effectively hiding (orphaning) the data.\n\nBefore shipping, add an upgrade path, e.g.:\n\n```php\n$legacy = 'bucket_' . $bucket->getInternalId();\n$new    = 'bucket_' . $bucket->getSequence();\n\nif (!$db->getCollection($new)->isEmpty()) {\n    // nothing to do\n} elseif (!$db->getCollection($legacy)->isEmpty()) {\n    $db->renameCollection($legacy, $new); // or copy & drop\n}\n```\n\nor keep reading from both names until a background migration finishes.  \nWithout such guard rails, production users will perceive sudden data loss.  \n\n\n\nAlso applies to: 360-361\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/http.php around lines 312-313 and also lines 360-361, the code changes\ncollection names from 'bucket_<internalId>' to 'bucket_<sequence>', which causes\nnew collections to be created and existing data to be orphaned. To fix this,\nimplement an upgrade path that checks if the new collection is empty and if the\nlegacy collection is not empty, then rename or migrate the legacy collection to\nthe new name before creating or using the new collection. This ensures existing\ndata remains accessible and prevents data loss after the upgrade.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:cougar -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136714238",
    "pr_number": 9985,
    "pr_file": "app/controllers/general.php",
    "created_at": "2025-06-10T00:38:48+00:00",
    "commented_code": ")[0] ?? new Document();\n             }\n \n-            if (!$rule->isEmpty() && $rule->getAttribute('projectInternalId') === $project->getInternalId()) {\n+            if (!$rule->isEmpty() && $rule->getAttribute('projectInternalId') === $project->getSequence()) {",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2136714238",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9985,
        "pr_file": "app/controllers/general.php",
        "discussion_id": "2136714238",
        "commented_code": "@@ -958,7 +958,7 @@ function router(App $utopia, Database $dbForPlatform, callable $getProjectDB, Sw\n                 )[0] ?? new Document();\n             }\n \n-            if (!$rule->isEmpty() && $rule->getAttribute('projectInternalId') === $project->getInternalId()) {\n+            if (!$rule->isEmpty() && $rule->getAttribute('projectInternalId') === $project->getSequence()) {",
        "comment_created_at": "2025-06-10T00:38:48+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Verify this architectural change has been properly tested.**\n\nThe conditional check now compares `$rule->getAttribute('projectInternalId')` against `$project->getSequence()`. This represents a significant change in how project identification works.\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Verify that migration scripts exist for this internal ID to sequence change\necho \"Searching for migration scripts related to sequence/internalId changes...\"\nfd -e php -x grep -l \"internalId.*sequence\\|sequence.*internalId\" {} \\; | head -10\n\necho \"Checking for test coverage of sequence field...\"\nrg \"sequence.*test|test.*sequence\" --type php -A 3 -B 3\n```\n\nLength of output: 1167\n\n---\n\n\n\n</details>\n\n**Ensure migration and test coverage for the projectInternalId \u2192 sequence change**\n\nIt appears there\u2019s no migration updating existing projects\u2019 `projectInternalId` to the new `sequence` values, nor any tests covering this comparison in app/controllers/general.php (line 961). Without these in place, existing data and future regressions may break.\n\nPlease address:\n\n- Add a migration in src/Appwrite/Migration/Version/VXX.php that populates each project\u2019s `sequence` into the `projectInternalId` (or vice versa) so the new check remains consistent for existing records.  \n- Include unit or integration tests around the controller logic in app/controllers/general.php (line 961) to verify that `$rule->getAttribute('projectInternalId') === $project->getSequence()` behaves as expected.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/controllers/general.php at line 961, the conditional now compares\n$rule->getAttribute('projectInternalId') with $project->getSequence(), which is\na significant change in project identification logic. To fix this, create a\nmigration script in src/Appwrite/Migration/Version/VXX.php that updates existing\nprojects by populating the sequence field based on projectInternalId or vice\nversa to keep data consistent. Additionally, add unit or integration tests\ncovering this controller logic to ensure the new comparison behaves correctly\nand prevents regressions.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136714241",
    "pr_number": 9985,
    "pr_file": "app/init/resources.php",
    "created_at": "2025-06-10T00:38:48+00:00",
    "commented_code": "$team = Authorization::skip(function () use ($dbForPlatform, $teamInternalId) {\n         return $dbForPlatform->findOne('teams', [\n-            Query::equal('$internalId', [$teamInternalId]),\n+            Query::equal('$sequence', [$teamInternalId]),",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2136714241",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9985,
        "pr_file": "app/init/resources.php",
        "discussion_id": "2136714241",
        "commented_code": "@@ -839,7 +839,7 @@ function getDevice(string $root, string $connection = ''): Device\n \n     $team = Authorization::skip(function () use ($dbForPlatform, $teamInternalId) {\n         return $dbForPlatform->findOne('teams', [\n-            Query::equal('$internalId', [$teamInternalId]),\n+            Query::equal('$sequence', [$teamInternalId]),",
        "comment_created_at": "2025-06-10T00:38:48+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Verify database schema migration for the `$sequence` field.**\n\nThe query now searches for teams using the `$sequence` field instead of `$internalId`. This is a breaking change that requires proper database migration.\n\n\nRun the following script to verify that the teams collection has been properly migrated:\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Description: Check if teams collection has the $sequence field and verify no $internalId references remain\n\n# Check for any remaining references to $internalId in team-related queries\necho \"Checking for remaining $internalId references in team queries:\"\nrg -A 3 \"Query::equal\\('.*internalId'\" --type php\n\n# Check for $sequence field usage in team queries\necho -e \"\\nChecking $sequence field usage in team queries:\"\nrg -A 3 \"Query::equal\\('\\$sequence'\" --type php\n\n# Look for database migration files that handle this schema change\necho -e \"\\nLooking for migration files handling the internalId to sequence transition:\"\nfd -e php . -x grep -l \"internalId.*sequence\\|sequence.*internalId\" {} \\; | head -20\n```\n\nLength of output: 575\n\n---\n\n\n\n</details>\n\n**Add missing database migration for the `$sequence` field**\n\nNo migration files were found handling the transition from `$internalId` to `$sequence`, and there are no remaining references to `$internalId` in your queries\u2014even though you\u2019ve switched to querying on `$sequence`. This is a breaking change that must be addressed before merging.\n\n\u2022 app/init/resources.php (line 842):  \n   ```php\n   Query::equal('$sequence', [$teamInternalId]),\n   ```  \n\u2022 Create a migration to add/populate the `sequence` field on existing team documents (e.g. `migrations/20250601_add_sequence_to_teams.php`).  \n\u2022 Ensure existing `internalId` values are copied into `sequence` (or provide a fallback) and remove any lingering `internalId` references.  \n\u2022 Coordinate with downstream services to confirm they now use `sequence` instead of `internalId`.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/init/resources.php at line 842, the query uses the $sequence field\ninstead of $internalId, but there is no database migration to support this\nschema change. To fix this, create a new migration script (e.g.,\nmigrations/20250601_add_sequence_to_teams.php) that adds the sequence field to\nexisting team documents and populates it by copying values from internalId.\nEnsure all references to internalId are removed and coordinate with downstream\nservices to update their usage to sequence.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2106530903",
    "pr_number": 9895,
    "pr_file": "src/Appwrite/Platform/Modules/Tokens/Http/Tokens/Buckets/Files/Create.php",
    "created_at": "2025-05-26T05:20:20+00:00",
    "commented_code": "'$id' => ID::unique(),\n             'secret' => Auth::tokenGenerator(128),\n             'resourceId' => $bucketId . ':' . $fileId,\n-            'resourceInternalId' => $bucket->getInternalId() . ':' . $file->getInternalId(),\n+            'resourceInternalId' => $bucket->getSequence() . ':' . $file->getSequence(),",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2106530903",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9895,
        "pr_file": "src/Appwrite/Platform/Modules/Tokens/Http/Tokens/Buckets/Files/Create.php",
        "discussion_id": "2106530903",
        "commented_code": "@@ -94,7 +94,7 @@ public function action(string $bucketId, string $fileId, ?string $expire, Respon\n             '$id' => ID::unique(),\n             'secret' => Auth::tokenGenerator(128),\n             'resourceId' => $bucketId . ':' . $fileId,\n-            'resourceInternalId' => $bucket->getInternalId() . ':' . $file->getInternalId(),\n+            'resourceInternalId' => $bucket->getSequence() . ':' . $file->getSequence(),",
        "comment_created_at": "2025-05-26T05:20:20+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Verify backward compatibility for existing tokens.**\n\nThe change from `getInternalId()` to `getSequence()` is consistent with the codebase-wide refactor. However, please ensure that existing tokens with the old internal ID format will continue to work correctly.\n\n\n\nRun the following script to check if there are any token validation or lookup logic that might be affected:\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Description: Search for token validation and lookup logic that might use resourceInternalId\n\n# Search for code that queries or filters by resourceInternalId\nrg -A 5 \"resourceInternalId\" --type php\n\n# Search for token validation logic\nast-grep --pattern 'resourceInternalId'\n```\n\nLength of output: 71301\n\n---\n\n\n\n</details>\n\n**Ensure backward compatibility for existing tokens**  \nChanging `resourceInternalId` from `getInternalId()` to `getSequence()` will break lookups for tokens issued before this refactor. Please add a fallback or data migration so that both legacy and new tokens resolve correctly.\n\n\u2022 In `src/Appwrite/Platform/Modules/Tokens/Http/Tokens/Buckets/Files/Create.php`, you now set:  \n  `'resourceInternalId' => $bucket->getSequence() . ':' . $file->getSequence(),`  \n  Consider also preserving the old format (`getInternalId() . ':' . getInternalId()`) for existing tokens.  \n\u2022 In `src/Appwrite/Platform/Modules/Tokens/Http/Tokens/Buckets/Files/XList.php`, lookups filter only on the new sequence format. Update the query to match either format:  \n```diff\n- $queries[] = Query::equal('resourceInternalId', [$bucket->getSequence() . ':' . $file->getSequence()]);\n+ $queries[] = Query::or([\n+   Query::equal('resourceInternalId', [$bucket->getSequence() . ':' . $file->getSequence()]),\n+   Query::equal('resourceInternalId', [$bucket->getInternalId() . ':' . $file->getInternalId()]),\n+ ]);\n```  \n\u2022 Review `app/init/resources.php` parsing logic\u2014splitting on `:`\u2014to ensure it handles both UUID and numeric formats.  \n\u2022 No existing migration updates token documents; add a migration to rewrite `resourceInternalId` for all `ResourceToken` records in the database.  \n\u2022 Verify the model in `src/Appwrite/Utopia/Response/Model/ResourceToken.php` and any delete, stats-gathering, or metrics code that filters by `resourceInternalId` continues to function for legacy tokens.\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn src/Appwrite/Platform/Modules/Tokens/Http/Tokens/Buckets/Files/Create.php at\nline 97, the change from getInternalId() to getSequence() for resourceInternalId\nbreaks backward compatibility with existing tokens. To fix this, implement a\nfallback mechanism or data migration that supports both the old format (using\ngetInternalId()) and the new format (using getSequence()). Update\nsrc/Appwrite/Platform/Modules/Tokens/Http/Tokens/Buckets/Files/XList.php to\nquery tokens matching either format, review app/init/resources.php to handle\nboth UUID and numeric IDs when parsing resourceInternalId, add a migration\nscript to update existing ResourceToken records in the database to the new\nformat, and verify that the ResourceToken model and related code continue to\nsupport legacy tokens correctly.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2106530908",
    "pr_number": 9895,
    "pr_file": "src/Appwrite/Platform/Modules/Sites/Http/Usage/Get.php",
    "created_at": "2025-05-26T05:20:20+00:00",
    "commented_code": "$stats = $usage = [];\n         $days = $periods[$range];\n         $metrics = [\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS_STORAGE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_STORAGE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_COMPUTE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_COMPUTE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_MB_SECONDS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_MB_SECONDS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_SUCCESS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_FAILED),\n-            str_replace(['{siteInternalId}'], [$site->getInternalId()], METRIC_SITES_ID_REQUESTS),\n-            str_replace(['{siteInternalId}'], [$site->getInternalId()], METRIC_SITES_ID_INBOUND),\n-            str_replace(['{siteInternalId}'], [$site->getInternalId()], METRIC_SITES_ID_OUTBOUND),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS_STORAGE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_STORAGE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_COMPUTE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_COMPUTE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_MB_SECONDS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_MB_SECONDS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_SUCCESS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_FAILED),\n+            str_replace(['{siteInternalId}'], [$site->getSequence()], METRIC_SITES_ID_REQUESTS),\n+            str_replace(['{siteInternalId}'], [$site->getSequence()], METRIC_SITES_ID_INBOUND),\n+            str_replace(['{siteInternalId}'], [$site->getSequence()], METRIC_SITES_ID_OUTBOUND),",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2106530908",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9895,
        "pr_file": "src/Appwrite/Platform/Modules/Sites/Http/Usage/Get.php",
        "discussion_id": "2106530908",
        "commented_code": "@@ -74,20 +74,20 @@ public function action(\n         $stats = $usage = [];\n         $days = $periods[$range];\n         $metrics = [\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS_STORAGE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_STORAGE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_COMPUTE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_COMPUTE),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_MB_SECONDS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_MB_SECONDS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_SUCCESS),\n-            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getInternalId()], METRIC_RESOURCE_TYPE_ID_BUILDS_FAILED),\n-            str_replace(['{siteInternalId}'], [$site->getInternalId()], METRIC_SITES_ID_REQUESTS),\n-            str_replace(['{siteInternalId}'], [$site->getInternalId()], METRIC_SITES_ID_INBOUND),\n-            str_replace(['{siteInternalId}'], [$site->getInternalId()], METRIC_SITES_ID_OUTBOUND),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_DEPLOYMENTS_STORAGE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_STORAGE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_COMPUTE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_COMPUTE),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_MB_SECONDS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_EXECUTIONS_MB_SECONDS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_SUCCESS),\n+            str_replace(['{resourceType}', '{resourceInternalId}'], [RESOURCE_TYPE_SITES, $site->getSequence()], METRIC_RESOURCE_TYPE_ID_BUILDS_FAILED),\n+            str_replace(['{siteInternalId}'], [$site->getSequence()], METRIC_SITES_ID_REQUESTS),\n+            str_replace(['{siteInternalId}'], [$site->getSequence()], METRIC_SITES_ID_INBOUND),\n+            str_replace(['{siteInternalId}'], [$site->getSequence()], METRIC_SITES_ID_OUTBOUND),",
        "comment_created_at": "2025-05-26T05:20:20+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Verify metric key migration and historical data consistency.**\n\nThe systematic replacement of `$site->getInternalId()` with `$site->getSequence()` in metric key construction will create new metric identifiers. This could lead to:\n\n1. **Historical data discontinuity** - Existing metrics using internal IDs won't match the new sequence-based keys\n2. **Potential data duplication** - Both old and new metric formats may coexist in the database\n\nPlease ensure there's a migration strategy to handle existing metric data.\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Check for existing metrics that might use internal IDs\necho \"Searching for metric patterns in the codebase...\"\nrg -A 3 \"METRIC_.*_ID_\" --type php\n\necho \"Checking for metric-related migration logic...\"\nast-grep --pattern 'function migrate$$$() {\n  $$$\n}'\n```\n\nLength of output: 45936\n\n---\n\n\n\n</details>\n\n**Ensure migration strategy for sequence-based metric keys**\n\nOur search confirms that all metric key constructions now use `$site->getSequence()` (and similarly for other resources) instead of internal IDs, but there is no existing migration logic (no `migrate\u2026()` function or equivalent) to reconcile or backfill historical metrics. Without a migration strategy, you risk:\n\n- Historical data discontinuity: old metrics keyed by `{resourceInternalId}` won\u2019t be recognized under the new `{sequence}` format  \n- Data duplication: both old and new metric entries may coexist, skewing analytics  \n\nPlease add or document a migration plan to transform existing `{resourceInternalId}`-based metrics to the new `{resourceSequence}`-based keys.  \nExample touchpoints:  \n- A migration script or DB job (e.g. in `StatsUsage` or a new CLI command)  \n- An alias layer in `app/init/constants.php` or in your workers to read both key formats until cut-over\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn src/Appwrite/Platform/Modules/Sites/Http/Usage/Get.php around lines 77 to 90,\nthe metric keys have been changed from using $site->getInternalId() to\n$site->getSequence(), but there is no migration strategy to handle existing\nmetrics keyed by internal IDs. To fix this, implement a migration plan that\ntransforms or aliases old metric keys to the new sequence-based keys. This can\nbe done by adding a migration script or database job to backfill or rename\nexisting metrics, or by introducing an alias layer in the constants or worker\ninitialization to support both key formats until the transition is complete.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2106530924",
    "pr_number": 9895,
    "pr_file": "src/Appwrite/Platform/Modules/Sites/Http/Variables/Delete.php",
    "created_at": "2025-05-26T05:20:21+00:00",
    "commented_code": "}\n \n         $variable = $dbForProject->getDocument('variables', $variableId);\n-        if ($variable === false || $variable->isEmpty() || $variable->getAttribute('resourceInternalId') !== $site->getInternalId() || $variable->getAttribute('resourceType') !== 'site') {\n+        if ($variable === false || $variable->isEmpty() || $variable->getAttribute('resourceInternalId') !== $site->getSequence() || $variable->getAttribute('resourceType') !== 'site') {",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2106530924",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9895,
        "pr_file": "src/Appwrite/Platform/Modules/Sites/Http/Variables/Delete.php",
        "discussion_id": "2106530924",
        "commented_code": "@@ -66,7 +66,7 @@ public function action(string $siteId, string $variableId, Response $response, D\n         }\n \n         $variable = $dbForProject->getDocument('variables', $variableId);\n-        if ($variable === false || $variable->isEmpty() || $variable->getAttribute('resourceInternalId') !== $site->getInternalId() || $variable->getAttribute('resourceType') !== 'site') {\n+        if ($variable === false || $variable->isEmpty() || $variable->getAttribute('resourceInternalId') !== $site->getSequence() || $variable->getAttribute('resourceType') !== 'site') {",
        "comment_created_at": "2025-05-26T05:20:21+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Critical: Verify data consistency for existing variable documents.**\n\nThis change modifies a security-critical validation that ensures variables can only be deleted by their owning site. If existing variable documents have `resourceInternalId` set to the site's internal ID (from before this refactor), they will fail this validation and become inaccessible.\n\n\n\nPlease run the following script to check for data consistency issues:\n\n\n\nA database migration is likely required to update existing `resourceInternalId` values from internal IDs to sequence numbers.\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Search for any database migration handling this change\nrg -A 10 -B 5 \"resourceInternalId.*sequence|sequence.*resourceInternalId\" --type php\n\n# Look for variable creation code to see how resourceInternalId is set\nast-grep --pattern 'setAttribute($_, $_)' | rg -A 2 -B 2 \"resourceInternalId\"\n\n# Check for migration scripts that might handle this transition\nfd -e php -x grep -l \"resourceInternalId\\|getInternalId\\|getSequence\" {} \\; | rg -i \"migrat\"\n```\n\nLength of output: 1980\n\n---\n\n\n\n</details>\n\n**Fix Required: Align `resourceInternalId` Assignment and Add Migration**\n\nWe\u2019ve confirmed that:\n\n- In `src/Appwrite/Platform/Modules/Sites/Http/Variables/Create.php`, new variables are still being created with  \n  ```php\n  $variable->setAttribute('resourceInternalId', $site->getInternalId());\n  ```\n  while the delete logic now expects `$site->getSequence()`.\n- No existing migration (V17\u2013V22) touches `resourceInternalId` for variable documents.\n\nActions:\n\n- Update creation (and any update) endpoints to use sequence instead of internal ID:\n  ```diff\n  \u2014 $variable->setAttribute('resourceInternalId', $site->getInternalId());\n  + $variable->setAttribute('resourceInternalId', $site->getSequence());\n  ```\n- Add a database migration to backfill all existing variable documents:\n  - Read each variable\u2019s `resourceInternalId` (old internal ID)  \n  - Look up the corresponding site\u2019s sequence  \n  - Update the document\u2019s `resourceInternalId` to that sequence  \n- Verify no other modules (e.g., update or bulk operations) still rely on the old internal-ID assignment.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn src/Appwrite/Platform/Modules/Sites/Http/Variables/Delete.php at line 69, the\nvalidation compares variable resourceInternalId to site sequence, but variable\ncreation still sets resourceInternalId to site internal ID. To fix this, update\nvariable creation and any update code to assign resourceInternalId using site\nsequence instead of internal ID. Additionally, create a database migration that\nreads existing variable documents, maps their old internal ID resourceInternalId\nto the correct site sequence, and updates the documents accordingly. Finally,\naudit other modules handling variables to ensure they also use sequence for\nresourceInternalId.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2102804736",
    "pr_number": 9865,
    "pr_file": "app/http.php",
    "created_at": "2025-05-22T15:08:46+00:00",
    "commented_code": "'orders' => $index['orders'],\n                 ]), $files['indexes']);\n \n-                $dbForPlatform->createCollection('bucket_' . $bucket->getInternalId(), $attributes, $indexes);\n+                $dbForPlatform->createCollection('bucket_' . $bucket->getSequence(), $attributes, $indexes);",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2102804736",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9865,
        "pr_file": "app/http.php",
        "discussion_id": "2102804736",
        "commented_code": "@@ -309,7 +309,7 @@ function createDatabase(App $app, string $resourceKey, string $dbName, array $co\n                     'orders' => $index['orders'],\n                 ]), $files['indexes']);\n \n-                $dbForPlatform->createCollection('bucket_' . $bucket->getInternalId(), $attributes, $indexes);\n+                $dbForPlatform->createCollection('bucket_' . $bucket->getSequence(), $attributes, $indexes);",
        "comment_created_at": "2025-05-22T15:08:46+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Updated collection naming scheme to use sequence instead of internal ID**\n\nThis change affects how collections are named for bucket files, using the bucket's sequence number instead of its internal ID. This is a significant change as it impacts database structure naming.\n\n\nIt's important to verify that any existing data migrations handle this change properly. If collections were previously created with internal IDs in their names, a migration strategy should be in place to ensure data continuity.\n\n\n\n\nAlso applies to: 360-360\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\n# Check for migration scripts that might handle collection renaming\n\necho \"Checking for relevant migration scripts...\"\nrg -A 5 -B 5 \"Migration.*[Ss]equence\" --type php\n\necho \"Checking for collection references in code...\"\nrg \"bucket_.*getSequence\\(\\)\" --type php\nrg \"bucket_.*getInternalId\\(\\)\" --type php\n```\n\nLength of output: 8806\n\n---\n\n\n\n</details>\n\n**Add migration for bucket collection naming change**  \nThe switch from using `getInternalId()` to `getSequence()` for bucket-collection names will break any existing collections named with the old internal\u2010ID scheme, and I don\u2019t see a migration that renames those collections. We need to ensure data continuity by adding a migration that:  \n\n- Scans all existing buckets  \n- Renames each collection from `bucket_<internalId>` \u2192 `bucket_<sequence>` (e.g. via `$db->renameCollection()`)  \n- Updates your new code to operate on the renamed collections  \n\nSuggested action:  \n\u2022 Create a new migration in `src/Appwrite/Migration/Version/V21.php` (or next version) that loops through buckets, computes both old and new collection names, and calls the appropriate rename API.  \n\u2022 Add corresponding tests to cover the rename logic.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/http.php at line 312, the collection naming was changed from using bucket\ninternal IDs to using bucket sequences, but there is no migration to rename\nexisting collections accordingly. To fix this, create a new migration class in\nsrc/Appwrite/Migration/Version/V21.php (or the next version) that iterates over\nall buckets, computes old collection names using internal IDs and new names\nusing sequences, and renames collections via the database renameCollection\nmethod. Also, add tests to verify the migration correctly renames collections to\nensure data continuity.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]