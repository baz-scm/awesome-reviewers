[
  {
    "discussion_id": "2218393469",
    "pr_number": 10176,
    "pr_file": "app/config/console.php",
    "created_at": "2025-07-21T07:22:12+00:00",
    "commented_code": "*/\n \n use Appwrite\\Auth\\Auth;\n-use Appwrite\\Network\\Validator\\Origin;\n+use Appwrite\\Network\\Platform;\n use Utopia\\Database\\Helpers\\ID;\n use Utopia\\System\\System;\n \n $console = [\n     '$id' => ID::custom('console'),\n-    '$internalId' => ID::custom('console'),\n+    '$sequence' => ID::custom('console'),\n     'name' => 'Appwrite',",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2218393469",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 10176,
        "pr_file": "app/config/console.php",
        "discussion_id": "2218393469",
        "commented_code": "@@ -5,13 +5,13 @@\n  */\n \n use Appwrite\\Auth\\Auth;\n-use Appwrite\\Network\\Validator\\Origin;\n+use Appwrite\\Network\\Platform;\n use Utopia\\Database\\Helpers\\ID;\n use Utopia\\System\\System;\n \n $console = [\n     '$id' => ID::custom('console'),\n-    '$internalId' => ID::custom('console'),\n+    '$sequence' => ID::custom('console'),\n     'name' => 'Appwrite',",
        "comment_created_at": "2025-07-21T07:22:12+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Duplication of identifiers may cause drift**  \n\nStoring both `$id` and `$sequence` with the same value can confuse future queries / migrations. Confirm whether keeping both is strictly required; if not, drop the redundant field to avoid divergence later.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/config/console.php at lines 14 to 15, both '$sequence' and 'name' fields\nare set with potentially overlapping identifiers which may cause confusion or\ndrift in queries and migrations. Review the necessity of storing both\n'$sequence' and '$id' if they hold the same value; if redundant, remove the\n'$sequence' field to prevent future inconsistencies and simplify the schema.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:cougar -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072814608",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Tables/Create.php",
    "created_at": "2025-05-05T03:45:45+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Tables;\n+\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\Limit as LimitException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Action;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\Text;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createTable';\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/tables')\n+            ->httpAlias('/v1/databases/:databaseId/collections')\n+            ->desc('Create table')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].tables.[tableId].create')\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'table.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/table/{response.$id}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: 'tables',\n+                name: 'createTable',\n+                description: '/docs/references/databases/create-collection.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_CREATED,\n+                        model: UtopiaResponse::MODEL_COLLECTION,\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('tableId', '', new CustomId(), 'Unique Id. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\\'t start with a special char. Max length is 36 chars.')\n+            ->param('name', '', new Text(128), 'Table name. Max length: 128 chars.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE), 'An array of permissions strings. By default, no user is granted with any permissions. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documentSecurity', false, new Boolean(true), 'Enables configuring permissions for individual documents. A user needs one of document or collection level permissions to access a document. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('enabled', true, new Boolean(), 'Is collection enabled? When set to \\'disabled\\', users cannot access the collection but Server SDKs with and API key can still read and write to the collection. No data is lost when this is toggled.', true)\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $tableId, string $name, ?array $permissions, bool $documentSecurity, bool $enabled, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents): void\n+    {\n+        $database = Authorization::skip(fn () => $dbForProject->getDocument('databases', $databaseId));\n+\n+        if ($database->isEmpty()) {\n+            throw new Exception(Exception::DATABASE_NOT_FOUND);\n+        }\n+\n+        $tableId = $tableId === 'unique()' ? ID::unique() : $tableId;\n+\n+        $permissions = Permission::aggregate($permissions) ?? [];\n+\n+        try {\n+            $table = $dbForProject->createDocument('database_' . $database->getInternalId(), new Document([\n+                '$id' => $tableId,\n+                'databaseInternalId' => $database->getInternalId(),\n+                'databaseId' => $databaseId,\n+                '$permissions' => $permissions,\n+                'documentSecurity' => $documentSecurity,\n+                'enabled' => $enabled,\n+                'name' => $name,\n+                'search' => \\implode(' ', [$tableId, $name]),\n+            ]));\n+\n+            $dbForProject->createCollection('database_' . $database->getInternalId() . '_collection_' . $table->getInternalId(), permissions: $permissions, documentSecurity: $documentSecurity);\n+        } catch (DuplicateException) {\n+            throw new Exception(Exception::COLLECTION_ALREADY_EXISTS);\n+        } catch (LimitException) {\n+            throw new Exception(Exception::COLLECTION_LIMIT_EXCEEDED);\n+        }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2072814608",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Tables/Create.php",
        "discussion_id": "2072814608",
        "commented_code": "@@ -0,0 +1,116 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Tables;\n+\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\Limit as LimitException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Action;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\Text;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createTable';\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/tables')\n+            ->httpAlias('/v1/databases/:databaseId/collections')\n+            ->desc('Create table')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].tables.[tableId].create')\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'table.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/table/{response.$id}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: 'tables',\n+                name: 'createTable',\n+                description: '/docs/references/databases/create-collection.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_CREATED,\n+                        model: UtopiaResponse::MODEL_COLLECTION,\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('tableId', '', new CustomId(), 'Unique Id. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\\'t start with a special char. Max length is 36 chars.')\n+            ->param('name', '', new Text(128), 'Table name. Max length: 128 chars.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE), 'An array of permissions strings. By default, no user is granted with any permissions. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documentSecurity', false, new Boolean(true), 'Enables configuring permissions for individual documents. A user needs one of document or collection level permissions to access a document. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('enabled', true, new Boolean(), 'Is collection enabled? When set to \\'disabled\\', users cannot access the collection but Server SDKs with and API key can still read and write to the collection. No data is lost when this is toggled.', true)\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $tableId, string $name, ?array $permissions, bool $documentSecurity, bool $enabled, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents): void\n+    {\n+        $database = Authorization::skip(fn () => $dbForProject->getDocument('databases', $databaseId));\n+\n+        if ($database->isEmpty()) {\n+            throw new Exception(Exception::DATABASE_NOT_FOUND);\n+        }\n+\n+        $tableId = $tableId === 'unique()' ? ID::unique() : $tableId;\n+\n+        $permissions = Permission::aggregate($permissions) ?? [];\n+\n+        try {\n+            $table = $dbForProject->createDocument('database_' . $database->getInternalId(), new Document([\n+                '$id' => $tableId,\n+                'databaseInternalId' => $database->getInternalId(),\n+                'databaseId' => $databaseId,\n+                '$permissions' => $permissions,\n+                'documentSecurity' => $documentSecurity,\n+                'enabled' => $enabled,\n+                'name' => $name,\n+                'search' => \\implode(' ', [$tableId, $name]),\n+            ]));\n+\n+            $dbForProject->createCollection('database_' . $database->getInternalId() . '_collection_' . $table->getInternalId(), permissions: $permissions, documentSecurity: $documentSecurity);\n+        } catch (DuplicateException) {\n+            throw new Exception(Exception::COLLECTION_ALREADY_EXISTS);\n+        } catch (LimitException) {\n+            throw new Exception(Exception::COLLECTION_LIMIT_EXCEEDED);\n+        }",
        "comment_created_at": "2025-05-05T03:45:45+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Risk of orphan metadata when `createCollection()` fails**  \n`createDocument()` succeeds first, then `createCollection()` may throw (e.g. network hiccup, storage limit, generic DB error).  \nThe database will then contain a \u201ctable\u201d document whose backing collection does not exist, leaving the project in an inconsistent state.\n\nWrap both calls in the same try/catch and roll back the document on failure or (preferred) create the collection first in a temporary namespace and commit both changes in a single transaction if the underlying adapter supports it.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077445012",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Collections/Create.php",
    "created_at": "2025-05-07T11:46:22+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Collections;\n+\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\Limit as LimitException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\Text;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createCollection';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_COLLECTION;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this->setContext(Action::COLLECTION);\n+\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/collections')\n+            ->desc('Create collections')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].create')\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'collection.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{response.$id}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/create-collection.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_CREATED,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new CustomId(), 'Unique Id. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\\'t start with a special char. Max length is 36 chars.')\n+            ->param('name', '', new Text(128), 'Collection name. Max length: 128 chars.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE), 'An array of permissions strings. By default, no user is granted with any permissions. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documentSecurity', false, new Boolean(true), 'Enables configuring permissions for individual documents. A user needs one of document or collection level permissions to access a document. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('enabled', true, new Boolean(), 'Is collection enabled? When set to \\'disabled\\', users cannot access the collection but Server SDKs with and API key can still read and write to the collection. No data is lost when this is toggled.', true)\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $collectionId, string $name, ?array $permissions, bool $documentSecurity, bool $enabled, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents): void\n+    {\n+        $this->validateContext();\n+\n+        $database = Authorization::skip(fn () => $dbForProject->getDocument('databases', $databaseId));\n+\n+        if ($database->isEmpty()) {\n+            throw new Exception(Exception::DATABASE_NOT_FOUND);\n+        }\n+\n+        $collectionId = $collectionId === 'unique()' ? ID::unique() : $collectionId;\n+\n+        $permissions = Permission::aggregate($permissions) ?? [];\n+\n+        try {\n+            $collection = $dbForProject->createDocument('database_' . $database->getInternalId(), new Document([\n+                '$id' => $collectionId,\n+                'databaseInternalId' => $database->getInternalId(),\n+                'databaseId' => $databaseId,\n+                '$permissions' => $permissions,\n+                'documentSecurity' => $documentSecurity,\n+                'enabled' => $enabled,\n+                'name' => $name,\n+                'search' => \\implode(' ', [$collectionId, $name]),\n+            ]));\n+\n+            $dbForProject->createCollection('database_' . $database->getInternalId() . '_collection_' . $collection->getInternalId(), permissions: $permissions, documentSecurity: $documentSecurity);\n+        } catch (DuplicateException) {",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2077445012",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Collections/Create.php",
        "discussion_id": "2077445012",
        "commented_code": "@@ -0,0 +1,123 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Collections;\n+\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\Limit as LimitException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\Text;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createCollection';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_COLLECTION;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this->setContext(Action::COLLECTION);\n+\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/collections')\n+            ->desc('Create collections')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].create')\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'collection.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{response.$id}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/create-collection.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_CREATED,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new CustomId(), 'Unique Id. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\\'t start with a special char. Max length is 36 chars.')\n+            ->param('name', '', new Text(128), 'Collection name. Max length: 128 chars.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE), 'An array of permissions strings. By default, no user is granted with any permissions. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documentSecurity', false, new Boolean(true), 'Enables configuring permissions for individual documents. A user needs one of document or collection level permissions to access a document. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('enabled', true, new Boolean(), 'Is collection enabled? When set to \\'disabled\\', users cannot access the collection but Server SDKs with and API key can still read and write to the collection. No data is lost when this is toggled.', true)\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $collectionId, string $name, ?array $permissions, bool $documentSecurity, bool $enabled, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents): void\n+    {\n+        $this->validateContext();\n+\n+        $database = Authorization::skip(fn () => $dbForProject->getDocument('databases', $databaseId));\n+\n+        if ($database->isEmpty()) {\n+            throw new Exception(Exception::DATABASE_NOT_FOUND);\n+        }\n+\n+        $collectionId = $collectionId === 'unique()' ? ID::unique() : $collectionId;\n+\n+        $permissions = Permission::aggregate($permissions) ?? [];\n+\n+        try {\n+            $collection = $dbForProject->createDocument('database_' . $database->getInternalId(), new Document([\n+                '$id' => $collectionId,\n+                'databaseInternalId' => $database->getInternalId(),\n+                'databaseId' => $databaseId,\n+                '$permissions' => $permissions,\n+                'documentSecurity' => $documentSecurity,\n+                'enabled' => $enabled,\n+                'name' => $name,\n+                'search' => \\implode(' ', [$collectionId, $name]),\n+            ]));\n+\n+            $dbForProject->createCollection('database_' . $database->getInternalId() . '_collection_' . $collection->getInternalId(), permissions: $permissions, documentSecurity: $documentSecurity);\n+        } catch (DuplicateException) {",
        "comment_created_at": "2025-05-07T11:46:22+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Possible orphaned metadata when the second DB call fails**  \n`createDocument()` and `createCollection()` run independently. If the second call throws (network blip, duplicate name, \u2026), the first document is left behind, creating an inconsistent state that will surface as \u201cphantom collections\u201d.\n\nConsider wrapping both operations in a database transaction (if supported) or adding explicit rollback logic:\n\n```diff\n try {\n     $collection = $dbForProject->createDocument(/* \u2026 */);\n-    $dbForProject->createCollection(/* \u2026 */);\n+    try {\n+        $dbForProject->createCollection(/* \u2026 */);\n+    } catch (\\Throwable $e) {\n+        // Roll back metadata document\n+        $dbForProject->deleteDocument('database_' . $database->getInternalId(), $collection->getId());\n+        throw $e;\n+    }\n } catch (DuplicateException) {\n     \u2026\n }\n```\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142300550",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Update.php",
    "created_at": "2025-06-12T10:28:58+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections;\n+\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\Text;\n+\n+class Update extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'updateCollection';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_COLLECTION;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PUT)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId')\n+            ->desc('Update collection')\n+            ->groups(['api', 'database', 'schema'])\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].update')\n+            ->label('audits.event', 'collection.update')\n+            ->label('audits.resource', 'database/{request.databaseId}/collections/{request.collectionId}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/update-collection.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('name', null, new Text(128), 'Collection name. Max length: 128 chars.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE), 'An array of permission strings. By default, the current permissions are inherited. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documentSecurity', false, new Boolean(true), 'Enables configuring permissions for individual documents. A user needs one of document or collection level permissions to access a document. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('enabled', true, new Boolean(), 'Is collection enabled? When set to \\'disabled\\', users cannot access the collection but Server SDKs with and API key can still read and write to the collection. No data is lost when this is toggled.', true)\n+            ->inject('response')",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2142300550",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Update.php",
        "discussion_id": "2142300550",
        "commented_code": "@@ -0,0 +1,113 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections;\n+\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\Text;\n+\n+class Update extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'updateCollection';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_COLLECTION;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PUT)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId')\n+            ->desc('Update collection')\n+            ->groups(['api', 'database', 'schema'])\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].update')\n+            ->label('audits.event', 'collection.update')\n+            ->label('audits.resource', 'database/{request.databaseId}/collections/{request.collectionId}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/update-collection.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('name', null, new Text(128), 'Collection name. Max length: 128 chars.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE), 'An array of permission strings. By default, the current permissions are inherited. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documentSecurity', false, new Boolean(true), 'Enables configuring permissions for individual documents. A user needs one of document or collection level permissions to access a document. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('enabled', true, new Boolean(), 'Is collection enabled? When set to \\'disabled\\', users cannot access the collection but Server SDKs with and API key can still read and write to the collection. No data is lost when this is toggled.', true)\n+            ->inject('response')",
        "comment_created_at": "2025-06-12T10:28:58+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Blindly overwriting attributes erases existing data**\n\nIf the caller omits `name`, `documentSecurity`, or `enabled`, the update still sets these attributes to their default/null values, unintentionally mutating the collection.\n\n```diff\n-            ->setAttribute('name', $name)\n+            ->setAttribute('name', $name ?? $collection->getAttribute('name'))\n...\n-            ->setAttribute('documentSecurity', $documentSecurity)\n-            ->setAttribute('enabled', $enabled)\n+            ->setAttribute('documentSecurity', $documentSecurity ?? $collection->getAttribute('documentSecurity'))\n+            ->setAttribute('enabled', $enabled ?? $collection->getAttribute('enabled', true))\n```\nAt minimum guard each field, or build the `$updates` array dynamically so only supplied params are changed.  \n\n\n\nAlso applies to: 93-102\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Update.php\naround lines 63 to 68 and 93 to 102, the update method currently overwrites\ncollection attributes like name, documentSecurity, and enabled with default or\nnull values even if they are not provided by the caller. To fix this, modify the\ncode to check if each parameter is actually supplied before including it in the\nupdates array, so only the explicitly provided fields are updated and existing\ndata is preserved.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2153485633",
    "pr_number": 10023,
    "pr_file": "app/controllers/api/databases.php",
    "created_at": "2025-06-18T02:14:39+00:00",
    "commented_code": "->dynamic($attribute, Response::MODEL_ATTRIBUTE_IP);\n     });\n \n+App::post('/v1/databases/transactions')\n+    ->desc('Create transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createTransaction',\n+        description: '/docs/references/databases/create-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('ttl', APP_DATABASE_TXN_TTL_DEFAULT, new Range(min: APP_DATABASE_TXN_TTL_MIN, max: APP_DATABASE_TXN_TTL_MAX), 'Seconds before the transaction expires.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (int $ttl, Response $response, Database $dbForProject) {\n+        $transaction = $dbForProject->createDocument('transactions', new Document([\n+            '$id' => ID::unique(),\n+            'status' => 'pending',\n+            'operations' => 0,\n+            'expiresAt' => DateTime::addSeconds(new \\DateTime(), $ttl),\n+        ]));\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::post('/v1/databases/transactions/:transactionId/operations')\n+    ->desc('Add operations to transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createOperations',\n+        description: '/docs/references/databases/create-operations.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->param('operations', [], new ArrayList(new Operation()), 'Array of staged operations.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->inject('plan')\n+    ->action(function (string $transactionId, array $operations, Response $response, Database $dbForProject, array $plan) {\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+        if ($transaction->isEmpty() || $transaction->getAttribute('status', '') !== 'pending') {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Invalid or non\u2011pending transaction');\n+        }\n+\n+        $maxBatch = $plan['databasesBatchSize'] ?? APP_LIMIT_DATABASE_BATCH;\n+        $existing = $transaction->getAttribute('operations', 0);\n+\n+        if (($existing + \\count($operations)) > $maxBatch) {\n+            throw new Exception(\n+                Exception::TRANSACTION_LIMIT_EXCEEDED,\n+                'Transaction already has ' . $existing . ' operations, adding ' . \\count($operations) . ' would exceed the maximum of ' . $maxBatch\n+            );\n+        }\n+\n+        $databases = $collections = $staged = [];\n+        foreach ($operations as $operation) {\n+            $database = $databases[$operation['databaseId']] ??= $dbForProject->getDocument('databases', $operation['databaseId']);\n+            if ($database->isEmpty()) {\n+                throw new Exception(Exception::DATABASE_NOT_FOUND);\n+            }\n+\n+            $collection = $collections[$operation['collectionId']] ??= $dbForProject->getDocument('database_' . $database->getSequence(), $operation['collectionId']);\n+            if ($collection->isEmpty()) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            }\n+\n+            $staged[] = new Document([\n+                '$id' => ID::unique(),\n+                'databaseInternalId' => $database->getSequence(),\n+                'collectionInternalId' => $collection->getSequence(),\n+                'transactionInternalId' => $transaction->getSequence(),\n+                'documentId' => $operation['documentId'] ?? ID::unique(),\n+                'action' => $operation['action'],\n+                'data' => $operation['data'] ?? new \\stdClass(),\n+            ]);\n+        }\n+\n+        $dbForProject->withTransaction(function () use ($dbForProject, $transactionId, $staged, $existing, $operations) {\n+            $dbForProject->createDocuments('transactionLogs', $staged);\n+            $dbForProject->updateDocument('transactions', $transactionId, new Document([\n+                'operations' => $existing + \\count($operations),\n+            ]));\n+        });\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2153485633",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 10023,
        "pr_file": "app/controllers/api/databases.php",
        "discussion_id": "2153485633",
        "commented_code": "@@ -1536,6 +1538,392 @@\n             ->dynamic($attribute, Response::MODEL_ATTRIBUTE_IP);\n     });\n \n+App::post('/v1/databases/transactions')\n+    ->desc('Create transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createTransaction',\n+        description: '/docs/references/databases/create-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('ttl', APP_DATABASE_TXN_TTL_DEFAULT, new Range(min: APP_DATABASE_TXN_TTL_MIN, max: APP_DATABASE_TXN_TTL_MAX), 'Seconds before the transaction expires.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (int $ttl, Response $response, Database $dbForProject) {\n+        $transaction = $dbForProject->createDocument('transactions', new Document([\n+            '$id' => ID::unique(),\n+            'status' => 'pending',\n+            'operations' => 0,\n+            'expiresAt' => DateTime::addSeconds(new \\DateTime(), $ttl),\n+        ]));\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::post('/v1/databases/transactions/:transactionId/operations')\n+    ->desc('Add operations to transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createOperations',\n+        description: '/docs/references/databases/create-operations.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->param('operations', [], new ArrayList(new Operation()), 'Array of staged operations.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->inject('plan')\n+    ->action(function (string $transactionId, array $operations, Response $response, Database $dbForProject, array $plan) {\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+        if ($transaction->isEmpty() || $transaction->getAttribute('status', '') !== 'pending') {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Invalid or non\u2011pending transaction');\n+        }\n+\n+        $maxBatch = $plan['databasesBatchSize'] ?? APP_LIMIT_DATABASE_BATCH;\n+        $existing = $transaction->getAttribute('operations', 0);\n+\n+        if (($existing + \\count($operations)) > $maxBatch) {\n+            throw new Exception(\n+                Exception::TRANSACTION_LIMIT_EXCEEDED,\n+                'Transaction already has ' . $existing . ' operations, adding ' . \\count($operations) . ' would exceed the maximum of ' . $maxBatch\n+            );\n+        }\n+\n+        $databases = $collections = $staged = [];\n+        foreach ($operations as $operation) {\n+            $database = $databases[$operation['databaseId']] ??= $dbForProject->getDocument('databases', $operation['databaseId']);\n+            if ($database->isEmpty()) {\n+                throw new Exception(Exception::DATABASE_NOT_FOUND);\n+            }\n+\n+            $collection = $collections[$operation['collectionId']] ??= $dbForProject->getDocument('database_' . $database->getSequence(), $operation['collectionId']);\n+            if ($collection->isEmpty()) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            }\n+\n+            $staged[] = new Document([\n+                '$id' => ID::unique(),\n+                'databaseInternalId' => $database->getSequence(),\n+                'collectionInternalId' => $collection->getSequence(),\n+                'transactionInternalId' => $transaction->getSequence(),\n+                'documentId' => $operation['documentId'] ?? ID::unique(),\n+                'action' => $operation['action'],\n+                'data' => $operation['data'] ?? new \\stdClass(),\n+            ]);\n+        }\n+\n+        $dbForProject->withTransaction(function () use ($dbForProject, $transactionId, $staged, $existing, $operations) {\n+            $dbForProject->createDocuments('transactionLogs', $staged);\n+            $dbForProject->updateDocument('transactions', $transactionId, new Document([\n+                'operations' => $existing + \\count($operations),\n+            ]));\n+        });\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);",
        "comment_created_at": "2025-06-18T02:14:39+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Response shows stale `operations` counter**\n\n`createOperations` updates the counter inside the DB, but the `$transaction` object returned to the client is the pre-update instance \u2013 it still shows the old `operations` value.\n\nFetch the updated document (or mutate the local `$transaction`) before calling `$response->dynamic(...)`.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/controllers/api/databases.php around lines 1639 to 1648, the response\nreturns the $transaction object before the operations counter is updated in the\ndatabase, causing stale data to be sent to the client. To fix this, after the\ntransaction update inside the withTransaction callback, fetch the updated\ntransaction document from the database or update the local $transaction variable\nto reflect the new operations count before passing it to\n$response->dynamic(...).\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2153485635",
    "pr_number": 10023,
    "pr_file": "app/controllers/api/databases.php",
    "created_at": "2025-06-18T02:14:39+00:00",
    "commented_code": "->dynamic($attribute, Response::MODEL_ATTRIBUTE_IP);\n     });\n \n+App::post('/v1/databases/transactions')\n+    ->desc('Create transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createTransaction',\n+        description: '/docs/references/databases/create-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('ttl', APP_DATABASE_TXN_TTL_DEFAULT, new Range(min: APP_DATABASE_TXN_TTL_MIN, max: APP_DATABASE_TXN_TTL_MAX), 'Seconds before the transaction expires.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (int $ttl, Response $response, Database $dbForProject) {\n+        $transaction = $dbForProject->createDocument('transactions', new Document([\n+            '$id' => ID::unique(),\n+            'status' => 'pending',\n+            'operations' => 0,\n+            'expiresAt' => DateTime::addSeconds(new \\DateTime(), $ttl),\n+        ]));\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::post('/v1/databases/transactions/:transactionId/operations')\n+    ->desc('Add operations to transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createOperations',\n+        description: '/docs/references/databases/create-operations.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->param('operations', [], new ArrayList(new Operation()), 'Array of staged operations.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->inject('plan')\n+    ->action(function (string $transactionId, array $operations, Response $response, Database $dbForProject, array $plan) {\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+        if ($transaction->isEmpty() || $transaction->getAttribute('status', '') !== 'pending') {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Invalid or non\u2011pending transaction');\n+        }\n+\n+        $maxBatch = $plan['databasesBatchSize'] ?? APP_LIMIT_DATABASE_BATCH;\n+        $existing = $transaction->getAttribute('operations', 0);\n+\n+        if (($existing + \\count($operations)) > $maxBatch) {\n+            throw new Exception(\n+                Exception::TRANSACTION_LIMIT_EXCEEDED,\n+                'Transaction already has ' . $existing . ' operations, adding ' . \\count($operations) . ' would exceed the maximum of ' . $maxBatch\n+            );\n+        }\n+\n+        $databases = $collections = $staged = [];\n+        foreach ($operations as $operation) {\n+            $database = $databases[$operation['databaseId']] ??= $dbForProject->getDocument('databases', $operation['databaseId']);\n+            if ($database->isEmpty()) {\n+                throw new Exception(Exception::DATABASE_NOT_FOUND);\n+            }\n+\n+            $collection = $collections[$operation['collectionId']] ??= $dbForProject->getDocument('database_' . $database->getSequence(), $operation['collectionId']);\n+            if ($collection->isEmpty()) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            }\n+\n+            $staged[] = new Document([\n+                '$id' => ID::unique(),\n+                'databaseInternalId' => $database->getSequence(),\n+                'collectionInternalId' => $collection->getSequence(),\n+                'transactionInternalId' => $transaction->getSequence(),\n+                'documentId' => $operation['documentId'] ?? ID::unique(),\n+                'action' => $operation['action'],\n+                'data' => $operation['data'] ?? new \\stdClass(),\n+            ]);\n+        }\n+\n+        $dbForProject->withTransaction(function () use ($dbForProject, $transactionId, $staged, $existing, $operations) {\n+            $dbForProject->createDocuments('transactionLogs', $staged);\n+            $dbForProject->updateDocument('transactions', $transactionId, new Document([\n+                'operations' => $existing + \\count($operations),\n+            ]));\n+        });\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::get('/v1/databases/transactions')\n+    ->desc('List transactions')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.read')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'listTransactions',\n+        description: '/docs/references/databases/list-transactions.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_OK,\n+                model: Response::MODEL_TRANSACTION_LIST,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('queries', [], new Transactions(), 'Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries).', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (array $queries, Response $response, Database $dbForProject) {\n+        try {\n+            $queries = Query::parseQueries($queries);\n+        } catch (QueryException $e) {\n+            throw new Exception(Exception::GENERAL_QUERY_INVALID, $e->getMessage());\n+        }\n+\n+        $response->dynamic(new Document([\n+            'transactions' => $dbForProject->find('transactions', $queries),\n+            'total' => $dbForProject->count('transactions', $queries),\n+        ]), Response::MODEL_TRANSACTION_LIST);\n+    });\n+\n+App::get('/v1/databases/transactions/:transactionId')\n+    ->desc('Get transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.read')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'getTransaction',\n+        description: '/docs/references/databases/get-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_OK,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (string $transactionId, Response $response, Database $dbForProject) {\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+\n+        if ($transaction->isEmpty()) {\n+            throw new Exception(Exception::TRANSACTION_NOT_FOUND);\n+        }\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_OK)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::patch('/v1/databases/transactions/:transactionId')\n+    ->desc('Update transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'collections.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'updateTransaction',\n+        description: '/docs/references/databases/update-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_OK,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->param('commit', false, new Boolean(), 'Commit transaction?', true)\n+    ->param('rollback', false, new Boolean(), 'Rollback transaction?', true)\n+    ->inject('requestTimestamp')\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->inject('project')\n+    ->action(function (string $transactionId, bool $commit, bool $rollback, ?\\DateTime $requestTimestamp, ?string $reason, Response $response, Database $dbForProject, Document $project) {\n+        if (!$commit && !$rollback) {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Either commit or rollback must be true');\n+        }\n+        if ($commit && $rollback) {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Cannot commit and rollback at the same time');\n+        }\n+\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+\n+        if ($transaction->isEmpty()) {\n+            throw new Exception(Exception::TRANSACTION_NOT_FOUND);\n+        }\n+\n+        if ($transaction->getAttribute('status', '') !== 'pending') {\n+            throw new Exception(Exception::TRANSACTION_NOT_READY);\n+        }\n+\n+        $now = new \\DateTime();\n+        $expiresAt = new \\DateTime($transaction->getAttribute('expiresAt'));\n+        if ($now > $expiresAt) {\n+            throw new Exception(Exception::TRANSACTION_EXPIRED);\n+        }\n+\n+        if ($commit) {\n+            $dbForProject->withRequestTimestamp($requestTimestamp, function () use ($dbForProject, $transactionId, $transaction, $requestTimestamp) {\n+                $dbForProject->withTransaction(function () use ($dbForProject, $transactionId, $transaction, $requestTimestamp) {\n+                    $dbForProject->updateDocument('transactions', $transactionId, new Document([\n+                        'status' => 'committing',\n+                    ]));\n+\n+                    $operations = $dbForProject->find('transactionLogs', [\n+                        Query::equal('transactionInternalId', [$transaction->getSequence()]),\n+                    ]);\n+\n+                    $creates = $updates = $deletes = $bulkUpdates = $bulkDeletes = [];\n+\n+                    foreach ($operations as $operation) {\n+                        $databaseInternalId = $operation['databaseInternalId'];\n+                        $collectionInternalId = $operation['collectionInternalId'];\n+                        $documentId = $operation['documentId'];\n+\n+                        switch ($operation['action']) {\n+                            case 'create':\n+                                $creates[$databaseInternalId][$collectionInternalId][] = new Document([\n+                                    '$id' => $documentId ?? ID::unique(),\n+                                    ...$operation['data']\n+                                ]);\n+                                break;\n+                            case 'update':\n+                            case 'upsert':\n+                                $updates[$databaseInternalId][$collectionInternalId][] = new Document([\n+                                    '$id' => $documentId,\n+                                    ...$operation['data'],\n+                                ]);\n+                                break;\n+                            case 'delete':\n+                                $deletes[$databaseInternalId][$collectionInternalId][] = $documentId;\n+                                break;\n+                            case 'bulkUpdate':\n+                                $bulkUpdates[$databaseInternalId][$collectionInternalId][] = [\n+                                    'data' => $operation['data'] ?? null,\n+                                    'queries' => $operation['queries'] ?? [],\n+                                ];\n+                                break;\n+                            case 'bulkDelete':\n+                                $bulkDeletes[$databaseInternalId][$collectionInternalId][] = [\n+                                    'queries' => $operation['queries'] ?? [],\n+                                ];\n+                                break;\n+                        }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2153485635",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 10023,
        "pr_file": "app/controllers/api/databases.php",
        "discussion_id": "2153485635",
        "commented_code": "@@ -1536,6 +1538,392 @@\n             ->dynamic($attribute, Response::MODEL_ATTRIBUTE_IP);\n     });\n \n+App::post('/v1/databases/transactions')\n+    ->desc('Create transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createTransaction',\n+        description: '/docs/references/databases/create-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('ttl', APP_DATABASE_TXN_TTL_DEFAULT, new Range(min: APP_DATABASE_TXN_TTL_MIN, max: APP_DATABASE_TXN_TTL_MAX), 'Seconds before the transaction expires.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (int $ttl, Response $response, Database $dbForProject) {\n+        $transaction = $dbForProject->createDocument('transactions', new Document([\n+            '$id' => ID::unique(),\n+            'status' => 'pending',\n+            'operations' => 0,\n+            'expiresAt' => DateTime::addSeconds(new \\DateTime(), $ttl),\n+        ]));\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::post('/v1/databases/transactions/:transactionId/operations')\n+    ->desc('Add operations to transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'createOperations',\n+        description: '/docs/references/databases/create-operations.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_CREATED,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->param('operations', [], new ArrayList(new Operation()), 'Array of staged operations.', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->inject('plan')\n+    ->action(function (string $transactionId, array $operations, Response $response, Database $dbForProject, array $plan) {\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+        if ($transaction->isEmpty() || $transaction->getAttribute('status', '') !== 'pending') {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Invalid or non\u2011pending transaction');\n+        }\n+\n+        $maxBatch = $plan['databasesBatchSize'] ?? APP_LIMIT_DATABASE_BATCH;\n+        $existing = $transaction->getAttribute('operations', 0);\n+\n+        if (($existing + \\count($operations)) > $maxBatch) {\n+            throw new Exception(\n+                Exception::TRANSACTION_LIMIT_EXCEEDED,\n+                'Transaction already has ' . $existing . ' operations, adding ' . \\count($operations) . ' would exceed the maximum of ' . $maxBatch\n+            );\n+        }\n+\n+        $databases = $collections = $staged = [];\n+        foreach ($operations as $operation) {\n+            $database = $databases[$operation['databaseId']] ??= $dbForProject->getDocument('databases', $operation['databaseId']);\n+            if ($database->isEmpty()) {\n+                throw new Exception(Exception::DATABASE_NOT_FOUND);\n+            }\n+\n+            $collection = $collections[$operation['collectionId']] ??= $dbForProject->getDocument('database_' . $database->getSequence(), $operation['collectionId']);\n+            if ($collection->isEmpty()) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            }\n+\n+            $staged[] = new Document([\n+                '$id' => ID::unique(),\n+                'databaseInternalId' => $database->getSequence(),\n+                'collectionInternalId' => $collection->getSequence(),\n+                'transactionInternalId' => $transaction->getSequence(),\n+                'documentId' => $operation['documentId'] ?? ID::unique(),\n+                'action' => $operation['action'],\n+                'data' => $operation['data'] ?? new \\stdClass(),\n+            ]);\n+        }\n+\n+        $dbForProject->withTransaction(function () use ($dbForProject, $transactionId, $staged, $existing, $operations) {\n+            $dbForProject->createDocuments('transactionLogs', $staged);\n+            $dbForProject->updateDocument('transactions', $transactionId, new Document([\n+                'operations' => $existing + \\count($operations),\n+            ]));\n+        });\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_CREATED)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::get('/v1/databases/transactions')\n+    ->desc('List transactions')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.read')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'listTransactions',\n+        description: '/docs/references/databases/list-transactions.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_OK,\n+                model: Response::MODEL_TRANSACTION_LIST,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('queries', [], new Transactions(), 'Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries).', true)\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (array $queries, Response $response, Database $dbForProject) {\n+        try {\n+            $queries = Query::parseQueries($queries);\n+        } catch (QueryException $e) {\n+            throw new Exception(Exception::GENERAL_QUERY_INVALID, $e->getMessage());\n+        }\n+\n+        $response->dynamic(new Document([\n+            'transactions' => $dbForProject->find('transactions', $queries),\n+            'total' => $dbForProject->count('transactions', $queries),\n+        ]), Response::MODEL_TRANSACTION_LIST);\n+    });\n+\n+App::get('/v1/databases/transactions/:transactionId')\n+    ->desc('Get transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'transactions.read')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'getTransaction',\n+        description: '/docs/references/databases/get-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_OK,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->action(function (string $transactionId, Response $response, Database $dbForProject) {\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+\n+        if ($transaction->isEmpty()) {\n+            throw new Exception(Exception::TRANSACTION_NOT_FOUND);\n+        }\n+\n+        $response\n+            ->setStatusCode(Response::STATUS_CODE_OK)\n+            ->dynamic($transaction, Response::MODEL_TRANSACTION);\n+    });\n+\n+App::patch('/v1/databases/transactions/:transactionId')\n+    ->desc('Update transaction')\n+    ->groups(['api', 'database', 'transactions'])\n+    ->label('scope', 'collections.write')\n+    ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+    ->label('sdk', new Method(\n+        namespace: 'databases',\n+        group: 'transactions',\n+        name: 'updateTransaction',\n+        description: '/docs/references/databases/update-transaction.md',\n+        auth: [AuthType::KEY],\n+        responses: [\n+            new SDKResponse(\n+                code: Response::STATUS_CODE_OK,\n+                model: Response::MODEL_TRANSACTION,\n+            )\n+        ],\n+        contentType: ContentType::JSON\n+    ))\n+    ->param('transactionId', '', new UID(), 'Transaction ID.')\n+    ->param('commit', false, new Boolean(), 'Commit transaction?', true)\n+    ->param('rollback', false, new Boolean(), 'Rollback transaction?', true)\n+    ->inject('requestTimestamp')\n+    ->inject('response')\n+    ->inject('dbForProject')\n+    ->inject('project')\n+    ->action(function (string $transactionId, bool $commit, bool $rollback, ?\\DateTime $requestTimestamp, ?string $reason, Response $response, Database $dbForProject, Document $project) {\n+        if (!$commit && !$rollback) {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Either commit or rollback must be true');\n+        }\n+        if ($commit && $rollback) {\n+            throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Cannot commit and rollback at the same time');\n+        }\n+\n+        $transaction = $dbForProject->getDocument('transactions', $transactionId);\n+\n+        if ($transaction->isEmpty()) {\n+            throw new Exception(Exception::TRANSACTION_NOT_FOUND);\n+        }\n+\n+        if ($transaction->getAttribute('status', '') !== 'pending') {\n+            throw new Exception(Exception::TRANSACTION_NOT_READY);\n+        }\n+\n+        $now = new \\DateTime();\n+        $expiresAt = new \\DateTime($transaction->getAttribute('expiresAt'));\n+        if ($now > $expiresAt) {\n+            throw new Exception(Exception::TRANSACTION_EXPIRED);\n+        }\n+\n+        if ($commit) {\n+            $dbForProject->withRequestTimestamp($requestTimestamp, function () use ($dbForProject, $transactionId, $transaction, $requestTimestamp) {\n+                $dbForProject->withTransaction(function () use ($dbForProject, $transactionId, $transaction, $requestTimestamp) {\n+                    $dbForProject->updateDocument('transactions', $transactionId, new Document([\n+                        'status' => 'committing',\n+                    ]));\n+\n+                    $operations = $dbForProject->find('transactionLogs', [\n+                        Query::equal('transactionInternalId', [$transaction->getSequence()]),\n+                    ]);\n+\n+                    $creates = $updates = $deletes = $bulkUpdates = $bulkDeletes = [];\n+\n+                    foreach ($operations as $operation) {\n+                        $databaseInternalId = $operation['databaseInternalId'];\n+                        $collectionInternalId = $operation['collectionInternalId'];\n+                        $documentId = $operation['documentId'];\n+\n+                        switch ($operation['action']) {\n+                            case 'create':\n+                                $creates[$databaseInternalId][$collectionInternalId][] = new Document([\n+                                    '$id' => $documentId ?? ID::unique(),\n+                                    ...$operation['data']\n+                                ]);\n+                                break;\n+                            case 'update':\n+                            case 'upsert':\n+                                $updates[$databaseInternalId][$collectionInternalId][] = new Document([\n+                                    '$id' => $documentId,\n+                                    ...$operation['data'],\n+                                ]);\n+                                break;\n+                            case 'delete':\n+                                $deletes[$databaseInternalId][$collectionInternalId][] = $documentId;\n+                                break;\n+                            case 'bulkUpdate':\n+                                $bulkUpdates[$databaseInternalId][$collectionInternalId][] = [\n+                                    'data' => $operation['data'] ?? null,\n+                                    'queries' => $operation['queries'] ?? [],\n+                                ];\n+                                break;\n+                            case 'bulkDelete':\n+                                $bulkDeletes[$databaseInternalId][$collectionInternalId][] = [\n+                                    'queries' => $operation['queries'] ?? [],\n+                                ];\n+                                break;\n+                        }",
        "comment_created_at": "2025-06-18T02:14:39+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**`increment` / `decrement` actions are silently dropped on commit**\n\n`updateTransaction`\u2019s commit loop never handles the `increment` and `decrement` actions that are being written to `transactionLogs` by the respective endpoints.  \nAs a result, those staged mutations are lost \u2013 the transaction is marked *committed* while the underlying data never changes.\n\nAdd explicit branches (or reuse `increaseDocumentAttribute` / `decreaseDocumentAttribute`) before setting the transaction status to `committed`.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/controllers/api/databases.php around lines 1788 to 1816, the switch\nstatement handling transaction commit actions does not process 'increment' and\n'decrement' actions, causing those mutations to be lost. To fix this, add\nexplicit cases for 'increment' and 'decrement' in the switch, and call the\nappropriate functions like increaseDocumentAttribute and\ndecreaseDocumentAttribute to apply these changes before marking the transaction\nas committed.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2153485636",
    "pr_number": 10023,
    "pr_file": "app/controllers/api/databases.php",
    "created_at": "2025-06-18T02:14:39+00:00",
    "commented_code": "return $document;\n         }, $documents);\n \n-        try {\n-            $dbForProject->createDocuments(\n-                'database_' . $database->getSequence() . '_collection_' . $collection->getSequence(),\n-                $documents\n-            );\n-        } catch (DuplicateException) {\n-            throw new Exception(Exception::DOCUMENT_ALREADY_EXISTS);\n-        } catch (NotFoundException) {\n-            throw new Exception(Exception::COLLECTION_NOT_FOUND);\n-        } catch (RelationshipException $e) {\n-            throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n-        } catch (StructureException $e) {\n-            throw new Exception(Exception::DOCUMENT_INVALID_STRUCTURE, $e->getMessage());\n-        }\n+        if (!empty($transactionId)) {\n+            $operations = [];\n+            foreach ($documents as $document) {\n+                $operations[] = new Document([\n+                    'databaseInternalId' => $database->getSequence(),\n+                    'collectionInternalId' => $collection->getSequence(),\n+                    'transactionInternalId' => $transaction->getSequence(),\n+                    'documentId' => $document->getId(),\n+                    'action' => 'create',\n+                    'data' => $document->getArrayCopy(),\n+                ]);\n+            }\n \n-        $queueForEvents\n-            ->setParam('databaseId', $databaseId)\n-            ->setParam('collectionId', $collection->getId())\n-            ->setContext('collection', $collection)\n-            ->setContext('database', $database);\n+            try {\n+                $dbForProject->createDocuments('transactionLogs', $operations);\n+            } catch (DuplicateException) {\n+                throw new Exception(Exception::DOCUMENT_ALREADY_EXISTS);\n+            } catch (NotFoundException) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            } catch (RelationshipException $e) {\n+                throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n+            } catch (StructureException $e) {\n+                throw new Exception(Exception::DOCUMENT_INVALID_STRUCTURE, $e->getMessage());\n+            }\n+        } else {\n+            try {\n+                $dbForProject->createDocuments(\n+                    'database_' . $database->getSequence() . '_collection_' . $collection->getSequence(),\n+                    $documents\n+                );\n+            } catch (DuplicateException) {\n+                throw new Exception(Exception::DOCUMENT_ALREADY_EXISTS);\n+            } catch (NotFoundException) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            } catch (RelationshipException $e) {\n+                throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n+            } catch (StructureException $e) {\n+                throw new Exception(Exception::DOCUMENT_INVALID_STRUCTURE, $e->getMessage());\n+            }\n+        }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2153485636",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 10023,
        "pr_file": "app/controllers/api/databases.php",
        "discussion_id": "2153485636",
        "commented_code": "@@ -3494,26 +3893,46 @@\n             return $document;\n         }, $documents);\n \n-        try {\n-            $dbForProject->createDocuments(\n-                'database_' . $database->getSequence() . '_collection_' . $collection->getSequence(),\n-                $documents\n-            );\n-        } catch (DuplicateException) {\n-            throw new Exception(Exception::DOCUMENT_ALREADY_EXISTS);\n-        } catch (NotFoundException) {\n-            throw new Exception(Exception::COLLECTION_NOT_FOUND);\n-        } catch (RelationshipException $e) {\n-            throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n-        } catch (StructureException $e) {\n-            throw new Exception(Exception::DOCUMENT_INVALID_STRUCTURE, $e->getMessage());\n-        }\n+        if (!empty($transactionId)) {\n+            $operations = [];\n+            foreach ($documents as $document) {\n+                $operations[] = new Document([\n+                    'databaseInternalId' => $database->getSequence(),\n+                    'collectionInternalId' => $collection->getSequence(),\n+                    'transactionInternalId' => $transaction->getSequence(),\n+                    'documentId' => $document->getId(),\n+                    'action' => 'create',\n+                    'data' => $document->getArrayCopy(),\n+                ]);\n+            }\n \n-        $queueForEvents\n-            ->setParam('databaseId', $databaseId)\n-            ->setParam('collectionId', $collection->getId())\n-            ->setContext('collection', $collection)\n-            ->setContext('database', $database);\n+            try {\n+                $dbForProject->createDocuments('transactionLogs', $operations);\n+            } catch (DuplicateException) {\n+                throw new Exception(Exception::DOCUMENT_ALREADY_EXISTS);\n+            } catch (NotFoundException) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            } catch (RelationshipException $e) {\n+                throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n+            } catch (StructureException $e) {\n+                throw new Exception(Exception::DOCUMENT_INVALID_STRUCTURE, $e->getMessage());\n+            }\n+        } else {\n+            try {\n+                $dbForProject->createDocuments(\n+                    'database_' . $database->getSequence() . '_collection_' . $collection->getSequence(),\n+                    $documents\n+                );\n+            } catch (DuplicateException) {\n+                throw new Exception(Exception::DOCUMENT_ALREADY_EXISTS);\n+            } catch (NotFoundException) {\n+                throw new Exception(Exception::COLLECTION_NOT_FOUND);\n+            } catch (RelationshipException $e) {\n+                throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n+            } catch (StructureException $e) {\n+                throw new Exception(Exception::DOCUMENT_INVALID_STRUCTURE, $e->getMessage());\n+            }\n+        }",
        "comment_created_at": "2025-06-18T02:14:39+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**`transactions.operations` never updated for staged single-document creates**\n\nWhen `transactionId` is supplied to `createDocument`, an entry is pushed to `transactionLogs` but the parent transaction\u2019s `operations` counter is **not** incremented nor is the batch-limit checked.  \nThis bypasses the safety limits enforced in `/operations`, making it possible to exceed `databasesBatchSize`.\n\nUpdate the transaction inside the same DB transaction used for logging:\n\n```diff\n$dbForProject->withTransaction(function () use ($dbForProject, $transaction) {\n    $dbForProject->createDocuments('transactionLogs', $operations);\n+   $dbForProject->updateDocument('transactions', $transaction->getId(), new Document([\n+       'operations' => $transaction->getAttribute('operations') + count($operations),\n+   ]));\n});\n```\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/controllers/api/databases.php around lines 3896 to 3935, when\ntransactionId is provided, the code logs operations to transactionLogs but does\nnot update the parent transaction's operations counter or check the batch limit,\nwhich can bypass safety limits. To fix this, modify the code to increment the\ntransaction's operations count and perform the batch size check within the same\ndatabase transaction that logs the operations, ensuring consistency and\nenforcing limits properly.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2099681758",
    "pr_number": 9845,
    "pr_file": "app/init/resources.php",
    "created_at": "2025-05-21T08:25:15+00:00",
    "commented_code": "App::setResource('getLogsDB', function (Group $pools, Cache $cache) {\n     $database = null;\n-    return function (?Document $project = null) use ($pools, $cache, $database) {\n+\n+    return function (?Document $project = null) use ($pools, $cache, &$database) {\n         if ($database !== null && $project !== null && !$project->isEmpty() && $project->getId() !== 'console') {\n             $database->setTenant($project->getInternalId());\n             return $database;\n         }\n \n-        $dbAdapter = $pools\n-            ->get('logs')\n-            ->pop()\n-            ->getResource();\n-\n-        $database = new Database(\n-            $dbAdapter,\n-            $cache\n-        );\n+        $adapter = new DatabasePool($pools->get('logs'));\n+        $database = new Database($adapter, $cache);",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2099681758",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9845,
        "pr_file": "app/init/resources.php",
        "discussion_id": "2099681758",
        "commented_code": "@@ -437,21 +428,15 @@\n \n App::setResource('getLogsDB', function (Group $pools, Cache $cache) {\n     $database = null;\n-    return function (?Document $project = null) use ($pools, $cache, $database) {\n+\n+    return function (?Document $project = null) use ($pools, $cache, &$database) {\n         if ($database !== null && $project !== null && !$project->isEmpty() && $project->getId() !== 'console') {\n             $database->setTenant($project->getInternalId());\n             return $database;\n         }\n \n-        $dbAdapter = $pools\n-            ->get('logs')\n-            ->pop()\n-            ->getResource();\n-\n-        $database = new Database(\n-            $dbAdapter,\n-            $cache\n-        );\n+        $adapter = new DatabasePool($pools->get('logs'));\n+        $database = new Database($adapter, $cache);\n ",
        "comment_created_at": "2025-05-21T08:25:15+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Re-entrancy bug in `getLogsDB`: adapter reused across tenants**  \nWhen a second project calls the closure, we mutate the previously cached `$database` with `setTenant()`. Any coroutine that is still using the old tenant will suddenly be switched mid-request.\n\nEither:  \n1. Keep a per-tenant cache (`$databases[$tenantId]`) instead of a single variable, or  \n2. Return a *fresh* `Database` per call (preferred).\n\n```diff\n-    $database = null;\n-    return function (?Document $project = null) use ($pools, $cache, &$database) {\n+    $databases = [];\n+    return function (?Document $project = null) use ($pools, $cache, &$databases) {\n@@\n-        if ($database !== null && $project !== null ... ) {\n-            ...\n-        }\n+        $key = $project?->getInternalId() ?? '_console';\n+        if (isset($databases[$key])) {\n+            return $databases[$key];\n+        }\n@@\n-        $database = new Database($adapter, $cache);\n+        $database = $databases[$key] = new Database($adapter, $cache);\n```\n\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    $databases = [];\n\n    return function (?Document $project = null) use ($pools, $cache, &$databases) {\n        $key = $project?->getInternalId() ?? '_console';\n        if (isset($databases[$key])) {\n            return $databases[$key];\n        }\n\n        $adapter = new DatabasePool($pools->get('logs'));\n        $database = $databases[$key] = new Database($adapter, $cache);\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/init/resources.php around lines 430 to 440, the closure caches a single\nDatabase instance and mutates its tenant on subsequent calls, causing tenant\ndata to be switched mid-request. To fix this, avoid reusing the same Database\nobject across different tenants by either maintaining a per-tenant cache keyed\nby tenant ID or, preferably, by returning a new Database instance on each call\nwithout caching it in a shared variable.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2092358548",
    "pr_number": 9738,
    "pr_file": "src/Appwrite/Migration/Migration.php",
    "created_at": "2025-05-16T05:40:16+00:00",
    "commented_code": "default => 'projects',\n         };\n \n-        if (!$this->projectDB->exists(System::getEnv('_APP_DB_SCHEMA', 'appwrite'), $name)) {\n+        if (!$this->dbForProject->getCollection($id)->isEmpty()) {\n             $attributes = [];\n             $indexes = [];\n             $collection = $this->collections[$collectionType][$id];\n-\n             foreach ($collection['attributes'] as $attribute) {\n-                $attributes[] = new Document([\n-                    '$id' => $attribute['$id'],\n-                    'type' => $attribute['type'],\n-                    'size' => $attribute['size'],\n-                    'required' => $attribute['required'],\n-                    'default' => $attribute['default'] ?? null,\n-                    'signed' => $attribute['signed'],\n-                    'array' => $attribute['array'],\n-                    'filters' => $attribute['filters'],\n-                ]);\n+                $attributes[] = new Document($attribute);\n             }\n-\n             foreach ($collection['indexes'] as $index) {\n-                $indexes[] = new Document([\n-                    '$id' => $index['$id'],\n-                    'type' => $index['type'],\n-                    'attributes' => $index['attributes'],\n-                    'lengths' => $index['lengths'],\n-                    'orders' => $index['orders'],\n-                ]);\n+                $indexes[] = new Document($index);\n             }\n \n-            try {\n-                $this->projectDB->createCollection($name, $attributes, $indexes);\n-            } catch (\\Throwable $th) {\n-                throw $th;\n+            $this->dbForProject->createCollection($name, $attributes, $indexes);\n+        }\n+    }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2092358548",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9738,
        "pr_file": "src/Appwrite/Migration/Migration.php",
        "discussion_id": "2092358548",
        "commented_code": "@@ -262,54 +207,104 @@ protected function createCollection(string $id, string $name = null): void\n             default => 'projects',\n         };\n \n-        if (!$this->projectDB->exists(System::getEnv('_APP_DB_SCHEMA', 'appwrite'), $name)) {\n+        if (!$this->dbForProject->getCollection($id)->isEmpty()) {\n             $attributes = [];\n             $indexes = [];\n             $collection = $this->collections[$collectionType][$id];\n-\n             foreach ($collection['attributes'] as $attribute) {\n-                $attributes[] = new Document([\n-                    '$id' => $attribute['$id'],\n-                    'type' => $attribute['type'],\n-                    'size' => $attribute['size'],\n-                    'required' => $attribute['required'],\n-                    'default' => $attribute['default'] ?? null,\n-                    'signed' => $attribute['signed'],\n-                    'array' => $attribute['array'],\n-                    'filters' => $attribute['filters'],\n-                ]);\n+                $attributes[] = new Document($attribute);\n             }\n-\n             foreach ($collection['indexes'] as $index) {\n-                $indexes[] = new Document([\n-                    '$id' => $index['$id'],\n-                    'type' => $index['type'],\n-                    'attributes' => $index['attributes'],\n-                    'lengths' => $index['lengths'],\n-                    'orders' => $index['orders'],\n-                ]);\n+                $indexes[] = new Document($index);\n             }\n \n-            try {\n-                $this->projectDB->createCollection($name, $attributes, $indexes);\n-            } catch (\\Throwable $th) {\n-                throw $th;\n+            $this->dbForProject->createCollection($name, $attributes, $indexes);\n+        }\n+    }",
        "comment_created_at": "2025-05-16T05:40:16+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Collection-creation guard inverted \u2013 may recreate existing collections**\n\n`createCollection()` proceeds when the collection is **not** empty:\n\n```php\nif (!$this->dbForProject->getCollection($id)->isEmpty()) {\n    ...\n    $this->dbForProject->createCollection(...)\n}\n```\n\nThe negation means we only attempt creation when the collection already exists, which triggers `duplicate` errors and slows the run.  \nSwitch the condition to `isEmpty()`:\n\n\n```diff\n-        if (!$this->dbForProject->getCollection($id)->isEmpty()) {\n+        if ($this->dbForProject->getCollection($id)->isEmpty()) {\n```\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn src/Appwrite/Migration/Migration.php around lines 210 to 223, the condition\nchecking whether to create a collection is inverted, causing attempts to\nrecreate collections that already exist. Change the if statement to check if the\ncollection is empty by removing the negation, so that createCollection() is only\ncalled when the collection does not exist yet.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n\u2705 Addressed in commits 697d23e to a3722f5",
        "pr_file_module": null
      }
    ]
  }
]