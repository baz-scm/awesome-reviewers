[
  {
    "discussion_id": "2072814647",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Rows/Update.php",
    "created_at": "2025-05-05T03:45:48+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Rows;\n+\n+use Appwrite\\Auth\\Auth;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Authorization as AuthorizationException;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\NotFound as NotFoundException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Helpers\\Role;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Action;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\JSON;\n+\n+class Update extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'updateRow';\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PATCH)\n+            ->setHttpPath('/v1/databases/:databaseId/tables/:tableId/rows/:rowId')\n+            ->httpAlias('/v1/databases/:databaseId/collections/:tableId/documents/:rowId')\n+            ->desc('Update row')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].tables.[tableId].rows.[rowId].update')\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'row.update')\n+            ->label('audits.resource', 'database/{request.databaseId}/table/{request.tableId}/row/{response.$id}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: 'rows',\n+                name: 'updateRow',\n+                description: '/docs/references/databases/update-document.md',\n+                auth: [AuthType::SESSION, AuthType::KEY, AuthType::JWT],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: UtopiaResponse::MODEL_DOCUMENT,\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('tableId', '', new UID(), 'Collection ID.')\n+            ->param('rowId', '', new UID(), 'Row ID.')\n+            ->param('data', [], new JSON(), 'Row data as JSON object. Include only columns and value pairs to be updated.', true)\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE, [Database::PERMISSION_READ, Database::PERMISSION_UPDATE, Database::PERMISSION_DELETE, Database::PERMISSION_WRITE]), 'An array of permissions strings. By default, the current permissions are inherited. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->inject('requestTimestamp')\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->inject('queueForStatsUsage')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $tableId, string $rowId, string|array $data, ?array $permissions, ?\\DateTime $requestTimestamp, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents, StatsUsage $queueForStatsUsage): void\n+    {\n+\n+        $data = (\\is_string($data)) ? \\json_decode($data, true) : $data; // Cast to JSON array\n+\n+        if (empty($data) && \\is_null($permissions)) {\n+            throw new Exception(Exception::DOCUMENT_MISSING_PAYLOAD);\n+        }\n+",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2072814647",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Rows/Update.php",
        "discussion_id": "2072814647",
        "commented_code": "@@ -0,0 +1,302 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Rows;\n+\n+use Appwrite\\Auth\\Auth;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Authorization as AuthorizationException;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\NotFound as NotFoundException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Helpers\\Role;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Action;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\JSON;\n+\n+class Update extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'updateRow';\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PATCH)\n+            ->setHttpPath('/v1/databases/:databaseId/tables/:tableId/rows/:rowId')\n+            ->httpAlias('/v1/databases/:databaseId/collections/:tableId/documents/:rowId')\n+            ->desc('Update row')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].tables.[tableId].rows.[rowId].update')\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'row.update')\n+            ->label('audits.resource', 'database/{request.databaseId}/table/{request.tableId}/row/{response.$id}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: 'rows',\n+                name: 'updateRow',\n+                description: '/docs/references/databases/update-document.md',\n+                auth: [AuthType::SESSION, AuthType::KEY, AuthType::JWT],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: UtopiaResponse::MODEL_DOCUMENT,\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('tableId', '', new UID(), 'Collection ID.')\n+            ->param('rowId', '', new UID(), 'Row ID.')\n+            ->param('data', [], new JSON(), 'Row data as JSON object. Include only columns and value pairs to be updated.', true)\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE, [Database::PERMISSION_READ, Database::PERMISSION_UPDATE, Database::PERMISSION_DELETE, Database::PERMISSION_WRITE]), 'An array of permissions strings. By default, the current permissions are inherited. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->inject('requestTimestamp')\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->inject('queueForStatsUsage')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $tableId, string $rowId, string|array $data, ?array $permissions, ?\\DateTime $requestTimestamp, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents, StatsUsage $queueForStatsUsage): void\n+    {\n+\n+        $data = (\\is_string($data)) ? \\json_decode($data, true) : $data; // Cast to JSON array\n+\n+        if (empty($data) && \\is_null($permissions)) {\n+            throw new Exception(Exception::DOCUMENT_MISSING_PAYLOAD);\n+        }\n+",
        "comment_created_at": "2025-05-05T03:45:48+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Silently swallowing JSON-decode errors can mask client bugs**\n\n`json_decode()` returns `null` on invalid JSON.  \nBecause `empty($data)` subsequently evaluates to `true`, the user receives the generic \u201cmissing payload\u201d error instead of a clear \u201cinvalid JSON\u201d message, making debugging harder.\n\n```diff\n- $data = (\\is_string($data)) ? \\json_decode($data, true) : $data; // Cast to JSON array\n+ if (\\is_string($data)) {\n+     $data = \\json_decode($data, true, 512, JSON_THROW_ON_ERROR);\n+ }\n```\n\nWrap the call in a `try \u2026 catch (\\JsonException $e)` and throw `Exception::DOCUMENT_INVALID_STRUCTURE` (or introduce a dedicated constant) with the parse error message.  \nThis keeps behaviour explicit and avoids hiding client-side mistakes.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077802583",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Attributes/Float/Create.php",
    "created_at": "2025-05-07T14:42:47+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Attributes\\Float;\n+\n+use Appwrite\\Event\\Database as EventDatabase;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\Platform\\Modules\\Databases\\Http\\Attributes\\Action;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Validator\\Key;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\FloatValidator;\n+use Utopia\\Validator\\Range;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createFloatAttribute';\n+    }\n+\n+    public function __construct()\n+    {\n+        $this->setResponseModel(UtopiaResponse::MODEL_ATTRIBUTE_FLOAT);\n+\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/attributes/float')\n+            ->desc('Create float attribute')\n+            ->groups(['api', 'database', 'schema'])\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].attributes.[attributeId].create')\n+            ->label('audits.event', 'attribute.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/create-float-attribute.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_ACCEPTED,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ]\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('key', '', new Key(), 'Attribute Key.')\n+            ->param('required', null, new Boolean(), 'Is attribute required?')\n+            ->param('min', null, new FloatValidator(), 'Minimum value.', true)\n+            ->param('max', null, new FloatValidator(), 'Maximum value.', true)\n+            ->param('default', null, new FloatValidator(), 'Default value. Cannot be set when required.', true)\n+            ->param('array', false, new Boolean(), 'Is attribute an array?', true)",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2077802583",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Attributes/Float/Create.php",
        "discussion_id": "2077802583",
        "commented_code": "@@ -0,0 +1,121 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Attributes\\Float;\n+\n+use Appwrite\\Event\\Database as EventDatabase;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\Platform\\Modules\\Databases\\Http\\Attributes\\Action;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Validator\\Key;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\Boolean;\n+use Utopia\\Validator\\FloatValidator;\n+use Utopia\\Validator\\Range;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createFloatAttribute';\n+    }\n+\n+    public function __construct()\n+    {\n+        $this->setResponseModel(UtopiaResponse::MODEL_ATTRIBUTE_FLOAT);\n+\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/attributes/float')\n+            ->desc('Create float attribute')\n+            ->groups(['api', 'database', 'schema'])\n+            ->label('scope', 'collections.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].attributes.[attributeId].create')\n+            ->label('audits.event', 'attribute.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}')\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/create-float-attribute.md',\n+                auth: [AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_ACCEPTED,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ]\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('key', '', new Key(), 'Attribute Key.')\n+            ->param('required', null, new Boolean(), 'Is attribute required?')\n+            ->param('min', null, new FloatValidator(), 'Minimum value.', true)\n+            ->param('max', null, new FloatValidator(), 'Maximum value.', true)\n+            ->param('default', null, new FloatValidator(), 'Default value. Cannot be set when required.', true)\n+            ->param('array', false, new Boolean(), 'Is attribute an array?', true)",
        "comment_created_at": "2025-05-07T14:42:47+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Missing validation: `default` must be null when `required` is true**  \nThe doc-string explicitly states \u201cDefault value. Cannot be set when required.\u201d but the implementation only checks the numeric range.  \nA client can therefore create a required attribute with a default value, violating the contract and producing ambiguous semantics at write-time.\n\n```diff\n@@\n-        $validator = new Range($min, $max, Database::VAR_FLOAT);\n-        if (!\\is_null($default) && !$validator->isValid($default)) {\n+        if ($required && !\\is_null($default)) {\n+            throw new Exception($this->getInvalidValueException(), 'Required attributes cannot have a default value.');\n+        }\n+\n+        $validator = new Range($min, $max, Database::VAR_FLOAT);\n+        if (!\\is_null($default) && !$validator->isValid($default)) {\n             throw new Exception($this->getInvalidValueException(), $validator->getDescription());\n         }\n```\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077802590",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Collections/Usage/Get.php",
    "created_at": "2025-05-07T14:42:47+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Collections\\Usage;\n+\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\Platform\\Modules\\Databases\\Http\\Collections\\Action;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Config\\Config;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Query;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\WhiteList;\n+\n+class Get extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'getCollectionUsage';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_USAGE_COLLECTION;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_GET)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/usage')\n+            ->desc('Get collection usage stats')\n+            ->groups(['api', 'database', 'usage'])\n+            ->label('scope', 'collections.read')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: null,\n+                name: self::getName(),\n+                description: '/docs/references/databases/get-collection-usage.md',\n+                auth: [AuthType::ADMIN],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: $this->getResponseModel()\n+                    )\n+                ],\n+                contentType: ContentType::JSON,\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('range', '30d', new WhiteList(['24h', '30d', '90d'], true), 'Date range.', true)\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $range, string $collectionId, UtopiaResponse $response, Database $dbForProject): void\n+    {\n+        $database = $dbForProject->getDocument('databases', $databaseId);\n+        $collectionDocument = $dbForProject->getDocument('database_' . $database->getInternalId(), $collectionId);\n+        $collection = $dbForProject->getCollection('database_' . $database->getInternalId() . '_collection_' . $collectionDocument->getInternalId());\n+\n+        if ($collection->isEmpty()) {\n+            throw new Exception($this->getNotFoundException());\n+        }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2077802590",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Collections/Usage/Get.php",
        "discussion_id": "2077802590",
        "commented_code": "@@ -0,0 +1,139 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Collections\\Usage;\n+\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\Platform\\Modules\\Databases\\Http\\Collections\\Action;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Config\\Config;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Query;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\WhiteList;\n+\n+class Get extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'getCollectionUsage';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_USAGE_COLLECTION;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_GET)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/usage')\n+            ->desc('Get collection usage stats')\n+            ->groups(['api', 'database', 'usage'])\n+            ->label('scope', 'collections.read')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('sdk', new Method(\n+                namespace: 'databases',\n+                group: null,\n+                name: self::getName(),\n+                description: '/docs/references/databases/get-collection-usage.md',\n+                auth: [AuthType::ADMIN],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: $this->getResponseModel()\n+                    )\n+                ],\n+                contentType: ContentType::JSON,\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('range', '30d', new WhiteList(['24h', '30d', '90d'], true), 'Date range.', true)\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->callback([$this, 'action']);\n+    }\n+\n+    public function action(string $databaseId, string $range, string $collectionId, UtopiaResponse $response, Database $dbForProject): void\n+    {\n+        $database = $dbForProject->getDocument('databases', $databaseId);\n+        $collectionDocument = $dbForProject->getDocument('database_' . $database->getInternalId(), $collectionId);\n+        $collection = $dbForProject->getCollection('database_' . $database->getInternalId() . '_collection_' . $collectionDocument->getInternalId());\n+\n+        if ($collection->isEmpty()) {\n+            throw new Exception($this->getNotFoundException());\n+        }",
        "comment_created_at": "2025-05-07T14:42:47+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**`collectionDocument` may be empty \u2013 add explicit not-found guard**  \nIf the supplied `collectionId` does not exist, `$collectionDocument->getInternalId()` will raise before you reach the later `isEmpty()` check on `$collection`. Insert an early guard similar to the one for collections/tables in other endpoints.\n\n```diff\n-        $collectionDocument = $dbForProject->getDocument('database_' . $database->getInternalId(), $collectionId);\n-        $collection = $dbForProject->getCollection('database_' . $database->getInternalId() . '_collection_' . $collectionDocument->getInternalId());\n+        $collectionDocument = $dbForProject->getDocument('database_' . $database->getInternalId(), $collectionId);\n+        if ($collectionDocument->isEmpty()) {\n+            throw new Exception($this->getNotFoundException());\n+        }\n+\n+        $collection = $dbForProject->getCollection(\n+            'database_' . $database->getInternalId() . '_collection_' . $collectionDocument->getInternalId()\n+        );\n```\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142300622",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Upsert.php",
    "created_at": "2025-06-12T10:29:00+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents;\n+\n+use Appwrite\\Auth\\Auth;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Conflict as ConflictException;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\Relationship as RelationshipException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Helpers\\Role;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\JSON;\n+\n+class Upsert extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'upsertDocument';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PUT)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/documents/:documentId')\n+            ->desc('Upsert document')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].documents.[documentId].upsert')\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'document.upsert')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}/document/{response.$id}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', [\n+                new Method(\n+                    namespace: $this->getSdkNamespace(),\n+                    group: $this->getSdkGroup(),\n+                    name: self::getName(),\n+                    description: '/docs/references/databases/upsert-document.md',\n+                    auth: [AuthType::SESSION, AuthType::KEY, AuthType::JWT],\n+                    responses: [\n+                        new SDKResponse(\n+                            code: SwooleResponse::STATUS_CODE_CREATED,\n+                            model: $this->getResponseModel(),\n+                        )\n+                    ],\n+                    contentType: ContentType::JSON\n+                ),\n+            ])\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('documentId', '', new CustomId(), 'Document ID.')\n+            ->param('data', [], new JSON(), 'Document data as JSON object. Include all required attributes of the document to be created or updated.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE, [Database::PERMISSION_READ, Database::PERMISSION_UPDATE, Database::PERMISSION_DELETE, Database::PERMISSION_WRITE]), 'An array of permissions strings. By default, the current permissions are inherited. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->inject('requestTimestamp')\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->inject('queueForStatsUsage')\n+            ->callback($this->action(...));\n+    }\n+\n+    public function action(string $databaseId, string $collectionId, string $documentId, string|array $data, ?array $permissions, ?\\DateTime $requestTimestamp, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents, StatsUsage $queueForStatsUsage): void\n+    {\n+        $data = (\\is_string($data)) ? \\json_decode($data, true) : $data; // Cast to JSON array\n+\n+        if (empty($data) && \\is_null($permissions)) {\n+            throw new Exception($this->getMissingPayloadException());\n+        }\n+\n+        $isAPIKey = Auth::isAppUser(Authorization::getRoles());\n+        $isPrivilegedUser = Auth::isPrivilegedUser(Authorization::getRoles());\n+\n+        $database = Authorization::skip(fn () => $dbForProject->getDocument('databases', $databaseId));\n+        if ($database->isEmpty() || (!$database->getAttribute('enabled', false) && !$isAPIKey && !$isPrivilegedUser)) {\n+            throw new Exception(Exception::DATABASE_NOT_FOUND);\n+        }\n+\n+        $collection = Authorization::skip(fn () => $dbForProject->getDocument('database_' . $database->getSequence(), $collectionId));\n+        if ($collection->isEmpty() || (!$collection->getAttribute('enabled', false) && !$isAPIKey && !$isPrivilegedUser)) {\n+            throw new Exception($this->getParentNotFoundException());\n+        }\n+\n+        // Map aggregate permissions into the multiple permissions they represent.\n+        $permissions = Permission::aggregate($permissions, [\n+            Database::PERMISSION_READ,\n+            Database::PERMISSION_UPDATE,\n+            Database::PERMISSION_DELETE,\n+        ]);\n+\n+        // Users can only manage their own roles, API keys and Admin users can manage any\n+        $roles = Authorization::getRoles();\n+        if (!$isAPIKey && !$isPrivilegedUser && !\\is_null($permissions)) {\n+            foreach (Database::PERMISSIONS as $type) {\n+                foreach ($permissions as $permission) {\n+                    $permission = Permission::parse($permission);\n+                    if ($permission->getPermission() != $type) {\n+                        continue;\n+                    }\n+                    $role = (new Role(\n+                        $permission->getRole(),\n+                        $permission->getIdentifier(),\n+                        $permission->getDimension()\n+                    ))->toString();\n+                    if (!Authorization::isRole($role)) {\n+                        throw new Exception(Exception::USER_UNAUTHORIZED, 'Permissions must be one of: (' . \\implode(', ', $roles) . ')');\n+                    }\n+                }\n+            }\n+        }\n+\n+        $data['$id'] = $documentId;\n+        $data['$permissions'] = $permissions;\n+        $newDocument = new Document($data);\n+\n+        $operations = 0;\n+\n+        $setCollection = (function (Document $collection, Document $document) use (&$setCollection, $dbForProject, $database, &$operations) {\n+\n+            $operations++;\n+\n+            $relationships = \\array_filter(\n+                $collection->getAttribute('attributes', []),\n+                fn ($attribute) => $attribute->getAttribute('type') === Database::VAR_RELATIONSHIP\n+            );\n+\n+            foreach ($relationships as $relationship) {\n+                $related = $document->getAttribute($relationship->getAttribute('key'));\n+\n+                if (empty($related)) {\n+                    continue;\n+                }\n+\n+                $isList = \\is_array($related) && \\array_values($related) === $related;\n+\n+                if ($isList) {\n+                    $relations = $related;\n+                } else {\n+                    $relations = [$related];\n+                }\n+\n+                $relatedCollectionId = $relationship->getAttribute('relatedCollection');\n+                $relatedCollection = Authorization::skip(\n+                    fn () => $dbForProject->getDocument('database_' . $database->getSequence(), $relatedCollectionId)\n+                );\n+\n+                foreach ($relations as &$relation) {\n+                    // If the relation is an array it can be either update or create a child document.\n+                    if (\n+                        \\is_array($relation)\n+                        && \\array_values($relation) !== $relation\n+                        && !isset($relation['$id'])\n+                    ) {\n+                        $relation['$id'] = ID::unique();\n+                        $relation = new Document($relation);\n+                    }\n+                    if ($relation instanceof Document) {\n+                        $oldDocument = Authorization::skip(fn () => $dbForProject->getDocument(\n+                            'database_' . $database->getSequence() . '_collection_' . $relatedCollection->getSequence(),\n+                            $relation->getId()\n+                        ));\n+                        $relation->removeAttribute('$collectionId');\n+                        $relation->removeAttribute('$databaseId');\n+                        // Attribute $collection is required for Utopia.\n+                        $relation->setAttribute(\n+                            '$collection',\n+                            'database_' . $database->getSequence() . '_collection_' . $relatedCollection->getSequence()\n+                        );\n+\n+                        if ($oldDocument->isEmpty()) {\n+                            if (isset($relation['$id']) && $relation['$id'] === 'unique()') {\n+                                $relation['$id'] = ID::unique();\n+                            }\n+                        }\n+                        $setCollection($relatedCollection, $relation);\n+                    }\n+                }\n+\n+                if ($isList) {\n+                    $document->setAttribute($relationship->getAttribute('key'), \\array_values($relations));\n+                } else {\n+                    $document->setAttribute($relationship->getAttribute('key'), \\reset($relations));\n+                }\n+            }\n+        });\n+\n+        $setCollection($collection, $newDocument);\n+\n+        $queueForStatsUsage\n+            ->addMetric(METRIC_DATABASES_OPERATIONS_WRITES, \\max(1, $operations))\n+            ->addMetric(str_replace('{databaseInternalId}', $database->getSequence(), METRIC_DATABASE_ID_OPERATIONS_WRITES), \\max(1, $operations));\n+\n+        $upserted = [];\n+        try {\n+            $dbForProject->createOrUpdateDocuments(\n+                'database_' . $database->getSequence() . '_collection_' . $collection->getSequence(),\n+                [$newDocument],\n+                onNext: function (Document $document) use (&$upserted) {\n+                    $upserted[] = $document;\n+                },\n+            );\n+        } catch (ConflictException) {\n+            throw new Exception($this->getConflictException());\n+        } catch (DuplicateException) {\n+            throw new Exception($this->getDuplicateException());\n+        } catch (RelationshipException $e) {\n+            throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n+        } catch (StructureException $e) {\n+            throw new Exception($this->getInvalidStructureException(), $e->getMessage());\n+        }\n+\n+        $document = $upserted[0];\n+        // Add $collectionId and $databaseId for all documents\n+        $processDocument = function (Document $table, Document $document) use (&$processDocument, $dbForProject, $database) {\n+            $document->setAttribute('$databaseId', $database->getId());\n+            $document->setAttribute('$collectionId', $table->getId());\n+\n+            $relationships = \\array_filter(\n+                $table->getAttribute('attributes', []),\n+                fn ($attribute) => $attribute->getAttribute('type') === Database::VAR_RELATIONSHIP\n+            );\n+\n+            foreach ($relationships as $relationship) {\n+                $related = $document->getAttribute($relationship->getAttribute('key'));\n+\n+                if (empty($related)) {\n+                    continue;\n+                }\n+                if (!\\is_array($related)) {\n+                    $related = [$related];\n+                }\n+\n+                $relatedCollectionId = $relationship->getAttribute('relatedCollection');\n+                $relatedCollection = Authorization::skip(\n+                    fn () => $dbForProject->getDocument('database_' . $database->getSequence(), $relatedCollectionId)\n+                );\n+\n+                foreach ($related as $relation) {\n+                    if ($relation instanceof Document) {\n+                        $processDocument($relatedCollection, $relation);\n+                    }\n+                }\n+            }\n+        };\n+\n+        $processDocument($collection, $document);\n+\n+        $relationships = \\array_map(\n+            fn ($document) => $document->getAttribute('key'),\n+            \\array_filter(\n+                $collection->getAttribute('attributes', []),\n+                fn ($attribute) => $attribute->getAttribute('type') === Database::VAR_RELATIONSHIP\n+            )\n+        );\n+\n+        $queueForEvents\n+            ->setParam('databaseId', $databaseId)\n+            ->setContext('database', $database)\n+            ->setParam('collectionId', $collection->getId())\n+            ->setParam('tableId', $collection->getId())\n+            ->setParam('documentId', $document->getId())\n+            ->setParam('rowId', $document->getId())\n+            ->setContext($this->getCollectionsEventsContext(), $collection)\n+            ->setPayload($response->getPayload(), sensitive: $relationships);\n+\n+        $response->dynamic(\n+            $document,\n+            $this->getResponseModel()\n+        );",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2142300622",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Upsert.php",
        "discussion_id": "2142300622",
        "commented_code": "@@ -0,0 +1,297 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents;\n+\n+use Appwrite\\Auth\\Auth;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Conflict as ConflictException;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\Relationship as RelationshipException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Helpers\\Role;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\JSON;\n+\n+class Upsert extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'upsertDocument';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PUT)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/documents/:documentId')\n+            ->desc('Upsert document')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].documents.[documentId].upsert')\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'document.upsert')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}/document/{response.$id}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', [\n+                new Method(\n+                    namespace: $this->getSdkNamespace(),\n+                    group: $this->getSdkGroup(),\n+                    name: self::getName(),\n+                    description: '/docs/references/databases/upsert-document.md',\n+                    auth: [AuthType::SESSION, AuthType::KEY, AuthType::JWT],\n+                    responses: [\n+                        new SDKResponse(\n+                            code: SwooleResponse::STATUS_CODE_CREATED,\n+                            model: $this->getResponseModel(),\n+                        )\n+                    ],\n+                    contentType: ContentType::JSON\n+                ),\n+            ])\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('documentId', '', new CustomId(), 'Document ID.')\n+            ->param('data', [], new JSON(), 'Document data as JSON object. Include all required attributes of the document to be created or updated.')\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE, [Database::PERMISSION_READ, Database::PERMISSION_UPDATE, Database::PERMISSION_DELETE, Database::PERMISSION_WRITE]), 'An array of permissions strings. By default, the current permissions are inherited. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->inject('requestTimestamp')\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForEvents')\n+            ->inject('queueForStatsUsage')\n+            ->callback($this->action(...));\n+    }\n+\n+    public function action(string $databaseId, string $collectionId, string $documentId, string|array $data, ?array $permissions, ?\\DateTime $requestTimestamp, UtopiaResponse $response, Database $dbForProject, Event $queueForEvents, StatsUsage $queueForStatsUsage): void\n+    {\n+        $data = (\\is_string($data)) ? \\json_decode($data, true) : $data; // Cast to JSON array\n+\n+        if (empty($data) && \\is_null($permissions)) {\n+            throw new Exception($this->getMissingPayloadException());\n+        }\n+\n+        $isAPIKey = Auth::isAppUser(Authorization::getRoles());\n+        $isPrivilegedUser = Auth::isPrivilegedUser(Authorization::getRoles());\n+\n+        $database = Authorization::skip(fn () => $dbForProject->getDocument('databases', $databaseId));\n+        if ($database->isEmpty() || (!$database->getAttribute('enabled', false) && !$isAPIKey && !$isPrivilegedUser)) {\n+            throw new Exception(Exception::DATABASE_NOT_FOUND);\n+        }\n+\n+        $collection = Authorization::skip(fn () => $dbForProject->getDocument('database_' . $database->getSequence(), $collectionId));\n+        if ($collection->isEmpty() || (!$collection->getAttribute('enabled', false) && !$isAPIKey && !$isPrivilegedUser)) {\n+            throw new Exception($this->getParentNotFoundException());\n+        }\n+\n+        // Map aggregate permissions into the multiple permissions they represent.\n+        $permissions = Permission::aggregate($permissions, [\n+            Database::PERMISSION_READ,\n+            Database::PERMISSION_UPDATE,\n+            Database::PERMISSION_DELETE,\n+        ]);\n+\n+        // Users can only manage their own roles, API keys and Admin users can manage any\n+        $roles = Authorization::getRoles();\n+        if (!$isAPIKey && !$isPrivilegedUser && !\\is_null($permissions)) {\n+            foreach (Database::PERMISSIONS as $type) {\n+                foreach ($permissions as $permission) {\n+                    $permission = Permission::parse($permission);\n+                    if ($permission->getPermission() != $type) {\n+                        continue;\n+                    }\n+                    $role = (new Role(\n+                        $permission->getRole(),\n+                        $permission->getIdentifier(),\n+                        $permission->getDimension()\n+                    ))->toString();\n+                    if (!Authorization::isRole($role)) {\n+                        throw new Exception(Exception::USER_UNAUTHORIZED, 'Permissions must be one of: (' . \\implode(', ', $roles) . ')');\n+                    }\n+                }\n+            }\n+        }\n+\n+        $data['$id'] = $documentId;\n+        $data['$permissions'] = $permissions;\n+        $newDocument = new Document($data);\n+\n+        $operations = 0;\n+\n+        $setCollection = (function (Document $collection, Document $document) use (&$setCollection, $dbForProject, $database, &$operations) {\n+\n+            $operations++;\n+\n+            $relationships = \\array_filter(\n+                $collection->getAttribute('attributes', []),\n+                fn ($attribute) => $attribute->getAttribute('type') === Database::VAR_RELATIONSHIP\n+            );\n+\n+            foreach ($relationships as $relationship) {\n+                $related = $document->getAttribute($relationship->getAttribute('key'));\n+\n+                if (empty($related)) {\n+                    continue;\n+                }\n+\n+                $isList = \\is_array($related) && \\array_values($related) === $related;\n+\n+                if ($isList) {\n+                    $relations = $related;\n+                } else {\n+                    $relations = [$related];\n+                }\n+\n+                $relatedCollectionId = $relationship->getAttribute('relatedCollection');\n+                $relatedCollection = Authorization::skip(\n+                    fn () => $dbForProject->getDocument('database_' . $database->getSequence(), $relatedCollectionId)\n+                );\n+\n+                foreach ($relations as &$relation) {\n+                    // If the relation is an array it can be either update or create a child document.\n+                    if (\n+                        \\is_array($relation)\n+                        && \\array_values($relation) !== $relation\n+                        && !isset($relation['$id'])\n+                    ) {\n+                        $relation['$id'] = ID::unique();\n+                        $relation = new Document($relation);\n+                    }\n+                    if ($relation instanceof Document) {\n+                        $oldDocument = Authorization::skip(fn () => $dbForProject->getDocument(\n+                            'database_' . $database->getSequence() . '_collection_' . $relatedCollection->getSequence(),\n+                            $relation->getId()\n+                        ));\n+                        $relation->removeAttribute('$collectionId');\n+                        $relation->removeAttribute('$databaseId');\n+                        // Attribute $collection is required for Utopia.\n+                        $relation->setAttribute(\n+                            '$collection',\n+                            'database_' . $database->getSequence() . '_collection_' . $relatedCollection->getSequence()\n+                        );\n+\n+                        if ($oldDocument->isEmpty()) {\n+                            if (isset($relation['$id']) && $relation['$id'] === 'unique()') {\n+                                $relation['$id'] = ID::unique();\n+                            }\n+                        }\n+                        $setCollection($relatedCollection, $relation);\n+                    }\n+                }\n+\n+                if ($isList) {\n+                    $document->setAttribute($relationship->getAttribute('key'), \\array_values($relations));\n+                } else {\n+                    $document->setAttribute($relationship->getAttribute('key'), \\reset($relations));\n+                }\n+            }\n+        });\n+\n+        $setCollection($collection, $newDocument);\n+\n+        $queueForStatsUsage\n+            ->addMetric(METRIC_DATABASES_OPERATIONS_WRITES, \\max(1, $operations))\n+            ->addMetric(str_replace('{databaseInternalId}', $database->getSequence(), METRIC_DATABASE_ID_OPERATIONS_WRITES), \\max(1, $operations));\n+\n+        $upserted = [];\n+        try {\n+            $dbForProject->createOrUpdateDocuments(\n+                'database_' . $database->getSequence() . '_collection_' . $collection->getSequence(),\n+                [$newDocument],\n+                onNext: function (Document $document) use (&$upserted) {\n+                    $upserted[] = $document;\n+                },\n+            );\n+        } catch (ConflictException) {\n+            throw new Exception($this->getConflictException());\n+        } catch (DuplicateException) {\n+            throw new Exception($this->getDuplicateException());\n+        } catch (RelationshipException $e) {\n+            throw new Exception(Exception::RELATIONSHIP_VALUE_INVALID, $e->getMessage());\n+        } catch (StructureException $e) {\n+            throw new Exception($this->getInvalidStructureException(), $e->getMessage());\n+        }\n+\n+        $document = $upserted[0];\n+        // Add $collectionId and $databaseId for all documents\n+        $processDocument = function (Document $table, Document $document) use (&$processDocument, $dbForProject, $database) {\n+            $document->setAttribute('$databaseId', $database->getId());\n+            $document->setAttribute('$collectionId', $table->getId());\n+\n+            $relationships = \\array_filter(\n+                $table->getAttribute('attributes', []),\n+                fn ($attribute) => $attribute->getAttribute('type') === Database::VAR_RELATIONSHIP\n+            );\n+\n+            foreach ($relationships as $relationship) {\n+                $related = $document->getAttribute($relationship->getAttribute('key'));\n+\n+                if (empty($related)) {\n+                    continue;\n+                }\n+                if (!\\is_array($related)) {\n+                    $related = [$related];\n+                }\n+\n+                $relatedCollectionId = $relationship->getAttribute('relatedCollection');\n+                $relatedCollection = Authorization::skip(\n+                    fn () => $dbForProject->getDocument('database_' . $database->getSequence(), $relatedCollectionId)\n+                );\n+\n+                foreach ($related as $relation) {\n+                    if ($relation instanceof Document) {\n+                        $processDocument($relatedCollection, $relation);\n+                    }\n+                }\n+            }\n+        };\n+\n+        $processDocument($collection, $document);\n+\n+        $relationships = \\array_map(\n+            fn ($document) => $document->getAttribute('key'),\n+            \\array_filter(\n+                $collection->getAttribute('attributes', []),\n+                fn ($attribute) => $attribute->getAttribute('type') === Database::VAR_RELATIONSHIP\n+            )\n+        );\n+\n+        $queueForEvents\n+            ->setParam('databaseId', $databaseId)\n+            ->setContext('database', $database)\n+            ->setParam('collectionId', $collection->getId())\n+            ->setParam('tableId', $collection->getId())\n+            ->setParam('documentId', $document->getId())\n+            ->setParam('rowId', $document->getId())\n+            ->setContext($this->getCollectionsEventsContext(), $collection)\n+            ->setPayload($response->getPayload(), sensitive: $relationships);\n+\n+        $response->dynamic(\n+            $document,\n+            $this->getResponseModel()\n+        );",
        "comment_created_at": "2025-06-12T10:29:00+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Event payload is captured before the response is populated**\n\n`setPayload($response->getPayload(), \u2026)` is called **before** `response->dynamic()`, so `getPayload()` returns `null`, resulting in an empty event body.\n\n```diff\n-            ->setPayload($response->getPayload(), sensitive: $relationships);\n-\n-        $response->dynamic(\n+        $response->dynamic(\n             $document,\n             $this->getResponseModel()\n-        );\n+        );\n+\n+        $queueForEvents\n+            ->setPayload($response->getPayload(), sensitive: $relationships);\n```\n\nFixing the order ensures subscribers receive the expected document snapshot.  \n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn\nsrc/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Upsert.php\nbetween lines 282 and 295, the event payload is set using\n$response->getPayload() before the response is populated by\n$response->dynamic(). This causes getPayload() to return null and results in an\nempty event body. To fix this, move the call to $response->dynamic() before\nsetting the payload on $queueForEvents so that the payload contains the updated\ndocument snapshot when setPayload() is called.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142300626",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Create.php",
    "created_at": "2025-06-12T10:29:01+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents;\n+\n+use Appwrite\\Auth\\Auth;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Parameter;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\NotFound as NotFoundException;\n+use Utopia\\Database\\Exception\\Relationship as RelationshipException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Helpers\\Role;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\ArrayList;\n+use Utopia\\Validator\\JSON;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createDocument';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT;\n+    }\n+\n+    protected function getBulkResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT_LIST;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/documents')\n+            ->desc('Create document')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].documents.[documentId].create')\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'document.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', [\n+                new Method(\n+                    namespace: $this->getSdkNamespace(),\n+                    group: $this->getSdkGroup(),\n+                    name: self::getName(),\n+                    description: '/docs/references/databases/create-document.md',\n+                    auth: [AuthType::SESSION, AuthType::KEY, AuthType::JWT],\n+                    responses: [\n+                        new SDKResponse(\n+                            code: SwooleResponse::STATUS_CODE_CREATED,\n+                            model: $this->getResponseModel(),\n+                        )\n+                    ],\n+                    contentType: ContentType::JSON,\n+                    parameters: [\n+                        new Parameter('databaseId', optional: false),\n+                        new Parameter('collectionId', optional: false),\n+                        new Parameter('documentId', optional: false),\n+                        new Parameter('data', optional: false),\n+                        new Parameter('permissions', optional: true),\n+                    ]\n+                ),\n+                new Method(\n+                    namespace: $this->getSdkNamespace(),\n+                    group: $this->getSdkGroup(),\n+                    name: $this->getBulkActionName(self::getName()),\n+                    description: '/docs/references/databases/create-documents.md',\n+                    auth: [AuthType::ADMIN, AuthType::KEY],\n+                    responses: [\n+                        new SDKResponse(\n+                            code: SwooleResponse::STATUS_CODE_CREATED,\n+                            model: $this->getBulkResponseModel(),\n+                        )\n+                    ],\n+                    contentType: ContentType::JSON,\n+                    parameters: [\n+                        new Parameter('databaseId', optional: false),\n+                        new Parameter('collectionId', optional: false),\n+                        new Parameter('documents', optional: false),\n+                    ]\n+                )\n+            ])\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('documentId', '', new CustomId(), 'Document ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\\'t start with a special char. Max length is 36 chars.', true)\n+            ->param('collectionId', '', new UID(), 'Collection ID. You can create a new collection using the Database service [server integration](https://appwrite.io/docs/server/databases#databasesCreateCollection). Make sure to define attributes before creating documents.')\n+            ->param('data', [], new JSON(), 'Document data as JSON object.', true)\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE, [Database::PERMISSION_READ, Database::PERMISSION_UPDATE, Database::PERMISSION_DELETE, Database::PERMISSION_WRITE]), 'An array of permissions strings. By default, only the current user is granted all permissions. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documents', [], fn (array $plan) => new ArrayList(new JSON(), $plan['databasesBatchSize'] ?? APP_LIMIT_DATABASE_BATCH), 'Array of documents data as JSON objects.', true, ['plan'])\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('user')\n+            ->inject('queueForEvents')\n+            ->inject('queueForStatsUsage')\n+            ->callback($this->action(...));\n+    }\n+\n+    public function action(string $databaseId, string $documentId, string $collectionId, string|array $data, ?array $permissions, ?array $documents, UtopiaResponse $response, Database $dbForProject, Document $user, Event $queueForEvents, StatsUsage $queueForStatsUsage): void\n+    {\n+        $data = \\is_string($data)\n+            ? \\json_decode($data, true)\n+            : $data;\n+\n+        /**\n+         * Determine which internal path to call, single or bulk",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2142300626",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Create.php",
        "discussion_id": "2142300626",
        "commented_code": "@@ -0,0 +1,447 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents;\n+\n+use Appwrite\\Auth\\Auth;\n+use Appwrite\\Event\\Event;\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Parameter;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Database\\Validator\\CustomId;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Duplicate as DuplicateException;\n+use Utopia\\Database\\Exception\\NotFound as NotFoundException;\n+use Utopia\\Database\\Exception\\Relationship as RelationshipException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Helpers\\ID;\n+use Utopia\\Database\\Helpers\\Permission;\n+use Utopia\\Database\\Helpers\\Role;\n+use Utopia\\Database\\Validator\\Authorization;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\ArrayList;\n+use Utopia\\Validator\\JSON;\n+\n+class Create extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'createDocument';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT;\n+    }\n+\n+    protected function getBulkResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT_LIST;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_POST)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/documents')\n+            ->desc('Create document')\n+            ->groups(['api', 'database'])\n+            ->label('event', 'databases.[databaseId].collections.[collectionId].documents.[documentId].create')\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'document.create')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', [\n+                new Method(\n+                    namespace: $this->getSdkNamespace(),\n+                    group: $this->getSdkGroup(),\n+                    name: self::getName(),\n+                    description: '/docs/references/databases/create-document.md',\n+                    auth: [AuthType::SESSION, AuthType::KEY, AuthType::JWT],\n+                    responses: [\n+                        new SDKResponse(\n+                            code: SwooleResponse::STATUS_CODE_CREATED,\n+                            model: $this->getResponseModel(),\n+                        )\n+                    ],\n+                    contentType: ContentType::JSON,\n+                    parameters: [\n+                        new Parameter('databaseId', optional: false),\n+                        new Parameter('collectionId', optional: false),\n+                        new Parameter('documentId', optional: false),\n+                        new Parameter('data', optional: false),\n+                        new Parameter('permissions', optional: true),\n+                    ]\n+                ),\n+                new Method(\n+                    namespace: $this->getSdkNamespace(),\n+                    group: $this->getSdkGroup(),\n+                    name: $this->getBulkActionName(self::getName()),\n+                    description: '/docs/references/databases/create-documents.md',\n+                    auth: [AuthType::ADMIN, AuthType::KEY],\n+                    responses: [\n+                        new SDKResponse(\n+                            code: SwooleResponse::STATUS_CODE_CREATED,\n+                            model: $this->getBulkResponseModel(),\n+                        )\n+                    ],\n+                    contentType: ContentType::JSON,\n+                    parameters: [\n+                        new Parameter('databaseId', optional: false),\n+                        new Parameter('collectionId', optional: false),\n+                        new Parameter('documents', optional: false),\n+                    ]\n+                )\n+            ])\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('documentId', '', new CustomId(), 'Document ID. Choose a custom ID or generate a random ID with `ID.unique()`. Valid chars are a-z, A-Z, 0-9, period, hyphen, and underscore. Can\\'t start with a special char. Max length is 36 chars.', true)\n+            ->param('collectionId', '', new UID(), 'Collection ID. You can create a new collection using the Database service [server integration](https://appwrite.io/docs/server/databases#databasesCreateCollection). Make sure to define attributes before creating documents.')\n+            ->param('data', [], new JSON(), 'Document data as JSON object.', true)\n+            ->param('permissions', null, new Permissions(APP_LIMIT_ARRAY_PARAMS_SIZE, [Database::PERMISSION_READ, Database::PERMISSION_UPDATE, Database::PERMISSION_DELETE, Database::PERMISSION_WRITE]), 'An array of permissions strings. By default, only the current user is granted all permissions. [Learn more about permissions](https://appwrite.io/docs/permissions).', true)\n+            ->param('documents', [], fn (array $plan) => new ArrayList(new JSON(), $plan['databasesBatchSize'] ?? APP_LIMIT_DATABASE_BATCH), 'Array of documents data as JSON objects.', true, ['plan'])\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('user')\n+            ->inject('queueForEvents')\n+            ->inject('queueForStatsUsage')\n+            ->callback($this->action(...));\n+    }\n+\n+    public function action(string $databaseId, string $documentId, string $collectionId, string|array $data, ?array $permissions, ?array $documents, UtopiaResponse $response, Database $dbForProject, Document $user, Event $queueForEvents, StatsUsage $queueForStatsUsage): void\n+    {\n+        $data = \\is_string($data)\n+            ? \\json_decode($data, true)\n+            : $data;\n+\n+        /**\n+         * Determine which internal path to call, single or bulk",
        "comment_created_at": "2025-06-12T10:29:01+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**No validation of `json_decode()` result \u2013 malformed JSON is silently treated as \u201cmissing data\u201d**\n\n`json_decode()` returns `null` on malformed JSON, which then triggers the \u201cmissing data\u201d branch instead of a 400 *invalid JSON* error. Clients receive an ambiguous message.\n\n```diff\n-        $data = \\is_string($data)\n-            ? \\json_decode($data, true)\n-            : $data;\n+        if (\\is_string($data)) {\n+            $data = \\json_decode($data, true);\n+            if (\\json_last_error() !== JSON_ERROR_NONE) {\n+                throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Malformed JSON in \"data\" payload');\n+            }\n+        }\n```\n\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    {\n-        $data = \\is_string($data)\n-            ? \\json_decode($data, true)\n-            : $data;\n+        if (\\is_string($data)) {\n+            $data = \\json_decode($data, true);\n+            if (\\json_last_error() !== JSON_ERROR_NONE) {\n+                throw new Exception(Exception::GENERAL_BAD_REQUEST, 'Malformed JSON in \"data\" payload');\n+            }\n+        }\n\n        /**\n         * Determine which internal path to call, single or bulk\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn\nsrc/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Create.php\naround lines 124 to 130, the code decodes JSON input but does not check if\njson_decode() failed, causing malformed JSON to be treated as missing data. Add\na validation step after json_decode() to check if the result is null and\njson_last_error() indicates an error, then return a 400 error response\nindicating invalid JSON input to provide clear feedback to clients.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142564137",
    "pr_number": 9693,
    "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Bulk/Update.php",
    "created_at": "2025-06-12T12:06:14+00:00",
    "commented_code": "+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents\\Bulk;\n+\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents\\Action;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Conflict as ConflictException;\n+use Utopia\\Database\\Exception\\Query as QueryException;\n+use Utopia\\Database\\Exception\\Relationship as RelationshipException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Query;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\ArrayList;\n+use Utopia\\Validator\\JSON;\n+use Utopia\\Validator\\Text;\n+\n+class Update extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'updateDocuments';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT_LIST;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PATCH)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/documents')\n+            ->desc('Update documents')\n+            ->groups(['api', 'database'])\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'documents.update')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', new Method(\n+                namespace: $this->getSdkNamespace(),\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/update-documents.md',\n+                auth: [AuthType::ADMIN, AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('data', [], new JSON(), 'Document data as JSON object. Include only attribute and value pairs to be updated.', true)\n+            ->param('queries', [], new ArrayList(new Text(APP_LIMIT_ARRAY_ELEMENT_SIZE), APP_LIMIT_ARRAY_PARAMS_SIZE), 'Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of ' . APP_LIMIT_ARRAY_PARAMS_SIZE . ' queries are allowed, each ' . APP_LIMIT_ARRAY_ELEMENT_SIZE . ' characters long.', true)\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForStatsUsage')\n+            ->inject('plan')\n+            ->callback($this->action(...));\n+    }\n+\n+    public function action(string $databaseId, string $collectionId, string|array $data, array $queries, UtopiaResponse $response, Database $dbForProject, StatsUsage $queueForStatsUsage, array $plan): void\n+    {\n+        $data = \\is_string($data)\n+            ? \\json_decode($data, true)\n+            : $data;\n+\n+        if (empty($data)) {\n+            throw new Exception($this->getMissingPayloadException());\n+        }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2142564137",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9693,
        "pr_file": "src/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Bulk/Update.php",
        "discussion_id": "2142564137",
        "commented_code": "@@ -0,0 +1,158 @@\n+<?php\n+\n+namespace Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents\\Bulk;\n+\n+use Appwrite\\Event\\StatsUsage;\n+use Appwrite\\Extend\\Exception;\n+use Appwrite\\Platform\\Modules\\Databases\\Http\\Databases\\Collections\\Documents\\Action;\n+use Appwrite\\SDK\\AuthType;\n+use Appwrite\\SDK\\ContentType;\n+use Appwrite\\SDK\\Method;\n+use Appwrite\\SDK\\Response as SDKResponse;\n+use Appwrite\\Utopia\\Response as UtopiaResponse;\n+use Utopia\\Database\\Database;\n+use Utopia\\Database\\Document;\n+use Utopia\\Database\\Exception\\Conflict as ConflictException;\n+use Utopia\\Database\\Exception\\Query as QueryException;\n+use Utopia\\Database\\Exception\\Relationship as RelationshipException;\n+use Utopia\\Database\\Exception\\Structure as StructureException;\n+use Utopia\\Database\\Query;\n+use Utopia\\Database\\Validator\\Permissions;\n+use Utopia\\Database\\Validator\\UID;\n+use Utopia\\Platform\\Scope\\HTTP;\n+use Utopia\\Swoole\\Response as SwooleResponse;\n+use Utopia\\Validator\\ArrayList;\n+use Utopia\\Validator\\JSON;\n+use Utopia\\Validator\\Text;\n+\n+class Update extends Action\n+{\n+    use HTTP;\n+\n+    public static function getName(): string\n+    {\n+        return 'updateDocuments';\n+    }\n+\n+    protected function getResponseModel(): string\n+    {\n+        return UtopiaResponse::MODEL_DOCUMENT_LIST;\n+    }\n+\n+    public function __construct()\n+    {\n+        $this\n+            ->setHttpMethod(self::HTTP_REQUEST_METHOD_PATCH)\n+            ->setHttpPath('/v1/databases/:databaseId/collections/:collectionId/documents')\n+            ->desc('Update documents')\n+            ->groups(['api', 'database'])\n+            ->label('scope', 'documents.write')\n+            ->label('resourceType', RESOURCE_TYPE_DATABASES)\n+            ->label('audits.event', 'documents.update')\n+            ->label('audits.resource', 'database/{request.databaseId}/collection/{request.collectionId}')\n+            ->label('abuse-key', 'ip:{ip},method:{method},url:{url},userId:{userId}')\n+            ->label('abuse-limit', APP_LIMIT_WRITE_RATE_DEFAULT * 2)\n+            ->label('abuse-time', APP_LIMIT_WRITE_RATE_PERIOD_DEFAULT)\n+            ->label('sdk', new Method(\n+                namespace: $this->getSdkNamespace(),\n+                group: $this->getSdkGroup(),\n+                name: self::getName(),\n+                description: '/docs/references/databases/update-documents.md',\n+                auth: [AuthType::ADMIN, AuthType::KEY],\n+                responses: [\n+                    new SDKResponse(\n+                        code: SwooleResponse::STATUS_CODE_OK,\n+                        model: $this->getResponseModel(),\n+                    )\n+                ],\n+                contentType: ContentType::JSON\n+            ))\n+            ->param('databaseId', '', new UID(), 'Database ID.')\n+            ->param('collectionId', '', new UID(), 'Collection ID.')\n+            ->param('data', [], new JSON(), 'Document data as JSON object. Include only attribute and value pairs to be updated.', true)\n+            ->param('queries', [], new ArrayList(new Text(APP_LIMIT_ARRAY_ELEMENT_SIZE), APP_LIMIT_ARRAY_PARAMS_SIZE), 'Array of query strings generated using the Query class provided by the SDK. [Learn more about queries](https://appwrite.io/docs/queries). Maximum of ' . APP_LIMIT_ARRAY_PARAMS_SIZE . ' queries are allowed, each ' . APP_LIMIT_ARRAY_ELEMENT_SIZE . ' characters long.', true)\n+            ->inject('response')\n+            ->inject('dbForProject')\n+            ->inject('queueForStatsUsage')\n+            ->inject('plan')\n+            ->callback($this->action(...));\n+    }\n+\n+    public function action(string $databaseId, string $collectionId, string|array $data, array $queries, UtopiaResponse $response, Database $dbForProject, StatsUsage $queueForStatsUsage, array $plan): void\n+    {\n+        $data = \\is_string($data)\n+            ? \\json_decode($data, true)\n+            : $data;\n+\n+        if (empty($data)) {\n+            throw new Exception($this->getMissingPayloadException());\n+        }",
        "comment_created_at": "2025-06-12T12:06:14+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Invalid JSON is silently swallowed**\n\nIf `json_decode` fails it returns `null`, which passes `empty($data)` and triggers \u201cmissing payload\u201d rather than \u201cinvalid JSON\u201d.  \nValidate the decode result and throw a dedicated error to help clients diagnose bad input.\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn\nsrc/Appwrite/Platform/Modules/Databases/Http/Databases/Collections/Documents/Bulk/Update.php\naround lines 83 to 89, the code silently treats invalid JSON as missing payload\nby checking empty($data) after json_decode. To fix this, explicitly check if\njson_decode returned null and json_last_error() indicates an error, then throw a\ndedicated exception for invalid JSON before the empty check. This will help\nclients distinguish between missing payload and malformed JSON input.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2155513148",
    "pr_number": 10010,
    "pr_file": "tests/e2e/Services/Account/AccountCustomClientTest.php",
    "created_at": "2025-06-18T21:06:52+00:00",
    "commented_code": "$this->assertTrue((new DatetimeValidator())->isValid($response['body']['registration']));\n         $this->assertEquals($response['body']['email'], $email);\n \n+        $currentSessionId = $data['sessionId'] ?? '';\n+        $response = $this->client->call(Client::METHOD_GET, '/account/sessions', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]));\n+\n+        $this->assertEquals(200, $response['headers']['status-code']);\n+        $this->assertEquals(1, $response['body']['total']);\n+        // checking the current session or not\n+        $this->assertEquals($currentSessionId, $response['body']['sessions'][0]['$id']);\n+        $this->assertTrue($response['body']['sessions'][0]['current']);\n+\n+        // checking for all non active sessions are cleared\n+        foreach ($allSessions as $sessionId) {\n+            if ($currentSessionId === $sessionId) {\n+                $response = $this->client->call(Client::METHOD_GET, '/account/sessions/current', array_merge([\n+                    'origin' => 'http://localhost',\n+                    'content-type' => 'application/json',\n+                    'x-appwrite-project' => $this->getProject()['$id'],\n+                    'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+                ]));\n+\n+                $this->assertEquals(200, $response['headers']['status-code']);\n+            } else {\n+                $response = $this->client->call(Client::METHOD_GET, '/account/sessions/'.$sessionId, array_merge([\n+                    'origin' => 'http://localhost',\n+                    'content-type' => 'application/json',\n+                    'x-appwrite-project' => $this->getProject()['$id'],\n+                    'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+                ]));\n+\n+                $this->assertEquals(404, $response['headers']['status-code']);\n+            }\n+        }\n+\n+        $newPassword = 'new-password';\n+        // updating the invalidateSession to false to check sessions are not invalidated\n+        $this->updateProjectinvalidateSessionsProperty(false);\n+        for ($i = 0; $i < 5; $i++) {\n+            $response = $this->client->call(Client::METHOD_POST, '/account/sessions/email', array_merge([\n+                'origin' => 'http://localhost',\n+                'content-type' => 'application/json',\n+                'x-appwrite-project' => $this->getProject()['$id'],\n+            ]), [\n+                'email' => $email,\n+                'password' => $newPassword,\n+            ]);\n+\n+            $this->assertEquals(201, $response['headers']['status-code']);\n+            sleep(1);\n+        }\n+\n+        $response = $this->client->call(Client::METHOD_GET, '/account/sessions', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]));\n+\n+        $allSessions = array_map(fn ($sessionDetails) => $sessionDetails['$id'], $response['body']['sessions']);\n+\n+        $response = $this->client->call(Client::METHOD_PATCH, '/account/password', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]), [\n+            'password' => $newPassword,\n+            'oldPassword' => $newPassword,\n+        ]);\n+\n+        $this->assertEquals(200, $response['headers']['status-code']);\n+\n+        foreach ($allSessions as $sessionId) {\n+            $response = $this->client->call(Client::METHOD_GET, '/account/sessions/'.$sessionId, headers: array_merge([\n+                'origin' => 'http://localhost',\n+                'content-type' => 'application/json',\n+                'x-appwrite-project' => $this->getProject()['$id'],\n+                'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+            ]));\n+\n+            $this->assertEquals(200, $response['headers']['status-code']);\n+        }\n+\n+        // setting invalidateSession to true to check the sessions are cleared or not\n+        $this->updateProjectinvalidateSessionsProperty(true);\n+        $response = $this->client->call(Client::METHOD_PATCH, '/account/password', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]), [\n+            'password' => $newPassword,\n+            'oldPassword' => $newPassword,\n+        ]);",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2155513148",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 10010,
        "pr_file": "tests/e2e/Services/Account/AccountCustomClientTest.php",
        "discussion_id": "2155513148",
        "commented_code": "@@ -500,17 +523,140 @@\n         $this->assertTrue((new DatetimeValidator())->isValid($response['body']['registration']));\n         $this->assertEquals($response['body']['email'], $email);\n \n+        $currentSessionId = $data['sessionId'] ?? '';\n+        $response = $this->client->call(Client::METHOD_GET, '/account/sessions', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]));\n+\n+        $this->assertEquals(200, $response['headers']['status-code']);\n+        $this->assertEquals(1, $response['body']['total']);\n+        // checking the current session or not\n+        $this->assertEquals($currentSessionId, $response['body']['sessions'][0]['$id']);\n+        $this->assertTrue($response['body']['sessions'][0]['current']);\n+\n+        // checking for all non active sessions are cleared\n+        foreach ($allSessions as $sessionId) {\n+            if ($currentSessionId === $sessionId) {\n+                $response = $this->client->call(Client::METHOD_GET, '/account/sessions/current', array_merge([\n+                    'origin' => 'http://localhost',\n+                    'content-type' => 'application/json',\n+                    'x-appwrite-project' => $this->getProject()['$id'],\n+                    'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+                ]));\n+\n+                $this->assertEquals(200, $response['headers']['status-code']);\n+            } else {\n+                $response = $this->client->call(Client::METHOD_GET, '/account/sessions/'.$sessionId, array_merge([\n+                    'origin' => 'http://localhost',\n+                    'content-type' => 'application/json',\n+                    'x-appwrite-project' => $this->getProject()['$id'],\n+                    'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+                ]));\n+\n+                $this->assertEquals(404, $response['headers']['status-code']);\n+            }\n+        }\n+\n+        $newPassword = 'new-password';\n+        // updating the invalidateSession to false to check sessions are not invalidated\n+        $this->updateProjectinvalidateSessionsProperty(false);\n+        for ($i = 0; $i < 5; $i++) {\n+            $response = $this->client->call(Client::METHOD_POST, '/account/sessions/email', array_merge([\n+                'origin' => 'http://localhost',\n+                'content-type' => 'application/json',\n+                'x-appwrite-project' => $this->getProject()['$id'],\n+            ]), [\n+                'email' => $email,\n+                'password' => $newPassword,\n+            ]);\n+\n+            $this->assertEquals(201, $response['headers']['status-code']);\n+            sleep(1);\n+        }\n+\n+        $response = $this->client->call(Client::METHOD_GET, '/account/sessions', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]));\n+\n+        $allSessions = array_map(fn ($sessionDetails) => $sessionDetails['$id'], $response['body']['sessions']);\n+\n+        $response = $this->client->call(Client::METHOD_PATCH, '/account/password', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]), [\n+            'password' => $newPassword,\n+            'oldPassword' => $newPassword,\n+        ]);\n+\n+        $this->assertEquals(200, $response['headers']['status-code']);\n+\n+        foreach ($allSessions as $sessionId) {\n+            $response = $this->client->call(Client::METHOD_GET, '/account/sessions/'.$sessionId, headers: array_merge([\n+                'origin' => 'http://localhost',\n+                'content-type' => 'application/json',\n+                'x-appwrite-project' => $this->getProject()['$id'],\n+                'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+            ]));\n+\n+            $this->assertEquals(200, $response['headers']['status-code']);\n+        }\n+\n+        // setting invalidateSession to true to check the sessions are cleared or not\n+        $this->updateProjectinvalidateSessionsProperty(true);\n+        $response = $this->client->call(Client::METHOD_PATCH, '/account/password', array_merge([\n+            'origin' => 'http://localhost',\n+            'content-type' => 'application/json',\n+            'x-appwrite-project' => $this->getProject()['$id'],\n+            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n+        ]), [\n+            'password' => $newPassword,\n+            'oldPassword' => $newPassword,\n+        ]);",
        "comment_created_at": "2025-06-18T21:06:52+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Another password inconsistency issue**\n\nSimilar to the earlier issue, using the same value for both `password` and `oldPassword` parameters doesn't make logical sense for a password update operation.\n\n\n\n```diff\n-        ]), [\n-            'password' => $newPassword,\n-            'oldPassword' => $newPassword,\n-        ]);\n+        ]), [\n+            'password' => 'final-new-password',\n+            'oldPassword' => $newPassword,\n+        ]);\n```\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n        $response = $this->client->call(Client::METHOD_PATCH, '/account/password', array_merge([\n            'origin' => 'http://localhost',\n            'content-type' => 'application/json',\n            'x-appwrite-project' => $this->getProject()['$id'],\n            'cookie' => 'a_session_' . $this->getProject()['$id'] . '=' . $session,\n        ]), [\n            'password' => 'final-new-password',\n            'oldPassword' => $newPassword,\n        ]);\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn tests/e2e/Services/Account/AccountCustomClientTest.php around lines 614 to\n622, the password update call incorrectly uses the same value for both\n'password' and 'oldPassword' parameters. To fix this, ensure 'oldPassword' holds\nthe current password value and 'password' holds the new password value to\ncorrectly represent a password change operation.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136714245",
    "pr_number": 9985,
    "pr_file": "app/controllers/api/messaging.php",
    "created_at": "2025-06-10T00:38:49+00:00",
    "commented_code": "throw new Exception(Exception::STORAGE_BUCKET_NOT_FOUND);\n             }\n \n-            $file = $dbForProject->getDocument('bucket_' . $bucket->getInternalId(), $fileId);\n+            $file = $dbForProject->getDocument('bucket_' . $bucket->getSequence(), $fileId);\n             if ($file->isEmpty()) {\n                 throw new Exception(Exception::STORAGE_BUCKET_NOT_FOUND);\n             }",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2136714245",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9985,
        "pr_file": "app/controllers/api/messaging.php",
        "discussion_id": "2136714245",
        "commented_code": "@@ -3232,7 +3232,7 @@\n                 throw new Exception(Exception::STORAGE_BUCKET_NOT_FOUND);\n             }\n \n-            $file = $dbForProject->getDocument('bucket_' . $bucket->getInternalId(), $fileId);\n+            $file = $dbForProject->getDocument('bucket_' . $bucket->getSequence(), $fileId);\n             if ($file->isEmpty()) {\n                 throw new Exception(Exception::STORAGE_BUCKET_NOT_FOUND);\n             }",
        "comment_created_at": "2025-06-10T00:38:49+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Correct exception type on file lookup failure**  \nCurrently, missing files in both the push create and update handlers throw `STORAGE_BUCKET_NOT_FOUND`, which is misleading. They should throw `STORAGE_FILE_NOT_FOUND` for clarity and consistency.  \n\nApply this diff:\n```diff\n-    if ($file->isEmpty()) {\n-        throw new Exception(Exception::STORAGE_BUCKET_NOT_FOUND);\n-    }\n+    if ($file->isEmpty()) {\n+        throw new Exception(Exception::STORAGE_FILE_NOT_FOUND);\n+    }\n```\n\n\nAlso applies to: 4213-4216\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn app/controllers/api/messaging.php at lines 3235 to 3238 and also at lines\n4213 to 4216, the code throws an Exception with STORAGE_BUCKET_NOT_FOUND when a\nfile is not found, which is misleading. Change the exception thrown in these\nfile lookup failure cases to STORAGE_FILE_NOT_FOUND to accurately reflect the\nerror. Update the throw statements accordingly in both locations.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2081556953",
    "pr_number": 9738,
    "pr_file": "src/Appwrite/Migration/Version/V23.php",
    "created_at": "2025-05-09T12:21:59+00:00",
    "commented_code": "Console::warning(\"'_key_roles' from {$id}: {$th->getMessage()}\");\n                     }\n                     break;\n+                case 'migrations':\n+                    $attributesToCreate = [\n+                        'options',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource_id');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource_id' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'functions':\n+                    $attributesToCreate = [\n+                        'deploymentId',\n+                        'deploymentCreatedAt',\n+                        'latestDeploymentId',\n+                        'latestDeploymentInternalId',\n+                        'latestDeploymentCreatedAt',\n+                        'latestDeploymentStatus',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_deploymentId');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_deploymentId' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'deployments':\n+                    $attributesToCreate = [\n+                        'buildCommands',\n+                        'sourcePath',\n+                        'buildOutput',\n+                        'adapter',\n+                        'fallbackFile',\n+                        'sourceSize',\n+                        'sourceMetadata',\n+                        'sourceChunksTotal',\n+                        'sourceChunksUploaded',\n+                        'screenshotLight',\n+                        'screenshotDark',\n+                        'buildStartAt',\n+                        'buildEndAt',\n+                        'buildDuration',\n+                        'buildSize',\n+                        'status',\n+                        'buildPath',\n+                        'buildLogs',\n+                        'totalSize',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $indexesToCreate = [\n+                        '_key_sourceSize',\n+                        '_key_buildSize',\n+                        '_key_totalSize',\n+                        '_key_buildDuration',\n+                        '_key_type',\n+                        '_key_status',\n+                    ];\n+                    foreach ($indexesToCreate as $index) {\n+                        try {\n+                            $this->createIndexFromCollection($this->projectDB, $id, $index);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"'$index' from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'executions':\n+                    $attributesToCreate = [\n+                        'resourceInternalId',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'variables':\n+                    try {\n+                        $this->createAttributeFromCollection($this->projectDB, $id, 'secret');\n+                    } catch (\\Throwable $th) {\n+                        Console::warning(\"'secret' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+\n+                    break;\n+                default:\n+                    break;\n             }\n \n             usleep(50000);\n         }\n     }\n+\n+    /**\n+     * Fix run on each document\n+     *\n+     * @param Document $document\n+     * @return Document\n+     */\n+    protected function fixDocument(Document $document): Document\n+    {\n+        switch ($document->getCollection()) {\n+            case 'functions':\n+                /*\n+                    1. Convert \"deployment\" to \"deploymentId\"\n+                    --- Fetch activeDeployment from \"deploymentId\"\n+                    2. Fill \"deploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    --- Fetch latestDeployment using find()\n+                    3. Fill latestDeploymentId with latestDeployment's \"$id\"\n+                    4. Fill latestDeploymentInternalId with latestDeployment's \"$internalId\"\n+                    5. Fill latestDeploymentCreatedAt with latestDeployment's \"$createdAt\"\n+                    6. Fill latestDeploymentStatus with latestDeployment's build's \"status\"\n+\n+                    (some deployment attributes needs dual writing from deployment's write action too)\n+                */\n+\n+                $document->setAttribute('deploymentId', $document->getAttribute('deployment'));\n+\n+                $deploymentId = $document->getAttribute('deploymentId');\n+                $deployment = Authorization::skip(fn () => $this->projectDB->getDocument('deployments', $deploymentId));\n+                $document->setAttribute('deploymentCreatedAt', $deployment->getCreatedAt());\n+\n+                $latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n+                    Query::orderDesc(),\n+                    Query::limit(1),\n+                ]));\n+                $latestDeployment = $latestDeployments[0] ?? new Document();\n+                $latestBuild = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $latestDeployment->getAttribute('buildId', '')));\n+                $document\n+                    ->setAttribute('latestDeploymentId', $latestDeployment->getId())\n+                    ->setAttribute('latestDeploymentInternalId', $latestDeployment->getInternalId())\n+                    ->setAttribute('latestDeploymentCreatedAt', $latestDeployment->getCreatedAt())\n+                    ->setAttribute('latestDeploymentStatus', $latestBuild->getAttribute('status'));\n+                break;",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2081556953",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9738,
        "pr_file": "src/Appwrite/Migration/Version/V23.php",
        "discussion_id": "2081556953",
        "commented_code": "@@ -61,9 +75,398 @@ private function migrateCollections(): void\n                         Console::warning(\"'_key_roles' from {$id}: {$th->getMessage()}\");\n                     }\n                     break;\n+                case 'migrations':\n+                    $attributesToCreate = [\n+                        'options',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource_id');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource_id' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'functions':\n+                    $attributesToCreate = [\n+                        'deploymentId',\n+                        'deploymentCreatedAt',\n+                        'latestDeploymentId',\n+                        'latestDeploymentInternalId',\n+                        'latestDeploymentCreatedAt',\n+                        'latestDeploymentStatus',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_deploymentId');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_deploymentId' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'deployments':\n+                    $attributesToCreate = [\n+                        'buildCommands',\n+                        'sourcePath',\n+                        'buildOutput',\n+                        'adapter',\n+                        'fallbackFile',\n+                        'sourceSize',\n+                        'sourceMetadata',\n+                        'sourceChunksTotal',\n+                        'sourceChunksUploaded',\n+                        'screenshotLight',\n+                        'screenshotDark',\n+                        'buildStartAt',\n+                        'buildEndAt',\n+                        'buildDuration',\n+                        'buildSize',\n+                        'status',\n+                        'buildPath',\n+                        'buildLogs',\n+                        'totalSize',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $indexesToCreate = [\n+                        '_key_sourceSize',\n+                        '_key_buildSize',\n+                        '_key_totalSize',\n+                        '_key_buildDuration',\n+                        '_key_type',\n+                        '_key_status',\n+                    ];\n+                    foreach ($indexesToCreate as $index) {\n+                        try {\n+                            $this->createIndexFromCollection($this->projectDB, $id, $index);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"'$index' from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'executions':\n+                    $attributesToCreate = [\n+                        'resourceInternalId',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'variables':\n+                    try {\n+                        $this->createAttributeFromCollection($this->projectDB, $id, 'secret');\n+                    } catch (\\Throwable $th) {\n+                        Console::warning(\"'secret' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+\n+                    break;\n+                default:\n+                    break;\n             }\n \n             usleep(50000);\n         }\n     }\n+\n+    /**\n+     * Fix run on each document\n+     *\n+     * @param Document $document\n+     * @return Document\n+     */\n+    protected function fixDocument(Document $document): Document\n+    {\n+        switch ($document->getCollection()) {\n+            case 'functions':\n+                /*\n+                    1. Convert \"deployment\" to \"deploymentId\"\n+                    --- Fetch activeDeployment from \"deploymentId\"\n+                    2. Fill \"deploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    --- Fetch latestDeployment using find()\n+                    3. Fill latestDeploymentId with latestDeployment's \"$id\"\n+                    4. Fill latestDeploymentInternalId with latestDeployment's \"$internalId\"\n+                    5. Fill latestDeploymentCreatedAt with latestDeployment's \"$createdAt\"\n+                    6. Fill latestDeploymentStatus with latestDeployment's build's \"status\"\n+\n+                    (some deployment attributes needs dual writing from deployment's write action too)\n+                */\n+\n+                $document->setAttribute('deploymentId', $document->getAttribute('deployment'));\n+\n+                $deploymentId = $document->getAttribute('deploymentId');\n+                $deployment = Authorization::skip(fn () => $this->projectDB->getDocument('deployments', $deploymentId));\n+                $document->setAttribute('deploymentCreatedAt', $deployment->getCreatedAt());\n+\n+                $latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n+                    Query::orderDesc(),\n+                    Query::limit(1),\n+                ]));\n+                $latestDeployment = $latestDeployments[0] ?? new Document();\n+                $latestBuild = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $latestDeployment->getAttribute('buildId', '')));\n+                $document\n+                    ->setAttribute('latestDeploymentId', $latestDeployment->getId())\n+                    ->setAttribute('latestDeploymentInternalId', $latestDeployment->getInternalId())\n+                    ->setAttribute('latestDeploymentCreatedAt', $latestDeployment->getCreatedAt())\n+                    ->setAttribute('latestDeploymentStatus', $latestBuild->getAttribute('status'));\n+                break;",
        "comment_created_at": "2025-05-09T12:21:59+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Guard against missing deployments & tighten latest-deployment lookup**\n\n`getDocument()` will throw if `$deploymentId` is empty or points to a deleted deployment, and indexing into `$latestDeployments[0]` can raise a notice when the search returns an empty array.  \nIn addition, the latest\u2013deployment query isn\u2019t scoped to the current function, so you may end up attaching an unrelated deployment to every function in the project.\n\n```diff\n-$deployment = Authorization::skip(fn () => $this->projectDB->getDocument('deployments', $deploymentId));\n-$document->setAttribute('deploymentCreatedAt', $deployment->getCreatedAt());\n-\n-$latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n-    Query::orderDesc(),\n-    Query::limit(1),\n-]));\n-$latestDeployment = $latestDeployments[0] ?? new Document();\n-$latestBuild = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $latestDeployment->getAttribute('buildId', '')));\n+try {\n+    $deployment = Authorization::skip(fn () => $this->projectDB->getDocument('deployments', $deploymentId));\n+    $document->setAttribute('deploymentCreatedAt', $deployment->getCreatedAt());\n+} catch (Throwable $th) {\n+    Console::warning(\"Missing deployment '{$deploymentId}' for function '{$document->getId()}': {$th->getMessage()}\");\n+}\n+\n+$latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n+    Query::equal('resourceType', ['functions']),\n+    Query::equal('resourceId', [$document->getId()]),\n+    Query::orderDesc(),\n+    Query::limit(1),\n+]));\n+$latestDeployment = \\count($latestDeployments) ? $latestDeployments[0] : null;\n+$latestBuild = $latestDeployment\n+    ? Authorization::skip(fn () => $this->projectDB->getDocument('builds', $latestDeployment->getAttribute('buildId', '')))\n+    : new Document();\n```\n\nThis shields the migration from fatal errors and ensures we only pick the latest deployment **belonging to the function being processed**.  \nWithout these checks the entire migration can abort part-way, leaving the project in an inconsistent state.  \n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2081556965",
    "pr_number": 9738,
    "pr_file": "src/Appwrite/Migration/Version/V23.php",
    "created_at": "2025-05-09T12:21:59+00:00",
    "commented_code": "Console::warning(\"'_key_roles' from {$id}: {$th->getMessage()}\");\n                     }\n                     break;\n+                case 'migrations':\n+                    $attributesToCreate = [\n+                        'options',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource_id');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource_id' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'functions':\n+                    $attributesToCreate = [\n+                        'deploymentId',\n+                        'deploymentCreatedAt',\n+                        'latestDeploymentId',\n+                        'latestDeploymentInternalId',\n+                        'latestDeploymentCreatedAt',\n+                        'latestDeploymentStatus',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_deploymentId');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_deploymentId' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'deployments':\n+                    $attributesToCreate = [\n+                        'buildCommands',\n+                        'sourcePath',\n+                        'buildOutput',\n+                        'adapter',\n+                        'fallbackFile',\n+                        'sourceSize',\n+                        'sourceMetadata',\n+                        'sourceChunksTotal',\n+                        'sourceChunksUploaded',\n+                        'screenshotLight',\n+                        'screenshotDark',\n+                        'buildStartAt',\n+                        'buildEndAt',\n+                        'buildDuration',\n+                        'buildSize',\n+                        'status',\n+                        'buildPath',\n+                        'buildLogs',\n+                        'totalSize',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $indexesToCreate = [\n+                        '_key_sourceSize',\n+                        '_key_buildSize',\n+                        '_key_totalSize',\n+                        '_key_buildDuration',\n+                        '_key_type',\n+                        '_key_status',\n+                    ];\n+                    foreach ($indexesToCreate as $index) {\n+                        try {\n+                            $this->createIndexFromCollection($this->projectDB, $id, $index);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"'$index' from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'executions':\n+                    $attributesToCreate = [\n+                        'resourceInternalId',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'variables':\n+                    try {\n+                        $this->createAttributeFromCollection($this->projectDB, $id, 'secret');\n+                    } catch (\\Throwable $th) {\n+                        Console::warning(\"'secret' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+\n+                    break;\n+                default:\n+                    break;\n             }\n \n             usleep(50000);\n         }\n     }\n+\n+    /**\n+     * Fix run on each document\n+     *\n+     * @param Document $document\n+     * @return Document\n+     */\n+    protected function fixDocument(Document $document): Document\n+    {\n+        switch ($document->getCollection()) {\n+            case 'functions':\n+                /*\n+                    1. Convert \"deployment\" to \"deploymentId\"\n+                    --- Fetch activeDeployment from \"deploymentId\"\n+                    2. Fill \"deploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    --- Fetch latestDeployment using find()\n+                    3. Fill latestDeploymentId with latestDeployment's \"$id\"\n+                    4. Fill latestDeploymentInternalId with latestDeployment's \"$internalId\"\n+                    5. Fill latestDeploymentCreatedAt with latestDeployment's \"$createdAt\"\n+                    6. Fill latestDeploymentStatus with latestDeployment's build's \"status\"\n+\n+                    (some deployment attributes needs dual writing from deployment's write action too)\n+                */\n+\n+                $document->setAttribute('deploymentId', $document->getAttribute('deployment'));\n+\n+                $deploymentId = $document->getAttribute('deploymentId');\n+                $deployment = Authorization::skip(fn () => $this->projectDB->getDocument('deployments', $deploymentId));\n+                $document->setAttribute('deploymentCreatedAt', $deployment->getCreatedAt());\n+\n+                $latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n+                    Query::orderDesc(),\n+                    Query::limit(1),\n+                ]));\n+                $latestDeployment = $latestDeployments[0] ?? new Document();\n+                $latestBuild = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $latestDeployment->getAttribute('buildId', '')));\n+                $document\n+                    ->setAttribute('latestDeploymentId', $latestDeployment->getId())\n+                    ->setAttribute('latestDeploymentInternalId', $latestDeployment->getInternalId())\n+                    ->setAttribute('latestDeploymentCreatedAt', $latestDeployment->getCreatedAt())\n+                    ->setAttribute('latestDeploymentStatus', $latestBuild->getAttribute('status'));\n+                break;\n+            case 'deployments':\n+                /*\n+                    --- Support for functions dual writing, if function's deploymentId is current deployment\n+                    1. Fill function's \"deploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    --- Support for functions dual writing, if this is most recent deployment\n+                    2. Fill function's \"latestDeploymentId\" with deployment's \"$id\"\n+                    3. Fill function's \"latestDeploymentInternalId\" with deployment's \"$internalId\"\n+                    4. Fill function's \"latestDeploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    5. Fill function's \"latestDeploymentStatus\" with deployment's \"$status\"\n+                    --- Actual deployment dual write\n+                    6. Convert \"commands\" to \"buildCommands\"\n+                    7. Convert \"path\" to \"sourcePath\"\n+                    8. Convert \"size\" to \"sourceSize\"\n+                    9. Convert \"metadata\" to \"sourceMetadata\"\n+                    10. Convert \"chunksTotal\" to \"sourceChunksTotal\"\n+                    11. Convert \"chunksUploaded\" to \"sourceChunksUploaded\"\n+                    12. Convert build's \"startTime\" to \"buildStartAt\"\n+                    13. Convert build's \"endTime\" to \"buildEndAt\"\n+                    14. Convert build's \"duration\" to \"buildDuration\"\n+                    15. Convert build's \"size\" to \"buildSize\"\n+                    16. Convert build's \"status\" to \"status\"\n+                    17. Convert build's \"path\" to \"buildPath\"\n+                    18. Convert build's \"logs\" to \"buildLogs\"\n+                    19. Fill \"totalSize\" with \"buildSize\" plus \"sourceSize\"\n+                */\n+\n+                $function = Authorization::skip(fn () => $this->projectDB->getDocument('functions', $document->getAttribute('resourceId')));\n+                if (!$function->isEmpty()) {\n+                    $activeDeploymentId = $function->getAttribute('deployment', $function->getAttribute('deploymentId', ''));\n+                    if ($activeDeploymentId === $document->getId()) {\n+                        $function->setAttribute('deploymentCreatedAt', $document->getCreatedAt());\n+                        $function = Authorization::skip(fn () => $this->projectDB->updateDocument('functions', $function->getId(), $function));\n+                    } else {\n+                        $latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n+                            Query::limit(1),\n+                            Query::equal('resourceType', ['functions']),\n+                            Query::equal('resourceId', [$function->getId()]),\n+                            Query::orderDesc()\n+                        ]));\n+                        $latestDeployment = $latestDeployments[0] ? $latestDeployments[0] : new Document();\n+\n+                        if (!$latestDeployment->isEmpty()) {\n+                            if ($latestDeployment->getId() === $document->getId()) {\n+                                $function\n+                                    ->setAttribute(\"latestDeploymentId\", $document->getId())\n+                                    ->setAttribute(\"latestDeploymentInternalId\", $document->getInternalId())\n+                                    ->setAttribute(\"latestDeploymentCreatedAt\", $document->getCreatedAt())\n+                                    ->setAttribute(\"latestDeploymentStatus\", $document->getAttribute('status'))\n+                                ;\n+\n+                                $function = Authorization::skip(fn () => $this->projectDB->updateDocument('functions', $function->getId(), $function));\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                $document\n+                    ->setAttribute(\"buildCommands\", $document->getAttribute(\"commands\"))\n+                    ->setAttribute(\"sourcePath\", $document->getAttribute(\"path\"))\n+                    ->setAttribute(\"sourceSize\", $document->getAttribute(\"size\"))\n+                    ->setAttribute(\"sourceMetadata\", $document->getAttribute(\"metadata\"))\n+                    ->setAttribute(\"sourceChunksTotal\", $document->getAttribute(\"chunksTotal\"))\n+                    ->setAttribute(\"sourceChunksUploaded\", $document->getAttribute(\"chunksUploaded\"))\n+                ;\n+\n+                $build = new Document();\n+\n+                if (!empty($document->getAttribute('buildId'))) {\n+                    $build = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $document->getAttribute('buildId')));\n+                }\n+\n+                $document\n+                    ->setAttribute(\"buildStartAt\", $build->getAttribute(\"startTime\", DateTime::now()))\n+                    ->setAttribute(\"buildEndAt\", $build->getAttribute(\"endTime\", null))\n+                    ->setAttribute(\"buildDuration\", $build->getAttribute(\"duration\", 0))\n+                    ->setAttribute(\"buildSize\", $build->getAttribute(\"size\", 0))\n+                    ->setAttribute(\"status\", $build->getAttribute(\"status\", \"processing\"))\n+                    ->setAttribute(\"buildPath\", $build->getAttribute(\"path\", \"\"))\n+                    ->setAttribute(\"buildLogs\", $build->getAttribute(\"logs\", \"\"))\n+                ;",
    "repo_full_name": "appwrite/appwrite",
    "discussion_comments": [
      {
        "comment_id": "2081556965",
        "repo_full_name": "appwrite/appwrite",
        "pr_number": 9738,
        "pr_file": "src/Appwrite/Migration/Version/V23.php",
        "discussion_id": "2081556965",
        "commented_code": "@@ -61,9 +75,398 @@ private function migrateCollections(): void\n                         Console::warning(\"'_key_roles' from {$id}: {$th->getMessage()}\");\n                     }\n                     break;\n+                case 'migrations':\n+                    $attributesToCreate = [\n+                        'options',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource_id');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource_id' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'functions':\n+                    $attributesToCreate = [\n+                        'deploymentId',\n+                        'deploymentCreatedAt',\n+                        'latestDeploymentId',\n+                        'latestDeploymentInternalId',\n+                        'latestDeploymentCreatedAt',\n+                        'latestDeploymentStatus',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_deploymentId');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_deploymentId' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'deployments':\n+                    $attributesToCreate = [\n+                        'buildCommands',\n+                        'sourcePath',\n+                        'buildOutput',\n+                        'adapter',\n+                        'fallbackFile',\n+                        'sourceSize',\n+                        'sourceMetadata',\n+                        'sourceChunksTotal',\n+                        'sourceChunksUploaded',\n+                        'screenshotLight',\n+                        'screenshotDark',\n+                        'buildStartAt',\n+                        'buildEndAt',\n+                        'buildDuration',\n+                        'buildSize',\n+                        'status',\n+                        'buildPath',\n+                        'buildLogs',\n+                        'totalSize',\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $indexesToCreate = [\n+                        '_key_sourceSize',\n+                        '_key_buildSize',\n+                        '_key_totalSize',\n+                        '_key_buildDuration',\n+                        '_key_type',\n+                        '_key_status',\n+                    ];\n+                    foreach ($indexesToCreate as $index) {\n+                        try {\n+                            $this->createIndexFromCollection($this->projectDB, $id, $index);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"'$index' from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'executions':\n+                    $attributesToCreate = [\n+                        'resourceInternalId',\n+                        'resourceId',\n+                        'resourceType'\n+                    ];\n+                    foreach ($attributesToCreate as $attribute) {\n+                        try {\n+                            $this->createAttributeFromCollection($this->projectDB, $id, $attribute);\n+                        } catch (\\Throwable $th) {\n+                            Console::warning(\"$attribute from {$id}: {$th->getMessage()}\");\n+                        }\n+                    }\n+\n+                    try {\n+                        $this->createIndexFromCollection($this->projectDB, $id, '_key_resource');\n+                    } catch (Throwable $th) {\n+                        Console::warning(\"'_key_resource' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+                    break;\n+                case 'variables':\n+                    try {\n+                        $this->createAttributeFromCollection($this->projectDB, $id, 'secret');\n+                    } catch (\\Throwable $th) {\n+                        Console::warning(\"'secret' from {$id}: {$th->getMessage()}\");\n+                    }\n+\n+                    $this->projectDB->purgeCachedCollection($id);\n+\n+                    break;\n+                default:\n+                    break;\n             }\n \n             usleep(50000);\n         }\n     }\n+\n+    /**\n+     * Fix run on each document\n+     *\n+     * @param Document $document\n+     * @return Document\n+     */\n+    protected function fixDocument(Document $document): Document\n+    {\n+        switch ($document->getCollection()) {\n+            case 'functions':\n+                /*\n+                    1. Convert \"deployment\" to \"deploymentId\"\n+                    --- Fetch activeDeployment from \"deploymentId\"\n+                    2. Fill \"deploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    --- Fetch latestDeployment using find()\n+                    3. Fill latestDeploymentId with latestDeployment's \"$id\"\n+                    4. Fill latestDeploymentInternalId with latestDeployment's \"$internalId\"\n+                    5. Fill latestDeploymentCreatedAt with latestDeployment's \"$createdAt\"\n+                    6. Fill latestDeploymentStatus with latestDeployment's build's \"status\"\n+\n+                    (some deployment attributes needs dual writing from deployment's write action too)\n+                */\n+\n+                $document->setAttribute('deploymentId', $document->getAttribute('deployment'));\n+\n+                $deploymentId = $document->getAttribute('deploymentId');\n+                $deployment = Authorization::skip(fn () => $this->projectDB->getDocument('deployments', $deploymentId));\n+                $document->setAttribute('deploymentCreatedAt', $deployment->getCreatedAt());\n+\n+                $latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n+                    Query::orderDesc(),\n+                    Query::limit(1),\n+                ]));\n+                $latestDeployment = $latestDeployments[0] ?? new Document();\n+                $latestBuild = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $latestDeployment->getAttribute('buildId', '')));\n+                $document\n+                    ->setAttribute('latestDeploymentId', $latestDeployment->getId())\n+                    ->setAttribute('latestDeploymentInternalId', $latestDeployment->getInternalId())\n+                    ->setAttribute('latestDeploymentCreatedAt', $latestDeployment->getCreatedAt())\n+                    ->setAttribute('latestDeploymentStatus', $latestBuild->getAttribute('status'));\n+                break;\n+            case 'deployments':\n+                /*\n+                    --- Support for functions dual writing, if function's deploymentId is current deployment\n+                    1. Fill function's \"deploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    --- Support for functions dual writing, if this is most recent deployment\n+                    2. Fill function's \"latestDeploymentId\" with deployment's \"$id\"\n+                    3. Fill function's \"latestDeploymentInternalId\" with deployment's \"$internalId\"\n+                    4. Fill function's \"latestDeploymentCreatedAt\" with deployment's \"$createdAt\"\n+                    5. Fill function's \"latestDeploymentStatus\" with deployment's \"$status\"\n+                    --- Actual deployment dual write\n+                    6. Convert \"commands\" to \"buildCommands\"\n+                    7. Convert \"path\" to \"sourcePath\"\n+                    8. Convert \"size\" to \"sourceSize\"\n+                    9. Convert \"metadata\" to \"sourceMetadata\"\n+                    10. Convert \"chunksTotal\" to \"sourceChunksTotal\"\n+                    11. Convert \"chunksUploaded\" to \"sourceChunksUploaded\"\n+                    12. Convert build's \"startTime\" to \"buildStartAt\"\n+                    13. Convert build's \"endTime\" to \"buildEndAt\"\n+                    14. Convert build's \"duration\" to \"buildDuration\"\n+                    15. Convert build's \"size\" to \"buildSize\"\n+                    16. Convert build's \"status\" to \"status\"\n+                    17. Convert build's \"path\" to \"buildPath\"\n+                    18. Convert build's \"logs\" to \"buildLogs\"\n+                    19. Fill \"totalSize\" with \"buildSize\" plus \"sourceSize\"\n+                */\n+\n+                $function = Authorization::skip(fn () => $this->projectDB->getDocument('functions', $document->getAttribute('resourceId')));\n+                if (!$function->isEmpty()) {\n+                    $activeDeploymentId = $function->getAttribute('deployment', $function->getAttribute('deploymentId', ''));\n+                    if ($activeDeploymentId === $document->getId()) {\n+                        $function->setAttribute('deploymentCreatedAt', $document->getCreatedAt());\n+                        $function = Authorization::skip(fn () => $this->projectDB->updateDocument('functions', $function->getId(), $function));\n+                    } else {\n+                        $latestDeployments = Authorization::skip(fn () => $this->projectDB->find('deployments', [\n+                            Query::limit(1),\n+                            Query::equal('resourceType', ['functions']),\n+                            Query::equal('resourceId', [$function->getId()]),\n+                            Query::orderDesc()\n+                        ]));\n+                        $latestDeployment = $latestDeployments[0] ? $latestDeployments[0] : new Document();\n+\n+                        if (!$latestDeployment->isEmpty()) {\n+                            if ($latestDeployment->getId() === $document->getId()) {\n+                                $function\n+                                    ->setAttribute(\"latestDeploymentId\", $document->getId())\n+                                    ->setAttribute(\"latestDeploymentInternalId\", $document->getInternalId())\n+                                    ->setAttribute(\"latestDeploymentCreatedAt\", $document->getCreatedAt())\n+                                    ->setAttribute(\"latestDeploymentStatus\", $document->getAttribute('status'))\n+                                ;\n+\n+                                $function = Authorization::skip(fn () => $this->projectDB->updateDocument('functions', $function->getId(), $function));\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                $document\n+                    ->setAttribute(\"buildCommands\", $document->getAttribute(\"commands\"))\n+                    ->setAttribute(\"sourcePath\", $document->getAttribute(\"path\"))\n+                    ->setAttribute(\"sourceSize\", $document->getAttribute(\"size\"))\n+                    ->setAttribute(\"sourceMetadata\", $document->getAttribute(\"metadata\"))\n+                    ->setAttribute(\"sourceChunksTotal\", $document->getAttribute(\"chunksTotal\"))\n+                    ->setAttribute(\"sourceChunksUploaded\", $document->getAttribute(\"chunksUploaded\"))\n+                ;\n+\n+                $build = new Document();\n+\n+                if (!empty($document->getAttribute('buildId'))) {\n+                    $build = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $document->getAttribute('buildId')));\n+                }\n+\n+                $document\n+                    ->setAttribute(\"buildStartAt\", $build->getAttribute(\"startTime\", DateTime::now()))\n+                    ->setAttribute(\"buildEndAt\", $build->getAttribute(\"endTime\", null))\n+                    ->setAttribute(\"buildDuration\", $build->getAttribute(\"duration\", 0))\n+                    ->setAttribute(\"buildSize\", $build->getAttribute(\"size\", 0))\n+                    ->setAttribute(\"status\", $build->getAttribute(\"status\", \"processing\"))\n+                    ->setAttribute(\"buildPath\", $build->getAttribute(\"path\", \"\"))\n+                    ->setAttribute(\"buildLogs\", $build->getAttribute(\"logs\", \"\"))\n+                ;",
        "comment_created_at": "2025-05-09T12:21:59+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Handle absent build documents & avoid defaulting to \u201cnow\u201d**\n\nIf `buildId` is empty or the referenced build was purged, `getDocument()` will throw.  \nFurther, defaulting `buildStartAt` to `DateTime::now()` fabricates data that never existed and can corrupt analytics.\n\nRecommend:\n\n1. Wrap `getDocument()` in `try/catch` (or use `find` with a limit).\n2. Leave `buildStartAt`, `buildEndAt`, etc. as `null` when the build is missing.\n\n```diff\n-$build = new Document();\n-\n-if (!empty($document->getAttribute('buildId'))) {\n-    $build = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $document->getAttribute('buildId')));\n-}\n-\n-$document\n-    ->setAttribute(\"buildStartAt\", $build->getAttribute(\"startTime\", DateTime::now()))\n+try {\n+    $build = Authorization::skip(fn () => $this->projectDB->getDocument('builds', $document->getAttribute('buildId', '')));\n+} catch (Throwable $th) {\n+    $build = new Document(); // proceed with empty defaults\n+}\n+\n+$document\n+    ->setAttribute(\"buildStartAt\", $build->getAttribute(\"startTime\"))\n     ->setAttribute(\"buildEndAt\", $build->getAttribute(\"endTime\"))\n```\n\nThis prevents bogus timestamps and keeps the migration idempotent.  \n\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n`````suggestion\n                try {\n                    $build = Authorization::skip(fn () => $this->projectDB->getDocument(\n                        'builds',\n                        $document->getAttribute('buildId', '')\n                    ));\n                } catch (Throwable $th) {\n                    $build = new Document(); // proceed with empty defaults\n                }\n\n                $document\n                    ->setAttribute(\"buildStartAt\",  $build->getAttribute(\"startTime\"))\n                    ->setAttribute(\"buildEndAt\",    $build->getAttribute(\"endTime\"))\n                    ->setAttribute(\"buildDuration\", $build->getAttribute(\"duration\", 0))\n                    ->setAttribute(\"buildSize\",     $build->getAttribute(\"size\", 0))\n                    ->setAttribute(\"status\",        $build->getAttribute(\"status\", \"processing\"))\n                    ->setAttribute(\"buildPath\",     $build->getAttribute(\"path\", \"\"))\n                    ->setAttribute(\"buildLogs\",     $build->getAttribute(\"logs\", \"\"))\n                ;\n`````\n\n</details>\n\n<!-- suggestion_end -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]