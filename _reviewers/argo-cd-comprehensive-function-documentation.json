[
  {
    "discussion_id": "2206824476",
    "pr_number": 23762,
    "pr_file": "controller/appcontroller.go",
    "created_at": "2025-07-15T08:27:54+00:00",
    "commented_code": "if app.Spec.SyncPolicy.Automated.Prune && !app.Spec.SyncPolicy.Automated.AllowEmpty {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2206824476",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23762,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2206824476",
        "commented_code": "@@ -2182,7 +2182,7 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \tif app.Spec.SyncPolicy.Automated.Prune && !app.Spec.SyncPolicy.Automated.AllowEmpty {",
        "comment_created_at": "2025-07-15T08:27:54+00:00",
        "comment_author": "nitishfy",
        "comment_body": "```suggestion\r\n\t// If pruning is enabled and the app is *not* allowed to have an empty desired state,\r\n        // we need to ensure we're not about to accidentally wipe out all resources.\r\n       // This is a safety mechanism to prevent full deletion due to automation errors (e.g., empty Git path).\r\n\tif app.Spec.SyncPolicy.Automated.Prune && !app.Spec.SyncPolicy.Automated.AllowEmpty {\r\n```\r\n\r\nI read this piece of code and I think adding comments on why this piece of code exists at the first place is an important thing to add too.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193411102",
    "pr_number": 23628,
    "pr_file": "controller/appcontroller.go",
    "created_at": "2025-07-08T20:44:06+00:00",
    "commented_code": "if stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2193411102",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-08T20:44:06+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "I feel like this function is doing too much... the revisions and phase output parameters seem to be simple aliases of their respective fields in `app.Status.OperationState`. If we need short var names, we can just do\r\n\r\n```go\r\nopPhase := app.Status.OperationState.Phase\r\nopRevisions := app.Status.OperationState.SyncResult.GetRevisions() # would probably need a new receiver\r\n```\r\n\r\nThen this function could focus on the first return param, which seems to involve the more interesting logic.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198152746",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-10T16:06:14+00:00",
        "comment_author": "agaudreault",
        "comment_body": "out of scope of this refactor",
        "pr_file_module": null
      },
      {
        "comment_id": "2198166800",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-10T16:13:05+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "Maybe but I'm really struggling to understand what this function does due to it being so crowded.\r\n\r\nFor now I'd settle for a docstring thoroughly explaining the intent and a TODO to remove the unnecessary behavior.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198425762",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-10T18:35:58+00:00",
        "comment_author": "agaudreault",
        "comment_body": "any change suggestion on the current docstring?",
        "pr_file_module": null
      },
      {
        "comment_id": "2198516322",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-10T19:18:13+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "Not really, because I don't think I fully understand either the behavior or the intent of the function (regarding just the first output param).\r\n\r\n> alreadyAttemptedSync returns whether the most recent sync was performed against the desiredRevisions and with the same app source config which are currently set in the app.\r\n\r\nI think I basically follow that, but the actual behavior is:\r\n\r\n1) If there is no operation state, return false, because we can't confirm the above two things.\r\n2) If we have an operation state but not a sync result, we return true if and only if the phase was marked completed. This is weird, because we haven't confirmed whether the synced revisions match `desiredRevisions` or whether the source config has changed. \"Phase is completed\" wasn't even mentioned as a criteria in the docstring. Why return true if the phase is completed? There's a docstring above that `return`, but it seems to be explaining the behavior of the calling function, not the `alreadyAttemptedSync` function.\r\n3) If `newRevisionHasChanges`, return `false` if `desiredRevisions` doesn't match the synced revisions. What does `newRevisionHasChanges` mean? And why aren't we checking whether the synced source config has changed, like the function docs mentioned?\r\n4) If not `newRevisionHasChanges`, just return whether the synced source config matches current source config. But it's unclear why we're not comparing desired revisions to synced revisions. Is that already confirmed to be true because `newRevisionHasChanges` is false? If `newRevisionHasChanges` means \"desired revisions don't match synced revisions\", why are we checking that again in the previous point?",
        "pr_file_module": null
      },
      {
        "comment_id": "2198537935",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-10T19:29:10+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "> alreadyAttemptedSync is meant to help the caller understand whether an identical sync operation has been attempted, to avoid excessively retrying the exact same sync operation.\r\n>\r\n> alreadyAttemptedSync returns true if either 1) newRevisionHasChanges is true and the most recently synced revision(s) exactly match the given desiredRevisions, 2) newRevisionHasChanges is false and the most recently synced app source configuration matches exactly the current app source configuration, or 3) the most recent operation state is missing a sync result but the sync phase is completed (this can happen when there are errors that cause the sync result not to be persisted). The last case returns true, because the caller should treat such a failed sync as an attempt. \r\n>\r\n> alreadyAttemptedSync returns false if the operation state is not set at all. This happens when the app is brand new or when a new operation has started.\r\n>\r\n> alreadyAttemptedSync also returns the most recently synced revisions and the most recent sync operation's phase.\r\n>\r\n> TODO: remove the last two return parameters, since they're effectively just aliases for fields on the app object. If the nil checks are too cumbersome for the caller, they can be moved into separate utility functions to avoid crowding this one.\r\n\r\nThis would get closer. But I think the references to `newRevisionHasChanges` should be replaced with a plain-language explanation of what that parameters means, and that param should be documented.",
        "pr_file_module": null
      },
      {
        "comment_id": "2205029450",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-14T14:02:38+00:00",
        "comment_author": "agaudreault",
        "comment_body": "Description updated to reflect the intent of the function and added doc for newRevisionHasChanges param usage. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2205034876",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23628,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2193411102",
        "commented_code": "@@ -2209,57 +2202,58 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \t\tif stderrors.Is(err, argo.ErrAnotherOperationInProgress) {\n \t\t\t// skipping auto-sync because another operation is in progress and was not noticed due to stale data in informer\n \t\t\t// it is safe to skip auto-sync because it is already running\n-\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\t\tlogCtx.Warnf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\t\treturn nil, 0\n \t\t}\n \n-\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n+\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredRevisions, err)\n \t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}, setOpTime\n \t}\n \tctrl.writeBackToInformer(updatedApp)\n \tts.AddCheckpoint(\"write_back_to_informer_ms\")\n \n-\tvar target string\n-\tif updatedApp.Spec.HasMultipleSources() {\n-\t\ttarget = strings.Join(desiredCommitSHAsMS, \", \")\n-\t} else {\n-\t\ttarget = desiredCommitSHA\n-\t}\n-\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", target)\n+\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredRevisions)\n \tctrl.logAppEvent(context.TODO(), app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: corev1.EventTypeNormal}, message)\n \tlogCtx.Info(message)\n \treturn nil, setOpTime\n }\n \n // alreadyAttemptedSync returns whether the most recent sync was performed against the\n-// commitSHA and with the same app source config which are currently set in the app.\n-func alreadyAttemptedSync(app *appv1.Application, commitSHA string, commitSHAsMS []string, hasMultipleSources bool, revisionUpdated bool) (bool, synccommon.OperationPhase) {\n-\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n-\t\treturn false, \"\"\n-\t}\n-\tif hasMultipleSources {\n-\t\tif revisionUpdated {\n-\t\t\tif !reflect.DeepEqual(app.Status.OperationState.SyncResult.Revisions, commitSHAsMS) {\n-\t\t\t\treturn false, \"\"\n+// desiredRevisions and with the same app source config which are currently set in the app.\n+// It also returns the last synced revisions and the result of that operation.\n+func alreadyAttemptedSync(app *appv1.Application, desiredRevisions []string, newRevisionHasChanges bool) (bool, []string, synccommon.OperationPhase) {",
        "comment_created_at": "2025-07-14T14:05:07+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "The description of `newRevisionHasChanges`. cleared up a lot for me.\r\n\r\nWould probably be good to standardize on one var name for that variable and document it in each function that uses it. But that can be a future enhancement.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174873956",
    "pr_number": 23605,
    "pr_file": "util/settings/settings.go",
    "created_at": "2025-06-30T11:41:13+00:00",
    "commented_code": "return mgr.GetSecretByName(common.ArgoCDSecretName)\n }\n \n-// Returns the Secret with the given name from the cluster.\n+// GetSecretByName returns the Secret with the given name from the cluster.",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2174873956",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23605,
        "pr_file": "util/settings/settings.go",
        "discussion_id": "2174873956",
        "commented_code": "@@ -745,7 +745,7 @@ func (mgr *SettingsManager) getSecret() (*corev1.Secret, error) {\n \treturn mgr.GetSecretByName(common.ArgoCDSecretName)\n }\n \n-// Returns the Secret with the given name from the cluster.\n+// GetSecretByName returns the Secret with the given name from the cluster.",
        "comment_created_at": "2025-06-30T11:41:13+00:00",
        "comment_author": "ppapapetrou76",
        "comment_body": "++++",
        "pr_file_module": null
      }
    ]
  }
]