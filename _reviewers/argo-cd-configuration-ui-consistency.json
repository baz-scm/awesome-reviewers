[
  {
    "discussion_id": "2005942494",
    "pr_number": 22368,
    "pr_file": "ui/src/app/applications/components/application-parameters/application-parameters.tsx",
    "created_at": "2025-03-20T15:44:26+00:00",
    "commented_code": ".map((item, i) => ({...item, before: (i === 0 && <p style={{marginTop: '1em'}}>{title}</p>) || null}));\n }\n \n+function mergeAndFormatHelmValues(valuesObject: any, values: string) {\n+    if (!valuesObject && !values) {\n+        return '';\n+    }\n+    //Order of precedence: valuesObject > values\n+    const mergedValueObject = merge(jsYaml.load(values || ''), valuesObject || {});\n+    return jsYaml.dump(mergedValueObject);\n+}\n+\n+function flattenObject(obj: any, parentPath = '', result = {} as any) {\n+    forEach(obj, (value, key) => {\n+        const fullPath = parentPath ? (isArray(obj) ? `${parentPath}[${key}]` : `${parentPath}.${key}`) : key;\n+        if (isObject(value) || isArray(value)) {\n+            flattenObject(value, fullPath, result);\n+        } else {\n+            result[fullPath] = value;\n+        }\n+    });\n+    return result;\n+}\n+\n+function unflattenedObject(obj: any) {\n+    const result = {};\n+    for (const key in obj) {\n+        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n+            set(result, key, obj[key]);\n+        }\n+    }\n+    return result;\n+}",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2005942494",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22368,
        "pr_file": "ui/src/app/applications/components/application-parameters/application-parameters.tsx",
        "discussion_id": "2005942494",
        "commented_code": "@@ -142,6 +142,268 @@ function getParamsEditableItems(\n         .map((item, i) => ({...item, before: (i === 0 && <p style={{marginTop: '1em'}}>{title}</p>) || null}));\n }\n \n+function mergeAndFormatHelmValues(valuesObject: any, values: string) {\n+    if (!valuesObject && !values) {\n+        return '';\n+    }\n+    //Order of precedence: valuesObject > values\n+    const mergedValueObject = merge(jsYaml.load(values || ''), valuesObject || {});\n+    return jsYaml.dump(mergedValueObject);\n+}\n+\n+function flattenObject(obj: any, parentPath = '', result = {} as any) {\n+    forEach(obj, (value, key) => {\n+        const fullPath = parentPath ? (isArray(obj) ? `${parentPath}[${key}]` : `${parentPath}.${key}`) : key;\n+        if (isObject(value) || isArray(value)) {\n+            flattenObject(value, fullPath, result);\n+        } else {\n+            result[fullPath] = value;\n+        }\n+    });\n+    return result;\n+}\n+\n+function unflattenedObject(obj: any) {\n+    const result = {};\n+    for (const key in obj) {\n+        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n+            set(result, key, obj[key]);\n+        }\n+    }\n+    return result;\n+}",
        "comment_created_at": "2025-03-20T15:44:26+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "Could we have some unit tests for these utility functions? I think we're trying to mimic Helm's values file merging behavior. If we find later that our merge algorithms differ from Helm's, it would be good to have unit tests to help safely change our algorithm to match Helm's.",
        "pr_file_module": null
      },
      {
        "comment_id": "2006931381",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22368,
        "pr_file": "ui/src/app/applications/components/application-parameters/application-parameters.tsx",
        "discussion_id": "2005942494",
        "commented_code": "@@ -142,6 +142,268 @@ function getParamsEditableItems(\n         .map((item, i) => ({...item, before: (i === 0 && <p style={{marginTop: '1em'}}>{title}</p>) || null}));\n }\n \n+function mergeAndFormatHelmValues(valuesObject: any, values: string) {\n+    if (!valuesObject && !values) {\n+        return '';\n+    }\n+    //Order of precedence: valuesObject > values\n+    const mergedValueObject = merge(jsYaml.load(values || ''), valuesObject || {});\n+    return jsYaml.dump(mergedValueObject);\n+}\n+\n+function flattenObject(obj: any, parentPath = '', result = {} as any) {\n+    forEach(obj, (value, key) => {\n+        const fullPath = parentPath ? (isArray(obj) ? `${parentPath}[${key}]` : `${parentPath}.${key}`) : key;\n+        if (isObject(value) || isArray(value)) {\n+            flattenObject(value, fullPath, result);\n+        } else {\n+            result[fullPath] = value;\n+        }\n+    });\n+    return result;\n+}\n+\n+function unflattenedObject(obj: any) {\n+    const result = {};\n+    for (const key in obj) {\n+        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n+            set(result, key, obj[key]);\n+        }\n+    }\n+    return result;\n+}",
        "comment_created_at": "2025-03-21T06:28:59+00:00",
        "comment_author": "Ruby-rc",
        "comment_body": "I completely agree\uff01\r\n\r\nGive me some time to review the original Helm's values file merging behavior and add test cases for these functions.",
        "pr_file_module": null
      },
      {
        "comment_id": "2014592049",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22368,
        "pr_file": "ui/src/app/applications/components/application-parameters/application-parameters.tsx",
        "discussion_id": "2005942494",
        "commented_code": "@@ -142,6 +142,268 @@ function getParamsEditableItems(\n         .map((item, i) => ({...item, before: (i === 0 && <p style={{marginTop: '1em'}}>{title}</p>) || null}));\n }\n \n+function mergeAndFormatHelmValues(valuesObject: any, values: string) {\n+    if (!valuesObject && !values) {\n+        return '';\n+    }\n+    //Order of precedence: valuesObject > values\n+    const mergedValueObject = merge(jsYaml.load(values || ''), valuesObject || {});\n+    return jsYaml.dump(mergedValueObject);\n+}\n+\n+function flattenObject(obj: any, parentPath = '', result = {} as any) {\n+    forEach(obj, (value, key) => {\n+        const fullPath = parentPath ? (isArray(obj) ? `${parentPath}[${key}]` : `${parentPath}.${key}`) : key;\n+        if (isObject(value) || isArray(value)) {\n+            flattenObject(value, fullPath, result);\n+        } else {\n+            result[fullPath] = value;\n+        }\n+    });\n+    return result;\n+}\n+\n+function unflattenedObject(obj: any) {\n+    const result = {};\n+    for (const key in obj) {\n+        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n+            set(result, key, obj[key]);\n+        }\n+    }\n+    return result;\n+}",
        "comment_created_at": "2025-03-26T16:46:21+00:00",
        "comment_author": "Ruby-rc",
        "comment_body": "Hello! @crenshaw-dev @nitishfy \r\n\r\nI've reviewed the backend implementation of Helm values handling, particularly focusing on `SetValuesString` and `ValuesYAML` methods in https://github.com/argoproj/argo-cd/blob/master/pkg/apis/application/v1alpha1/values.go#L15\r\n\r\nIn my view, the current backend implementation follows a clear pattern:\r\n1. `ValuesObject` takes precedence over `Values` (as documented in CRD)\r\n2. When setting values through `SetValuesString`:\r\n   - Converts YAML to JSON and stores in `ValuesObject`\r\n   - Clears the `Values` field to avoid conflicts\r\n3. When retrieving values through `ValuesYAML`:\r\n   - Returns `ValuesObject` if present (converted back to YAML)\r\n   - Falls back to `Values` if `ValuesObject` is nil\r\n\r\nHowever, our current UI form doesn't reflect this implementation, which creates two UX issues:\r\n1. Values edited in YAML view may appear differently in form view due to the internal conversion\r\n2. Users have no visibility into which field (`values` or `valuesObject`) is actually being used\r\n\r\nI propose two potential solutions:\r\n\r\n1. **Enhanced UI with Source Visibility** (Recommended):\r\n   - Add visual indication of the active values source\r\n   - Provide explicit control over which field to modify\r\n   - Example mockup:\r\n![image](https://github.com/user-attachments/assets/9371c50d-552a-45d7-9a67-db8710bbcfd1)\r\n\r\n2. **Simplified Single-Field Approach**:\r\n   - Always use `values` field for both display and editing in UI form\r\n   - Remove the dual-field complexity from UI\r\n\r\nI recommend the first approach because:\r\n- It provides transparency into the backend behavior\r\n- Maintains consistency with the CRD design\r\n- Gives users explicit control over their configuration\r\n\r\nHope to receive your thoughts  on this discussion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2127874807",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22368,
        "pr_file": "ui/src/app/applications/components/application-parameters/application-parameters.tsx",
        "discussion_id": "2005942494",
        "commented_code": "@@ -142,6 +142,268 @@ function getParamsEditableItems(\n         .map((item, i) => ({...item, before: (i === 0 && <p style={{marginTop: '1em'}}>{title}</p>) || null}));\n }\n \n+function mergeAndFormatHelmValues(valuesObject: any, values: string) {\n+    if (!valuesObject && !values) {\n+        return '';\n+    }\n+    //Order of precedence: valuesObject > values\n+    const mergedValueObject = merge(jsYaml.load(values || ''), valuesObject || {});\n+    return jsYaml.dump(mergedValueObject);\n+}\n+\n+function flattenObject(obj: any, parentPath = '', result = {} as any) {\n+    forEach(obj, (value, key) => {\n+        const fullPath = parentPath ? (isArray(obj) ? `${parentPath}[${key}]` : `${parentPath}.${key}`) : key;\n+        if (isObject(value) || isArray(value)) {\n+            flattenObject(value, fullPath, result);\n+        } else {\n+            result[fullPath] = value;\n+        }\n+    });\n+    return result;\n+}\n+\n+function unflattenedObject(obj: any) {\n+    const result = {};\n+    for (const key in obj) {\n+        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n+            set(result, key, obj[key]);\n+        }\n+    }\n+    return result;\n+}",
        "comment_created_at": "2025-06-05T03:37:44+00:00",
        "comment_author": "Ruby-rc",
        "comment_body": "I have updated the description of this PR.\r\nThis PR now only fix the issue of preventing a crash when switching from YAML to form mode with valuesObject during application creation.\r\n\r\nIt does not include any changes to value or parameters, as I believe the UI should only be responsible for displaying configuration, not handling the logic of data merging.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2029328079",
    "pr_number": 22482,
    "pr_file": "ui/src/app/applications/components/application-summary/application-summary.tsx",
    "created_at": "2025-04-04T19:27:05+00:00",
    "commented_code": "{app.spec.syncPolicy && app.spec.syncPolicy.automated && (\n                                 <React.Fragment>\n+                                    <div className='row white-box__details-row'>\n+                                        <div className='columns small-12'>\n+                                            <div className='checkbox-container'>\n+                                                <Checkbox\n+                                                    onChange={async (val: boolean) => {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2029328079",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22482,
        "pr_file": "ui/src/app/applications/components/application-summary/application-summary.tsx",
        "discussion_id": "2029328079",
        "commented_code": "@@ -529,6 +531,39 @@ export const ApplicationSummary = (props: ApplicationSummaryProps) => {\n \n                             {app.spec.syncPolicy && app.spec.syncPolicy.automated && (\n                                 <React.Fragment>\n+                                    <div className='row white-box__details-row'>\n+                                        <div className='columns small-12'>\n+                                            <div className='checkbox-container'>\n+                                                <Checkbox\n+                                                    onChange={async (val: boolean) => {",
        "comment_created_at": "2025-04-04T19:27:05+00:00",
        "comment_author": "keithchong",
        "comment_body": "Could we still simply call `setAutoSync` from here like for the other two flags?  So pass the current state of the enabled flag to ensure it's preserved, and then you don't have to change `setAutoSync`, other than to allow enabled to be passed in?\r\n\r\nWhen we're enabling autosync, eg. `automated` is first added, do you want to maintain the previous behaviour so that you _only_ introduce the enabled element when the user checks the enabled checkbox?\r\n\r\nThe checkbox being unchecked right now maps to two different situations in the actual CRD.    Unchecked, is for `enabled: false` as well as for when the `enabled` field does not exist.  Checked, is for `enabled: true` in the CRD only, which is ok.  This can lead to inconsistencies when you initialize the state of the checkbox when you first visit the page. It is particularly evident when you make changes directly to YAML (via the YAML source in the UI, or changing it externally).   \r\n\r\nSo, it's like you need a third state and perhaps the use of another widget.  Potentially, a drop down combo could be used with three selections: 1. a blank entry, 2. `true` and 3. `false`.   One for each of the three situations.\r\n\r\nOn a separate note, the UI representation for selfHeal and prune could be improved - I see they have similar issues. \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2029333775",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22482,
        "pr_file": "ui/src/app/applications/components/application-summary/application-summary.tsx",
        "discussion_id": "2029328079",
        "commented_code": "@@ -529,6 +531,39 @@ export const ApplicationSummary = (props: ApplicationSummaryProps) => {\n \n                             {app.spec.syncPolicy && app.spec.syncPolicy.automated && (\n                                 <React.Fragment>\n+                                    <div className='row white-box__details-row'>\n+                                        <div className='columns small-12'>\n+                                            <div className='checkbox-container'>\n+                                                <Checkbox\n+                                                    onChange={async (val: boolean) => {",
        "comment_created_at": "2025-04-04T19:31:43+00:00",
        "comment_author": "keithchong",
        "comment_body": "Something like this:\r\n\r\n> \r\n                                                        setAutoSync(\r\n                                                            ctx,\r\n                                                            val ? 'Enable Auto-Sync?' : 'Disable Auto-Sync?',\r\n                                                            val\r\n                                                                ? 'If checked, application will automatically sync when changes are detected'\r\n                                                                : 'Are you sure you want to disable automated application synchronization',\r\n                                                            app.spec.syncPolicy.automated.prune,\r\n                                                            app.spec.syncPolicy.automated.selfHeal,\r\n                                                            val\r\n                                                        )",
        "pr_file_module": null
      },
      {
        "comment_id": "2029403893",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22482,
        "pr_file": "ui/src/app/applications/components/application-summary/application-summary.tsx",
        "discussion_id": "2029328079",
        "commented_code": "@@ -529,6 +531,39 @@ export const ApplicationSummary = (props: ApplicationSummaryProps) => {\n \n                             {app.spec.syncPolicy && app.spec.syncPolicy.automated && (\n                                 <React.Fragment>\n+                                    <div className='row white-box__details-row'>\n+                                        <div className='columns small-12'>\n+                                            <div className='checkbox-container'>\n+                                                <Checkbox\n+                                                    onChange={async (val: boolean) => {",
        "comment_created_at": "2025-04-04T20:33:38+00:00",
        "comment_author": "aali309",
        "comment_body": "The behaviour on the back end is that the `enabled` field is enabled by default when sync is automated. Also to make the behaviour consistent across both the UI and backend. The UI's checkbox logic (automated.enabled !== false) matches the backend's logic (Enabled == nil || *Enabled).\r\nSo when you set automated: {}, you're effectively enabling auto-sync because Enabled is nil, which is treated as enabled by design. \r\n\r\nThis means:\r\nWhen `automated: {}`, then `enabled` is undefined and `undefined !== false` evaluates to true, therefore, the checkbox appears ticked.\r\nThis behaviour is actually documented in [docs/user-guide/auto_sync.md:](https://github.com/argoproj/argo-cd/blob/master/docs/user-guide/auto_sync.md#:~:text=Application%20CRD%20now%20also%20support%20explicitly%20setting,like%20prune%2C%20self%2Dheal%20and%20allowEmpty)\r\n\r\nSetting `spec.syncPolicy.automated.enabled` flag to null will be treated as automated sync as `enabled`.\r\nSo there are three equivalent ways to enable auto-sync:\r\n\r\n1. `automated: {}`\r\n2. `automated: {enabled: null}`\r\n3. `automated: {enabled: true}`\r\n\r\nAnd only one way to explicitly disable it:\r\n`automated: {enabled: false}`",
        "pr_file_module": null
      },
      {
        "comment_id": "2031508780",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22482,
        "pr_file": "ui/src/app/applications/components/application-summary/application-summary.tsx",
        "discussion_id": "2029328079",
        "commented_code": "@@ -529,6 +531,39 @@ export const ApplicationSummary = (props: ApplicationSummaryProps) => {\n \n                             {app.spec.syncPolicy && app.spec.syncPolicy.automated && (\n                                 <React.Fragment>\n+                                    <div className='row white-box__details-row'>\n+                                        <div className='columns small-12'>\n+                                            <div className='checkbox-container'>\n+                                                <Checkbox\n+                                                    onChange={async (val: boolean) => {",
        "comment_created_at": "2025-04-07T15:32:22+00:00",
        "comment_author": "keithchong",
        "comment_body": "Hi @aali309 , just wanted to clarify, that typically in general, when using checkboxes the two check-states represent two distinct values (like a toggle), something like this:\r\n\r\nState ---> YAML\r\n--\r\nchecked ---> `a.b.enabled = true`\r\nunchecked ---> `a.b.enabled = false`\r\n\r\nIt's intuitive because there are two values, true/false, represented by the two check-states. No other logic is used to determine the check-state of the checkbox.  Another behaviour of the checkbox in this case is that if you repeatedly uncheck and check it, the YAML changes predictably.  You also get back the original value.\r\n\r\na.b.enabled = true\r\na.b.enabled = false\r\na.b.enabled = true\r\na.b.enabled = false\r\n...\r\n\r\n\r\nBecause we're considering whether enabled is set to null, or if the enabled field is present or not, then it's problematic because the check-state represents more of a semantic representation (in line 559). So, when we repeatedly uncheck and check it, you might not get back the original contents of the YAML:\r\n\r\nautomated: {}\r\nautomated: { enabled: false}\r\nautomated: { enabled: enabled}\r\nautomated: { enabled: false}\r\nautomated: { enabled: enabled}\r\n...\r\n\r\nIn this case, it doesn't matter because the semantics/logic make it the same.  However, in terms a design point and usability, it is unclear initially how the form UI maps directly to the YAML.\r\n\r\nThus, does this mean we could even make the checkbox a regular push button, just like that for prune and selfHeal, to make it consistent (although I mentioned that this representation does have shortcomings too)?  Note that If you disable prune, it actually removes the element in the YAML.",
        "pr_file_module": null
      },
      {
        "comment_id": "2031695628",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22482,
        "pr_file": "ui/src/app/applications/components/application-summary/application-summary.tsx",
        "discussion_id": "2029328079",
        "commented_code": "@@ -529,6 +531,39 @@ export const ApplicationSummary = (props: ApplicationSummaryProps) => {\n \n                             {app.spec.syncPolicy && app.spec.syncPolicy.automated && (\n                                 <React.Fragment>\n+                                    <div className='row white-box__details-row'>\n+                                        <div className='columns small-12'>\n+                                            <div className='checkbox-container'>\n+                                                <Checkbox\n+                                                    onChange={async (val: boolean) => {",
        "comment_created_at": "2025-04-07T17:30:16+00:00",
        "comment_author": "aali309",
        "comment_body": "I agree that clarity and predictability are important for usability, especially when translating between form UI and YAML. Here the checkbox better represents the parent-child relationship where enabled is a property of automated, and its checked state naturally shows both explicit (enabled: true) and implicit (automated: {}) enabled states. While push buttons work well for independent toggles like prune and selfHeal, they don't visually convey this hierarchical relationship as clearly as the nested checkbox does. \r\n\r\nI\u2019ll open a follow-up issue/PR to explore ways we can improve the form-YAML mapping while preserving simplicity for the majority of users.",
        "pr_file_module": null
      },
      {
        "comment_id": "2034050542",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22482,
        "pr_file": "ui/src/app/applications/components/application-summary/application-summary.tsx",
        "discussion_id": "2029328079",
        "commented_code": "@@ -529,6 +531,39 @@ export const ApplicationSummary = (props: ApplicationSummaryProps) => {\n \n                             {app.spec.syncPolicy && app.spec.syncPolicy.automated && (\n                                 <React.Fragment>\n+                                    <div className='row white-box__details-row'>\n+                                        <div className='columns small-12'>\n+                                            <div className='checkbox-container'>\n+                                                <Checkbox\n+                                                    onChange={async (val: boolean) => {",
        "comment_created_at": "2025-04-08T21:21:00+00:00",
        "comment_author": "keithchong",
        "comment_body": "Ok, I see https://github.com/argoproj/argo-cd/issues/22592. ",
        "pr_file_module": null
      }
    ]
  }
]