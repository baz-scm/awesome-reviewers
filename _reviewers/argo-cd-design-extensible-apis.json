[
  {
    "discussion_id": "2104901563",
    "pr_number": 23131,
    "pr_file": "server/application/application.go",
    "created_at": "2025-05-23T16:00:47+00:00",
    "commented_code": "return nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n }\n \n+func diffBetweenApplicationSpecs(a *v1alpha1.ApplicationSpec, b *v1alpha1.ApplicationSpec) (string, error) {\n+\taBytes, err := json.Marshal(a)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to marshal application: %w\", err)\n+\t}\n+\tbBytes, err := json.Marshal(b)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to marshal application: %w\", err)\n+\t}\n+\n+\tpatch, err := jsonpatch.CreateMergePatch(aBytes, bBytes)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to create json diff between applications: %w\", err)\n+\t}\n+\treturn string(patch), nil",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2104901563",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23131,
        "pr_file": "server/application/application.go",
        "discussion_id": "2104901563",
        "commented_code": "@@ -987,6 +993,23 @@ func (s *Server) updateApp(ctx context.Context, app *v1alpha1.Application, newAp\n \treturn nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n }\n \n+func diffBetweenApplicationSpecs(a *v1alpha1.ApplicationSpec, b *v1alpha1.ApplicationSpec) (string, error) {\n+\taBytes, err := json.Marshal(a)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to marshal application: %w\", err)\n+\t}\n+\tbBytes, err := json.Marshal(b)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to marshal application: %w\", err)\n+\t}\n+\n+\tpatch, err := jsonpatch.CreateMergePatch(aBytes, bBytes)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to create json diff between applications: %w\", err)\n+\t}\n+\treturn string(patch), nil",
        "comment_created_at": "2025-05-23T16:00:47+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "Would it be possible to unmarshal the patch into a map[string]any so log tools aren't forced to parse a JSON string?",
        "pr_file_module": null
      },
      {
        "comment_id": "2105476538",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23131,
        "pr_file": "server/application/application.go",
        "discussion_id": "2104901563",
        "commented_code": "@@ -987,6 +993,23 @@ func (s *Server) updateApp(ctx context.Context, app *v1alpha1.Application, newAp\n \treturn nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n }\n \n+func diffBetweenApplicationSpecs(a *v1alpha1.ApplicationSpec, b *v1alpha1.ApplicationSpec) (string, error) {\n+\taBytes, err := json.Marshal(a)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to marshal application: %w\", err)\n+\t}\n+\tbBytes, err := json.Marshal(b)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to marshal application: %w\", err)\n+\t}\n+\n+\tpatch, err := jsonpatch.CreateMergePatch(aBytes, bBytes)\n+\tif err != nil {\n+\t\treturn \"\", fmt.Errorf(\"failed to create json diff between applications: %w\", err)\n+\t}\n+\treturn string(patch), nil",
        "comment_created_at": "2025-05-23T22:05:53+00:00",
        "comment_author": "TomHellier",
        "comment_body": "I've made this change",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2089376434",
    "pr_number": 22444,
    "pr_file": "pkg/apis/application/v1alpha1/types.go",
    "created_at": "2025-05-14T17:02:28+00:00",
    "commented_code": "type ApplicationList struct {\n \tmetav1.TypeMeta `json:\",inline\"`\n \tmetav1.ListMeta `json:\"metadata\" protobuf:\"bytes,1,opt,name=metadata\"`\n-\tItems           []Application `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n+\tItems           []Application        `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n+\tStats           ApplicationListStats `json:\"stats,omitempty\" protobuf:\"bytes,3,opt,name=stats\"`",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2089376434",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22444,
        "pr_file": "pkg/apis/application/v1alpha1/types.go",
        "discussion_id": "2089376434",
        "commented_code": "@@ -1696,7 +1696,31 @@ type ApplicationWatchEvent struct {\n type ApplicationList struct {\n \tmetav1.TypeMeta `json:\",inline\"`\n \tmetav1.ListMeta `json:\"metadata\" protobuf:\"bytes,1,opt,name=metadata\"`\n-\tItems           []Application `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n+\tItems           []Application        `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n+\tStats           ApplicationListStats `json:\"stats,omitempty\" protobuf:\"bytes,3,opt,name=stats\"`",
        "comment_created_at": "2025-05-14T17:02:28+00:00",
        "comment_author": "agaudreault",
        "comment_body": "The list stats should be part of an ApplicationListResponse object specific to the server/application/application.proto.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2106074806",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22444,
        "pr_file": "pkg/apis/application/v1alpha1/types.go",
        "discussion_id": "2089376434",
        "commented_code": "@@ -1696,7 +1696,31 @@ type ApplicationWatchEvent struct {\n type ApplicationList struct {\n \tmetav1.TypeMeta `json:\",inline\"`\n \tmetav1.ListMeta `json:\"metadata\" protobuf:\"bytes,1,opt,name=metadata\"`\n-\tItems           []Application `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n+\tItems           []Application        `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n+\tStats           ApplicationListStats `json:\"stats,omitempty\" protobuf:\"bytes,3,opt,name=stats\"`",
        "comment_created_at": "2025-05-25T03:40:18+00:00",
        "comment_author": "muma378",
        "comment_body": "Sure, that sounds more reasonable, but it might be a problem that a breaking change was introduced.  Maybe we should add a new method instead of modifying the return type of the existing one?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2186085699",
    "pr_number": 22901,
    "pr_file": "util/session/sessionmanager.go",
    "created_at": "2025-07-04T20:35:18+00:00",
    "commented_code": "VerifyToken(token string) (jwt.Claims, string, error)\n }\n \n-// WithAuthMiddleware is an HTTP middleware used to ensure incoming\n-// requests are authenticated before invoking the target handler. If\n-// disabled is true, it will just invoke the next handler in the chain.\n+// WithAuthMiddleware is an HTTP middleware used to ensure incoming requests are authenticated before invoking the target handler.\n+// If disabled is true, it will just invoke the next handler in the chain.\n+// It checks for tokens in a configured header (for IAP JWTs) first, then falls back to cookies.\n func WithAuthMiddleware(disabled bool, authn TokenVerifier, next http.Handler) http.Handler {\n \treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n-\t\tif !disabled {\n-\t\t\tcookies := r.Cookies()\n-\t\t\ttokenString, err := httputil.JoinCookies(common.AuthCookieName, cookies)\n-\t\t\tif err != nil {\n-\t\t\t\thttp.Error(w, \"Auth cookie not found\", http.StatusBadRequest)\n-\t\t\t\treturn\n+\t\tif disabled {\n+\t\t\tnext.ServeHTTP(w, r)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar tokenString string\n+\t\tvar err error\n+\t\tctx := r.Context()\n+\n+\t\t// Attempt to get settings manager from the verifier if possible\n+\t\t// This assumes the TokenVerifier implementation might expose settings\n+\t\tvar settingsMgr *settings.SettingsManager\n+\t\tif sm, ok := authn.(*SessionManager); ok {\n+\t\t\tsettingsMgr = sm.settingsMgr\n+\t\t}",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2186085699",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22901,
        "pr_file": "util/session/sessionmanager.go",
        "discussion_id": "2186085699",
        "commented_code": "@@ -490,86 +494,155 @@ type TokenVerifier interface {\n \tVerifyToken(token string) (jwt.Claims, string, error)\n }\n \n-// WithAuthMiddleware is an HTTP middleware used to ensure incoming\n-// requests are authenticated before invoking the target handler. If\n-// disabled is true, it will just invoke the next handler in the chain.\n+// WithAuthMiddleware is an HTTP middleware used to ensure incoming requests are authenticated before invoking the target handler.\n+// If disabled is true, it will just invoke the next handler in the chain.\n+// It checks for tokens in a configured header (for IAP JWTs) first, then falls back to cookies.\n func WithAuthMiddleware(disabled bool, authn TokenVerifier, next http.Handler) http.Handler {\n \treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n-\t\tif !disabled {\n-\t\t\tcookies := r.Cookies()\n-\t\t\ttokenString, err := httputil.JoinCookies(common.AuthCookieName, cookies)\n-\t\t\tif err != nil {\n-\t\t\t\thttp.Error(w, \"Auth cookie not found\", http.StatusBadRequest)\n-\t\t\t\treturn\n+\t\tif disabled {\n+\t\t\tnext.ServeHTTP(w, r)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar tokenString string\n+\t\tvar err error\n+\t\tctx := r.Context()\n+\n+\t\t// Attempt to get settings manager from the verifier if possible\n+\t\t// This assumes the TokenVerifier implementation might expose settings\n+\t\tvar settingsMgr *settings.SettingsManager\n+\t\tif sm, ok := authn.(*SessionManager); ok {\n+\t\t\tsettingsMgr = sm.settingsMgr\n+\t\t}",
        "comment_created_at": "2025-07-04T20:35:18+00:00",
        "comment_author": "agaudreault",
        "comment_body": "Create another method on the interface, or provide another interface param to the middleware to `GetToken(r *http.Request) string`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2186121207",
    "pr_number": 22901,
    "pr_file": "util/oidc/provider.go",
    "created_at": "2025-07-04T21:19:42+00:00",
    "commented_code": "ParseConfig() (*OIDCConfiguration, error)\n \n \tVerify(tokenString string, argoSettings *settings.ArgoCDSettings) (*gooidc.IDToken, error)\n+\n+\tVerifyJWT(tokenString string, argoSettings *settings.ArgoCDSettings) (*jwtgo.Token, error)",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2186121207",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22901,
        "pr_file": "util/oidc/provider.go",
        "discussion_id": "2186121207",
        "commented_code": "@@ -28,21 +33,29 @@ type Provider interface {\n \tParseConfig() (*OIDCConfiguration, error)\n \n \tVerify(tokenString string, argoSettings *settings.ArgoCDSettings) (*gooidc.IDToken, error)\n+\n+\tVerifyJWT(tokenString string, argoSettings *settings.ArgoCDSettings) (*jwtgo.Token, error)",
        "comment_created_at": "2025-07-04T21:19:42+00:00",
        "comment_author": "agaudreault",
        "comment_body": "Instead of having a new VerifyJWT method on the existing provider interface, shouldn't you have a new implementation of the provider interface for JWT token? or have a new provider totally in something like /util/jwt/provider.go",
        "pr_file_module": null
      }
    ]
  }
]