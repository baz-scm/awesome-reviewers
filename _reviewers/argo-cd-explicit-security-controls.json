[
  {
    "discussion_id": "2152540804",
    "pr_number": 22858,
    "pr_file": "docs/operator-manual/rbac.md",
    "created_at": "2025-06-17T15:15:45+00:00",
    "commented_code": "#### The `override` action\n \n+The `override` action grant can be used to allow deploying arbitrary manifests or different revisions to existing Applications, e.g. for development or testing purposes. \n+\n+**Attention:** This allows users to completely change/delete the deployed resources of the Application. \n+\n When granted along with the `sync` action, the override action will allow a user to synchronize local manifests to the Application.\n These manifests will be used instead of the configured source, until the next sync is performed.\n \n+Additionally, when `application.sync.externalRevisionConsideredOverride: 'true'` is set in the `argcd-cm` configmap, \n+passing a revision when syncing an application is also considered as an `override`, to prevent synchronizing to arbitrary revisions other than the revision(s) given in the Application source.\n+\n+The default setting is 'false', to prevent breaking changes in existing installations. It is recommended to set this setting to 'true' and grant the `override` right per AppProject to the users that actually need this behavior.",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2152540804",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22858,
        "pr_file": "docs/operator-manual/rbac.md",
        "discussion_id": "2152540804",
        "commented_code": "@@ -203,9 +203,19 @@ p, example-user, applications, action/*, default/*, allow\n \n #### The `override` action\n \n+The `override` action grant can be used to allow deploying arbitrary manifests or different revisions to existing Applications, e.g. for development or testing purposes. \n+\n+**Attention:** This allows users to completely change/delete the deployed resources of the Application. \n+\n When granted along with the `sync` action, the override action will allow a user to synchronize local manifests to the Application.\n These manifests will be used instead of the configured source, until the next sync is performed.\n \n+Additionally, when `application.sync.externalRevisionConsideredOverride: 'true'` is set in the `argcd-cm` configmap, \n+passing a revision when syncing an application is also considered as an `override`, to prevent synchronizing to arbitrary revisions other than the revision(s) given in the Application source.\n+\n+The default setting is 'false', to prevent breaking changes in existing installations. It is recommended to set this setting to 'true' and grant the `override` right per AppProject to the users that actually need this behavior.",
        "comment_created_at": "2025-06-17T15:15:45+00:00",
        "comment_author": "agaudreault",
        "comment_body": "Should we set the default behavior to `false` (reverse the flag) so we are \"secure\" by default. Since the Sync action has to be called by a client, users will be able to upgrade Argo CD with the new behavior without affecting their Application. \r\n\r\nIf users need tome to apply the override permissions, then they can disable the flag.",
        "pr_file_module": null
      },
      {
        "comment_id": "2153088880",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22858,
        "pr_file": "docs/operator-manual/rbac.md",
        "discussion_id": "2152540804",
        "commented_code": "@@ -203,9 +203,19 @@ p, example-user, applications, action/*, default/*, allow\n \n #### The `override` action\n \n+The `override` action grant can be used to allow deploying arbitrary manifests or different revisions to existing Applications, e.g. for development or testing purposes. \n+\n+**Attention:** This allows users to completely change/delete the deployed resources of the Application. \n+\n When granted along with the `sync` action, the override action will allow a user to synchronize local manifests to the Application.\n These manifests will be used instead of the configured source, until the next sync is performed.\n \n+Additionally, when `application.sync.externalRevisionConsideredOverride: 'true'` is set in the `argcd-cm` configmap, \n+passing a revision when syncing an application is also considered as an `override`, to prevent synchronizing to arbitrary revisions other than the revision(s) given in the Application source.\n+\n+The default setting is 'false', to prevent breaking changes in existing installations. It is recommended to set this setting to 'true' and grant the `override` right per AppProject to the users that actually need this behavior.",
        "comment_created_at": "2025-06-17T20:14:04+00:00",
        "comment_author": "schraax",
        "comment_body": "First, thanks for taking a look at this pr. \r\nRegarding you suggestion, I am sorry, i think i do not completely understand it.\r\nThe default is already 'false', as you suggest. \r\n![grafik](https://github.com/user-attachments/assets/6c8caf45-ff31-4667-b23f-bd4018abf18f)\r\n\r\n![grafik](https://github.com/user-attachments/assets/b4bddf3a-f944-4cbd-ba30-c4590bbf468c)\r\n\r\n\r\nIs there any way i could rephrase this to prevent misunderstanding?\r\n\r\nThe way this setting is introduced is exactly to \"not affect\"  existing procedures for argocd users. \r\n\r\nPersonally, i would like to completely disable any and all \"overriding\" for our usecase, but i assume this feature has been implemented by people who need it exactly the way it is. \r\nAlso, as someone managing a lot of applications i appreciate an update without surprises.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1974816375",
    "pr_number": 22049,
    "pr_file": "docs/operator-manual/user-management/zitadel.md",
    "created_at": "2025-02-28T05:36:31+00:00",
    "commented_code": "Configure your configmaps as follows while making sure to replace the relevant values such as `url`, `issuer`, `clientID`, `clientSecret` and `logoutURL` with ones matching your setup.\n \n+### argocd-secret.yaml\n+```yaml\n+apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: argocd-secret\n+  namespace: argocd\n+  labels:\n+    app.kubernetes.io/name: argocd-secret\n+    app.kubernetes.io/part-of: argocd\n+type: Opaque\n+data:\n+  ...\n+  # The secret value must be base64 encoded **once** \n+  # this value corresponds to: `printf \"hello-world\" | base64`\n+  oidc.zitadel.clientSecret: \"VUd2VGpYVkZBUThFa012Mng0R2JQY3JFd3JKR1daMHNSMktid0hSTmZZeGVMc0R1ckNpVkVwYTVia2dXMHBsMA==\"",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "1974816375",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22049,
        "pr_file": "docs/operator-manual/user-management/zitadel.md",
        "discussion_id": "1974816375",
        "commented_code": "@@ -149,9 +149,27 @@ Next, we will configure two ArgoCD configmaps:\n \n Configure your configmaps as follows while making sure to replace the relevant values such as `url`, `issuer`, `clientID`, `clientSecret` and `logoutURL` with ones matching your setup.\n \n+### argocd-secret.yaml\n+```yaml\n+apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: argocd-secret\n+  namespace: argocd\n+  labels:\n+    app.kubernetes.io/name: argocd-secret\n+    app.kubernetes.io/part-of: argocd\n+type: Opaque\n+data:\n+  ...\n+  # The secret value must be base64 encoded **once** \n+  # this value corresponds to: `printf \"hello-world\" | base64`\n+  oidc.zitadel.clientSecret: \"VUd2VGpYVkZBUThFa012Mng0R2JQY3JFd3JKR1daMHNSMktid0hSTmZZeGVMc0R1ckNpVkVwYTVia2dXMHBsMA==\"",
        "comment_created_at": "2025-02-28T05:36:31+00:00",
        "comment_author": "andrii-korotkov-verkada",
        "comment_body": "I don't think we should encourage people to set secret values in manifests.",
        "pr_file_module": null
      },
      {
        "comment_id": "1976251859",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22049,
        "pr_file": "docs/operator-manual/user-management/zitadel.md",
        "discussion_id": "1974816375",
        "commented_code": "@@ -149,9 +149,27 @@ Next, we will configure two ArgoCD configmaps:\n \n Configure your configmaps as follows while making sure to replace the relevant values such as `url`, `issuer`, `clientID`, `clientSecret` and `logoutURL` with ones matching your setup.\n \n+### argocd-secret.yaml\n+```yaml\n+apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: argocd-secret\n+  namespace: argocd\n+  labels:\n+    app.kubernetes.io/name: argocd-secret\n+    app.kubernetes.io/part-of: argocd\n+type: Opaque\n+data:\n+  ...\n+  # The secret value must be base64 encoded **once** \n+  # this value corresponds to: `printf \"hello-world\" | base64`\n+  oidc.zitadel.clientSecret: \"VUd2VGpYVkZBUThFa012Mng0R2JQY3JFd3JKR1daMHNSMktid0hSTmZZeGVMc0R1ckNpVkVwYTVia2dXMHBsMA==\"",
        "comment_created_at": "2025-03-01T03:18:25+00:00",
        "comment_author": "AFanaei",
        "comment_body": "In my opinion People usually know how to deal with handling secrets in general using various methods such as sealed secret, external secret or ... but they may not be familiar with the way secrets can be ingested in argocd manifests. At least this was my issue. Feel free to close this pr.",
        "pr_file_module": null
      },
      {
        "comment_id": "1976267127",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22049,
        "pr_file": "docs/operator-manual/user-management/zitadel.md",
        "discussion_id": "1974816375",
        "commented_code": "@@ -149,9 +149,27 @@ Next, we will configure two ArgoCD configmaps:\n \n Configure your configmaps as follows while making sure to replace the relevant values such as `url`, `issuer`, `clientID`, `clientSecret` and `logoutURL` with ones matching your setup.\n \n+### argocd-secret.yaml\n+```yaml\n+apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: argocd-secret\n+  namespace: argocd\n+  labels:\n+    app.kubernetes.io/name: argocd-secret\n+    app.kubernetes.io/part-of: argocd\n+type: Opaque\n+data:\n+  ...\n+  # The secret value must be base64 encoded **once** \n+  # this value corresponds to: `printf \"hello-world\" | base64`\n+  oidc.zitadel.clientSecret: \"VUd2VGpYVkZBUThFa012Mng0R2JQY3JFd3JKR1daMHNSMktid0hSTmZZeGVMc0R1ckNpVkVwYTVia2dXMHBsMA==\"",
        "comment_created_at": "2025-03-01T04:05:15+00:00",
        "comment_author": "andrii-korotkov-verkada",
        "comment_body": "I mean, you can update the instructions to use kubectl edit to ingest the secret or similar.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1943554047",
    "pr_number": 21678,
    "pr_file": "docs/operator-manual/upgrading/2.14-3.0.md",
    "created_at": "2025-02-05T19:28:23+00:00",
    "commented_code": "Read the [RBAC documentation](../rbac.md#fine-grained-permissions-for-updatedelete-action) for more detailed inforamtion.\n \n+### Logs RBAC enforcement as a first-class RBAC citizen\n+\n+2.4 introduced `logs` as a new RBAC resource. In 2.3 and lower, users with `applications, get` access automatically got logs access. In 2.4, it became possible to enable logs RBAC enforcement with a flag in `argocd-cm` ConfigMap:\n+\n+```yaml\n+server.rbac.log.enforce.enable: \"true\"\n+```\n+\n+Users who have the above setting in place, would be unaffected by this change and don't need to perform any additional action. It is recommended though to delete this setting from the `argocd-cm` ConfigMap.\n+\n+Users who either have `server.rbac.log.enforce.enable` set to `false` or don't have this setting at all in their `argocd-cm` ConfigMap will have to explicitly grant `logs, get` access, as this flag (and it's default behaviour of `false`) has been deprecated.",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "1943554047",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 21678,
        "pr_file": "docs/operator-manual/upgrading/2.14-3.0.md",
        "discussion_id": "1943554047",
        "commented_code": "@@ -23,6 +23,19 @@ to `false` in the Argo CD ConfigMap `argocd-cm`.\n \n Read the [RBAC documentation](../rbac.md#fine-grained-permissions-for-updatedelete-action) for more detailed inforamtion.\n \n+### Logs RBAC enforcement as a first-class RBAC citizen\n+\n+2.4 introduced `logs` as a new RBAC resource. In 2.3 and lower, users with `applications, get` access automatically got logs access. In 2.4, it became possible to enable logs RBAC enforcement with a flag in `argocd-cm` ConfigMap:\n+\n+```yaml\n+server.rbac.log.enforce.enable: \"true\"\n+```\n+\n+Users who have the above setting in place, would be unaffected by this change and don't need to perform any additional action. It is recommended though to delete this setting from the `argocd-cm` ConfigMap.\n+\n+Users who either have `server.rbac.log.enforce.enable` set to `false` or don't have this setting at all in their `argocd-cm` ConfigMap will have to explicitly grant `logs, get` access, as this flag (and it's default behaviour of `false`) has been deprecated.",
        "comment_created_at": "2025-02-05T19:28:23+00:00",
        "comment_author": "rumstead",
        "comment_body": "```suggestion\r\nUsers who either have `server.rbac.log.enforce.enable` set to `false` or don't have this setting at all in their `argocd-cm` ConfigMap will have to explicitly grant `logs, get` access, as this flag (and it's default behaviour of `false`) has been removed.\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983037272",
    "pr_number": 22223,
    "pr_file": "docs/proposals/image-verification-policies.md",
    "created_at": "2025-03-06T09:49:05+00:00",
    "commented_code": "+---\n+title: image Verification Policies\n+authors:\n+  - \"@anithapriyanatarajan\" \n+sponsors:\n+  - TBD        # List all interested parties here.\n+reviewers:\n+  - \"@anandf\"\n+approvers:\n+  - TBD\n+\n+creation-date: 2025-02-20\n+last-updated: 2025-02-20\n+---\n+\n+# Image Verification Policies\n+\n+This proposal introduces a new feature to verify the integrity of container images before deployment\n+\n+## Summary\n+\n+As containerized applications grow in complexity, ensuring the security of deployed images becomes a critical concern. Deploying unsigned or tampered images can lead to potential security risks, such as vulnerabilities being introduced into production environments. Currently, there is no automated process within ArgoCD to verify the integrity of container images before deployment, creating a security gap in the pipeline.\n+\n+This proposal introduces a new feature to validate the container image using signatures before deployment, providing an additional layer of security by ensuring that only trusted and verified images are deployed in production environments. \n+\n+## Motivation\n+\n+\"Shift Left does not mean abandoning the Right.\"\n+\n+Argo CD is a widely-used deployment tool that automates the continuous delivery of applications in Kubernetes environments. Since it integrates with source control repositories and can trigger deployments, Argo CD sits at a critical point in the DevOps pipeline. However, there is currently no automated method to verify the integrity of container images before deployment, leaving room for potentially unsafe or tampered images to make their way into production.\n+\n+Cryptographically signed images and secure supply chain management practices are becoming essential for organizations looking to reduce the risk of vulnerabilities and threats from malicious actors.\n+\n+While there are multiple ways to produce secure, signed container images, there is no existing feature in Argo CD that automates the verification of these artifacts before deployment. This proposed feature will bridge this gap, offering image verification at the time of deployment to ensure that only trusted and signed images are deployed.\n+\n+### Goals\n+\n+* Increase confidence in the integrity of the images deployed to production.\n+* Verify that images are supplied by trusted sources, ensuring that only cryptographically signed images are deployed.\n+* Ensure compliance with SLSA (Supply Chain Levels for Software Artifacts) standards, allowing organizations to verify that their images meet the necessary security and compliance levels.\n+* Abort deployment if the image signature verification fails or if the image does not adhere to the defined SLSA levels.\n+* Provide flexibility for users to opt into this verification process at the application level, allowing granular control.\n+\n+### Non-Goals\n+\n+* To start with we will focus on artifacts signed by sigstore tool cosign only. Verification of images signed by other tools like Notary could be progressed at a later stage.\n+* Solution to sign images (as this is a separate process handled outside of Argo CD).\n+* Handle artifacts other than container images (e.g., Helm charts, Kubernetes manifests).\n+\n+## Proposal\n+\n+\n+### Use cases\n+\n+Add a list of detailed use cases this enhancement intends to take care of.\n+\n+#### Use case 1: Image Signature Verification\n+\n+As an Argo CD user, I would like to ensure that my applications are only deployed if the container images are built following SLSA standards and have been cryptographically signed by a trusted party.\n+\n+#### Use case 2: Per-Application Validation\n+\n+As an Argo CD user, I need the ability to apply different image signature verification policies to different applications. For example, some applications may require stricter image signature checks, while others may be more flexible.\n+\n+## Implementation Details/Notes/Constraints\n+\n+We enable enforcement configurations at the `AppProject` level and granular verification configs at the `Application` level.\n+\n+### Enforcement Configuration in `AppProject`\n+\n+- **imageVerification**: enabled/disabled - Indicates if image verification should be enabled for the given project.\n+- **enforcementLevel**: strict/permissive - Indicates if the deployment should be blocked or progressed with a warning.\n+- **allowedProviders**: e.g., `cosign`, `notary` - Can be expanded to include more options.\n+- **minSlsaLevel**: 0/1/2/3/4 - Expected SLSA level of images deployed.\n+- **defaultSigners**: Default configurations used to verify images for all applications within the project.\n+\n+```\n+apiVersion: argoproj.io/v1alpha1\n+kind: AppProject\n+metadata:\n+  name: my-secure-project\n+spec:\n+  imageVerification:\n+    enabled: true\n+    enforcementLevel: strict  # Enforce strict validation across applications\n+    allowedProviders: [\"cosign\", \"notary\"]\n+    minSlsaLevel: 2  # Enforce a minimum SLSA level for all applications\n+    defaultSigners:\n+      - method: \"kms\"\n+        signer:\n+          kmsKeyID: \"arn:aws:kms:region:account-id:key/key-id\"\n+          kmsProvider: \"AWS\"\n+      - method: \"static\"\n+        signer:\n+          publicKey: \"trusted-public-key\"\n+```\n+\n+### Granular Configuration in `Application`\n+\n+Application level image verification config overrides the default signer configuration at the AppProject level\n+\n+```\n+apiVersion: argoproj.io/v1alpha1\n+kind: Application\n+metadata:\n+  name: my-secure-app\n+spec:\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+  source:\n+    repoURL: 'https://github.com/my-repo'\n+    targetRevision: HEAD\n+    path: charts/my-secure-app\n+  syncPolicy:\n+    automated:\n+      prune: true\n+      selfHeal: true\n+  imageVerification:\n+    signers:\n+      - method: \"static\"\n+        publicKey: \"trusted-public-key\" #mount path where the public key can be accessed",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "1983037272",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22223,
        "pr_file": "docs/proposals/image-verification-policies.md",
        "discussion_id": "1983037272",
        "commented_code": "@@ -0,0 +1,211 @@\n+---\n+title: image Verification Policies\n+authors:\n+  - \"@anithapriyanatarajan\" \n+sponsors:\n+  - TBD        # List all interested parties here.\n+reviewers:\n+  - \"@anandf\"\n+approvers:\n+  - TBD\n+\n+creation-date: 2025-02-20\n+last-updated: 2025-02-20\n+---\n+\n+# Image Verification Policies\n+\n+This proposal introduces a new feature to verify the integrity of container images before deployment\n+\n+## Summary\n+\n+As containerized applications grow in complexity, ensuring the security of deployed images becomes a critical concern. Deploying unsigned or tampered images can lead to potential security risks, such as vulnerabilities being introduced into production environments. Currently, there is no automated process within ArgoCD to verify the integrity of container images before deployment, creating a security gap in the pipeline.\n+\n+This proposal introduces a new feature to validate the container image using signatures before deployment, providing an additional layer of security by ensuring that only trusted and verified images are deployed in production environments. \n+\n+## Motivation\n+\n+\"Shift Left does not mean abandoning the Right.\"\n+\n+Argo CD is a widely-used deployment tool that automates the continuous delivery of applications in Kubernetes environments. Since it integrates with source control repositories and can trigger deployments, Argo CD sits at a critical point in the DevOps pipeline. However, there is currently no automated method to verify the integrity of container images before deployment, leaving room for potentially unsafe or tampered images to make their way into production.\n+\n+Cryptographically signed images and secure supply chain management practices are becoming essential for organizations looking to reduce the risk of vulnerabilities and threats from malicious actors.\n+\n+While there are multiple ways to produce secure, signed container images, there is no existing feature in Argo CD that automates the verification of these artifacts before deployment. This proposed feature will bridge this gap, offering image verification at the time of deployment to ensure that only trusted and signed images are deployed.\n+\n+### Goals\n+\n+* Increase confidence in the integrity of the images deployed to production.\n+* Verify that images are supplied by trusted sources, ensuring that only cryptographically signed images are deployed.\n+* Ensure compliance with SLSA (Supply Chain Levels for Software Artifacts) standards, allowing organizations to verify that their images meet the necessary security and compliance levels.\n+* Abort deployment if the image signature verification fails or if the image does not adhere to the defined SLSA levels.\n+* Provide flexibility for users to opt into this verification process at the application level, allowing granular control.\n+\n+### Non-Goals\n+\n+* To start with we will focus on artifacts signed by sigstore tool cosign only. Verification of images signed by other tools like Notary could be progressed at a later stage.\n+* Solution to sign images (as this is a separate process handled outside of Argo CD).\n+* Handle artifacts other than container images (e.g., Helm charts, Kubernetes manifests).\n+\n+## Proposal\n+\n+\n+### Use cases\n+\n+Add a list of detailed use cases this enhancement intends to take care of.\n+\n+#### Use case 1: Image Signature Verification\n+\n+As an Argo CD user, I would like to ensure that my applications are only deployed if the container images are built following SLSA standards and have been cryptographically signed by a trusted party.\n+\n+#### Use case 2: Per-Application Validation\n+\n+As an Argo CD user, I need the ability to apply different image signature verification policies to different applications. For example, some applications may require stricter image signature checks, while others may be more flexible.\n+\n+## Implementation Details/Notes/Constraints\n+\n+We enable enforcement configurations at the `AppProject` level and granular verification configs at the `Application` level.\n+\n+### Enforcement Configuration in `AppProject`\n+\n+- **imageVerification**: enabled/disabled - Indicates if image verification should be enabled for the given project.\n+- **enforcementLevel**: strict/permissive - Indicates if the deployment should be blocked or progressed with a warning.\n+- **allowedProviders**: e.g., `cosign`, `notary` - Can be expanded to include more options.\n+- **minSlsaLevel**: 0/1/2/3/4 - Expected SLSA level of images deployed.\n+- **defaultSigners**: Default configurations used to verify images for all applications within the project.\n+\n+```\n+apiVersion: argoproj.io/v1alpha1\n+kind: AppProject\n+metadata:\n+  name: my-secure-project\n+spec:\n+  imageVerification:\n+    enabled: true\n+    enforcementLevel: strict  # Enforce strict validation across applications\n+    allowedProviders: [\"cosign\", \"notary\"]\n+    minSlsaLevel: 2  # Enforce a minimum SLSA level for all applications\n+    defaultSigners:\n+      - method: \"kms\"\n+        signer:\n+          kmsKeyID: \"arn:aws:kms:region:account-id:key/key-id\"\n+          kmsProvider: \"AWS\"\n+      - method: \"static\"\n+        signer:\n+          publicKey: \"trusted-public-key\"\n+```\n+\n+### Granular Configuration in `Application`\n+\n+Application level image verification config overrides the default signer configuration at the AppProject level\n+\n+```\n+apiVersion: argoproj.io/v1alpha1\n+kind: Application\n+metadata:\n+  name: my-secure-app\n+spec:\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+  source:\n+    repoURL: 'https://github.com/my-repo'\n+    targetRevision: HEAD\n+    path: charts/my-secure-app\n+  syncPolicy:\n+    automated:\n+      prune: true\n+      selfHeal: true\n+  imageVerification:\n+    signers:\n+      - method: \"static\"\n+        publicKey: \"trusted-public-key\" #mount path where the public key can be accessed",
        "comment_created_at": "2025-03-06T09:49:05+00:00",
        "comment_author": "anandf",
        "comment_body": "Can you put a specific path like `/tmp/trusted-public-key.pub`",
        "pr_file_module": null
      }
    ]
  }
]