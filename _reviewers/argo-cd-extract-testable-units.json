[
  {
    "discussion_id": "2087183726",
    "pr_number": 22780,
    "pr_file": "cmd/argocd/commands/admin/backup_test.go",
    "created_at": "2025-05-13T16:07:08+00:00",
    "commented_code": "}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"It should update live object if skip label is not present in backup object\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\tprune:                    true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should update live spec if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should update live spec if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should not update live object if it matches the backup exactly\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should create live resource if it is missing\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should prune live resources not present in backup when prune is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should clear the operation field when stopOperation is true\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should override live object when --override-on-conflict is true\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)\n+\t\t\tliveObj := decodeYAMLToUnstructured(t, tt.args.live)\n+\t\t\tpruneObjects := make(map[kube.ResourceKey]unstructured.Unstructured)\n+\n+\t\t\tconfigMap := &unstructured.Unstructured{}\n+\t\t\tconfigMap.SetUnstructuredContent(map[string]any{\n+\t\t\t\t\"apiVersion\": \"v1\",\n+\t\t\t\t\"kind\":       \"ConfigMap\",\n+\t\t\t\t\"metadata\": map[string]any{\n+\t\t\t\t\t\"name\":      \"argocd-cmd-params-cm\",\n+\t\t\t\t\t\"namespace\": \"default\",\n+\t\t\t\t},\n+\t\t\t\t\"data\": map[string]any{\n+\t\t\t\t\t\"application.namespaces\":    \"argocd,dev\",\n+\t\t\t\t\t\"applicationset.namespaces\": \"argocd,stage\",\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tctx := t.Context()\n+\t\t\tgvr := schema.GroupVersionResource{\n+\t\t\t\tGroup:    \"\",\n+\t\t\t\tVersion:  \"v1\",\n+\t\t\t\tResource: \"configmaps\",\n+\t\t\t}\n+\n+\t\t\tdynamicClient := dynamicfake.NewSimpleDynamicClient(runtime.NewScheme(), configMap)\n+\t\t\tconfigMapResource := dynamicClient.Resource(gvr).Namespace(\"default\")\n+\n+\t\t\tif len(tt.applicationNamespaces) == 0 || len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\tdefaultNs := getAdditionalNamespaces(ctx, configMapResource)\n+\n+\t\t\t\tif len(tt.applicationNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationNamespaces = defaultNs.applicationNamespaces\n+\t\t\t\t}\n+\n+\t\t\t\tif len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationsetNamespaces = defaultNs.applicationsetNamespaces\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// check if the object is a configMap or not\n+\t\t\tif isArgoCDConfigMap(bakObj.GetName()) {\n+\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"\", Kind: \"ConfigMap\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t}\n+\t\t\t// check if the object is a secret or not\n+\t\t\tif isArgoCDSecret(*bakObj) {\n+\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"\", Kind: \"Secret\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t}\n+\t\t\t// check if the object is an application or not\n+\t\t\tif bakObj.GetKind() == \"Application\" {\n+\t\t\t\tif security.IsNamespaceEnabled(bakObj.GetNamespace(), \"argocd\", tt.applicationNamespaces) {\n+\t\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"Application\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// check if the object is a project or not\n+\t\t\tif bakObj.GetKind() == \"AppProject\" {\n+\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"AppProject\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t}\n+\t\t\t// check if the object is an applicationSet or not\n+\t\t\tif bakObj.GetKind() == \"ApplicationSet\" {\n+\t\t\t\tif security.IsNamespaceEnabled(bakObj.GetNamespace(), \"argocd\", tt.applicationsetNamespaces) {\n+\t\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"ApplicationSet\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tgvk := bakObj.GroupVersionKind()\n+\t\t\tif bakObj.GetNamespace() == \"\" {\n+\t\t\t\tbakObj.SetNamespace(\"argocd\")\n+\t\t\t}\n+\t\t\tkey := kube.ResourceKey{Group: gvk.Group, Kind: gvk.Kind, Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}\n+\t\t\tliveObject, exists := pruneObjects[key]\n+\t\t\tdelete(pruneObjects, key)\n+\n+\t\t\tvar updatedLive *unstructured.Unstructured\n+\t\t\tvar dynClient dynamic.ResourceInterface\n+\n+\t\t\tif bakObj.GetKind() == \"Secret\" {\n+\t\t\t\tdynClient = dynamicClient.Resource(secretResource).Namespace(bakObj.GetNamespace())\n+\t\t\t}\n+\n+\t\t\tif slices.Contains(tt.applicationNamespaces, bakObj.GetNamespace()) || slices.Contains(tt.applicationsetNamespaces, bakObj.GetNamespace()) {\n+\t\t\t\tif !isSkipLabelMatches(bakObj, tt.skipResourcesWithLabel) || !isSkipLabelMatches(liveObj, tt.skipResourcesWithLabel) {\n+\t\t\t\t\tif tt.prune {\n+\t\t\t\t\t\terr := dynClient.Delete(ctx, key.Name, metav1.DeleteOptions{})\n+\t\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tupdatedLive = updateLive(bakObj, liveObj, tt.stopOperation)\n+\n+\t\t\t\t\t\tif tt.overrideOnConflict {\n+\t\t\t\t\t\t\tswitch {\n+\t\t\t\t\t\t\tcase !exists:\n+\t\t\t\t\t\t\t\t_, err := dynClient.Create(ctx, bakObj, metav1.CreateOptions{})\n+\t\t\t\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\t\tnewLive := updateLive(bakObj, &liveObject, tt.stopOperation)\n+\t\t\t\t\t\t\t\t_, err := dynClient.Update(ctx, newLive, metav1.UpdateOptions{})\n+\t\t\t\t\t\t\t\tif apierrors.IsConflict(err) && tt.overrideOnConflict {\n+\t\t\t\t\t\t\t\t\terr = retry.RetryOnConflict(retry.DefaultRetry, func() error {\n+\t\t\t\t\t\t\t\t\t\tliveObj, _ := dynClient.Get(ctx, newLive.GetName(), metav1.GetOptions{})\n+\n+\t\t\t\t\t\t\t\t\t\tnewLive.SetResourceVersion(liveObj.GetResourceVersion())\n+\t\t\t\t\t\t\t\t\t\t_, err = dynClient.Update(ctx, newLive, metav1.UpdateOptions{})\n+\t\t\t\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t\t\t\t})\n+\n+\t\t\t\t\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t\t\t\t\t}",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2087183726",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22780,
        "pr_file": "cmd/argocd/commands/admin/backup_test.go",
        "discussion_id": "2087183726",
        "commented_code": "@@ -362,6 +372,430 @@ status: {}\n \t}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"It should update live object if skip label is not present in backup object\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\tprune:                    true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should update live spec if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should update live spec if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should not update live object if it matches the backup exactly\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should create live resource if it is missing\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should prune live resources not present in backup when prune is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should clear the operation field when stopOperation is true\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"It should override live object when --override-on-conflict is true\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)\n+\t\t\tliveObj := decodeYAMLToUnstructured(t, tt.args.live)\n+\t\t\tpruneObjects := make(map[kube.ResourceKey]unstructured.Unstructured)\n+\n+\t\t\tconfigMap := &unstructured.Unstructured{}\n+\t\t\tconfigMap.SetUnstructuredContent(map[string]any{\n+\t\t\t\t\"apiVersion\": \"v1\",\n+\t\t\t\t\"kind\":       \"ConfigMap\",\n+\t\t\t\t\"metadata\": map[string]any{\n+\t\t\t\t\t\"name\":      \"argocd-cmd-params-cm\",\n+\t\t\t\t\t\"namespace\": \"default\",\n+\t\t\t\t},\n+\t\t\t\t\"data\": map[string]any{\n+\t\t\t\t\t\"application.namespaces\":    \"argocd,dev\",\n+\t\t\t\t\t\"applicationset.namespaces\": \"argocd,stage\",\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tctx := t.Context()\n+\t\t\tgvr := schema.GroupVersionResource{\n+\t\t\t\tGroup:    \"\",\n+\t\t\t\tVersion:  \"v1\",\n+\t\t\t\tResource: \"configmaps\",\n+\t\t\t}\n+\n+\t\t\tdynamicClient := dynamicfake.NewSimpleDynamicClient(runtime.NewScheme(), configMap)\n+\t\t\tconfigMapResource := dynamicClient.Resource(gvr).Namespace(\"default\")\n+\n+\t\t\tif len(tt.applicationNamespaces) == 0 || len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\tdefaultNs := getAdditionalNamespaces(ctx, configMapResource)\n+\n+\t\t\t\tif len(tt.applicationNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationNamespaces = defaultNs.applicationNamespaces\n+\t\t\t\t}\n+\n+\t\t\t\tif len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationsetNamespaces = defaultNs.applicationsetNamespaces\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// check if the object is a configMap or not\n+\t\t\tif isArgoCDConfigMap(bakObj.GetName()) {\n+\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"\", Kind: \"ConfigMap\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t}\n+\t\t\t// check if the object is a secret or not\n+\t\t\tif isArgoCDSecret(*bakObj) {\n+\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"\", Kind: \"Secret\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t}\n+\t\t\t// check if the object is an application or not\n+\t\t\tif bakObj.GetKind() == \"Application\" {\n+\t\t\t\tif security.IsNamespaceEnabled(bakObj.GetNamespace(), \"argocd\", tt.applicationNamespaces) {\n+\t\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"Application\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t// check if the object is a project or not\n+\t\t\tif bakObj.GetKind() == \"AppProject\" {\n+\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"AppProject\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t}\n+\t\t\t// check if the object is an applicationSet or not\n+\t\t\tif bakObj.GetKind() == \"ApplicationSet\" {\n+\t\t\t\tif security.IsNamespaceEnabled(bakObj.GetNamespace(), \"argocd\", tt.applicationsetNamespaces) {\n+\t\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"ApplicationSet\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tgvk := bakObj.GroupVersionKind()\n+\t\t\tif bakObj.GetNamespace() == \"\" {\n+\t\t\t\tbakObj.SetNamespace(\"argocd\")\n+\t\t\t}\n+\t\t\tkey := kube.ResourceKey{Group: gvk.Group, Kind: gvk.Kind, Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}\n+\t\t\tliveObject, exists := pruneObjects[key]\n+\t\t\tdelete(pruneObjects, key)\n+\n+\t\t\tvar updatedLive *unstructured.Unstructured\n+\t\t\tvar dynClient dynamic.ResourceInterface\n+\n+\t\t\tif bakObj.GetKind() == \"Secret\" {\n+\t\t\t\tdynClient = dynamicClient.Resource(secretResource).Namespace(bakObj.GetNamespace())\n+\t\t\t}\n+\n+\t\t\tif slices.Contains(tt.applicationNamespaces, bakObj.GetNamespace()) || slices.Contains(tt.applicationsetNamespaces, bakObj.GetNamespace()) {\n+\t\t\t\tif !isSkipLabelMatches(bakObj, tt.skipResourcesWithLabel) || !isSkipLabelMatches(liveObj, tt.skipResourcesWithLabel) {\n+\t\t\t\t\tif tt.prune {\n+\t\t\t\t\t\terr := dynClient.Delete(ctx, key.Name, metav1.DeleteOptions{})\n+\t\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tupdatedLive = updateLive(bakObj, liveObj, tt.stopOperation)\n+\n+\t\t\t\t\t\tif tt.overrideOnConflict {\n+\t\t\t\t\t\t\tswitch {\n+\t\t\t\t\t\t\tcase !exists:\n+\t\t\t\t\t\t\t\t_, err := dynClient.Create(ctx, bakObj, metav1.CreateOptions{})\n+\t\t\t\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t\t\t\tdefault:\n+\t\t\t\t\t\t\t\tnewLive := updateLive(bakObj, &liveObject, tt.stopOperation)\n+\t\t\t\t\t\t\t\t_, err := dynClient.Update(ctx, newLive, metav1.UpdateOptions{})\n+\t\t\t\t\t\t\t\tif apierrors.IsConflict(err) && tt.overrideOnConflict {\n+\t\t\t\t\t\t\t\t\terr = retry.RetryOnConflict(retry.DefaultRetry, func() error {\n+\t\t\t\t\t\t\t\t\t\tliveObj, _ := dynClient.Get(ctx, newLive.GetName(), metav1.GetOptions{})\n+\n+\t\t\t\t\t\t\t\t\t\tnewLive.SetResourceVersion(liveObj.GetResourceVersion())\n+\t\t\t\t\t\t\t\t\t\t_, err = dynClient.Update(ctx, newLive, metav1.UpdateOptions{})\n+\t\t\t\t\t\t\t\t\t\treturn err\n+\t\t\t\t\t\t\t\t\t})\n+\n+\t\t\t\t\t\t\t\t\trequire.NoError(t, err)\n+\t\t\t\t\t\t\t\t}",
        "comment_created_at": "2025-05-13T16:07:08+00:00",
        "comment_author": "nitishfy",
        "comment_body": "```suggestion\r\n\t\t\tctx := t.Context()\r\n\t\t\tgvr := schema.GroupVersionResource{\r\n\t\t\t\tGroup:    \"\",\r\n\t\t\t\tVersion:  \"v1\",\r\n\t\t\t\tResource: \"configmaps\",\r\n\t\t\t}\r\n\r\n\t\t\tdynamicClient := dynamicfake.NewSimpleDynamicClient(runtime.NewScheme(), configMap)\r\n\t\t\tconfigMapResource := dynamicClient.Resource(gvr).Namespace(\"default\")\r\n\r\n\t\t\tif len(tt.applicationNamespaces) == 0 || len(tt.applicationsetNamespaces) == 0 {\r\n\t\t\t\tdefaultNs := getAdditionalNamespaces(ctx, configMapResource)\r\n\r\n\t\t\t\tif len(tt.applicationNamespaces) == 0 {\r\n\t\t\t\t\ttt.applicationNamespaces = defaultNs.applicationNamespaces\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif len(tt.applicationsetNamespaces) == 0 {\r\n\t\t\t\t\ttt.applicationsetNamespaces = defaultNs.applicationsetNamespaces\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// check if the object is a configMap or not\r\n\t\t\tif isArgoCDConfigMap(bakObj.GetName()) {\r\n\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"\", Kind: \"ConfigMap\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\r\n\t\t\t}\r\n\t\t\t// check if the object is a secret or not\r\n\t\t\tif isArgoCDSecret(*bakObj) {\r\n\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"\", Kind: \"Secret\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\r\n\t\t\t}\r\n\t\t\t// check if the object is an application or not\r\n\t\t\tif bakObj.GetKind() == \"Application\" {\r\n\t\t\t\tif security.IsNamespaceEnabled(bakObj.GetNamespace(), \"argocd\", tt.applicationNamespaces) {\r\n\t\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"Application\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// check if the object is a project or not\r\n\t\t\tif bakObj.GetKind() == \"AppProject\" {\r\n\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"AppProject\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\r\n\t\t\t}\r\n\t\t\t// check if the object is an applicationSet or not\r\n\t\t\tif bakObj.GetKind() == \"ApplicationSet\" {\r\n\t\t\t\tif security.IsNamespaceEnabled(bakObj.GetNamespace(), \"argocd\", tt.applicationsetNamespaces) {\r\n\t\t\t\t\tpruneObjects[kube.ResourceKey{Group: \"argoproj.io\", Kind: \"ApplicationSet\", Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}] = *bakObj\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tgvk := bakObj.GroupVersionKind()\r\n\t\t\tif bakObj.GetNamespace() == \"\" {\r\n\t\t\t\tbakObj.SetNamespace(\"argocd\")\r\n\t\t\t}\r\n\t\t\tkey := kube.ResourceKey{Group: gvk.Group, Kind: gvk.Kind, Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}\r\n\t\t\tliveObject, exists := pruneObjects[key]\r\n\t\t\tdelete(pruneObjects, key)\r\n\r\n\t\t\tvar updatedLive *unstructured.Unstructured\r\n\t\t\tvar dynClient dynamic.ResourceInterface\r\n\r\n\t\t\tif bakObj.GetKind() == \"Secret\" {\r\n\t\t\t\tdynClient = dynamicClient.Resource(secretResource).Namespace(bakObj.GetNamespace())\r\n\t\t\t}\r\n\r\n\t\t\tif slices.Contains(tt.applicationNamespaces, bakObj.GetNamespace()) || slices.Contains(tt.applicationsetNamespaces, bakObj.GetNamespace()) {\r\n\t\t\t\tif !isSkipLabelMatches(bakObj, tt.skipResourcesWithLabel) || !isSkipLabelMatches(liveObj, tt.skipResourcesWithLabel) {\r\n\t\t\t\t\tif tt.prune {\r\n\t\t\t\t\t\terr := dynClient.Delete(ctx, key.Name, metav1.DeleteOptions{})\r\n\t\t\t\t\t\trequire.NoError(t, err)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tupdatedLive = updateLive(bakObj, liveObj, tt.stopOperation)\r\n\r\n\t\t\t\t\t\tif tt.overrideOnConflict {\r\n\t\t\t\t\t\t\tswitch {\r\n\t\t\t\t\t\t\tcase !exists:\r\n\t\t\t\t\t\t\t\t_, err := dynClient.Create(ctx, bakObj, metav1.CreateOptions{})\r\n\t\t\t\t\t\t\t\trequire.NoError(t, err)\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tnewLive := updateLive(bakObj, &liveObject, tt.stopOperation)\r\n\t\t\t\t\t\t\t\t_, err := dynClient.Update(ctx, newLive, metav1.UpdateOptions{})\r\n\t\t\t\t\t\t\t\tif apierrors.IsConflict(err) && tt.overrideOnConflict {\r\n\t\t\t\t\t\t\t\t\terr = retry.RetryOnConflict(retry.DefaultRetry, func() error {\r\n\t\t\t\t\t\t\t\t\t\tliveObj, _ := dynClient.Get(ctx, newLive.GetName(), metav1.GetOptions{})\r\n\r\n\t\t\t\t\t\t\t\t\t\tnewLive.SetResourceVersion(liveObj.GetResourceVersion())\r\n\t\t\t\t\t\t\t\t\t\t_, err = dynClient.Update(ctx, newLive, metav1.UpdateOptions{})\r\n\t\t\t\t\t\t\t\t\t\treturn err\r\n\t\t\t\t\t\t\t\t\t})\r\n\r\n\t\t\t\t\t\t\t\t\trequire.NoError(t, err)\r\n\t\t\t\t\t\t\t\t}\r\n```\r\n\r\nI read through this. A lot of this is logic that has been copied from the `backup.go` file. Instead of doing that, I'd suggest refactoring the existing codebase for the `backup.go`, create small functions and test those functions as a part of unit test. This is the correct way to write unit test for this. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175473764",
    "pr_number": 22780,
    "pr_file": "cmd/argocd/commands/admin/backup_test.go",
    "created_at": "2025-06-30T16:28:16+00:00",
    "commented_code": "}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2175473764",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22780,
        "pr_file": "cmd/argocd/commands/admin/backup_test.go",
        "discussion_id": "2175473764",
        "commented_code": "@@ -362,6 +386,440 @@ status: {}\n \t}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)",
        "comment_created_at": "2025-06-30T16:28:16+00:00",
        "comment_author": "agaudreault",
        "comment_body": "extract all the test setup code to a function, the method should be generic enough so that it accepts a liveObj and returns only the client. You can then provide the faeClient to the \"import\" method (needs refactoring) and validate the result by doing a Get on the liveObj after the import.",
        "pr_file_module": null
      },
      {
        "comment_id": "2202425765",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22780,
        "pr_file": "cmd/argocd/commands/admin/backup_test.go",
        "discussion_id": "2175473764",
        "commented_code": "@@ -362,6 +386,440 @@ status: {}\n \t}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)",
        "comment_created_at": "2025-07-12T08:00:44+00:00",
        "comment_author": "yaten2302",
        "comment_body": "@agaudreault , I didn't get this completely, could you kindly elaborate a bit more on this please?\r\n\r\nLike, currently, I've created the `decodeYAMLToUnstructured()` func, which accepts the YAML of backup and the live object and decodes them to Unstructured format.\r\n\r\nNow, as you said that, it should accept the `liveObj` and return only the client. I wasn't able to get this exactly?",
        "pr_file_module": null
      },
      {
        "comment_id": "2217701848",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22780,
        "pr_file": "cmd/argocd/commands/admin/backup_test.go",
        "discussion_id": "2175473764",
        "commented_code": "@@ -362,6 +386,440 @@ status: {}\n \t}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)",
        "comment_created_at": "2025-07-20T08:41:15+00:00",
        "comment_author": "yaten2302",
        "comment_body": "Hi @agaudreault , wanted to confirm that if I've understood this correctly, then I should extract this [import test setup](https://github.com/argoproj/argo-cd/pull/22780/files#diff-b2b9976573c508d94790348115fc627f48fabac7e518863624e40ab55180a86eR679-R769) code to a new func let's say - `setupImportTest()`. And then I should call this func to the `Test_importResources()`?\r\nHave I understood this correctly?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175480986",
    "pr_number": 22780,
    "pr_file": "cmd/argocd/commands/admin/backup_test.go",
    "created_at": "2025-06-30T16:32:44+00:00",
    "commented_code": "}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)\n+\t\t\tliveObj := decodeYAMLToUnstructured(t, tt.args.live)\n+\n+\t\t\tvar (\n+\t\t\t\tconfigMapGVR = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"configmaps\"}\n+\t\t\t\tsecretGVR    = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"secrets\"}\n+\t\t\t\tappGVR       = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applications\"}\n+\t\t\t\tprojGVR      = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"appprojects\"}\n+\t\t\t\tappSetGVR    = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applicationsets\"}\n+\t\t\t)\n+\n+\t\t\tcm := newConfigmapObject()\n+\t\t\tsecret := newSecretsObject()\n+\t\t\tapplication := newApplication(\"argocd\")\n+\t\t\tproject := newAppProject()\n+\t\t\tapplicationSet := newApplicationSet(\"argocd\")\n+\n+\t\t\tscheme := runtime.NewScheme()\n+\n+\t\t\tlistKinds := map[schema.GroupVersionResource]string{\n+\t\t\t\tconfigMapGVR: \"ConfigMapList\",\n+\t\t\t\tsecretGVR:    \"SecretList\",\n+\t\t\t\tappGVR:       \"ApplicationList\",\n+\t\t\t\tprojGVR:      \"AppProjectList\",\n+\t\t\t\tappSetGVR:    \"ApplicationSetList\",\n+\t\t\t}\n+\n+\t\t\tfakeClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(scheme, listKinds, cm, secret, application, project, applicationSet)\n+\t\t\tacdClientsets := &argoCDClientsets{\n+\t\t\t\tconfigMaps:      fakeClient.Resource(configMapGVR).Namespace(\"argocd\"),\n+\t\t\t\tsecrets:         fakeClient.Resource(secretGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplications:    fakeClient.Resource(appGVR).Namespace(\"argocd\"),\n+\t\t\t\tprojects:        fakeClient.Resource(projGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplicationSets: fakeClient.Resource(appSetGVR).Namespace(\"argocd\"),\n+\t\t\t}\n+\n+\t\t\tconfigMap := &unstructured.Unstructured{}\n+\t\t\tconfigMap.SetUnstructuredContent(map[string]any{\n+\t\t\t\t\"apiVersion\": \"v1\",\n+\t\t\t\t\"kind\":       \"ConfigMap\",\n+\t\t\t\t\"metadata\": map[string]any{\n+\t\t\t\t\t\"name\":      \"argocd-cmd-params-cm\",\n+\t\t\t\t\t\"namespace\": \"default\",\n+\t\t\t\t},\n+\t\t\t\t\"data\": map[string]any{\n+\t\t\t\t\t\"application.namespaces\":    \"argocd,dev\",\n+\t\t\t\t\t\"applicationset.namespaces\": \"argocd,stage\",\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tctx := t.Context()\n+\t\t\tgvr := schema.GroupVersionResource{\n+\t\t\t\tGroup:    \"\",\n+\t\t\t\tVersion:  \"v1\",\n+\t\t\t\tResource: \"configmaps\",\n+\t\t\t}\n+\n+\t\t\tdynamicClient := dynamicfake.NewSimpleDynamicClient(scheme, configMap)\n+\t\t\tconfigMapResource := dynamicClient.Resource(gvr).Namespace(\"default\")\n+\n+\t\t\tif len(tt.applicationNamespaces) == 0 || len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\tdefaultNs := getAdditionalNamespaces(ctx, configMapResource)\n+\n+\t\t\t\tif len(tt.applicationNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationNamespaces = defaultNs.applicationNamespaces\n+\t\t\t\t}\n+\n+\t\t\t\tif len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationsetNamespaces = defaultNs.applicationsetNamespaces\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpruneObjects, err := createPruneObject(ctx, acdClientsets, tt.applicationNamespaces, namespace, tt.applicationsetNamespaces)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tgvk := bakObj.GroupVersionKind()\n+\t\t\tif bakObj.GetNamespace() == \"\" {\n+\t\t\t\tbakObj.SetNamespace(\"argocd\")\n+\t\t\t}\n+\t\t\tkey := kube.ResourceKey{Group: gvk.Group, Kind: gvk.Kind, Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}\n+\t\t\tliveObject, exists := pruneObjects[key]\n+\t\t\tdelete(pruneObjects, key)\n+\n+\t\t\tvar updatedLive *unstructured.Unstructured\n+\t\t\tdynClient := setDynamicClient(&dynamic.DynamicClient{}, bakObj, \"argocd\", tt.applicationNamespaces, tt.applicationsetNamespaces)\n+\n+\t\t\tif bakObj.GetKind() == \"Secret\" {\n+\t\t\t\tdynClient = dynamicClient.Resource(secretResource).Namespace(bakObj.GetNamespace())\n+\t\t\t}\n+\n+\t\t\tif slices.Contains(tt.applicationNamespaces, bakObj.GetNamespace()) || slices.Contains(tt.applicationsetNamespaces, bakObj.GetNamespace()) {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2175480986",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22780,
        "pr_file": "cmd/argocd/commands/admin/backup_test.go",
        "discussion_id": "2175480986",
        "commented_code": "@@ -362,6 +386,440 @@ status: {}\n \t}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)\n+\t\t\tliveObj := decodeYAMLToUnstructured(t, tt.args.live)\n+\n+\t\t\tvar (\n+\t\t\t\tconfigMapGVR = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"configmaps\"}\n+\t\t\t\tsecretGVR    = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"secrets\"}\n+\t\t\t\tappGVR       = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applications\"}\n+\t\t\t\tprojGVR      = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"appprojects\"}\n+\t\t\t\tappSetGVR    = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applicationsets\"}\n+\t\t\t)\n+\n+\t\t\tcm := newConfigmapObject()\n+\t\t\tsecret := newSecretsObject()\n+\t\t\tapplication := newApplication(\"argocd\")\n+\t\t\tproject := newAppProject()\n+\t\t\tapplicationSet := newApplicationSet(\"argocd\")\n+\n+\t\t\tscheme := runtime.NewScheme()\n+\n+\t\t\tlistKinds := map[schema.GroupVersionResource]string{\n+\t\t\t\tconfigMapGVR: \"ConfigMapList\",\n+\t\t\t\tsecretGVR:    \"SecretList\",\n+\t\t\t\tappGVR:       \"ApplicationList\",\n+\t\t\t\tprojGVR:      \"AppProjectList\",\n+\t\t\t\tappSetGVR:    \"ApplicationSetList\",\n+\t\t\t}\n+\n+\t\t\tfakeClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(scheme, listKinds, cm, secret, application, project, applicationSet)\n+\t\t\tacdClientsets := &argoCDClientsets{\n+\t\t\t\tconfigMaps:      fakeClient.Resource(configMapGVR).Namespace(\"argocd\"),\n+\t\t\t\tsecrets:         fakeClient.Resource(secretGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplications:    fakeClient.Resource(appGVR).Namespace(\"argocd\"),\n+\t\t\t\tprojects:        fakeClient.Resource(projGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplicationSets: fakeClient.Resource(appSetGVR).Namespace(\"argocd\"),\n+\t\t\t}\n+\n+\t\t\tconfigMap := &unstructured.Unstructured{}\n+\t\t\tconfigMap.SetUnstructuredContent(map[string]any{\n+\t\t\t\t\"apiVersion\": \"v1\",\n+\t\t\t\t\"kind\":       \"ConfigMap\",\n+\t\t\t\t\"metadata\": map[string]any{\n+\t\t\t\t\t\"name\":      \"argocd-cmd-params-cm\",\n+\t\t\t\t\t\"namespace\": \"default\",\n+\t\t\t\t},\n+\t\t\t\t\"data\": map[string]any{\n+\t\t\t\t\t\"application.namespaces\":    \"argocd,dev\",\n+\t\t\t\t\t\"applicationset.namespaces\": \"argocd,stage\",\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tctx := t.Context()\n+\t\t\tgvr := schema.GroupVersionResource{\n+\t\t\t\tGroup:    \"\",\n+\t\t\t\tVersion:  \"v1\",\n+\t\t\t\tResource: \"configmaps\",\n+\t\t\t}\n+\n+\t\t\tdynamicClient := dynamicfake.NewSimpleDynamicClient(scheme, configMap)\n+\t\t\tconfigMapResource := dynamicClient.Resource(gvr).Namespace(\"default\")\n+\n+\t\t\tif len(tt.applicationNamespaces) == 0 || len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\tdefaultNs := getAdditionalNamespaces(ctx, configMapResource)\n+\n+\t\t\t\tif len(tt.applicationNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationNamespaces = defaultNs.applicationNamespaces\n+\t\t\t\t}\n+\n+\t\t\t\tif len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationsetNamespaces = defaultNs.applicationsetNamespaces\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpruneObjects, err := createPruneObject(ctx, acdClientsets, tt.applicationNamespaces, namespace, tt.applicationsetNamespaces)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tgvk := bakObj.GroupVersionKind()\n+\t\t\tif bakObj.GetNamespace() == \"\" {\n+\t\t\t\tbakObj.SetNamespace(\"argocd\")\n+\t\t\t}\n+\t\t\tkey := kube.ResourceKey{Group: gvk.Group, Kind: gvk.Kind, Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}\n+\t\t\tliveObject, exists := pruneObjects[key]\n+\t\t\tdelete(pruneObjects, key)\n+\n+\t\t\tvar updatedLive *unstructured.Unstructured\n+\t\t\tdynClient := setDynamicClient(&dynamic.DynamicClient{}, bakObj, \"argocd\", tt.applicationNamespaces, tt.applicationsetNamespaces)\n+\n+\t\t\tif bakObj.GetKind() == \"Secret\" {\n+\t\t\t\tdynClient = dynamicClient.Resource(secretResource).Namespace(bakObj.GetNamespace())\n+\t\t\t}\n+\n+\t\t\tif slices.Contains(tt.applicationNamespaces, bakObj.GetNamespace()) || slices.Contains(tt.applicationsetNamespaces, bakObj.GetNamespace()) {",
        "comment_created_at": "2025-06-30T16:32:44+00:00",
        "comment_author": "agaudreault",
        "comment_body": "This test seems to re-implement the logic of the run function.\r\n\r\nThe unit test should be able to test a unit of code for which it can mock its dependencies. In this case, we want to test the NewImportCommand `Run` function. However, it is quite complex to provide a \"mock\" of the Kubernetes dependency this way. Instead, extract a function that you can test, that will receive a fake Kubernetes client and the  command arguments. This way, you can unit test that code.\r\n\r\nExample: `func (opts *importOpts) executeImport(client *dynamic.DynamicClient)`",
        "pr_file_module": null
      },
      {
        "comment_id": "2187126533",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22780,
        "pr_file": "cmd/argocd/commands/admin/backup_test.go",
        "discussion_id": "2175480986",
        "commented_code": "@@ -362,6 +386,440 @@ status: {}\n \t}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)\n+\t\t\tliveObj := decodeYAMLToUnstructured(t, tt.args.live)\n+\n+\t\t\tvar (\n+\t\t\t\tconfigMapGVR = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"configmaps\"}\n+\t\t\t\tsecretGVR    = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"secrets\"}\n+\t\t\t\tappGVR       = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applications\"}\n+\t\t\t\tprojGVR      = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"appprojects\"}\n+\t\t\t\tappSetGVR    = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applicationsets\"}\n+\t\t\t)\n+\n+\t\t\tcm := newConfigmapObject()\n+\t\t\tsecret := newSecretsObject()\n+\t\t\tapplication := newApplication(\"argocd\")\n+\t\t\tproject := newAppProject()\n+\t\t\tapplicationSet := newApplicationSet(\"argocd\")\n+\n+\t\t\tscheme := runtime.NewScheme()\n+\n+\t\t\tlistKinds := map[schema.GroupVersionResource]string{\n+\t\t\t\tconfigMapGVR: \"ConfigMapList\",\n+\t\t\t\tsecretGVR:    \"SecretList\",\n+\t\t\t\tappGVR:       \"ApplicationList\",\n+\t\t\t\tprojGVR:      \"AppProjectList\",\n+\t\t\t\tappSetGVR:    \"ApplicationSetList\",\n+\t\t\t}\n+\n+\t\t\tfakeClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(scheme, listKinds, cm, secret, application, project, applicationSet)\n+\t\t\tacdClientsets := &argoCDClientsets{\n+\t\t\t\tconfigMaps:      fakeClient.Resource(configMapGVR).Namespace(\"argocd\"),\n+\t\t\t\tsecrets:         fakeClient.Resource(secretGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplications:    fakeClient.Resource(appGVR).Namespace(\"argocd\"),\n+\t\t\t\tprojects:        fakeClient.Resource(projGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplicationSets: fakeClient.Resource(appSetGVR).Namespace(\"argocd\"),\n+\t\t\t}\n+\n+\t\t\tconfigMap := &unstructured.Unstructured{}\n+\t\t\tconfigMap.SetUnstructuredContent(map[string]any{\n+\t\t\t\t\"apiVersion\": \"v1\",\n+\t\t\t\t\"kind\":       \"ConfigMap\",\n+\t\t\t\t\"metadata\": map[string]any{\n+\t\t\t\t\t\"name\":      \"argocd-cmd-params-cm\",\n+\t\t\t\t\t\"namespace\": \"default\",\n+\t\t\t\t},\n+\t\t\t\t\"data\": map[string]any{\n+\t\t\t\t\t\"application.namespaces\":    \"argocd,dev\",\n+\t\t\t\t\t\"applicationset.namespaces\": \"argocd,stage\",\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tctx := t.Context()\n+\t\t\tgvr := schema.GroupVersionResource{\n+\t\t\t\tGroup:    \"\",\n+\t\t\t\tVersion:  \"v1\",\n+\t\t\t\tResource: \"configmaps\",\n+\t\t\t}\n+\n+\t\t\tdynamicClient := dynamicfake.NewSimpleDynamicClient(scheme, configMap)\n+\t\t\tconfigMapResource := dynamicClient.Resource(gvr).Namespace(\"default\")\n+\n+\t\t\tif len(tt.applicationNamespaces) == 0 || len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\tdefaultNs := getAdditionalNamespaces(ctx, configMapResource)\n+\n+\t\t\t\tif len(tt.applicationNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationNamespaces = defaultNs.applicationNamespaces\n+\t\t\t\t}\n+\n+\t\t\t\tif len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationsetNamespaces = defaultNs.applicationsetNamespaces\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpruneObjects, err := createPruneObject(ctx, acdClientsets, tt.applicationNamespaces, namespace, tt.applicationsetNamespaces)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tgvk := bakObj.GroupVersionKind()\n+\t\t\tif bakObj.GetNamespace() == \"\" {\n+\t\t\t\tbakObj.SetNamespace(\"argocd\")\n+\t\t\t}\n+\t\t\tkey := kube.ResourceKey{Group: gvk.Group, Kind: gvk.Kind, Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}\n+\t\t\tliveObject, exists := pruneObjects[key]\n+\t\t\tdelete(pruneObjects, key)\n+\n+\t\t\tvar updatedLive *unstructured.Unstructured\n+\t\t\tdynClient := setDynamicClient(&dynamic.DynamicClient{}, bakObj, \"argocd\", tt.applicationNamespaces, tt.applicationsetNamespaces)\n+\n+\t\t\tif bakObj.GetKind() == \"Secret\" {\n+\t\t\t\tdynClient = dynamicClient.Resource(secretResource).Namespace(bakObj.GetNamespace())\n+\t\t\t}\n+\n+\t\t\tif slices.Contains(tt.applicationNamespaces, bakObj.GetNamespace()) || slices.Contains(tt.applicationsetNamespaces, bakObj.GetNamespace()) {",
        "comment_created_at": "2025-07-05T11:31:14+00:00",
        "comment_author": "nitishfy",
        "comment_body": "+1",
        "pr_file_module": null
      },
      {
        "comment_id": "2202424548",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22780,
        "pr_file": "cmd/argocd/commands/admin/backup_test.go",
        "discussion_id": "2175480986",
        "commented_code": "@@ -362,6 +386,440 @@ status: {}\n \t}\n }\n \n+func Test_importResources(t *testing.T) {\n+\ttype args struct {\n+\t\tbak  string\n+\t\tlive string\n+\t}\n+\n+\ttests := []struct {\n+\t\tname                     string\n+\t\targs                     args\n+\t\tapplicationNamespaces    []string\n+\t\tapplicationsetNamespaces []string\n+\t\tprune                    bool\n+\t\tskipResourcesWithLabel   string\n+\t\tstopOperation            bool\n+\t\toverrideOnConflict       bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"Update live object when backup does not match skip label\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: dev\n+  annotations:\n+    argocd.argoproj.io/instance: test-instance\n+  finalizers:\n+    - test.finalizer.io\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+  labels:\n+    env: prod\n+  annotations:\n+    argocd.argoproj.io/instance: old-instance\n+  finalizers: []\n+data:\n+  foo: old\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t\tskipResourcesWithLabel:   \"env=dev\",\n+\t\t\tstopOperation:            false,\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live object when data differs from backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-configmap\n+  namespace: namespace\n+data:\n+  foo: old\t\t\t\t\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for Application\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/updated.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  source:\n+    repoURL: https://github.com/example/old.git\n+  destination:\n+    namespace: default\n+    server: https://kubernetes.default.svc\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Update live if spec differs from backup for ApplicationSet\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: dev\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ApplicationSet\n+metadata:\n+  name: my-appset\n+  namespace: argocd\n+spec:\n+  generators:\n+    - list:\n+        elements:\n+          - clusters: prod\n+  template:\n+    metadata:\n+      name: '{{appName}}'\n+    spec: {}\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{},\n+\t\t\tapplicationsetNamespaces: []string{\"dev\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Should not update live object if it matches the backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argo-cd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argo-*\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argo-*\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Create resource if it's missing from live\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespace: argocd\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: my-cm\n+  namespaces: argocd\n+  labels:\n+    env: dev\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\", \"dev\"},\n+\t\t\tapplicationsetNamespaces: []string{\"argocd\", \"prod\"},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Prune live resources when not present in backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: ConfigMap\n+metadata:\n+  name: configmap-to-keep\n+  namespace: default\n+  labels:\n+    env: dev\n+data:\n+  foo: bar\n+`,\n+\t\t\t},\n+\t\t\tprune: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Clear the operation field when stopOperation is enabled\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    path: .\n+    targetRevision: HEAD\n+  destination:\n+    server: https://kubernetes.default.svc\n+    namespace: default\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Application\n+metadata:\n+  name: app\n+  namespace: argocd\n+spec:\n+  project: default\n+  source:\n+    repoURL: https://github.com/example/repo.git\n+    namespace: default\n+status:\n+  operationState:\n+    phase: Running\n+    operation:\n+      sync:\n+        revision: HEAD\n+`,\n+\t\t\t},\n+\t\t\tstopOperation: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"Override live object on conflict with backup\",\n+\t\t\targs: args{\n+\t\t\t\tbak: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: dev\n+type: Opaque\n+data:\n+  username: bar\n+  password: abc\n+`,\n+\t\t\t\tlive: `apiVersion: v1\n+kind: Secret\n+metadata:\n+  name: my-secret\n+  namespace: argocd\n+  labels:\n+    env: prod\n+type: Opaque\n+data:\n+  username: old\n+  password: old-pwd\n+`,\n+\t\t\t},\n+\t\t\tapplicationNamespaces:    []string{\"argocd\"},\n+\t\t\tapplicationsetNamespaces: []string{},\n+\t\t\toverrideOnConflict:       true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tbakObj := decodeYAMLToUnstructured(t, tt.args.bak)\n+\t\t\tliveObj := decodeYAMLToUnstructured(t, tt.args.live)\n+\n+\t\t\tvar (\n+\t\t\t\tconfigMapGVR = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"configmaps\"}\n+\t\t\t\tsecretGVR    = schema.GroupVersionResource{Group: \"\", Version: \"v1\", Resource: \"secrets\"}\n+\t\t\t\tappGVR       = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applications\"}\n+\t\t\t\tprojGVR      = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"appprojects\"}\n+\t\t\t\tappSetGVR    = schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"applicationsets\"}\n+\t\t\t)\n+\n+\t\t\tcm := newConfigmapObject()\n+\t\t\tsecret := newSecretsObject()\n+\t\t\tapplication := newApplication(\"argocd\")\n+\t\t\tproject := newAppProject()\n+\t\t\tapplicationSet := newApplicationSet(\"argocd\")\n+\n+\t\t\tscheme := runtime.NewScheme()\n+\n+\t\t\tlistKinds := map[schema.GroupVersionResource]string{\n+\t\t\t\tconfigMapGVR: \"ConfigMapList\",\n+\t\t\t\tsecretGVR:    \"SecretList\",\n+\t\t\t\tappGVR:       \"ApplicationList\",\n+\t\t\t\tprojGVR:      \"AppProjectList\",\n+\t\t\t\tappSetGVR:    \"ApplicationSetList\",\n+\t\t\t}\n+\n+\t\t\tfakeClient := dynamicfake.NewSimpleDynamicClientWithCustomListKinds(scheme, listKinds, cm, secret, application, project, applicationSet)\n+\t\t\tacdClientsets := &argoCDClientsets{\n+\t\t\t\tconfigMaps:      fakeClient.Resource(configMapGVR).Namespace(\"argocd\"),\n+\t\t\t\tsecrets:         fakeClient.Resource(secretGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplications:    fakeClient.Resource(appGVR).Namespace(\"argocd\"),\n+\t\t\t\tprojects:        fakeClient.Resource(projGVR).Namespace(\"argocd\"),\n+\t\t\t\tapplicationSets: fakeClient.Resource(appSetGVR).Namespace(\"argocd\"),\n+\t\t\t}\n+\n+\t\t\tconfigMap := &unstructured.Unstructured{}\n+\t\t\tconfigMap.SetUnstructuredContent(map[string]any{\n+\t\t\t\t\"apiVersion\": \"v1\",\n+\t\t\t\t\"kind\":       \"ConfigMap\",\n+\t\t\t\t\"metadata\": map[string]any{\n+\t\t\t\t\t\"name\":      \"argocd-cmd-params-cm\",\n+\t\t\t\t\t\"namespace\": \"default\",\n+\t\t\t\t},\n+\t\t\t\t\"data\": map[string]any{\n+\t\t\t\t\t\"application.namespaces\":    \"argocd,dev\",\n+\t\t\t\t\t\"applicationset.namespaces\": \"argocd,stage\",\n+\t\t\t\t},\n+\t\t\t})\n+\n+\t\t\tctx := t.Context()\n+\t\t\tgvr := schema.GroupVersionResource{\n+\t\t\t\tGroup:    \"\",\n+\t\t\t\tVersion:  \"v1\",\n+\t\t\t\tResource: \"configmaps\",\n+\t\t\t}\n+\n+\t\t\tdynamicClient := dynamicfake.NewSimpleDynamicClient(scheme, configMap)\n+\t\t\tconfigMapResource := dynamicClient.Resource(gvr).Namespace(\"default\")\n+\n+\t\t\tif len(tt.applicationNamespaces) == 0 || len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\tdefaultNs := getAdditionalNamespaces(ctx, configMapResource)\n+\n+\t\t\t\tif len(tt.applicationNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationNamespaces = defaultNs.applicationNamespaces\n+\t\t\t\t}\n+\n+\t\t\t\tif len(tt.applicationsetNamespaces) == 0 {\n+\t\t\t\t\ttt.applicationsetNamespaces = defaultNs.applicationsetNamespaces\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tpruneObjects, err := createPruneObject(ctx, acdClientsets, tt.applicationNamespaces, namespace, tt.applicationsetNamespaces)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tgvk := bakObj.GroupVersionKind()\n+\t\t\tif bakObj.GetNamespace() == \"\" {\n+\t\t\t\tbakObj.SetNamespace(\"argocd\")\n+\t\t\t}\n+\t\t\tkey := kube.ResourceKey{Group: gvk.Group, Kind: gvk.Kind, Name: bakObj.GetName(), Namespace: bakObj.GetNamespace()}\n+\t\t\tliveObject, exists := pruneObjects[key]\n+\t\t\tdelete(pruneObjects, key)\n+\n+\t\t\tvar updatedLive *unstructured.Unstructured\n+\t\t\tdynClient := setDynamicClient(&dynamic.DynamicClient{}, bakObj, \"argocd\", tt.applicationNamespaces, tt.applicationsetNamespaces)\n+\n+\t\t\tif bakObj.GetKind() == \"Secret\" {\n+\t\t\t\tdynClient = dynamicClient.Resource(secretResource).Namespace(bakObj.GetNamespace())\n+\t\t\t}\n+\n+\t\t\tif slices.Contains(tt.applicationNamespaces, bakObj.GetNamespace()) || slices.Contains(tt.applicationsetNamespaces, bakObj.GetNamespace()) {",
        "comment_created_at": "2025-07-12T07:57:10+00:00",
        "comment_author": "yaten2302",
        "comment_body": "Hi @nitishfy @agaudreault , if I've understood this correctly, then currently the behaviour is - \"I'm rewriting the Run() func in the backup_test.go and then testing it.\"\r\n\r\nExpected behaviour: \"The test should be such that, instead of rewriting the Run() func, I should pass the fake kubernetes client and the command args, like - `argocd admin import --dry-run import_file.txt`. Like, this command should be passed to the test and the fake kubernetes and then according to the command it'll generate the result\"?\r\n\r\nHave I understood this correctly?",
        "pr_file_module": null
      }
    ]
  }
]