[
  {
    "discussion_id": "2206828135",
    "pr_number": 23762,
    "pr_file": "controller/appcontroller.go",
    "created_at": "2025-07-15T08:29:35+00:00",
    "commented_code": "if app.Spec.SyncPolicy.Automated.Prune && !app.Spec.SyncPolicy.Automated.AllowEmpty {\n \t\tbAllNeedPrune := true\n \t\tfor _, r := range resources {\n-\t\t\tif !r.RequiresPruning {\n+\t\t\tif r.IsSelfReferencedObj && !r.RequiresPruning {\n \t\t\t\tbAllNeedPrune = false",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2206828135",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23762,
        "pr_file": "controller/appcontroller.go",
        "discussion_id": "2206828135",
        "commented_code": "@@ -2182,7 +2182,7 @@ func (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *\n \tif app.Spec.SyncPolicy.Automated.Prune && !app.Spec.SyncPolicy.Automated.AllowEmpty {\n \t\tbAllNeedPrune := true\n \t\tfor _, r := range resources {\n-\t\t\tif !r.RequiresPruning {\n+\t\t\tif r.IsSelfReferencedObj && !r.RequiresPruning {\n \t\t\t\tbAllNeedPrune = false",
        "comment_created_at": "2025-07-15T08:29:35+00:00",
        "comment_author": "nitishfy",
        "comment_body": "```suggestion\r\n\t\t\t\tbAllNeedPrune = false\r\n\t\t\t\tbreak\r\n```\r\nwe can simply break once we found out that a resource doesn't needs to be pruned.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2145325445",
    "pr_number": 23187,
    "pr_file": "pkg/apis/application/v1alpha1/applicationset_types.go",
    "created_at": "2025-06-13T15:21:33+00:00",
    "commented_code": "// If the applicationset has a pre-existing condition of a type that is not in the evaluated list,\n // it will be preserved. If the applicationset has a pre-existing condition of a type, status, reason that\n // is in the evaluated list, but not in the incoming conditions list, it will be removed.\n-func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, _ map[ApplicationSetConditionType]bool) {\n-\tapplicationSetConditions := make([]ApplicationSetCondition, 0)\n+func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, evaluatedTypes map[ApplicationSetConditionType]bool) {\n+\tnewConditions := make([]ApplicationSetCondition, 0)\n \tnow := metav1.Now()\n+\t// Keep the existing conditions when they are not evaluated\n+\tfor i := range status.Conditions {\n+\t\tcurrentCondition := status.Conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[currentCondition.Type]; !ok || !isEvaluated {\n+\t\t\tif currentCondition.LastTransitionTime == nil {\n+\t\t\t\tcurrentCondition.LastTransitionTime = &now\n+\t\t\t}\n+\t\t\tnewConditions = append(newConditions, currentCondition)\n+\t\t}\n+\t}\n+\n+\t// Update the evaluated conditions\n \tfor i := range conditions {\n \t\tcondition := conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[condition.Type]; !ok || !isEvaluated {\n+\t\t\t// ignore an new condition when it is not evaluated\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif condition.LastTransitionTime == nil {\n \t\t\tcondition.LastTransitionTime = &now\n \t\t}\n-\t\teci := findConditionIndex(status.Conditions, condition.Type)\n+\t\teci := condition.Type.findConditionIndex(status.Conditions)\n \t\tif eci >= 0 && status.Conditions[eci].Message == condition.Message && status.Conditions[eci].Reason == condition.Reason && status.Conditions[eci].Status == condition.Status {\n-\t\t\t// If we already have a condition of this type, status and reason, only update the timestamp if something\n-\t\t\t// has changed.\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, status.Conditions[eci])\n+\t\t\t// If we already have a condition of this type and nothing has changed, do not update it\n+\t\t\tnewConditions = append(newConditions, status.Conditions[eci])\n \t\t} else {\n-\t\t\t// Otherwise we use the new incoming condition with an updated timestamp:\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, condition)\n+\t\t\t// Otherwise we use the new incoming condition with updated information\n+\t\t\tnewConditions = append(newConditions, condition)\n \t\t}\n \t}\n-\tsort.Slice(applicationSetConditions, func(i, j int) bool {\n-\t\tleft := applicationSetConditions[i]\n-\t\tright := applicationSetConditions[j]\n+\n+\tsort.Slice(newConditions, func(i, j int) bool {\n+\t\tleft := newConditions[i]\n+\t\tright := newConditions[j]\n \t\treturn fmt.Sprintf(\"%s/%s/%s/%s/%v\", left.Type, left.Message, left.Status, left.Reason, left.LastTransitionTime) < fmt.Sprintf(\"%s/%s/%s/%s/%v\", right.Type, right.Message, right.Status, right.Reason, right.LastTransitionTime)",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2145325445",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23187,
        "pr_file": "pkg/apis/application/v1alpha1/applicationset_types.go",
        "discussion_id": "2145325445",
        "commented_code": "@@ -917,33 +931,50 @@ func (a *ApplicationSet) RefreshRequired() bool {\n // If the applicationset has a pre-existing condition of a type that is not in the evaluated list,\n // it will be preserved. If the applicationset has a pre-existing condition of a type, status, reason that\n // is in the evaluated list, but not in the incoming conditions list, it will be removed.\n-func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, _ map[ApplicationSetConditionType]bool) {\n-\tapplicationSetConditions := make([]ApplicationSetCondition, 0)\n+func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, evaluatedTypes map[ApplicationSetConditionType]bool) {\n+\tnewConditions := make([]ApplicationSetCondition, 0)\n \tnow := metav1.Now()\n+\t// Keep the existing conditions when they are not evaluated\n+\tfor i := range status.Conditions {\n+\t\tcurrentCondition := status.Conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[currentCondition.Type]; !ok || !isEvaluated {\n+\t\t\tif currentCondition.LastTransitionTime == nil {\n+\t\t\t\tcurrentCondition.LastTransitionTime = &now\n+\t\t\t}\n+\t\t\tnewConditions = append(newConditions, currentCondition)\n+\t\t}\n+\t}\n+\n+\t// Update the evaluated conditions\n \tfor i := range conditions {\n \t\tcondition := conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[condition.Type]; !ok || !isEvaluated {\n+\t\t\t// ignore an new condition when it is not evaluated\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif condition.LastTransitionTime == nil {\n \t\t\tcondition.LastTransitionTime = &now\n \t\t}\n-\t\teci := findConditionIndex(status.Conditions, condition.Type)\n+\t\teci := condition.Type.findConditionIndex(status.Conditions)\n \t\tif eci >= 0 && status.Conditions[eci].Message == condition.Message && status.Conditions[eci].Reason == condition.Reason && status.Conditions[eci].Status == condition.Status {\n-\t\t\t// If we already have a condition of this type, status and reason, only update the timestamp if something\n-\t\t\t// has changed.\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, status.Conditions[eci])\n+\t\t\t// If we already have a condition of this type and nothing has changed, do not update it\n+\t\t\tnewConditions = append(newConditions, status.Conditions[eci])\n \t\t} else {\n-\t\t\t// Otherwise we use the new incoming condition with an updated timestamp:\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, condition)\n+\t\t\t// Otherwise we use the new incoming condition with updated information\n+\t\t\tnewConditions = append(newConditions, condition)\n \t\t}\n \t}\n-\tsort.Slice(applicationSetConditions, func(i, j int) bool {\n-\t\tleft := applicationSetConditions[i]\n-\t\tright := applicationSetConditions[j]\n+\n+\tsort.Slice(newConditions, func(i, j int) bool {\n+\t\tleft := newConditions[i]\n+\t\tright := newConditions[j]\n \t\treturn fmt.Sprintf(\"%s/%s/%s/%s/%v\", left.Type, left.Message, left.Status, left.Reason, left.LastTransitionTime) < fmt.Sprintf(\"%s/%s/%s/%s/%v\", right.Type, right.Message, right.Status, right.Reason, right.LastTransitionTime)",
        "comment_created_at": "2025-06-13T15:21:33+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "While we're in here, I think we should fix this logic. Instead of constructing a single string and then comparing, we should compare the highest priority field, return if not equal, proceed to the next field if equal, etc.",
        "pr_file_module": null
      },
      {
        "comment_id": "2145329735",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23187,
        "pr_file": "pkg/apis/application/v1alpha1/applicationset_types.go",
        "discussion_id": "2145325445",
        "commented_code": "@@ -917,33 +931,50 @@ func (a *ApplicationSet) RefreshRequired() bool {\n // If the applicationset has a pre-existing condition of a type that is not in the evaluated list,\n // it will be preserved. If the applicationset has a pre-existing condition of a type, status, reason that\n // is in the evaluated list, but not in the incoming conditions list, it will be removed.\n-func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, _ map[ApplicationSetConditionType]bool) {\n-\tapplicationSetConditions := make([]ApplicationSetCondition, 0)\n+func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, evaluatedTypes map[ApplicationSetConditionType]bool) {\n+\tnewConditions := make([]ApplicationSetCondition, 0)\n \tnow := metav1.Now()\n+\t// Keep the existing conditions when they are not evaluated\n+\tfor i := range status.Conditions {\n+\t\tcurrentCondition := status.Conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[currentCondition.Type]; !ok || !isEvaluated {\n+\t\t\tif currentCondition.LastTransitionTime == nil {\n+\t\t\t\tcurrentCondition.LastTransitionTime = &now\n+\t\t\t}\n+\t\t\tnewConditions = append(newConditions, currentCondition)\n+\t\t}\n+\t}\n+\n+\t// Update the evaluated conditions\n \tfor i := range conditions {\n \t\tcondition := conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[condition.Type]; !ok || !isEvaluated {\n+\t\t\t// ignore an new condition when it is not evaluated\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif condition.LastTransitionTime == nil {\n \t\t\tcondition.LastTransitionTime = &now\n \t\t}\n-\t\teci := findConditionIndex(status.Conditions, condition.Type)\n+\t\teci := condition.Type.findConditionIndex(status.Conditions)\n \t\tif eci >= 0 && status.Conditions[eci].Message == condition.Message && status.Conditions[eci].Reason == condition.Reason && status.Conditions[eci].Status == condition.Status {\n-\t\t\t// If we already have a condition of this type, status and reason, only update the timestamp if something\n-\t\t\t// has changed.\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, status.Conditions[eci])\n+\t\t\t// If we already have a condition of this type and nothing has changed, do not update it\n+\t\t\tnewConditions = append(newConditions, status.Conditions[eci])\n \t\t} else {\n-\t\t\t// Otherwise we use the new incoming condition with an updated timestamp:\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, condition)\n+\t\t\t// Otherwise we use the new incoming condition with updated information\n+\t\t\tnewConditions = append(newConditions, condition)\n \t\t}\n \t}\n-\tsort.Slice(applicationSetConditions, func(i, j int) bool {\n-\t\tleft := applicationSetConditions[i]\n-\t\tright := applicationSetConditions[j]\n+\n+\tsort.Slice(newConditions, func(i, j int) bool {\n+\t\tleft := newConditions[i]\n+\t\tright := newConditions[j]\n \t\treturn fmt.Sprintf(\"%s/%s/%s/%s/%v\", left.Type, left.Message, left.Status, left.Reason, left.LastTransitionTime) < fmt.Sprintf(\"%s/%s/%s/%s/%v\", right.Type, right.Message, right.Status, right.Reason, right.LastTransitionTime)",
        "comment_created_at": "2025-06-13T15:22:59+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "Copilot came up with this:\r\n\r\n```\r\nsort.Slice(newConditions, func(i, j int) bool {\r\n\tleft := newConditions[i]\r\n\tright := newConditions[j]\r\n\r\n\tif left.Type != right.Type {\r\n\t\treturn left.Type < right.Type\r\n\t}\r\n\tif left.Message != right.Message {\r\n\t\treturn left.Message < right.Message\r\n\t}\r\n\tif left.Status != right.Status {\r\n\t\treturn left.Status < right.Status\r\n\t}\r\n\tif left.Reason != right.Reason {\r\n\t\treturn left.Reason < right.Reason\r\n\t}\r\n\treturn left.LastTransitionTime.Before(right.LastTransitionTime)\r\n})\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1946016600",
    "pr_number": 21542,
    "pr_file": "applicationset/controllers/applicationset_controller.go",
    "created_at": "2025-02-07T06:27:38+00:00",
    "commented_code": "appOutdated := false\n \t\tif progressiveSyncsRollingSyncStrategyEnabled(applicationSet) {\n-\t\t\tappOutdated = syncStatusString == \"OutOfSync\"\n+\t\t\tappOutdated = syncStatusString == string(argov1alpha1.SyncStatusCodeOutOfSync)\n+\t\t\tpruneEnabled := app.Spec.SyncPolicy != nil && app.Spec.SyncPolicy.Automated != nil && app.Spec.SyncPolicy.Automated.Prune\n+\t\t\tif !pruneEnabled && appOutdated {\n+\t\t\t\trequirePruneOnly := true\n+\t\t\t\tfor _, r := range app.Status.Resources {\n+\t\t\t\t\tif r.Status != argov1alpha1.SyncStatusCodeSynced && !r.RequiresPruning {\n+\t\t\t\t\t\trequirePruneOnly = false\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "1946016600",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 21542,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "1946016600",
        "commented_code": "@@ -1068,7 +1068,20 @@ func (r *ApplicationSetReconciler) updateApplicationSetApplicationStatus(ctx con\n \n \t\tappOutdated := false\n \t\tif progressiveSyncsRollingSyncStrategyEnabled(applicationSet) {\n-\t\t\tappOutdated = syncStatusString == \"OutOfSync\"\n+\t\t\tappOutdated = syncStatusString == string(argov1alpha1.SyncStatusCodeOutOfSync)\n+\t\t\tpruneEnabled := app.Spec.SyncPolicy != nil && app.Spec.SyncPolicy.Automated != nil && app.Spec.SyncPolicy.Automated.Prune\n+\t\t\tif !pruneEnabled && appOutdated {\n+\t\t\t\trequirePruneOnly := true\n+\t\t\t\tfor _, r := range app.Status.Resources {\n+\t\t\t\t\tif r.Status != argov1alpha1.SyncStatusCodeSynced && !r.RequiresPruning {\n+\t\t\t\t\t\trequirePruneOnly = false\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}",
        "comment_created_at": "2025-02-07T06:27:38+00:00",
        "comment_author": "andrii-korotkov-verkada",
        "comment_body": "This may be too slow, resulting in O(N * M) time complexity from the number of apps and number of resources. I think we have to do incremental updates of the target value to get linear complexity.",
        "pr_file_module": null
      },
      {
        "comment_id": "1946302032",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 21542,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "1946016600",
        "commented_code": "@@ -1068,7 +1068,20 @@ func (r *ApplicationSetReconciler) updateApplicationSetApplicationStatus(ctx con\n \n \t\tappOutdated := false\n \t\tif progressiveSyncsRollingSyncStrategyEnabled(applicationSet) {\n-\t\t\tappOutdated = syncStatusString == \"OutOfSync\"\n+\t\t\tappOutdated = syncStatusString == string(argov1alpha1.SyncStatusCodeOutOfSync)\n+\t\t\tpruneEnabled := app.Spec.SyncPolicy != nil && app.Spec.SyncPolicy.Automated != nil && app.Spec.SyncPolicy.Automated.Prune\n+\t\t\tif !pruneEnabled && appOutdated {\n+\t\t\t\trequirePruneOnly := true\n+\t\t\t\tfor _, r := range app.Status.Resources {\n+\t\t\t\t\tif r.Status != argov1alpha1.SyncStatusCodeSynced && !r.RequiresPruning {\n+\t\t\t\t\t\trequirePruneOnly = false\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}",
        "comment_created_at": "2025-02-07T10:20:47+00:00",
        "comment_author": "Homulvas",
        "comment_body": "I do agree that it would make things much easier if the app status had a distinction between `OutOfSync` and `OutOfSyncPruneOnly`.\r\nAt the same time if Application Controller can live with this loop https://github.com/argoproj/argo-cd/blob/4a1d0f3af5cb1f093b3b17a82093f48f36959b99/controller/appcontroller.go#L2060C1-L2072C3 then I don't see any point keeping this out from Appset Controller when it only affects Progressive Syncs.",
        "pr_file_module": null
      },
      {
        "comment_id": "1946402566",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 21542,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "1946016600",
        "commented_code": "@@ -1068,7 +1068,20 @@ func (r *ApplicationSetReconciler) updateApplicationSetApplicationStatus(ctx con\n \n \t\tappOutdated := false\n \t\tif progressiveSyncsRollingSyncStrategyEnabled(applicationSet) {\n-\t\t\tappOutdated = syncStatusString == \"OutOfSync\"\n+\t\t\tappOutdated = syncStatusString == string(argov1alpha1.SyncStatusCodeOutOfSync)\n+\t\t\tpruneEnabled := app.Spec.SyncPolicy != nil && app.Spec.SyncPolicy.Automated != nil && app.Spec.SyncPolicy.Automated.Prune\n+\t\t\tif !pruneEnabled && appOutdated {\n+\t\t\t\trequirePruneOnly := true\n+\t\t\t\tfor _, r := range app.Status.Resources {\n+\t\t\t\t\tif r.Status != argov1alpha1.SyncStatusCodeSynced && !r.RequiresPruning {\n+\t\t\t\t\t\trequirePruneOnly = false\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}",
        "comment_created_at": "2025-02-07T11:42:00+00:00",
        "comment_author": "andrii-korotkov-verkada",
        "comment_body": "We should probably update application status to have this field and re-compute it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172878572",
    "pr_number": 23506,
    "pr_file": "pkg/apis/application/v1alpha1/applicationset_types.go",
    "created_at": "2025-06-27T21:10:10+00:00",
    "commented_code": "// If the applicationset has a pre-existing condition of a type that is not in the evaluated list,\n // it will be preserved. If the applicationset has a pre-existing condition of a type, status, reason that\n // is in the evaluated list, but not in the incoming conditions list, it will be removed.\n-func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, _ map[ApplicationSetConditionType]bool) {\n-\tapplicationSetConditions := make([]ApplicationSetCondition, 0)\n+func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, evaluatedTypes map[ApplicationSetConditionType]bool) {\n+\tnewConditions := make([]ApplicationSetCondition, 0)\n \tnow := metav1.Now()\n+\t// Keep the existing conditions when they are not evaluated\n+\tfor i := range status.Conditions {\n+\t\tcurrentCondition := status.Conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[currentCondition.Type]; !ok || !isEvaluated {\n+\t\t\tif currentCondition.LastTransitionTime == nil {\n+\t\t\t\tcurrentCondition.LastTransitionTime = &now\n+\t\t\t}\n+\t\t\tnewConditions = append(newConditions, currentCondition)\n+\t\t}\n+\t}\n+\n+\t// Update the evaluated conditions\n \tfor i := range conditions {\n \t\tcondition := conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[condition.Type]; !ok || !isEvaluated {\n+\t\t\t// ignore an new condition when it is not evaluated\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif condition.LastTransitionTime == nil {\n \t\t\tcondition.LastTransitionTime = &now\n \t\t}\n-\t\teci := findConditionIndex(status.Conditions, condition.Type)\n+\t\teci := condition.Type.findConditionIndex(status.Conditions)\n \t\tif eci >= 0 && status.Conditions[eci].Message == condition.Message && status.Conditions[eci].Reason == condition.Reason && status.Conditions[eci].Status == condition.Status {\n-\t\t\t// If we already have a condition of this type, status and reason, only update the timestamp if something\n-\t\t\t// has changed.\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, status.Conditions[eci])\n+\t\t\t// If we already have a condition of this type and nothing has changed, do not update it\n+\t\t\tnewConditions = append(newConditions, status.Conditions[eci])\n \t\t} else {\n-\t\t\t// Otherwise we use the new incoming condition with an updated timestamp:\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, condition)\n+\t\t\t// Otherwise we use the new incoming condition with updated information\n+\t\t\tnewConditions = append(newConditions, condition)\n \t\t}\n \t}\n-\tsort.Slice(applicationSetConditions, func(i, j int) bool {\n-\t\tleft := applicationSetConditions[i]\n-\t\tright := applicationSetConditions[j]\n-\t\treturn fmt.Sprintf(\"%s/%s/%s/%s/%v\", left.Type, left.Message, left.Status, left.Reason, left.LastTransitionTime) < fmt.Sprintf(\"%s/%s/%s/%s/%v\", right.Type, right.Message, right.Status, right.Reason, right.LastTransitionTime)\n+\n+\tsort.Slice(newConditions, func(i, j int) bool {\n+\t\tleft := newConditions[i]\n+\t\tright := newConditions[j]\n+\n+\t\tif left.Type != right.Type {\n+\t\t\treturn left.Type < right.Type\n+\t\t}\n+\t\tif left.Message != right.Message {\n+\t\t\treturn left.Message < right.Message\n+\t\t}\n+\t\tif left.Status != right.Status {\n+\t\t\treturn left.Status < right.Status\n+\t\t}\n+\t\tif left.Reason != right.Reason {\n+\t\t\treturn left.Reason < right.Reason\n+\t\t}",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2172878572",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23506,
        "pr_file": "pkg/apis/application/v1alpha1/applicationset_types.go",
        "discussion_id": "2172878572",
        "commented_code": "@@ -917,33 +916,63 @@ func (a *ApplicationSet) RefreshRequired() bool {\n // If the applicationset has a pre-existing condition of a type that is not in the evaluated list,\n // it will be preserved. If the applicationset has a pre-existing condition of a type, status, reason that\n // is in the evaluated list, but not in the incoming conditions list, it will be removed.\n-func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, _ map[ApplicationSetConditionType]bool) {\n-\tapplicationSetConditions := make([]ApplicationSetCondition, 0)\n+func (status *ApplicationSetStatus) SetConditions(conditions []ApplicationSetCondition, evaluatedTypes map[ApplicationSetConditionType]bool) {\n+\tnewConditions := make([]ApplicationSetCondition, 0)\n \tnow := metav1.Now()\n+\t// Keep the existing conditions when they are not evaluated\n+\tfor i := range status.Conditions {\n+\t\tcurrentCondition := status.Conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[currentCondition.Type]; !ok || !isEvaluated {\n+\t\t\tif currentCondition.LastTransitionTime == nil {\n+\t\t\t\tcurrentCondition.LastTransitionTime = &now\n+\t\t\t}\n+\t\t\tnewConditions = append(newConditions, currentCondition)\n+\t\t}\n+\t}\n+\n+\t// Update the evaluated conditions\n \tfor i := range conditions {\n \t\tcondition := conditions[i]\n+\t\tif isEvaluated, ok := evaluatedTypes[condition.Type]; !ok || !isEvaluated {\n+\t\t\t// ignore an new condition when it is not evaluated\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tif condition.LastTransitionTime == nil {\n \t\t\tcondition.LastTransitionTime = &now\n \t\t}\n-\t\teci := findConditionIndex(status.Conditions, condition.Type)\n+\t\teci := condition.Type.findConditionIndex(status.Conditions)\n \t\tif eci >= 0 && status.Conditions[eci].Message == condition.Message && status.Conditions[eci].Reason == condition.Reason && status.Conditions[eci].Status == condition.Status {\n-\t\t\t// If we already have a condition of this type, status and reason, only update the timestamp if something\n-\t\t\t// has changed.\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, status.Conditions[eci])\n+\t\t\t// If we already have a condition of this type and nothing has changed, do not update it\n+\t\t\tnewConditions = append(newConditions, status.Conditions[eci])\n \t\t} else {\n-\t\t\t// Otherwise we use the new incoming condition with an updated timestamp:\n-\t\t\tapplicationSetConditions = append(applicationSetConditions, condition)\n+\t\t\t// Otherwise we use the new incoming condition with updated information\n+\t\t\tnewConditions = append(newConditions, condition)\n \t\t}\n \t}\n-\tsort.Slice(applicationSetConditions, func(i, j int) bool {\n-\t\tleft := applicationSetConditions[i]\n-\t\tright := applicationSetConditions[j]\n-\t\treturn fmt.Sprintf(\"%s/%s/%s/%s/%v\", left.Type, left.Message, left.Status, left.Reason, left.LastTransitionTime) < fmt.Sprintf(\"%s/%s/%s/%s/%v\", right.Type, right.Message, right.Status, right.Reason, right.LastTransitionTime)\n+\n+\tsort.Slice(newConditions, func(i, j int) bool {\n+\t\tleft := newConditions[i]\n+\t\tright := newConditions[j]\n+\n+\t\tif left.Type != right.Type {\n+\t\t\treturn left.Type < right.Type\n+\t\t}\n+\t\tif left.Message != right.Message {\n+\t\t\treturn left.Message < right.Message\n+\t\t}\n+\t\tif left.Status != right.Status {\n+\t\t\treturn left.Status < right.Status\n+\t\t}\n+\t\tif left.Reason != right.Reason {\n+\t\t\treturn left.Reason < right.Reason\n+\t\t}",
        "comment_created_at": "2025-06-27T21:10:10+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "```suggestion\r\n\t\tif left.Status != right.Status {\r\n\t\t\treturn left.Status < right.Status\r\n\t\t}\r\n\t\tif left.Reason != right.Reason {\r\n\t\t\treturn left.Reason < right.Reason\r\n\t\t}\r\n\t\tif left.Message != right.Message {\r\n\t\t\treturn left.Message < right.Message\r\n\t\t}\r\n```\r\n\r\nThis should give us somewhat more stable order, since the messages are arbitrary.",
        "pr_file_module": null
      }
    ]
  }
]