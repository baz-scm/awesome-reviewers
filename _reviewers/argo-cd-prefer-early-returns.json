[
  {
    "discussion_id": "2185529574",
    "pr_number": 23586,
    "pr_file": "util/session/sessionmanager.go",
    "created_at": "2025-07-04T14:37:10+00:00",
    "commented_code": "// WithAuthMiddleware is an HTTP middleware used to ensure incoming\n // requests are authenticated before invoking the target handler. If\n // disabled is true, it will just invoke the next handler in the chain.\n-func WithAuthMiddleware(disabled bool, authn TokenVerifier, next http.Handler) http.Handler {\n+func WithAuthMiddleware(disabled bool, ssoClientApp *oidcutil.ClientApp, settings *settings.ArgoCDSettings, authn TokenVerifier, next http.Handler) http.Handler {\n \treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n \t\tif !disabled {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2185529574",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23586,
        "pr_file": "util/session/sessionmanager.go",
        "discussion_id": "2185529574",
        "commented_code": "@@ -476,7 +476,7 @@ type TokenVerifier interface {\n // WithAuthMiddleware is an HTTP middleware used to ensure incoming\n // requests are authenticated before invoking the target handler. If\n // disabled is true, it will just invoke the next handler in the chain.\n-func WithAuthMiddleware(disabled bool, authn TokenVerifier, next http.Handler) http.Handler {\n+func WithAuthMiddleware(disabled bool, ssoClientApp *oidcutil.ClientApp, settings *settings.ArgoCDSettings, authn TokenVerifier, next http.Handler) http.Handler {\n \treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n \t\tif !disabled {",
        "comment_created_at": "2025-07-04T14:37:10+00:00",
        "comment_author": "agaudreault",
        "comment_body": "Invert if condition to return early. It will be more readable now that the method grew in size",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2050863875",
    "pr_number": 22722,
    "pr_file": "util/argo/resource_tracking.go",
    "created_at": "2025-04-18T16:46:56+00:00",
    "commented_code": "return nil\n \t}\n \n-\tannotation, err := kube.GetAppInstanceAnnotation(config, common.AnnotationKeyAppInstance)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\terr = kube.SetAppInstanceAnnotation(live, common.AnnotationKeyAppInstance, annotation)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n+\tif !kubeutil.IsCRD(live) {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2050863875",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22722,
        "pr_file": "util/argo/resource_tracking.go",
        "discussion_id": "2050863875",
        "commented_code": "@@ -232,23 +233,25 @@ func (rt *resourceTracking) Normalize(config, live *unstructured.Unstructured, l\n \t\treturn nil\n \t}\n \n-\tannotation, err := kube.GetAppInstanceAnnotation(config, common.AnnotationKeyAppInstance)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\terr = kube.SetAppInstanceAnnotation(live, common.AnnotationKeyAppInstance, annotation)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n+\tif !kubeutil.IsCRD(live) {",
        "comment_created_at": "2025-04-18T16:46:56+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "I'd short-circuit instead of nesting\r\n\r\n```go\r\nif kubeutil.IsCRD(live) {\r\n// CRDs don't get tracking annotations.\r\nreturn nil\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2191535011",
    "pr_number": 23465,
    "pr_file": "applicationset/controllers/applicationset_controller.go",
    "created_at": "2025-07-08T05:46:26+00:00",
    "commented_code": "}, nil\n }\n \n+func (r *ApplicationSetReconciler) performReverseDeletion(ctx context.Context, logCtx *log.Entry, appset argov1alpha1.ApplicationSet, currentApps []argov1alpha1.Application) (time.Duration, error) {\n+\trequeueTime := 10 * time.Second\n+\t// get deletionOrder using current Apps\n+\tstepLength := len(appset.Spec.Strategy.RollingSync.Steps)\n+\tif stepLength == 0 {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2191535011",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23465,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "2191535011",
        "commented_code": "@@ -357,6 +376,62 @@ func (r *ApplicationSetReconciler) Reconcile(ctx context.Context, req ctrl.Reque\n \t}, nil\n }\n \n+func (r *ApplicationSetReconciler) performReverseDeletion(ctx context.Context, logCtx *log.Entry, appset argov1alpha1.ApplicationSet, currentApps []argov1alpha1.Application) (time.Duration, error) {\n+\trequeueTime := 10 * time.Second\n+\t// get deletionOrder using current Apps\n+\tstepLength := len(appset.Spec.Strategy.RollingSync.Steps)\n+\tif stepLength == 0 {",
        "comment_created_at": "2025-07-08T05:46:26+00:00",
        "comment_author": "anandf",
        "comment_body": "I think this check should be first task in the function and there should be an early exit.\r\n```\r\nif len(appset.Spec.Strategy.RollingSync.Steps) <=0 {\r\nlogCtx.Info(\"no rolling sync steps found\")\r\nreturn\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2196521154",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23465,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "2191535011",
        "commented_code": "@@ -357,6 +376,62 @@ func (r *ApplicationSetReconciler) Reconcile(ctx context.Context, req ctrl.Reque\n \t}, nil\n }\n \n+func (r *ApplicationSetReconciler) performReverseDeletion(ctx context.Context, logCtx *log.Entry, appset argov1alpha1.ApplicationSet, currentApps []argov1alpha1.Application) (time.Duration, error) {\n+\trequeueTime := 10 * time.Second\n+\t// get deletionOrder using current Apps\n+\tstepLength := len(appset.Spec.Strategy.RollingSync.Steps)\n+\tif stepLength == 0 {",
        "comment_created_at": "2025-07-10T04:31:27+00:00",
        "comment_author": "ranakan19",
        "comment_body": "removed the check for stepLength because `isRollingSyncDeletionReversed ` checks for the length of steps to be greater than zero. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1974812661",
    "pr_number": 22064,
    "pr_file": "controller/sync.go",
    "created_at": "2025-02-28T05:32:47+00:00",
    "commented_code": "} else {\n \t\t\tsyncRes.Source = source\n \t\t}\n-\t\tstate.SyncResult = syncRes\n+\t\tif !syncOp.DryRun {\n+\t\t\tstate.SyncResult = syncRes\n+\t\t}",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "1974812661",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 22064,
        "pr_file": "controller/sync.go",
        "discussion_id": "1974812661",
        "commented_code": "@@ -155,7 +155,9 @@ func (m *appStateManager) SyncAppState(app *v1alpha1.Application, state *v1alpha\n \t\t} else {\n \t\t\tsyncRes.Source = source\n \t\t}\n-\t\tstate.SyncResult = syncRes\n+\t\tif !syncOp.DryRun {\n+\t\t\tstate.SyncResult = syncRes\n+\t\t}",
        "comment_created_at": "2025-02-28T05:32:47+00:00",
        "comment_author": "andrii-korotkov-verkada",
        "comment_body": "If it's dry run, whole block is not needed, please move the condition above.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172849541",
    "pr_number": 23506,
    "pr_file": "applicationset/controllers/applicationset_controller.go",
    "created_at": "2025-06-27T20:45:30+00:00",
    "commented_code": "}\n \n func getParametersGeneratedCondition(parametersGenerated bool, message string) argov1alpha1.ApplicationSetCondition {\n-\tvar paramtersGeneratedCondition argov1alpha1.ApplicationSetCondition\n+\tvar parametersGeneratedCondition argov1alpha1.ApplicationSetCondition\n \tif parametersGenerated {\n-\t\tparamtersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n+\t\tparametersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n \t\t\tType:    argov1alpha1.ApplicationSetConditionParametersGenerated,\n \t\t\tMessage: \"Successfully generated parameters for all Applications\",\n \t\t\tReason:  argov1alpha1.ApplicationSetReasonParametersGenerated,\n \t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusTrue,\n \t\t}\n \t} else {\n-\t\tparamtersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n+\t\tparametersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n \t\t\tType:    argov1alpha1.ApplicationSetConditionParametersGenerated,\n \t\t\tMessage: message,\n \t\t\tReason:  argov1alpha1.ApplicationSetReasonErrorOccurred,\n \t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n \t\t}\n \t}\n-\treturn paramtersGeneratedCondition\n+\treturn parametersGeneratedCondition\n }\n \n-func getResourceUpToDateCondition(errorOccurred bool, message string, reason string) argov1alpha1.ApplicationSetCondition {\n-\tvar resourceUpToDateCondition argov1alpha1.ApplicationSetCondition\n-\tif errorOccurred {\n-\t\tresourceUpToDateCondition = argov1alpha1.ApplicationSetCondition{\n-\t\t\tType:    argov1alpha1.ApplicationSetConditionResourcesUpToDate,\n-\t\t\tMessage: message,\n-\t\t\tReason:  reason,\n-\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n-\t\t}\n-\t} else {\n-\t\tresourceUpToDateCondition = argov1alpha1.ApplicationSetCondition{\n-\t\t\tType:    argov1alpha1.ApplicationSetConditionResourcesUpToDate,\n-\t\t\tMessage: \"ApplicationSet up to date\",\n-\t\t\tReason:  argov1alpha1.ApplicationSetReasonApplicationSetUpToDate,\n-\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusTrue,\n-\t\t}\n+func (r *ApplicationSetReconciler) setApplicationSetStatusCondition(ctx context.Context, applicationSet *argov1alpha1.ApplicationSet, condition argov1alpha1.ApplicationSetCondition, parametersGenerated bool) error {\n+\tnewConditions := []argov1alpha1.ApplicationSetCondition{}\n+\tevaluatedTypes := map[argov1alpha1.ApplicationSetConditionType]bool{\n+\t\targov1alpha1.ApplicationSetConditionParametersGenerated: true,\n+\t\targov1alpha1.ApplicationSetConditionErrorOccurred:       false,\n+\t\targov1alpha1.ApplicationSetConditionResourcesUpToDate:   false,\n+\t\targov1alpha1.ApplicationSetConditionRolloutProgressing:  false,\n \t}\n-\treturn resourceUpToDateCondition\n-}\n \n-func (r *ApplicationSetReconciler) setApplicationSetStatusCondition(ctx context.Context, applicationSet *argov1alpha1.ApplicationSet, condition argov1alpha1.ApplicationSetCondition, paramtersGenerated bool) error {\n-\t// check if error occurred during reconcile process\n-\terrOccurred := condition.Type == argov1alpha1.ApplicationSetConditionErrorOccurred\n-\n-\tvar errOccurredCondition argov1alpha1.ApplicationSetCondition\n-\n-\tif errOccurred {\n-\t\terrOccurredCondition = condition\n-\t} else {\n-\t\terrOccurredCondition = argov1alpha1.ApplicationSetCondition{\n-\t\t\tType:    argov1alpha1.ApplicationSetConditionErrorOccurred,\n-\t\t\tMessage: \"Successfully generated parameters for all Applications\",\n-\t\t\tReason:  argov1alpha1.ApplicationSetReasonApplicationSetUpToDate,\n-\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n-\t\t}\n+\tif !isRollingSyncStrategy(applicationSet) {\n+\t\t// Progressing sync is always evaluated so conditions are removed when it is not enabled\n+\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionRolloutProgressing] = true\n \t}\n \n-\tparamtersGeneratedCondition := getParametersGeneratedCondition(paramtersGenerated, condition.Message)\n-\tresourceUpToDateCondition := getResourceUpToDateCondition(errOccurred, condition.Message, condition.Reason)\n+\t// Evaluate current condition\n+\tevaluatedTypes[condition.Type] = true\n+\tnewConditions = append(newConditions, condition)\n \n-\tevaluatedTypes := map[argov1alpha1.ApplicationSetConditionType]bool{\n-\t\targov1alpha1.ApplicationSetConditionErrorOccurred:       true,\n-\t\targov1alpha1.ApplicationSetConditionParametersGenerated: true,\n-\t\targov1alpha1.ApplicationSetConditionResourcesUpToDate:   true,\n+\t// Evaluate ParametersGenerated since it is always provided\n+\tif condition.Type != argov1alpha1.ApplicationSetConditionParametersGenerated {\n+\t\tnewConditions = append(newConditions, getParametersGeneratedCondition(parametersGenerated, condition.Message))\n \t}\n-\tnewConditions := []argov1alpha1.ApplicationSetCondition{errOccurredCondition, paramtersGeneratedCondition, resourceUpToDateCondition}\n-\n-\tif progressiveSyncsRollingSyncStrategyEnabled(applicationSet) {\n-\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionRolloutProgressing] = true\n \n-\t\tif condition.Type == argov1alpha1.ApplicationSetConditionRolloutProgressing {\n-\t\t\tnewConditions = append(newConditions, condition)\n+\t// Evaluate dependencies between conditions.\n+\tswitch condition.Type {\n+\tcase argov1alpha1.ApplicationSetConditionResourcesUpToDate:\n+\t\tif condition.Status == argov1alpha1.ApplicationSetConditionStatusTrue {\n+\t\t\t// If the resources are up to date, we know there was no errors\n+\t\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionErrorOccurred] = true\n+\t\t\tnewConditions = append(newConditions, argov1alpha1.ApplicationSetCondition{\n+\t\t\t\tType:    argov1alpha1.ApplicationSetConditionErrorOccurred,\n+\t\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n+\t\t\t\tReason:  condition.Reason,\n+\t\t\t\tMessage: condition.Message,\n+\t\t\t})\n+\t\t}\n+\tcase argov1alpha1.ApplicationSetConditionErrorOccurred:\n+\t\tif condition.Status == argov1alpha1.ApplicationSetConditionStatusTrue {\n+\t\t\t// If there is an error anywhere in the reconciliation, we cannot consider the resources up to date\n+\t\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionResourcesUpToDate] = true\n+\t\t\tnewConditions = append(newConditions, argov1alpha1.ApplicationSetCondition{\n+\t\t\t\tType:    argov1alpha1.ApplicationSetConditionResourcesUpToDate,\n+\t\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n+\t\t\t\tReason:  argov1alpha1.ApplicationSetReasonErrorOccurred,\n+\t\t\t\tMessage: condition.Message,\n+\t\t\t})\n+\t\t}\n+\tcase argov1alpha1.ApplicationSetConditionRolloutProgressing:\n+\t\tif !isRollingSyncStrategy(applicationSet) {\n+\t\t\t// if the condition is a rolling sync and it is disabled, ignore it\n+\t\t\tevaluatedTypes[condition.Type] = false\n \t\t}\n \t}\n \n-\tneedToUpdateConditions := false\n-\tfor _, condition := range newConditions {\n-\t\t// do nothing if appset already has same condition\n-\t\tfor _, c := range applicationSet.Status.Conditions {\n-\t\t\tif c.Type == condition.Type && (c.Reason != condition.Reason || c.Status != condition.Status || c.Message != condition.Message) {\n+\t// Update the applicationSet conditions\n+\tpreviousConditions := applicationSet.Status.Conditions\n+\tapplicationSet.Status.SetConditions(newConditions, evaluatedTypes)\n+\n+\t// Try to not call get/update if nothing has changed\n+\tneedToUpdateConditions := len(applicationSet.Status.Conditions) != len(previousConditions)\n+\tif !needToUpdateConditions {\n+\t\tfor i, c := range applicationSet.Status.Conditions {\n+\t\t\tprevious := previousConditions[i]\n+\t\t\tif c.Type != previous.Type || c.Reason != previous.Reason || c.Status != previous.Status || c.Message != previous.Message {\n \t\t\t\tneedToUpdateConditions = true\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n \n-\tif needToUpdateConditions || len(applicationSet.Status.Conditions) < len(newConditions) {\n-\t\t// fetch updated Application Set object before updating it\n+\tif needToUpdateConditions {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2172849541",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23506,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "2172849541",
        "commented_code": "@@ -358,107 +364,107 @@ func (r *ApplicationSetReconciler) Reconcile(ctx context.Context, req ctrl.Reque\n }\n \n func getParametersGeneratedCondition(parametersGenerated bool, message string) argov1alpha1.ApplicationSetCondition {\n-\tvar paramtersGeneratedCondition argov1alpha1.ApplicationSetCondition\n+\tvar parametersGeneratedCondition argov1alpha1.ApplicationSetCondition\n \tif parametersGenerated {\n-\t\tparamtersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n+\t\tparametersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n \t\t\tType:    argov1alpha1.ApplicationSetConditionParametersGenerated,\n \t\t\tMessage: \"Successfully generated parameters for all Applications\",\n \t\t\tReason:  argov1alpha1.ApplicationSetReasonParametersGenerated,\n \t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusTrue,\n \t\t}\n \t} else {\n-\t\tparamtersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n+\t\tparametersGeneratedCondition = argov1alpha1.ApplicationSetCondition{\n \t\t\tType:    argov1alpha1.ApplicationSetConditionParametersGenerated,\n \t\t\tMessage: message,\n \t\t\tReason:  argov1alpha1.ApplicationSetReasonErrorOccurred,\n \t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n \t\t}\n \t}\n-\treturn paramtersGeneratedCondition\n+\treturn parametersGeneratedCondition\n }\n \n-func getResourceUpToDateCondition(errorOccurred bool, message string, reason string) argov1alpha1.ApplicationSetCondition {\n-\tvar resourceUpToDateCondition argov1alpha1.ApplicationSetCondition\n-\tif errorOccurred {\n-\t\tresourceUpToDateCondition = argov1alpha1.ApplicationSetCondition{\n-\t\t\tType:    argov1alpha1.ApplicationSetConditionResourcesUpToDate,\n-\t\t\tMessage: message,\n-\t\t\tReason:  reason,\n-\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n-\t\t}\n-\t} else {\n-\t\tresourceUpToDateCondition = argov1alpha1.ApplicationSetCondition{\n-\t\t\tType:    argov1alpha1.ApplicationSetConditionResourcesUpToDate,\n-\t\t\tMessage: \"ApplicationSet up to date\",\n-\t\t\tReason:  argov1alpha1.ApplicationSetReasonApplicationSetUpToDate,\n-\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusTrue,\n-\t\t}\n+func (r *ApplicationSetReconciler) setApplicationSetStatusCondition(ctx context.Context, applicationSet *argov1alpha1.ApplicationSet, condition argov1alpha1.ApplicationSetCondition, parametersGenerated bool) error {\n+\tnewConditions := []argov1alpha1.ApplicationSetCondition{}\n+\tevaluatedTypes := map[argov1alpha1.ApplicationSetConditionType]bool{\n+\t\targov1alpha1.ApplicationSetConditionParametersGenerated: true,\n+\t\targov1alpha1.ApplicationSetConditionErrorOccurred:       false,\n+\t\targov1alpha1.ApplicationSetConditionResourcesUpToDate:   false,\n+\t\targov1alpha1.ApplicationSetConditionRolloutProgressing:  false,\n \t}\n-\treturn resourceUpToDateCondition\n-}\n \n-func (r *ApplicationSetReconciler) setApplicationSetStatusCondition(ctx context.Context, applicationSet *argov1alpha1.ApplicationSet, condition argov1alpha1.ApplicationSetCondition, paramtersGenerated bool) error {\n-\t// check if error occurred during reconcile process\n-\terrOccurred := condition.Type == argov1alpha1.ApplicationSetConditionErrorOccurred\n-\n-\tvar errOccurredCondition argov1alpha1.ApplicationSetCondition\n-\n-\tif errOccurred {\n-\t\terrOccurredCondition = condition\n-\t} else {\n-\t\terrOccurredCondition = argov1alpha1.ApplicationSetCondition{\n-\t\t\tType:    argov1alpha1.ApplicationSetConditionErrorOccurred,\n-\t\t\tMessage: \"Successfully generated parameters for all Applications\",\n-\t\t\tReason:  argov1alpha1.ApplicationSetReasonApplicationSetUpToDate,\n-\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n-\t\t}\n+\tif !isRollingSyncStrategy(applicationSet) {\n+\t\t// Progressing sync is always evaluated so conditions are removed when it is not enabled\n+\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionRolloutProgressing] = true\n \t}\n \n-\tparamtersGeneratedCondition := getParametersGeneratedCondition(paramtersGenerated, condition.Message)\n-\tresourceUpToDateCondition := getResourceUpToDateCondition(errOccurred, condition.Message, condition.Reason)\n+\t// Evaluate current condition\n+\tevaluatedTypes[condition.Type] = true\n+\tnewConditions = append(newConditions, condition)\n \n-\tevaluatedTypes := map[argov1alpha1.ApplicationSetConditionType]bool{\n-\t\targov1alpha1.ApplicationSetConditionErrorOccurred:       true,\n-\t\targov1alpha1.ApplicationSetConditionParametersGenerated: true,\n-\t\targov1alpha1.ApplicationSetConditionResourcesUpToDate:   true,\n+\t// Evaluate ParametersGenerated since it is always provided\n+\tif condition.Type != argov1alpha1.ApplicationSetConditionParametersGenerated {\n+\t\tnewConditions = append(newConditions, getParametersGeneratedCondition(parametersGenerated, condition.Message))\n \t}\n-\tnewConditions := []argov1alpha1.ApplicationSetCondition{errOccurredCondition, paramtersGeneratedCondition, resourceUpToDateCondition}\n-\n-\tif progressiveSyncsRollingSyncStrategyEnabled(applicationSet) {\n-\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionRolloutProgressing] = true\n \n-\t\tif condition.Type == argov1alpha1.ApplicationSetConditionRolloutProgressing {\n-\t\t\tnewConditions = append(newConditions, condition)\n+\t// Evaluate dependencies between conditions.\n+\tswitch condition.Type {\n+\tcase argov1alpha1.ApplicationSetConditionResourcesUpToDate:\n+\t\tif condition.Status == argov1alpha1.ApplicationSetConditionStatusTrue {\n+\t\t\t// If the resources are up to date, we know there was no errors\n+\t\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionErrorOccurred] = true\n+\t\t\tnewConditions = append(newConditions, argov1alpha1.ApplicationSetCondition{\n+\t\t\t\tType:    argov1alpha1.ApplicationSetConditionErrorOccurred,\n+\t\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n+\t\t\t\tReason:  condition.Reason,\n+\t\t\t\tMessage: condition.Message,\n+\t\t\t})\n+\t\t}\n+\tcase argov1alpha1.ApplicationSetConditionErrorOccurred:\n+\t\tif condition.Status == argov1alpha1.ApplicationSetConditionStatusTrue {\n+\t\t\t// If there is an error anywhere in the reconciliation, we cannot consider the resources up to date\n+\t\t\tevaluatedTypes[argov1alpha1.ApplicationSetConditionResourcesUpToDate] = true\n+\t\t\tnewConditions = append(newConditions, argov1alpha1.ApplicationSetCondition{\n+\t\t\t\tType:    argov1alpha1.ApplicationSetConditionResourcesUpToDate,\n+\t\t\t\tStatus:  argov1alpha1.ApplicationSetConditionStatusFalse,\n+\t\t\t\tReason:  argov1alpha1.ApplicationSetReasonErrorOccurred,\n+\t\t\t\tMessage: condition.Message,\n+\t\t\t})\n+\t\t}\n+\tcase argov1alpha1.ApplicationSetConditionRolloutProgressing:\n+\t\tif !isRollingSyncStrategy(applicationSet) {\n+\t\t\t// if the condition is a rolling sync and it is disabled, ignore it\n+\t\t\tevaluatedTypes[condition.Type] = false\n \t\t}\n \t}\n \n-\tneedToUpdateConditions := false\n-\tfor _, condition := range newConditions {\n-\t\t// do nothing if appset already has same condition\n-\t\tfor _, c := range applicationSet.Status.Conditions {\n-\t\t\tif c.Type == condition.Type && (c.Reason != condition.Reason || c.Status != condition.Status || c.Message != condition.Message) {\n+\t// Update the applicationSet conditions\n+\tpreviousConditions := applicationSet.Status.Conditions\n+\tapplicationSet.Status.SetConditions(newConditions, evaluatedTypes)\n+\n+\t// Try to not call get/update if nothing has changed\n+\tneedToUpdateConditions := len(applicationSet.Status.Conditions) != len(previousConditions)\n+\tif !needToUpdateConditions {\n+\t\tfor i, c := range applicationSet.Status.Conditions {\n+\t\t\tprevious := previousConditions[i]\n+\t\t\tif c.Type != previous.Type || c.Reason != previous.Reason || c.Status != previous.Status || c.Message != previous.Message {\n \t\t\t\tneedToUpdateConditions = true\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n \n-\tif needToUpdateConditions || len(applicationSet.Status.Conditions) < len(newConditions) {\n-\t\t// fetch updated Application Set object before updating it\n+\tif needToUpdateConditions {",
        "comment_created_at": "2025-06-27T20:45:30+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "We can avoid the deep nesting by just short-circuiting here.\r\n\r\n```suggestion\r\n\tif !needToUpdateConditions {\r\n\t\treturn nil\r\n\t}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2000183192",
    "pr_number": 21999,
    "pr_file": "pkg/apis/application/v1alpha1/types.go",
    "created_at": "2025-03-18T04:38:42+00:00",
    "commented_code": "// If you add a field here, be sure to update IsZero.\n }\n \n+// IsAutomatedSyncEnabled checks if the automated sync is enabled or disabled\n+func (p *SyncPolicy) IsAutomatedSyncEnabled() bool {\n+\tvar isEnabled bool\n+\n+\tif p.Automated != nil && (p.Automated.Enable == nil || *p.Automated.Enable) {\n+\t\tisEnabled = true",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2000183192",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 21999,
        "pr_file": "pkg/apis/application/v1alpha1/types.go",
        "discussion_id": "2000183192",
        "commented_code": "@@ -1432,6 +1432,16 @@ type SyncPolicy struct {\n \t// If you add a field here, be sure to update IsZero.\n }\n \n+// IsAutomatedSyncEnabled checks if the automated sync is enabled or disabled\n+func (p *SyncPolicy) IsAutomatedSyncEnabled() bool {\n+\tvar isEnabled bool\n+\n+\tif p.Automated != nil && (p.Automated.Enable == nil || *p.Automated.Enable) {\n+\t\tisEnabled = true",
        "comment_created_at": "2025-03-18T04:38:42+00:00",
        "comment_author": "anandf",
        "comment_body": "better to `return true` and remove the variable `isEnabled`",
        "pr_file_module": null
      },
      {
        "comment_id": "2000226303",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 21999,
        "pr_file": "pkg/apis/application/v1alpha1/types.go",
        "discussion_id": "2000183192",
        "commented_code": "@@ -1432,6 +1432,16 @@ type SyncPolicy struct {\n \t// If you add a field here, be sure to update IsZero.\n }\n \n+// IsAutomatedSyncEnabled checks if the automated sync is enabled or disabled\n+func (p *SyncPolicy) IsAutomatedSyncEnabled() bool {\n+\tvar isEnabled bool\n+\n+\tif p.Automated != nil && (p.Automated.Enable == nil || *p.Automated.Enable) {\n+\t\tisEnabled = true",
        "comment_created_at": "2025-03-18T05:20:23+00:00",
        "comment_author": "anandrkskd",
        "comment_body": "Updated 👍🏽 ",
        "pr_file_module": null
      }
    ]
  }
]