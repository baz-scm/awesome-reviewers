[
  {
    "discussion_id": "2104632157",
    "pr_number": 23131,
    "pr_file": "server/application/application.go",
    "created_at": "2025-05-23T13:46:04+00:00",
    "commented_code": "return nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n }\n \n+func diffBetweenApplicationSpecs(a *v1alpha1.ApplicationSpec, b *v1alpha1.ApplicationSpec) (string, error) {",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2104632157",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23131,
        "pr_file": "server/application/application.go",
        "discussion_id": "2104632157",
        "commented_code": "@@ -987,6 +991,23 @@ func (s *Server) updateApp(ctx context.Context, app *v1alpha1.Application, newAp\n \treturn nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n }\n \n+func diffBetweenApplicationSpecs(a *v1alpha1.ApplicationSpec, b *v1alpha1.ApplicationSpec) (string, error) {",
        "comment_created_at": "2025-05-23T13:46:04+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "A couple suggestions:\r\n\r\n1) I'd unmarshal the patch into a map[any]any and log it as its own field, so it's parseable by log tools\r\n2) I'd exclude the patch from the event: some people put _huge_ stuff in their app spec",
        "pr_file_module": null
      },
      {
        "comment_id": "2104826622",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23131,
        "pr_file": "server/application/application.go",
        "discussion_id": "2104632157",
        "commented_code": "@@ -987,6 +991,23 @@ func (s *Server) updateApp(ctx context.Context, app *v1alpha1.Application, newAp\n \treturn nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n }\n \n+func diffBetweenApplicationSpecs(a *v1alpha1.ApplicationSpec, b *v1alpha1.ApplicationSpec) (string, error) {",
        "comment_created_at": "2025-05-23T15:24:44+00:00",
        "comment_author": "TomHellier",
        "comment_body": "Hi @crenshaw-dev  - thanks for the review.\r\n\r\nI've pushed changes based on my understanding of your feedback, if you wouldn't mind another look.\r\n\r\nI've pushed logFields right up to the top of logAppEvent so future audit context can be added more easily.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1919195344",
    "pr_number": 21442,
    "pr_file": "applicationset/controllers/applicationset_controller.go",
    "created_at": "2025-01-16T21:06:11+00:00",
    "commented_code": "},\n \t\tGenericFunc: func(e event.GenericEvent) bool {\n \t\t\tif log.IsLevelEnabled(log.DebugLevel) {\n-\t\t\t\tvar appName string\n+\t\t\t\tlogFields := log.Fields{\"app\": \"\"}",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "1919195344",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 21442,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "1919195344",
        "commented_code": "@@ -1508,12 +1510,12 @@ func getOwnsHandlerPredicates(enableProgressiveSyncs bool) predicate.Funcs {\n \t\t},\n \t\tGenericFunc: func(e event.GenericEvent) bool {\n \t\t\tif log.IsLevelEnabled(log.DebugLevel) {\n-\t\t\t\tvar appName string\n+\t\t\t\tlogFields := log.Fields{\"app\": \"\"}",
        "comment_created_at": "2025-01-16T21:06:11+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "```suggestion\r\n\t\t\t\tlogFields := log.Fields{}\r\n```\r\n\r\nProbably fine to start with an empty set and replace it if the type assertion is successful.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1853330980",
    "pr_number": 20901,
    "pr_file": "util/oidc/oidc.go",
    "created_at": "2024-11-22T06:03:58+00:00",
    "commented_code": "idToken, err := a.provider.Verify(idTokenRAW, a.settings)\n \tif err != nil {\n \t\tlog.Warnf(\"Failed to verify token: %s\", err)\n+\t\tlog.Infof(\"Client IP: %s\", r.RemoteAddr)",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "1853330980",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 20901,
        "pr_file": "util/oidc/oidc.go",
        "discussion_id": "1853330980",
        "commented_code": "@@ -376,6 +376,7 @@ func (a *ClientApp) HandleCallback(w http.ResponseWriter, r *http.Request) {\n \tidToken, err := a.provider.Verify(idTokenRAW, a.settings)\n \tif err != nil {\n \t\tlog.Warnf(\"Failed to verify token: %s\", err)\n+\t\tlog.Infof(\"Client IP: %s\", r.RemoteAddr)",
        "comment_created_at": "2024-11-22T06:03:58+00:00",
        "comment_author": "andrii-korotkov-verkada",
        "comment_body": "Let's have one log statement and/or add client ip as a structured field for the warn message. I find two logs of different kind from the same block confusing. However, we may also log ip address regardless in the outside block together with some other metadata.",
        "pr_file_module": null
      },
      {
        "comment_id": "1853800113",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 20901,
        "pr_file": "util/oidc/oidc.go",
        "discussion_id": "1853330980",
        "commented_code": "@@ -376,6 +376,7 @@ func (a *ClientApp) HandleCallback(w http.ResponseWriter, r *http.Request) {\n \tidToken, err := a.provider.Verify(idTokenRAW, a.settings)\n \tif err != nil {\n \t\tlog.Warnf(\"Failed to verify token: %s\", err)\n+\t\tlog.Infof(\"Client IP: %s\", r.RemoteAddr)",
        "comment_created_at": "2024-11-22T11:52:23+00:00",
        "comment_author": "omerap12",
        "comment_body": "Understood. I recommend including the IP address in all warning messages, not just this one.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172823663",
    "pr_number": 23506,
    "pr_file": "applicationset/controllers/applicationset_controller.go",
    "created_at": "2025-06-27T20:21:49+00:00",
    "commented_code": "appMap[app.Name] = app\n \t\t\t}\n \n-\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, desiredApplications, appMap)\n+\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, generatedApplications, appMap)\n \t\t\tif err != nil {\n \t\t\t\treturn ctrl.Result{}, fmt.Errorf(\"failed to perform progressive sync reconciliation for application set: %w\", err)\n \t\t\t}\n \t\t}\n \t}\n \n \tvar validApps []argov1alpha1.Application\n-\tfor i := range desiredApplications {\n-\t\tif validateErrors[i] == nil {\n-\t\t\tvalidApps = append(validApps, desiredApplications[i])\n+\tfor i, app := range generatedApplications {\n+\t\tif validateErrors[app.QualifiedName()] == nil {\n+\t\t\tvalidApps = append(validApps, generatedApplications[i])\n \t\t}\n \t}\n \n \tif len(validateErrors) > 0 {\n+\t\terrorApps := make([]string, 0, len(validateErrors))\n+\t\tfor key := range validateErrors {\n+\t\t\terrorApps = append(errorApps, key)\n+\t\t}\n+\t\tsort.Strings(errorApps)\n+\n \t\tvar message string\n-\t\tfor _, v := range validateErrors {\n-\t\t\tmessage = v.Error()\n-\t\t\tlogCtx.Errorf(\"validation error found during application validation: %s\", message)\n+\t\tfor _, appName := range errorApps {\n+\t\t\tmessage = validateErrors[appName].Error()\n+\t\t\tlogCtx.WithField(\"app\", appName).Errorf(\"validation error found during application validation: %s\", message)",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2172823663",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23506,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "2172823663",
        "commented_code": "@@ -225,25 +225,31 @@ func (r *ApplicationSetReconciler) Reconcile(ctx context.Context, req ctrl.Reque\n \t\t\t\tappMap[app.Name] = app\n \t\t\t}\n \n-\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, desiredApplications, appMap)\n+\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, generatedApplications, appMap)\n \t\t\tif err != nil {\n \t\t\t\treturn ctrl.Result{}, fmt.Errorf(\"failed to perform progressive sync reconciliation for application set: %w\", err)\n \t\t\t}\n \t\t}\n \t}\n \n \tvar validApps []argov1alpha1.Application\n-\tfor i := range desiredApplications {\n-\t\tif validateErrors[i] == nil {\n-\t\t\tvalidApps = append(validApps, desiredApplications[i])\n+\tfor i, app := range generatedApplications {\n+\t\tif validateErrors[app.QualifiedName()] == nil {\n+\t\t\tvalidApps = append(validApps, generatedApplications[i])\n \t\t}\n \t}\n \n \tif len(validateErrors) > 0 {\n+\t\terrorApps := make([]string, 0, len(validateErrors))\n+\t\tfor key := range validateErrors {\n+\t\t\terrorApps = append(errorApps, key)\n+\t\t}\n+\t\tsort.Strings(errorApps)\n+\n \t\tvar message string\n-\t\tfor _, v := range validateErrors {\n-\t\t\tmessage = v.Error()\n-\t\t\tlogCtx.Errorf(\"validation error found during application validation: %s\", message)\n+\t\tfor _, appName := range errorApps {\n+\t\t\tmessage = validateErrors[appName].Error()\n+\t\t\tlogCtx.WithField(\"app\", appName).Errorf(\"validation error found during application validation: %s\", message)",
        "comment_created_at": "2025-06-27T20:21:49+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "```suggestion\r\n\t\t\tlogCtx.WithFields(applog.GetAppLogFields(&generatedApplications[i])).Errorf(\"validation error found during application validation: %s\", message)\r\n```\r\n\r\nSomething like that would get you the standard app log fields.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175855965",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23506,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "2172823663",
        "commented_code": "@@ -225,25 +225,31 @@ func (r *ApplicationSetReconciler) Reconcile(ctx context.Context, req ctrl.Reque\n \t\t\t\tappMap[app.Name] = app\n \t\t\t}\n \n-\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, desiredApplications, appMap)\n+\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, generatedApplications, appMap)\n \t\t\tif err != nil {\n \t\t\t\treturn ctrl.Result{}, fmt.Errorf(\"failed to perform progressive sync reconciliation for application set: %w\", err)\n \t\t\t}\n \t\t}\n \t}\n \n \tvar validApps []argov1alpha1.Application\n-\tfor i := range desiredApplications {\n-\t\tif validateErrors[i] == nil {\n-\t\t\tvalidApps = append(validApps, desiredApplications[i])\n+\tfor i, app := range generatedApplications {\n+\t\tif validateErrors[app.QualifiedName()] == nil {\n+\t\t\tvalidApps = append(validApps, generatedApplications[i])\n \t\t}\n \t}\n \n \tif len(validateErrors) > 0 {\n+\t\terrorApps := make([]string, 0, len(validateErrors))\n+\t\tfor key := range validateErrors {\n+\t\t\terrorApps = append(errorApps, key)\n+\t\t}\n+\t\tsort.Strings(errorApps)\n+\n \t\tvar message string\n-\t\tfor _, v := range validateErrors {\n-\t\t\tmessage = v.Error()\n-\t\t\tlogCtx.Errorf(\"validation error found during application validation: %s\", message)\n+\t\tfor _, appName := range errorApps {\n+\t\t\tmessage = validateErrors[appName].Error()\n+\t\t\tlogCtx.WithField(\"app\", appName).Errorf(\"validation error found during application validation: %s\", message)",
        "comment_created_at": "2025-06-30T20:37:25+00:00",
        "comment_author": "agaudreault",
        "comment_body": "This change would mean refactoring the variables so we have a map of Applications instead of a list. This change is outside the scope of this refactor",
        "pr_file_module": null
      },
      {
        "comment_id": "2176033137",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23506,
        "pr_file": "applicationset/controllers/applicationset_controller.go",
        "discussion_id": "2172823663",
        "commented_code": "@@ -225,25 +225,31 @@ func (r *ApplicationSetReconciler) Reconcile(ctx context.Context, req ctrl.Reque\n \t\t\t\tappMap[app.Name] = app\n \t\t\t}\n \n-\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, desiredApplications, appMap)\n+\t\t\tappSyncMap, err = r.performProgressiveSyncs(ctx, logCtx, applicationSetInfo, currentApplications, generatedApplications, appMap)\n \t\t\tif err != nil {\n \t\t\t\treturn ctrl.Result{}, fmt.Errorf(\"failed to perform progressive sync reconciliation for application set: %w\", err)\n \t\t\t}\n \t\t}\n \t}\n \n \tvar validApps []argov1alpha1.Application\n-\tfor i := range desiredApplications {\n-\t\tif validateErrors[i] == nil {\n-\t\t\tvalidApps = append(validApps, desiredApplications[i])\n+\tfor i, app := range generatedApplications {\n+\t\tif validateErrors[app.QualifiedName()] == nil {\n+\t\t\tvalidApps = append(validApps, generatedApplications[i])\n \t\t}\n \t}\n \n \tif len(validateErrors) > 0 {\n+\t\terrorApps := make([]string, 0, len(validateErrors))\n+\t\tfor key := range validateErrors {\n+\t\t\terrorApps = append(errorApps, key)\n+\t\t}\n+\t\tsort.Strings(errorApps)\n+\n \t\tvar message string\n-\t\tfor _, v := range validateErrors {\n-\t\t\tmessage = v.Error()\n-\t\t\tlogCtx.Errorf(\"validation error found during application validation: %s\", message)\n+\t\tfor _, appName := range errorApps {\n+\t\t\tmessage = validateErrors[appName].Error()\n+\t\t\tlogCtx.WithField(\"app\", appName).Errorf(\"validation error found during application validation: %s\", message)",
        "comment_created_at": "2025-06-30T21:54:46+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "Makes sense. At any rate, I'd go with \"application\" instead of \"app\" to match the standard: https://argo-cd.readthedocs.io/en/latest/operator-manual/security/#standard-application-log-fields",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143720179",
    "pr_number": 23361,
    "pr_file": "util/git/client.go",
    "created_at": "2025-06-12T21:51:04+00:00",
    "commented_code": "authorDateUnixTimestamp, _ := strconv.ParseInt(segments[1], 10, 64)\n \tmessage := strings.TrimSpace(segments[2])\n \n+\tcmd := exec.Command(\"git\", \"interpret-trailers\", \"--parse\")\n+\tcmd.Stdin = strings.NewReader(message)\n+\tout, err = m.runCmdOutput(cmd, runOpts{})\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to interpret trailers: %w\", err)\n+\t}\n+\trelatedCommits := getReferences(out)\n+\n \tout, err = m.runCmd(\"tag\", \"--points-at\", revision)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \ttags := strings.Fields(out)\n \n-\treturn &RevisionMetadata{author, time.Unix(authorDateUnixTimestamp, 0), tags, message}, nil\n+\treturn &RevisionMetadata{\n+\t\tAuthor:     author,\n+\t\tDate:       time.Unix(authorDateUnixTimestamp, 0),\n+\t\tTags:       tags,\n+\t\tMessage:    message,\n+\t\tReferences: relatedCommits,\n+\t}, nil\n+}\n+\n+// getReferences extracts related commit metadata from the commit message trailers. If related commit\n+// metadata is present, we return a slice containing a single metadata object. If no related commit metadata is found,\n+// we return a nil slice.\n+func getReferences(commitMessageBody string) []RevisionReference {\n+\tvar relatedCommit CommitMetadata\n+\tfor _, line := range strings.Split(commitMessageBody, \"\n\") {\n+\t\tif !strings.HasPrefix(line, \"Argocd-reference-commit-\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tparts := strings.SplitN(line, \": \", 2)\n+\t\tif len(parts) != 2 {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttrailerKey := parts[0]\n+\t\ttrailerValue := parts[1]\n+\t\tswitch trailerKey {\n+\t\tcase \"Argocd-reference-commit-repourl\":\n+\t\t\t_, err := url.Parse(trailerValue)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Errorf(\"failed to parse repo URL %s: %v\", trailerValue, err)",
    "repo_full_name": "argoproj/argo-cd",
    "discussion_comments": [
      {
        "comment_id": "2143720179",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23361,
        "pr_file": "util/git/client.go",
        "discussion_id": "2143720179",
        "commented_code": "@@ -741,13 +786,77 @@ func (m *nativeGitClient) RevisionMetadata(revision string) (*RevisionMetadata,\n \tauthorDateUnixTimestamp, _ := strconv.ParseInt(segments[1], 10, 64)\n \tmessage := strings.TrimSpace(segments[2])\n \n+\tcmd := exec.Command(\"git\", \"interpret-trailers\", \"--parse\")\n+\tcmd.Stdin = strings.NewReader(message)\n+\tout, err = m.runCmdOutput(cmd, runOpts{})\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to interpret trailers: %w\", err)\n+\t}\n+\trelatedCommits := getReferences(out)\n+\n \tout, err = m.runCmd(\"tag\", \"--points-at\", revision)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \ttags := strings.Fields(out)\n \n-\treturn &RevisionMetadata{author, time.Unix(authorDateUnixTimestamp, 0), tags, message}, nil\n+\treturn &RevisionMetadata{\n+\t\tAuthor:     author,\n+\t\tDate:       time.Unix(authorDateUnixTimestamp, 0),\n+\t\tTags:       tags,\n+\t\tMessage:    message,\n+\t\tReferences: relatedCommits,\n+\t}, nil\n+}\n+\n+// getReferences extracts related commit metadata from the commit message trailers. If related commit\n+// metadata is present, we return a slice containing a single metadata object. If no related commit metadata is found,\n+// we return a nil slice.\n+func getReferences(commitMessageBody string) []RevisionReference {\n+\tvar relatedCommit CommitMetadata\n+\tfor _, line := range strings.Split(commitMessageBody, \"\\n\") {\n+\t\tif !strings.HasPrefix(line, \"Argocd-reference-commit-\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tparts := strings.SplitN(line, \": \", 2)\n+\t\tif len(parts) != 2 {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttrailerKey := parts[0]\n+\t\ttrailerValue := parts[1]\n+\t\tswitch trailerKey {\n+\t\tcase \"Argocd-reference-commit-repourl\":\n+\t\t\t_, err := url.Parse(trailerValue)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Errorf(\"failed to parse repo URL %s: %v\", trailerValue, err)",
        "comment_created_at": "2025-06-12T21:51:04+00:00",
        "comment_author": "agaudreault",
        "comment_body": "any ways to have a logger with some context like the revision / and git repo ?\r\n\r\nIt will be hard to know what caused that error",
        "pr_file_module": null
      },
      {
        "comment_id": "2144019680",
        "repo_full_name": "argoproj/argo-cd",
        "pr_number": 23361,
        "pr_file": "util/git/client.go",
        "discussion_id": "2143720179",
        "commented_code": "@@ -741,13 +786,77 @@ func (m *nativeGitClient) RevisionMetadata(revision string) (*RevisionMetadata,\n \tauthorDateUnixTimestamp, _ := strconv.ParseInt(segments[1], 10, 64)\n \tmessage := strings.TrimSpace(segments[2])\n \n+\tcmd := exec.Command(\"git\", \"interpret-trailers\", \"--parse\")\n+\tcmd.Stdin = strings.NewReader(message)\n+\tout, err = m.runCmdOutput(cmd, runOpts{})\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to interpret trailers: %w\", err)\n+\t}\n+\trelatedCommits := getReferences(out)\n+\n \tout, err = m.runCmd(\"tag\", \"--points-at\", revision)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \ttags := strings.Fields(out)\n \n-\treturn &RevisionMetadata{author, time.Unix(authorDateUnixTimestamp, 0), tags, message}, nil\n+\treturn &RevisionMetadata{\n+\t\tAuthor:     author,\n+\t\tDate:       time.Unix(authorDateUnixTimestamp, 0),\n+\t\tTags:       tags,\n+\t\tMessage:    message,\n+\t\tReferences: relatedCommits,\n+\t}, nil\n+}\n+\n+// getReferences extracts related commit metadata from the commit message trailers. If related commit\n+// metadata is present, we return a slice containing a single metadata object. If no related commit metadata is found,\n+// we return a nil slice.\n+func getReferences(commitMessageBody string) []RevisionReference {\n+\tvar relatedCommit CommitMetadata\n+\tfor _, line := range strings.Split(commitMessageBody, \"\\n\") {\n+\t\tif !strings.HasPrefix(line, \"Argocd-reference-commit-\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tparts := strings.SplitN(line, \": \", 2)\n+\t\tif len(parts) != 2 {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttrailerKey := parts[0]\n+\t\ttrailerValue := parts[1]\n+\t\tswitch trailerKey {\n+\t\tcase \"Argocd-reference-commit-repourl\":\n+\t\t\t_, err := url.Parse(trailerValue)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Errorf(\"failed to parse repo URL %s: %v\", trailerValue, err)",
        "comment_created_at": "2025-06-13T01:16:59+00:00",
        "comment_author": "crenshaw-dev",
        "comment_body": "added revision and repo url",
        "pr_file_module": null
      }
    ]
  }
]