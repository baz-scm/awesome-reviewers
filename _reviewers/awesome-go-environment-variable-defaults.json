[
  {
    "discussion_id": "1860667412",
    "pr_number": 5492,
    "pr_file": "maturity_test.go",
    "created_at": "2024-11-27T13:29:58+00:00",
    "commented_code": "+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/PuerkitoBio/goquery\"\n+)\n+\n+var (\n+\tgithubApiAuthorizationToken = os.Getenv(\"GITHUB_API_TOKEN\")\n+\tminimumMaturityDate         = time.Now().AddDate(0, -5, 0)\n+)\n+\n+func TestMaturity(t *testing.T) {\n+\tdoc := goqueryFromReadme(t)\n+\tdoc.Find(\"body li > a:first-child\").Each(func(_ int, s *goquery.Selection) {\n+\t\tt.Run(s.Text(), func(t *testing.T) {\n+\t\t\thref, ok := s.Attr(\"href\")\n+\t\t\tif !ok {\n+\t\t\t\tt.Error(\"expected to have href\")\n+\t\t\t}\n+\n+\t\t\tmatches := reGithubRepo.FindStringSubmatch(href)\n+\t\t\tif matches == nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif len(matches) != 3 {\n+\t\t\t\tt.Fatalf(\"failed to extract repo and user from: %s, got [%v]\", href, strings.Join(matches, \", \"))\n+\t\t\t}\n+\n+\t\t\tif err := checkRepositoryMaturity(matches[1], matches[2]); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t})\n+\t})\n+}\n+\n+func checkRepositoryMaturity(user, repo string) error {\n+\tuntil := minimumMaturityDate.Format(time.RFC3339)\n+\turl := fmt.Sprintf(\"https://api.github.com/repos/%s/%s/commits?per_page=1&until=%s\", user, repo, until)\n+\trequest, err := http.NewRequest(http.MethodGet, url, nil)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create request for `%s`, %v\", url, err)\n+\t}\n+\n+\trequest.Header.Set(\"Accept\", \"application/vnd.github+json\")\n+\trequest.Header.Set(\"X-GitHub-Api-Version\", \"2022-11-28\")\n+\trequest.Header.Set(\"User-Agent\", \"avelino\")",
    "repo_full_name": "avelino/awesome-go",
    "discussion_comments": [
      {
        "comment_id": "1860667412",
        "repo_full_name": "avelino/awesome-go",
        "pr_number": 5492,
        "pr_file": "maturity_test.go",
        "discussion_id": "1860667412",
        "commented_code": "@@ -0,0 +1,77 @@\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/PuerkitoBio/goquery\"\n+)\n+\n+var (\n+\tgithubApiAuthorizationToken = os.Getenv(\"GITHUB_API_TOKEN\")\n+\tminimumMaturityDate         = time.Now().AddDate(0, -5, 0)\n+)\n+\n+func TestMaturity(t *testing.T) {\n+\tdoc := goqueryFromReadme(t)\n+\tdoc.Find(\"body li > a:first-child\").Each(func(_ int, s *goquery.Selection) {\n+\t\tt.Run(s.Text(), func(t *testing.T) {\n+\t\t\thref, ok := s.Attr(\"href\")\n+\t\t\tif !ok {\n+\t\t\t\tt.Error(\"expected to have href\")\n+\t\t\t}\n+\n+\t\t\tmatches := reGithubRepo.FindStringSubmatch(href)\n+\t\t\tif matches == nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif len(matches) != 3 {\n+\t\t\t\tt.Fatalf(\"failed to extract repo and user from: %s, got [%v]\", href, strings.Join(matches, \", \"))\n+\t\t\t}\n+\n+\t\t\tif err := checkRepositoryMaturity(matches[1], matches[2]); err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t})\n+\t})\n+}\n+\n+func checkRepositoryMaturity(user, repo string) error {\n+\tuntil := minimumMaturityDate.Format(time.RFC3339)\n+\turl := fmt.Sprintf(\"https://api.github.com/repos/%s/%s/commits?per_page=1&until=%s\", user, repo, until)\n+\trequest, err := http.NewRequest(http.MethodGet, url, nil)\n+\tif err != nil {\n+\t\treturn fmt.Errorf(\"failed to create request for `%s`, %v\", url, err)\n+\t}\n+\n+\trequest.Header.Set(\"Accept\", \"application/vnd.github+json\")\n+\trequest.Header.Set(\"X-GitHub-Api-Version\", \"2022-11-28\")\n+\trequest.Header.Set(\"User-Agent\", \"avelino\")",
        "comment_created_at": "2024-11-27T13:29:58+00:00",
        "comment_author": "ccoVeille",
        "comment_body": "The user agent could be a env variable too. And you should have a default one, one that respect the UserAgent format",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "482803361",
    "pr_number": 3210,
    "pr_file": "test_stale_repositories.go",
    "created_at": "2020-09-03T08:32:08+00:00",
    "commented_code": "+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"strings\"\n+\t\"text/template\"\n+\t\"time\"\n+\n+\t\"github.com/PuerkitoBio/goquery\"\n+\t\"golang.org/x/oauth2\"\n+)\n+\n+const issueTemplate = `\n+{{range .}}\n+- [ ] {{.}}\n+{{end}}\n+`\n+\n+var reGithubRepo = regexp.MustCompile(\"https://github.com/[a-zA-Z0-9-.]+/[a-zA-Z0-9-.]+$\")\n+var githubGETCOMMITS = \"https://api.github.com/repos%s/commits\"\n+var githubPOSTISSUES = \"https://api.github.com/repos/mrKappen/awesome-go/issues\"\n+var awesomeGoGETISSUES = \"http://api.github.com/repos/mrKappen/awesome-go/issues\" //only returns open issues\n+var numberOfYears time.Duration = 1\n+\n+const issueTitle = \"Investigate repositories with more than 1 year without update\"\n+const deadLinkMessage = \" this repository might no longer exist! (status code >= 400 returned)\"\n+const movedPermanently = \" status code 301 received\"\n+const status302 = \" status code 302 received\"\n+\n+var delay time.Duration = 1\n+\n+//LIMIT specifies the max number of repositories that are added in a single run of the script\n+var LIMIT = 10\n+var ctr = 0\n+\n+type tokenSource struct {\n+\tAccessToken string\n+}\n+type issue struct {\n+\tTitle string `json:\"title\"`\n+\tBody  string `json:\"body\"`\n+}\n+\n+func (t *tokenSource) Token() (*oauth2.Token, error) {\n+\ttoken := &oauth2.Token{\n+\t\tAccessToken: t.AccessToken,\n+\t}\n+\treturn token, nil\n+}\n+func getRepositoriesFromBody(body string) []string {\n+\tlinks := strings.Split(body, \"- \")\n+\tfor idx, link := range links {\n+\t\tstr := strings.ReplaceAll(link, \"\\r\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"[ ]\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"[x]\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \" \", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"\n\", \"\")\n+\t\tstr = strings.ReplaceAll(str, deadLinkMessage, \"\")\n+\t\tstr = strings.ReplaceAll(str, movedPermanently, \"\")\n+\t\tstr = strings.ReplaceAll(str, status302, \"\")\n+\t\tlinks[idx] = str\n+\t}\n+\treturn links\n+}\n+func generateIssueBody(repositories []string) (string, error) {\n+\tvar writer bytes.Buffer\n+\tt := template.New(\"issue\")\n+\ttemp, err := t.Parse(issueTemplate)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to generate template\")\n+\t\treturn \"\", err\n+\t}\n+\terr = temp.Execute(&writer, repositories)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to generate template\")\n+\t\treturn \"\", err\n+\t}\n+\tissueBody := writer.String()\n+\treturn issueBody, nil\n+}\n+func createIssue(staleRepos []string, oauthClient *http.Client) {\n+\tif len(staleRepos) == 0 {\n+\t\tlog.Print(\"NO STALE REPOSITORIES\")\n+\t\treturn\n+\t}\n+\tbody, err := generateIssueBody(staleRepos)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed at CreateIssue\")\n+\t\treturn\n+\t}\n+\tnewIssue := &issue{\n+\t\tTitle: issueTitle,\n+\t\tBody:  body,\n+\t}\n+\tbuf := new(bytes.Buffer)\n+\tjson.NewEncoder(buf).Encode(newIssue)\n+\treq, err := http.NewRequest(\"POST\", githubPOSTISSUES, buf)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed at CreateIssue\")\n+\t\treturn\n+\t}\n+\toauthClient.Do(req)\n+}\n+func getAllFlaggedRepositories(oauthClient *http.Client, flaggedRepositories *map[string]bool) error {\n+\treq, err := http.NewRequest(\"GET\", awesomeGoGETISSUES, nil)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to get all issues\")\n+\t\treturn err\n+\t}\n+\tres, err := oauthClient.Do(req)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to get all issues\")\n+\t\treturn err\n+\t}\n+\ttarget := []issue{}\n+\tdefer res.Body.Close()\n+\tjson.NewDecoder(res.Body).Decode(&target)\n+\tfor _, i := range target {\n+\t\tif i.Title == issueTitle {\n+\t\t\trepos := getRepositoriesFromBody(i.Body)\n+\t\t\tfmt.Println(repos)\n+\t\t\tfor _, repo := range repos {\n+\t\t\t\t(*flaggedRepositories)[repo] = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+func containsOpenIssue(link string, openIssues map[string]bool) bool {\n+\t_, ok := openIssues[link]\n+\tif ok {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+func testCommitAge(href string, oauthClient *http.Client, staleRepos *[]string, openIssues map[string]bool) {\n+\tvar isValidRepo bool\n+\tvar isAged bool\n+\tvar ownerRepo string\n+\tisValidRepo = reGithubRepo.MatchString(href)\n+\tvar apiCall string\n+\tvar respObj []map[string]interface{}\n+\tnow := time.Now()\n+\tsince := now.Add(-1 * 365 * 24 * numberOfYears * time.Hour)\n+\tsinceQuery := since.Format(time.RFC3339)\n+\tif isValidRepo {\n+\t\tissueExists := containsOpenIssue(href, openIssues)\n+\t\tif issueExists {\n+\t\t\tlog.Printf(\"issue already exists for %s\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\townerRepo = strings.ReplaceAll(href, \"https://github.com\", \"\")\n+\t\tapiCall = fmt.Sprintf(githubGETCOMMITS, ownerRepo)\n+\t\treq, err := http.NewRequest(\"GET\", apiCall, nil)\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"Failed at repository %s\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\tq := req.URL.Query()\n+\t\tq.Add(\"since\", sinceQuery)\n+\t\treq.URL.RawQuery = q.Encode()\n+\t\tresp, err := oauthClient.Do(req)\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"Failed at repository %s\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer resp.Body.Close()\n+\t\tif resp.StatusCode == 301 {\n+\t\t\t*staleRepos = append(*staleRepos, href+movedPermanently)\n+\t\t\tlog.Printf(\"%s returned 301\", href)\n+\t\t} else if resp.StatusCode == 302 {\n+\t\t\t*staleRepos = append(*staleRepos, href+status302)\n+\t\t\tlog.Printf(\"%s returned 302\", href)\n+\t\t} else if resp.StatusCode >= 400 {\n+\t\t\t*staleRepos = append(*staleRepos, href+deadLinkMessage)\n+\t\t\tlog.Printf(\"%s might not exist!\", href)\n+\t\t} else {\n+\t\t\tjson.NewDecoder(resp.Body).Decode(&respObj)\n+\t\t\tisAged = len(respObj) == 0\n+\t\t}\n+\t\tif isAged {\n+\t\t\tlog.Printf(\"%s has not had a commit in a while\", href)\n+\t\t\t*staleRepos = append(*staleRepos, href)\n+\t\t\tctr++\n+\t\t}\n+\t}\n+}\n+func testStaleRepository() {\n+\tquery := startQuery()\n+\tvar staleRepos []string\n+\taddressedRepositories := make(map[string]bool)\n+\toauth := os.Getenv(\"GITHUB_OAUTH_TOKEN\")",
    "repo_full_name": "avelino/awesome-go",
    "discussion_comments": [
      {
        "comment_id": "482803361",
        "repo_full_name": "avelino/awesome-go",
        "pr_number": 3210,
        "pr_file": "test_stale_repositories.go",
        "discussion_id": "482803361",
        "commented_code": "@@ -0,0 +1,233 @@\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"strings\"\n+\t\"text/template\"\n+\t\"time\"\n+\n+\t\"github.com/PuerkitoBio/goquery\"\n+\t\"golang.org/x/oauth2\"\n+)\n+\n+const issueTemplate = `\n+{{range .}}\n+- [ ] {{.}}\n+{{end}}\n+`\n+\n+var reGithubRepo = regexp.MustCompile(\"https://github.com/[a-zA-Z0-9-.]+/[a-zA-Z0-9-.]+$\")\n+var githubGETCOMMITS = \"https://api.github.com/repos%s/commits\"\n+var githubPOSTISSUES = \"https://api.github.com/repos/mrKappen/awesome-go/issues\"\n+var awesomeGoGETISSUES = \"http://api.github.com/repos/mrKappen/awesome-go/issues\" //only returns open issues\n+var numberOfYears time.Duration = 1\n+\n+const issueTitle = \"Investigate repositories with more than 1 year without update\"\n+const deadLinkMessage = \" this repository might no longer exist! (status code >= 400 returned)\"\n+const movedPermanently = \" status code 301 received\"\n+const status302 = \" status code 302 received\"\n+\n+var delay time.Duration = 1\n+\n+//LIMIT specifies the max number of repositories that are added in a single run of the script\n+var LIMIT = 10\n+var ctr = 0\n+\n+type tokenSource struct {\n+\tAccessToken string\n+}\n+type issue struct {\n+\tTitle string `json:\"title\"`\n+\tBody  string `json:\"body\"`\n+}\n+\n+func (t *tokenSource) Token() (*oauth2.Token, error) {\n+\ttoken := &oauth2.Token{\n+\t\tAccessToken: t.AccessToken,\n+\t}\n+\treturn token, nil\n+}\n+func getRepositoriesFromBody(body string) []string {\n+\tlinks := strings.Split(body, \"- \")\n+\tfor idx, link := range links {\n+\t\tstr := strings.ReplaceAll(link, \"\\r\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"[ ]\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"[x]\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \" \", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"\\n\", \"\")\n+\t\tstr = strings.ReplaceAll(str, deadLinkMessage, \"\")\n+\t\tstr = strings.ReplaceAll(str, movedPermanently, \"\")\n+\t\tstr = strings.ReplaceAll(str, status302, \"\")\n+\t\tlinks[idx] = str\n+\t}\n+\treturn links\n+}\n+func generateIssueBody(repositories []string) (string, error) {\n+\tvar writer bytes.Buffer\n+\tt := template.New(\"issue\")\n+\ttemp, err := t.Parse(issueTemplate)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to generate template\")\n+\t\treturn \"\", err\n+\t}\n+\terr = temp.Execute(&writer, repositories)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to generate template\")\n+\t\treturn \"\", err\n+\t}\n+\tissueBody := writer.String()\n+\treturn issueBody, nil\n+}\n+func createIssue(staleRepos []string, oauthClient *http.Client) {\n+\tif len(staleRepos) == 0 {\n+\t\tlog.Print(\"NO STALE REPOSITORIES\")\n+\t\treturn\n+\t}\n+\tbody, err := generateIssueBody(staleRepos)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed at CreateIssue\")\n+\t\treturn\n+\t}\n+\tnewIssue := &issue{\n+\t\tTitle: issueTitle,\n+\t\tBody:  body,\n+\t}\n+\tbuf := new(bytes.Buffer)\n+\tjson.NewEncoder(buf).Encode(newIssue)\n+\treq, err := http.NewRequest(\"POST\", githubPOSTISSUES, buf)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed at CreateIssue\")\n+\t\treturn\n+\t}\n+\toauthClient.Do(req)\n+}\n+func getAllFlaggedRepositories(oauthClient *http.Client, flaggedRepositories *map[string]bool) error {\n+\treq, err := http.NewRequest(\"GET\", awesomeGoGETISSUES, nil)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to get all issues\")\n+\t\treturn err\n+\t}\n+\tres, err := oauthClient.Do(req)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to get all issues\")\n+\t\treturn err\n+\t}\n+\ttarget := []issue{}\n+\tdefer res.Body.Close()\n+\tjson.NewDecoder(res.Body).Decode(&target)\n+\tfor _, i := range target {\n+\t\tif i.Title == issueTitle {\n+\t\t\trepos := getRepositoriesFromBody(i.Body)\n+\t\t\tfmt.Println(repos)\n+\t\t\tfor _, repo := range repos {\n+\t\t\t\t(*flaggedRepositories)[repo] = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+func containsOpenIssue(link string, openIssues map[string]bool) bool {\n+\t_, ok := openIssues[link]\n+\tif ok {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+func testCommitAge(href string, oauthClient *http.Client, staleRepos *[]string, openIssues map[string]bool) {\n+\tvar isValidRepo bool\n+\tvar isAged bool\n+\tvar ownerRepo string\n+\tisValidRepo = reGithubRepo.MatchString(href)\n+\tvar apiCall string\n+\tvar respObj []map[string]interface{}\n+\tnow := time.Now()\n+\tsince := now.Add(-1 * 365 * 24 * numberOfYears * time.Hour)\n+\tsinceQuery := since.Format(time.RFC3339)\n+\tif isValidRepo {\n+\t\tissueExists := containsOpenIssue(href, openIssues)\n+\t\tif issueExists {\n+\t\t\tlog.Printf(\"issue already exists for %s\\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\townerRepo = strings.ReplaceAll(href, \"https://github.com\", \"\")\n+\t\tapiCall = fmt.Sprintf(githubGETCOMMITS, ownerRepo)\n+\t\treq, err := http.NewRequest(\"GET\", apiCall, nil)\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"Failed at repository %s\\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\tq := req.URL.Query()\n+\t\tq.Add(\"since\", sinceQuery)\n+\t\treq.URL.RawQuery = q.Encode()\n+\t\tresp, err := oauthClient.Do(req)\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"Failed at repository %s\\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer resp.Body.Close()\n+\t\tif resp.StatusCode == 301 {\n+\t\t\t*staleRepos = append(*staleRepos, href+movedPermanently)\n+\t\t\tlog.Printf(\"%s returned 301\", href)\n+\t\t} else if resp.StatusCode == 302 {\n+\t\t\t*staleRepos = append(*staleRepos, href+status302)\n+\t\t\tlog.Printf(\"%s returned 302\", href)\n+\t\t} else if resp.StatusCode >= 400 {\n+\t\t\t*staleRepos = append(*staleRepos, href+deadLinkMessage)\n+\t\t\tlog.Printf(\"%s might not exist!\", href)\n+\t\t} else {\n+\t\t\tjson.NewDecoder(resp.Body).Decode(&respObj)\n+\t\t\tisAged = len(respObj) == 0\n+\t\t}\n+\t\tif isAged {\n+\t\t\tlog.Printf(\"%s has not had a commit in a while\", href)\n+\t\t\t*staleRepos = append(*staleRepos, href)\n+\t\t\tctr++\n+\t\t}\n+\t}\n+}\n+func testStaleRepository() {\n+\tquery := startQuery()\n+\tvar staleRepos []string\n+\taddressedRepositories := make(map[string]bool)\n+\toauth := os.Getenv(\"GITHUB_OAUTH_TOKEN\")",
        "comment_created_at": "2020-09-03T08:32:08+00:00",
        "comment_author": "avelino",
        "comment_body": "as variable environment setting in github workflow `GITHUB_OAUTH_TOKEN`",
        "pr_file_module": null
      },
      {
        "comment_id": "483098417",
        "repo_full_name": "avelino/awesome-go",
        "pr_number": 3210,
        "pr_file": "test_stale_repositories.go",
        "discussion_id": "482803361",
        "commented_code": "@@ -0,0 +1,233 @@\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"regexp\"\n+\t\"strings\"\n+\t\"text/template\"\n+\t\"time\"\n+\n+\t\"github.com/PuerkitoBio/goquery\"\n+\t\"golang.org/x/oauth2\"\n+)\n+\n+const issueTemplate = `\n+{{range .}}\n+- [ ] {{.}}\n+{{end}}\n+`\n+\n+var reGithubRepo = regexp.MustCompile(\"https://github.com/[a-zA-Z0-9-.]+/[a-zA-Z0-9-.]+$\")\n+var githubGETCOMMITS = \"https://api.github.com/repos%s/commits\"\n+var githubPOSTISSUES = \"https://api.github.com/repos/mrKappen/awesome-go/issues\"\n+var awesomeGoGETISSUES = \"http://api.github.com/repos/mrKappen/awesome-go/issues\" //only returns open issues\n+var numberOfYears time.Duration = 1\n+\n+const issueTitle = \"Investigate repositories with more than 1 year without update\"\n+const deadLinkMessage = \" this repository might no longer exist! (status code >= 400 returned)\"\n+const movedPermanently = \" status code 301 received\"\n+const status302 = \" status code 302 received\"\n+\n+var delay time.Duration = 1\n+\n+//LIMIT specifies the max number of repositories that are added in a single run of the script\n+var LIMIT = 10\n+var ctr = 0\n+\n+type tokenSource struct {\n+\tAccessToken string\n+}\n+type issue struct {\n+\tTitle string `json:\"title\"`\n+\tBody  string `json:\"body\"`\n+}\n+\n+func (t *tokenSource) Token() (*oauth2.Token, error) {\n+\ttoken := &oauth2.Token{\n+\t\tAccessToken: t.AccessToken,\n+\t}\n+\treturn token, nil\n+}\n+func getRepositoriesFromBody(body string) []string {\n+\tlinks := strings.Split(body, \"- \")\n+\tfor idx, link := range links {\n+\t\tstr := strings.ReplaceAll(link, \"\\r\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"[ ]\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"[x]\", \"\")\n+\t\tstr = strings.ReplaceAll(str, \" \", \"\")\n+\t\tstr = strings.ReplaceAll(str, \"\\n\", \"\")\n+\t\tstr = strings.ReplaceAll(str, deadLinkMessage, \"\")\n+\t\tstr = strings.ReplaceAll(str, movedPermanently, \"\")\n+\t\tstr = strings.ReplaceAll(str, status302, \"\")\n+\t\tlinks[idx] = str\n+\t}\n+\treturn links\n+}\n+func generateIssueBody(repositories []string) (string, error) {\n+\tvar writer bytes.Buffer\n+\tt := template.New(\"issue\")\n+\ttemp, err := t.Parse(issueTemplate)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to generate template\")\n+\t\treturn \"\", err\n+\t}\n+\terr = temp.Execute(&writer, repositories)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to generate template\")\n+\t\treturn \"\", err\n+\t}\n+\tissueBody := writer.String()\n+\treturn issueBody, nil\n+}\n+func createIssue(staleRepos []string, oauthClient *http.Client) {\n+\tif len(staleRepos) == 0 {\n+\t\tlog.Print(\"NO STALE REPOSITORIES\")\n+\t\treturn\n+\t}\n+\tbody, err := generateIssueBody(staleRepos)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed at CreateIssue\")\n+\t\treturn\n+\t}\n+\tnewIssue := &issue{\n+\t\tTitle: issueTitle,\n+\t\tBody:  body,\n+\t}\n+\tbuf := new(bytes.Buffer)\n+\tjson.NewEncoder(buf).Encode(newIssue)\n+\treq, err := http.NewRequest(\"POST\", githubPOSTISSUES, buf)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed at CreateIssue\")\n+\t\treturn\n+\t}\n+\toauthClient.Do(req)\n+}\n+func getAllFlaggedRepositories(oauthClient *http.Client, flaggedRepositories *map[string]bool) error {\n+\treq, err := http.NewRequest(\"GET\", awesomeGoGETISSUES, nil)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to get all issues\")\n+\t\treturn err\n+\t}\n+\tres, err := oauthClient.Do(req)\n+\tif err != nil {\n+\t\tlog.Print(\"Failed to get all issues\")\n+\t\treturn err\n+\t}\n+\ttarget := []issue{}\n+\tdefer res.Body.Close()\n+\tjson.NewDecoder(res.Body).Decode(&target)\n+\tfor _, i := range target {\n+\t\tif i.Title == issueTitle {\n+\t\t\trepos := getRepositoriesFromBody(i.Body)\n+\t\t\tfmt.Println(repos)\n+\t\t\tfor _, repo := range repos {\n+\t\t\t\t(*flaggedRepositories)[repo] = true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+func containsOpenIssue(link string, openIssues map[string]bool) bool {\n+\t_, ok := openIssues[link]\n+\tif ok {\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+func testCommitAge(href string, oauthClient *http.Client, staleRepos *[]string, openIssues map[string]bool) {\n+\tvar isValidRepo bool\n+\tvar isAged bool\n+\tvar ownerRepo string\n+\tisValidRepo = reGithubRepo.MatchString(href)\n+\tvar apiCall string\n+\tvar respObj []map[string]interface{}\n+\tnow := time.Now()\n+\tsince := now.Add(-1 * 365 * 24 * numberOfYears * time.Hour)\n+\tsinceQuery := since.Format(time.RFC3339)\n+\tif isValidRepo {\n+\t\tissueExists := containsOpenIssue(href, openIssues)\n+\t\tif issueExists {\n+\t\t\tlog.Printf(\"issue already exists for %s\\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\townerRepo = strings.ReplaceAll(href, \"https://github.com\", \"\")\n+\t\tapiCall = fmt.Sprintf(githubGETCOMMITS, ownerRepo)\n+\t\treq, err := http.NewRequest(\"GET\", apiCall, nil)\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"Failed at repository %s\\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\tq := req.URL.Query()\n+\t\tq.Add(\"since\", sinceQuery)\n+\t\treq.URL.RawQuery = q.Encode()\n+\t\tresp, err := oauthClient.Do(req)\n+\t\tif err != nil {\n+\t\t\tlog.Printf(\"Failed at repository %s\\n\", href)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer resp.Body.Close()\n+\t\tif resp.StatusCode == 301 {\n+\t\t\t*staleRepos = append(*staleRepos, href+movedPermanently)\n+\t\t\tlog.Printf(\"%s returned 301\", href)\n+\t\t} else if resp.StatusCode == 302 {\n+\t\t\t*staleRepos = append(*staleRepos, href+status302)\n+\t\t\tlog.Printf(\"%s returned 302\", href)\n+\t\t} else if resp.StatusCode >= 400 {\n+\t\t\t*staleRepos = append(*staleRepos, href+deadLinkMessage)\n+\t\t\tlog.Printf(\"%s might not exist!\", href)\n+\t\t} else {\n+\t\t\tjson.NewDecoder(resp.Body).Decode(&respObj)\n+\t\t\tisAged = len(respObj) == 0\n+\t\t}\n+\t\tif isAged {\n+\t\t\tlog.Printf(\"%s has not had a commit in a while\", href)\n+\t\t\t*staleRepos = append(*staleRepos, href)\n+\t\t\tctr++\n+\t\t}\n+\t}\n+}\n+func testStaleRepository() {\n+\tquery := startQuery()\n+\tvar staleRepos []string\n+\taddressedRepositories := make(map[string]bool)\n+\toauth := os.Getenv(\"GITHUB_OAUTH_TOKEN\")",
        "comment_created_at": "2020-09-03T16:14:52+00:00",
        "comment_author": "mrKappen",
        "comment_body": "added environment variable OAUTH_TOKEN. @avelino, you need to create a new OAUTH token and create a secret for this repository with the same name",
        "pr_file_module": null
      }
    ]
  }
]