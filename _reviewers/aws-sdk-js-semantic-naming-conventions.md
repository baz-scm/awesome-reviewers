---
title: Semantic naming conventions
description: 'Use descriptive, semantic names for all code elements that clearly indicate
  their purpose and behavior. Follow consistent casing patterns throughout the codebase:'
repository: aws/aws-sdk-js
label: Naming Conventions
language: Javascript
comments_count: 6
repository_stars: 7628
---

Use descriptive, semantic names for all code elements that clearly indicate their purpose and behavior. Follow consistent casing patterns throughout the codebase:

- camelCase for variables, properties, and method names (e.g., 'useDualstack', 'bucketExists')
- PascalCase for class names and type definitions
- When naming functions, prefer names that describe what the function does rather than implementation details (e.g., 'buildMessage' is clearer than 'formatMessage')
- Avoid abbreviations that aren't widely understood (e.g., use 'optionalDiscoveryEndpoint' instead of 'optionalDisverEndpoint')
- When type names conflict with JavaScript primitives, use a prefix (e.g., '_Date') rather than skipping the type definition entirely to prevent runtime errors

```javascript
// Poor naming
function getServiceClock() {
  return new Date(Date.now() + this.config.systemClockOffset);
}

// Better naming
function getSkewCorrectedDate() {
  return new Date(Date.now() + this.config.systemClockOffset);
}

// Poor type handling - skipping shapes that match JavaScript primitives
if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {
  return '';
}

// Better type handling - using prefix to preserve shape names
if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {
  code += 'export type _' + shapeKey + ' = ' + getTypeMapping(shape.type) + ';\n';
  return code;
}
```


[
  {
    "discussion_id": "1013368805",
    "pr_number": 4261,
    "pr_file": "lib/services/resourceexplorer2.js",
    "created_at": "2022-11-03T20:29:07+00:00",
    "commented_code": "var AWS = require('../core');\n\nAWS.util.update(AWS.ResourceExplorer2.prototype, {\n  validateService: function () {\n    var config = this.config;\n    if (config.useDualstackEndpoint === false || config.useDualStack === false) {",
    "repo_full_name": "aws/aws-sdk-js",
    "discussion_comments": [
      {
        "comment_id": "1013368805",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 4261,
        "pr_file": "lib/services/resourceexplorer2.js",
        "discussion_id": "1013368805",
        "commented_code": "@@ -0,0 +1,12 @@\n+var AWS = require('../core');\n+\n+AWS.util.update(AWS.ResourceExplorer2.prototype, {\n+  validateService: function () {\n+    var config = this.config;\n+    if (config.useDualstackEndpoint === false || config.useDualStack === false) {",
        "comment_created_at": "2022-11-03T20:29:07+00:00",
        "comment_author": "kuhe",
        "comment_body": "use this casing: `useDualstack`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "85186711",
    "pr_number": 1189,
    "pr_file": "scripts/lib/ts-generator.js",
    "created_at": "2016-10-26T18:17:43+00:00",
    "commented_code": "var fs = require('fs');\nvar path = require('path');\n\nvar CUSTOM_CONFIG_ENUMS = {\n    DUALSTACK: {\n        FILE_NAME: 'config_use_dualstack',\n        INTERFACE: 'UseDualstackConfigOptions'\n    }\n};\n\nfunction TSGenerator(options) {\n    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n    this._apiRootDir = path.join(this._sdkRootDir, 'apis');\n    this._metadataPath = path.join(this._apiRootDir, 'metadata.json');\n    this._clientsDir = path.join(this._sdkRootDir, 'clients');\n    this.metadata = null;\n    this.typings = {};\n    this.fillApiModelFileNames(this._apiRootDir);\n}\n\n/**\n * Loads the AWS SDK metadata.json file.\n */\nTSGenerator.prototype.loadMetadata = function loadMetadata() {\n    var metadataFile = fs.readFileSync(this._metadataPath);\n    this.metadata = JSON.parse(metadataFile);\n    return this.metadata;\n};\n\n/**\n * Modifies metadata to include api model filenames.\n */\nTSGenerator.prototype.fillApiModelFileNames = function fillApiModelFileNames(apisPath) {\n    var modelPaths = fs.readdirSync(apisPath);\n    if (!this.metadata) {\n        this.loadMetadata();\n    }\n    var metadata = this.metadata;\n\n    // sort paths so latest versions appear first\n    modelPaths = modelPaths.sort(function sort(a, b) {\n        if (a < b) {\n            return 1;\n        } else if (a > b) {\n            return -1;\n        } else {\n            return 0;\n        }\n    });\n\n    // Only get latest version of models\n    var foundModels = Object.create(null);\n    modelPaths.forEach(function(modelFileName) {\n        var match = modelFileName.match(/^(.+)(-[\\d]{4}-[\\d]{2}-[\\d]{2})\\.normal\\.json$/i);\n        if (match) {\n            var model = match[1];\n            if (!foundModels[model]) {\n                foundModels[model] = modelFileName;\n            }\n        }\n    });\n\n    // now update the metadata\n    var keys = Object.keys(metadata);\n    keys.forEach(function(key) {\n        var modelName = metadata[key].prefix || key;\n        metadata[key].api_path = foundModels[modelName];\n        // find waiters file\n        var baseName = foundModels[modelName].split('.')[0];\n        if (modelPaths.indexOf(baseName + '.waiters2.json') >= 0) {\n            metadata[key].waiters_path = baseName + '.waiters2.json';\n        }\n    });\n};\n\n/**\n * Generates the file containing DocumentClient interfaces.\n */\nTSGenerator.prototype.generateDocumentClientInterfaces = function generateDocumentClientInterfaces() {\n    var self = this;\n    // get the dynamodb model\n    var dynamodbModel = this.loadServiceApi('dynamodb');\n    var code = '';\n    // include node reference\n    code += '///<reference types=\"node\" />\\n';\n    // generate shapes\n    var modelShapes = dynamodbModel.shapes;\n    // iterate over each shape\n    var shapeKeys = Object.keys(modelShapes);\n    shapeKeys.forEach(function (shapeKey) {\n        var modelShape = modelShapes[shapeKey];\n        // ignore exceptions\n        if (modelShape.exception) {\n            return;\n        }\n        // overwrite AttributeValue\n        if (shapeKey === 'AttributeValue') {\n            code += self.generateDocString('A JavaScript object or native type.');\n            code += 'export type ' + shapeKey + ' = any;\\n';\n            return;\n        }\n        code += self.generateTypingsFromShape(shapeKey, modelShape);\n    });\n\n    // write file:\n    this.writeTypingsFile('document_client_interfaces', path.join(this._sdkRootDir, 'lib', 'dynamodb'), code);\n};\n\n/**\n * Returns a service model based on the serviceIdentifier.\n */\nTSGenerator.prototype.loadServiceApi = function loadServiceApi(serviceIdentifier) {\n    // first, find the correct identifier\n    var metadata = this.metadata;\n    var serviceFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].api_path);\n    var serviceModelFile = fs.readFileSync(serviceFilePath);\n    var serviceModel = JSON.parse(serviceModelFile);\n    // load waiters file if it exists\n    var waiterFilePath;\n    if (metadata[serviceIdentifier].waiters_path) {\n        waiterFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].waiters_path);\n        var waiterModelFile = fs.readFileSync(waiterFilePath);\n        var waiterModel = JSON.parse(waiterModelFile);\n        serviceModel.waiters = waiterModel.waiters;\n    }\n\n    return serviceModel;\n};\n\n/**\n * Determines if a member is required by checking for it in a list.\n */\nTSGenerator.prototype.checkRequired = function checkRequired(list, member) {\n    if (list.indexOf(member)) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Generates whitespace based on the count.\n */\nTSGenerator.prototype.tabs = function tabs(count) {\n    var code = '';\n    for (var i = 0; i < count; i++) {\n        code += '  ';\n    }\n    return code;\n};\n\n/**\n * Transforms documentation string to a more readable format.\n */\nTSGenerator.prototype.transformDocumentation = function transformDocumentation(documentation) {\n    if (!documentation) {\n        return '';\n    }\n    documentation = documentation.replace(/<(?:.|\\n)*?>/gm, '');\n    documentation = documentation.replace(/\\*\\//g, '*');\n    return documentation;\n};\n\n/**\n * Returns a doc string based on the supplied documentation.\n * Also tabs the doc string if a count is provided.\n */\nTSGenerator.prototype.generateDocString = function generateDocString(documentation, tabCount) {\n    tabCount = tabCount || 0;\n    var code = '';\n    code += this.tabs(tabCount) + '/**\\n';\n    code += this.tabs(tabCount) + ' * ' + this.transformDocumentation(documentation) + '\\n';\n    code += this.tabs(tabCount) + ' */\\n';\n    return code;\n};\n\n/**\n * Returns an array of custom configuration options based on a service identiffier.\n * Custom configuration options are determined by checking the metadata.json file.\n */\nTSGenerator.prototype.generateCustomConfigFromMetadata = function generateCustomConfigFromMetadata(serviceIdentifier) {\n    // some services have additional configuration options that are defined in the metadata.json file\n    // i.e. dualstackAvailable = useDualstack\n    // create reference to custom options\n    var customConfigurations = [];\n    var serviceMetadata = this.metadata[serviceIdentifier];\n    // loop through metadata members\n    for (var memberName in serviceMetadata) {\n        if (!serviceMetadata.hasOwnProperty(memberName)) {\n            continue;\n        }\n        var memberValue = serviceMetadata[memberName];\n        // check configs\n        switch (memberName) {\n            case 'dualstackAvailable':\n                customConfigurations.push(CUSTOM_CONFIG_ENUMS.DUALSTACK);\n                break;\n        }\n    }\n\n    return customConfigurations;\n};\n\n/**\n * Generates a type or interface based on the shape.\n */\nTSGenerator.prototype.generateTypingsFromShape = function generateTypingsFromShape(shapeKey, shape, tabCount) {\n    // some shapes shouldn't be generated if they are javascript primitives\n    if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {\n        return '';",
    "repo_full_name": "aws/aws-sdk-js",
    "discussion_comments": [
      {
        "comment_id": "85186711",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 1189,
        "pr_file": "scripts/lib/ts-generator.js",
        "discussion_id": "85186711",
        "commented_code": "@@ -0,0 +1,437 @@\n+var fs = require('fs');\n+var path = require('path');\n+\n+var CUSTOM_CONFIG_ENUMS = {\n+    DUALSTACK: {\n+        FILE_NAME: 'config_use_dualstack',\n+        INTERFACE: 'UseDualstackConfigOptions'\n+    }\n+};\n+\n+function TSGenerator(options) {\n+    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n+    this._apiRootDir = path.join(this._sdkRootDir, 'apis');\n+    this._metadataPath = path.join(this._apiRootDir, 'metadata.json');\n+    this._clientsDir = path.join(this._sdkRootDir, 'clients');\n+    this.metadata = null;\n+    this.typings = {};\n+    this.fillApiModelFileNames(this._apiRootDir);\n+}\n+\n+/**\n+ * Loads the AWS SDK metadata.json file.\n+ */\n+TSGenerator.prototype.loadMetadata = function loadMetadata() {\n+    var metadataFile = fs.readFileSync(this._metadataPath);\n+    this.metadata = JSON.parse(metadataFile);\n+    return this.metadata;\n+};\n+\n+/**\n+ * Modifies metadata to include api model filenames.\n+ */\n+TSGenerator.prototype.fillApiModelFileNames = function fillApiModelFileNames(apisPath) {\n+    var modelPaths = fs.readdirSync(apisPath);\n+    if (!this.metadata) {\n+        this.loadMetadata();\n+    }\n+    var metadata = this.metadata;\n+\n+    // sort paths so latest versions appear first\n+    modelPaths = modelPaths.sort(function sort(a, b) {\n+        if (a < b) {\n+            return 1;\n+        } else if (a > b) {\n+            return -1;\n+        } else {\n+            return 0;\n+        }\n+    });\n+\n+    // Only get latest version of models\n+    var foundModels = Object.create(null);\n+    modelPaths.forEach(function(modelFileName) {\n+        var match = modelFileName.match(/^(.+)(-[\\d]{4}-[\\d]{2}-[\\d]{2})\\.normal\\.json$/i);\n+        if (match) {\n+            var model = match[1];\n+            if (!foundModels[model]) {\n+                foundModels[model] = modelFileName;\n+            }\n+        }\n+    });\n+\n+    // now update the metadata\n+    var keys = Object.keys(metadata);\n+    keys.forEach(function(key) {\n+        var modelName = metadata[key].prefix || key;\n+        metadata[key].api_path = foundModels[modelName];\n+        // find waiters file\n+        var baseName = foundModels[modelName].split('.')[0];\n+        if (modelPaths.indexOf(baseName + '.waiters2.json') >= 0) {\n+            metadata[key].waiters_path = baseName + '.waiters2.json';\n+        }\n+    });\n+};\n+\n+/**\n+ * Generates the file containing DocumentClient interfaces.\n+ */\n+TSGenerator.prototype.generateDocumentClientInterfaces = function generateDocumentClientInterfaces() {\n+    var self = this;\n+    // get the dynamodb model\n+    var dynamodbModel = this.loadServiceApi('dynamodb');\n+    var code = '';\n+    // include node reference\n+    code += '///<reference types=\"node\" />\\n';\n+    // generate shapes\n+    var modelShapes = dynamodbModel.shapes;\n+    // iterate over each shape\n+    var shapeKeys = Object.keys(modelShapes);\n+    shapeKeys.forEach(function (shapeKey) {\n+        var modelShape = modelShapes[shapeKey];\n+        // ignore exceptions\n+        if (modelShape.exception) {\n+            return;\n+        }\n+        // overwrite AttributeValue\n+        if (shapeKey === 'AttributeValue') {\n+            code += self.generateDocString('A JavaScript object or native type.');\n+            code += 'export type ' + shapeKey + ' = any;\\n';\n+            return;\n+        }\n+        code += self.generateTypingsFromShape(shapeKey, modelShape);\n+    });\n+\n+    // write file:\n+    this.writeTypingsFile('document_client_interfaces', path.join(this._sdkRootDir, 'lib', 'dynamodb'), code);\n+};\n+\n+/**\n+ * Returns a service model based on the serviceIdentifier.\n+ */\n+TSGenerator.prototype.loadServiceApi = function loadServiceApi(serviceIdentifier) {\n+    // first, find the correct identifier\n+    var metadata = this.metadata;\n+    var serviceFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].api_path);\n+    var serviceModelFile = fs.readFileSync(serviceFilePath);\n+    var serviceModel = JSON.parse(serviceModelFile);\n+    // load waiters file if it exists\n+    var waiterFilePath;\n+    if (metadata[serviceIdentifier].waiters_path) {\n+        waiterFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].waiters_path);\n+        var waiterModelFile = fs.readFileSync(waiterFilePath);\n+        var waiterModel = JSON.parse(waiterModelFile);\n+        serviceModel.waiters = waiterModel.waiters;\n+    }\n+\n+    return serviceModel;\n+};\n+\n+/**\n+ * Determines if a member is required by checking for it in a list.\n+ */\n+TSGenerator.prototype.checkRequired = function checkRequired(list, member) {\n+    if (list.indexOf(member)) {\n+        return true;\n+    }\n+    return false;\n+};\n+\n+/**\n+ * Generates whitespace based on the count.\n+ */\n+TSGenerator.prototype.tabs = function tabs(count) {\n+    var code = '';\n+    for (var i = 0; i < count; i++) {\n+        code += '  ';\n+    }\n+    return code;\n+};\n+\n+/**\n+ * Transforms documentation string to a more readable format.\n+ */\n+TSGenerator.prototype.transformDocumentation = function transformDocumentation(documentation) {\n+    if (!documentation) {\n+        return '';\n+    }\n+    documentation = documentation.replace(/<(?:.|\\n)*?>/gm, '');\n+    documentation = documentation.replace(/\\*\\//g, '*');\n+    return documentation;\n+};\n+\n+/**\n+ * Returns a doc string based on the supplied documentation.\n+ * Also tabs the doc string if a count is provided.\n+ */\n+TSGenerator.prototype.generateDocString = function generateDocString(documentation, tabCount) {\n+    tabCount = tabCount || 0;\n+    var code = '';\n+    code += this.tabs(tabCount) + '/**\\n';\n+    code += this.tabs(tabCount) + ' * ' + this.transformDocumentation(documentation) + '\\n';\n+    code += this.tabs(tabCount) + ' */\\n';\n+    return code;\n+};\n+\n+/**\n+ * Returns an array of custom configuration options based on a service identiffier.\n+ * Custom configuration options are determined by checking the metadata.json file.\n+ */\n+TSGenerator.prototype.generateCustomConfigFromMetadata = function generateCustomConfigFromMetadata(serviceIdentifier) {\n+    // some services have additional configuration options that are defined in the metadata.json file\n+    // i.e. dualstackAvailable = useDualstack\n+    // create reference to custom options\n+    var customConfigurations = [];\n+    var serviceMetadata = this.metadata[serviceIdentifier];\n+    // loop through metadata members\n+    for (var memberName in serviceMetadata) {\n+        if (!serviceMetadata.hasOwnProperty(memberName)) {\n+            continue;\n+        }\n+        var memberValue = serviceMetadata[memberName];\n+        // check configs\n+        switch (memberName) {\n+            case 'dualstackAvailable':\n+                customConfigurations.push(CUSTOM_CONFIG_ENUMS.DUALSTACK);\n+                break;\n+        }\n+    }\n+\n+    return customConfigurations;\n+};\n+\n+/**\n+ * Generates a type or interface based on the shape.\n+ */\n+TSGenerator.prototype.generateTypingsFromShape = function generateTypingsFromShape(shapeKey, shape, tabCount) {\n+    // some shapes shouldn't be generated if they are javascript primitives\n+    if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {\n+        return '';",
        "comment_created_at": "2016-10-26T18:17:43+00:00",
        "comment_author": "LiuJoyceC",
        "comment_body": "Instead of skipping shapes that happen to be named these, we could just add an underscore in front to differentiate the name of the shape from the javascript primitives.\nIt could still be useful to generate a typing for these shapes. For example, some services (like CodeCommit) have a shape named `\"Date\"` that is modeled as a string rather than a timestamp. If we rename the shape rather than skip it and have it be typed as a JavaScript `Date` object, then it could prevent errors before runtime, such as calling a `Date` method like `getMonth()` on the string.\n",
        "pr_file_module": null
      },
      {
        "comment_id": "85187632",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 1189,
        "pr_file": "scripts/lib/ts-generator.js",
        "discussion_id": "85186711",
        "commented_code": "@@ -0,0 +1,437 @@\n+var fs = require('fs');\n+var path = require('path');\n+\n+var CUSTOM_CONFIG_ENUMS = {\n+    DUALSTACK: {\n+        FILE_NAME: 'config_use_dualstack',\n+        INTERFACE: 'UseDualstackConfigOptions'\n+    }\n+};\n+\n+function TSGenerator(options) {\n+    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n+    this._apiRootDir = path.join(this._sdkRootDir, 'apis');\n+    this._metadataPath = path.join(this._apiRootDir, 'metadata.json');\n+    this._clientsDir = path.join(this._sdkRootDir, 'clients');\n+    this.metadata = null;\n+    this.typings = {};\n+    this.fillApiModelFileNames(this._apiRootDir);\n+}\n+\n+/**\n+ * Loads the AWS SDK metadata.json file.\n+ */\n+TSGenerator.prototype.loadMetadata = function loadMetadata() {\n+    var metadataFile = fs.readFileSync(this._metadataPath);\n+    this.metadata = JSON.parse(metadataFile);\n+    return this.metadata;\n+};\n+\n+/**\n+ * Modifies metadata to include api model filenames.\n+ */\n+TSGenerator.prototype.fillApiModelFileNames = function fillApiModelFileNames(apisPath) {\n+    var modelPaths = fs.readdirSync(apisPath);\n+    if (!this.metadata) {\n+        this.loadMetadata();\n+    }\n+    var metadata = this.metadata;\n+\n+    // sort paths so latest versions appear first\n+    modelPaths = modelPaths.sort(function sort(a, b) {\n+        if (a < b) {\n+            return 1;\n+        } else if (a > b) {\n+            return -1;\n+        } else {\n+            return 0;\n+        }\n+    });\n+\n+    // Only get latest version of models\n+    var foundModels = Object.create(null);\n+    modelPaths.forEach(function(modelFileName) {\n+        var match = modelFileName.match(/^(.+)(-[\\d]{4}-[\\d]{2}-[\\d]{2})\\.normal\\.json$/i);\n+        if (match) {\n+            var model = match[1];\n+            if (!foundModels[model]) {\n+                foundModels[model] = modelFileName;\n+            }\n+        }\n+    });\n+\n+    // now update the metadata\n+    var keys = Object.keys(metadata);\n+    keys.forEach(function(key) {\n+        var modelName = metadata[key].prefix || key;\n+        metadata[key].api_path = foundModels[modelName];\n+        // find waiters file\n+        var baseName = foundModels[modelName].split('.')[0];\n+        if (modelPaths.indexOf(baseName + '.waiters2.json') >= 0) {\n+            metadata[key].waiters_path = baseName + '.waiters2.json';\n+        }\n+    });\n+};\n+\n+/**\n+ * Generates the file containing DocumentClient interfaces.\n+ */\n+TSGenerator.prototype.generateDocumentClientInterfaces = function generateDocumentClientInterfaces() {\n+    var self = this;\n+    // get the dynamodb model\n+    var dynamodbModel = this.loadServiceApi('dynamodb');\n+    var code = '';\n+    // include node reference\n+    code += '///<reference types=\"node\" />\\n';\n+    // generate shapes\n+    var modelShapes = dynamodbModel.shapes;\n+    // iterate over each shape\n+    var shapeKeys = Object.keys(modelShapes);\n+    shapeKeys.forEach(function (shapeKey) {\n+        var modelShape = modelShapes[shapeKey];\n+        // ignore exceptions\n+        if (modelShape.exception) {\n+            return;\n+        }\n+        // overwrite AttributeValue\n+        if (shapeKey === 'AttributeValue') {\n+            code += self.generateDocString('A JavaScript object or native type.');\n+            code += 'export type ' + shapeKey + ' = any;\\n';\n+            return;\n+        }\n+        code += self.generateTypingsFromShape(shapeKey, modelShape);\n+    });\n+\n+    // write file:\n+    this.writeTypingsFile('document_client_interfaces', path.join(this._sdkRootDir, 'lib', 'dynamodb'), code);\n+};\n+\n+/**\n+ * Returns a service model based on the serviceIdentifier.\n+ */\n+TSGenerator.prototype.loadServiceApi = function loadServiceApi(serviceIdentifier) {\n+    // first, find the correct identifier\n+    var metadata = this.metadata;\n+    var serviceFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].api_path);\n+    var serviceModelFile = fs.readFileSync(serviceFilePath);\n+    var serviceModel = JSON.parse(serviceModelFile);\n+    // load waiters file if it exists\n+    var waiterFilePath;\n+    if (metadata[serviceIdentifier].waiters_path) {\n+        waiterFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].waiters_path);\n+        var waiterModelFile = fs.readFileSync(waiterFilePath);\n+        var waiterModel = JSON.parse(waiterModelFile);\n+        serviceModel.waiters = waiterModel.waiters;\n+    }\n+\n+    return serviceModel;\n+};\n+\n+/**\n+ * Determines if a member is required by checking for it in a list.\n+ */\n+TSGenerator.prototype.checkRequired = function checkRequired(list, member) {\n+    if (list.indexOf(member)) {\n+        return true;\n+    }\n+    return false;\n+};\n+\n+/**\n+ * Generates whitespace based on the count.\n+ */\n+TSGenerator.prototype.tabs = function tabs(count) {\n+    var code = '';\n+    for (var i = 0; i < count; i++) {\n+        code += '  ';\n+    }\n+    return code;\n+};\n+\n+/**\n+ * Transforms documentation string to a more readable format.\n+ */\n+TSGenerator.prototype.transformDocumentation = function transformDocumentation(documentation) {\n+    if (!documentation) {\n+        return '';\n+    }\n+    documentation = documentation.replace(/<(?:.|\\n)*?>/gm, '');\n+    documentation = documentation.replace(/\\*\\//g, '*');\n+    return documentation;\n+};\n+\n+/**\n+ * Returns a doc string based on the supplied documentation.\n+ * Also tabs the doc string if a count is provided.\n+ */\n+TSGenerator.prototype.generateDocString = function generateDocString(documentation, tabCount) {\n+    tabCount = tabCount || 0;\n+    var code = '';\n+    code += this.tabs(tabCount) + '/**\\n';\n+    code += this.tabs(tabCount) + ' * ' + this.transformDocumentation(documentation) + '\\n';\n+    code += this.tabs(tabCount) + ' */\\n';\n+    return code;\n+};\n+\n+/**\n+ * Returns an array of custom configuration options based on a service identiffier.\n+ * Custom configuration options are determined by checking the metadata.json file.\n+ */\n+TSGenerator.prototype.generateCustomConfigFromMetadata = function generateCustomConfigFromMetadata(serviceIdentifier) {\n+    // some services have additional configuration options that are defined in the metadata.json file\n+    // i.e. dualstackAvailable = useDualstack\n+    // create reference to custom options\n+    var customConfigurations = [];\n+    var serviceMetadata = this.metadata[serviceIdentifier];\n+    // loop through metadata members\n+    for (var memberName in serviceMetadata) {\n+        if (!serviceMetadata.hasOwnProperty(memberName)) {\n+            continue;\n+        }\n+        var memberValue = serviceMetadata[memberName];\n+        // check configs\n+        switch (memberName) {\n+            case 'dualstackAvailable':\n+                customConfigurations.push(CUSTOM_CONFIG_ENUMS.DUALSTACK);\n+                break;\n+        }\n+    }\n+\n+    return customConfigurations;\n+};\n+\n+/**\n+ * Generates a type or interface based on the shape.\n+ */\n+TSGenerator.prototype.generateTypingsFromShape = function generateTypingsFromShape(shapeKey, shape, tabCount) {\n+    // some shapes shouldn't be generated if they are javascript primitives\n+    if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {\n+        return '';",
        "comment_created_at": "2016-10-26T18:21:55+00:00",
        "comment_author": "LiuJoyceC",
        "comment_body": "So for example, the typing could look like:\n\n```\nexport type _Date = string;\n```\n\nAnd the references to this shape would have to have an underscore added in front as well.\n",
        "pr_file_module": null
      },
      {
        "comment_id": "85431358",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 1189,
        "pr_file": "scripts/lib/ts-generator.js",
        "discussion_id": "85186711",
        "commented_code": "@@ -0,0 +1,437 @@\n+var fs = require('fs');\n+var path = require('path');\n+\n+var CUSTOM_CONFIG_ENUMS = {\n+    DUALSTACK: {\n+        FILE_NAME: 'config_use_dualstack',\n+        INTERFACE: 'UseDualstackConfigOptions'\n+    }\n+};\n+\n+function TSGenerator(options) {\n+    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n+    this._apiRootDir = path.join(this._sdkRootDir, 'apis');\n+    this._metadataPath = path.join(this._apiRootDir, 'metadata.json');\n+    this._clientsDir = path.join(this._sdkRootDir, 'clients');\n+    this.metadata = null;\n+    this.typings = {};\n+    this.fillApiModelFileNames(this._apiRootDir);\n+}\n+\n+/**\n+ * Loads the AWS SDK metadata.json file.\n+ */\n+TSGenerator.prototype.loadMetadata = function loadMetadata() {\n+    var metadataFile = fs.readFileSync(this._metadataPath);\n+    this.metadata = JSON.parse(metadataFile);\n+    return this.metadata;\n+};\n+\n+/**\n+ * Modifies metadata to include api model filenames.\n+ */\n+TSGenerator.prototype.fillApiModelFileNames = function fillApiModelFileNames(apisPath) {\n+    var modelPaths = fs.readdirSync(apisPath);\n+    if (!this.metadata) {\n+        this.loadMetadata();\n+    }\n+    var metadata = this.metadata;\n+\n+    // sort paths so latest versions appear first\n+    modelPaths = modelPaths.sort(function sort(a, b) {\n+        if (a < b) {\n+            return 1;\n+        } else if (a > b) {\n+            return -1;\n+        } else {\n+            return 0;\n+        }\n+    });\n+\n+    // Only get latest version of models\n+    var foundModels = Object.create(null);\n+    modelPaths.forEach(function(modelFileName) {\n+        var match = modelFileName.match(/^(.+)(-[\\d]{4}-[\\d]{2}-[\\d]{2})\\.normal\\.json$/i);\n+        if (match) {\n+            var model = match[1];\n+            if (!foundModels[model]) {\n+                foundModels[model] = modelFileName;\n+            }\n+        }\n+    });\n+\n+    // now update the metadata\n+    var keys = Object.keys(metadata);\n+    keys.forEach(function(key) {\n+        var modelName = metadata[key].prefix || key;\n+        metadata[key].api_path = foundModels[modelName];\n+        // find waiters file\n+        var baseName = foundModels[modelName].split('.')[0];\n+        if (modelPaths.indexOf(baseName + '.waiters2.json') >= 0) {\n+            metadata[key].waiters_path = baseName + '.waiters2.json';\n+        }\n+    });\n+};\n+\n+/**\n+ * Generates the file containing DocumentClient interfaces.\n+ */\n+TSGenerator.prototype.generateDocumentClientInterfaces = function generateDocumentClientInterfaces() {\n+    var self = this;\n+    // get the dynamodb model\n+    var dynamodbModel = this.loadServiceApi('dynamodb');\n+    var code = '';\n+    // include node reference\n+    code += '///<reference types=\"node\" />\\n';\n+    // generate shapes\n+    var modelShapes = dynamodbModel.shapes;\n+    // iterate over each shape\n+    var shapeKeys = Object.keys(modelShapes);\n+    shapeKeys.forEach(function (shapeKey) {\n+        var modelShape = modelShapes[shapeKey];\n+        // ignore exceptions\n+        if (modelShape.exception) {\n+            return;\n+        }\n+        // overwrite AttributeValue\n+        if (shapeKey === 'AttributeValue') {\n+            code += self.generateDocString('A JavaScript object or native type.');\n+            code += 'export type ' + shapeKey + ' = any;\\n';\n+            return;\n+        }\n+        code += self.generateTypingsFromShape(shapeKey, modelShape);\n+    });\n+\n+    // write file:\n+    this.writeTypingsFile('document_client_interfaces', path.join(this._sdkRootDir, 'lib', 'dynamodb'), code);\n+};\n+\n+/**\n+ * Returns a service model based on the serviceIdentifier.\n+ */\n+TSGenerator.prototype.loadServiceApi = function loadServiceApi(serviceIdentifier) {\n+    // first, find the correct identifier\n+    var metadata = this.metadata;\n+    var serviceFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].api_path);\n+    var serviceModelFile = fs.readFileSync(serviceFilePath);\n+    var serviceModel = JSON.parse(serviceModelFile);\n+    // load waiters file if it exists\n+    var waiterFilePath;\n+    if (metadata[serviceIdentifier].waiters_path) {\n+        waiterFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].waiters_path);\n+        var waiterModelFile = fs.readFileSync(waiterFilePath);\n+        var waiterModel = JSON.parse(waiterModelFile);\n+        serviceModel.waiters = waiterModel.waiters;\n+    }\n+\n+    return serviceModel;\n+};\n+\n+/**\n+ * Determines if a member is required by checking for it in a list.\n+ */\n+TSGenerator.prototype.checkRequired = function checkRequired(list, member) {\n+    if (list.indexOf(member)) {\n+        return true;\n+    }\n+    return false;\n+};\n+\n+/**\n+ * Generates whitespace based on the count.\n+ */\n+TSGenerator.prototype.tabs = function tabs(count) {\n+    var code = '';\n+    for (var i = 0; i < count; i++) {\n+        code += '  ';\n+    }\n+    return code;\n+};\n+\n+/**\n+ * Transforms documentation string to a more readable format.\n+ */\n+TSGenerator.prototype.transformDocumentation = function transformDocumentation(documentation) {\n+    if (!documentation) {\n+        return '';\n+    }\n+    documentation = documentation.replace(/<(?:.|\\n)*?>/gm, '');\n+    documentation = documentation.replace(/\\*\\//g, '*');\n+    return documentation;\n+};\n+\n+/**\n+ * Returns a doc string based on the supplied documentation.\n+ * Also tabs the doc string if a count is provided.\n+ */\n+TSGenerator.prototype.generateDocString = function generateDocString(documentation, tabCount) {\n+    tabCount = tabCount || 0;\n+    var code = '';\n+    code += this.tabs(tabCount) + '/**\\n';\n+    code += this.tabs(tabCount) + ' * ' + this.transformDocumentation(documentation) + '\\n';\n+    code += this.tabs(tabCount) + ' */\\n';\n+    return code;\n+};\n+\n+/**\n+ * Returns an array of custom configuration options based on a service identiffier.\n+ * Custom configuration options are determined by checking the metadata.json file.\n+ */\n+TSGenerator.prototype.generateCustomConfigFromMetadata = function generateCustomConfigFromMetadata(serviceIdentifier) {\n+    // some services have additional configuration options that are defined in the metadata.json file\n+    // i.e. dualstackAvailable = useDualstack\n+    // create reference to custom options\n+    var customConfigurations = [];\n+    var serviceMetadata = this.metadata[serviceIdentifier];\n+    // loop through metadata members\n+    for (var memberName in serviceMetadata) {\n+        if (!serviceMetadata.hasOwnProperty(memberName)) {\n+            continue;\n+        }\n+        var memberValue = serviceMetadata[memberName];\n+        // check configs\n+        switch (memberName) {\n+            case 'dualstackAvailable':\n+                customConfigurations.push(CUSTOM_CONFIG_ENUMS.DUALSTACK);\n+                break;\n+        }\n+    }\n+\n+    return customConfigurations;\n+};\n+\n+/**\n+ * Generates a type or interface based on the shape.\n+ */\n+TSGenerator.prototype.generateTypingsFromShape = function generateTypingsFromShape(shapeKey, shape, tabCount) {\n+    // some shapes shouldn't be generated if they are javascript primitives\n+    if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {\n+        return '';",
        "comment_created_at": "2016-10-27T21:27:10+00:00",
        "comment_author": "chrisradek",
        "comment_body": "Fair point, thanks for finding that.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "85250379",
    "pr_number": 1189,
    "pr_file": "scripts/lib/ts-generator.js",
    "created_at": "2016-10-27T01:01:32+00:00",
    "commented_code": "var fs = require('fs');\nvar path = require('path');\n\nvar CUSTOM_CONFIG_ENUMS = {\n    DUALSTACK: {\n        FILE_NAME: 'config_use_dualstack',\n        INTERFACE: 'UseDualstackConfigOptions'\n    }\n};\n\nfunction TSGenerator(options) {\n    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n    this._apiRootDir = path.join(this._sdkRootDir, 'apis');\n    this._metadataPath = path.join(this._apiRootDir, 'metadata.json');\n    this._clientsDir = path.join(this._sdkRootDir, 'clients');\n    this.metadata = null;\n    this.typings = {};\n    this.fillApiModelFileNames(this._apiRootDir);\n}\n\n/**\n * Loads the AWS SDK metadata.json file.\n */\nTSGenerator.prototype.loadMetadata = function loadMetadata() {\n    var metadataFile = fs.readFileSync(this._metadataPath);\n    this.metadata = JSON.parse(metadataFile);\n    return this.metadata;\n};\n\n/**\n * Modifies metadata to include api model filenames.\n */\nTSGenerator.prototype.fillApiModelFileNames = function fillApiModelFileNames(apisPath) {\n    var modelPaths = fs.readdirSync(apisPath);\n    if (!this.metadata) {\n        this.loadMetadata();\n    }\n    var metadata = this.metadata;\n\n    // sort paths so latest versions appear first\n    modelPaths = modelPaths.sort(function sort(a, b) {\n        if (a < b) {\n            return 1;\n        } else if (a > b) {\n            return -1;\n        } else {\n            return 0;\n        }\n    });\n\n    // Only get latest version of models\n    var foundModels = Object.create(null);\n    modelPaths.forEach(function(modelFileName) {\n        var match = modelFileName.match(/^(.+)(-[\\d]{4}-[\\d]{2}-[\\d]{2})\\.normal\\.json$/i);\n        if (match) {\n            var model = match[1];\n            if (!foundModels[model]) {\n                foundModels[model] = modelFileName;\n            }\n        }\n    });\n\n    // now update the metadata\n    var keys = Object.keys(metadata);\n    keys.forEach(function(key) {\n        var modelName = metadata[key].prefix || key;\n        metadata[key].api_path = foundModels[modelName];\n        // find waiters file\n        var baseName = foundModels[modelName].split('.')[0];\n        if (modelPaths.indexOf(baseName + '.waiters2.json') >= 0) {\n            metadata[key].waiters_path = baseName + '.waiters2.json';\n        }\n    });\n};\n\n/**\n * Generates the file containing DocumentClient interfaces.\n */\nTSGenerator.prototype.generateDocumentClientInterfaces = function generateDocumentClientInterfaces() {\n    var self = this;\n    // get the dynamodb model\n    var dynamodbModel = this.loadServiceApi('dynamodb');\n    var code = '';\n    // include node reference\n    code += '///<reference types=\"node\" />\\n';\n    // generate shapes\n    var modelShapes = dynamodbModel.shapes;\n    // iterate over each shape\n    var shapeKeys = Object.keys(modelShapes);\n    shapeKeys.forEach(function (shapeKey) {\n        var modelShape = modelShapes[shapeKey];\n        // ignore exceptions\n        if (modelShape.exception) {\n            return;\n        }\n        // overwrite AttributeValue\n        if (shapeKey === 'AttributeValue') {\n            code += self.generateDocString('A JavaScript object or native type.');\n            code += 'export type ' + shapeKey + ' = any;\\n';\n            return;\n        }\n        code += self.generateTypingsFromShape(shapeKey, modelShape);\n    });\n\n    // write file:\n    this.writeTypingsFile('document_client_interfaces', path.join(this._sdkRootDir, 'lib', 'dynamodb'), code);\n};\n\n/**\n * Returns a service model based on the serviceIdentifier.\n */\nTSGenerator.prototype.loadServiceApi = function loadServiceApi(serviceIdentifier) {\n    // first, find the correct identifier\n    var metadata = this.metadata;\n    var serviceFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].api_path);\n    var serviceModelFile = fs.readFileSync(serviceFilePath);\n    var serviceModel = JSON.parse(serviceModelFile);\n    // load waiters file if it exists\n    var waiterFilePath;\n    if (metadata[serviceIdentifier].waiters_path) {\n        waiterFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].waiters_path);\n        var waiterModelFile = fs.readFileSync(waiterFilePath);\n        var waiterModel = JSON.parse(waiterModelFile);\n        serviceModel.waiters = waiterModel.waiters;\n    }\n\n    return serviceModel;\n};\n\n/**\n * Determines if a member is required by checking for it in a list.\n */\nTSGenerator.prototype.checkRequired = function checkRequired(list, member) {\n    if (list.indexOf(member)) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Generates whitespace based on the count.\n */\nTSGenerator.prototype.tabs = function tabs(count) {\n    var code = '';\n    for (var i = 0; i < count; i++) {\n        code += '  ';\n    }\n    return code;\n};\n\n/**\n * Transforms documentation string to a more readable format.\n */\nTSGenerator.prototype.transformDocumentation = function transformDocumentation(documentation) {\n    if (!documentation) {\n        return '';\n    }\n    documentation = documentation.replace(/<(?:.|\\n)*?>/gm, '');\n    documentation = documentation.replace(/\\*\\//g, '*');\n    return documentation;\n};\n\n/**\n * Returns a doc string based on the supplied documentation.\n * Also tabs the doc string if a count is provided.\n */\nTSGenerator.prototype.generateDocString = function generateDocString(documentation, tabCount) {\n    tabCount = tabCount || 0;\n    var code = '';\n    code += this.tabs(tabCount) + '/**\\n';\n    code += this.tabs(tabCount) + ' * ' + this.transformDocumentation(documentation) + '\\n';\n    code += this.tabs(tabCount) + ' */\\n';\n    return code;\n};\n\n/**\n * Returns an array of custom configuration options based on a service identiffier.\n * Custom configuration options are determined by checking the metadata.json file.\n */\nTSGenerator.prototype.generateCustomConfigFromMetadata = function generateCustomConfigFromMetadata(serviceIdentifier) {\n    // some services have additional configuration options that are defined in the metadata.json file\n    // i.e. dualstackAvailable = useDualstack\n    // create reference to custom options\n    var customConfigurations = [];\n    var serviceMetadata = this.metadata[serviceIdentifier];\n    // loop through metadata members\n    for (var memberName in serviceMetadata) {\n        if (!serviceMetadata.hasOwnProperty(memberName)) {\n            continue;\n        }\n        var memberValue = serviceMetadata[memberName];\n        // check configs\n        switch (memberName) {\n            case 'dualstackAvailable':\n                customConfigurations.push(CUSTOM_CONFIG_ENUMS.DUALSTACK);\n                break;\n        }\n    }\n\n    return customConfigurations;\n};\n\n/**\n * Generates a type or interface based on the shape.\n */\nTSGenerator.prototype.generateTypingsFromShape = function generateTypingsFromShape(shapeKey, shape, tabCount) {\n    // some shapes shouldn't be generated if they are javascript primitives\n    if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {\n        return '';\n    }\n    var self = this;\n    var code = '';\n    tabCount = tabCount || 0;\n    var tabs = this.tabs;\n    var type = shape.type;\n    if (type === 'structure') {\n        code += tabs(tabCount) + 'export interface ' + shapeKey + ' {\\n';\n        var members = shape.members;\n        // cycle through members\n        var memberKeys = Object.keys(members);\n        memberKeys.forEach(function(memberKey) {\n            // docs\n            var member = members[memberKey];\n            if (member.documentation) {\n                code += self.generateDocString(member.documentation, tabCount + 1);\n            }\n            var required = self.checkRequired(shape.required || [], memberKey) ? '?' : '';\n            code += tabs(tabCount + 1) + memberKey + required + ': ' + member.shape + ';\\n';\n        });\n        code += tabs(tabCount) + '}\\n';\n    } else if (type === 'list') {\n        code += tabs(tabCount) + 'export type ' + shapeKey + ' = ' + shape.member.shape + '[];\\n';\n    } else if (type === 'map') {\n        code += tabs(tabCount) + 'export type ' + shapeKey + ' = {[key: string]: ' + shape.value.shape + '};\\n';\n    } else if (type === 'string' || type === 'character') {\n        code += tabs(tabCount) + 'export type ' + shapeKey + ' = string;\\n';\n    } else if (['double', 'long', 'short', 'biginteger', 'bigdecimal', 'integer', 'float'].indexOf(type) >= 0) {\n        code += tabs(tabCount) + 'export type ' + shapeKey + ' = number;\\n';\n    } else if (type === 'timestamp') {\n        code += tabs(tabCount) + 'export type ' + shapeKey + ' = Date;\\n';\n    } else if (type === 'boolean') {\n        code += tabs(tabCount) + 'export type ' + shapeKey + ' = boolean;\\n';\n    } else if (type === 'blob' || type === 'binary') {\n        code += tabs(tabCount) + 'export type ' + shapeKey + ' = Buffer|Uint8Array|Blob|string;\\n';\n    }\n    return code;\n};\n\n/**\n * Generates a class method type for an operation.\n */\nTSGenerator.prototype.generateTypingsFromOperations = function generateTypingsFromOperations(className, operation, tabCount) {\n    var code = '';\n    tabCount = tabCount || 0;\n    var tabs = this.tabs;\n\n    var input = operation.input;\n    var output = operation.output;\n    var operationName = operation.name.charAt(0).toLowerCase() + operation.name.substring(1);\n\n    var inputShape = input ? className + '.' + input.shape : '{}';\n    var outputShape = output ? className + '.' + output.shape : '{}';\n\n    code += this.generateDocString(operation.documentation, tabCount);\n    code += tabs(tabCount) + operationName + '(params: ' + inputShape + ', callback?: (err: AWSError, data: ' + outputShape + ') => void): Request<' + outputShape + ', AWSError>;\\n';\n    code += this.generateDocString(operation.documentation, tabCount);\n    code += tabs(tabCount) + operationName + '(callback?: (err: AWSError, data: ' + outputShape + ') => void): Request<' + outputShape + ', AWSError>;\\n';\n\n    return code;\n};\n\n/**\n * Generates class method types for a waiter.\n */\nTSGenerator.prototype.generateTypingsFromWaiters = function generateTypingsFromWaiters(className, waiterState, waiter, underlyingOperation, tabCount) {",
    "repo_full_name": "aws/aws-sdk-js",
    "discussion_comments": [
      {
        "comment_id": "85250379",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 1189,
        "pr_file": "scripts/lib/ts-generator.js",
        "discussion_id": "85250379",
        "commented_code": "@@ -0,0 +1,437 @@\n+var fs = require('fs');\n+var path = require('path');\n+\n+var CUSTOM_CONFIG_ENUMS = {\n+    DUALSTACK: {\n+        FILE_NAME: 'config_use_dualstack',\n+        INTERFACE: 'UseDualstackConfigOptions'\n+    }\n+};\n+\n+function TSGenerator(options) {\n+    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n+    this._apiRootDir = path.join(this._sdkRootDir, 'apis');\n+    this._metadataPath = path.join(this._apiRootDir, 'metadata.json');\n+    this._clientsDir = path.join(this._sdkRootDir, 'clients');\n+    this.metadata = null;\n+    this.typings = {};\n+    this.fillApiModelFileNames(this._apiRootDir);\n+}\n+\n+/**\n+ * Loads the AWS SDK metadata.json file.\n+ */\n+TSGenerator.prototype.loadMetadata = function loadMetadata() {\n+    var metadataFile = fs.readFileSync(this._metadataPath);\n+    this.metadata = JSON.parse(metadataFile);\n+    return this.metadata;\n+};\n+\n+/**\n+ * Modifies metadata to include api model filenames.\n+ */\n+TSGenerator.prototype.fillApiModelFileNames = function fillApiModelFileNames(apisPath) {\n+    var modelPaths = fs.readdirSync(apisPath);\n+    if (!this.metadata) {\n+        this.loadMetadata();\n+    }\n+    var metadata = this.metadata;\n+\n+    // sort paths so latest versions appear first\n+    modelPaths = modelPaths.sort(function sort(a, b) {\n+        if (a < b) {\n+            return 1;\n+        } else if (a > b) {\n+            return -1;\n+        } else {\n+            return 0;\n+        }\n+    });\n+\n+    // Only get latest version of models\n+    var foundModels = Object.create(null);\n+    modelPaths.forEach(function(modelFileName) {\n+        var match = modelFileName.match(/^(.+)(-[\\d]{4}-[\\d]{2}-[\\d]{2})\\.normal\\.json$/i);\n+        if (match) {\n+            var model = match[1];\n+            if (!foundModels[model]) {\n+                foundModels[model] = modelFileName;\n+            }\n+        }\n+    });\n+\n+    // now update the metadata\n+    var keys = Object.keys(metadata);\n+    keys.forEach(function(key) {\n+        var modelName = metadata[key].prefix || key;\n+        metadata[key].api_path = foundModels[modelName];\n+        // find waiters file\n+        var baseName = foundModels[modelName].split('.')[0];\n+        if (modelPaths.indexOf(baseName + '.waiters2.json') >= 0) {\n+            metadata[key].waiters_path = baseName + '.waiters2.json';\n+        }\n+    });\n+};\n+\n+/**\n+ * Generates the file containing DocumentClient interfaces.\n+ */\n+TSGenerator.prototype.generateDocumentClientInterfaces = function generateDocumentClientInterfaces() {\n+    var self = this;\n+    // get the dynamodb model\n+    var dynamodbModel = this.loadServiceApi('dynamodb');\n+    var code = '';\n+    // include node reference\n+    code += '///<reference types=\"node\" />\\n';\n+    // generate shapes\n+    var modelShapes = dynamodbModel.shapes;\n+    // iterate over each shape\n+    var shapeKeys = Object.keys(modelShapes);\n+    shapeKeys.forEach(function (shapeKey) {\n+        var modelShape = modelShapes[shapeKey];\n+        // ignore exceptions\n+        if (modelShape.exception) {\n+            return;\n+        }\n+        // overwrite AttributeValue\n+        if (shapeKey === 'AttributeValue') {\n+            code += self.generateDocString('A JavaScript object or native type.');\n+            code += 'export type ' + shapeKey + ' = any;\\n';\n+            return;\n+        }\n+        code += self.generateTypingsFromShape(shapeKey, modelShape);\n+    });\n+\n+    // write file:\n+    this.writeTypingsFile('document_client_interfaces', path.join(this._sdkRootDir, 'lib', 'dynamodb'), code);\n+};\n+\n+/**\n+ * Returns a service model based on the serviceIdentifier.\n+ */\n+TSGenerator.prototype.loadServiceApi = function loadServiceApi(serviceIdentifier) {\n+    // first, find the correct identifier\n+    var metadata = this.metadata;\n+    var serviceFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].api_path);\n+    var serviceModelFile = fs.readFileSync(serviceFilePath);\n+    var serviceModel = JSON.parse(serviceModelFile);\n+    // load waiters file if it exists\n+    var waiterFilePath;\n+    if (metadata[serviceIdentifier].waiters_path) {\n+        waiterFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].waiters_path);\n+        var waiterModelFile = fs.readFileSync(waiterFilePath);\n+        var waiterModel = JSON.parse(waiterModelFile);\n+        serviceModel.waiters = waiterModel.waiters;\n+    }\n+\n+    return serviceModel;\n+};\n+\n+/**\n+ * Determines if a member is required by checking for it in a list.\n+ */\n+TSGenerator.prototype.checkRequired = function checkRequired(list, member) {\n+    if (list.indexOf(member)) {\n+        return true;\n+    }\n+    return false;\n+};\n+\n+/**\n+ * Generates whitespace based on the count.\n+ */\n+TSGenerator.prototype.tabs = function tabs(count) {\n+    var code = '';\n+    for (var i = 0; i < count; i++) {\n+        code += '  ';\n+    }\n+    return code;\n+};\n+\n+/**\n+ * Transforms documentation string to a more readable format.\n+ */\n+TSGenerator.prototype.transformDocumentation = function transformDocumentation(documentation) {\n+    if (!documentation) {\n+        return '';\n+    }\n+    documentation = documentation.replace(/<(?:.|\\n)*?>/gm, '');\n+    documentation = documentation.replace(/\\*\\//g, '*');\n+    return documentation;\n+};\n+\n+/**\n+ * Returns a doc string based on the supplied documentation.\n+ * Also tabs the doc string if a count is provided.\n+ */\n+TSGenerator.prototype.generateDocString = function generateDocString(documentation, tabCount) {\n+    tabCount = tabCount || 0;\n+    var code = '';\n+    code += this.tabs(tabCount) + '/**\\n';\n+    code += this.tabs(tabCount) + ' * ' + this.transformDocumentation(documentation) + '\\n';\n+    code += this.tabs(tabCount) + ' */\\n';\n+    return code;\n+};\n+\n+/**\n+ * Returns an array of custom configuration options based on a service identiffier.\n+ * Custom configuration options are determined by checking the metadata.json file.\n+ */\n+TSGenerator.prototype.generateCustomConfigFromMetadata = function generateCustomConfigFromMetadata(serviceIdentifier) {\n+    // some services have additional configuration options that are defined in the metadata.json file\n+    // i.e. dualstackAvailable = useDualstack\n+    // create reference to custom options\n+    var customConfigurations = [];\n+    var serviceMetadata = this.metadata[serviceIdentifier];\n+    // loop through metadata members\n+    for (var memberName in serviceMetadata) {\n+        if (!serviceMetadata.hasOwnProperty(memberName)) {\n+            continue;\n+        }\n+        var memberValue = serviceMetadata[memberName];\n+        // check configs\n+        switch (memberName) {\n+            case 'dualstackAvailable':\n+                customConfigurations.push(CUSTOM_CONFIG_ENUMS.DUALSTACK);\n+                break;\n+        }\n+    }\n+\n+    return customConfigurations;\n+};\n+\n+/**\n+ * Generates a type or interface based on the shape.\n+ */\n+TSGenerator.prototype.generateTypingsFromShape = function generateTypingsFromShape(shapeKey, shape, tabCount) {\n+    // some shapes shouldn't be generated if they are javascript primitives\n+    if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {\n+        return '';\n+    }\n+    var self = this;\n+    var code = '';\n+    tabCount = tabCount || 0;\n+    var tabs = this.tabs;\n+    var type = shape.type;\n+    if (type === 'structure') {\n+        code += tabs(tabCount) + 'export interface ' + shapeKey + ' {\\n';\n+        var members = shape.members;\n+        // cycle through members\n+        var memberKeys = Object.keys(members);\n+        memberKeys.forEach(function(memberKey) {\n+            // docs\n+            var member = members[memberKey];\n+            if (member.documentation) {\n+                code += self.generateDocString(member.documentation, tabCount + 1);\n+            }\n+            var required = self.checkRequired(shape.required || [], memberKey) ? '?' : '';\n+            code += tabs(tabCount + 1) + memberKey + required + ': ' + member.shape + ';\\n';\n+        });\n+        code += tabs(tabCount) + '}\\n';\n+    } else if (type === 'list') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = ' + shape.member.shape + '[];\\n';\n+    } else if (type === 'map') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = {[key: string]: ' + shape.value.shape + '};\\n';\n+    } else if (type === 'string' || type === 'character') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = string;\\n';\n+    } else if (['double', 'long', 'short', 'biginteger', 'bigdecimal', 'integer', 'float'].indexOf(type) >= 0) {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = number;\\n';\n+    } else if (type === 'timestamp') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = Date;\\n';\n+    } else if (type === 'boolean') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = boolean;\\n';\n+    } else if (type === 'blob' || type === 'binary') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = Buffer|Uint8Array|Blob|string;\\n';\n+    }\n+    return code;\n+};\n+\n+/**\n+ * Generates a class method type for an operation.\n+ */\n+TSGenerator.prototype.generateTypingsFromOperations = function generateTypingsFromOperations(className, operation, tabCount) {\n+    var code = '';\n+    tabCount = tabCount || 0;\n+    var tabs = this.tabs;\n+\n+    var input = operation.input;\n+    var output = operation.output;\n+    var operationName = operation.name.charAt(0).toLowerCase() + operation.name.substring(1);\n+\n+    var inputShape = input ? className + '.' + input.shape : '{}';\n+    var outputShape = output ? className + '.' + output.shape : '{}';\n+\n+    code += this.generateDocString(operation.documentation, tabCount);\n+    code += tabs(tabCount) + operationName + '(params: ' + inputShape + ', callback?: (err: AWSError, data: ' + outputShape + ') => void): Request<' + outputShape + ', AWSError>;\\n';\n+    code += this.generateDocString(operation.documentation, tabCount);\n+    code += tabs(tabCount) + operationName + '(callback?: (err: AWSError, data: ' + outputShape + ') => void): Request<' + outputShape + ', AWSError>;\\n';\n+\n+    return code;\n+};\n+\n+/**\n+ * Generates class method types for a waiter.\n+ */\n+TSGenerator.prototype.generateTypingsFromWaiters = function generateTypingsFromWaiters(className, waiterState, waiter, underlyingOperation, tabCount) {",
        "comment_created_at": "2016-10-27T01:01:32+00:00",
        "comment_author": "LiuJoyceC",
        "comment_body": "`waiterState` needs to have its first letter lowercased. For example, using the state `\"BucketExists\"` will result in an error, but `\"bucketExists\"` is correct.\n",
        "pr_file_module": null
      },
      {
        "comment_id": "85430054",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 1189,
        "pr_file": "scripts/lib/ts-generator.js",
        "discussion_id": "85250379",
        "commented_code": "@@ -0,0 +1,437 @@\n+var fs = require('fs');\n+var path = require('path');\n+\n+var CUSTOM_CONFIG_ENUMS = {\n+    DUALSTACK: {\n+        FILE_NAME: 'config_use_dualstack',\n+        INTERFACE: 'UseDualstackConfigOptions'\n+    }\n+};\n+\n+function TSGenerator(options) {\n+    this._sdkRootDir = options.SdkRootDirectory || process.cwd();\n+    this._apiRootDir = path.join(this._sdkRootDir, 'apis');\n+    this._metadataPath = path.join(this._apiRootDir, 'metadata.json');\n+    this._clientsDir = path.join(this._sdkRootDir, 'clients');\n+    this.metadata = null;\n+    this.typings = {};\n+    this.fillApiModelFileNames(this._apiRootDir);\n+}\n+\n+/**\n+ * Loads the AWS SDK metadata.json file.\n+ */\n+TSGenerator.prototype.loadMetadata = function loadMetadata() {\n+    var metadataFile = fs.readFileSync(this._metadataPath);\n+    this.metadata = JSON.parse(metadataFile);\n+    return this.metadata;\n+};\n+\n+/**\n+ * Modifies metadata to include api model filenames.\n+ */\n+TSGenerator.prototype.fillApiModelFileNames = function fillApiModelFileNames(apisPath) {\n+    var modelPaths = fs.readdirSync(apisPath);\n+    if (!this.metadata) {\n+        this.loadMetadata();\n+    }\n+    var metadata = this.metadata;\n+\n+    // sort paths so latest versions appear first\n+    modelPaths = modelPaths.sort(function sort(a, b) {\n+        if (a < b) {\n+            return 1;\n+        } else if (a > b) {\n+            return -1;\n+        } else {\n+            return 0;\n+        }\n+    });\n+\n+    // Only get latest version of models\n+    var foundModels = Object.create(null);\n+    modelPaths.forEach(function(modelFileName) {\n+        var match = modelFileName.match(/^(.+)(-[\\d]{4}-[\\d]{2}-[\\d]{2})\\.normal\\.json$/i);\n+        if (match) {\n+            var model = match[1];\n+            if (!foundModels[model]) {\n+                foundModels[model] = modelFileName;\n+            }\n+        }\n+    });\n+\n+    // now update the metadata\n+    var keys = Object.keys(metadata);\n+    keys.forEach(function(key) {\n+        var modelName = metadata[key].prefix || key;\n+        metadata[key].api_path = foundModels[modelName];\n+        // find waiters file\n+        var baseName = foundModels[modelName].split('.')[0];\n+        if (modelPaths.indexOf(baseName + '.waiters2.json') >= 0) {\n+            metadata[key].waiters_path = baseName + '.waiters2.json';\n+        }\n+    });\n+};\n+\n+/**\n+ * Generates the file containing DocumentClient interfaces.\n+ */\n+TSGenerator.prototype.generateDocumentClientInterfaces = function generateDocumentClientInterfaces() {\n+    var self = this;\n+    // get the dynamodb model\n+    var dynamodbModel = this.loadServiceApi('dynamodb');\n+    var code = '';\n+    // include node reference\n+    code += '///<reference types=\"node\" />\\n';\n+    // generate shapes\n+    var modelShapes = dynamodbModel.shapes;\n+    // iterate over each shape\n+    var shapeKeys = Object.keys(modelShapes);\n+    shapeKeys.forEach(function (shapeKey) {\n+        var modelShape = modelShapes[shapeKey];\n+        // ignore exceptions\n+        if (modelShape.exception) {\n+            return;\n+        }\n+        // overwrite AttributeValue\n+        if (shapeKey === 'AttributeValue') {\n+            code += self.generateDocString('A JavaScript object or native type.');\n+            code += 'export type ' + shapeKey + ' = any;\\n';\n+            return;\n+        }\n+        code += self.generateTypingsFromShape(shapeKey, modelShape);\n+    });\n+\n+    // write file:\n+    this.writeTypingsFile('document_client_interfaces', path.join(this._sdkRootDir, 'lib', 'dynamodb'), code);\n+};\n+\n+/**\n+ * Returns a service model based on the serviceIdentifier.\n+ */\n+TSGenerator.prototype.loadServiceApi = function loadServiceApi(serviceIdentifier) {\n+    // first, find the correct identifier\n+    var metadata = this.metadata;\n+    var serviceFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].api_path);\n+    var serviceModelFile = fs.readFileSync(serviceFilePath);\n+    var serviceModel = JSON.parse(serviceModelFile);\n+    // load waiters file if it exists\n+    var waiterFilePath;\n+    if (metadata[serviceIdentifier].waiters_path) {\n+        waiterFilePath = path.join(this._apiRootDir, metadata[serviceIdentifier].waiters_path);\n+        var waiterModelFile = fs.readFileSync(waiterFilePath);\n+        var waiterModel = JSON.parse(waiterModelFile);\n+        serviceModel.waiters = waiterModel.waiters;\n+    }\n+\n+    return serviceModel;\n+};\n+\n+/**\n+ * Determines if a member is required by checking for it in a list.\n+ */\n+TSGenerator.prototype.checkRequired = function checkRequired(list, member) {\n+    if (list.indexOf(member)) {\n+        return true;\n+    }\n+    return false;\n+};\n+\n+/**\n+ * Generates whitespace based on the count.\n+ */\n+TSGenerator.prototype.tabs = function tabs(count) {\n+    var code = '';\n+    for (var i = 0; i < count; i++) {\n+        code += '  ';\n+    }\n+    return code;\n+};\n+\n+/**\n+ * Transforms documentation string to a more readable format.\n+ */\n+TSGenerator.prototype.transformDocumentation = function transformDocumentation(documentation) {\n+    if (!documentation) {\n+        return '';\n+    }\n+    documentation = documentation.replace(/<(?:.|\\n)*?>/gm, '');\n+    documentation = documentation.replace(/\\*\\//g, '*');\n+    return documentation;\n+};\n+\n+/**\n+ * Returns a doc string based on the supplied documentation.\n+ * Also tabs the doc string if a count is provided.\n+ */\n+TSGenerator.prototype.generateDocString = function generateDocString(documentation, tabCount) {\n+    tabCount = tabCount || 0;\n+    var code = '';\n+    code += this.tabs(tabCount) + '/**\\n';\n+    code += this.tabs(tabCount) + ' * ' + this.transformDocumentation(documentation) + '\\n';\n+    code += this.tabs(tabCount) + ' */\\n';\n+    return code;\n+};\n+\n+/**\n+ * Returns an array of custom configuration options based on a service identiffier.\n+ * Custom configuration options are determined by checking the metadata.json file.\n+ */\n+TSGenerator.prototype.generateCustomConfigFromMetadata = function generateCustomConfigFromMetadata(serviceIdentifier) {\n+    // some services have additional configuration options that are defined in the metadata.json file\n+    // i.e. dualstackAvailable = useDualstack\n+    // create reference to custom options\n+    var customConfigurations = [];\n+    var serviceMetadata = this.metadata[serviceIdentifier];\n+    // loop through metadata members\n+    for (var memberName in serviceMetadata) {\n+        if (!serviceMetadata.hasOwnProperty(memberName)) {\n+            continue;\n+        }\n+        var memberValue = serviceMetadata[memberName];\n+        // check configs\n+        switch (memberName) {\n+            case 'dualstackAvailable':\n+                customConfigurations.push(CUSTOM_CONFIG_ENUMS.DUALSTACK);\n+                break;\n+        }\n+    }\n+\n+    return customConfigurations;\n+};\n+\n+/**\n+ * Generates a type or interface based on the shape.\n+ */\n+TSGenerator.prototype.generateTypingsFromShape = function generateTypingsFromShape(shapeKey, shape, tabCount) {\n+    // some shapes shouldn't be generated if they are javascript primitives\n+    if (['string', 'boolean', 'number', 'Date', 'Blob'].indexOf(shapeKey) >= 0) {\n+        return '';\n+    }\n+    var self = this;\n+    var code = '';\n+    tabCount = tabCount || 0;\n+    var tabs = this.tabs;\n+    var type = shape.type;\n+    if (type === 'structure') {\n+        code += tabs(tabCount) + 'export interface ' + shapeKey + ' {\\n';\n+        var members = shape.members;\n+        // cycle through members\n+        var memberKeys = Object.keys(members);\n+        memberKeys.forEach(function(memberKey) {\n+            // docs\n+            var member = members[memberKey];\n+            if (member.documentation) {\n+                code += self.generateDocString(member.documentation, tabCount + 1);\n+            }\n+            var required = self.checkRequired(shape.required || [], memberKey) ? '?' : '';\n+            code += tabs(tabCount + 1) + memberKey + required + ': ' + member.shape + ';\\n';\n+        });\n+        code += tabs(tabCount) + '}\\n';\n+    } else if (type === 'list') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = ' + shape.member.shape + '[];\\n';\n+    } else if (type === 'map') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = {[key: string]: ' + shape.value.shape + '};\\n';\n+    } else if (type === 'string' || type === 'character') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = string;\\n';\n+    } else if (['double', 'long', 'short', 'biginteger', 'bigdecimal', 'integer', 'float'].indexOf(type) >= 0) {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = number;\\n';\n+    } else if (type === 'timestamp') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = Date;\\n';\n+    } else if (type === 'boolean') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = boolean;\\n';\n+    } else if (type === 'blob' || type === 'binary') {\n+        code += tabs(tabCount) + 'export type ' + shapeKey + ' = Buffer|Uint8Array|Blob|string;\\n';\n+    }\n+    return code;\n+};\n+\n+/**\n+ * Generates a class method type for an operation.\n+ */\n+TSGenerator.prototype.generateTypingsFromOperations = function generateTypingsFromOperations(className, operation, tabCount) {\n+    var code = '';\n+    tabCount = tabCount || 0;\n+    var tabs = this.tabs;\n+\n+    var input = operation.input;\n+    var output = operation.output;\n+    var operationName = operation.name.charAt(0).toLowerCase() + operation.name.substring(1);\n+\n+    var inputShape = input ? className + '.' + input.shape : '{}';\n+    var outputShape = output ? className + '.' + output.shape : '{}';\n+\n+    code += this.generateDocString(operation.documentation, tabCount);\n+    code += tabs(tabCount) + operationName + '(params: ' + inputShape + ', callback?: (err: AWSError, data: ' + outputShape + ') => void): Request<' + outputShape + ', AWSError>;\\n';\n+    code += this.generateDocString(operation.documentation, tabCount);\n+    code += tabs(tabCount) + operationName + '(callback?: (err: AWSError, data: ' + outputShape + ') => void): Request<' + outputShape + ', AWSError>;\\n';\n+\n+    return code;\n+};\n+\n+/**\n+ * Generates class method types for a waiter.\n+ */\n+TSGenerator.prototype.generateTypingsFromWaiters = function generateTypingsFromWaiters(className, waiterState, waiter, underlyingOperation, tabCount) {",
        "comment_created_at": "2016-10-27T21:19:43+00:00",
        "comment_author": "chrisradek",
        "comment_body": "Good catch!\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "138404158",
    "pr_number": 1716,
    "pr_file": "lib/service.js",
    "created_at": "2017-09-12T16:43:11+00:00",
    "commented_code": "/**\n   * @api private\n   */\n  getServiceClock: function getServiceClock() {",
    "repo_full_name": "aws/aws-sdk-js",
    "discussion_comments": [
      {
        "comment_id": "138404158",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 1716,
        "pr_file": "lib/service.js",
        "discussion_id": "138404158",
        "commented_code": "@@ -403,6 +403,31 @@ AWS.Service = inherit({\n   /**\n    * @api private\n    */\n+  getServiceClock: function getServiceClock() {",
        "comment_created_at": "2017-09-12T16:43:11+00:00",
        "comment_author": "jeskew",
        "comment_body": "I'm not sure this method name reflects what the function does. How about 'getSkewCorrectedDate' or just 'getDate'?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "193597828",
    "pr_number": 2074,
    "pr_file": "lib/event-stream/format-message.js",
    "created_at": "2018-06-07T00:29:04+00:00",
    "commented_code": "var crypto = require('../../lib/util').crypto;\nvar Int64 = require('./int64').Int64;\nvar toBuffer = require('./to-buffer').toBuffer;\nvar allocBuffer = require('./alloc-buffer').allocBuffer;\n\nfunction formatMessage(message) {",
    "repo_full_name": "aws/aws-sdk-js",
    "discussion_comments": [
      {
        "comment_id": "193597828",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 2074,
        "pr_file": "lib/event-stream/format-message.js",
        "discussion_id": "193597828",
        "commented_code": "@@ -0,0 +1,166 @@\n+var crypto = require('../../lib/util').crypto;\n+var Int64 = require('./int64').Int64;\n+var toBuffer = require('./to-buffer').toBuffer;\n+var allocBuffer = require('./alloc-buffer').allocBuffer;\n+\n+function formatMessage(message) {",
        "comment_created_at": "2018-06-07T00:29:04+00:00",
        "comment_author": "AllanZhengYP",
        "comment_body": "This name is a bit confusing to me. `buildMessage` is probably a better name. Same for the `builderHeaders`",
        "pr_file_module": null
      },
      {
        "comment_id": "193619601",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 2074,
        "pr_file": "lib/event-stream/format-message.js",
        "discussion_id": "193597828",
        "commented_code": "@@ -0,0 +1,166 @@\n+var crypto = require('../../lib/util').crypto;\n+var Int64 = require('./int64').Int64;\n+var toBuffer = require('./to-buffer').toBuffer;\n+var allocBuffer = require('./alloc-buffer').allocBuffer;\n+\n+function formatMessage(message) {",
        "comment_created_at": "2018-06-07T03:55:00+00:00",
        "comment_author": "chrisradek",
        "comment_body": "Sure, I don't have a strong preference either way.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "227528680",
    "pr_number": 2253,
    "pr_file": "lib/discover_endpoint.js",
    "created_at": "2018-10-23T19:15:16+00:00",
    "commented_code": "var AWS = require('./core');\nvar util = require('./util');\nvar iniLoader = require('./shared-ini').iniLoader;\nvar ENDPOINT_OPERATION_MAX_RETRIES = 60;\nvar endpointDiscoveryEnabledEnv = 'AWS_ENABLE_ENDPOINT_DISCOVERY';\n\n/**\n * Generate key to index the endpoints in the cache\n * @return [map<String,String>] object with keys to index endpoints.\n * @api private\n */\nfunction getCacheKey(request) {\n  var service = request.service;\n  var api = service.api || {};\n  var operations = api.operations;\n  var identifiers = {};\n  if (operations[request.operation] && operations[request.operation].name) {\n    identifiers.operation = operations[request.operation].name;\n  }\n  if (service.config.region) {\n    identifiers.region = service.config.region;\n  }\n  if (api.serviceId) {\n    identifiers.serviceId = api.serviceId\n  }\n  if (service.config.credentials.accessKeyId) {\n    identifiers.accessKeyId = service.config.credentials.accessKeyId\n  }\n  return identifiers;\n}\n\n/**\n * @api private\n */\nfunction marshallCustomeIdentifiersHelper(result, params, shape) {\n  if (!shape || params === undefined || params === null) return;\n  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {\n    util.arrayEach(shape.required, function(name) {\n      var memberShape = shape.members[name];\n      if (memberShape.endpointDiscoveryId === true) {\n        var locationName = memberShape.isLocationName ? memberShape.name : name;\n        result[locationName] = String(params[name]);\n      } else {\n        marshallCustomeIdentifiersHelper(result, params[name], memberShape);\n      }\n    });\n  }\n}\n\n/**\n * Get customized cache key according to the 'endpointDiscoveryId' trait.\n * @param [object] request object\n * @param [object] input shape of the given operation's api\n */\nfunction marshallCustomeIdentifiers(request, shape) {\n  var identifiers = {};\n  marshallCustomeIdentifiersHelper(identifiers, request.params, shape);\n  return identifiers;\n}\n\n/**\n * Call endpoint discovery operation when it's optional.\n * When endpoint is available in cache then use the cached endpoints. If endpoints\n * are unavailable then use regional endpoints and call endpoint discovery operation\n * asynchronously. This is turned off by default.\n * @param [object] request object\n * @api private\n */\nfunction optionalDisverEndpoint(request) {",
    "repo_full_name": "aws/aws-sdk-js",
    "discussion_comments": [
      {
        "comment_id": "227528680",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 2253,
        "pr_file": "lib/discover_endpoint.js",
        "discussion_id": "227528680",
        "commented_code": "@@ -0,0 +1,305 @@\n+var AWS = require('./core');\n+var util = require('./util');\n+var iniLoader = require('./shared-ini').iniLoader;\n+var ENDPOINT_OPERATION_MAX_RETRIES = 60;\n+var endpointDiscoveryEnabledEnv = 'AWS_ENABLE_ENDPOINT_DISCOVERY';\n+\n+/**\n+ * Generate key to index the endpoints in the cache\n+ * @return [map<String,String>] object with keys to index endpoints.\n+ * @api private\n+ */\n+function getCacheKey(request) {\n+  var service = request.service;\n+  var api = service.api || {};\n+  var operations = api.operations;\n+  var identifiers = {};\n+  if (operations[request.operation] && operations[request.operation].name) {\n+    identifiers.operation = operations[request.operation].name;\n+  }\n+  if (service.config.region) {\n+    identifiers.region = service.config.region;\n+  }\n+  if (api.serviceId) {\n+    identifiers.serviceId = api.serviceId\n+  }\n+  if (service.config.credentials.accessKeyId) {\n+    identifiers.accessKeyId = service.config.credentials.accessKeyId\n+  }\n+  return identifiers;\n+}\n+\n+/**\n+ * @api private\n+ */\n+function marshallCustomeIdentifiersHelper(result, params, shape) {\n+  if (!shape || params === undefined || params === null) return;\n+  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {\n+    util.arrayEach(shape.required, function(name) {\n+      var memberShape = shape.members[name];\n+      if (memberShape.endpointDiscoveryId === true) {\n+        var locationName = memberShape.isLocationName ? memberShape.name : name;\n+        result[locationName] = String(params[name]);\n+      } else {\n+        marshallCustomeIdentifiersHelper(result, params[name], memberShape);\n+      }\n+    });\n+  }\n+}\n+\n+/**\n+ * Get customized cache key according to the 'endpointDiscoveryId' trait.\n+ * @param [object] request object\n+ * @param [object] input shape of the given operation's api\n+ */\n+function marshallCustomeIdentifiers(request, shape) {\n+  var identifiers = {};\n+  marshallCustomeIdentifiersHelper(identifiers, request.params, shape);\n+  return identifiers;\n+}\n+\n+/**\n+ * Call endpoint discovery operation when it's optional.\n+ * When endpoint is available in cache then use the cached endpoints. If endpoints\n+ * are unavailable then use regional endpoints and call endpoint discovery operation\n+ * asynchronously. This is turned off by default.\n+ * @param [object] request object\n+ * @api private\n+ */\n+function optionalDisverEndpoint(request) {",
        "comment_created_at": "2018-10-23T19:15:16+00:00",
        "comment_author": "chrisradek",
        "comment_body": "Can you spell out `optionalDiscoveryVersionEndpoint` (assuming that's what Disver means). `Disver` isn't a common abbreviation and coming back to this in the future it may be confusing what this means.",
        "pr_file_module": null
      },
      {
        "comment_id": "228002596",
        "repo_full_name": "aws/aws-sdk-js",
        "pr_number": 2253,
        "pr_file": "lib/discover_endpoint.js",
        "discussion_id": "227528680",
        "commented_code": "@@ -0,0 +1,305 @@\n+var AWS = require('./core');\n+var util = require('./util');\n+var iniLoader = require('./shared-ini').iniLoader;\n+var ENDPOINT_OPERATION_MAX_RETRIES = 60;\n+var endpointDiscoveryEnabledEnv = 'AWS_ENABLE_ENDPOINT_DISCOVERY';\n+\n+/**\n+ * Generate key to index the endpoints in the cache\n+ * @return [map<String,String>] object with keys to index endpoints.\n+ * @api private\n+ */\n+function getCacheKey(request) {\n+  var service = request.service;\n+  var api = service.api || {};\n+  var operations = api.operations;\n+  var identifiers = {};\n+  if (operations[request.operation] && operations[request.operation].name) {\n+    identifiers.operation = operations[request.operation].name;\n+  }\n+  if (service.config.region) {\n+    identifiers.region = service.config.region;\n+  }\n+  if (api.serviceId) {\n+    identifiers.serviceId = api.serviceId\n+  }\n+  if (service.config.credentials.accessKeyId) {\n+    identifiers.accessKeyId = service.config.credentials.accessKeyId\n+  }\n+  return identifiers;\n+}\n+\n+/**\n+ * @api private\n+ */\n+function marshallCustomeIdentifiersHelper(result, params, shape) {\n+  if (!shape || params === undefined || params === null) return;\n+  if (shape.type === 'structure' && shape.required && shape.required.length > 0) {\n+    util.arrayEach(shape.required, function(name) {\n+      var memberShape = shape.members[name];\n+      if (memberShape.endpointDiscoveryId === true) {\n+        var locationName = memberShape.isLocationName ? memberShape.name : name;\n+        result[locationName] = String(params[name]);\n+      } else {\n+        marshallCustomeIdentifiersHelper(result, params[name], memberShape);\n+      }\n+    });\n+  }\n+}\n+\n+/**\n+ * Get customized cache key according to the 'endpointDiscoveryId' trait.\n+ * @param [object] request object\n+ * @param [object] input shape of the given operation's api\n+ */\n+function marshallCustomeIdentifiers(request, shape) {\n+  var identifiers = {};\n+  marshallCustomeIdentifiersHelper(identifiers, request.params, shape);\n+  return identifiers;\n+}\n+\n+/**\n+ * Call endpoint discovery operation when it's optional.\n+ * When endpoint is available in cache then use the cached endpoints. If endpoints\n+ * are unavailable then use regional endpoints and call endpoint discovery operation\n+ * asynchronously. This is turned off by default.\n+ * @param [object] request object\n+ * @api private\n+ */\n+function optionalDisverEndpoint(request) {",
        "comment_created_at": "2018-10-25T00:27:24+00:00",
        "comment_author": "AllanZhengYP",
        "comment_body": "It is a typo. And my auto-completion respects my typo of this name elsewhere. Thank you for pointing this out",
        "pr_file_module": null
      }
    ]
  }
]
