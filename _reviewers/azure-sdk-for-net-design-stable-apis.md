---
title: Design stable APIs
description: When creating or modifying APIs, carefully consider what becomes part
  of your public API surface to ensure backward compatibility and consistent developer
  experience.
repository: Azure/azure-sdk-for-net
label: API
language: Markdown
comments_count: 7
repository_stars: 5809
---

When creating or modifying APIs, carefully consider what becomes part of your public API surface to ensure backward compatibility and consistent developer experience.

Key practices:
1. Use specific, descriptive names for API elements that follow established patterns (e.g., `TerraformAuthorizationScopeFilter` instead of generic `AuthorizationScopeFilter`)
2. Avoid exposing implementation details or utility methods that might need to change later
3. Ensure consistent behavior between related API methods (e.g., streaming and non-streaming variants should follow similar patterns)
4. Prefer strongly-typed parameters over generic types like Dictionary when possible
5. Maintain consistent terminology throughout code and documentation

Example:
```csharp
// GOOD: Specific, descriptive client name with consistent method naming
PersistentAgentsClient agentClient = projectClient.GetPersistentAgentsClient();

// BAD: Generic naming or inconsistent patterns
AgentsClient agentClient = projectClient.GetAgentsClient();

// GOOD: Strongly-typed parameters
private int GetHumidityByAddress(Address address)
{
    return (address.City == "Seattle") ? 60 : 80;
}

// BAD: Generic dictionary parameters that hide the actual structure
private int GetHumidityByAddress(Dictionary<string, string> address)
{
    return (address["City"] == "Seattle") ? 60 : 80;
}
```

Before adding new public API members, consider if they're truly necessary and ensure they won't need breaking changes in the future.


[
  {
    "discussion_id": "2180635446",
    "pr_number": 51023,
    "pr_file": "sdk/ai/Azure.AI.Projects/AGENTS_MIGRATION_GUIDE.md",
    "created_at": "2025-07-02T17:44:03+00:00",
    "commented_code": "# Agents migration guide from Hub-based projects to Endpoint-based projects.\nThis guide describes migration from hub-based to Endpoint-based projects. To create a Endpoint-based project, please use one of the deployment scripts on [foundry samples repository](https://github.com/azure-ai-foundry/foundry-samples/tree/main/samples/microsoft/infrastructure-setup) appropriate for your scenario, also you can use Azure AI Foundry UI. The support of hub-based projects was dropped in `Azure.AI.Projects` version `1.0.0-beta.9`. In this document, we show the operation implementation of before `1.0.0-beta.9` in **Hub-based** secion, followed by code for `azure-ai-projects` version `1.0.0-beta.9` or later in **Endpoint-based**.\n\n## Installation\nStarting from version `1.0.0-beta.9`, the operations, related to agents were moved to a separate package `Azure.AI.Agents.Persistent`. To use agents please add both `Azure.AI.Projects` and `Azure.AI.Agents.Persistent` packages into the project.\n```\ndotnet add package Azure.AI.Projects --version 1.0.0-beta.9\ndotnet add package Azure.AI.Agents.Persistent --version 1.1.0-beta.3\n```\n\n## Namespace changes\nAgents were moved to a new package and namespace `Azure.AI.Agents.Persistent`.\n\n## Class renamings\n| Hub-based | Endpoint-based |\n|-|-|\n| New in `1.0.0-beta.9` | `PersistentAgentsClient` |\n| `AgentsClient` | `PersistentAgentsAdministrationClient` |\n| `AgentsClientOptions` | `PersistentAgentsAdministrationClientOptions` |\n| `Agent` | `PersistentAgent` |\n| `AgentThread` | `PersistentAgentThread`|\n| `ThreadMessage` | `PersistentThreadMessage` |\n| `ThreadRun` | `ThreadRun` |\n| `AgentFile` | `PersistentAgentFileInfo` |\n| `VectorStore` | `PersistentAgentsVectorStore` |\n\n## Class structure changes\nHere `projectClient` is `AIProjectClient` and `agentClient` is `PersistentAgentsClient` for version `1.0.0-beta.9` and `AgentsClient` for earlier versions.\n\nAgents Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `projectClient.GetAgentsClient` | `projectClient.GetPersistentAgentsClient` |\n| `agentClient.CreateAgent` | `agentClient.Administration.CreateAgent` |\n| `agentClient.GetAgents` | `agentClient.Administration.GetAgents` |\n| `agentClient.GetAgent` | `agentClient.Administration..GetAgent` |\n| `agentClient.UpdateAgent` | `agentClient.Administration.UpdateAgent` |\n| `agentClient.Delete_agent` | `agentClient.Administration.DeleteAgent` |\n| `agentClient.CreateThreadAndRun` | `agentClient.CreateThreadAndRun` |\n\nThreads Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.CreateThread` | `agentClient.Threads.CreateThread` |\n| `agentClient.GetThread` | `agentClient.Threads.GetThread` |\n| `agentClient.UpdateThread` | `agentClient.Threads.UpdateThread` |\n| `agentClient.GetThreads` | `agentClient.Threads.GetThreads` |\n| `agentClient.DeleteThread` | `agentClient.Threads.DeleteThread` |\n\nMessages Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.CreateMessage` | `agentClient.Messages.CreateMessage` |\n| `agentClient.GetMessages` | `agentClient.Messages.GetMessages` |\n| `agentClient.GetMessage` | `pagentClient.Messages.GetMessage` |\n| `agentClient.UpdateMessage` | `agentClient.Messages.UpdateMessage` |\n\nRuns Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.CreateRun` | `agentClient.Runs.CreateRun` |\n| `agentClient.GetRun` | `agentClient.Runs.GetRun` |\n| `agentClient.GetRuns` | `agentClient.Runs.GetRuns` |\n| `agentClient.UpdateRun` | `agentClient.Runs.UpdateRun` |\n| `agentClient.CreateRunStreaming` | `agentClient.Runs.CreateRunStreaming` |\n| `agentClient.SubmitToolOutputsToRun` | `agentClient.Runs.SubmitToolOutputsToRun` |\n| `agentClient.SubmitToolOutputsToStream` | `agentClient.Runs.SubmitToolOutputsToStream` |\n| `agentClient.CancelRun` | `agentClient.Runs.CancelRun` |\n\nRun Steps Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.GetRunStep` | `agentClient.Runs.GetRunStep` |\n| `agentClient.GetRunSteps` | `agentClient.Runs.GetRunSteps` |\n\nVector Stores Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.CreateVectorStore` | `agentClient.VectorStores.CreateVectorStore |\n| `agentClient.GetVectorStores` | `agentClient.VectorStores.GetVectorStores |\n| `agentClient.GetVectorStore` | `agentClient.VectorStores.GetVectorStore |\n| `agentClient.ModifyVectorStore` | `agentClient.VectorStores.ModifyVectorStore |\n| `agentClient.DeleteVectorStore` | `agentClient.VectorStores.DeleteVectorStore |\n\nVector Store Files Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.GetVectorStoreFiles` | `agentClient.VectorStores.GetVectorStoreFiles` |\n| `agentClient.CreateVectorStoreFile` | `agentClient.VectorStores.CreateVectorStoreFile` |\n| `agentClient.GetVectorStoreFile` | `agentClient.VectorStores.GetVectorStoreFile` |\n| `agentClient.DeleteVectorStoreFile` | `agentClient.VectorStores.DeleteVectorStoreFile` |\n\nVector Store File Batches Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.CreateVectorStoreFileBatch` | `agentClient.VectorStores.CreateVectorStoreFileBatch`|\n| `agentClient.GetVectorStoreFileBatch` | `agentClient.VectorStores.GetVectorStoreFileBatch`|\n| `agentClient.GetVectorSroreFileBatchFiles` | `agentClient.VectorStores.GetVectorStoreFileBatchFiles`|\n| `agentClient.CancelVectorStoreFileBatch` | `agentClient.VectorStores.CancelVectorStoreFileBatch`|\n\nFiles Operations\n\n| Hub-based | Endpoint-based |\n|-|-|\n| `agentClient.UploadFile` | `agentClient.Files.UploadFile` |\n| `agentClient.GetFile` | `agentClient.Files.GetFile` |\n| `agentClient.GetFileContent` | `agentClient.Files.GetFileContent` |\n| `agentClient.GetFiles` | `agentClient.Files.GetFiles` |\n| `agentClient.DeleteFile` | `agentClient.Files.DeleteFile` |\n\n## API changes\n1. Create project. The connection string is replaced by the endpoint. The project endpoint URL has the form https://\\<your-ai-services-account-name\\>.services.ai.azure.com/api/projects/\\<your-project-name\\>. It can be found in your Azure AI Foundry Project overview page.\n\n    **Hub-based**\n    ```C#\n    AIProjectClient projectClient = new (\n        connectionString: connectionString,\n        credential: new DefaultAzureCredential());\n    ```\n\n    **Endpoint-based**\n    ```C#\n    AIProjectClient projectClient = new(endpoint: endpoint, credential: new DefaultAzureCredential())\n    ```\n2. Agents client. In the new `Azure.AI.Projects` version `1.0.0-beta.9` agents are managed using `PersistentAgentsClient` class. It can be obtained from `AIProjectClient` instance or can be created using constructor. The letter allows to provide additional options for the `PersistentAgentsClient`.\n\n    **Hub-based**\n    ```C#\n    AgentsClient agentClient = projectClient.GetAgentsClient();\n    ```\n\n    **Endpoint-based**\n    Create agent using `AIProjectClient`.\n    ```C#\n    AgentsClient agentClient = projectClient.GetAgentsClient();",
    "repo_full_name": "Azure/azure-sdk-for-net",
    "discussion_comments": [
      {
        "comment_id": "2180635446",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 51023,
        "pr_file": "sdk/ai/Azure.AI.Projects/AGENTS_MIGRATION_GUIDE.md",
        "discussion_id": "2180635446",
        "commented_code": "@@ -0,0 +1,615 @@\n+# Agents migration guide from Hub-based projects to Endpoint-based projects.\n+This guide describes migration from hub-based to Endpoint-based projects. To create a Endpoint-based project, please use one of the deployment scripts on [foundry samples repository](https://github.com/azure-ai-foundry/foundry-samples/tree/main/samples/microsoft/infrastructure-setup) appropriate for your scenario, also you can use Azure AI Foundry UI. The support of hub-based projects was dropped in `Azure.AI.Projects` version `1.0.0-beta.9`. In this document, we show the operation implementation of before `1.0.0-beta.9` in **Hub-based** secion, followed by code for `azure-ai-projects` version `1.0.0-beta.9` or later in **Endpoint-based**.\n+\n+## Installation\n+Starting from version `1.0.0-beta.9`, the operations, related to agents were moved to a separate package `Azure.AI.Agents.Persistent`. To use agents please add both `Azure.AI.Projects` and `Azure.AI.Agents.Persistent` packages into the project.\n+```\n+dotnet add package Azure.AI.Projects --version 1.0.0-beta.9\n+dotnet add package Azure.AI.Agents.Persistent --version 1.1.0-beta.3\n+```\n+\n+## Namespace changes\n+Agents were moved to a new package and namespace `Azure.AI.Agents.Persistent`.\n+\n+## Class renamings\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| New in `1.0.0-beta.9` | `PersistentAgentsClient` |\n+| `AgentsClient` | `PersistentAgentsAdministrationClient` |\n+| `AgentsClientOptions` | `PersistentAgentsAdministrationClientOptions` |\n+| `Agent` | `PersistentAgent` |\n+| `AgentThread` | `PersistentAgentThread`|\n+| `ThreadMessage` | `PersistentThreadMessage` |\n+| `ThreadRun` | `ThreadRun` |\n+| `AgentFile` | `PersistentAgentFileInfo` |\n+| `VectorStore` | `PersistentAgentsVectorStore` |\n+\n+## Class structure changes\n+Here `projectClient` is `AIProjectClient` and `agentClient` is `PersistentAgentsClient` for version `1.0.0-beta.9` and `AgentsClient` for earlier versions.\n+\n+Agents Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `projectClient.GetAgentsClient` | `projectClient.GetPersistentAgentsClient` |\n+| `agentClient.CreateAgent` | `agentClient.Administration.CreateAgent` |\n+| `agentClient.GetAgents` | `agentClient.Administration.GetAgents` |\n+| `agentClient.GetAgent` | `agentClient.Administration..GetAgent` |\n+| `agentClient.UpdateAgent` | `agentClient.Administration.UpdateAgent` |\n+| `agentClient.Delete_agent` | `agentClient.Administration.DeleteAgent` |\n+| `agentClient.CreateThreadAndRun` | `agentClient.CreateThreadAndRun` |\n+\n+Threads Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateThread` | `agentClient.Threads.CreateThread` |\n+| `agentClient.GetThread` | `agentClient.Threads.GetThread` |\n+| `agentClient.UpdateThread` | `agentClient.Threads.UpdateThread` |\n+| `agentClient.GetThreads` | `agentClient.Threads.GetThreads` |\n+| `agentClient.DeleteThread` | `agentClient.Threads.DeleteThread` |\n+\n+Messages Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateMessage` | `agentClient.Messages.CreateMessage` |\n+| `agentClient.GetMessages` | `agentClient.Messages.GetMessages` |\n+| `agentClient.GetMessage` | `pagentClient.Messages.GetMessage` |\n+| `agentClient.UpdateMessage` | `agentClient.Messages.UpdateMessage` |\n+\n+Runs Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateRun` | `agentClient.Runs.CreateRun` |\n+| `agentClient.GetRun` | `agentClient.Runs.GetRun` |\n+| `agentClient.GetRuns` | `agentClient.Runs.GetRuns` |\n+| `agentClient.UpdateRun` | `agentClient.Runs.UpdateRun` |\n+| `agentClient.CreateRunStreaming` | `agentClient.Runs.CreateRunStreaming` |\n+| `agentClient.SubmitToolOutputsToRun` | `agentClient.Runs.SubmitToolOutputsToRun` |\n+| `agentClient.SubmitToolOutputsToStream` | `agentClient.Runs.SubmitToolOutputsToStream` |\n+| `agentClient.CancelRun` | `agentClient.Runs.CancelRun` |\n+\n+Run Steps Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.GetRunStep` | `agentClient.Runs.GetRunStep` |\n+| `agentClient.GetRunSteps` | `agentClient.Runs.GetRunSteps` |\n+\n+Vector Stores Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateVectorStore` | `agentClient.VectorStores.CreateVectorStore |\n+| `agentClient.GetVectorStores` | `agentClient.VectorStores.GetVectorStores |\n+| `agentClient.GetVectorStore` | `agentClient.VectorStores.GetVectorStore |\n+| `agentClient.ModifyVectorStore` | `agentClient.VectorStores.ModifyVectorStore |\n+| `agentClient.DeleteVectorStore` | `agentClient.VectorStores.DeleteVectorStore |\n+\n+Vector Store Files Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.GetVectorStoreFiles` | `agentClient.VectorStores.GetVectorStoreFiles` |\n+| `agentClient.CreateVectorStoreFile` | `agentClient.VectorStores.CreateVectorStoreFile` |\n+| `agentClient.GetVectorStoreFile` | `agentClient.VectorStores.GetVectorStoreFile` |\n+| `agentClient.DeleteVectorStoreFile` | `agentClient.VectorStores.DeleteVectorStoreFile` |\n+\n+Vector Store File Batches Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateVectorStoreFileBatch` | `agentClient.VectorStores.CreateVectorStoreFileBatch`|\n+| `agentClient.GetVectorStoreFileBatch` | `agentClient.VectorStores.GetVectorStoreFileBatch`|\n+| `agentClient.GetVectorSroreFileBatchFiles` | `agentClient.VectorStores.GetVectorStoreFileBatchFiles`|\n+| `agentClient.CancelVectorStoreFileBatch` | `agentClient.VectorStores.CancelVectorStoreFileBatch`|\n+\n+Files Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.UploadFile` | `agentClient.Files.UploadFile` |\n+| `agentClient.GetFile` | `agentClient.Files.GetFile` |\n+| `agentClient.GetFileContent` | `agentClient.Files.GetFileContent` |\n+| `agentClient.GetFiles` | `agentClient.Files.GetFiles` |\n+| `agentClient.DeleteFile` | `agentClient.Files.DeleteFile` |\n+\n+## API changes\n+1. Create project. The connection string is replaced by the endpoint. The project endpoint URL has the form https://\\<your-ai-services-account-name\\>.services.ai.azure.com/api/projects/\\<your-project-name\\>. It can be found in your Azure AI Foundry Project overview page.\n+\n+    **Hub-based**\n+    ```C#\n+    AIProjectClient projectClient = new (\n+        connectionString: connectionString,\n+        credential: new DefaultAzureCredential());\n+    ```\n+\n+    **Endpoint-based**\n+    ```C#\n+    AIProjectClient projectClient = new(endpoint: endpoint, credential: new DefaultAzureCredential())\n+    ```\n+2. Agents client. In the new `Azure.AI.Projects` version `1.0.0-beta.9` agents are managed using `PersistentAgentsClient` class. It can be obtained from `AIProjectClient` instance or can be created using constructor. The letter allows to provide additional options for the `PersistentAgentsClient`.\n+\n+    **Hub-based**\n+    ```C#\n+    AgentsClient agentClient = projectClient.GetAgentsClient();\n+    ```\n+\n+    **Endpoint-based**\n+    Create agent using `AIProjectClient`.\n+    ```C#\n+    AgentsClient agentClient = projectClient.GetAgentsClient();",
        "comment_created_at": "2025-07-02T17:44:03+00:00",
        "comment_author": "Copilot",
        "comment_body": "Endpoint-based example should use `PersistentAgentsClient` and `GetPersistentAgentsClient()` rather than `AgentsClient`/`GetAgentsClient()`.\n```suggestion\n    PersistentAgentsClient agentClient = projectClient.GetPersistentAgentsClient();\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2180676387",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 51023,
        "pr_file": "sdk/ai/Azure.AI.Projects/AGENTS_MIGRATION_GUIDE.md",
        "discussion_id": "2180635446",
        "commented_code": "@@ -0,0 +1,615 @@\n+# Agents migration guide from Hub-based projects to Endpoint-based projects.\n+This guide describes migration from hub-based to Endpoint-based projects. To create a Endpoint-based project, please use one of the deployment scripts on [foundry samples repository](https://github.com/azure-ai-foundry/foundry-samples/tree/main/samples/microsoft/infrastructure-setup) appropriate for your scenario, also you can use Azure AI Foundry UI. The support of hub-based projects was dropped in `Azure.AI.Projects` version `1.0.0-beta.9`. In this document, we show the operation implementation of before `1.0.0-beta.9` in **Hub-based** secion, followed by code for `azure-ai-projects` version `1.0.0-beta.9` or later in **Endpoint-based**.\n+\n+## Installation\n+Starting from version `1.0.0-beta.9`, the operations, related to agents were moved to a separate package `Azure.AI.Agents.Persistent`. To use agents please add both `Azure.AI.Projects` and `Azure.AI.Agents.Persistent` packages into the project.\n+```\n+dotnet add package Azure.AI.Projects --version 1.0.0-beta.9\n+dotnet add package Azure.AI.Agents.Persistent --version 1.1.0-beta.3\n+```\n+\n+## Namespace changes\n+Agents were moved to a new package and namespace `Azure.AI.Agents.Persistent`.\n+\n+## Class renamings\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| New in `1.0.0-beta.9` | `PersistentAgentsClient` |\n+| `AgentsClient` | `PersistentAgentsAdministrationClient` |\n+| `AgentsClientOptions` | `PersistentAgentsAdministrationClientOptions` |\n+| `Agent` | `PersistentAgent` |\n+| `AgentThread` | `PersistentAgentThread`|\n+| `ThreadMessage` | `PersistentThreadMessage` |\n+| `ThreadRun` | `ThreadRun` |\n+| `AgentFile` | `PersistentAgentFileInfo` |\n+| `VectorStore` | `PersistentAgentsVectorStore` |\n+\n+## Class structure changes\n+Here `projectClient` is `AIProjectClient` and `agentClient` is `PersistentAgentsClient` for version `1.0.0-beta.9` and `AgentsClient` for earlier versions.\n+\n+Agents Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `projectClient.GetAgentsClient` | `projectClient.GetPersistentAgentsClient` |\n+| `agentClient.CreateAgent` | `agentClient.Administration.CreateAgent` |\n+| `agentClient.GetAgents` | `agentClient.Administration.GetAgents` |\n+| `agentClient.GetAgent` | `agentClient.Administration..GetAgent` |\n+| `agentClient.UpdateAgent` | `agentClient.Administration.UpdateAgent` |\n+| `agentClient.Delete_agent` | `agentClient.Administration.DeleteAgent` |\n+| `agentClient.CreateThreadAndRun` | `agentClient.CreateThreadAndRun` |\n+\n+Threads Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateThread` | `agentClient.Threads.CreateThread` |\n+| `agentClient.GetThread` | `agentClient.Threads.GetThread` |\n+| `agentClient.UpdateThread` | `agentClient.Threads.UpdateThread` |\n+| `agentClient.GetThreads` | `agentClient.Threads.GetThreads` |\n+| `agentClient.DeleteThread` | `agentClient.Threads.DeleteThread` |\n+\n+Messages Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateMessage` | `agentClient.Messages.CreateMessage` |\n+| `agentClient.GetMessages` | `agentClient.Messages.GetMessages` |\n+| `agentClient.GetMessage` | `pagentClient.Messages.GetMessage` |\n+| `agentClient.UpdateMessage` | `agentClient.Messages.UpdateMessage` |\n+\n+Runs Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateRun` | `agentClient.Runs.CreateRun` |\n+| `agentClient.GetRun` | `agentClient.Runs.GetRun` |\n+| `agentClient.GetRuns` | `agentClient.Runs.GetRuns` |\n+| `agentClient.UpdateRun` | `agentClient.Runs.UpdateRun` |\n+| `agentClient.CreateRunStreaming` | `agentClient.Runs.CreateRunStreaming` |\n+| `agentClient.SubmitToolOutputsToRun` | `agentClient.Runs.SubmitToolOutputsToRun` |\n+| `agentClient.SubmitToolOutputsToStream` | `agentClient.Runs.SubmitToolOutputsToStream` |\n+| `agentClient.CancelRun` | `agentClient.Runs.CancelRun` |\n+\n+Run Steps Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.GetRunStep` | `agentClient.Runs.GetRunStep` |\n+| `agentClient.GetRunSteps` | `agentClient.Runs.GetRunSteps` |\n+\n+Vector Stores Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateVectorStore` | `agentClient.VectorStores.CreateVectorStore |\n+| `agentClient.GetVectorStores` | `agentClient.VectorStores.GetVectorStores |\n+| `agentClient.GetVectorStore` | `agentClient.VectorStores.GetVectorStore |\n+| `agentClient.ModifyVectorStore` | `agentClient.VectorStores.ModifyVectorStore |\n+| `agentClient.DeleteVectorStore` | `agentClient.VectorStores.DeleteVectorStore |\n+\n+Vector Store Files Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.GetVectorStoreFiles` | `agentClient.VectorStores.GetVectorStoreFiles` |\n+| `agentClient.CreateVectorStoreFile` | `agentClient.VectorStores.CreateVectorStoreFile` |\n+| `agentClient.GetVectorStoreFile` | `agentClient.VectorStores.GetVectorStoreFile` |\n+| `agentClient.DeleteVectorStoreFile` | `agentClient.VectorStores.DeleteVectorStoreFile` |\n+\n+Vector Store File Batches Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.CreateVectorStoreFileBatch` | `agentClient.VectorStores.CreateVectorStoreFileBatch`|\n+| `agentClient.GetVectorStoreFileBatch` | `agentClient.VectorStores.GetVectorStoreFileBatch`|\n+| `agentClient.GetVectorSroreFileBatchFiles` | `agentClient.VectorStores.GetVectorStoreFileBatchFiles`|\n+| `agentClient.CancelVectorStoreFileBatch` | `agentClient.VectorStores.CancelVectorStoreFileBatch`|\n+\n+Files Operations\n+\n+| Hub-based | Endpoint-based |\n+|-|-|\n+| `agentClient.UploadFile` | `agentClient.Files.UploadFile` |\n+| `agentClient.GetFile` | `agentClient.Files.GetFile` |\n+| `agentClient.GetFileContent` | `agentClient.Files.GetFileContent` |\n+| `agentClient.GetFiles` | `agentClient.Files.GetFiles` |\n+| `agentClient.DeleteFile` | `agentClient.Files.DeleteFile` |\n+\n+## API changes\n+1. Create project. The connection string is replaced by the endpoint. The project endpoint URL has the form https://\\<your-ai-services-account-name\\>.services.ai.azure.com/api/projects/\\<your-project-name\\>. It can be found in your Azure AI Foundry Project overview page.\n+\n+    **Hub-based**\n+    ```C#\n+    AIProjectClient projectClient = new (\n+        connectionString: connectionString,\n+        credential: new DefaultAzureCredential());\n+    ```\n+\n+    **Endpoint-based**\n+    ```C#\n+    AIProjectClient projectClient = new(endpoint: endpoint, credential: new DefaultAzureCredential())\n+    ```\n+2. Agents client. In the new `Azure.AI.Projects` version `1.0.0-beta.9` agents are managed using `PersistentAgentsClient` class. It can be obtained from `AIProjectClient` instance or can be created using constructor. The letter allows to provide additional options for the `PersistentAgentsClient`.\n+\n+    **Hub-based**\n+    ```C#\n+    AgentsClient agentClient = projectClient.GetAgentsClient();\n+    ```\n+\n+    **Endpoint-based**\n+    Create agent using `AIProjectClient`.\n+    ```C#\n+    AgentsClient agentClient = projectClient.GetAgentsClient();",
        "comment_created_at": "2025-07-02T18:08:51+00:00",
        "comment_author": "nick863",
        "comment_body": "Fixed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2170502909",
    "pr_number": 50575,
    "pr_file": ".github/copilot-instructions.md",
    "created_at": "2025-06-27T01:47:40+00:00",
    "commented_code": "# Repository information\nNote that files in this repository are generally organized in the following way:\n- `azure-sdk-for-net/sdk/{service-directory}/{package-name}` holds everything for a specific Azure SDK package.\n- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/src` holds the source code for the package.\n- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/tests` holds the tests for the package.\n- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/samples` holds the samples for the package.\n\nThere are a few exceptions where package-name is replaced with a shorter directory name. For example in the cognitiveservices directory. The package `Microsoft.Azure.CognitiveServices.Language.SpellCheck` can be found in `azure-sdk-for-net/sdk/cognitiveservices/Language.SpellCheck`. When in doubt, you can look at the name of the .csproj file within the src folder to determine the package name.\n\n## Definitions:\n- \"service directory\" refers to the folder under `sdk`. For example, `azure-sdk-for-net/sdk/eventhub`, `eventhub` is the service directory\n- \"data plane\" refers to packages that don't include `ResourceManager` in the package name. They are used to interact with azure resources at application run time.\n- \"management plane\" refers to packages that include `ResourceManager` in the package name. They are used to manage (create/modify/delete) azure resources.\n- \"track 2\" refers to packages that start with `Azure`. Unless otherwise specified, assume that references to \"data plane\" mean \"track 2 data plane\", i.e. packages that start with `Azure` and don't include `ResourceManager` in the package name. Unless otherwise specified, assume that references to \"management plane\" mean \"track 2 management plane\", i.e. packages that start with `Azure.ResourceManager`.\n- \"functions extensions packages\" or sometimes just \"extensions packages\" refers to packages that start with `Microsoft.Azure.WebJobs.Extensions`. They are built on data plane packages and are used with Azure Functions.\n\n# Requirements\n- If you are writing C# code within the `azure-sdk-for-net/sdk` directory:\n    1. Follow the coding guidelines in the \"Coding guidelines\" section below.\n    2. You should never manually make changes to `*/Generated/*` files, e.g. `azure-sdk-for-net/sdk/containerregistry/Azure.Containers.ContainerRegistry/src/Generated/`\n        - Only re-generate these files if instructed to do so. If you are instructed to regenerate an SDK, use `dotnet build /t:GenerateCode`\n        - If you feel like you need to make changes to these files beyond re-generating them in order to complete your task, do not do this, instead see if you can work around the problem in the code that is not in the `Generated` folder. If you can't, report this to the user.\n    3. Code should build successfully using the following steps:\n        - navigate to the root of the repository and run `dotnet build eng\\service.proj /p:ServiceDirectory={service-directory}` for each service directory you modified. For example, if you modified code in `sdk/eventhub` and `sdk/keyvault`, you would run:\n          `dotnet build eng\\service.proj /p:ServiceDirectory=eventhub` and `dotnet build eng\\service.proj /p:ServiceDirectory=keyvault`\n        - If you see build errors, try to fix them, if you can't fix them within 5 iterations, give up, do not do steps 4 or 5, and report this to the user. Do not report success if the build fails!\n    4. Once the code builds, run the unit tests using `dotnet test eng/service.proj /p:ServiceDirectory={service-directory} --filter TestCategory!=Live` for each service directory you modified. Try to fix failures if you can within 5 iterations. If you can't, give up and report this to the user. Do not report success if the tests fail!",
    "repo_full_name": "Azure/azure-sdk-for-net",
    "discussion_comments": [
      {
        "comment_id": "2170502909",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 50575,
        "pr_file": ".github/copilot-instructions.md",
        "discussion_id": "2170502909",
        "commented_code": "@@ -0,0 +1,34 @@\n+# Repository information\n+Note that files in this repository are generally organized in the following way:\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}` holds everything for a specific Azure SDK package.\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/src` holds the source code for the package.\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/tests` holds the tests for the package.\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/samples` holds the samples for the package.\n+\n+There are a few exceptions where package-name is replaced with a shorter directory name. For example in the cognitiveservices directory. The package `Microsoft.Azure.CognitiveServices.Language.SpellCheck` can be found in `azure-sdk-for-net/sdk/cognitiveservices/Language.SpellCheck`. When in doubt, you can look at the name of the .csproj file within the src folder to determine the package name.\n+\n+## Definitions:\n+- \"service directory\" refers to the folder under `sdk`. For example, `azure-sdk-for-net/sdk/eventhub`, `eventhub` is the service directory\n+- \"data plane\" refers to packages that don't include `ResourceManager` in the package name. They are used to interact with azure resources at application run time.\n+- \"management plane\" refers to packages that include `ResourceManager` in the package name. They are used to manage (create/modify/delete) azure resources.\n+- \"track 2\" refers to packages that start with `Azure`. Unless otherwise specified, assume that references to \"data plane\" mean \"track 2 data plane\", i.e. packages that start with `Azure` and don't include `ResourceManager` in the package name. Unless otherwise specified, assume that references to \"management plane\" mean \"track 2 management plane\", i.e. packages that start with `Azure.ResourceManager`.\n+- \"functions extensions packages\" or sometimes just \"extensions packages\" refers to packages that start with `Microsoft.Azure.WebJobs.Extensions`. They are built on data plane packages and are used with Azure Functions.\n+\n+# Requirements\n+- If you are writing C# code within the `azure-sdk-for-net/sdk` directory:\n+    1. Follow the coding guidelines in the \"Coding guidelines\" section below.\n+    2. You should never manually make changes to `*/Generated/*` files, e.g. `azure-sdk-for-net/sdk/containerregistry/Azure.Containers.ContainerRegistry/src/Generated/`\n+        - Only re-generate these files if instructed to do so. If you are instructed to regenerate an SDK, use `dotnet build /t:GenerateCode`\n+        - If you feel like you need to make changes to these files beyond re-generating them in order to complete your task, do not do this, instead see if you can work around the problem in the code that is not in the `Generated` folder. If you can't, report this to the user.\n+    3. Code should build successfully using the following steps:\n+        - navigate to the root of the repository and run `dotnet build eng\\service.proj /p:ServiceDirectory={service-directory}` for each service directory you modified. For example, if you modified code in `sdk/eventhub` and `sdk/keyvault`, you would run:\n+          `dotnet build eng\\service.proj /p:ServiceDirectory=eventhub` and `dotnet build eng\\service.proj /p:ServiceDirectory=keyvault`\n+        - If you see build errors, try to fix them, if you can't fix them within 5 iterations, give up, do not do steps 4 or 5, and report this to the user. Do not report success if the build fails!\n+    4. Once the code builds, run the unit tests using `dotnet test eng/service.proj /p:ServiceDirectory={service-directory} --filter TestCategory!=Live` for each service directory you modified. Try to fix failures if you can within 5 iterations. If you can't, give up and report this to the user. Do not report success if the tests fail!",
        "comment_created_at": "2025-06-27T01:47:40+00:00",
        "comment_author": "jsquire",
        "comment_body": "We should consider adding one that instructs it to avoid making any breaking change to a public API and avoid adding public API members unless explicitly instructed to do so.",
        "pr_file_module": null
      },
      {
        "comment_id": "2172760547",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 50575,
        "pr_file": ".github/copilot-instructions.md",
        "discussion_id": "2170502909",
        "commented_code": "@@ -0,0 +1,34 @@\n+# Repository information\n+Note that files in this repository are generally organized in the following way:\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}` holds everything for a specific Azure SDK package.\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/src` holds the source code for the package.\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/tests` holds the tests for the package.\n+- `azure-sdk-for-net/sdk/{service-directory}/{package-name}/samples` holds the samples for the package.\n+\n+There are a few exceptions where package-name is replaced with a shorter directory name. For example in the cognitiveservices directory. The package `Microsoft.Azure.CognitiveServices.Language.SpellCheck` can be found in `azure-sdk-for-net/sdk/cognitiveservices/Language.SpellCheck`. When in doubt, you can look at the name of the .csproj file within the src folder to determine the package name.\n+\n+## Definitions:\n+- \"service directory\" refers to the folder under `sdk`. For example, `azure-sdk-for-net/sdk/eventhub`, `eventhub` is the service directory\n+- \"data plane\" refers to packages that don't include `ResourceManager` in the package name. They are used to interact with azure resources at application run time.\n+- \"management plane\" refers to packages that include `ResourceManager` in the package name. They are used to manage (create/modify/delete) azure resources.\n+- \"track 2\" refers to packages that start with `Azure`. Unless otherwise specified, assume that references to \"data plane\" mean \"track 2 data plane\", i.e. packages that start with `Azure` and don't include `ResourceManager` in the package name. Unless otherwise specified, assume that references to \"management plane\" mean \"track 2 management plane\", i.e. packages that start with `Azure.ResourceManager`.\n+- \"functions extensions packages\" or sometimes just \"extensions packages\" refers to packages that start with `Microsoft.Azure.WebJobs.Extensions`. They are built on data plane packages and are used with Azure Functions.\n+\n+# Requirements\n+- If you are writing C# code within the `azure-sdk-for-net/sdk` directory:\n+    1. Follow the coding guidelines in the \"Coding guidelines\" section below.\n+    2. You should never manually make changes to `*/Generated/*` files, e.g. `azure-sdk-for-net/sdk/containerregistry/Azure.Containers.ContainerRegistry/src/Generated/`\n+        - Only re-generate these files if instructed to do so. If you are instructed to regenerate an SDK, use `dotnet build /t:GenerateCode`\n+        - If you feel like you need to make changes to these files beyond re-generating them in order to complete your task, do not do this, instead see if you can work around the problem in the code that is not in the `Generated` folder. If you can't, report this to the user.\n+    3. Code should build successfully using the following steps:\n+        - navigate to the root of the repository and run `dotnet build eng\\service.proj /p:ServiceDirectory={service-directory}` for each service directory you modified. For example, if you modified code in `sdk/eventhub` and `sdk/keyvault`, you would run:\n+          `dotnet build eng\\service.proj /p:ServiceDirectory=eventhub` and `dotnet build eng\\service.proj /p:ServiceDirectory=keyvault`\n+        - If you see build errors, try to fix them, if you can't fix them within 5 iterations, give up, do not do steps 4 or 5, and report this to the user. Do not report success if the build fails!\n+    4. Once the code builds, run the unit tests using `dotnet test eng/service.proj /p:ServiceDirectory={service-directory} --filter TestCategory!=Live` for each service directory you modified. Try to fix failures if you can within 5 iterations. If you can't, give up and report this to the user. Do not report success if the tests fail!",
        "comment_created_at": "2025-06-27T19:47:02+00:00",
        "comment_author": "m-redding",
        "comment_body": "I added one below, I'll test it over the next couple days and see if the copilot follows it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2170843437",
    "pr_number": 50712,
    "pr_file": "sdk/terraform/Azure.ResourceManager.Terraform/CHANGELOG.md",
    "created_at": "2025-06-27T05:47:43+00:00",
    "commented_code": "# Release History\n\n## 1.0.0-beta.2 (Unreleased)\n## 1.0.0-beta.2 (2025-06-19)\n\n### Features Added\n\n### Breaking Changes\n- **Support for Exclusion Filters in Export Operations**:\n  - Added `ExcludeAzureResource` and `ExcludeTerraformResource` properties to export parameter models,\n    these allow users to exclude resources from being exported based on Azure resource ID patterns or Terraform resource types.\n\n### Bugs Fixed\n- **Authorization Scope Filter Support**:\n  - Introduced the `AuthorizationScopeFilter` struct, enabling fine-grained control over the scope of Azure Resource Graph queries during export.",
    "repo_full_name": "Azure/azure-sdk-for-net",
    "discussion_comments": [
      {
        "comment_id": "2170843437",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 50712,
        "pr_file": "sdk/terraform/Azure.ResourceManager.Terraform/CHANGELOG.md",
        "discussion_id": "2170843437",
        "commented_code": "@@ -1,14 +1,21 @@\n # Release History\n \n-## 1.0.0-beta.2 (Unreleased)\n+## 1.0.0-beta.2 (2025-06-19)\n \n ### Features Added\n \n-### Breaking Changes\n+- **Support for Exclusion Filters in Export Operations**:\n+  - Added `ExcludeAzureResource` and `ExcludeTerraformResource` properties to export parameter models,\n+    these allow users to exclude resources from being exported based on Azure resource ID patterns or Terraform resource types.\n \n-### Bugs Fixed\n+- **Authorization Scope Filter Support**:\n+  - Introduced the `AuthorizationScopeFilter` struct, enabling fine-grained control over the scope of Azure Resource Graph queries during export.",
        "comment_created_at": "2025-06-27T05:47:43+00:00",
        "comment_author": "ArcturusZhang",
        "comment_body": "```suggestion\r\n  - Introduced the `TerraformAuthorizationScopeFilter` struct, enabling fine-grained control over the scope of Azure Resource Graph queries during export.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2170860019",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 50712,
        "pr_file": "sdk/terraform/Azure.ResourceManager.Terraform/CHANGELOG.md",
        "discussion_id": "2170843437",
        "commented_code": "@@ -1,14 +1,21 @@\n # Release History\n \n-## 1.0.0-beta.2 (Unreleased)\n+## 1.0.0-beta.2 (2025-06-19)\n \n ### Features Added\n \n-### Breaking Changes\n+- **Support for Exclusion Filters in Export Operations**:\n+  - Added `ExcludeAzureResource` and `ExcludeTerraformResource` properties to export parameter models,\n+    these allow users to exclude resources from being exported based on Azure resource ID patterns or Terraform resource types.\n \n-### Bugs Fixed\n+- **Authorization Scope Filter Support**:\n+  - Introduced the `AuthorizationScopeFilter` struct, enabling fine-grained control over the scope of Azure Resource Graph queries during export.",
        "comment_created_at": "2025-06-27T05:55:40+00:00",
        "comment_author": "gerrytan",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2058806603",
    "pr_number": 49293,
    "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
    "created_at": "2025-04-24T16:12:44+00:00",
    "commented_code": "while (toolOutputs.Count > 0);\n```\n\n#### Function call executed automatically\n\nIn addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n\nHere we use other functions for demonstration:\n```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\nprivate class Address\n{\n    public string Street { get; set; }\n    public string City { get; set; }\n}\n\nprivate int GetHumidityByAddress(Address address)\n{\n    return (address.City == \"Seattle\") ? 60 : 80;\n}\n\nprivate string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")",
    "repo_full_name": "Azure/azure-sdk-for-net",
    "discussion_comments": [
      {
        "comment_id": "2058806603",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058806603",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")",
        "comment_created_at": "2025-04-24T16:12:44+00:00",
        "comment_author": "KrzysztofCwalina",
        "comment_body": "Why do you get JSON parsed into Dictionary here? If we don't have time to add higher level helpers, we should just keep using raw JSON, i.e. UTF8 bytes wrapped in BinaryData. Then a reoutine like this would simply use one of the JSON parsers to parse the addresses and unit. \r\n\r\nAlso, long term we really need to be able to create methods like this that take Address[] as a parameter. Will we be able to do it? i.e. how will your code know whether the delegate accepts JSON or Address[]?",
        "pr_file_module": null
      },
      {
        "comment_id": "2058955957",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058806603",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")",
        "comment_created_at": "2025-04-24T17:51:45+00:00",
        "comment_author": "howieleung",
        "comment_body": "I am just showing developers that we support Dictionary type.   I can change to Address[]",
        "pr_file_module": null
      },
      {
        "comment_id": "2059163033",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058806603",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")",
        "comment_created_at": "2025-04-24T20:17:52+00:00",
        "comment_author": "KrzysztofCwalina",
        "comment_body": "I don't think we should support dictionary like that. It just adds complexity and is not a nice API for the users",
        "pr_file_module": null
      },
      {
        "comment_id": "2060553553",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058806603",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")",
        "comment_created_at": "2025-04-25T16:33:17+00:00",
        "comment_author": "howieleung",
        "comment_body": "Took it off.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2058822771",
    "pr_number": 49293,
    "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
    "created_at": "2025-04-24T16:22:52+00:00",
    "commented_code": "while (toolOutputs.Count > 0);\n```\n\n#### Function call executed automatically\n\nIn addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n\nHere we use other functions for demonstration:\n```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\nprivate class Address\n{\n    public string Street { get; set; }\n    public string City { get; set; }\n}\n\nprivate int GetHumidityByAddress(Address address)\n{\n    return (address.City == \"Seattle\") ? 60 : 80;\n}\n\nprivate string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n{\n    string[] temps = new string[addresses.Length];\n    for (int i = 0; i < addresses.Length; i++)\n    {\n        if (addresses[i].TryGetValue(\"city\", out string city))\n        {\n            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n        }\n        else\n        {\n            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n        }\n    }\n    return temps;\n}\n```\nNow we define the function definitions:\n```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\nprivate FunctionToolDefinition geHhumidityByAddressTool = new(\n     name: \"GetHumidityByAddress\",\n     description: \"Get humidity by street and city\",\n     parameters: BinaryData.FromObjectAsJson(\n     new\n     {\n         Type = \"object\",\n         Properties = new\n         {\n             Address = new\n             {\n                 Type = \"object\",\n                 Properties = new\n                 {\n                     Street = new\n                     {\n                         Type = \"string\",\n                         Description = \"Street\"\n                     },\n                     City = new\n                     {\n                         Type = \"string\",\n                         Description = \"city\"\n                     },\n                 },\n                 Required = new[] { \"street\", \"city\" }\n             }\n         },\n         Required = new[] { \"address\" }\n     },\n     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n\nprivate FunctionToolDefinition getWeatherByAddressesTool = new(\n     name: \"GetWeatherByAddresses\",\n     description: \"Get weather by street and city\",\n     parameters: BinaryData.FromObjectAsJson(\n     new\n     {\n         Type = \"object\",\n         Properties = new\n         {\n             Addresses = new\n             {\n                 Type = \"array\",\n                 Description = \"A list of addresses\",\n                 Items = new\n                 {\n                     Type = \"object\",\n                     Properties = new\n                     {\n                         Street = new\n                         {\n                             Type = \"string\",\n                             Description = \"Street\"\n                         },\n                         City = new\n                         {\n                             Type = \"string\",\n                             description = \"city\"\n                         },\n                     },\n                     Required = new[] { \"street\", \"city\" }\n                 }\n             },\n             Unit = new\n             {\n                 Type = \"string\",\n                 Enum = new[] { \"c\", \"f\" },\n             },\n         },\n         Required = new[] { \"addresses\" }\n     },\n     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n```\nUse `EnableAutoFunctionCall` to enable the auto function call:\n```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\nList<ToolOutput> toolOutputs = new();\nDictionary<string, Delegate> delegates = new();\ndelegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\ndelegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\nAIProjectClientOptions options = new();\noptions.EnableAutoFunctionCalls(delegates);\n\nAgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n```\n\n\nWhen you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\nAgent agent = client.CreateAgent(\n    model: modelDeploymentName,\n    name: \"SDK Test Agent - Functions\",\n        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n            + \"nicknames for cities whenever possible.\",\n    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n);\n```\n\nWe create a thread and message similar to the example of manual function tool calls:\n```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\nAgentThread thread = client.CreateThread();\n\nThreadMessage message = client.CreateMessage(\n    thread.Id,\n    MessageRole.User,\n    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n```\n\nThe agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
    "repo_full_name": "Azure/azure-sdk-for-net",
    "discussion_comments": [
      {
        "comment_id": "2058822771",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-24T16:22:52+00:00",
        "comment_author": "KrzysztofCwalina",
        "comment_body": "do we really need streaming runs here? Can we just use a simple completion?",
        "pr_file_module": null
      },
      {
        "comment_id": "2058964616",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-24T17:56:02+00:00",
        "comment_author": "howieleung",
        "comment_body": "Auto function calling only support for streaming.   For non-streaming, they need to have a while loop to call getRun.   When the run say required_action, they need to call the function manually.",
        "pr_file_module": null
      },
      {
        "comment_id": "2059165687",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-24T20:20:04+00:00",
        "comment_author": "KrzysztofCwalina",
        "comment_body": "why would we not support non-streaming? This seems like very suprising design for the user. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2060527319",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-25T16:13:44+00:00",
        "comment_author": "howieleung",
        "comment_body": "Because for non-streaming, developers write their own while loop to iterate the run.   The function call must be made within the while loop.   If the while loop is inside of the SDK, yes, I would want to call the function for them.   ",
        "pr_file_module": null
      },
      {
        "comment_id": "2060675130",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-25T18:04:50+00:00",
        "comment_author": "KrzysztofCwalina",
        "comment_body": "isn't the await foreach below the same as the while loop?",
        "pr_file_module": null
      },
      {
        "comment_id": "2060919485",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-25T21:44:47+00:00",
        "comment_author": "howieleung",
        "comment_body": "It isn't because whether it is a for-loop or while -loop.    I\r\nDuring streaming, the SDK inside run a loop to go through the events and I can add code to call functions.  Regardless it needs to call function or not, we than `yeild return` the content out.    \r\nOn the other hand, for non-streaming, users call getRun again and again in a loop until thread status is completed.    Inside of the SDK, getRun does not have loop for me to do function call, submit output, and call function again, and retry if necessary.   Users have to make function call manually inside of their loop.\r\nThe same design happens  in Python SDK and SK as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "2061034362",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-25T23:41:45+00:00",
        "comment_author": "KrzysztofCwalina",
        "comment_body": "Then maybe we just move this off the client options and pass it to the streaming completion methods. As of right not, the API is confusing: the user initializes the client to do auto tool calls and then the client won't do auto tool calls unless the user calls the streaming APIs. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2062953026",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2058822771",
        "commented_code": "@@ -647,6 +648,172 @@ do\n while (toolOutputs.Count > 0);\n ```\n \n+#### Function call executed automatically\n+\n+In addition to the manual function calls, SDK supports automatic function calling.  Here is the example:\n+\n+Here we use other functions for demonstration:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctions\n+private class Address\n+{\n+    public string Street { get; set; }\n+    public string City { get; set; }\n+}\n+\n+private int GetHumidityByAddress(Address address)\n+{\n+    return (address.City == \"Seattle\") ? 60 : 80;\n+}\n+\n+private string[] GetWeatherByAddresses(Dictionary<string, string>[] addresses, string unit = \"F\")\n+{\n+    string[] temps = new string[addresses.Length];\n+    for (int i = 0; i < addresses.Length; i++)\n+    {\n+        if (addresses[i].TryGetValue(\"city\", out string city))\n+        {\n+            temps[i] = string.Format(\"{0}{1}\", (city == \"Seattle\") ? \"20\" : \"50\", unit);\n+        }\n+        else\n+        {\n+            throw new ArgumentException(\"Each address must contain 'street' and 'city' keys.\");\n+        }\n+    }\n+    return temps;\n+}\n+```\n+Now we define the function definitions:\n+```C# Snippet:StreamingWithAutoFunctionCall_DefineFunctionTools\n+private FunctionToolDefinition geHhumidityByAddressTool = new(\n+     name: \"GetHumidityByAddress\",\n+     description: \"Get humidity by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Address = new\n+             {\n+                 Type = \"object\",\n+                 Properties = new\n+                 {\n+                     Street = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"Street\"\n+                     },\n+                     City = new\n+                     {\n+                         Type = \"string\",\n+                         Description = \"city\"\n+                     },\n+                 },\n+                 Required = new[] { \"street\", \"city\" }\n+             }\n+         },\n+         Required = new[] { \"address\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+\n+private FunctionToolDefinition getWeatherByAddressesTool = new(\n+     name: \"GetWeatherByAddresses\",\n+     description: \"Get weather by street and city\",\n+     parameters: BinaryData.FromObjectAsJson(\n+     new\n+     {\n+         Type = \"object\",\n+         Properties = new\n+         {\n+             Addresses = new\n+             {\n+                 Type = \"array\",\n+                 Description = \"A list of addresses\",\n+                 Items = new\n+                 {\n+                     Type = \"object\",\n+                     Properties = new\n+                     {\n+                         Street = new\n+                         {\n+                             Type = \"string\",\n+                             Description = \"Street\"\n+                         },\n+                         City = new\n+                         {\n+                             Type = \"string\",\n+                             description = \"city\"\n+                         },\n+                     },\n+                     Required = new[] { \"street\", \"city\" }\n+                 }\n+             },\n+             Unit = new\n+             {\n+                 Type = \"string\",\n+                 Enum = new[] { \"c\", \"f\" },\n+             },\n+         },\n+         Required = new[] { \"addresses\" }\n+     },\n+     new JsonSerializerOptions() { PropertyNamingPolicy = JsonNamingPolicy.CamelCase }));\n+```\n+Use `EnableAutoFunctionCall` to enable the auto function call:\n+```C# Snippet:StreamingWithAutoFunctionCall_EnableAutoFunctionCalls\n+List<ToolOutput> toolOutputs = new();\n+Dictionary<string, Delegate> delegates = new();\n+delegates.Add(nameof(GetWeatherByAddresses), GetWeatherByAddresses);\n+delegates.Add(nameof(GetHumidityByAddress), GetHumidityByAddress);\n+AIProjectClientOptions options = new();\n+options.EnableAutoFunctionCalls(delegates);\n+\n+AgentsClient client = new(connectionString, new DefaultAzureCredential(), options);\n+```\n+\n+\n+When you create an agent, you can specify the function call by tools argument similar to the example of manual function calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateAgent\n+Agent agent = client.CreateAgent(\n+    model: modelDeploymentName,\n+    name: \"SDK Test Agent - Functions\",\n+        instructions: \"You are a weather bot. Use the provided functions to help answer questions. \"\n+            + \"Customize your responses to the user's preferences as much as possible and use friendly \"\n+            + \"nicknames for cities whenever possible.\",\n+    tools: [getWeatherByAddressesTool, geHhumidityByAddressTool]\n+);\n+```\n+\n+We create a thread and message similar to the example of manual function tool calls:\n+```C# Snippet:StreamingWithAutoFunctionCall_CreateThreadMessage\n+AgentThread thread = client.CreateThread();\n+\n+ThreadMessage message = client.CreateMessage(\n+    thread.Id,\n+    MessageRole.User,\n+    \"Get weather and humidity for street, 123 1st St in city, Seattle and street, 456 2nd Ave in city, Bellevue\");\n+```\n+\n+The agent will then call the function automatically when it is needed during `CreateRunStreamingAsync`:",
        "comment_created_at": "2025-04-28T06:17:24+00:00",
        "comment_author": "howieleung",
        "comment_body": "Done..   I added autoFunctionCallOptions to create_stream function.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2060975818",
    "pr_number": 49293,
    "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
    "created_at": "2025-04-25T22:51:07+00:00",
    "commented_code": "{\n    if (functionName == getUserFavoriteCityTool.Name)\n    {\n        return new ToolOutput(toolCallId, GetUserFavoriteCity());\n        return new ToolOutput(toolCallId, ToolCallsResolver.Resolve(GetUserFavoriteCity, functionArguments).ToString());",
    "repo_full_name": "Azure/azure-sdk-for-net",
    "discussion_comments": [
      {
        "comment_id": "2060975818",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2060975818",
        "commented_code": "@@ -581,23 +582,15 @@ ToolOutput GetResolvedToolOutput(string functionName, string toolCallId, string\n {\n     if (functionName == getUserFavoriteCityTool.Name)\n     {\n-        return new ToolOutput(toolCallId, GetUserFavoriteCity());\n+        return new ToolOutput(toolCallId, ToolCallsResolver.Resolve(GetUserFavoriteCity, functionArguments).ToString());",
        "comment_created_at": "2025-04-25T22:51:07+00:00",
        "comment_author": "KrzysztofCwalina",
        "comment_body": "I don't think we should ship this API as public. If tool calls are not automatic, we want the caller to simply call the CLR API they want. We don't want them to go through some resolver. If you want an API that maps from tol call request arguments to CLR values that can be passed to a CLR method, then I would be fine with that, but honestly such API should be in some shared library, not in AI Project",
        "pr_file_module": null
      },
      {
        "comment_id": "2061195294",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 49293,
        "pr_file": "sdk/ai/Azure.AI.Projects/README.md",
        "discussion_id": "2060975818",
        "commented_code": "@@ -581,23 +582,15 @@ ToolOutput GetResolvedToolOutput(string functionName, string toolCallId, string\n {\n     if (functionName == getUserFavoriteCityTool.Name)\n     {\n-        return new ToolOutput(toolCallId, GetUserFavoriteCity());\n+        return new ToolOutput(toolCallId, ToolCallsResolver.Resolve(GetUserFavoriteCity, functionArguments).ToString());",
        "comment_created_at": "2025-04-26T06:38:16+00:00",
        "comment_author": "howieleung",
        "comment_body": "changed to internal.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2098984732",
    "pr_number": 50169,
    "pr_file": "sdk/communication/Azure.Communication.PhoneNumbers/samples/Sample_PhoneNumbersClient.md",
    "created_at": "2025-05-20T22:46:40+00:00",
    "commented_code": "## Purchase phone numbers\n\nPhone numbers can be acquired through purchasing a reservation.\nPhone numbers can be acquired through purchasing a search.",
    "repo_full_name": "Azure/azure-sdk-for-net",
    "discussion_comments": [
      {
        "comment_id": "2098984732",
        "repo_full_name": "Azure/azure-sdk-for-net",
        "pr_number": 50169,
        "pr_file": "sdk/communication/Azure.Communication.PhoneNumbers/samples/Sample_PhoneNumbersClient.md",
        "discussion_id": "2098984732",
        "commented_code": "@@ -34,7 +34,7 @@ while (!searchOperation.HasCompleted)\n \n ## Purchase phone numbers\n \n-Phone numbers can be acquired through purchasing a reservation.\n+Phone numbers can be acquired through purchasing a search.",
        "comment_created_at": "2025-05-20T22:46:40+00:00",
        "comment_author": "Copilot",
        "comment_body": "The sample description appears inconsistent with the rest of the Reservations API documentation. It states 'purchasing a search' instead of 'purchasing a reservation'; please clarify the intended terminology to avoid confusion.",
        "pr_file_module": null
      }
    ]
  }
]
