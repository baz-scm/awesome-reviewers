[
  {
    "discussion_id": "1084651485",
    "pr_number": 17109,
    "pr_file": "tools/ctexplain/bazel_api.py",
    "created_at": "2023-01-23T22:51:56+00:00",
    "commented_code": "Returns:\n     Corresponding ConfiguredTarget if the line matches else None.\n   \"\"\"\n-  tokens = line.split(maxsplit=2)\n-  label = tokens[0]\n-  if tokens[1][0] != \"(\" or tokens[1][-1] != \")\":\n-    raise ValueError(f\"{tokens[1]} in {line} not surrounded by parentheses\")\n-  config_hash = tokens[1][1:-1]\n-  if config_hash == \"null\":\n-    fragments = ()\n+  result = CQUERY_RESULT_LINE_REGEX.search(line)",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1084651485",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17109,
        "pr_file": "tools/ctexplain/bazel_api.py",
        "discussion_id": "1084651485",
        "commented_code": "@@ -144,20 +154,16 @@ def _parse_cquery_result_line(line: str) -> ConfiguredTarget:\n   Returns:\n     Corresponding ConfiguredTarget if the line matches else None.\n   \"\"\"\n-  tokens = line.split(maxsplit=2)\n-  label = tokens[0]\n-  if tokens[1][0] != \"(\" or tokens[1][-1] != \")\":\n-    raise ValueError(f\"{tokens[1]} in {line} not surrounded by parentheses\")\n-  config_hash = tokens[1][1:-1]\n-  if config_hash == \"null\":\n-    fragments = ()\n+  result = CQUERY_RESULT_LINE_REGEX.search(line)",
        "comment_created_at": "2023-01-23T22:51:56+00:00",
        "comment_author": "gregestren",
        "comment_body": "Implementing the TODO from line 139 would be a great followup, especially if it's not hard (not sure it is). \r\n\r\nI know you're just expanding on the parsing logic already implemented, but this (existing) logic is way more brittle than it should be.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1828698436",
    "pr_number": 23828,
    "pr_file": "src/test/py/bazel/bzlmod/mod_command_test.py",
    "created_at": "2024-11-05T04:10:26+00:00",
    "commented_code": "'wrong output in graph query with extension filter specified',\n     )\n \n+  def testGraphWithFailingExtensions(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\n\")\n+      f.write(\"ext2.dep(name = 'fail')\n\")\n+\n+    exit_code, _, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all'],\n+      rstrip=True, allow_failure=True,\n+    )\n+    self.AssertNotExitCode(exit_code, 0, stderr)\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+\n+  def testGraphWithFailingExtensionsKeepGoing(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\n\")\n+      f.write(\"ext2.dep(name = 'fail')\n\")\n+\n+    _, stdout, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all', '--keep_going'], rstrip=True\n+    )\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+    self.assertListEqual(\n+      stdout,",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1828698436",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23828,
        "pr_file": "src/test/py/bazel/bzlmod/mod_command_test.py",
        "discussion_id": "1828698436",
        "commented_code": "@@ -239,6 +241,65 @@ def testGraphWithExtensionFilter(self):\n         'wrong output in graph query with extension filter specified',\n     )\n \n+  def testGraphWithFailingExtensions(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    exit_code, _, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all'],\n+      rstrip=True, allow_failure=True,\n+    )\n+    self.AssertNotExitCode(exit_code, 0, stderr)\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+\n+  def testGraphWithFailingExtensionsKeepGoing(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    _, stdout, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all', '--keep_going'], rstrip=True\n+    )\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+    self.assertListEqual(\n+      stdout,",
        "comment_created_at": "2024-11-05T04:10:26+00:00",
        "comment_author": "Wyverald",
        "comment_body": "hmm... I guess I really don't understand how `--keep_going` interacts with Skyframe. On ModCommand.java:222, I'd expected the \"has error\" bit to be true for the evaluation, but apparently it just keeps going (heh) without considering that there's an error? Maybe it only considers there to be an error if the requested set of SkyKeys has errors?\r\n\r\nCould you quickly check something -- is the error code on line 264 actually nonzero? If so, then I could still maybe make sense of the logic here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1829640317",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23828,
        "pr_file": "src/test/py/bazel/bzlmod/mod_command_test.py",
        "discussion_id": "1828698436",
        "commented_code": "@@ -239,6 +241,65 @@ def testGraphWithExtensionFilter(self):\n         'wrong output in graph query with extension filter specified',\n     )\n \n+  def testGraphWithFailingExtensions(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    exit_code, _, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all'],\n+      rstrip=True, allow_failure=True,\n+    )\n+    self.AssertNotExitCode(exit_code, 0, stderr)\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+\n+  def testGraphWithFailingExtensionsKeepGoing(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    _, stdout, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all', '--keep_going'], rstrip=True\n+    )\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+    self.assertListEqual(\n+      stdout,",
        "comment_created_at": "2024-11-05T16:16:37+00:00",
        "comment_author": "fmeum",
        "comment_body": "I checked that it's zero (the call above also doesn't pass `allow_failure=True`). \r\n\r\nOur observations are indeed consistent with Skyframe only setting the error bit if a top-level key evaluation fails. I agree that the exit code should be non-zero if any failing extension has been encountered, but I don't know how to pull that off. If we figure it out, we may be able to just get rid of the injected value.\r\n\r\nI updated the test to verify exit codes (hence it fails).",
        "pr_file_module": null
      },
      {
        "comment_id": "1829993742",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23828,
        "pr_file": "src/test/py/bazel/bzlmod/mod_command_test.py",
        "discussion_id": "1828698436",
        "commented_code": "@@ -239,6 +241,65 @@ def testGraphWithExtensionFilter(self):\n         'wrong output in graph query with extension filter specified',\n     )\n \n+  def testGraphWithFailingExtensions(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    exit_code, _, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all'],\n+      rstrip=True, allow_failure=True,\n+    )\n+    self.AssertNotExitCode(exit_code, 0, stderr)\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+\n+  def testGraphWithFailingExtensionsKeepGoing(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    _, stdout, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all', '--keep_going'], rstrip=True\n+    )\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+    self.assertListEqual(\n+      stdout,",
        "comment_created_at": "2024-11-05T20:59:31+00:00",
        "comment_author": "Wyverald",
        "comment_body": "OK, I double-checked with @michaeledgar. The \"keep going\" setting makes it so that errors in transitive dep (Skyframe) nodes _don't_ bubble up to the surface, whereas in \"no keep going\" mode, as soon as a transitive dep node errors, its requesting node is also marked as erroring (even if it was try/catching, for example). This in turn means that the whole evaluation does not result in an error in \"keep going\" mode, as the evaluation roots are not erroring. And because we're always using \"keep going\" effectively (due to usage of `prepareAndGet`), the `mod` command has always had this behavior.\r\n\r\nWe should structure this in a way that the nodes whose deps are erroring _store_ the dep errors in its SkyValue (in this case, BazelModuleInspectorFunction should store extension eval errors in BazelModuleInspectorValue), and then later report those errors (if present) by checking the SkyValue (instead of just relying on the error status of the Skyframe eval result). Similar to how PackageFunction stores most errors in the `Package` object itself, instead of throwing an exception. (TIL more about Skyframe...)\r\n\r\nAs an aside, Mike also pointed out that we should not alter the behavior of SkyFunctions based on the value of `--keep_going`; any SkyFunction that _can_ keep going should _always_ \"keep going\". If `--keep_going` is false, Skyframe will not restart that SkyFunction anyway. That would also remove the `BAZEL_MOD_KEEP_GOING` precomputed value, which is nice.",
        "pr_file_module": null
      },
      {
        "comment_id": "1830944220",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23828,
        "pr_file": "src/test/py/bazel/bzlmod/mod_command_test.py",
        "discussion_id": "1828698436",
        "commented_code": "@@ -239,6 +241,65 @@ def testGraphWithExtensionFilter(self):\n         'wrong output in graph query with extension filter specified',\n     )\n \n+  def testGraphWithFailingExtensions(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    exit_code, _, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all'],\n+      rstrip=True, allow_failure=True,\n+    )\n+    self.AssertNotExitCode(exit_code, 0, stderr)\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+\n+  def testGraphWithFailingExtensionsKeepGoing(self):\n+    # Force ext2 to fail.\n+    with open(self.Path('MODULE.bazel'), 'a+') as f:\n+      f.write(\"ext2.dep(name = 'repo2')\\n\")\n+      f.write(\"ext2.dep(name = 'fail')\\n\")\n+\n+    _, stdout, stderr = self.RunBazel(\n+      ['mod', 'graph', '--extension_info=all', '--keep_going'], rstrip=True\n+    )\n+    self.assertIn('\\t\\tfail(\"ext failed\")', stderr)\n+    self.assertIn('Error in fail: ext failed', stderr)\n+    self.assertListEqual(\n+      stdout,",
        "comment_created_at": "2024-11-06T12:32:45+00:00",
        "comment_author": "fmeum",
        "comment_body": "Thanks, this explanation was very helpful. I made the required changes.",
        "pr_file_module": null
      }
    ]
  }
]