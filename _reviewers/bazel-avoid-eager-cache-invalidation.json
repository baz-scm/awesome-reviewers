[
  {
    "discussion_id": "2303336181",
    "pr_number": 26837,
    "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/SymlinkTreeAction.java",
    "created_at": "2025-08-27T09:04:12+00:00",
    "commented_code": "public boolean mayInsensitivelyPropagateInputs() {\n     return true;\n   }\n+\n+  @Override\n+  public boolean actionCacheHit(NotifyOnActionCacheHit.ActionCachedContext context) {\n+    // Before 8.4.0, Bazel created the output manifest as a symlink to the input manifest, which\n+    // makes it infeasible to reliably detect stale runfiles directories, which are only created as\n+    // a side effect of this action and not tracked in the action cache.\n+    // https://github.com/bazelbuild/bazel/issues/26818\n+    // TODO: Consider removing this when Bazel 7 is no longer supported.\n+    return !context.getPathResolver().toPath(getPrimaryOutput()).isSymbolicLink();",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2303336181",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/SymlinkTreeAction.java",
        "discussion_id": "2303336181",
        "commented_code": "@@ -251,4 +253,14 @@ public ActionResult execute(ActionExecutionContext actionExecutionContext)\n   public boolean mayInsensitivelyPropagateInputs() {\n     return true;\n   }\n+\n+  @Override\n+  public boolean actionCacheHit(NotifyOnActionCacheHit.ActionCachedContext context) {\n+    // Before 8.4.0, Bazel created the output manifest as a symlink to the input manifest, which\n+    // makes it infeasible to reliably detect stale runfiles directories, which are only created as\n+    // a side effect of this action and not tracked in the action cache.\n+    // https://github.com/bazelbuild/bazel/issues/26818\n+    // TODO: Consider removing this when Bazel 7 is no longer supported.\n+    return !context.getPathResolver().toPath(getPrimaryOutput()).isSymbolicLink();",
        "comment_created_at": "2025-08-27T09:04:12+00:00",
        "comment_author": "tjgq",
        "comment_body": "I'd rather not use `NotifyOnCacheHit`. Can we bump the GUID instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2303557679",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/SymlinkTreeAction.java",
        "discussion_id": "2303336181",
        "commented_code": "@@ -251,4 +253,14 @@ public ActionResult execute(ActionExecutionContext actionExecutionContext)\n   public boolean mayInsensitivelyPropagateInputs() {\n     return true;\n   }\n+\n+  @Override\n+  public boolean actionCacheHit(NotifyOnActionCacheHit.ActionCachedContext context) {\n+    // Before 8.4.0, Bazel created the output manifest as a symlink to the input manifest, which\n+    // makes it infeasible to reliably detect stale runfiles directories, which are only created as\n+    // a side effect of this action and not tracked in the action cache.\n+    // https://github.com/bazelbuild/bazel/issues/26818\n+    // TODO: Consider removing this when Bazel 7 is no longer supported.\n+    return !context.getPathResolver().toPath(getPrimaryOutput()).isSymbolicLink();",
        "comment_created_at": "2025-08-27T10:46:18+00:00",
        "comment_author": "fmeum",
        "comment_body": "I tried that first but it doesn't work: the intermediate Bazel invocation doesn't update the action cache (because it uses a different version in the reproducer and because of `--nouse_action_cache` in the test), so the first and third run would always see the same GUID no matter how we change it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161025065",
    "pr_number": 26318,
    "pr_file": "src/main/java/com/google/devtools/build/lib/remote/RemoteLeaseExtension.java",
    "created_at": "2025-06-23T08:29:42+00:00",
    "commented_code": "token.extendOutputFile(artifact, expirationTime);\n           }\n         }\n+      } else {\n+        delete = true;\n+        break;\n       }\n     }\n \n-    if (actionCache != null && token != null && token.dirty) {\n-      // Only update the action cache entry if the token was updated because it usually involves\n-      // serialization.\n-      actionCache.put(token.key, token.entry);\n+    if (actionCache != null && token != null) {\n+      if (delete) {\n+        actionCache.remove(token.key);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2161025065",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26318,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/RemoteLeaseExtension.java",
        "discussion_id": "2161025065",
        "commented_code": "@@ -206,13 +208,20 @@ private void extendLeaseForAction(\n             token.extendOutputFile(artifact, expirationTime);\n           }\n         }\n+      } else {\n+        delete = true;\n+        break;\n       }\n     }\n \n-    if (actionCache != null && token != null && token.dirty) {\n-      // Only update the action cache entry if the token was updated because it usually involves\n-      // serialization.\n-      actionCache.put(token.key, token.entry);\n+    if (actionCache != null && token != null) {\n+      if (delete) {\n+        actionCache.remove(token.key);",
        "comment_created_at": "2025-06-23T08:29:42+00:00",
        "comment_author": "coeuvre",
        "comment_body": "Can you elaborate why we need to delete entry from the action cache?\r\n\r\nThe changes in `RemoteOutputChecker` below allows cold build to hit action cache even if the TTL of cache entries expired. Is that the case you want to avoid?",
        "pr_file_module": null
      },
      {
        "comment_id": "2161283682",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26318,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/RemoteLeaseExtension.java",
        "discussion_id": "2161025065",
        "commented_code": "@@ -206,13 +208,20 @@ private void extendLeaseForAction(\n             token.extendOutputFile(artifact, expirationTime);\n           }\n         }\n+      } else {\n+        delete = true;\n+        break;\n       }\n     }\n \n-    if (actionCache != null && token != null && token.dirty) {\n-      // Only update the action cache entry if the token was updated because it usually involves\n-      // serialization.\n-      actionCache.put(token.key, token.entry);\n+    if (actionCache != null && token != null) {\n+      if (delete) {\n+        actionCache.remove(token.key);",
        "comment_created_at": "2025-06-23T10:39:44+00:00",
        "comment_author": "fmeum",
        "comment_body": "We don't have to, but I think it's worth doing: We know that the remote cache doesn't have the artifact anymore (as opposed to just knowing that it's TTL expired) and deleting the entry means that we can avoid build rewinding, which has an associated cost (mostly a loss in observability).",
        "pr_file_module": null
      },
      {
        "comment_id": "2161337733",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26318,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/RemoteLeaseExtension.java",
        "discussion_id": "2161025065",
        "commented_code": "@@ -206,13 +208,20 @@ private void extendLeaseForAction(\n             token.extendOutputFile(artifact, expirationTime);\n           }\n         }\n+      } else {\n+        delete = true;\n+        break;\n       }\n     }\n \n-    if (actionCache != null && token != null && token.dirty) {\n-      // Only update the action cache entry if the token was updated because it usually involves\n-      // serialization.\n-      actionCache.put(token.key, token.entry);\n+    if (actionCache != null && token != null) {\n+      if (delete) {\n+        actionCache.remove(token.key);",
        "comment_created_at": "2025-06-23T11:05:26+00:00",
        "comment_author": "coeuvre",
        "comment_body": "It's true that remote cache doesn't have the artifact anymore, but the cache entry can still save build time for actions whose outputs are never materialized. It's similar to why we don't want to eagerly invalidate metadata, we probably also don't want to eagerly invalidate action cache.",
        "pr_file_module": null
      },
      {
        "comment_id": "2161893580",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26318,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/RemoteLeaseExtension.java",
        "discussion_id": "2161025065",
        "commented_code": "@@ -206,13 +208,20 @@ private void extendLeaseForAction(\n             token.extendOutputFile(artifact, expirationTime);\n           }\n         }\n+      } else {\n+        delete = true;\n+        break;\n       }\n     }\n \n-    if (actionCache != null && token != null && token.dirty) {\n-      // Only update the action cache entry if the token was updated because it usually involves\n-      // serialization.\n-      actionCache.put(token.key, token.entry);\n+    if (actionCache != null && token != null) {\n+      if (delete) {\n+        actionCache.remove(token.key);",
        "comment_created_at": "2025-06-23T15:23:47+00:00",
        "comment_author": "fmeum",
        "comment_body": "That makes sense, I'll remove this part.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1993358514",
    "pr_number": 23066,
    "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
    "created_at": "2025-03-13T11:51:45+00:00",
    "commented_code": "actionCache =\n             CompactPersistentActionCache.create(getCacheDirectory(), runtime.getClock(), reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)) {\n+          actionCache.removeIf(\n+            entry ->\n+            entry.getOutputFiles().values().stream().filter(e -> e.getExpireAtEpochMilli() == RemoteFileArtifactValue.SERVER_EXPIRATION_SENTINEL).count() > 0 ||\n+            entry.getOutputTrees().values().stream().filter(\n+              tv -> tv.childValues().values().stream().filter(e -> e.getExpireAtEpochMilli() == RemoteFileArtifactValue.SERVER_EXPIRATION_SENTINEL).count() > 0\n+            ).count() > 0",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1993358514",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23066,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
        "discussion_id": "1993358514",
        "commented_code": "@@ -289,6 +298,22 @@ public ActionCache getOrLoadPersistentActionCache(Reporter reporter) throws IOEx\n         actionCache =\n             CompactPersistentActionCache.create(getCacheDirectory(), runtime.getClock(), reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)) {\n+          actionCache.removeIf(\n+            entry ->\n+            entry.getOutputFiles().values().stream().filter(e -> e.getExpireAtEpochMilli() == RemoteFileArtifactValue.SERVER_EXPIRATION_SENTINEL).count() > 0 ||\n+            entry.getOutputTrees().values().stream().filter(\n+              tv -> tv.childValues().values().stream().filter(e -> e.getExpireAtEpochMilli() == RemoteFileArtifactValue.SERVER_EXPIRATION_SENTINEL).count() > 0\n+            ).count() > 0",
        "comment_created_at": "2025-03-13T11:51:45+00:00",
        "comment_author": "fmeum",
        "comment_body": "```suggestion\r\n                  Stream.concat(\r\n                          entry.getOutputFiles().values().stream(),\r\n                          entry.getOutputTrees().values().stream()\r\n                              .flatMap(tv -> tv.childValues().values().stream()))\r\n                      .anyMatch(e -> e.getExpirationTime() == RemoteFileArtifactValue.SERVER_EXPIRATION_SENTINEL));\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2131901843",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23066,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
        "discussion_id": "1993358514",
        "commented_code": "@@ -289,6 +298,22 @@ public ActionCache getOrLoadPersistentActionCache(Reporter reporter) throws IOEx\n         actionCache =\n             CompactPersistentActionCache.create(getCacheDirectory(), runtime.getClock(), reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)) {\n+          actionCache.removeIf(\n+            entry ->\n+            entry.getOutputFiles().values().stream().filter(e -> e.getExpireAtEpochMilli() == RemoteFileArtifactValue.SERVER_EXPIRATION_SENTINEL).count() > 0 ||\n+            entry.getOutputTrees().values().stream().filter(\n+              tv -> tv.childValues().values().stream().filter(e -> e.getExpireAtEpochMilli() == RemoteFileArtifactValue.SERVER_EXPIRATION_SENTINEL).count() > 0\n+            ).count() > 0",
        "comment_created_at": "2025-06-06T09:55:47+00:00",
        "comment_author": "dws",
        "comment_body": "Great suggestion, thanks!",
        "pr_file_module": null
      }
    ]
  }
]