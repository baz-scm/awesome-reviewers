[
  {
    "discussion_id": "2208021416",
    "pr_number": 26525,
    "pr_file": "src/main/java/com/google/devtools/build/lib/query2/engine/ExecutablesFunction.java",
    "created_at": "2025-07-15T16:49:32+00:00",
    "commented_code": "+// Copyright 2014 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.devtools.build.lib.query2.engine;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.ThreadSafe;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.Argument;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.ArgumentType;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.QueryFunction;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.QueryTaskFuture;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.Setting;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.TargetAccessor;\n+import com.google.devtools.build.lib.server.FailureDetails.FailureDetail;\n+import com.google.devtools.build.lib.server.FailureDetails.Query;\n+import com.google.devtools.build.lib.server.FailureDetails.Query.Code;\n+import com.google.devtools.build.lib.util.DetailedExitCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * A executables(x) filter expression, which returns all the executables in set x.\n+ *\n+ * <pre>expr ::= EXECUTABLES '(' expr ')'</pre>\n+ */\n+public class ExecutablesFunction implements QueryFunction {\n+  @VisibleForTesting\n+  public ExecutablesFunction() {}\n+\n+  @Override\n+  public String getName() {\n+    return \"executables\";\n+  }\n+\n+  @Override\n+  public int getMandatoryArguments() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public List<ArgumentType> getArgumentTypes() {\n+    return ImmutableList.of(ArgumentType.EXPRESSION);\n+  }\n+\n+  @Override\n+  public <T> QueryTaskFuture<Void> eval(\n+      QueryEnvironment<T> env,\n+      QueryExpressionContext<T> context,\n+      QueryExpression expression,\n+      List<Argument> args,\n+      Callback<T> callback) {\n+    TargetAccessor<T> accessor = env.getAccessor();\n+\n+    return env.eval(args.get(0).getExpression(), context, partialResult -> {\n+      for (T input : partialResult) {\n+        if (accessor.isExecutableRule(input)) {\n+          callback.process(Collections.singletonList(env.getOrCreate(input)));\n+        }\n+      }",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2208021416",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26525,
        "pr_file": "src/main/java/com/google/devtools/build/lib/query2/engine/ExecutablesFunction.java",
        "discussion_id": "2208021416",
        "commented_code": "@@ -0,0 +1,78 @@\n+// Copyright 2014 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.devtools.build.lib.query2.engine;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.ThreadSafe;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.Argument;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.ArgumentType;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.QueryFunction;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.QueryTaskFuture;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.Setting;\n+import com.google.devtools.build.lib.query2.engine.QueryEnvironment.TargetAccessor;\n+import com.google.devtools.build.lib.server.FailureDetails.FailureDetail;\n+import com.google.devtools.build.lib.server.FailureDetails.Query;\n+import com.google.devtools.build.lib.server.FailureDetails.Query.Code;\n+import com.google.devtools.build.lib.util.DetailedExitCode;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * A executables(x) filter expression, which returns all the executables in set x.\n+ *\n+ * <pre>expr ::= EXECUTABLES '(' expr ')'</pre>\n+ */\n+public class ExecutablesFunction implements QueryFunction {\n+  @VisibleForTesting\n+  public ExecutablesFunction() {}\n+\n+  @Override\n+  public String getName() {\n+    return \"executables\";\n+  }\n+\n+  @Override\n+  public int getMandatoryArguments() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public List<ArgumentType> getArgumentTypes() {\n+    return ImmutableList.of(ArgumentType.EXPRESSION);\n+  }\n+\n+  @Override\n+  public <T> QueryTaskFuture<Void> eval(\n+      QueryEnvironment<T> env,\n+      QueryExpressionContext<T> context,\n+      QueryExpression expression,\n+      List<Argument> args,\n+      Callback<T> callback) {\n+    TargetAccessor<T> accessor = env.getAccessor();\n+\n+    return env.eval(args.get(0).getExpression(), context, partialResult -> {\n+      for (T input : partialResult) {\n+        if (accessor.isExecutableRule(input)) {\n+          callback.process(Collections.singletonList(env.getOrCreate(input)));\n+        }\n+      }",
        "comment_created_at": "2025-07-15T16:49:32+00:00",
        "comment_author": "fmeum",
        "comment_body": "You can use `Iterables.filter` to avoid the overhead of allocating all the singleton lists + an extra iteration.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "884865754",
    "pr_number": 15594,
    "pr_file": "src/main/java/net/starlark/java/eval/Eval.java",
    "created_at": "2022-05-30T14:04:40+00:00",
    "commented_code": "continue;\n           case BREAK:\n             // Finish loop, execute next statement after loop.\n+            CoverageRecorder.getInstance().recordVirtualJump(node);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "884865754",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 15594,
        "pr_file": "src/main/java/net/starlark/java/eval/Eval.java",
        "discussion_id": "884865754",
        "commented_code": "@@ -131,6 +133,7 @@ private static TokenKind execFor(StarlarkThread.Frame fr, ForStatement node)\n             continue;\n           case BREAK:\n             // Finish loop, execute next statement after loop.\n+            CoverageRecorder.getInstance().recordVirtualJump(node);",
        "comment_created_at": "2022-05-30T14:04:40+00:00",
        "comment_author": "fmeum",
        "comment_body": "I don't have any data to assess whether this causes a performance degradation even if coverage is not being recorded (which means that the instance returned will have a no-op `recordVirtualJump`). If this should turn out to be prohibitive, I could make the instance `static final` and populate it e.g. via an environment variable rather than a Bazel flag.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2132824037",
    "pr_number": 23066,
    "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
    "created_at": "2025-06-06T19:47:31+00:00",
    "commented_code": "runtime.getClock(),\n                 reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2132824037",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23066,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
        "discussion_id": "2132824037",
        "commented_code": "@@ -395,6 +406,23 @@ public ActionCache getOrLoadPersistentActionCache(Reporter reporter) throws IOEx\n                 runtime.getClock(),\n                 reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)",
        "comment_created_at": "2025-06-06T19:47:31+00:00",
        "comment_author": "fmeum",
        "comment_body": "How long does this take on a larger repo? It's a cost paid even by someone who doesn't use the new feature, so we need to be careful.",
        "pr_file_module": null
      },
      {
        "comment_id": "2136071838",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23066,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
        "discussion_id": "2132824037",
        "commented_code": "@@ -395,6 +406,23 @@ public ActionCache getOrLoadPersistentActionCache(Reporter reporter) throws IOEx\n                 runtime.getClock(),\n                 reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)",
        "comment_created_at": "2025-06-09T16:49:59+00:00",
        "comment_author": "dws",
        "comment_body": "That is a very fair question.  Having a look at a sampling of timings of the pruning, the time required seems to vary between 20% and 90% of the time required to load the action cache.  In the repo I'm working with, this adds at most about 1.5s to the server startup time.  I kept the implementation here as simple as I could by doing the sweep unconditionally.\r\n\r\nShall I try to make it do the sweep only if the action cache was last used in conjunction with `--experimental_remote_cache_ttl=server`?  I'd need to record that in the action cache in some fashion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2136608853",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23066,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
        "discussion_id": "2132824037",
        "commented_code": "@@ -395,6 +406,23 @@ public ActionCache getOrLoadPersistentActionCache(Reporter reporter) throws IOEx\n                 runtime.getClock(),\n                 reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)",
        "comment_created_at": "2025-06-09T22:38:34+00:00",
        "comment_author": "fmeum",
        "comment_body": "I think I would prefer that, a slowdown of 1.5s just for providing this feature (even if unused) is something we should try to avoid.\n\n@tjgq as he worked on action cache GC logic recently",
        "pr_file_module": null
      },
      {
        "comment_id": "2136751806",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23066,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BlazeWorkspace.java",
        "discussion_id": "2132824037",
        "commented_code": "@@ -395,6 +406,23 @@ public ActionCache getOrLoadPersistentActionCache(Reporter reporter) throws IOEx\n                 runtime.getClock(),\n                 reporter);\n       }\n+\n+      // Here we clear any server-lifetime entries in the action cache that a previous instance of\n+      // the server might have created.\n+      if (clearActionCacheServerLifetimeEntries) {\n+        // We only exercise this code at most once during the lifetime of the server.\n+        clearActionCacheServerLifetimeEntries = false;\n+        try (AutoProfiler p = profiledAndLogged(\"pruning server-lifetime entries from action cache\", ProfilerTask.INFO)",
        "comment_created_at": "2025-06-10T01:30:19+00:00",
        "comment_author": "dws",
        "comment_body": "My initial thought here would be to add a new \"magic\" entry in the action cache akin to `VALIDATION_KEY` in order to record, by its existence, whether the action cache is being used in conjunction with `--experimental_remote_cache_ttl=server`.  If the Bazel server starts up and finds that action cache entry exists, then it needs to do the sweep.  After that, it will remove, add, or leave alone that action cache entry per the current use of `--experimental_remote_cache_ttl=server`.  Since the public interfaces for action cache entries are based on supplying a string rather than an integer like `VALIDATION_KEY`, this would entail providing some new public interfaces for the purpose of supporting this magic non-string-indexed entry.\r\n\r\nAnother possibility might be to add a whole new map to the action cache, this one dedicated to user-defined metadata, for the purpose of supporting this one new bit of state.  This would likely be more code, but would perhaps be less \"hacky\" than supporting a magic action cache entry.\r\n\r\nThoughts?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2105915749",
    "pr_number": 26146,
    "pr_file": "src/main/java/com/google/devtools/build/lib/remote/AbstractActionInputPrefetcher.java",
    "created_at": "2025-05-24T19:51:14+00:00",
    "commented_code": "}\n \n   private static boolean shouldDownloadFile(Path path, FileArtifactValue metadata) {\n-    if (!path.exists()) {\n+    var stat = path.statNullable();\n+    if (stat == null) {\n       return true;\n     }\n \n-    // In the most cases, skyframe should be able to detect source files modifications and delete\n-    // staled outputs before action execution. However, there are some cases where outputs are not\n-    // tracked by skyframe. We compare the digest here to make sure we don't use staled files.\n+    // In most cases, skyframe should be able to detect source files modifications and delete\n+    // stale outputs before action execution. However, there are some cases where outputs are not",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2105915749",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26146,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/AbstractActionInputPrefetcher.java",
        "discussion_id": "2105915749",
        "commented_code": "@@ -224,14 +224,24 @@ protected AbstractActionInputPrefetcher(\n   }\n \n   private static boolean shouldDownloadFile(Path path, FileArtifactValue metadata) {\n-    if (!path.exists()) {\n+    var stat = path.statNullable();\n+    if (stat == null) {\n       return true;\n     }\n \n-    // In the most cases, skyframe should be able to detect source files modifications and delete\n-    // staled outputs before action execution. However, there are some cases where outputs are not\n-    // tracked by skyframe. We compare the digest here to make sure we don't use staled files.\n+    // In most cases, skyframe should be able to detect source files modifications and delete\n+    // stale outputs before action execution. However, there are some cases where outputs are not",
        "comment_created_at": "2025-05-24T19:51:14+00:00",
        "comment_author": "fmeum",
        "comment_body": "@coeuvre I'm curious which files you had in mind when you introduced this in https://github.com/bazelbuild/bazel/commit/ebd6e58ac186d5137a4ba4450ae48a28b1e111f7. Is this perhaps about spawn outputs that aren't action outputs (e.g. `test.xml`)? If so, could we optimize this further by skipping the checks for non-test actions? It seems likely that this would also benefit from using the digest cache, but it could also pollute it when the digest mismatches often.",
        "pr_file_module": null
      },
      {
        "comment_id": "2106846158",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26146,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/AbstractActionInputPrefetcher.java",
        "discussion_id": "2105915749",
        "commented_code": "@@ -224,14 +224,24 @@ protected AbstractActionInputPrefetcher(\n   }\n \n   private static boolean shouldDownloadFile(Path path, FileArtifactValue metadata) {\n-    if (!path.exists()) {\n+    var stat = path.statNullable();\n+    if (stat == null) {\n       return true;\n     }\n \n-    // In the most cases, skyframe should be able to detect source files modifications and delete\n-    // staled outputs before action execution. However, there are some cases where outputs are not\n-    // tracked by skyframe. We compare the digest here to make sure we don't use staled files.\n+    // In most cases, skyframe should be able to detect source files modifications and delete\n+    // stale outputs before action execution. However, there are some cases where outputs are not",
        "comment_created_at": "2025-05-26T08:39:12+00:00",
        "comment_author": "coeuvre",
        "comment_body": "Any file that is spawn output but not declared action output will have this problem. test.xml is one example and we have other files related to tree artifacts internally.",
        "pr_file_module": null
      },
      {
        "comment_id": "2106946856",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26146,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/AbstractActionInputPrefetcher.java",
        "discussion_id": "2105915749",
        "commented_code": "@@ -224,14 +224,24 @@ protected AbstractActionInputPrefetcher(\n   }\n \n   private static boolean shouldDownloadFile(Path path, FileArtifactValue metadata) {\n-    if (!path.exists()) {\n+    var stat = path.statNullable();\n+    if (stat == null) {\n       return true;\n     }\n \n-    // In the most cases, skyframe should be able to detect source files modifications and delete\n-    // staled outputs before action execution. However, there are some cases where outputs are not\n-    // tracked by skyframe. We compare the digest here to make sure we don't use staled files.\n+    // In most cases, skyframe should be able to detect source files modifications and delete\n+    // stale outputs before action execution. However, there are some cases where outputs are not",
        "comment_created_at": "2025-05-26T09:38:29+00:00",
        "comment_author": "fmeum",
        "comment_body": "In that case, what do you think of adding a check for whether the artifact is an output of the action (which we have available) and skipping I/O in that case? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1114003657",
    "pr_number": 14470,
    "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java",
    "created_at": "2023-02-22T08:45:38+00:00",
    "commented_code": "// Since the BEP currently shuts down at the BuildCompleteEvent, we cannot just move posting\n         // the BuildToolLogs to afterCommand of this module.\n         try {\n+          if(Profiler.getProcessCpuTimeMaybe() != null) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1114003657",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 14470,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java",
        "discussion_id": "1114003657",
        "commented_code": "@@ -182,6 +194,9 @@ public void buildComplete(BuildCompleteEvent event) {\n         // Since the BEP currently shuts down at the BuildCompleteEvent, we cannot just move posting\n         // the BuildToolLogs to afterCommand of this module.\n         try {\n+          if(Profiler.getProcessCpuTimeMaybe() != null) {",
        "comment_created_at": "2023-02-22T08:45:38+00:00",
        "comment_author": "larsrc-google",
        "comment_body": "Nit: I'd prefer to not call `getProcessCpuTimeMaybe()` twice.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1931973212",
    "pr_number": 25081,
    "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainVariables.java",
    "created_at": "2025-01-28T11:09:03+00:00",
    "commented_code": "String variableName,\n           String field,\n           @Nullable ArtifactExpander expander,\n+          PathMapper pathMapper,\n           boolean throwOnMissingVariable) {\n         if (NAME_FIELD_NAME.equals(field)) {\n-          return new StringValue(name);\n+          if (pathMapper.isNoop()) {\n+            return new StringValue(name);\n+          }",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1931973212",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25081,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainVariables.java",
        "discussion_id": "1931973212",
        "commented_code": "@@ -784,11 +806,17 @@ public VariableValue getFieldValue(\n           String variableName,\n           String field,\n           @Nullable ArtifactExpander expander,\n+          PathMapper pathMapper,\n           boolean throwOnMissingVariable) {\n         if (NAME_FIELD_NAME.equals(field)) {\n-          return new StringValue(name);\n+          if (pathMapper.isNoop()) {\n+            return new StringValue(name);\n+          }",
        "comment_created_at": "2025-01-28T11:09:03+00:00",
        "comment_author": "comius",
        "comment_body": "Is this an optimization or would the no-op PathMapper produce wrong result executing next statment?",
        "pr_file_module": null
      },
      {
        "comment_id": "1931995057",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25081,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcToolchainVariables.java",
        "discussion_id": "1931973212",
        "commented_code": "@@ -784,11 +806,17 @@ public VariableValue getFieldValue(\n           String variableName,\n           String field,\n           @Nullable ArtifactExpander expander,\n+          PathMapper pathMapper,\n           boolean throwOnMissingVariable) {\n         if (NAME_FIELD_NAME.equals(field)) {\n-          return new StringValue(name);\n+          if (pathMapper.isNoop()) {\n+            return new StringValue(name);\n+          }",
        "comment_created_at": "2025-01-28T11:26:07+00:00",
        "comment_author": "fmeum",
        "comment_body": "Assuming that the `name` field only contains normalized file paths (which I guess it does?), this meant to be a pure optimization.",
        "pr_file_module": null
      }
    ]
  }
]