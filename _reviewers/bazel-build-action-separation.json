[
  {
    "discussion_id": "2169058407",
    "pr_number": 22553,
    "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppCompileAction.java",
    "created_at": "2025-06-26T13:19:48+00:00",
    "commented_code": "@Nullable Artifact gcnoFile,\n       @Nullable Artifact dwoFile,\n       @Nullable Artifact ltoIndexingFile,\n-      ImmutableList<Artifact> additionalOutputs) {\n+      ImmutableList<Artifact> additionalOutputs,\n+      FeatureConfiguration featureConfiguration,\n+      String actionName) {\n     ImmutableSet.Builder<Artifact> outputs = ImmutableSet.builder();\n     outputs.add(outputFile);\n     if (gcnoFile != null) {\n       outputs.add(gcnoFile);\n     }\n     outputs.addAll(additionalOutputs);\n     if (dotdFile != null) {\n-      outputs.add(dotdFile);\n+      if (featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES)) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2169058407",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppCompileAction.java",
        "discussion_id": "2169058407",
        "commented_code": "@@ -383,15 +408,34 @@ private static ImmutableSet<Artifact> collectOutputs(\n       @Nullable Artifact gcnoFile,\n       @Nullable Artifact dwoFile,\n       @Nullable Artifact ltoIndexingFile,\n-      ImmutableList<Artifact> additionalOutputs) {\n+      ImmutableList<Artifact> additionalOutputs,\n+      FeatureConfiguration featureConfiguration,\n+      String actionName) {\n     ImmutableSet.Builder<Artifact> outputs = ImmutableSet.builder();\n     outputs.add(outputFile);\n     if (gcnoFile != null) {\n       outputs.add(gcnoFile);\n     }\n     outputs.addAll(additionalOutputs);\n     if (dotdFile != null) {\n-      outputs.add(dotdFile);\n+      if (featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES)) {",
        "comment_created_at": "2025-06-26T13:19:48+00:00",
        "comment_author": "fmeum",
        "comment_body": "This part of the change looks unnecessary as the followup PR does not set `dotdFile` on the builder for the codegen action. The action itself should contain as little action-specific branching as possible, so if we do need to tweak something, that should happen in the builder.",
        "pr_file_module": null
      },
      {
        "comment_id": "2179213785",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppCompileAction.java",
        "discussion_id": "2169058407",
        "commented_code": "@@ -383,15 +408,34 @@ private static ImmutableSet<Artifact> collectOutputs(\n       @Nullable Artifact gcnoFile,\n       @Nullable Artifact dwoFile,\n       @Nullable Artifact ltoIndexingFile,\n-      ImmutableList<Artifact> additionalOutputs) {\n+      ImmutableList<Artifact> additionalOutputs,\n+      FeatureConfiguration featureConfiguration,\n+      String actionName) {\n     ImmutableSet.Builder<Artifact> outputs = ImmutableSet.builder();\n     outputs.add(outputFile);\n     if (gcnoFile != null) {\n       outputs.add(gcnoFile);\n     }\n     outputs.addAll(additionalOutputs);\n     if (dotdFile != null) {\n-      outputs.add(dotdFile);\n+      if (featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES)) {",
        "comment_created_at": "2025-07-02T06:20:49+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "You\u2019re right\u2014those changes aren\u2019t necessary in this PR.\r\n\r\nThis PR adds support for C++20 modules in the one-phase compilation pipeline, which does not create a separate `c++20-module-codegen` action. Consequently, we never set a `dotdFile` explicitly. The only `dotdFile` involved is the one that `c++20-module-compile` automatically receives via `builder.setOutputs(...)` inside `createSourceActionHelper`.\r\n\r\nThe explicit `dotdFile` logic in `CppCompileAction.java` is needed only for the two-phase pipeline in https://github.com/bazelbuild/bazel/pull/22555 , where `c++20-module-codegen` reuses the `dotdFile` produced by `c++20-module-compile` to prune dependencies.\r\n\r\nTo keep this PR clean and focused, I\u2019ll remove the extra branching from the action.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169072504",
    "pr_number": 22553,
    "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppCompileAction.java",
    "created_at": "2025-06-26T13:25:58+00:00",
    "commented_code": "DetailedExitCode code = createDetailedExitCode(message, Code.COMMAND_GENERATION_FAILURE);\n         throw new ActionExecutionException(message, this, /* catastrophe= */ false, code);\n       }\n+      usedCpp20Modules = computeUsedCpp20Modules(actionExecutionContext);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2169072504",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppCompileAction.java",
        "discussion_id": "2169072504",
        "commented_code": "@@ -629,6 +678,7 @@ public NestedSet<Artifact> discoverInputs(ActionExecutionContext actionExecution\n         DetailedExitCode code = createDetailedExitCode(message, Code.COMMAND_GENERATION_FAILURE);\n         throw new ActionExecutionException(message, this, /* catastrophe= */ false, code);\n       }\n+      usedCpp20Modules = computeUsedCpp20Modules(actionExecutionContext);",
        "comment_created_at": "2025-06-26T13:25:58+00:00",
        "comment_author": "fmeum",
        "comment_body": "I assume that you don't want to support include scanning with C++20 modules (that probably doesn't make sense). How about ensuring that include scanning is disabled for the deps scanning action at https://github.com/bazelbuild/bazel/blob/b07549d774d6768ada95dc2d4715557bce53bf2c/src/main/java/com/google/devtools/build/lib/bazel/rules/cpp/BazelCppSemantics.java#L114? Then we could move this computation into the branch below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169133932",
    "pr_number": 22553,
    "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
    "created_at": "2025-06-26T13:53:23+00:00",
    "commented_code": "// Create compile actions (both PIC and no-PIC).\n     try {\n-      CcCompilationOutputs ccOutputs = createCcCompileActions();\n-\n+      CcCompilationOutputs ccOutputs;\n+      if (featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES)) {\n+        // Handle C++20 Module compile\n+        ccOutputs = createCcCompileActionsWithCpp20Module();\n+        publicCompilationContext =",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2169133932",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "2169133932",
        "commented_code": "@@ -824,8 +831,21 @@ public CompilationInfo compile(RuleContext ruleContext)\n \n     // Create compile actions (both PIC and no-PIC).\n     try {\n-      CcCompilationOutputs ccOutputs = createCcCompileActions();\n-\n+      CcCompilationOutputs ccOutputs;\n+      if (featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES)) {\n+        // Handle C++20 Module compile\n+        ccOutputs = createCcCompileActionsWithCpp20Module();\n+        publicCompilationContext =",
        "comment_created_at": "2025-06-26T13:53:23+00:00",
        "comment_author": "fmeum",
        "comment_body": "This doesn't update the `ccCompilationContext` member, which is read by other methods. It's not clear to me whether that's a problem.",
        "pr_file_module": null
      },
      {
        "comment_id": "2179715891",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "2169133932",
        "commented_code": "@@ -824,8 +831,21 @@ public CompilationInfo compile(RuleContext ruleContext)\n \n     // Create compile actions (both PIC and no-PIC).\n     try {\n-      CcCompilationOutputs ccOutputs = createCcCompileActions();\n-\n+      CcCompilationOutputs ccOutputs;\n+      if (featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES)) {\n+        // Handle C++20 Module compile\n+        ccOutputs = createCcCompileActionsWithCpp20Module();\n+        publicCompilationContext =",
        "comment_created_at": "2025-07-02T10:34:32+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "That shouldn\u2019t be an issue.\r\n\r\n`ccCompilationContext` is only consulted while we are _building_ the compile actions (`createCcCompileActions()` / `createCcCompileActionsWithCpp20Module()`).  \r\nAfter the actions are created, the rest of the pipeline works with the `publicCompilationContext`, which we _do_ update with the C++20-module information and pass on via\r\n`new CompilationInfo(publicCompilationContext, ccOutputs);`\r\n\r\nIn other words, once the compile-action construction is finished, no code reads `ccCompilationContext` any more, so leaving it untouched is safe.  \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1176233815",
    "pr_number": 17984,
    "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
    "created_at": "2023-04-25T09:11:15+00:00",
    "commented_code": "CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1176233815",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-04-25T09:11:15+00:00",
        "comment_author": "buildbreaker2021",
        "comment_body": "I would be against having another `SpecialArtifact` introduced for cc related stuff. Because this is basically un-Starlarkifiable. @oquenchil WDYT?",
        "pr_file_module": null
      },
      {
        "comment_id": "1176242274",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-04-25T09:18:36+00:00",
        "comment_author": "oquenchil",
        "comment_body": "I agree that this should not go in. We shouldn't have any more special casing in native. Someone would need to contribute to move https://github.com/bazelbuild/bazel/issues/17237 forward, then this PR should be based on that or some other generic mechanism that doesn't introduce more native code.\r\n\r\nNo more SpecialArtifacts should be accepted. https://github.com/bazelbuild/bazel/issues/17237 and Starlark tree artifacts should provide the necessary APIs.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1324931372",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T18:47:50+00:00",
        "comment_author": "comius",
        "comment_body": "Do you perhaps know if aspect with shadow actions can support a use case like this? What I mean is, can you copy CcCompileAction in an aspect and add an output to it, that you can collect?",
        "pr_file_module": null
      },
      {
        "comment_id": "1325005330",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T19:48:14+00:00",
        "comment_author": "brentleyjones",
        "comment_body": "That would mean compiling twice, right? (since we can't have our action be depended on by the original compilation?), where just adding the flag and output only causes a small increase in original compilation time.",
        "pr_file_module": null
      },
      {
        "comment_id": "1325056716",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T20:41:33+00:00",
        "comment_author": "comius",
        "comment_body": "If you use outputs from both actions, then yes, you compile/cache twice. If you need the outputs for IDE only, then you\u2019d compile once. But the regular compile the users probably do/need couldn\u2019t reuse that.\r\n\r\nReplacing outputs in CcInfo might be possible within an extended rule if shadow actions were supported there.\r\n\r\nI\u2019m a bit conflicted with the idea that you need to have a complete set of new rules to support IDEs. Or even special toolchains.\r\n\r\nIf only you could split compilation actions away from parsing+index generation for IDEs that would be ideal solution. That is because I\u2019m assuming parsing is an order faster and because those actions can then run in parallel. You redo some work, but the data for IDEs is ready much sooner.\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1325066372",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T20:51:54+00:00",
        "comment_author": "brentleyjones",
        "comment_body": "This is the clang/apple way, indexing-while-building. And we use the normal build graph to support that. Adding more actions just for indexing defeats what we are trying to do with this PR.",
        "pr_file_module": null
      },
      {
        "comment_id": "1325086469",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T21:17:12+00:00",
        "comment_author": "comius",
        "comment_body": "Is there any information on the files that are generated?\r\n\r\nReading clangs docs, it seems the feature is designed to point to a cache directory for the entire build, where clang also reads the files. \r\n\r\nIs there any concern, that Bazel will use a new empty directory for each file it compiles? This is how tree artifacts work.\r\n\r\nThis might mean that it will generate an index file for each header file times source file.\r\n\r\nWhat am I missing?",
        "pr_file_module": null
      },
      {
        "comment_id": "1325113171",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T21:50:30+00:00",
        "comment_author": "brentleyjones",
        "comment_body": "Not reflected in this PR yet, but @yongjincho92 took the rules_swift implementation of a \"[global index store](https://github.com/bazelbuild/rules_swift/commit/914eff948be54cbcde847ae800a2e373e61a5c56)\" and implemented it for this. That makes it (more) efficient. We also plan on changing it to produce a `.tar` file instead of a tree artifact, similar to the comment from @DavidGoldman: https://github.com/bazelbuild/bazel/issues/15983#issuecomment-1272143337 (because that helps with some remote cache performance).",
        "pr_file_module": null
      },
      {
        "comment_id": "1325130745",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T22:18:24+00:00",
        "comment_author": "comius",
        "comment_body": "\"global index store\" link seems like it's using a worker. Using a worker makes much more sense, because if I'm not mistaken, you can use a global cache directory for the entire build, that behaves just like expected by clang. It can even read from it. And they are more lax on the hermeticity/sandboxing constraints.\r\n\r\nThis PR/implementation is touching C++ action that don't have a worker. Bazel has much higher expectations for actions like this. They are executed in a sandbox. I don't see a relation to a worker with this PR. If you implemented a worker, you wouldn't need to pass anything additional parameters to it. Just set an env variable to the path to that directory, or in the toolchain configuration and parse it from IDEs.\r\n\r\nMaybe some details are missing? I don't know if it's currently even possible to insert a worker into C++ toolchain.",
        "pr_file_module": null
      },
      {
        "comment_id": "1325162611",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T23:19:20+00:00",
        "comment_author": "yongjincho92",
        "comment_body": "I have a [pr in apple_support](https://github.com/bazelbuild/apple_support/pull/251) that does adopt how rules_swift did [global index store](https://github.com/bazelbuild/rules_swift/commit/914eff948be54cbcde847ae800a2e373e61a5c56). ",
        "pr_file_module": null
      },
      {
        "comment_id": "1325164068",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T23:22:48+00:00",
        "comment_author": "yongjincho92",
        "comment_body": "With the change above, I still observed a huge spike in remote cache fetching, so I implemented another change that tars the generated .indexstore directory [here](https://github.com/bazelbuild/apple_support/pull/256/commits/510241167560ed096342b5fda67b47098c805ab9) ",
        "pr_file_module": null
      },
      {
        "comment_id": "1325177901",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17984,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "1176233815",
        "commented_code": "@@ -1497,12 +1497,19 @@ private Artifact createCompileActionTemplate(\n           CppHelper.getDiagnosticsOutputTreeArtifact(\n               actionConstructionContext, label, sourceArtifact, outputName, usePic);\n     }\n+    SpecialArtifact indexstoreTreeArtifact = null;",
        "comment_created_at": "2023-09-13T23:51:56+00:00",
        "comment_author": "brentleyjones",
        "comment_body": "So after those changes, we just need the ability in Bazel to declare new outputs (like this PR does), though ideally new arguments as well. The outputs need to be declared in order to be cached properly.",
        "pr_file_module": null
      }
    ]
  }
]