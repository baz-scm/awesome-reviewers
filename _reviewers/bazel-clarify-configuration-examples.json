[
  {
    "discussion_id": "1479998623",
    "pr_number": 21136,
    "pr_file": "site/en/run/build.md",
    "created_at": "2024-02-06T15:10:30+00:00",
    "commented_code": "```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1479998623",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 21136,
        "pr_file": "site/en/run/build.md",
        "discussion_id": "1479998623",
        "commented_code": "@@ -433,6 +433,20 @@ BCR through internet. Add the following line to your `.bazelrc`:\n ```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository",
        "comment_created_at": "2024-02-06T15:10:30+00:00",
        "comment_author": "meteorcloudy",
        "comment_body": "What does the `/path/to/repository` mean?",
        "pr_file_module": null
      },
      {
        "comment_id": "1493238695",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 21136,
        "pr_file": "site/en/run/build.md",
        "discussion_id": "1479998623",
        "commented_code": "@@ -433,6 +433,20 @@ BCR through internet. Add the following line to your `.bazelrc`:\n ```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository",
        "comment_created_at": "2024-02-17T05:57:48+00:00",
        "comment_author": "evn10",
        "comment_body": "/path/to/repository is the path where you hold the downloaded repos, e.g. build:windows --distdir=c:\\Users\\johndoe\\bazel_repos",
        "pr_file_module": null
      },
      {
        "comment_id": "1494234928",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 21136,
        "pr_file": "site/en/run/build.md",
        "discussion_id": "1479998623",
        "commented_code": "@@ -433,6 +433,20 @@ BCR through internet. Add the following line to your `.bazelrc`:\n ```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository",
        "comment_created_at": "2024-02-19T09:18:39+00:00",
        "comment_author": "meteorcloudy",
        "comment_body": "If Bzlmod is enabled, Bazel will likely try to access BCR anyway, so this approach probably won't work.",
        "pr_file_module": null
      },
      {
        "comment_id": "1505386305",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 21136,
        "pr_file": "site/en/run/build.md",
        "discussion_id": "1479998623",
        "commented_code": "@@ -433,6 +433,20 @@ BCR through internet. Add the following line to your `.bazelrc`:\n ```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository",
        "comment_created_at": "2024-02-28T05:34:00+00:00",
        "comment_author": "evn10",
        "comment_body": "Yes indeed, you are absolutely right. Apologies for not specifying this. I have downloaded the BCR and added to the .bazelrc\r\n- windows : common --registry=file:///Users.../source/bazel-central-registry-main\r\n- linux        : common --registry=file:////....../bazel-central-registry-main",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1494236617",
    "pr_number": 21136,
    "pr_file": "site/en/run/build.md",
    "created_at": "2024-02-19T09:19:57+00:00",
    "commented_code": "```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository\n+```\n+- Packages are to be kept compressed (either _tar.gz_ or _zip_).\n+- Some packages (e.g. rules_proto-4.0.0.zip) are not picked up automatically. A workaround is to add the following entries in the MODULE.bazel file and create a symbolic link in the third_party directory at the project root directory :\n+```\n+bazel_dep(name = \"rules_proto\", version = \"4.0.0\")",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1494236617",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 21136,
        "pr_file": "site/en/run/build.md",
        "discussion_id": "1494236617",
        "commented_code": "@@ -433,6 +433,20 @@ BCR through internet. Add the following line to your `.bazelrc`:\n ```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository\n+```\n+- Packages are to be kept compressed (either _tar.gz_ or _zip_).\n+- Some packages (e.g. rules_proto-4.0.0.zip) are not picked up automatically. A workaround is to add the following entries in the MODULE.bazel file and create a symbolic link in the third_party directory at the project root directory :\n+```\n+bazel_dep(name = \"rules_proto\", version = \"4.0.0\")",
        "comment_created_at": "2024-02-19T09:19:57+00:00",
        "comment_author": "meteorcloudy",
        "comment_body": "> Some packages (e.g. rules_proto-4.0.0.zip) are not picked up automatically.\r\n\r\nWhy?\r\n\r\nHow does a user get the `third_party/rules_proto` directory?",
        "pr_file_module": null
      },
      {
        "comment_id": "1505396255",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 21136,
        "pr_file": "site/en/run/build.md",
        "discussion_id": "1494236617",
        "commented_code": "@@ -433,6 +433,20 @@ BCR through internet. Add the following line to your `.bazelrc`:\n ```python\n common --registry=\"path/to/local/bcr/registry\"\n ```\n+Note that in case you don't have an 'source' server with Internet connectivity to execute the above procedure, the --dist_dir option still works in Bazel 7. This might be a path to follow in case if you don't have access. The --repository_cache option is preferred in case you don't experience this constraint. Some considerations :\n+- The packages will need to be downloaded manually using a web browser. This sounds more dramatic as it sounds as only a dozen or so packages are to be downloaded. The following entries could be added to the .bazelrc file or the ~/.bazelrc can be used instead on each of the target platforms without the _:windows_ and _:linux_ extensions on the tags :\n+```\n+build:windows --distdir=C:\\\\path\\\\to\\\\repository\n+test:linux --distdir=/path/to/repository\n+```\n+- Packages are to be kept compressed (either _tar.gz_ or _zip_).\n+- Some packages (e.g. rules_proto-4.0.0.zip) are not picked up automatically. A workaround is to add the following entries in the MODULE.bazel file and create a symbolic link in the third_party directory at the project root directory :\n+```\n+bazel_dep(name = \"rules_proto\", version = \"4.0.0\")",
        "comment_created_at": "2024-02-28T05:49:50+00:00",
        "comment_author": "evn10",
        "comment_body": "I am not sure why, assuming it is because of the airgap? The following was  added in the MODULE.bazel file\r\n\r\n```\r\nbazel_dep(name = \"rules_proto\", version = \"4.0.0\")\r\nlocal_path_override(module_name = \"rules_proto\", path = \"third_party/rules_proto\")\r\nrules_proto = use_extension(\"@rules_proto//:*\", \"rules_proto\")\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1814896854",
    "pr_number": 23958,
    "pr_file": "site/en/start/go.md",
    "created_at": "2024-10-24T12:37:21+00:00",
    "commented_code": "+Project: /_project.yaml\n+Book: /_book.yaml\n+\n+# Bazel Tutorial: Build a Go Project\n+\n+{% include \"_buttons.html\" %}\n+\n+This tutorial introduces you to the basics of Bazel by showing you how to build a Go (Golang) project. You'll learn how to set up your workspace, build a small program, import a library, and run its test. Along the way, you'll learn key Bazel concepts, such as targets and `BUILD` files.\n+\n+Estimated completion time: 30 minutes\n+\n+## What you'll learn\n+\n+## Before you begin\n+\n+### Install Bazel\n+\n+Before you get started, first [install bazel](/install) if you haven't done so already.\n+\n+You can check if Bazel is installed by running `bazel version` in any directory.\n+\n+### Install Go (optional)\n+\n+You don't need to [install Go](https://go.dev/doc/install) to build Go projects with Bazel. The Bazel Go rule set automatically downloads and uses a Go toolchain instead of using the toolchain installed on your machine. This ensures all developers on a project build with same version of Go.\n+\n+However, you may still want to install a Go toolchain to run commands like `go get` and `go mod tidy`.\n+\n+You can check if Go is installed by running `go version` in any directory.\n+\n+### Get the sample project\n+\n+The Bazel examples are stored in a Git repository, so you'll need to [install Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if you haven't already. To download the examples repository, run this command:\n+\n+```posix-terminal\n+git clone https://github.com/bazelbuild/examples\n+```\n+\n+The sample project for this tutorial is in the `examples/go-tutorial` directory. Let's see what it contains:\n+\n+```none\n+go-tutorial/\n+\u2514\u2500\u2500 stage1\n+\u2514\u2500\u2500 stage2\n+\u2514\u2500\u2500 stage3\n+```\n+\n+There are three subdirectories (`stage1`, `stage2`, and `stage3`), each for a different section of this tutorial. Each stage builds on the previous one.\n+\n+## Build with Bazel\n+\n+Let's start in the `stage1` directory, where we'll find a simple program. We can build it with `bazel build`, then run it:\n+\n+```posix-shell\n+$ cd go-tutorial/stage1/\n+$ bazel build //:hello\n+INFO: Analyzed target //:hello (0 packages loaded, 0 targets configured).\n+INFO: Found 1 target...\n+Target //:hello up-to-date:\n+  bazel-bin/hello_/hello\n+INFO: Elapsed time: 0.473s, Critical Path: 0.25s\n+INFO: 3 processes: 1 internal, 2 darwin-sandbox.\n+INFO: Build completed successfully, 3 total actions\n+\n+$ bazel-bin/hello_/hello\n+Hello, Bazel! \ud83d\udc9a\n+```\n+\n+We can also build run the program with a single `bazel run` command:\n+\n+```posix-shell\n+$ bazel run //:hello\n+bazel run //:hello\n+INFO: Analyzed target //:hello (0 packages loaded, 0 targets configured).\n+INFO: Found 1 target...\n+Target //:hello up-to-date:\n+  bazel-bin/hello_/hello\n+INFO: Elapsed time: 0.128s, Critical Path: 0.00s\n+INFO: 1 process: 1 internal.\n+INFO: Build completed successfully, 1 total action\n+INFO: Running command line: bazel-bin/hello_/hello\n+Hello, Bazel! \ud83d\udc9a\n+```\n+\n+### Understanding project structure\n+\n+Let's take a look at the project we just built.\n+\n+`hello.go` contains the Go source code for the program.\n+\n+```go\n+package main\n+\n+import \"fmt\"\n+\n+func main() {\n+\tfmt.Println(\"Hello, Bazel! \ud83d\udc9a\")\n+}\n+```\n+\n+`BUILD` contains some instructions for Bazel, telling it what we want to build. You'll typically write a file like this in each directory. For this project, we have a single `go_binary` target that builds our program from `hello.go`.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_binary\")\n+\n+go_binary(\n+    name = \"hello\",\n+    srcs = [\"hello.go\"],\n+)\n+```\n+\n+`MODULE.bazel` tracks your project's dependencies. It also marks your project's root directory, so you'll only write one `MODULE.bazel` file per project. It serves a similar purpose to Go's `go.mod` file. You don't actually need a `go.mod` file in a Bazel project, but it may still be useful to have one so that you can continue using `go get` and `go mod tidy` for dependency management. The Bazel Go rule set can import dependencies from `go.mod`, but we'll cover that in another tutorial.\n+\n+Our `MODULE.bazel` file contains a single dependency on [rules_go](https://github.com/bazelbuild/rules_go), the Go rule set. We need this dependency because Bazel doesn't have built-in support for Go.\n+\n+```bazel\n+bazel_dep(\n+    name = \"rules_go\",\n+    version = \"0.50.1\",\n+)\n+```\n+\n+Finally, `MODULE.bazel.lock` is a file generated by Bazel that contains hashes and other metadata about our dependencies. It includes implicit dependencies added by Bazel itself, so it's quite long, and we won't show it here. Just like `go.sum`, you should commit your `MODULE.bazel.lock` file to source control to ensure everyone on your project gets the same version of each dependency. You should not need to edit `MODULE.bazel.lock` manually.\n+\n+### Understand the BUILD file\n+\n+Most of your interaction with Bazel will be through `BUILD` files (or equivalently, `BUILD.bazel` files), so it's important to understand what they do.\n+\n+`BUILD` files are written in a scripting language called [Starlark](https://bazel.build/rules/language), a limited subset of Python.\n+\n+A `BUILD` file contains a list of [targets](https://bazel.build/reference/glossary#target). A target is something Bazel can build, like a binary, library, or test.\n+\n+A target calls a rule function with a list of [attributes](https://bazel.build/reference/glossary#attribute) to describe what should be built. Our example has two attributes: `name` identifies the target on the command line, and `srcs` is a list of source file paths (slash-separated, relative to the directory containing the `BUILD` file).\n+\n+A [rule](https://bazel.build/reference/glossary#rule) tells Bazel how to build a target. In our example, we used the [`go_binary`](https://github.com/bazelbuild/rules_go/blob/master/docs/go/core/rules.md#go_binary) rule. Each rule defines [actions](https://bazel.build/reference/glossary#action) (commands) that generate a set of output files. For example, `go_binary` defines Go compile and link actions that produce an executable output file.\n+\n+Bazel has built-in rules for a few languages like Java and C++. You can find their [documentation in the Build Encyclopedia](https://bazel.build/reference/be/overview#rules). You can find rule sets for many other languages and tools on the [Bazel Central Registry (BCR)](https://registry.bazel.build/). \n+\n+## Add a library\n+\n+Let's move onto the `stage2` directory, where we'll build a new program that prints your fortune. This program uses a separate Go package as a library that selects a fortune from a predefined list of messages.\n+\n+```none\n+go-tutorial/stage2\n+\u251c\u2500\u2500 BUILD\n+\u251c\u2500\u2500 MODULE.bazel\n+\u251c\u2500\u2500 MODULE.bazel.lock\n+\u251c\u2500\u2500 fortune\n+\u2502   \u251c\u2500\u2500 BUILD\n+\u2502   \u2514\u2500\u2500 fortune.go\n+\u2514\u2500\u2500 print_fortune.go\n+```\n+\n+`fortune.go` is the source file for the library. The `fortune` library is a separate Go package, so its source files are in a separate directory. Bazel doesn't require you to keep Go packages in separate directories, but it's a strong convention in the Go ecosystem, and following it will help you stay compatible with other Go tools.\n+\n+```go\n+package fortune\n+\n+import \"math/rand\"\n+\n+var fortunes = []string{\n+\t\"Your build will complete quickly.\",\n+\t\"Your dependencies will be free of bugs.\",\n+\t\"Your tests will pass.\",\n+}\n+\n+func Get() string {\n+\treturn fortunes[rand.Intn(len(fortunes))]\n+}\n+```\n+\n+The `fortune` directory has its own `BUILD` file that tells Bazel how to build this package. We use `go_library` here instead of `go_binary`.\n+\n+We also need to set the `importpath` attribute to a string with which the library can be imported into other Go source files. This name should be the repository path (or module path) concatenated with the directory within the repository.\n+\n+Finally, we need to set the `visibility` attribute to `[\"//visibility:public\"]`. [`visibility`](https://bazel.build/concepts/visibility) may be set on any target. It determines which Bazel packages may depend on this target. In our case, we want any target to be able to depend on this library, so we use the special value `//visibility:public`.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_library\")\n+\n+go_library(\n+    name = \"fortune\",\n+    srcs = [\"fortune.go\"],\n+    importpath = \"github.com/bazelbuild/examples/go-tutorial/stage2/fortune\",\n+    visibility = [\"//visibility:public\"],\n+)\n+```\n+\n+You can build this library with:\n+\n+```posix-shell\n+$ bazel build //fortune\n+```\n+\n+Next, let's see how `print_fortune.go` uses this package.\n+\n+```go\n+package main\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/bazelbuild/examples/go-tutorial/stage2/fortune\"\n+)\n+\n+func main() {\n+\tfmt.Println(fortune.Get())\n+}\n+```\n+\n+`print_fortune.go` imports the package using the same string declared in the `importpath` attribute of the `fortune` library.\n+\n+We also need to declare this dependency to Bazel. Here's the `BUILD` file in the `stage2` directory.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_binary\")\n+\n+go_binary(\n+    name = \"print_fortune\",\n+    srcs = [\"print_fortune.go\"],\n+    deps = [\"//fortune\"],\n+)\n+```\n+\n+You can run this with the command below.\n+\n+```posix-shell\n+bazel run //:print_fortune\n+```\n+\n+The `print_fortune` target has a `deps` attribute, a list of other targets that it depends on. It contains `\"//fortune\"`, a label string referring to the target in the `fortune` directory named `fortune`.\n+\n+Bazel requires that all targets declare their dependencies explicitly with attributes like `deps`. This may seem cumbersome since dependencies are *also* specified in source files, but Bazel's explictness gives it an advantage. Bazel builds an [action graph](https://bazel.build/reference/glossary#action-graph) containing all commands, inputs, and outputs before running any commands, without reading any source files. Bazel can then cache action results or send actions for [remote execution](https://bazel.build/remote/rbe) without builtin language-specific logic.\n+\n+### Understanding labels\n+\n+A [label](https://bazel.build/reference/glossary#label) is a string Bazel uses to identify a target or a file. Labels are used in command line arguments and in `BUILD` file attributes like `deps`. We've seen a few already, like `//fortune`, `//:print-fortune`, and `@rules_go//go:def.bzl`.\n+\n+A label has three parts: a repository name, a package name, and a target (or file) name.\n+\n+The repository name is written between `@` and `//` and is used to refer to a target from a different Bazel module (for historical reasons, *module* and *repository* are sometimes used synonymously). In the label, `@rules_go//go:def.bzl`, the repository name is `rules_go`. The repository name can be omitted when referring to targets in the same repository.\n+\n+The package name is written between `//` and `:` and is used to refer to a target in from a different Bazel package. In the label `@rules_go//go:def.bzl`, the package name is `go`. A Bazel [package](https://bazel.build/reference/glossary#package) is a set of files and targets defined by a `BUILD` or `BUILD.bazel` file in its top-level directory. Its package name is a slash-separated path from the module root directory (containing `MODULE.bazel`) to the directory containing the `BUILD` file. A package may include subdirectories, but only if they don't also contain `BUILD` files defining their own packages.\n+\n+Most Go projects have one `BUILD` file per directory and one Go package per `BUILD` file. The package name in a label may be omitted when referring to targets in the same directory.\n+\n+The target name is written after `:` and refers to a target within a package. The target name may be omitted if it's the same as the last component of the package name (so `//a/b/c:c` is the same as `//a/b/c`; `//fortune:fortune` is the same as `//fortune`).\n+\n+On the command-line, you can use `...` as a wildcard to refer to all the targets within a package. This is useful for building or testing all the targets in a repository.\n+\n+```posix-shell\n+# Build everything\n+$ bazel build //...\n+```\n+\n+## Test your project\n+\n+Next, let's move to the `stage3` directory, where we'll add a test.\n+\n+```none\n+go-tutorial/stage3\n+\u251c\u2500\u2500 BUILD\n+\u251c\u2500\u2500 MODULE.bazel\n+\u251c\u2500\u2500 MODULE.bazel.lock\n+\u251c\u2500\u2500 fortune\n+\u2502   \u251c\u2500\u2500 BUILD\n+\u2502   \u251c\u2500\u2500 fortune.go\n+\u2502   \u2514\u2500\u2500 fortune_test.go\n+\u2514\u2500\u2500 print-fortune.go\n+```\n+\n+`fortune/fortune_test.go` is our new test source file.\n+\n+```go\n+package fortune\n+\n+import (\n+\t\"slices\"\n+\t\"testing\"\n+)\n+\n+// TestGet checks that Get returns one of the strings from fortunes.\n+func TestGet(t *testing.T) {\n+\tmsg := Get()\n+\tif i := slices.Index(fortunes, msg); i < 0 {\n+\t\tt.Errorf(\"Get returned %q, not one the expected messages\", msg)\n+\t}\n+}\n+```\n+\n+This file uses the unexported `fortunes` variable, so it needs to be compiled into the same Go package as `fortune.go`. Let's look at the `BUILD` file to see how that works:\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_library\", \"go_test\")\n+\n+go_library(\n+    name = \"fortune\",\n+    srcs = [\"fortune.go\"],\n+    importpath = \"github.com/bazelbuild/examples/go-tutorial/stage3/fortune\",\n+    visibility = [\"//visibility:public\"],\n+)\n+\n+go_test(\n+    name = \"fortune_test\",\n+    srcs = [\"fortune_test.go\"],\n+    embed = [\":fortune\"],\n+)\n+```\n+\n+We have a new `fortune_test` target that uses the `go_test` rule to compile and link a test executable. `go_test` needs to compile `fortune.go` and `fortune_test.go` together with the same command, so we use the `embed` attribute here to incorporate the attributes of the `fortune` target into `fortune_test`. `embed` is most commonly used with `go_test` and `go_binary`, but it also works with `go_library`, which is sometimes useful for generated code.\n+\n+You may be wondering if the `embed` attribute is related to Go's [`embed`](https://pkg.go.dev/embed) package, which is used to access data files copied into an executable. This is an unfortunate name collision: rules_go's `embed` attribute was introduced before Go's `embed` package. Instead, rules_go uses the `embedsrcs` to list files that can be loaded with the `embed` package.\n+\n+Let's try running our test with `bazel test`:\n+\n+```posix-shell\n+$ bazel test //fortune:fortune_test\n+INFO: Analyzed target //fortune:fortune_test (0 packages loaded, 0 targets configured).\n+INFO: Found 1 test target...\n+Target //fortune:fortune_test up-to-date:\n+  bazel-bin/fortune/fortune_test_/fortune_test\n+INFO: Elapsed time: 0.168s, Critical Path: 0.00s\n+INFO: 1 process: 1 internal.\n+INFO: Build completed successfully, 1 total action\n+//fortune:fortune_test                                          PASSED in 0.3s\n+\n+Executed 0 out of 1 test: 1 test passes.\n+There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option to see which ones these are.\n+```\n+\n+You can use the `...` wildcard to run all tests. Bazel will also build targets that aren't tests, so this can catch compile errors even in packages that don't have tests.\n+\n+```posix-shell\n+$ bazel test //...\n+```\n+\n+## Conclusion and further reading\n+\n+In this tutorial, we built and tested a small Go project with Bazel, and we learned some core Bazel concepts along the way.\n+\n+- To get started building other applications with Bazel, see the tutorials for [C++](/start/cpp), [Java](/start/java), [Android](/start/android-app), and [iOS](/start/ios-app).\n+- You can also check the list of [recommended rules](/rules) for other languages.\n+- For more information on Go, see the [rules_go](https://github.com/bazelbuild/rules_go) module, especially the [Core Go rules](https://github.com/bazelbuild/rules_go/blob/master/docs/go/core/rules.md) docuemntation.\n+- To learn more about working with modules outside your project, see [external dependencies](/docs/external).",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1814896854",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23958,
        "pr_file": "site/en/start/go.md",
        "discussion_id": "1814896854",
        "commented_code": "@@ -0,0 +1,343 @@\n+Project: /_project.yaml\n+Book: /_book.yaml\n+\n+# Bazel Tutorial: Build a Go Project\n+\n+{% include \"_buttons.html\" %}\n+\n+This tutorial introduces you to the basics of Bazel by showing you how to build a Go (Golang) project. You'll learn how to set up your workspace, build a small program, import a library, and run its test. Along the way, you'll learn key Bazel concepts, such as targets and `BUILD` files.\n+\n+Estimated completion time: 30 minutes\n+\n+## What you'll learn\n+\n+## Before you begin\n+\n+### Install Bazel\n+\n+Before you get started, first [install bazel](/install) if you haven't done so already.\n+\n+You can check if Bazel is installed by running `bazel version` in any directory.\n+\n+### Install Go (optional)\n+\n+You don't need to [install Go](https://go.dev/doc/install) to build Go projects with Bazel. The Bazel Go rule set automatically downloads and uses a Go toolchain instead of using the toolchain installed on your machine. This ensures all developers on a project build with same version of Go.\n+\n+However, you may still want to install a Go toolchain to run commands like `go get` and `go mod tidy`.\n+\n+You can check if Go is installed by running `go version` in any directory.\n+\n+### Get the sample project\n+\n+The Bazel examples are stored in a Git repository, so you'll need to [install Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if you haven't already. To download the examples repository, run this command:\n+\n+```posix-terminal\n+git clone https://github.com/bazelbuild/examples\n+```\n+\n+The sample project for this tutorial is in the `examples/go-tutorial` directory. Let's see what it contains:\n+\n+```none\n+go-tutorial/\n+\u2514\u2500\u2500 stage1\n+\u2514\u2500\u2500 stage2\n+\u2514\u2500\u2500 stage3\n+```\n+\n+There are three subdirectories (`stage1`, `stage2`, and `stage3`), each for a different section of this tutorial. Each stage builds on the previous one.\n+\n+## Build with Bazel\n+\n+Let's start in the `stage1` directory, where we'll find a simple program. We can build it with `bazel build`, then run it:\n+\n+```posix-shell\n+$ cd go-tutorial/stage1/\n+$ bazel build //:hello\n+INFO: Analyzed target //:hello (0 packages loaded, 0 targets configured).\n+INFO: Found 1 target...\n+Target //:hello up-to-date:\n+  bazel-bin/hello_/hello\n+INFO: Elapsed time: 0.473s, Critical Path: 0.25s\n+INFO: 3 processes: 1 internal, 2 darwin-sandbox.\n+INFO: Build completed successfully, 3 total actions\n+\n+$ bazel-bin/hello_/hello\n+Hello, Bazel! \ud83d\udc9a\n+```\n+\n+We can also build run the program with a single `bazel run` command:\n+\n+```posix-shell\n+$ bazel run //:hello\n+bazel run //:hello\n+INFO: Analyzed target //:hello (0 packages loaded, 0 targets configured).\n+INFO: Found 1 target...\n+Target //:hello up-to-date:\n+  bazel-bin/hello_/hello\n+INFO: Elapsed time: 0.128s, Critical Path: 0.00s\n+INFO: 1 process: 1 internal.\n+INFO: Build completed successfully, 1 total action\n+INFO: Running command line: bazel-bin/hello_/hello\n+Hello, Bazel! \ud83d\udc9a\n+```\n+\n+### Understanding project structure\n+\n+Let's take a look at the project we just built.\n+\n+`hello.go` contains the Go source code for the program.\n+\n+```go\n+package main\n+\n+import \"fmt\"\n+\n+func main() {\n+\tfmt.Println(\"Hello, Bazel! \ud83d\udc9a\")\n+}\n+```\n+\n+`BUILD` contains some instructions for Bazel, telling it what we want to build. You'll typically write a file like this in each directory. For this project, we have a single `go_binary` target that builds our program from `hello.go`.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_binary\")\n+\n+go_binary(\n+    name = \"hello\",\n+    srcs = [\"hello.go\"],\n+)\n+```\n+\n+`MODULE.bazel` tracks your project's dependencies. It also marks your project's root directory, so you'll only write one `MODULE.bazel` file per project. It serves a similar purpose to Go's `go.mod` file. You don't actually need a `go.mod` file in a Bazel project, but it may still be useful to have one so that you can continue using `go get` and `go mod tidy` for dependency management. The Bazel Go rule set can import dependencies from `go.mod`, but we'll cover that in another tutorial.\n+\n+Our `MODULE.bazel` file contains a single dependency on [rules_go](https://github.com/bazelbuild/rules_go), the Go rule set. We need this dependency because Bazel doesn't have built-in support for Go.\n+\n+```bazel\n+bazel_dep(\n+    name = \"rules_go\",\n+    version = \"0.50.1\",\n+)\n+```\n+\n+Finally, `MODULE.bazel.lock` is a file generated by Bazel that contains hashes and other metadata about our dependencies. It includes implicit dependencies added by Bazel itself, so it's quite long, and we won't show it here. Just like `go.sum`, you should commit your `MODULE.bazel.lock` file to source control to ensure everyone on your project gets the same version of each dependency. You should not need to edit `MODULE.bazel.lock` manually.\n+\n+### Understand the BUILD file\n+\n+Most of your interaction with Bazel will be through `BUILD` files (or equivalently, `BUILD.bazel` files), so it's important to understand what they do.\n+\n+`BUILD` files are written in a scripting language called [Starlark](https://bazel.build/rules/language), a limited subset of Python.\n+\n+A `BUILD` file contains a list of [targets](https://bazel.build/reference/glossary#target). A target is something Bazel can build, like a binary, library, or test.\n+\n+A target calls a rule function with a list of [attributes](https://bazel.build/reference/glossary#attribute) to describe what should be built. Our example has two attributes: `name` identifies the target on the command line, and `srcs` is a list of source file paths (slash-separated, relative to the directory containing the `BUILD` file).\n+\n+A [rule](https://bazel.build/reference/glossary#rule) tells Bazel how to build a target. In our example, we used the [`go_binary`](https://github.com/bazelbuild/rules_go/blob/master/docs/go/core/rules.md#go_binary) rule. Each rule defines [actions](https://bazel.build/reference/glossary#action) (commands) that generate a set of output files. For example, `go_binary` defines Go compile and link actions that produce an executable output file.\n+\n+Bazel has built-in rules for a few languages like Java and C++. You can find their [documentation in the Build Encyclopedia](https://bazel.build/reference/be/overview#rules). You can find rule sets for many other languages and tools on the [Bazel Central Registry (BCR)](https://registry.bazel.build/). \n+\n+## Add a library\n+\n+Let's move onto the `stage2` directory, where we'll build a new program that prints your fortune. This program uses a separate Go package as a library that selects a fortune from a predefined list of messages.\n+\n+```none\n+go-tutorial/stage2\n+\u251c\u2500\u2500 BUILD\n+\u251c\u2500\u2500 MODULE.bazel\n+\u251c\u2500\u2500 MODULE.bazel.lock\n+\u251c\u2500\u2500 fortune\n+\u2502   \u251c\u2500\u2500 BUILD\n+\u2502   \u2514\u2500\u2500 fortune.go\n+\u2514\u2500\u2500 print_fortune.go\n+```\n+\n+`fortune.go` is the source file for the library. The `fortune` library is a separate Go package, so its source files are in a separate directory. Bazel doesn't require you to keep Go packages in separate directories, but it's a strong convention in the Go ecosystem, and following it will help you stay compatible with other Go tools.\n+\n+```go\n+package fortune\n+\n+import \"math/rand\"\n+\n+var fortunes = []string{\n+\t\"Your build will complete quickly.\",\n+\t\"Your dependencies will be free of bugs.\",\n+\t\"Your tests will pass.\",\n+}\n+\n+func Get() string {\n+\treturn fortunes[rand.Intn(len(fortunes))]\n+}\n+```\n+\n+The `fortune` directory has its own `BUILD` file that tells Bazel how to build this package. We use `go_library` here instead of `go_binary`.\n+\n+We also need to set the `importpath` attribute to a string with which the library can be imported into other Go source files. This name should be the repository path (or module path) concatenated with the directory within the repository.\n+\n+Finally, we need to set the `visibility` attribute to `[\"//visibility:public\"]`. [`visibility`](https://bazel.build/concepts/visibility) may be set on any target. It determines which Bazel packages may depend on this target. In our case, we want any target to be able to depend on this library, so we use the special value `//visibility:public`.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_library\")\n+\n+go_library(\n+    name = \"fortune\",\n+    srcs = [\"fortune.go\"],\n+    importpath = \"github.com/bazelbuild/examples/go-tutorial/stage2/fortune\",\n+    visibility = [\"//visibility:public\"],\n+)\n+```\n+\n+You can build this library with:\n+\n+```posix-shell\n+$ bazel build //fortune\n+```\n+\n+Next, let's see how `print_fortune.go` uses this package.\n+\n+```go\n+package main\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/bazelbuild/examples/go-tutorial/stage2/fortune\"\n+)\n+\n+func main() {\n+\tfmt.Println(fortune.Get())\n+}\n+```\n+\n+`print_fortune.go` imports the package using the same string declared in the `importpath` attribute of the `fortune` library.\n+\n+We also need to declare this dependency to Bazel. Here's the `BUILD` file in the `stage2` directory.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_binary\")\n+\n+go_binary(\n+    name = \"print_fortune\",\n+    srcs = [\"print_fortune.go\"],\n+    deps = [\"//fortune\"],\n+)\n+```\n+\n+You can run this with the command below.\n+\n+```posix-shell\n+bazel run //:print_fortune\n+```\n+\n+The `print_fortune` target has a `deps` attribute, a list of other targets that it depends on. It contains `\"//fortune\"`, a label string referring to the target in the `fortune` directory named `fortune`.\n+\n+Bazel requires that all targets declare their dependencies explicitly with attributes like `deps`. This may seem cumbersome since dependencies are *also* specified in source files, but Bazel's explictness gives it an advantage. Bazel builds an [action graph](https://bazel.build/reference/glossary#action-graph) containing all commands, inputs, and outputs before running any commands, without reading any source files. Bazel can then cache action results or send actions for [remote execution](https://bazel.build/remote/rbe) without builtin language-specific logic.\n+\n+### Understanding labels\n+\n+A [label](https://bazel.build/reference/glossary#label) is a string Bazel uses to identify a target or a file. Labels are used in command line arguments and in `BUILD` file attributes like `deps`. We've seen a few already, like `//fortune`, `//:print-fortune`, and `@rules_go//go:def.bzl`.\n+\n+A label has three parts: a repository name, a package name, and a target (or file) name.\n+\n+The repository name is written between `@` and `//` and is used to refer to a target from a different Bazel module (for historical reasons, *module* and *repository* are sometimes used synonymously). In the label, `@rules_go//go:def.bzl`, the repository name is `rules_go`. The repository name can be omitted when referring to targets in the same repository.\n+\n+The package name is written between `//` and `:` and is used to refer to a target in from a different Bazel package. In the label `@rules_go//go:def.bzl`, the package name is `go`. A Bazel [package](https://bazel.build/reference/glossary#package) is a set of files and targets defined by a `BUILD` or `BUILD.bazel` file in its top-level directory. Its package name is a slash-separated path from the module root directory (containing `MODULE.bazel`) to the directory containing the `BUILD` file. A package may include subdirectories, but only if they don't also contain `BUILD` files defining their own packages.\n+\n+Most Go projects have one `BUILD` file per directory and one Go package per `BUILD` file. The package name in a label may be omitted when referring to targets in the same directory.\n+\n+The target name is written after `:` and refers to a target within a package. The target name may be omitted if it's the same as the last component of the package name (so `//a/b/c:c` is the same as `//a/b/c`; `//fortune:fortune` is the same as `//fortune`).\n+\n+On the command-line, you can use `...` as a wildcard to refer to all the targets within a package. This is useful for building or testing all the targets in a repository.\n+\n+```posix-shell\n+# Build everything\n+$ bazel build //...\n+```\n+\n+## Test your project\n+\n+Next, let's move to the `stage3` directory, where we'll add a test.\n+\n+```none\n+go-tutorial/stage3\n+\u251c\u2500\u2500 BUILD\n+\u251c\u2500\u2500 MODULE.bazel\n+\u251c\u2500\u2500 MODULE.bazel.lock\n+\u251c\u2500\u2500 fortune\n+\u2502   \u251c\u2500\u2500 BUILD\n+\u2502   \u251c\u2500\u2500 fortune.go\n+\u2502   \u2514\u2500\u2500 fortune_test.go\n+\u2514\u2500\u2500 print-fortune.go\n+```\n+\n+`fortune/fortune_test.go` is our new test source file.\n+\n+```go\n+package fortune\n+\n+import (\n+\t\"slices\"\n+\t\"testing\"\n+)\n+\n+// TestGet checks that Get returns one of the strings from fortunes.\n+func TestGet(t *testing.T) {\n+\tmsg := Get()\n+\tif i := slices.Index(fortunes, msg); i < 0 {\n+\t\tt.Errorf(\"Get returned %q, not one the expected messages\", msg)\n+\t}\n+}\n+```\n+\n+This file uses the unexported `fortunes` variable, so it needs to be compiled into the same Go package as `fortune.go`. Let's look at the `BUILD` file to see how that works:\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_library\", \"go_test\")\n+\n+go_library(\n+    name = \"fortune\",\n+    srcs = [\"fortune.go\"],\n+    importpath = \"github.com/bazelbuild/examples/go-tutorial/stage3/fortune\",\n+    visibility = [\"//visibility:public\"],\n+)\n+\n+go_test(\n+    name = \"fortune_test\",\n+    srcs = [\"fortune_test.go\"],\n+    embed = [\":fortune\"],\n+)\n+```\n+\n+We have a new `fortune_test` target that uses the `go_test` rule to compile and link a test executable. `go_test` needs to compile `fortune.go` and `fortune_test.go` together with the same command, so we use the `embed` attribute here to incorporate the attributes of the `fortune` target into `fortune_test`. `embed` is most commonly used with `go_test` and `go_binary`, but it also works with `go_library`, which is sometimes useful for generated code.\n+\n+You may be wondering if the `embed` attribute is related to Go's [`embed`](https://pkg.go.dev/embed) package, which is used to access data files copied into an executable. This is an unfortunate name collision: rules_go's `embed` attribute was introduced before Go's `embed` package. Instead, rules_go uses the `embedsrcs` to list files that can be loaded with the `embed` package.\n+\n+Let's try running our test with `bazel test`:\n+\n+```posix-shell\n+$ bazel test //fortune:fortune_test\n+INFO: Analyzed target //fortune:fortune_test (0 packages loaded, 0 targets configured).\n+INFO: Found 1 test target...\n+Target //fortune:fortune_test up-to-date:\n+  bazel-bin/fortune/fortune_test_/fortune_test\n+INFO: Elapsed time: 0.168s, Critical Path: 0.00s\n+INFO: 1 process: 1 internal.\n+INFO: Build completed successfully, 1 total action\n+//fortune:fortune_test                                          PASSED in 0.3s\n+\n+Executed 0 out of 1 test: 1 test passes.\n+There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option to see which ones these are.\n+```\n+\n+You can use the `...` wildcard to run all tests. Bazel will also build targets that aren't tests, so this can catch compile errors even in packages that don't have tests.\n+\n+```posix-shell\n+$ bazel test //...\n+```\n+\n+## Conclusion and further reading\n+\n+In this tutorial, we built and tested a small Go project with Bazel, and we learned some core Bazel concepts along the way.\n+\n+- To get started building other applications with Bazel, see the tutorials for [C++](/start/cpp), [Java](/start/java), [Android](/start/android-app), and [iOS](/start/ios-app).\n+- You can also check the list of [recommended rules](/rules) for other languages.\n+- For more information on Go, see the [rules_go](https://github.com/bazelbuild/rules_go) module, especially the [Core Go rules](https://github.com/bazelbuild/rules_go/blob/master/docs/go/core/rules.md) docuemntation.\n+- To learn more about working with modules outside your project, see [external dependencies](/docs/external).",
        "comment_created_at": "2024-10-24T12:37:21+00:00",
        "comment_author": "fmeum",
        "comment_body": "Could make sense to say `Bazel modules` here as Go modules would be fetched with Gazelle.\n\nCould you also mention external deps and reference the rules_go `bzlmod.md` guide for that?",
        "pr_file_module": null
      },
      {
        "comment_id": "1815647932",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23958,
        "pr_file": "site/en/start/go.md",
        "discussion_id": "1814896854",
        "commented_code": "@@ -0,0 +1,343 @@\n+Project: /_project.yaml\n+Book: /_book.yaml\n+\n+# Bazel Tutorial: Build a Go Project\n+\n+{% include \"_buttons.html\" %}\n+\n+This tutorial introduces you to the basics of Bazel by showing you how to build a Go (Golang) project. You'll learn how to set up your workspace, build a small program, import a library, and run its test. Along the way, you'll learn key Bazel concepts, such as targets and `BUILD` files.\n+\n+Estimated completion time: 30 minutes\n+\n+## What you'll learn\n+\n+## Before you begin\n+\n+### Install Bazel\n+\n+Before you get started, first [install bazel](/install) if you haven't done so already.\n+\n+You can check if Bazel is installed by running `bazel version` in any directory.\n+\n+### Install Go (optional)\n+\n+You don't need to [install Go](https://go.dev/doc/install) to build Go projects with Bazel. The Bazel Go rule set automatically downloads and uses a Go toolchain instead of using the toolchain installed on your machine. This ensures all developers on a project build with same version of Go.\n+\n+However, you may still want to install a Go toolchain to run commands like `go get` and `go mod tidy`.\n+\n+You can check if Go is installed by running `go version` in any directory.\n+\n+### Get the sample project\n+\n+The Bazel examples are stored in a Git repository, so you'll need to [install Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git) if you haven't already. To download the examples repository, run this command:\n+\n+```posix-terminal\n+git clone https://github.com/bazelbuild/examples\n+```\n+\n+The sample project for this tutorial is in the `examples/go-tutorial` directory. Let's see what it contains:\n+\n+```none\n+go-tutorial/\n+\u2514\u2500\u2500 stage1\n+\u2514\u2500\u2500 stage2\n+\u2514\u2500\u2500 stage3\n+```\n+\n+There are three subdirectories (`stage1`, `stage2`, and `stage3`), each for a different section of this tutorial. Each stage builds on the previous one.\n+\n+## Build with Bazel\n+\n+Let's start in the `stage1` directory, where we'll find a simple program. We can build it with `bazel build`, then run it:\n+\n+```posix-shell\n+$ cd go-tutorial/stage1/\n+$ bazel build //:hello\n+INFO: Analyzed target //:hello (0 packages loaded, 0 targets configured).\n+INFO: Found 1 target...\n+Target //:hello up-to-date:\n+  bazel-bin/hello_/hello\n+INFO: Elapsed time: 0.473s, Critical Path: 0.25s\n+INFO: 3 processes: 1 internal, 2 darwin-sandbox.\n+INFO: Build completed successfully, 3 total actions\n+\n+$ bazel-bin/hello_/hello\n+Hello, Bazel! \ud83d\udc9a\n+```\n+\n+We can also build run the program with a single `bazel run` command:\n+\n+```posix-shell\n+$ bazel run //:hello\n+bazel run //:hello\n+INFO: Analyzed target //:hello (0 packages loaded, 0 targets configured).\n+INFO: Found 1 target...\n+Target //:hello up-to-date:\n+  bazel-bin/hello_/hello\n+INFO: Elapsed time: 0.128s, Critical Path: 0.00s\n+INFO: 1 process: 1 internal.\n+INFO: Build completed successfully, 1 total action\n+INFO: Running command line: bazel-bin/hello_/hello\n+Hello, Bazel! \ud83d\udc9a\n+```\n+\n+### Understanding project structure\n+\n+Let's take a look at the project we just built.\n+\n+`hello.go` contains the Go source code for the program.\n+\n+```go\n+package main\n+\n+import \"fmt\"\n+\n+func main() {\n+\tfmt.Println(\"Hello, Bazel! \ud83d\udc9a\")\n+}\n+```\n+\n+`BUILD` contains some instructions for Bazel, telling it what we want to build. You'll typically write a file like this in each directory. For this project, we have a single `go_binary` target that builds our program from `hello.go`.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_binary\")\n+\n+go_binary(\n+    name = \"hello\",\n+    srcs = [\"hello.go\"],\n+)\n+```\n+\n+`MODULE.bazel` tracks your project's dependencies. It also marks your project's root directory, so you'll only write one `MODULE.bazel` file per project. It serves a similar purpose to Go's `go.mod` file. You don't actually need a `go.mod` file in a Bazel project, but it may still be useful to have one so that you can continue using `go get` and `go mod tidy` for dependency management. The Bazel Go rule set can import dependencies from `go.mod`, but we'll cover that in another tutorial.\n+\n+Our `MODULE.bazel` file contains a single dependency on [rules_go](https://github.com/bazelbuild/rules_go), the Go rule set. We need this dependency because Bazel doesn't have built-in support for Go.\n+\n+```bazel\n+bazel_dep(\n+    name = \"rules_go\",\n+    version = \"0.50.1\",\n+)\n+```\n+\n+Finally, `MODULE.bazel.lock` is a file generated by Bazel that contains hashes and other metadata about our dependencies. It includes implicit dependencies added by Bazel itself, so it's quite long, and we won't show it here. Just like `go.sum`, you should commit your `MODULE.bazel.lock` file to source control to ensure everyone on your project gets the same version of each dependency. You should not need to edit `MODULE.bazel.lock` manually.\n+\n+### Understand the BUILD file\n+\n+Most of your interaction with Bazel will be through `BUILD` files (or equivalently, `BUILD.bazel` files), so it's important to understand what they do.\n+\n+`BUILD` files are written in a scripting language called [Starlark](https://bazel.build/rules/language), a limited subset of Python.\n+\n+A `BUILD` file contains a list of [targets](https://bazel.build/reference/glossary#target). A target is something Bazel can build, like a binary, library, or test.\n+\n+A target calls a rule function with a list of [attributes](https://bazel.build/reference/glossary#attribute) to describe what should be built. Our example has two attributes: `name` identifies the target on the command line, and `srcs` is a list of source file paths (slash-separated, relative to the directory containing the `BUILD` file).\n+\n+A [rule](https://bazel.build/reference/glossary#rule) tells Bazel how to build a target. In our example, we used the [`go_binary`](https://github.com/bazelbuild/rules_go/blob/master/docs/go/core/rules.md#go_binary) rule. Each rule defines [actions](https://bazel.build/reference/glossary#action) (commands) that generate a set of output files. For example, `go_binary` defines Go compile and link actions that produce an executable output file.\n+\n+Bazel has built-in rules for a few languages like Java and C++. You can find their [documentation in the Build Encyclopedia](https://bazel.build/reference/be/overview#rules). You can find rule sets for many other languages and tools on the [Bazel Central Registry (BCR)](https://registry.bazel.build/). \n+\n+## Add a library\n+\n+Let's move onto the `stage2` directory, where we'll build a new program that prints your fortune. This program uses a separate Go package as a library that selects a fortune from a predefined list of messages.\n+\n+```none\n+go-tutorial/stage2\n+\u251c\u2500\u2500 BUILD\n+\u251c\u2500\u2500 MODULE.bazel\n+\u251c\u2500\u2500 MODULE.bazel.lock\n+\u251c\u2500\u2500 fortune\n+\u2502   \u251c\u2500\u2500 BUILD\n+\u2502   \u2514\u2500\u2500 fortune.go\n+\u2514\u2500\u2500 print_fortune.go\n+```\n+\n+`fortune.go` is the source file for the library. The `fortune` library is a separate Go package, so its source files are in a separate directory. Bazel doesn't require you to keep Go packages in separate directories, but it's a strong convention in the Go ecosystem, and following it will help you stay compatible with other Go tools.\n+\n+```go\n+package fortune\n+\n+import \"math/rand\"\n+\n+var fortunes = []string{\n+\t\"Your build will complete quickly.\",\n+\t\"Your dependencies will be free of bugs.\",\n+\t\"Your tests will pass.\",\n+}\n+\n+func Get() string {\n+\treturn fortunes[rand.Intn(len(fortunes))]\n+}\n+```\n+\n+The `fortune` directory has its own `BUILD` file that tells Bazel how to build this package. We use `go_library` here instead of `go_binary`.\n+\n+We also need to set the `importpath` attribute to a string with which the library can be imported into other Go source files. This name should be the repository path (or module path) concatenated with the directory within the repository.\n+\n+Finally, we need to set the `visibility` attribute to `[\"//visibility:public\"]`. [`visibility`](https://bazel.build/concepts/visibility) may be set on any target. It determines which Bazel packages may depend on this target. In our case, we want any target to be able to depend on this library, so we use the special value `//visibility:public`.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_library\")\n+\n+go_library(\n+    name = \"fortune\",\n+    srcs = [\"fortune.go\"],\n+    importpath = \"github.com/bazelbuild/examples/go-tutorial/stage2/fortune\",\n+    visibility = [\"//visibility:public\"],\n+)\n+```\n+\n+You can build this library with:\n+\n+```posix-shell\n+$ bazel build //fortune\n+```\n+\n+Next, let's see how `print_fortune.go` uses this package.\n+\n+```go\n+package main\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/bazelbuild/examples/go-tutorial/stage2/fortune\"\n+)\n+\n+func main() {\n+\tfmt.Println(fortune.Get())\n+}\n+```\n+\n+`print_fortune.go` imports the package using the same string declared in the `importpath` attribute of the `fortune` library.\n+\n+We also need to declare this dependency to Bazel. Here's the `BUILD` file in the `stage2` directory.\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_binary\")\n+\n+go_binary(\n+    name = \"print_fortune\",\n+    srcs = [\"print_fortune.go\"],\n+    deps = [\"//fortune\"],\n+)\n+```\n+\n+You can run this with the command below.\n+\n+```posix-shell\n+bazel run //:print_fortune\n+```\n+\n+The `print_fortune` target has a `deps` attribute, a list of other targets that it depends on. It contains `\"//fortune\"`, a label string referring to the target in the `fortune` directory named `fortune`.\n+\n+Bazel requires that all targets declare their dependencies explicitly with attributes like `deps`. This may seem cumbersome since dependencies are *also* specified in source files, but Bazel's explictness gives it an advantage. Bazel builds an [action graph](https://bazel.build/reference/glossary#action-graph) containing all commands, inputs, and outputs before running any commands, without reading any source files. Bazel can then cache action results or send actions for [remote execution](https://bazel.build/remote/rbe) without builtin language-specific logic.\n+\n+### Understanding labels\n+\n+A [label](https://bazel.build/reference/glossary#label) is a string Bazel uses to identify a target or a file. Labels are used in command line arguments and in `BUILD` file attributes like `deps`. We've seen a few already, like `//fortune`, `//:print-fortune`, and `@rules_go//go:def.bzl`.\n+\n+A label has three parts: a repository name, a package name, and a target (or file) name.\n+\n+The repository name is written between `@` and `//` and is used to refer to a target from a different Bazel module (for historical reasons, *module* and *repository* are sometimes used synonymously). In the label, `@rules_go//go:def.bzl`, the repository name is `rules_go`. The repository name can be omitted when referring to targets in the same repository.\n+\n+The package name is written between `//` and `:` and is used to refer to a target in from a different Bazel package. In the label `@rules_go//go:def.bzl`, the package name is `go`. A Bazel [package](https://bazel.build/reference/glossary#package) is a set of files and targets defined by a `BUILD` or `BUILD.bazel` file in its top-level directory. Its package name is a slash-separated path from the module root directory (containing `MODULE.bazel`) to the directory containing the `BUILD` file. A package may include subdirectories, but only if they don't also contain `BUILD` files defining their own packages.\n+\n+Most Go projects have one `BUILD` file per directory and one Go package per `BUILD` file. The package name in a label may be omitted when referring to targets in the same directory.\n+\n+The target name is written after `:` and refers to a target within a package. The target name may be omitted if it's the same as the last component of the package name (so `//a/b/c:c` is the same as `//a/b/c`; `//fortune:fortune` is the same as `//fortune`).\n+\n+On the command-line, you can use `...` as a wildcard to refer to all the targets within a package. This is useful for building or testing all the targets in a repository.\n+\n+```posix-shell\n+# Build everything\n+$ bazel build //...\n+```\n+\n+## Test your project\n+\n+Next, let's move to the `stage3` directory, where we'll add a test.\n+\n+```none\n+go-tutorial/stage3\n+\u251c\u2500\u2500 BUILD\n+\u251c\u2500\u2500 MODULE.bazel\n+\u251c\u2500\u2500 MODULE.bazel.lock\n+\u251c\u2500\u2500 fortune\n+\u2502   \u251c\u2500\u2500 BUILD\n+\u2502   \u251c\u2500\u2500 fortune.go\n+\u2502   \u2514\u2500\u2500 fortune_test.go\n+\u2514\u2500\u2500 print-fortune.go\n+```\n+\n+`fortune/fortune_test.go` is our new test source file.\n+\n+```go\n+package fortune\n+\n+import (\n+\t\"slices\"\n+\t\"testing\"\n+)\n+\n+// TestGet checks that Get returns one of the strings from fortunes.\n+func TestGet(t *testing.T) {\n+\tmsg := Get()\n+\tif i := slices.Index(fortunes, msg); i < 0 {\n+\t\tt.Errorf(\"Get returned %q, not one the expected messages\", msg)\n+\t}\n+}\n+```\n+\n+This file uses the unexported `fortunes` variable, so it needs to be compiled into the same Go package as `fortune.go`. Let's look at the `BUILD` file to see how that works:\n+\n+```bazel\n+load(\"@rules_go//go:def.bzl\", \"go_library\", \"go_test\")\n+\n+go_library(\n+    name = \"fortune\",\n+    srcs = [\"fortune.go\"],\n+    importpath = \"github.com/bazelbuild/examples/go-tutorial/stage3/fortune\",\n+    visibility = [\"//visibility:public\"],\n+)\n+\n+go_test(\n+    name = \"fortune_test\",\n+    srcs = [\"fortune_test.go\"],\n+    embed = [\":fortune\"],\n+)\n+```\n+\n+We have a new `fortune_test` target that uses the `go_test` rule to compile and link a test executable. `go_test` needs to compile `fortune.go` and `fortune_test.go` together with the same command, so we use the `embed` attribute here to incorporate the attributes of the `fortune` target into `fortune_test`. `embed` is most commonly used with `go_test` and `go_binary`, but it also works with `go_library`, which is sometimes useful for generated code.\n+\n+You may be wondering if the `embed` attribute is related to Go's [`embed`](https://pkg.go.dev/embed) package, which is used to access data files copied into an executable. This is an unfortunate name collision: rules_go's `embed` attribute was introduced before Go's `embed` package. Instead, rules_go uses the `embedsrcs` to list files that can be loaded with the `embed` package.\n+\n+Let's try running our test with `bazel test`:\n+\n+```posix-shell\n+$ bazel test //fortune:fortune_test\n+INFO: Analyzed target //fortune:fortune_test (0 packages loaded, 0 targets configured).\n+INFO: Found 1 test target...\n+Target //fortune:fortune_test up-to-date:\n+  bazel-bin/fortune/fortune_test_/fortune_test\n+INFO: Elapsed time: 0.168s, Critical Path: 0.00s\n+INFO: 1 process: 1 internal.\n+INFO: Build completed successfully, 1 total action\n+//fortune:fortune_test                                          PASSED in 0.3s\n+\n+Executed 0 out of 1 test: 1 test passes.\n+There were tests whose specified size is too big. Use the --test_verbose_timeout_warnings command line option to see which ones these are.\n+```\n+\n+You can use the `...` wildcard to run all tests. Bazel will also build targets that aren't tests, so this can catch compile errors even in packages that don't have tests.\n+\n+```posix-shell\n+$ bazel test //...\n+```\n+\n+## Conclusion and further reading\n+\n+In this tutorial, we built and tested a small Go project with Bazel, and we learned some core Bazel concepts along the way.\n+\n+- To get started building other applications with Bazel, see the tutorials for [C++](/start/cpp), [Java](/start/java), [Android](/start/android-app), and [iOS](/start/ios-app).\n+- You can also check the list of [recommended rules](/rules) for other languages.\n+- For more information on Go, see the [rules_go](https://github.com/bazelbuild/rules_go) module, especially the [Core Go rules](https://github.com/bazelbuild/rules_go/blob/master/docs/go/core/rules.md) docuemntation.\n+- To learn more about working with modules outside your project, see [external dependencies](/docs/external).",
        "comment_created_at": "2024-10-24T20:18:54+00:00",
        "comment_author": "jayconrod",
        "comment_body": "Thanks, made both changes.",
        "pr_file_module": null
      }
    ]
  }
]