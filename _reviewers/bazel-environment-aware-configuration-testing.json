[
  {
    "discussion_id": "2005812436",
    "pr_number": 14308,
    "pr_file": "src/test/shell/integration/rc_options_test.sh",
    "created_at": "2025-03-20T14:44:08+00:00",
    "commented_code": "expect_not_log '^xxxxxxxxxxx'\n }\n \n+function test_bep_option_source() {\n+  local -r build_event_text_file=\"$(pwd)/bep.txt\"\n+  local -r pkg=$FUNCNAME\n+  create_pkg $pkg\n+  bazel build --build_event_text_file=\"$build_event_text_file\" \\",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2005812436",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 14308,
        "pr_file": "src/test/shell/integration/rc_options_test.sh",
        "discussion_id": "2005812436",
        "commented_code": "@@ -96,4 +96,13 @@ function test_options_override() {\n   expect_not_log '^xxxxxxxxxxx'\n }\n \n+function test_bep_option_source() {\n+  local -r build_event_text_file=\"$(pwd)/bep.txt\"\n+  local -r pkg=$FUNCNAME\n+  create_pkg $pkg\n+  bazel build --build_event_text_file=\"$build_event_text_file\" \\",
        "comment_created_at": "2025-03-20T14:44:08+00:00",
        "comment_author": "meisterT",
        "comment_body": "consider logging to `$TEST_log` and then using `expect_log`\r\n\r\nThat will most likely also make the windows CI error go away",
        "pr_file_module": null
      },
      {
        "comment_id": "2005918954",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 14308,
        "pr_file": "src/test/shell/integration/rc_options_test.sh",
        "discussion_id": "2005812436",
        "commented_code": "@@ -96,4 +96,13 @@ function test_options_override() {\n   expect_not_log '^xxxxxxxxxxx'\n }\n \n+function test_bep_option_source() {\n+  local -r build_event_text_file=\"$(pwd)/bep.txt\"\n+  local -r pkg=$FUNCNAME\n+  create_pkg $pkg\n+  bazel build --build_event_text_file=\"$build_event_text_file\" \\",
        "comment_created_at": "2025-03-20T15:34:51+00:00",
        "comment_author": "Yannic",
        "comment_body": "Done, but Windows is still failing and never has `source=C:...` for some reason. I don't immediately see what's different on Windows here",
        "pr_file_module": null
      },
      {
        "comment_id": "2007096624",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 14308,
        "pr_file": "src/test/shell/integration/rc_options_test.sh",
        "discussion_id": "2005812436",
        "commented_code": "@@ -96,4 +96,13 @@ function test_options_override() {\n   expect_not_log '^xxxxxxxxxxx'\n }\n \n+function test_bep_option_source() {\n+  local -r build_event_text_file=\"$(pwd)/bep.txt\"\n+  local -r pkg=$FUNCNAME\n+  create_pkg $pkg\n+  bazel build --build_event_text_file=\"$build_event_text_file\" \\",
        "comment_created_at": "2025-03-21T08:41:40+00:00",
        "comment_author": "meisterT",
        "comment_body": "This is what you see in the log:\r\n\r\n```\r\n        source: \"c:\\\\b\\\\25iqplwx\\\\execroot\\\\_main\\\\_tmp\\\\8169ff1475785e994d89051acf25c560\\\\bazelrc\"\r\n```\r\n\r\nThis is what the error message:\r\n\r\n```\r\ntest_bep_option_source FAILED: Expected regexp 'source: \"C:/b/25iqplwx/execroot/_main/_tmp/8169ff1475785e994d89051acf25c560/bazelrc\"' not found.\r\n```\r\n\r\nSo I think you have to do something like:\r\n```\r\nif is_windows; then\r\n  expected_path=$(echo \"$bazelrc\" | sed 's/^C:/c:/; s/\\//\\\\\\\\/g')\r\nelse\r\n  expected_path=\"$bazelrc\"\r\nfi\r\nexpect_log \"source: \\\"$expected_path\\\"\"\r\n```\r\n  ",
        "pr_file_module": null
      },
      {
        "comment_id": "2007238986",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 14308,
        "pr_file": "src/test/shell/integration/rc_options_test.sh",
        "discussion_id": "2005812436",
        "commented_code": "@@ -96,4 +96,13 @@ function test_options_override() {\n   expect_not_log '^xxxxxxxxxxx'\n }\n \n+function test_bep_option_source() {\n+  local -r build_event_text_file=\"$(pwd)/bep.txt\"\n+  local -r pkg=$FUNCNAME\n+  create_pkg $pkg\n+  bazel build --build_event_text_file=\"$build_event_text_file\" \\",
        "comment_created_at": "2025-03-21T09:57:50+00:00",
        "comment_author": "Yannic",
        "comment_body": "Thanks! This fixed the first part of the error. But it's still failing\r\n\r\n```\r\n      option {\r\n        combined_form: \"--output_user_root=c:\\\\tmp\\\\bazel_root_1ge5yj\"\r\n        option_name: \"output_user_root\"\r\n        option_value: \"c:\\\\tmp\\\\bazel_root_1ge5yj\"\r\n        effect_tags: AFFECTS_OUTPUTS\r\n        effect_tags: LOSES_INCREMENTAL_STATE\r\n        source: \"c:\\\\b\\\\4zq342hb\\\\execroot\\\\_main\\\\_tmp\\\\8169ff1475785e994d89051acf25c560\\\\bazelrc\"\r\n      }\r\n```\r\n\r\n```\r\ntest_bep_option_source FAILED: Expected regexp 'source: \"c:\\\\b\\\\4zq342hb\\\\execroot\\\\_main\\\\_tmp\\\\8169ff1475785e994d89051acf25c560\\\\bazelrc\"' not found.\r\nC:/b/4zq342hb/execroot/_main/bazel-out/x64_windows-fastbuild/bin/src/test/shell/integration/rc_options_test:111: in call to test_bep_option_source\r\n```\r\n\r\nIs the regex evaluation somehow different on Windows?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1148576781",
    "pr_number": 17887,
    "pr_file": "src/test/shell/bazel/cc_integration_test.sh",
    "created_at": "2023-03-26T15:13:28+00:00",
    "commented_code": "@other_repo//pkg:test &>\"$TEST_log\" || fail \"Test should succeed\"\n   expect_log \"in external/other_repo/pkg/test.cpp: 'other_repo'\"\n   expect_log \"in pkg/library.cpp: ''\"\n+\n+  # test Runfiles::CurrentRepository()\n+  cat > pkg/BUILD.bazel <<'EOF'\n+cc_library(\n+  name = \"library\",\n+  hdrs = [\"library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\", \":gen_library\", \"@other_repo//gen_pkg:gen_library\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+)\n+\n+cc_binary(\n+  name = \"binary\",\n+  srcs = [\"binary.cpp\"],\n+  deps = [\":library\"],\n+)\n+\n+cc_test(\n+  name = \"test\",\n+  srcs = [\"test.cpp\"],\n+  deps = [\":library\"],\n+)\n+EOF\n+\n+  mkdir -p other_repo/gen_pkg\n+  cat > other_repo/gen_pkg/BUILD.bazel <<'EOF'\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void other_repo_gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+EOF\n+\n+  cat > pkg/library.h <<'EOF'\n+#include <iostream>\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+#include \"pkg/gen_library.h\"\n+#include \"gen_pkg/gen_library.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+  gen_print_repo_name();\n+  other_repo_gen_print_repo_name();\n+}\n+EOF\n+\n+  bazel run //pkg:binary &>\"$TEST_log\" || fail \"Run should succeed\"",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1148576781",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17887,
        "pr_file": "src/test/shell/bazel/cc_integration_test.sh",
        "discussion_id": "1148576781",
        "commented_code": "@@ -1655,6 +1655,120 @@ EOF\n     @other_repo//pkg:test &>\"$TEST_log\" || fail \"Test should succeed\"\n   expect_log \"in external/other_repo/pkg/test.cpp: 'other_repo'\"\n   expect_log \"in pkg/library.cpp: ''\"\n+\n+  # test Runfiles::CurrentRepository()\n+  cat > pkg/BUILD.bazel <<'EOF'\n+cc_library(\n+  name = \"library\",\n+  hdrs = [\"library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\", \":gen_library\", \"@other_repo//gen_pkg:gen_library\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+)\n+\n+cc_binary(\n+  name = \"binary\",\n+  srcs = [\"binary.cpp\"],\n+  deps = [\":library\"],\n+)\n+\n+cc_test(\n+  name = \"test\",\n+  srcs = [\"test.cpp\"],\n+  deps = [\":library\"],\n+)\n+EOF\n+\n+  mkdir -p other_repo/gen_pkg\n+  cat > other_repo/gen_pkg/BUILD.bazel <<'EOF'\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void other_repo_gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+EOF\n+\n+  cat > pkg/library.h <<'EOF'\n+#include <iostream>\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+#include \"pkg/gen_library.h\"\n+#include \"gen_pkg/gen_library.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+  gen_print_repo_name();\n+  other_repo_gen_print_repo_name();\n+}\n+EOF\n+\n+  bazel run //pkg:binary &>\"$TEST_log\" || fail \"Run should succeed\"",
        "comment_created_at": "2023-03-26T15:13:28+00:00",
        "comment_author": "fmeum",
        "comment_body": "I think that the test fails because Bazel uses C++11 by default. You probably have to add `--copt=c++20`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1148594479",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17887,
        "pr_file": "src/test/shell/bazel/cc_integration_test.sh",
        "discussion_id": "1148576781",
        "commented_code": "@@ -1655,6 +1655,120 @@ EOF\n     @other_repo//pkg:test &>\"$TEST_log\" || fail \"Test should succeed\"\n   expect_log \"in external/other_repo/pkg/test.cpp: 'other_repo'\"\n   expect_log \"in pkg/library.cpp: ''\"\n+\n+  # test Runfiles::CurrentRepository()\n+  cat > pkg/BUILD.bazel <<'EOF'\n+cc_library(\n+  name = \"library\",\n+  hdrs = [\"library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\", \":gen_library\", \"@other_repo//gen_pkg:gen_library\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+)\n+\n+cc_binary(\n+  name = \"binary\",\n+  srcs = [\"binary.cpp\"],\n+  deps = [\":library\"],\n+)\n+\n+cc_test(\n+  name = \"test\",\n+  srcs = [\"test.cpp\"],\n+  deps = [\":library\"],\n+)\n+EOF\n+\n+  mkdir -p other_repo/gen_pkg\n+  cat > other_repo/gen_pkg/BUILD.bazel <<'EOF'\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void other_repo_gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+EOF\n+\n+  cat > pkg/library.h <<'EOF'\n+#include <iostream>\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+#include \"pkg/gen_library.h\"\n+#include \"gen_pkg/gen_library.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+  gen_print_repo_name();\n+  other_repo_gen_print_repo_name();\n+}\n+EOF\n+\n+  bazel run //pkg:binary &>\"$TEST_log\" || fail \"Run should succeed\"",
        "comment_created_at": "2023-03-26T16:51:28+00:00",
        "comment_author": "BoleynSu",
        "comment_body": "Currently, using CurrentRepository will fail when the cc toolchain does not support __builtin_FILE. I guess it is failing in such cases. Could we just check if it is supported and skip the rest of not?",
        "pr_file_module": null
      },
      {
        "comment_id": "1148599498",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17887,
        "pr_file": "src/test/shell/bazel/cc_integration_test.sh",
        "discussion_id": "1148576781",
        "commented_code": "@@ -1655,6 +1655,120 @@ EOF\n     @other_repo//pkg:test &>\"$TEST_log\" || fail \"Test should succeed\"\n   expect_log \"in external/other_repo/pkg/test.cpp: 'other_repo'\"\n   expect_log \"in pkg/library.cpp: ''\"\n+\n+  # test Runfiles::CurrentRepository()\n+  cat > pkg/BUILD.bazel <<'EOF'\n+cc_library(\n+  name = \"library\",\n+  hdrs = [\"library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\", \":gen_library\", \"@other_repo//gen_pkg:gen_library\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+)\n+\n+cc_binary(\n+  name = \"binary\",\n+  srcs = [\"binary.cpp\"],\n+  deps = [\":library\"],\n+)\n+\n+cc_test(\n+  name = \"test\",\n+  srcs = [\"test.cpp\"],\n+  deps = [\":library\"],\n+)\n+EOF\n+\n+  mkdir -p other_repo/gen_pkg\n+  cat > other_repo/gen_pkg/BUILD.bazel <<'EOF'\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void other_repo_gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+EOF\n+\n+  cat > pkg/library.h <<'EOF'\n+#include <iostream>\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+#include \"pkg/gen_library.h\"\n+#include \"gen_pkg/gen_library.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+  gen_print_repo_name();\n+  other_repo_gen_print_repo_name();\n+}\n+EOF\n+\n+  bazel run //pkg:binary &>\"$TEST_log\" || fail \"Run should succeed\"",
        "comment_created_at": "2023-03-26T17:20:38+00:00",
        "comment_author": "fmeum",
        "comment_body": "We could, but I think that the test just wouldn't run if we did: Since Bazel passes `--std=0x` on Unix by default, it just won't be available on any of the runners.",
        "pr_file_module": null
      },
      {
        "comment_id": "1167829983",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17887,
        "pr_file": "src/test/shell/bazel/cc_integration_test.sh",
        "discussion_id": "1148576781",
        "commented_code": "@@ -1655,6 +1655,120 @@ EOF\n     @other_repo//pkg:test &>\"$TEST_log\" || fail \"Test should succeed\"\n   expect_log \"in external/other_repo/pkg/test.cpp: 'other_repo'\"\n   expect_log \"in pkg/library.cpp: ''\"\n+\n+  # test Runfiles::CurrentRepository()\n+  cat > pkg/BUILD.bazel <<'EOF'\n+cc_library(\n+  name = \"library\",\n+  hdrs = [\"library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\", \":gen_library\", \"@other_repo//gen_pkg:gen_library\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+)\n+\n+cc_binary(\n+  name = \"binary\",\n+  srcs = [\"binary.cpp\"],\n+  deps = [\":library\"],\n+)\n+\n+cc_test(\n+  name = \"test\",\n+  srcs = [\"test.cpp\"],\n+  deps = [\":library\"],\n+)\n+EOF\n+\n+  mkdir -p other_repo/gen_pkg\n+  cat > other_repo/gen_pkg/BUILD.bazel <<'EOF'\n+genrule(\n+  name = \"gen_library_hdr\",\n+  outs = [\"gen_library.h\"],\n+  cmd = \"\"\"\n+cat >$@ <<EOF_\n+#include <iostream>\n+\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void other_repo_gen_print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+}\n+EOF_\n+\"\"\"\n+)\n+\n+cc_library(\n+  name = \"gen_library\",\n+  hdrs = [\"gen_library.h\"],\n+  deps = [\"@bazel_tools//tools/cpp/runfiles\"],\n+  visibility = [\"//visibility:public\"],\n+)\n+EOF\n+\n+  cat > pkg/library.h <<'EOF'\n+#include <iostream>\n+#include \"tools/cpp/runfiles/runfiles.h\"\n+#include \"pkg/gen_library.h\"\n+#include \"gen_pkg/gen_library.h\"\n+\n+using bazel::tools::cpp::runfiles::Runfiles;\n+\n+inline void print_repo_name() {\n+  std::cout << \"in \" << __FILE__ << \": '\" << Runfiles::CurrentRepository() << \"'\" << std::endl;\n+  gen_print_repo_name();\n+  other_repo_gen_print_repo_name();\n+}\n+EOF\n+\n+  bazel run //pkg:binary &>\"$TEST_log\" || fail \"Run should succeed\"",
        "comment_created_at": "2023-04-16T11:04:15+00:00",
        "comment_author": "BoleynSu",
        "comment_body": "It is more related to compiler version. Some older compiler does not support `__builtin_FILE`. I added a cc_test if test if `__builtin_FILE` is supported or not and skip the test if it is not supported.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066660308",
    "pr_number": 25868,
    "pr_file": "src/test/shell/bazel/remote/remote_execution_test.sh",
    "created_at": "2025-04-29T14:18:40+00:00",
    "commented_code": "assert_contains \"input\" bazel-bin/a/my_rule\n }\n \n+# Verifies that the contents of a directory have the same representation with\n+# remote execution regardless of whether they are added as a source directory or\n+# via globbing.\n+function test_source_directory() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+GENRULE_COMMAND = \"\"\"\n+[[ -f a/dir/file.txt ]] || { echo \"a/dir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/file.txt ]] || { echo \"a/dir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink_dir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink_dir ]] || { echo \"a/dir/symlink_dir is a symlink\"; exit 1; }\n+[[ ! -e a/dir/empty_dir ]] || { echo \"a/dir/empty_dir exists\"; exit 1; }\n+[[ ! -e a/dir/symlink_empty_dir ]] || { echo \"a/dir/symlink_empty_dir exists\"; exit 1; }\n+touch $@\n+\"\"\"\n+\n+genrule(\n+    name = \"gen_source_directory\",\n+    srcs = [\"dir\"],\n+    outs = [\"out1\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+\n+genrule(\n+    name = \"gen_glob\",\n+    srcs = glob([\"dir/**\"]),\n+    outs = [\"out2\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+EOF\n+  mkdir -p a/dir\n+  touch a/dir/file.txt\n+  ln -s file.txt a/dir/symlink.txt\n+  mkdir -p a/dir/subdir\n+  touch a/dir/subdir/file.txt\n+  ln -s subdir a/dir/symlink_dir\n+  mkdir a/dir/empty_dir\n+  ln -s empty_dir a/dir/symlink_empty_dir\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_source_directory >& $TEST_log || fail \"Failed to build //a:gen_source_directory\"\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_glob >& $TEST_log || fail \"Failed to build //a:gen_glob\"\n+}\n+\n+function test_source_directory_dangling_symlink() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+genrule(\n+    name = \"gen\",\n+    srcs = [\"dir\"],\n+    outs = [\"out\"],\n+    cmd = \"\"\"\n+touch $@\n+\"\"\",\n+)\n+EOF\n+  mkdir -p a/dir\n+  ln -s does_not_exist a/dir/symlink.txt\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen >& $TEST_log && fail \"build //a:gen should fail\"\n+  expect_log \"The file type of 'a/dir/symlink.txt' is not supported.\"\n+}",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2066660308",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25868,
        "pr_file": "src/test/shell/bazel/remote/remote_execution_test.sh",
        "discussion_id": "2066660308",
        "commented_code": "@@ -3766,4 +3766,77 @@ EOF\n   assert_contains \"input\" bazel-bin/a/my_rule\n }\n \n+# Verifies that the contents of a directory have the same representation with\n+# remote execution regardless of whether they are added as a source directory or\n+# via globbing.\n+function test_source_directory() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+GENRULE_COMMAND = \"\"\"\n+[[ -f a/dir/file.txt ]] || { echo \"a/dir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/file.txt ]] || { echo \"a/dir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink_dir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink_dir ]] || { echo \"a/dir/symlink_dir is a symlink\"; exit 1; }\n+[[ ! -e a/dir/empty_dir ]] || { echo \"a/dir/empty_dir exists\"; exit 1; }\n+[[ ! -e a/dir/symlink_empty_dir ]] || { echo \"a/dir/symlink_empty_dir exists\"; exit 1; }\n+touch $@\n+\"\"\"\n+\n+genrule(\n+    name = \"gen_source_directory\",\n+    srcs = [\"dir\"],\n+    outs = [\"out1\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+\n+genrule(\n+    name = \"gen_glob\",\n+    srcs = glob([\"dir/**\"]),\n+    outs = [\"out2\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+EOF\n+  mkdir -p a/dir\n+  touch a/dir/file.txt\n+  ln -s file.txt a/dir/symlink.txt\n+  mkdir -p a/dir/subdir\n+  touch a/dir/subdir/file.txt\n+  ln -s subdir a/dir/symlink_dir\n+  mkdir a/dir/empty_dir\n+  ln -s empty_dir a/dir/symlink_empty_dir\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_source_directory >& $TEST_log || fail \"Failed to build //a:gen_source_directory\"\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_glob >& $TEST_log || fail \"Failed to build //a:gen_glob\"\n+}\n+\n+function test_source_directory_dangling_symlink() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+genrule(\n+    name = \"gen\",\n+    srcs = [\"dir\"],\n+    outs = [\"out\"],\n+    cmd = \"\"\"\n+touch $@\n+\"\"\",\n+)\n+EOF\n+  mkdir -p a/dir\n+  ln -s does_not_exist a/dir/symlink.txt\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen >& $TEST_log && fail \"build //a:gen should fail\"\n+  expect_log \"The file type of 'a/dir/symlink.txt' is not supported.\"\n+}",
        "comment_created_at": "2025-04-29T14:18:40+00:00",
        "comment_author": "tjgq",
        "comment_body": "It should be possible to delete this test (or move it to a more suitable place) once mtime-based hashing of source directories is no longer a thing, right? Please leave a comment to that effect.",
        "pr_file_module": null
      },
      {
        "comment_id": "2067035169",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25868,
        "pr_file": "src/test/shell/bazel/remote/remote_execution_test.sh",
        "discussion_id": "2066660308",
        "commented_code": "@@ -3766,4 +3766,77 @@ EOF\n   assert_contains \"input\" bazel-bin/a/my_rule\n }\n \n+# Verifies that the contents of a directory have the same representation with\n+# remote execution regardless of whether they are added as a source directory or\n+# via globbing.\n+function test_source_directory() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+GENRULE_COMMAND = \"\"\"\n+[[ -f a/dir/file.txt ]] || { echo \"a/dir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/file.txt ]] || { echo \"a/dir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink_dir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink_dir ]] || { echo \"a/dir/symlink_dir is a symlink\"; exit 1; }\n+[[ ! -e a/dir/empty_dir ]] || { echo \"a/dir/empty_dir exists\"; exit 1; }\n+[[ ! -e a/dir/symlink_empty_dir ]] || { echo \"a/dir/symlink_empty_dir exists\"; exit 1; }\n+touch $@\n+\"\"\"\n+\n+genrule(\n+    name = \"gen_source_directory\",\n+    srcs = [\"dir\"],\n+    outs = [\"out1\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+\n+genrule(\n+    name = \"gen_glob\",\n+    srcs = glob([\"dir/**\"]),\n+    outs = [\"out2\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+EOF\n+  mkdir -p a/dir\n+  touch a/dir/file.txt\n+  ln -s file.txt a/dir/symlink.txt\n+  mkdir -p a/dir/subdir\n+  touch a/dir/subdir/file.txt\n+  ln -s subdir a/dir/symlink_dir\n+  mkdir a/dir/empty_dir\n+  ln -s empty_dir a/dir/symlink_empty_dir\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_source_directory >& $TEST_log || fail \"Failed to build //a:gen_source_directory\"\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_glob >& $TEST_log || fail \"Failed to build //a:gen_glob\"\n+}\n+\n+function test_source_directory_dangling_symlink() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+genrule(\n+    name = \"gen\",\n+    srcs = [\"dir\"],\n+    outs = [\"out\"],\n+    cmd = \"\"\"\n+touch $@\n+\"\"\",\n+)\n+EOF\n+  mkdir -p a/dir\n+  ln -s does_not_exist a/dir/symlink.txt\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen >& $TEST_log && fail \"build //a:gen should fail\"\n+  expect_log \"The file type of 'a/dir/symlink.txt' is not supported.\"\n+}",
        "comment_created_at": "2025-04-29T17:35:21+00:00",
        "comment_author": "fmeum",
        "comment_body": "I think that it would remain relevant, this failure originates in remote code and it's not so clear what to do with dangling symlinks in hashed directories. Or would you expect that to fail early in some other way?",
        "pr_file_module": null
      },
      {
        "comment_id": "2067055397",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25868,
        "pr_file": "src/test/shell/bazel/remote/remote_execution_test.sh",
        "discussion_id": "2066660308",
        "commented_code": "@@ -3766,4 +3766,77 @@ EOF\n   assert_contains \"input\" bazel-bin/a/my_rule\n }\n \n+# Verifies that the contents of a directory have the same representation with\n+# remote execution regardless of whether they are added as a source directory or\n+# via globbing.\n+function test_source_directory() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+GENRULE_COMMAND = \"\"\"\n+[[ -f a/dir/file.txt ]] || { echo \"a/dir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/file.txt ]] || { echo \"a/dir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink_dir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink_dir ]] || { echo \"a/dir/symlink_dir is a symlink\"; exit 1; }\n+[[ ! -e a/dir/empty_dir ]] || { echo \"a/dir/empty_dir exists\"; exit 1; }\n+[[ ! -e a/dir/symlink_empty_dir ]] || { echo \"a/dir/symlink_empty_dir exists\"; exit 1; }\n+touch $@\n+\"\"\"\n+\n+genrule(\n+    name = \"gen_source_directory\",\n+    srcs = [\"dir\"],\n+    outs = [\"out1\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+\n+genrule(\n+    name = \"gen_glob\",\n+    srcs = glob([\"dir/**\"]),\n+    outs = [\"out2\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+EOF\n+  mkdir -p a/dir\n+  touch a/dir/file.txt\n+  ln -s file.txt a/dir/symlink.txt\n+  mkdir -p a/dir/subdir\n+  touch a/dir/subdir/file.txt\n+  ln -s subdir a/dir/symlink_dir\n+  mkdir a/dir/empty_dir\n+  ln -s empty_dir a/dir/symlink_empty_dir\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_source_directory >& $TEST_log || fail \"Failed to build //a:gen_source_directory\"\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_glob >& $TEST_log || fail \"Failed to build //a:gen_glob\"\n+}\n+\n+function test_source_directory_dangling_symlink() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+genrule(\n+    name = \"gen\",\n+    srcs = [\"dir\"],\n+    outs = [\"out\"],\n+    cmd = \"\"\"\n+touch $@\n+\"\"\",\n+)\n+EOF\n+  mkdir -p a/dir\n+  ln -s does_not_exist a/dir/symlink.txt\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen >& $TEST_log && fail \"build //a:gen should fail\"\n+  expect_log \"The file type of 'a/dir/symlink.txt' is not supported.\"\n+}",
        "comment_created_at": "2025-04-29T17:50:02+00:00",
        "comment_author": "tjgq",
        "comment_body": "I'd expect it to fail when metadata is collected for the source directory, similarly to what happens when a source file is a dangling symlink.\r\n\r\nObviously that can't happen until we switch to hash-based metadata, but when we do, we should test it somewhere that applies to non-remote builds as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "2067176800",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25868,
        "pr_file": "src/test/shell/bazel/remote/remote_execution_test.sh",
        "discussion_id": "2066660308",
        "commented_code": "@@ -3766,4 +3766,77 @@ EOF\n   assert_contains \"input\" bazel-bin/a/my_rule\n }\n \n+# Verifies that the contents of a directory have the same representation with\n+# remote execution regardless of whether they are added as a source directory or\n+# via globbing.\n+function test_source_directory() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+GENRULE_COMMAND = \"\"\"\n+[[ -f a/dir/file.txt ]] || { echo \"a/dir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/file.txt ]] || { echo \"a/dir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/subdir/file.txt ]] || { echo \"a/dir/subdir/file.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink.txt ]] || { echo \"a/dir/symlink.txt is a symlink\"; exit 1; }\n+[[ -f a/dir/symlink_dir/file.txt ]] || { echo \"a/dir/subdir/file.txt is not a file\"; exit 1; }\n+[[ ! -L a/dir/symlink_dir ]] || { echo \"a/dir/symlink_dir is a symlink\"; exit 1; }\n+[[ ! -e a/dir/empty_dir ]] || { echo \"a/dir/empty_dir exists\"; exit 1; }\n+[[ ! -e a/dir/symlink_empty_dir ]] || { echo \"a/dir/symlink_empty_dir exists\"; exit 1; }\n+touch $@\n+\"\"\"\n+\n+genrule(\n+    name = \"gen_source_directory\",\n+    srcs = [\"dir\"],\n+    outs = [\"out1\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+\n+genrule(\n+    name = \"gen_glob\",\n+    srcs = glob([\"dir/**\"]),\n+    outs = [\"out2\"],\n+    cmd = GENRULE_COMMAND,\n+)\n+EOF\n+  mkdir -p a/dir\n+  touch a/dir/file.txt\n+  ln -s file.txt a/dir/symlink.txt\n+  mkdir -p a/dir/subdir\n+  touch a/dir/subdir/file.txt\n+  ln -s subdir a/dir/symlink_dir\n+  mkdir a/dir/empty_dir\n+  ln -s empty_dir a/dir/symlink_empty_dir\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_source_directory >& $TEST_log || fail \"Failed to build //a:gen_source_directory\"\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen_glob >& $TEST_log || fail \"Failed to build //a:gen_glob\"\n+}\n+\n+function test_source_directory_dangling_symlink() {\n+  mkdir -p a\n+  cat > a/BUILD <<'EOF'\n+genrule(\n+    name = \"gen\",\n+    srcs = [\"dir\"],\n+    outs = [\"out\"],\n+    cmd = \"\"\"\n+touch $@\n+\"\"\",\n+)\n+EOF\n+  mkdir -p a/dir\n+  ln -s does_not_exist a/dir/symlink.txt\n+\n+  bazel build \\\n+    --remote_executor=grpc://localhost:${worker_port} \\\n+    //a:gen >& $TEST_log && fail \"build //a:gen should fail\"\n+  expect_log \"The file type of 'a/dir/symlink.txt' is not supported.\"\n+}",
        "comment_created_at": "2025-04-29T19:12:08+00:00",
        "comment_author": "fmeum",
        "comment_body": "Added a comment",
        "pr_file_module": null
      }
    ]
  }
]