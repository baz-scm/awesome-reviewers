[
  {
    "discussion_id": "2099067716",
    "pr_number": 26092,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
    "created_at": "2025-05-21T00:14:58+00:00",
    "commented_code": "+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2099067716",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26092,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
        "discussion_id": "2099067716",
        "commented_code": "@@ -0,0 +1,278 @@\n+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(",
        "comment_created_at": "2025-05-21T00:14:58+00:00",
        "comment_author": "Wyverald",
        "comment_body": "any reason to use `invokeAny` over just `submit(...).get(...)`? There's only ever one task here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2099471703",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26092,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
        "discussion_id": "2099067716",
        "commented_code": "@@ -0,0 +1,278 @@\n+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(",
        "comment_created_at": "2025-05-21T06:36:10+00:00",
        "comment_author": "jmillikin",
        "comment_body": "The original version of this code used `submit(); get()`, and it was changed to the current syntax by reviewer request.\r\n\r\nI have no strong preference about how to use this API, and would be fine with changing the code back if that's the Bazel team's preference.",
        "pr_file_module": null
      },
      {
        "comment_id": "2099708896",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26092,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
        "discussion_id": "2099067716",
        "commented_code": "@@ -0,0 +1,278 @@\n+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(",
        "comment_created_at": "2025-05-21T08:37:24+00:00",
        "comment_author": "fmeum",
        "comment_body": "@Wyverald I suggested this and am okay with it being changed back if you prefer that.\r\n\r\nTo me, Futures are a low-level primitive that's best avoided if a more high-level, structured alternative exists. `invokeAny`'s behavior regarding cancellation is pretty much determined by its type signature (it returns a bare value), which helps readability and avoids misuse. For example, a Future would need to be cancelled manually when `get` times out.",
        "pr_file_module": null
      },
      {
        "comment_id": "2100616710",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26092,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
        "discussion_id": "2099067716",
        "commented_code": "@@ -0,0 +1,278 @@\n+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(",
        "comment_created_at": "2025-05-21T15:41:39+00:00",
        "comment_author": "Wyverald",
        "comment_body": "ah ok, that's interesting. I wasn't aware of this idiom. I'm ok with leaving it as is, although note that you also don't need to cancel the future manually; a shutdownNow() on the executor service would suffice.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1928186045",
    "pr_number": 24305,
    "pr_file": "src/main/java/com/google/devtools/build/lib/query2/query/output/StreamedProtoOutputFormatter.java",
    "created_at": "2025-01-24T07:07:17+00:00",
    "commented_code": "public OutputFormatterCallback<Target> createPostFactoStreamCallback(\n       final OutputStream out, final QueryOptions options, LabelPrinter labelPrinter) {\n     return new OutputFormatterCallback<Target>() {\n+      private static final int MAX_CHUNKS_IN_QUEUE = Runtime.getRuntime().availableProcessors() * 2;\n+      private static final int TARGETS_PER_CHUNK = 500;\n+\n+      private final LabelPrinter ourLabelPrinter = labelPrinter;\n+\n       @Override\n       public void processOutput(Iterable<Target> partialResult)\n           throws IOException, InterruptedException {\n-        for (Target target : partialResult) {\n-          toTargetProtoBuffer(target, labelPrinter).writeDelimitedTo(out);\n+        ForkJoinTask<?> writeAllTargetsFuture;\n+        try (ForkJoinPool executor =\n+            new ForkJoinPool(\n+                Runtime.getRuntime().availableProcessors(),\n+                ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n+                null,\n+                // we use asyncMode to ensure the queue is processed FIFO, which maximizes\n+                // throughput\n+                true)) {\n+          var targetQueue = new LinkedBlockingQueue<Future<List<byte[]>>>(MAX_CHUNKS_IN_QUEUE);\n+          var stillAddingTargetsToQueue = new AtomicBoolean(true);\n+          writeAllTargetsFuture =\n+              executor.submit(\n+                  () -> {\n+                    try {\n+                      while (stillAddingTargetsToQueue.get() || !targetQueue.isEmpty()) {\n+                        Future<List<byte[]>> targets = targetQueue.take();\n+                        for (byte[] target : targets.get()) {\n+                          out.write(target);\n+                        }\n+                      }\n+                    } catch (InterruptedException e) {\n+                      throw new WrappedInterruptedException(e);\n+                    } catch (IOException e) {\n+                      throw new WrappedIOException(e);\n+                    } catch (ExecutionException e) {\n+                      // TODO: figure out what might be in here and propagate\n+                      throw new RuntimeException(e);\n+                    }\n+                  });\n+          try {\n+            for (List<Target> targets : Iterables.partition(partialResult, TARGETS_PER_CHUNK)) {\n+              targetQueue.put(executor.submit(() -> writeTargetsDelimitedToByteArrays(targets)));\n+            }\n+          } finally {\n+            stillAddingTargetsToQueue.set(false);\n+          }\n+        }\n+        try {\n+          writeAllTargetsFuture.get();",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1928186045",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24305,
        "pr_file": "src/main/java/com/google/devtools/build/lib/query2/query/output/StreamedProtoOutputFormatter.java",
        "discussion_id": "1928186045",
        "commented_code": "@@ -34,13 +42,107 @@ public String getName() {\n   public OutputFormatterCallback<Target> createPostFactoStreamCallback(\n       final OutputStream out, final QueryOptions options, LabelPrinter labelPrinter) {\n     return new OutputFormatterCallback<Target>() {\n+      private static final int MAX_CHUNKS_IN_QUEUE = Runtime.getRuntime().availableProcessors() * 2;\n+      private static final int TARGETS_PER_CHUNK = 500;\n+\n+      private final LabelPrinter ourLabelPrinter = labelPrinter;\n+\n       @Override\n       public void processOutput(Iterable<Target> partialResult)\n           throws IOException, InterruptedException {\n-        for (Target target : partialResult) {\n-          toTargetProtoBuffer(target, labelPrinter).writeDelimitedTo(out);\n+        ForkJoinTask<?> writeAllTargetsFuture;\n+        try (ForkJoinPool executor =\n+            new ForkJoinPool(\n+                Runtime.getRuntime().availableProcessors(),\n+                ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n+                null,\n+                // we use asyncMode to ensure the queue is processed FIFO, which maximizes\n+                // throughput\n+                true)) {\n+          var targetQueue = new LinkedBlockingQueue<Future<List<byte[]>>>(MAX_CHUNKS_IN_QUEUE);\n+          var stillAddingTargetsToQueue = new AtomicBoolean(true);\n+          writeAllTargetsFuture =\n+              executor.submit(\n+                  () -> {\n+                    try {\n+                      while (stillAddingTargetsToQueue.get() || !targetQueue.isEmpty()) {\n+                        Future<List<byte[]>> targets = targetQueue.take();\n+                        for (byte[] target : targets.get()) {\n+                          out.write(target);\n+                        }\n+                      }\n+                    } catch (InterruptedException e) {\n+                      throw new WrappedInterruptedException(e);\n+                    } catch (IOException e) {\n+                      throw new WrappedIOException(e);\n+                    } catch (ExecutionException e) {\n+                      // TODO: figure out what might be in here and propagate\n+                      throw new RuntimeException(e);\n+                    }\n+                  });\n+          try {\n+            for (List<Target> targets : Iterables.partition(partialResult, TARGETS_PER_CHUNK)) {\n+              targetQueue.put(executor.submit(() -> writeTargetsDelimitedToByteArrays(targets)));\n+            }\n+          } finally {\n+            stillAddingTargetsToQueue.set(false);\n+          }\n+        }\n+        try {\n+          writeAllTargetsFuture.get();",
        "comment_created_at": "2025-01-24T07:07:17+00:00",
        "comment_author": "mattlwilliams",
        "comment_body": "I think this needs to be inside the try-with-resources block or the executor forkjoinpool may be shutdown. I observed java.lang.InterruptedExceptions when querying with skyquery (--output=streamed_proto --order_output=no --universe_scope=//...)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1576967891",
    "pr_number": 22100,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
    "created_at": "2024-04-23T22:14:37+00:00",
    "commented_code": "myWorkerFuture.cancel(true);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1576967891",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-23T22:14:37+00:00",
        "comment_author": "Wyverald",
        "comment_body": "one thing I don't quite understand here: I tried to replace this method body with\r\n\r\n```java\r\nworkerFuture = null;\r\nworkerExecutorService.shutdownNow();\r\n```\r\n\r\nPer the [Javadoc of `shutdownNow`](https://docs.oracle.com/en%2Fjava%2Fjavase%2F21%2Fdocs%2Fapi%2F%2F/java.base/java/util/concurrent/ExecutorService.html#shutdownNow()), this should have the same effect as the previous code, but for some reason using `shutdownNow()` here consistently causes the later call to `workerExecutorService.close()` on line 108 to block forever. This seems rather surprising, but I have no idea whether this is a bug in JRE or I'm holding it wrong, so I just reverted to the previous implementation.\r\n\r\nIf anyone has an idea what's happening here, please share.",
        "pr_file_module": null
      },
      {
        "comment_id": "1577527729",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-24T08:47:45+00:00",
        "comment_author": "fmeum",
        "comment_body": "I read a bit of JDK code and the only difference I could find is that `myWorkerFuture.cancel(true)` ensures that the `Future` both has its carrying thread interrupted *and* has its `done()` method called, which signals the `ExecutorService` that it is done. `workerExecutorService.shutdownNow()` instead seems to just interrupt the carrying threads and then waits for that to result in the `Future`s signalling that they are done. This could be a sign that something is still swallowing `InterruptedException`s in the worker threads.",
        "pr_file_module": null
      },
      {
        "comment_id": "1577628669",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-24T10:01:05+00:00",
        "comment_author": "lberki",
        "comment_body": "While the Skyframe thread is blocking on line 108, what is the worker virtual thread doing? (jstack should be able to tell) Maybe blocking on `signalQueue.put()`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1577736073",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-24T11:35:05+00:00",
        "comment_author": "coeuvre",
        "comment_body": "You want to use `jcmd ${pid} Thread.dump_to_file ${out_file}` to capture virtual thread stacks.",
        "pr_file_module": null
      },
      {
        "comment_id": "1578330197",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-24T18:19:38+00:00",
        "comment_author": "Wyverald",
        "comment_body": "It is indeed stuck in `signalQueue.put()`! Thanks @coeuvre for the tip -- `jstack` actually doesn't capture parked virtual thread stacks, so I had no idea it was actually running.\r\n\r\nI still don't quite understand why it's stuck there, though -- `SynchronousQueue#put` _does_ check interrupted status. \r\n\r\n> `workerExecutorService.shutdownNow()` instead seems to just interrupt the carrying threads and then waits for that to result in the `Future`s signalling that they are done.\r\n\r\n[this line](https://github.com/openjdk/jdk21/blob/890adb6410dab4606a4f26a942aed02fb2f55387/src/java.base/share/classes/java/util/concurrent/ThreadPerTaskExecutor.java#L136) seems to indicate that it's interrupting the virtual threads, not the carrying threads. Or I'm reading it wrong. :)",
        "pr_file_module": null
      },
      {
        "comment_id": "1578341285",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-24T18:29:24+00:00",
        "comment_author": "fmeum",
        "comment_body": "Yes, this wasn't clear on my part, I meant the (virtual) thread \"carrying\" the `Future`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1579020273",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-25T07:37:13+00:00",
        "comment_author": "lberki",
        "comment_body": "If you allow me to nitpick a bit, how could one interrupt a carrier thread? My understanding is that carrier threads are OS-level functionality that's not surfaced in Java (you don't get a `Thread` object to represent the carrier thread, do you?) and interrupts are Java-level functionality which doesn't have an equivalent in the OS.",
        "pr_file_module": null
      },
      {
        "comment_id": "1579547612",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1576967891",
        "commented_code": "@@ -92,4 +102,12 @@ public void close() {\n       myWorkerFuture.cancel(true);",
        "comment_created_at": "2024-04-25T14:09:31+00:00",
        "comment_author": "Wyverald",
        "comment_body": "No? Carrier threads are Java threads. Virtual threads are entirely implemented in the JRE, AFAIK, not OS-level functionality. There's even a `VirtualThread#carrierThread` field (https://github.com/openjdk/jdk21/blob/890adb6410dab4606a4f26a942aed02fb2f55387/src/java.base/share/classes/java/lang/VirtualThread.java#L131).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1587212853",
    "pr_number": 22100,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
    "created_at": "2024-05-02T07:51:09+00:00",
    "commented_code": "*/\n   final Map<RepoRecordedInput, String> recordedInputValues = new TreeMap<>();\n \n+  RepoFetchingSkyKeyComputeState(String repoName) {\n+    this.repoName = repoName;\n+    reset();\n+  }\n+\n+  // This may only be called from the host Skyframe thread, *and* only when no worker thread is\n+  // running.\n+  private void reset() {\n+    workerExecutorService =\n+        MoreExecutors.listeningDecorator(\n+            Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"starlark-repository-\" + repoName).factory()));\n+    signalSemaphore.drainPermits();\n+    delegateEnvQueue.clear();\n+    recordedInputValues.clear();\n+  }\n+\n+  /**\n+   * Releases a permit on the {@code signalSemaphore} and immediately expect a fresh Environment\n+   * back. This may only be called from the worker thread.\n+   */\n   SkyFunction.Environment signalForFreshEnv() throws InterruptedException {\n-    signalQueue.put(Signal.RESTART);\n+    signalSemaphore.release();\n     return delegateEnvQueue.take();\n   }\n \n+  /**\n+   * Starts a worker thread running the given callable. This sets the {@code workerFuture} field,\n+   * and makes sure to release a permit on the {@code signalSemaphore} when the worker finishes,\n+   * successfully or otherwise. Returns the worker future. This may only be called from the host\n+   * Skyframe thread.\n+   */\n+  ListenableFuture<RepositoryDirectoryValue.Builder> startWorker(\n+      Callable<RepositoryDirectoryValue.Builder> c) {\n+    var workerFuture = workerExecutorService.submit(c);\n+    this.workerFuture = workerFuture;\n+    workerFuture.addListener(signalSemaphore::release, directExecutor());\n+    return workerFuture;\n+  }\n+\n+  // This may be called from any thread, including the host Skyframe thread and the\n+  // high-memory-pressure listener thread.\n   @Override\n   public void close() {\n     var myWorkerFuture = workerFuture;",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1587212853",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1587212853",
        "commented_code": "@@ -79,11 +87,48 @@ enum Signal {\n    */\n   final Map<RepoRecordedInput, String> recordedInputValues = new TreeMap<>();\n \n+  RepoFetchingSkyKeyComputeState(String repoName) {\n+    this.repoName = repoName;\n+    reset();\n+  }\n+\n+  // This may only be called from the host Skyframe thread, *and* only when no worker thread is\n+  // running.\n+  private void reset() {\n+    workerExecutorService =\n+        MoreExecutors.listeningDecorator(\n+            Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"starlark-repository-\" + repoName).factory()));\n+    signalSemaphore.drainPermits();\n+    delegateEnvQueue.clear();\n+    recordedInputValues.clear();\n+  }\n+\n+  /**\n+   * Releases a permit on the {@code signalSemaphore} and immediately expect a fresh Environment\n+   * back. This may only be called from the worker thread.\n+   */\n   SkyFunction.Environment signalForFreshEnv() throws InterruptedException {\n-    signalQueue.put(Signal.RESTART);\n+    signalSemaphore.release();\n     return delegateEnvQueue.take();\n   }\n \n+  /**\n+   * Starts a worker thread running the given callable. This sets the {@code workerFuture} field,\n+   * and makes sure to release a permit on the {@code signalSemaphore} when the worker finishes,\n+   * successfully or otherwise. Returns the worker future. This may only be called from the host\n+   * Skyframe thread.\n+   */\n+  ListenableFuture<RepositoryDirectoryValue.Builder> startWorker(\n+      Callable<RepositoryDirectoryValue.Builder> c) {\n+    var workerFuture = workerExecutorService.submit(c);\n+    this.workerFuture = workerFuture;\n+    workerFuture.addListener(signalSemaphore::release, directExecutor());\n+    return workerFuture;\n+  }\n+\n+  // This may be called from any thread, including the host Skyframe thread and the\n+  // high-memory-pressure listener thread.\n   @Override\n   public void close() {\n     var myWorkerFuture = workerFuture;",
        "comment_created_at": "2024-05-02T07:51:09+00:00",
        "comment_author": "lberki",
        "comment_body": "This doesn't wait for the worker thread to terminate. Isn't this susceptible to the issue I mentioned a few days ago where such an \"orphaned\" worker thread can modify the file system at an unexpected moment, e.g. *after* the repository gets another associated worker thread, thus putting the file system in an inconsistent state?",
        "pr_file_module": null
      },
      {
        "comment_id": "1588133578",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1587212853",
        "commented_code": "@@ -79,11 +87,48 @@ enum Signal {\n    */\n   final Map<RepoRecordedInput, String> recordedInputValues = new TreeMap<>();\n \n+  RepoFetchingSkyKeyComputeState(String repoName) {\n+    this.repoName = repoName;\n+    reset();\n+  }\n+\n+  // This may only be called from the host Skyframe thread, *and* only when no worker thread is\n+  // running.\n+  private void reset() {\n+    workerExecutorService =\n+        MoreExecutors.listeningDecorator(\n+            Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"starlark-repository-\" + repoName).factory()));\n+    signalSemaphore.drainPermits();\n+    delegateEnvQueue.clear();\n+    recordedInputValues.clear();\n+  }\n+\n+  /**\n+   * Releases a permit on the {@code signalSemaphore} and immediately expect a fresh Environment\n+   * back. This may only be called from the worker thread.\n+   */\n   SkyFunction.Environment signalForFreshEnv() throws InterruptedException {\n-    signalQueue.put(Signal.RESTART);\n+    signalSemaphore.release();\n     return delegateEnvQueue.take();\n   }\n \n+  /**\n+   * Starts a worker thread running the given callable. This sets the {@code workerFuture} field,\n+   * and makes sure to release a permit on the {@code signalSemaphore} when the worker finishes,\n+   * successfully or otherwise. Returns the worker future. This may only be called from the host\n+   * Skyframe thread.\n+   */\n+  ListenableFuture<RepositoryDirectoryValue.Builder> startWorker(\n+      Callable<RepositoryDirectoryValue.Builder> c) {\n+    var workerFuture = workerExecutorService.submit(c);\n+    this.workerFuture = workerFuture;\n+    workerFuture.addListener(signalSemaphore::release, directExecutor());\n+    return workerFuture;\n+  }\n+\n+  // This may be called from any thread, including the host Skyframe thread and the\n+  // high-memory-pressure listener thread.\n   @Override\n   public void close() {\n     var myWorkerFuture = workerFuture;",
        "comment_created_at": "2024-05-02T18:34:56+00:00",
        "comment_author": "Wyverald",
        "comment_body": "if the worker thread gets 'orphaned' while the host Skyframe thread is active, then the host would call `state.closeAndWaitForTermination()`, ensuring the worker thread is joined. But if it gets 'orphaned' when the host Skyframe thread is _inactive_ (ie. having returned `null` but not yet restarted), then you're right the worker thread would live on for an indefinite amount of time.\r\n\r\nI added a clause to guard against that specific case (so when the Skyframe thread becomes active again, the first thing it does is to join the worker thread).\r\n\r\nAlso added a TODO to reconsider the ban on blocking work in `close()`...",
        "pr_file_module": null
      },
      {
        "comment_id": "1588268869",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1587212853",
        "commented_code": "@@ -79,11 +87,48 @@ enum Signal {\n    */\n   final Map<RepoRecordedInput, String> recordedInputValues = new TreeMap<>();\n \n+  RepoFetchingSkyKeyComputeState(String repoName) {\n+    this.repoName = repoName;\n+    reset();\n+  }\n+\n+  // This may only be called from the host Skyframe thread, *and* only when no worker thread is\n+  // running.\n+  private void reset() {\n+    workerExecutorService =\n+        MoreExecutors.listeningDecorator(\n+            Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"starlark-repository-\" + repoName).factory()));\n+    signalSemaphore.drainPermits();\n+    delegateEnvQueue.clear();\n+    recordedInputValues.clear();\n+  }\n+\n+  /**\n+   * Releases a permit on the {@code signalSemaphore} and immediately expect a fresh Environment\n+   * back. This may only be called from the worker thread.\n+   */\n   SkyFunction.Environment signalForFreshEnv() throws InterruptedException {\n-    signalQueue.put(Signal.RESTART);\n+    signalSemaphore.release();\n     return delegateEnvQueue.take();\n   }\n \n+  /**\n+   * Starts a worker thread running the given callable. This sets the {@code workerFuture} field,\n+   * and makes sure to release a permit on the {@code signalSemaphore} when the worker finishes,\n+   * successfully or otherwise. Returns the worker future. This may only be called from the host\n+   * Skyframe thread.\n+   */\n+  ListenableFuture<RepositoryDirectoryValue.Builder> startWorker(\n+      Callable<RepositoryDirectoryValue.Builder> c) {\n+    var workerFuture = workerExecutorService.submit(c);\n+    this.workerFuture = workerFuture;\n+    workerFuture.addListener(signalSemaphore::release, directExecutor());\n+    return workerFuture;\n+  }\n+\n+  // This may be called from any thread, including the host Skyframe thread and the\n+  // high-memory-pressure listener thread.\n   @Override\n   public void close() {\n     var myWorkerFuture = workerFuture;",
        "comment_created_at": "2024-05-02T19:45:53+00:00",
        "comment_author": "lberki",
        "comment_body": "My $.02: can we not have another complicated dance? The documentation of `close()` doesn't say *why* it shouldn't perform any blocking operations and it looks silly that a stray thread is preferred to blocking a bit.\r\n\r\nI'd much rather not have to think about what happens in odd cases likewhen the Skyframe evaluation is stopped due to an independent error (or a SIGINT) before the worker thread quits and another Bazel command is issued right after that, etc.",
        "pr_file_module": null
      },
      {
        "comment_id": "1588286217",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1587212853",
        "commented_code": "@@ -79,11 +87,48 @@ enum Signal {\n    */\n   final Map<RepoRecordedInput, String> recordedInputValues = new TreeMap<>();\n \n+  RepoFetchingSkyKeyComputeState(String repoName) {\n+    this.repoName = repoName;\n+    reset();\n+  }\n+\n+  // This may only be called from the host Skyframe thread, *and* only when no worker thread is\n+  // running.\n+  private void reset() {\n+    workerExecutorService =\n+        MoreExecutors.listeningDecorator(\n+            Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"starlark-repository-\" + repoName).factory()));\n+    signalSemaphore.drainPermits();\n+    delegateEnvQueue.clear();\n+    recordedInputValues.clear();\n+  }\n+\n+  /**\n+   * Releases a permit on the {@code signalSemaphore} and immediately expect a fresh Environment\n+   * back. This may only be called from the worker thread.\n+   */\n   SkyFunction.Environment signalForFreshEnv() throws InterruptedException {\n-    signalQueue.put(Signal.RESTART);\n+    signalSemaphore.release();\n     return delegateEnvQueue.take();\n   }\n \n+  /**\n+   * Starts a worker thread running the given callable. This sets the {@code workerFuture} field,\n+   * and makes sure to release a permit on the {@code signalSemaphore} when the worker finishes,\n+   * successfully or otherwise. Returns the worker future. This may only be called from the host\n+   * Skyframe thread.\n+   */\n+  ListenableFuture<RepositoryDirectoryValue.Builder> startWorker(\n+      Callable<RepositoryDirectoryValue.Builder> c) {\n+    var workerFuture = workerExecutorService.submit(c);\n+    this.workerFuture = workerFuture;\n+    workerFuture.addListener(signalSemaphore::release, directExecutor());\n+    return workerFuture;\n+  }\n+\n+  // This may be called from any thread, including the host Skyframe thread and the\n+  // high-memory-pressure listener thread.\n   @Override\n   public void close() {\n     var myWorkerFuture = workerFuture;",
        "comment_created_at": "2024-05-02T20:03:07+00:00",
        "comment_author": "Wyverald",
        "comment_body": "> The documentation of close() doesn't say why it shouldn't perform any blocking operations\r\n\r\nPresumably because it can be called from any thread. It's a bit scary to perform arbitrary blocking operations in random threads. If we want to reverse the decision, I'd rather get the Core team's input, and I suggest that we do this in a follow-up instead of right away in this PR, which is getting a bit big.",
        "pr_file_module": null
      },
      {
        "comment_id": "1588778869",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22100,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/RepoFetchingSkyKeyComputeState.java",
        "discussion_id": "1587212853",
        "commented_code": "@@ -79,11 +87,48 @@ enum Signal {\n    */\n   final Map<RepoRecordedInput, String> recordedInputValues = new TreeMap<>();\n \n+  RepoFetchingSkyKeyComputeState(String repoName) {\n+    this.repoName = repoName;\n+    reset();\n+  }\n+\n+  // This may only be called from the host Skyframe thread, *and* only when no worker thread is\n+  // running.\n+  private void reset() {\n+    workerExecutorService =\n+        MoreExecutors.listeningDecorator(\n+            Executors.newThreadPerTaskExecutor(\n+                Thread.ofVirtual().name(\"starlark-repository-\" + repoName).factory()));\n+    signalSemaphore.drainPermits();\n+    delegateEnvQueue.clear();\n+    recordedInputValues.clear();\n+  }\n+\n+  /**\n+   * Releases a permit on the {@code signalSemaphore} and immediately expect a fresh Environment\n+   * back. This may only be called from the worker thread.\n+   */\n   SkyFunction.Environment signalForFreshEnv() throws InterruptedException {\n-    signalQueue.put(Signal.RESTART);\n+    signalSemaphore.release();\n     return delegateEnvQueue.take();\n   }\n \n+  /**\n+   * Starts a worker thread running the given callable. This sets the {@code workerFuture} field,\n+   * and makes sure to release a permit on the {@code signalSemaphore} when the worker finishes,\n+   * successfully or otherwise. Returns the worker future. This may only be called from the host\n+   * Skyframe thread.\n+   */\n+  ListenableFuture<RepositoryDirectoryValue.Builder> startWorker(\n+      Callable<RepositoryDirectoryValue.Builder> c) {\n+    var workerFuture = workerExecutorService.submit(c);\n+    this.workerFuture = workerFuture;\n+    workerFuture.addListener(signalSemaphore::release, directExecutor());\n+    return workerFuture;\n+  }\n+\n+  // This may be called from any thread, including the host Skyframe thread and the\n+  // high-memory-pressure listener thread.\n   @Override\n   public void close() {\n     var myWorkerFuture = workerFuture;",
        "comment_created_at": "2024-05-03T06:12:24+00:00",
        "comment_author": "lberki",
        "comment_body": "Well, but at the same time, it's pretty scary to have orphaned threads doing I/O. But then again, that's arguably not for this pull request; you do cancel the future, which is supposed to kill off the now-orphan thread very quickly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1795976474",
    "pr_number": 23837,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
    "created_at": "2024-10-10T19:26:04+00:00",
    "commented_code": "eventHandler,\n                 clientEnv,\n                 context);\n+          } finally {\n+            doneSignal.countDown();",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1795976474",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
        "discussion_id": "1795976474",
        "commented_code": "@@ -138,6 +140,8 @@ public Future<Path> startDownload(\n                 eventHandler,\n                 clientEnv,\n                 context);\n+          } finally {\n+            doneSignal.countDown();",
        "comment_created_at": "2024-10-10T19:26:04+00:00",
        "comment_author": "Wyverald",
        "comment_body": "this could lead to a deadlock if the future is never scheduled before being canceled (that is, after `submit()` is called and returns, but before the Callable gets called).\r\n\r\n`WorkerSkyKeyComputeState` works around this by using a `ListeningExecutorService` and using `addListener` on the returned Future (https://cs.opensource.google/bazel/bazel/+/master:src/main/java/com/google/devtools/build/skyframe/WorkerSkyKeyComputeState.java;drc=23e5ec157d582585bb9635b5c374ec21cc50b4ea;l=173). let's do the same here",
        "pr_file_module": null
      },
      {
        "comment_id": "1796666745",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
        "discussion_id": "1795976474",
        "commented_code": "@@ -138,6 +140,8 @@ public Future<Path> startDownload(\n                 eventHandler,\n                 clientEnv,\n                 context);\n+          } finally {\n+            doneSignal.countDown();",
        "comment_created_at": "2024-10-11T09:09:17+00:00",
        "comment_author": "moroten",
        "comment_body": "That is a good point, but I verified, by both code inspection and empirically, that the `Future.addListener` also triggers its runnable too early. Therefore, I had to add a semaphore to get the ordering right, which my small scale experiment confirms work. (Well, I could not trigger the case where the task never starts, but the bug this is aimed to solve is gone.)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1796879861",
    "pr_number": 23837,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
    "created_at": "2024-10-11T12:22:24+00:00",
    "commented_code": "Path output,\n       ExtendedEventHandler eventHandler,\n       Map<String, String> clientEnv,\n-      String context) {\n-    return executorService.submit(\n+      String context,\n+      CountDownLatch doneSignal) {\n+    Semaphore doneSignaller = new Semaphore(1);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1796879861",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
        "discussion_id": "1796879861",
        "commented_code": "@@ -123,9 +128,14 @@ public Future<Path> startDownload(\n       Path output,\n       ExtendedEventHandler eventHandler,\n       Map<String, String> clientEnv,\n-      String context) {\n-    return executorService.submit(\n+      String context,\n+      CountDownLatch doneSignal) {\n+    Semaphore doneSignaller = new Semaphore(1);",
        "comment_created_at": "2024-10-11T12:22:24+00:00",
        "comment_author": "fmeum",
        "comment_body": "Instead of combining a semaphore and a latch, maybe we could use a single shared `Phaser` instead? A download can `register` at the start of the lambda and `arriveAndDeregister` in the `finally` block. Then `close` can wait on `arriveAndAwaitAdvance`. You can search for `Phaser` in the codebase to find another very similar usage.",
        "pr_file_module": null
      },
      {
        "comment_id": "1796978645",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
        "discussion_id": "1796879861",
        "commented_code": "@@ -123,9 +128,14 @@ public Future<Path> startDownload(\n       Path output,\n       ExtendedEventHandler eventHandler,\n       Map<String, String> clientEnv,\n-      String context) {\n-    return executorService.submit(\n+      String context,\n+      CountDownLatch doneSignal) {\n+    Semaphore doneSignaller = new Semaphore(1);",
        "comment_created_at": "2024-10-11T13:42:15+00:00",
        "comment_author": "moroten",
        "comment_body": "I don't see how to implement it using `Phaser`. We need three phases: Init (0), started (1) and done (2). Calling `awaitAdvance(1)` to wait for the done phase is not possible while in the init phase. @fmeum What is your idea?",
        "pr_file_module": null
      },
      {
        "comment_id": "1797002634",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
        "discussion_id": "1796879861",
        "commented_code": "@@ -123,9 +128,14 @@ public Future<Path> startDownload(\n       Path output,\n       ExtendedEventHandler eventHandler,\n       Map<String, String> clientEnv,\n-      String context) {\n-    return executorService.submit(\n+      String context,\n+      CountDownLatch doneSignal) {\n+    Semaphore doneSignaller = new Semaphore(1);",
        "comment_created_at": "2024-10-11T13:58:58+00:00",
        "comment_author": "fmeum",
        "comment_body": "I may very well be missing something, but why do we need to track the `init` phase at all with a `Phaser`? If the task has never been scheduled by the executor, we also don't need to cancel it. If it has started, it will either have registered with the `Phaser` (and will thus be awaited with `awaitAndAdvance`) or not since it hasn't even reached the `register` call (you can check the return value to avoid registrations happening after the advance).\n\nJust to clarify: With the `Phaser` approach, `addListener` also shouldn't be needed.",
        "pr_file_module": null
      },
      {
        "comment_id": "1797462642",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
        "discussion_id": "1796879861",
        "commented_code": "@@ -123,9 +128,14 @@ public Future<Path> startDownload(\n       Path output,\n       ExtendedEventHandler eventHandler,\n       Map<String, String> clientEnv,\n-      String context) {\n-    return executorService.submit(\n+      String context,\n+      CountDownLatch doneSignal) {\n+    Semaphore doneSignaller = new Semaphore(1);",
        "comment_created_at": "2024-10-11T22:13:28+00:00",
        "comment_author": "moroten",
        "comment_body": "Updated with `Phaser`, which is much better. Check the diff for the [two last commits together](https://github.com/bazelbuild/bazel/pull/23837/files/3b214852ac3a6ccf18b679dcfceb3e215efb5b26..8949c9898141542090724e244a4757d22f08faf8). Tested on my small reproduction but not in production.",
        "pr_file_module": null
      },
      {
        "comment_id": "1797633565",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/downloader/DownloadManager.java",
        "discussion_id": "1796879861",
        "commented_code": "@@ -123,9 +128,14 @@ public Future<Path> startDownload(\n       Path output,\n       ExtendedEventHandler eventHandler,\n       Map<String, String> clientEnv,\n-      String context) {\n-    return executorService.submit(\n+      String context,\n+      CountDownLatch doneSignal) {\n+    Semaphore doneSignaller = new Semaphore(1);",
        "comment_created_at": "2024-10-12T08:29:32+00:00",
        "comment_author": "fmeum",
        "comment_body": "I think that we could even use a single `Phaser` per context, see https://github.com/fmeum/bazel/tree/23837-phaser. It doesn't give use the opportunity the log the time taken to wait for a particular download cancellation though.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797633896",
    "pr_number": 23837,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkBaseExternalContext.java",
    "created_at": "2024-10-12T08:31:48+00:00",
    "commented_code": "return !future.cancel(true);\n     }\n \n+    @Override\n+    public void close() {\n+      // Call register() to ensure arriveAndDeregister() will terminate the\n+      // downloadPhaser if the download has not started yet.\n+      if (downloadPhaser.register() < 0) {\n+        // The download completed normally or has already been cancelled and the thread has\n+        // terminated in response to the interrupt.\n+        return;\n+      }\n+      try (SilentCloseable c =\n+          Profiler.instance().profile(\"Cancelling download \" + outputPath)) {\n+        downloadPhaser.awaitAdvance(downloadPhaser.arriveAndDeregister());",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1797633896",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkBaseExternalContext.java",
        "discussion_id": "1797633896",
        "commented_code": "@@ -553,6 +574,21 @@ public boolean cancel() {\n       return !future.cancel(true);\n     }\n \n+    @Override\n+    public void close() {\n+      // Call register() to ensure arriveAndDeregister() will terminate the\n+      // downloadPhaser if the download has not started yet.\n+      if (downloadPhaser.register() < 0) {\n+        // The download completed normally or has already been cancelled and the thread has\n+        // terminated in response to the interrupt.\n+        return;\n+      }\n+      try (SilentCloseable c =\n+          Profiler.instance().profile(\"Cancelling download \" + outputPath)) {\n+        downloadPhaser.awaitAdvance(downloadPhaser.arriveAndDeregister());",
        "comment_created_at": "2024-10-12T08:31:48+00:00",
        "comment_author": "fmeum",
        "comment_body": "```suggestion\r\n        downloadPhaser.arriveAndAwaitAdvance();\r\n```\r\nshould suffice as we don't care about deregistering (there won't be another phase).",
        "pr_file_module": null
      },
      {
        "comment_id": "1797674713",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23837,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkBaseExternalContext.java",
        "discussion_id": "1797633896",
        "commented_code": "@@ -553,6 +574,21 @@ public boolean cancel() {\n       return !future.cancel(true);\n     }\n \n+    @Override\n+    public void close() {\n+      // Call register() to ensure arriveAndDeregister() will terminate the\n+      // downloadPhaser if the download has not started yet.\n+      if (downloadPhaser.register() < 0) {\n+        // The download completed normally or has already been cancelled and the thread has\n+        // terminated in response to the interrupt.\n+        return;\n+      }\n+      try (SilentCloseable c =\n+          Profiler.instance().profile(\"Cancelling download \" + outputPath)) {\n+        downloadPhaser.awaitAdvance(downloadPhaser.arriveAndDeregister());",
        "comment_created_at": "2024-10-12T10:10:00+00:00",
        "comment_author": "moroten",
        "comment_body": "The code was written to use Phaser termination as the signalling method. I've now changed to to use `phase=0` as signalling method according to the suggestion. The JSON profiles look very nice in the small test case.",
        "pr_file_module": null
      }
    ]
  }
]