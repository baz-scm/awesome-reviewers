[
  {
    "discussion_id": "2279154189",
    "pr_number": 22553,
    "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
    "created_at": "2025-08-15T15:02:03+00:00",
    "commented_code": "(private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],\n+        mnemonic = \"CppGenModmap\",\n+        progress_message = \"Generating C++20 modules modmap %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_cc_compile_actions_with_cpp20_module_helper(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables,\n+        use_pic,\n+        output_name_map):\n+    direct_module_files = []\n+    source_to_module_file_map = {}\n+    source_to_ddi_file_map = {}\n+    modules_info_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_INFO,\n+            output_name = label.name,\n+        ),\n+    )\n+    if use_pic:\n+        outputs.add_pic_modules_info_file(modules_info_file)\n+    else:\n+        outputs.add_modules_info_file(modules_info_file)\n+\n+    native_cc_semantics = cc_common_internal.get_cpp_semantics(language = language)\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        ouptut_category = artifact_category.CPP_MODULE\n+        module_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = ouptut_category,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        direct_module_files.append(module_file)\n+        source_to_module_file_map[source_artifact] = module_file\n+\n+        # dependencies information are put in .ddi file\n+        # the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+        ddi_output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_DDI,\n+            output_name = output_name_base,\n+        )\n+        ddi_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = ddi_output_name,\n+        )\n+        _create_scan_deps_action(\n+            action_construction_context = action_construction_context,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            copts_filter = copts_filter,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            feature_configuration = feature_configuration,\n+            label = label,\n+            common_toolchain_variables = common_compile_build_variables,\n+            language = language,\n+            native_cc_semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            source_label = source_label,\n+            use_pic = use_pic,\n+            ddi_file = ddi_file,\n+            ddi_output_name = ddi_output_name,\n+        )\n+        source_to_ddi_file_map[source_artifact] = ddi_file\n+\n+    _create_aggregate_ddi_action(\n+        actions = actions,\n+        cc_toolchain = cc_toolchain,\n+        ddi_files = source_to_ddi_file_map.values(),\n+        direct_module_files = direct_module_files,\n+        transitive_modules_info_files = cc_compilation_context.modules_info_files(use_pic = use_pic),\n+        modules_info_file = modules_info_file,\n+    )\n+    compiled_basenames = set()\n+    all_module_files = depset(direct_module_files, transitive = [cc_compilation_context.module_files(use_pic = use_pic)])\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+        module_file = source_to_module_file_map[source_artifact]\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+            outputs.add_pic_cpp20_module_file(module_file)\n+        else:\n+            output_name_base = output_name\n+            outputs.add_cpp20_module_file(module_file)\n+\n+        modmap_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        modmap_input_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        _create_gen_modmap_action(\n+            actions = actions,\n+            cc_toolchain = cc_toolchain,\n+            ddi_file = source_to_ddi_file_map.get(source_artifact),",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2279154189",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279154189",
        "commented_code": "@@ -436,6 +493,602 @@ def _should_provide_header_modules(\n         (private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],\n+        mnemonic = \"CppGenModmap\",\n+        progress_message = \"Generating C++20 modules modmap %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_cc_compile_actions_with_cpp20_module_helper(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables,\n+        use_pic,\n+        output_name_map):\n+    direct_module_files = []\n+    source_to_module_file_map = {}\n+    source_to_ddi_file_map = {}\n+    modules_info_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_INFO,\n+            output_name = label.name,\n+        ),\n+    )\n+    if use_pic:\n+        outputs.add_pic_modules_info_file(modules_info_file)\n+    else:\n+        outputs.add_modules_info_file(modules_info_file)\n+\n+    native_cc_semantics = cc_common_internal.get_cpp_semantics(language = language)\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        ouptut_category = artifact_category.CPP_MODULE\n+        module_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = ouptut_category,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        direct_module_files.append(module_file)\n+        source_to_module_file_map[source_artifact] = module_file\n+\n+        # dependencies information are put in .ddi file\n+        # the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+        ddi_output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_DDI,\n+            output_name = output_name_base,\n+        )\n+        ddi_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = ddi_output_name,\n+        )\n+        _create_scan_deps_action(\n+            action_construction_context = action_construction_context,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            copts_filter = copts_filter,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            feature_configuration = feature_configuration,\n+            label = label,\n+            common_toolchain_variables = common_compile_build_variables,\n+            language = language,\n+            native_cc_semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            source_label = source_label,\n+            use_pic = use_pic,\n+            ddi_file = ddi_file,\n+            ddi_output_name = ddi_output_name,\n+        )\n+        source_to_ddi_file_map[source_artifact] = ddi_file\n+\n+    _create_aggregate_ddi_action(\n+        actions = actions,\n+        cc_toolchain = cc_toolchain,\n+        ddi_files = source_to_ddi_file_map.values(),\n+        direct_module_files = direct_module_files,\n+        transitive_modules_info_files = cc_compilation_context.modules_info_files(use_pic = use_pic),\n+        modules_info_file = modules_info_file,\n+    )\n+    compiled_basenames = set()\n+    all_module_files = depset(direct_module_files, transitive = [cc_compilation_context.module_files(use_pic = use_pic)])\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+        module_file = source_to_module_file_map[source_artifact]\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+            outputs.add_pic_cpp20_module_file(module_file)\n+        else:\n+            output_name_base = output_name\n+            outputs.add_cpp20_module_file(module_file)\n+\n+        modmap_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        modmap_input_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        _create_gen_modmap_action(\n+            actions = actions,\n+            cc_toolchain = cc_toolchain,\n+            ddi_file = source_to_ddi_file_map.get(source_artifact),",
        "comment_created_at": "2025-08-15T15:02:03+00:00",
        "comment_author": "fmeum",
        "comment_body": "Do we ever expect `source_artifact not in source_to_ddi_file_map`? If so, please add a comment explaining what happens in that case, if not, use `[...]` instead of `get` to make this an error.",
        "pr_file_module": null
      },
      {
        "comment_id": "2281651260",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279154189",
        "commented_code": "@@ -436,6 +493,602 @@ def _should_provide_header_modules(\n         (private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],\n+        mnemonic = \"CppGenModmap\",\n+        progress_message = \"Generating C++20 modules modmap %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_cc_compile_actions_with_cpp20_module_helper(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables,\n+        use_pic,\n+        output_name_map):\n+    direct_module_files = []\n+    source_to_module_file_map = {}\n+    source_to_ddi_file_map = {}\n+    modules_info_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_INFO,\n+            output_name = label.name,\n+        ),\n+    )\n+    if use_pic:\n+        outputs.add_pic_modules_info_file(modules_info_file)\n+    else:\n+        outputs.add_modules_info_file(modules_info_file)\n+\n+    native_cc_semantics = cc_common_internal.get_cpp_semantics(language = language)\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        ouptut_category = artifact_category.CPP_MODULE\n+        module_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = ouptut_category,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        direct_module_files.append(module_file)\n+        source_to_module_file_map[source_artifact] = module_file\n+\n+        # dependencies information are put in .ddi file\n+        # the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+        ddi_output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_DDI,\n+            output_name = output_name_base,\n+        )\n+        ddi_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = ddi_output_name,\n+        )\n+        _create_scan_deps_action(\n+            action_construction_context = action_construction_context,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            copts_filter = copts_filter,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            feature_configuration = feature_configuration,\n+            label = label,\n+            common_toolchain_variables = common_compile_build_variables,\n+            language = language,\n+            native_cc_semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            source_label = source_label,\n+            use_pic = use_pic,\n+            ddi_file = ddi_file,\n+            ddi_output_name = ddi_output_name,\n+        )\n+        source_to_ddi_file_map[source_artifact] = ddi_file\n+\n+    _create_aggregate_ddi_action(\n+        actions = actions,\n+        cc_toolchain = cc_toolchain,\n+        ddi_files = source_to_ddi_file_map.values(),\n+        direct_module_files = direct_module_files,\n+        transitive_modules_info_files = cc_compilation_context.modules_info_files(use_pic = use_pic),\n+        modules_info_file = modules_info_file,\n+    )\n+    compiled_basenames = set()\n+    all_module_files = depset(direct_module_files, transitive = [cc_compilation_context.module_files(use_pic = use_pic)])\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+        module_file = source_to_module_file_map[source_artifact]\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+            outputs.add_pic_cpp20_module_file(module_file)\n+        else:\n+            output_name_base = output_name\n+            outputs.add_cpp20_module_file(module_file)\n+\n+        modmap_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        modmap_input_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        _create_gen_modmap_action(\n+            actions = actions,\n+            cc_toolchain = cc_toolchain,\n+            ddi_file = source_to_ddi_file_map.get(source_artifact),",
        "comment_created_at": "2025-08-18T08:22:20+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "`source_artifact` must be present in `source_to_ddi_file_map`; if it's missing, that's a bug.\r\n\r\n`source_to_ddi_file_map` is populated during the first traversal of `module_interfaces_sources`. This code performs a second traversal of the same `module_interfaces_sources`, so the map is expected to already contain the entry.",
        "pr_file_module": null
      },
      {
        "comment_id": "2282004802",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279154189",
        "commented_code": "@@ -436,6 +493,602 @@ def _should_provide_header_modules(\n         (private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],\n+        mnemonic = \"CppGenModmap\",\n+        progress_message = \"Generating C++20 modules modmap %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_cc_compile_actions_with_cpp20_module_helper(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables,\n+        use_pic,\n+        output_name_map):\n+    direct_module_files = []\n+    source_to_module_file_map = {}\n+    source_to_ddi_file_map = {}\n+    modules_info_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_INFO,\n+            output_name = label.name,\n+        ),\n+    )\n+    if use_pic:\n+        outputs.add_pic_modules_info_file(modules_info_file)\n+    else:\n+        outputs.add_modules_info_file(modules_info_file)\n+\n+    native_cc_semantics = cc_common_internal.get_cpp_semantics(language = language)\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        ouptut_category = artifact_category.CPP_MODULE\n+        module_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = ouptut_category,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        direct_module_files.append(module_file)\n+        source_to_module_file_map[source_artifact] = module_file\n+\n+        # dependencies information are put in .ddi file\n+        # the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+        ddi_output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_DDI,\n+            output_name = output_name_base,\n+        )\n+        ddi_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = ddi_output_name,\n+        )\n+        _create_scan_deps_action(\n+            action_construction_context = action_construction_context,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            copts_filter = copts_filter,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            feature_configuration = feature_configuration,\n+            label = label,\n+            common_toolchain_variables = common_compile_build_variables,\n+            language = language,\n+            native_cc_semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            source_label = source_label,\n+            use_pic = use_pic,\n+            ddi_file = ddi_file,\n+            ddi_output_name = ddi_output_name,\n+        )\n+        source_to_ddi_file_map[source_artifact] = ddi_file\n+\n+    _create_aggregate_ddi_action(\n+        actions = actions,\n+        cc_toolchain = cc_toolchain,\n+        ddi_files = source_to_ddi_file_map.values(),\n+        direct_module_files = direct_module_files,\n+        transitive_modules_info_files = cc_compilation_context.modules_info_files(use_pic = use_pic),\n+        modules_info_file = modules_info_file,\n+    )\n+    compiled_basenames = set()\n+    all_module_files = depset(direct_module_files, transitive = [cc_compilation_context.module_files(use_pic = use_pic)])\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+        module_file = source_to_module_file_map[source_artifact]\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+            outputs.add_pic_cpp20_module_file(module_file)\n+        else:\n+            output_name_base = output_name\n+            outputs.add_cpp20_module_file(module_file)\n+\n+        modmap_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        modmap_input_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        _create_gen_modmap_action(\n+            actions = actions,\n+            cc_toolchain = cc_toolchain,\n+            ddi_file = source_to_ddi_file_map.get(source_artifact),",
        "comment_created_at": "2025-08-18T10:32:40+00:00",
        "comment_author": "fmeum",
        "comment_body": "In that case please use `[...]` instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "2282196040",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279154189",
        "commented_code": "@@ -436,6 +493,602 @@ def _should_provide_header_modules(\n         (private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],\n+        mnemonic = \"CppGenModmap\",\n+        progress_message = \"Generating C++20 modules modmap %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_cc_compile_actions_with_cpp20_module_helper(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables,\n+        use_pic,\n+        output_name_map):\n+    direct_module_files = []\n+    source_to_module_file_map = {}\n+    source_to_ddi_file_map = {}\n+    modules_info_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_INFO,\n+            output_name = label.name,\n+        ),\n+    )\n+    if use_pic:\n+        outputs.add_pic_modules_info_file(modules_info_file)\n+    else:\n+        outputs.add_modules_info_file(modules_info_file)\n+\n+    native_cc_semantics = cc_common_internal.get_cpp_semantics(language = language)\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        ouptut_category = artifact_category.CPP_MODULE\n+        module_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = ouptut_category,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        direct_module_files.append(module_file)\n+        source_to_module_file_map[source_artifact] = module_file\n+\n+        # dependencies information are put in .ddi file\n+        # the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+        ddi_output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_DDI,\n+            output_name = output_name_base,\n+        )\n+        ddi_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = ddi_output_name,\n+        )\n+        _create_scan_deps_action(\n+            action_construction_context = action_construction_context,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            copts_filter = copts_filter,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            feature_configuration = feature_configuration,\n+            label = label,\n+            common_toolchain_variables = common_compile_build_variables,\n+            language = language,\n+            native_cc_semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            source_label = source_label,\n+            use_pic = use_pic,\n+            ddi_file = ddi_file,\n+            ddi_output_name = ddi_output_name,\n+        )\n+        source_to_ddi_file_map[source_artifact] = ddi_file\n+\n+    _create_aggregate_ddi_action(\n+        actions = actions,\n+        cc_toolchain = cc_toolchain,\n+        ddi_files = source_to_ddi_file_map.values(),\n+        direct_module_files = direct_module_files,\n+        transitive_modules_info_files = cc_compilation_context.modules_info_files(use_pic = use_pic),\n+        modules_info_file = modules_info_file,\n+    )\n+    compiled_basenames = set()\n+    all_module_files = depset(direct_module_files, transitive = [cc_compilation_context.module_files(use_pic = use_pic)])\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+        module_file = source_to_module_file_map[source_artifact]\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+            outputs.add_pic_cpp20_module_file(module_file)\n+        else:\n+            output_name_base = output_name\n+            outputs.add_cpp20_module_file(module_file)\n+\n+        modmap_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        modmap_input_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        _create_gen_modmap_action(\n+            actions = actions,\n+            cc_toolchain = cc_toolchain,\n+            ddi_file = source_to_ddi_file_map.get(source_artifact),",
        "comment_created_at": "2025-08-18T11:59:46+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1148576547",
    "pr_number": 17887,
    "pr_file": "tools/cpp/runfiles/runfiles_src.cc",
    "created_at": "2023-03-26T15:12:19+00:00",
    "commented_code": "}  // namespace\n \n+#if defined(__has_builtin)\n+#if __has_builtin(__builtin_FILE)\n+#define BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+#if defined(_MSC_VER)\n+#if _MSC_VER >= 1926\n+#define BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+\n+#if defined(BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE) ||                        \\\n+    defined(BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE)\n+std::string Runfiles::CurrentRepository(std::string file) {\n+  std::string repo;\n+  if (file[0] == 'e' && file[1] == 'x' && file[2] == 't' && file[3] == 'e' &&",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1148576547",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17887,
        "pr_file": "tools/cpp/runfiles/runfiles_src.cc",
        "discussion_id": "1148576547",
        "commented_code": "@@ -111,6 +111,59 @@ bool ParseRepoMapping(const string& path,\n \n }  // namespace\n \n+#if defined(__has_builtin)\n+#if __has_builtin(__builtin_FILE)\n+#define BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+#if defined(_MSC_VER)\n+#if _MSC_VER >= 1926\n+#define BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+\n+#if defined(BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE) ||                        \\\n+    defined(BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE)\n+std::string Runfiles::CurrentRepository(std::string file) {\n+  std::string repo;\n+  if (file[0] == 'e' && file[1] == 'x' && file[2] == 't' && file[3] == 'e' &&",
        "comment_created_at": "2023-03-26T15:12:19+00:00",
        "comment_author": "fmeum",
        "comment_body": "Could this use `startswith`? In any case it would need bounds checking as `file` may be too short.",
        "pr_file_module": null
      },
      {
        "comment_id": "1148594081",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17887,
        "pr_file": "tools/cpp/runfiles/runfiles_src.cc",
        "discussion_id": "1148576547",
        "commented_code": "@@ -111,6 +111,59 @@ bool ParseRepoMapping(const string& path,\n \n }  // namespace\n \n+#if defined(__has_builtin)\n+#if __has_builtin(__builtin_FILE)\n+#define BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+#if defined(_MSC_VER)\n+#if _MSC_VER >= 1926\n+#define BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+\n+#if defined(BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE) ||                        \\\n+    defined(BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE)\n+std::string Runfiles::CurrentRepository(std::string file) {\n+  std::string repo;\n+  if (file[0] == 'e' && file[1] == 'x' && file[2] == 't' && file[3] == 'e' &&",
        "comment_created_at": "2023-03-26T16:48:20+00:00",
        "comment_author": "BoleynSu",
        "comment_body": "Good catch! Is path always using forward slash, i.e., even on Windows?",
        "pr_file_module": null
      },
      {
        "comment_id": "1148599264",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 17887,
        "pr_file": "tools/cpp/runfiles/runfiles_src.cc",
        "discussion_id": "1148576547",
        "commented_code": "@@ -111,6 +111,59 @@ bool ParseRepoMapping(const string& path,\n \n }  // namespace\n \n+#if defined(__has_builtin)\n+#if __has_builtin(__builtin_FILE)\n+#define BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+#if defined(_MSC_VER)\n+#if _MSC_VER >= 1926\n+#define BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE\n+#endif\n+#endif\n+\n+#if defined(BAZEL_RUNFILES_GENERIC_HAS_BUILTIN_FILE) ||                        \\\n+    defined(BAZEL_RUNFILES_MSVC_HAS_BUILTIN_FILE)\n+std::string Runfiles::CurrentRepository(std::string file) {\n+  std::string repo;\n+  if (file[0] == 'e' && file[1] == 'x' && file[2] == 't' && file[3] == 'e' &&",
        "comment_created_at": "2023-03-26T17:19:24+00:00",
        "comment_author": "fmeum",
        "comment_body": "I don't know, but the tests should tell us.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1601737040",
    "pr_number": 16954,
    "pr_file": "src/main/starlark/builtins_bzl/common/cc/experimental_cc_static_library.bzl",
    "created_at": "2024-05-15T14:16:45+00:00",
    "commented_code": "+# Copyright 2021 The Bazel Authors. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"This is an experimental implementation of cc_static_library.\n+\n+We may change the implementation at any moment or even delete this file. Do not\n+rely on this.\n+\"\"\"\n+\n+load(\":common/cc/action_names.bzl\", \"ACTION_NAMES\")\n+load(\":common/cc/cc_common.bzl\", \"cc_common\")\n+load(\":common/cc/cc_helper.bzl\", \"artifact_category\", \"cc_helper\")\n+load(\":common/cc/cc_info.bzl\", \"CcInfo\")\n+load(\":common/cc/semantics.bzl\", \"semantics\")\n+\n+cc_internal = _builtins.internal.cc_internal\n+\n+def _declare_static_library(*, name, actions, cc_toolchain):\n+    new_name = cc_internal.get_artifact_name_for_category(\n+        cc_toolchain = cc_toolchain,\n+        category = artifact_category.STATIC_LIBRARY,\n+        output_name = cc_helper.get_base_name(name),\n+    )\n+    return actions.declare_file(cc_helper.replace_name(name, new_name))\n+\n+def _collect_linker_inputs(deps):\n+    transitive_linker_inputs = [dep[CcInfo].linking_context.linker_inputs for dep in deps]\n+    return depset(transitive = transitive_linker_inputs)\n+\n+def _flatten_and_get_objects(linker_inputs):\n+    # Flattening a depset to get the action inputs.\n+    transitive_objects = []\n+    for linker_input in linker_inputs.to_list():\n+        for lib in linker_input.libraries:\n+            if lib.pic_objects:",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1601737040",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 16954,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/experimental_cc_static_library.bzl",
        "discussion_id": "1601737040",
        "commented_code": "@@ -0,0 +1,301 @@\n+# Copyright 2021 The Bazel Authors. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"This is an experimental implementation of cc_static_library.\n+\n+We may change the implementation at any moment or even delete this file. Do not\n+rely on this.\n+\"\"\"\n+\n+load(\":common/cc/action_names.bzl\", \"ACTION_NAMES\")\n+load(\":common/cc/cc_common.bzl\", \"cc_common\")\n+load(\":common/cc/cc_helper.bzl\", \"artifact_category\", \"cc_helper\")\n+load(\":common/cc/cc_info.bzl\", \"CcInfo\")\n+load(\":common/cc/semantics.bzl\", \"semantics\")\n+\n+cc_internal = _builtins.internal.cc_internal\n+\n+def _declare_static_library(*, name, actions, cc_toolchain):\n+    new_name = cc_internal.get_artifact_name_for_category(\n+        cc_toolchain = cc_toolchain,\n+        category = artifact_category.STATIC_LIBRARY,\n+        output_name = cc_helper.get_base_name(name),\n+    )\n+    return actions.declare_file(cc_helper.replace_name(name, new_name))\n+\n+def _collect_linker_inputs(deps):\n+    transitive_linker_inputs = [dep[CcInfo].linking_context.linker_inputs for dep in deps]\n+    return depset(transitive = transitive_linker_inputs)\n+\n+def _flatten_and_get_objects(linker_inputs):\n+    # Flattening a depset to get the action inputs.\n+    transitive_objects = []\n+    for linker_input in linker_inputs.to_list():\n+        for lib in linker_input.libraries:\n+            if lib.pic_objects:",
        "comment_created_at": "2024-05-15T14:16:45+00:00",
        "comment_author": "comius",
        "comment_body": "Should be `if lib.pic_objects != None`. There are non-empty archives in C++ linking code, which have objects set to `None`. And empty ones that have objects set to `[]`.",
        "pr_file_module": null
      }
    ]
  }
]