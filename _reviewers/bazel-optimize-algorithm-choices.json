[
  {
    "discussion_id": "2169305306",
    "pr_number": 22553,
    "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
    "created_at": "2025-06-26T15:10:42+00:00",
    "commented_code": "return result.build();\n   }\n \n+  private CcCompilationOutputs createCcCompileActionsWithCpp20Module()\n+      throws RuleErrorException, EvalException, InterruptedException {\n+    Preconditions.checkState(\n+        featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES),\n+        \"to use C++20 Modules, the feature CPP_MODULES must be enabled\");\n+    Preconditions.checkNotNull(ccCompilationContext);\n+    CcCompilationOutputs.Builder result = CcCompilationOutputs.builder();\n+    // merge module interfaces and ordinary sources\n+    Map<Artifact, CppSource> sourcesMap = new LinkedHashMap<>();\n+    sourcesMap.putAll(compilationUnitSources);\n+    sourcesMap.putAll(moduleInterfaceSources);\n+    ImmutableMap<Artifact, String> outputNameMap =\n+        calculateOutputNameMapByType(sourcesMap, /* prefixDir= */ null);\n+    if (generateNoPicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ false, outputNameMap);\n+    }\n+    if (generatePicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ true, outputNameMap);\n+    }\n+    return result.build();\n+  }\n+\n+  private void createCcCompileActionsWithCpp20ModuleHelper(\n+      CcCompilationOutputs.Builder result,\n+      boolean usePic,\n+      ImmutableMap<Artifact, String> outputNameMap)\n+      throws RuleErrorException, EvalException, InterruptedException {\n+\n+    ImmutableMap.Builder<Artifact, Artifact.DerivedArtifact> moduleFileMapBuilder =\n+        new ImmutableMap.Builder<>();\n+    ImmutableMap.Builder<Artifact, Artifact> ddiFileMapBuilder = new ImmutableMap.Builder<>();\n+    NestedSetBuilder<Artifact> ddiFileSetBuilder = NestedSetBuilder.stableOrder();\n+    ImmutableList.Builder<CommandLine> commandLineBuilder = new ImmutableList.Builder<>();\n+\n+    // declare <target-name>.CXXModules.json\n+    // all modules information is put here\n+    Artifact modulesInfoFile =\n+        CppHelper.getCompileOutputArtifact(\n+            actionConstructionContext,\n+            label,\n+            CppHelper.getArtifactNameForCategory(\n+                ccToolchain,\n+                ArtifactCategory.CPP_MODULES_INFO,\n+                getOutputNameBaseWith(label.getName(), usePic)),\n+            configuration);\n+    if (usePic) {\n+      result.addPicModulesInfoFile(modulesInfoFile);\n+    } else {\n+      result.addModulesInfoFile(modulesInfoFile);\n+    }\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      ArtifactCategory outputCategory = ArtifactCategory.CPP_MODULE;\n+      if (Objects.equals(ccToolchain.getCompiler(), \"gcc\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_GCM;\n+      } else if (Objects.equals(ccToolchain.getCompiler(), \"msvc-cl\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_IFC;\n+      }\n+      var moduleFile =\n+          CppHelper.getCompileModuleOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain, outputCategory, getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      moduleFileMapBuilder.put(sourceArtifact, moduleFile);\n+      // dependencies information are put in .ddi file\n+      // the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+      var ddiOutputName =\n+          CppHelper.getArtifactNameForCategory(\n+              ccToolchain,\n+              ArtifactCategory.CPP_MODULES_DDI,\n+              getOutputNameBaseWith(outputName, usePic));\n+      Artifact ddiFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext, label, ddiOutputName, configuration);\n+      commandLineBuilder.add(\n+          CommandLine.of(\n+              ImmutableList.of(\"-d\", ddiFile.getExecPathString(), moduleFile.getExecPathString())));\n+      createScanDepsAction(source.getLabel(), sourceArtifact, usePic, ddiFile, ddiOutputName);\n+      ddiFileSetBuilder.add(ddiFile);\n+      ddiFileMapBuilder.put(sourceArtifact, ddiFile);\n+    }\n+    createAggDdiAction(\n+        ddiFileSetBuilder.build(),\n+        commandLineBuilder.build(),\n+        ccCompilationContext.getModulesInfoFiles(usePic),\n+        modulesInfoFile);\n+    ImmutableMap<Artifact, Artifact.DerivedArtifact> moduleFileMap = moduleFileMapBuilder.build();\n+    ImmutableMap<Artifact, Artifact> ddiFileMap = ddiFileMapBuilder.build();\n+    var allModuleFilesBuilder =\n+        NestedSetBuilder.<Artifact.DerivedArtifact>stableOrder().addAll(moduleFileMap.values());\n+    var depModuleFiles = ccCompilationContext.getModuleFiles(usePic);\n+    if (depModuleFiles != null) {\n+      allModuleFilesBuilder.addTransitive(depModuleFiles);\n+    }\n+    var allModuleFiles = allModuleFilesBuilder.build();\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+\n+      Label sourceLabel = source.getLabel();\n+      CppCompileActionBuilder builder = initializeCompileAction(sourceArtifact);\n+      builder.setPicMode(usePic);\n+      builder.setActionName(CppActionNames.CPP20_MODULE_COMPILE);\n+\n+      builder\n+          .addMandatoryInputs(additionalCompilationInputs)\n+          .addAdditionalIncludeScanningRoots(additionalIncludeScanningRoots);\n+\n+      boolean bitcodeOutput =\n+          featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)\n+              && CppFileTypes.LTO_SOURCE.matches(sourceArtifact.getFilename());\n+\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      Artifact.DerivedArtifact moduleFile = moduleFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(moduleFile);\n+      builder.setAdditionalOutputs(ImmutableList.of(moduleFile));\n+      builder.setModuleFiles(allModuleFiles);\n+      if (usePic) {\n+        result.addPicCpp20ModuleFile(moduleFile);\n+      } else {\n+        result.addCpp20ModuleFile(moduleFile);\n+      }\n+\n+      // all -fmodule-file=<module-name>=<path/to/bmi> flags are put in .modmap file\n+      var modmapFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      // all path/to/bmi are put in .modmap.input file,\n+      // which is convenient to get all bmi in CppCompileAction\n+      var modmapInputFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP_INPUT,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      var ddiFile = ddiFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(ddiFile);\n+      createGenModmapAction(ddiFile, modulesInfoFile, modmapFile, modmapInputFile);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2169305306",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "2169305306",
        "commented_code": "@@ -950,13 +970,287 @@ private ImmutableSet<Artifact> getSourceArtifactsByType(\n     return result.build();\n   }\n \n+  private CcCompilationOutputs createCcCompileActionsWithCpp20Module()\n+      throws RuleErrorException, EvalException, InterruptedException {\n+    Preconditions.checkState(\n+        featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES),\n+        \"to use C++20 Modules, the feature CPP_MODULES must be enabled\");\n+    Preconditions.checkNotNull(ccCompilationContext);\n+    CcCompilationOutputs.Builder result = CcCompilationOutputs.builder();\n+    // merge module interfaces and ordinary sources\n+    Map<Artifact, CppSource> sourcesMap = new LinkedHashMap<>();\n+    sourcesMap.putAll(compilationUnitSources);\n+    sourcesMap.putAll(moduleInterfaceSources);\n+    ImmutableMap<Artifact, String> outputNameMap =\n+        calculateOutputNameMapByType(sourcesMap, /* prefixDir= */ null);\n+    if (generateNoPicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ false, outputNameMap);\n+    }\n+    if (generatePicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ true, outputNameMap);\n+    }\n+    return result.build();\n+  }\n+\n+  private void createCcCompileActionsWithCpp20ModuleHelper(\n+      CcCompilationOutputs.Builder result,\n+      boolean usePic,\n+      ImmutableMap<Artifact, String> outputNameMap)\n+      throws RuleErrorException, EvalException, InterruptedException {\n+\n+    ImmutableMap.Builder<Artifact, Artifact.DerivedArtifact> moduleFileMapBuilder =\n+        new ImmutableMap.Builder<>();\n+    ImmutableMap.Builder<Artifact, Artifact> ddiFileMapBuilder = new ImmutableMap.Builder<>();\n+    NestedSetBuilder<Artifact> ddiFileSetBuilder = NestedSetBuilder.stableOrder();\n+    ImmutableList.Builder<CommandLine> commandLineBuilder = new ImmutableList.Builder<>();\n+\n+    // declare <target-name>.CXXModules.json\n+    // all modules information is put here\n+    Artifact modulesInfoFile =\n+        CppHelper.getCompileOutputArtifact(\n+            actionConstructionContext,\n+            label,\n+            CppHelper.getArtifactNameForCategory(\n+                ccToolchain,\n+                ArtifactCategory.CPP_MODULES_INFO,\n+                getOutputNameBaseWith(label.getName(), usePic)),\n+            configuration);\n+    if (usePic) {\n+      result.addPicModulesInfoFile(modulesInfoFile);\n+    } else {\n+      result.addModulesInfoFile(modulesInfoFile);\n+    }\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      ArtifactCategory outputCategory = ArtifactCategory.CPP_MODULE;\n+      if (Objects.equals(ccToolchain.getCompiler(), \"gcc\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_GCM;\n+      } else if (Objects.equals(ccToolchain.getCompiler(), \"msvc-cl\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_IFC;\n+      }\n+      var moduleFile =\n+          CppHelper.getCompileModuleOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain, outputCategory, getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      moduleFileMapBuilder.put(sourceArtifact, moduleFile);\n+      // dependencies information are put in .ddi file\n+      // the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+      var ddiOutputName =\n+          CppHelper.getArtifactNameForCategory(\n+              ccToolchain,\n+              ArtifactCategory.CPP_MODULES_DDI,\n+              getOutputNameBaseWith(outputName, usePic));\n+      Artifact ddiFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext, label, ddiOutputName, configuration);\n+      commandLineBuilder.add(\n+          CommandLine.of(\n+              ImmutableList.of(\"-d\", ddiFile.getExecPathString(), moduleFile.getExecPathString())));\n+      createScanDepsAction(source.getLabel(), sourceArtifact, usePic, ddiFile, ddiOutputName);\n+      ddiFileSetBuilder.add(ddiFile);\n+      ddiFileMapBuilder.put(sourceArtifact, ddiFile);\n+    }\n+    createAggDdiAction(\n+        ddiFileSetBuilder.build(),\n+        commandLineBuilder.build(),\n+        ccCompilationContext.getModulesInfoFiles(usePic),\n+        modulesInfoFile);\n+    ImmutableMap<Artifact, Artifact.DerivedArtifact> moduleFileMap = moduleFileMapBuilder.build();\n+    ImmutableMap<Artifact, Artifact> ddiFileMap = ddiFileMapBuilder.build();\n+    var allModuleFilesBuilder =\n+        NestedSetBuilder.<Artifact.DerivedArtifact>stableOrder().addAll(moduleFileMap.values());\n+    var depModuleFiles = ccCompilationContext.getModuleFiles(usePic);\n+    if (depModuleFiles != null) {\n+      allModuleFilesBuilder.addTransitive(depModuleFiles);\n+    }\n+    var allModuleFiles = allModuleFilesBuilder.build();\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+\n+      Label sourceLabel = source.getLabel();\n+      CppCompileActionBuilder builder = initializeCompileAction(sourceArtifact);\n+      builder.setPicMode(usePic);\n+      builder.setActionName(CppActionNames.CPP20_MODULE_COMPILE);\n+\n+      builder\n+          .addMandatoryInputs(additionalCompilationInputs)\n+          .addAdditionalIncludeScanningRoots(additionalIncludeScanningRoots);\n+\n+      boolean bitcodeOutput =\n+          featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)\n+              && CppFileTypes.LTO_SOURCE.matches(sourceArtifact.getFilename());\n+\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      Artifact.DerivedArtifact moduleFile = moduleFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(moduleFile);\n+      builder.setAdditionalOutputs(ImmutableList.of(moduleFile));\n+      builder.setModuleFiles(allModuleFiles);\n+      if (usePic) {\n+        result.addPicCpp20ModuleFile(moduleFile);\n+      } else {\n+        result.addCpp20ModuleFile(moduleFile);\n+      }\n+\n+      // all -fmodule-file=<module-name>=<path/to/bmi> flags are put in .modmap file\n+      var modmapFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      // all path/to/bmi are put in .modmap.input file,\n+      // which is convenient to get all bmi in CppCompileAction\n+      var modmapInputFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP_INPUT,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      var ddiFile = ddiFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(ddiFile);\n+      createGenModmapAction(ddiFile, modulesInfoFile, modmapFile, modmapInputFile);",
        "comment_created_at": "2025-06-26T15:10:42+00:00",
        "comment_author": "fmeum",
        "comment_body": "The `generate-modmap` tool uses `unsorted_set` extensively, which doesn't guarantee any particular ordering (I am not even sure whether its guaranteed to be deterministic on a single machine). Could you either use a data structure that preserves insertion order or just use `set` to get sort order?",
        "pr_file_module": null
      },
      {
        "comment_id": "2179746107",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "2169305306",
        "commented_code": "@@ -950,13 +970,287 @@ private ImmutableSet<Artifact> getSourceArtifactsByType(\n     return result.build();\n   }\n \n+  private CcCompilationOutputs createCcCompileActionsWithCpp20Module()\n+      throws RuleErrorException, EvalException, InterruptedException {\n+    Preconditions.checkState(\n+        featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES),\n+        \"to use C++20 Modules, the feature CPP_MODULES must be enabled\");\n+    Preconditions.checkNotNull(ccCompilationContext);\n+    CcCompilationOutputs.Builder result = CcCompilationOutputs.builder();\n+    // merge module interfaces and ordinary sources\n+    Map<Artifact, CppSource> sourcesMap = new LinkedHashMap<>();\n+    sourcesMap.putAll(compilationUnitSources);\n+    sourcesMap.putAll(moduleInterfaceSources);\n+    ImmutableMap<Artifact, String> outputNameMap =\n+        calculateOutputNameMapByType(sourcesMap, /* prefixDir= */ null);\n+    if (generateNoPicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ false, outputNameMap);\n+    }\n+    if (generatePicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ true, outputNameMap);\n+    }\n+    return result.build();\n+  }\n+\n+  private void createCcCompileActionsWithCpp20ModuleHelper(\n+      CcCompilationOutputs.Builder result,\n+      boolean usePic,\n+      ImmutableMap<Artifact, String> outputNameMap)\n+      throws RuleErrorException, EvalException, InterruptedException {\n+\n+    ImmutableMap.Builder<Artifact, Artifact.DerivedArtifact> moduleFileMapBuilder =\n+        new ImmutableMap.Builder<>();\n+    ImmutableMap.Builder<Artifact, Artifact> ddiFileMapBuilder = new ImmutableMap.Builder<>();\n+    NestedSetBuilder<Artifact> ddiFileSetBuilder = NestedSetBuilder.stableOrder();\n+    ImmutableList.Builder<CommandLine> commandLineBuilder = new ImmutableList.Builder<>();\n+\n+    // declare <target-name>.CXXModules.json\n+    // all modules information is put here\n+    Artifact modulesInfoFile =\n+        CppHelper.getCompileOutputArtifact(\n+            actionConstructionContext,\n+            label,\n+            CppHelper.getArtifactNameForCategory(\n+                ccToolchain,\n+                ArtifactCategory.CPP_MODULES_INFO,\n+                getOutputNameBaseWith(label.getName(), usePic)),\n+            configuration);\n+    if (usePic) {\n+      result.addPicModulesInfoFile(modulesInfoFile);\n+    } else {\n+      result.addModulesInfoFile(modulesInfoFile);\n+    }\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      ArtifactCategory outputCategory = ArtifactCategory.CPP_MODULE;\n+      if (Objects.equals(ccToolchain.getCompiler(), \"gcc\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_GCM;\n+      } else if (Objects.equals(ccToolchain.getCompiler(), \"msvc-cl\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_IFC;\n+      }\n+      var moduleFile =\n+          CppHelper.getCompileModuleOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain, outputCategory, getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      moduleFileMapBuilder.put(sourceArtifact, moduleFile);\n+      // dependencies information are put in .ddi file\n+      // the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+      var ddiOutputName =\n+          CppHelper.getArtifactNameForCategory(\n+              ccToolchain,\n+              ArtifactCategory.CPP_MODULES_DDI,\n+              getOutputNameBaseWith(outputName, usePic));\n+      Artifact ddiFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext, label, ddiOutputName, configuration);\n+      commandLineBuilder.add(\n+          CommandLine.of(\n+              ImmutableList.of(\"-d\", ddiFile.getExecPathString(), moduleFile.getExecPathString())));\n+      createScanDepsAction(source.getLabel(), sourceArtifact, usePic, ddiFile, ddiOutputName);\n+      ddiFileSetBuilder.add(ddiFile);\n+      ddiFileMapBuilder.put(sourceArtifact, ddiFile);\n+    }\n+    createAggDdiAction(\n+        ddiFileSetBuilder.build(),\n+        commandLineBuilder.build(),\n+        ccCompilationContext.getModulesInfoFiles(usePic),\n+        modulesInfoFile);\n+    ImmutableMap<Artifact, Artifact.DerivedArtifact> moduleFileMap = moduleFileMapBuilder.build();\n+    ImmutableMap<Artifact, Artifact> ddiFileMap = ddiFileMapBuilder.build();\n+    var allModuleFilesBuilder =\n+        NestedSetBuilder.<Artifact.DerivedArtifact>stableOrder().addAll(moduleFileMap.values());\n+    var depModuleFiles = ccCompilationContext.getModuleFiles(usePic);\n+    if (depModuleFiles != null) {\n+      allModuleFilesBuilder.addTransitive(depModuleFiles);\n+    }\n+    var allModuleFiles = allModuleFilesBuilder.build();\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+\n+      Label sourceLabel = source.getLabel();\n+      CppCompileActionBuilder builder = initializeCompileAction(sourceArtifact);\n+      builder.setPicMode(usePic);\n+      builder.setActionName(CppActionNames.CPP20_MODULE_COMPILE);\n+\n+      builder\n+          .addMandatoryInputs(additionalCompilationInputs)\n+          .addAdditionalIncludeScanningRoots(additionalIncludeScanningRoots);\n+\n+      boolean bitcodeOutput =\n+          featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)\n+              && CppFileTypes.LTO_SOURCE.matches(sourceArtifact.getFilename());\n+\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      Artifact.DerivedArtifact moduleFile = moduleFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(moduleFile);\n+      builder.setAdditionalOutputs(ImmutableList.of(moduleFile));\n+      builder.setModuleFiles(allModuleFiles);\n+      if (usePic) {\n+        result.addPicCpp20ModuleFile(moduleFile);\n+      } else {\n+        result.addCpp20ModuleFile(moduleFile);\n+      }\n+\n+      // all -fmodule-file=<module-name>=<path/to/bmi> flags are put in .modmap file\n+      var modmapFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      // all path/to/bmi are put in .modmap.input file,\n+      // which is convenient to get all bmi in CppCompileAction\n+      var modmapInputFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP_INPUT,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      var ddiFile = ddiFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(ddiFile);\n+      createGenModmapAction(ddiFile, modulesInfoFile, modmapFile, modmapInputFile);",
        "comment_created_at": "2025-07-02T10:51:28+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "> The `generate-modmap` tool uses `unsorted_set` extensively, which doesn't guarantee any particular ordering (I am not even sure whether its guaranteed to be deterministic on a single machine).\r\n\r\nGood point; we do need a deterministic iteration order.\r\n\r\n> Could you either use a data structure that preserves insertion order or just use set to get sort order?\r\n\r\nI\u2019ll replace them with `std::set` so the modmap is emitted in a stable, sorted order. I\u2019ll update the patch and add a small test to confirm the output is deterministic.\r\n\r\nThanks for catching this!\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2184563419",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "2169305306",
        "commented_code": "@@ -950,13 +970,287 @@ private ImmutableSet<Artifact> getSourceArtifactsByType(\n     return result.build();\n   }\n \n+  private CcCompilationOutputs createCcCompileActionsWithCpp20Module()\n+      throws RuleErrorException, EvalException, InterruptedException {\n+    Preconditions.checkState(\n+        featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES),\n+        \"to use C++20 Modules, the feature CPP_MODULES must be enabled\");\n+    Preconditions.checkNotNull(ccCompilationContext);\n+    CcCompilationOutputs.Builder result = CcCompilationOutputs.builder();\n+    // merge module interfaces and ordinary sources\n+    Map<Artifact, CppSource> sourcesMap = new LinkedHashMap<>();\n+    sourcesMap.putAll(compilationUnitSources);\n+    sourcesMap.putAll(moduleInterfaceSources);\n+    ImmutableMap<Artifact, String> outputNameMap =\n+        calculateOutputNameMapByType(sourcesMap, /* prefixDir= */ null);\n+    if (generateNoPicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ false, outputNameMap);\n+    }\n+    if (generatePicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ true, outputNameMap);\n+    }\n+    return result.build();\n+  }\n+\n+  private void createCcCompileActionsWithCpp20ModuleHelper(\n+      CcCompilationOutputs.Builder result,\n+      boolean usePic,\n+      ImmutableMap<Artifact, String> outputNameMap)\n+      throws RuleErrorException, EvalException, InterruptedException {\n+\n+    ImmutableMap.Builder<Artifact, Artifact.DerivedArtifact> moduleFileMapBuilder =\n+        new ImmutableMap.Builder<>();\n+    ImmutableMap.Builder<Artifact, Artifact> ddiFileMapBuilder = new ImmutableMap.Builder<>();\n+    NestedSetBuilder<Artifact> ddiFileSetBuilder = NestedSetBuilder.stableOrder();\n+    ImmutableList.Builder<CommandLine> commandLineBuilder = new ImmutableList.Builder<>();\n+\n+    // declare <target-name>.CXXModules.json\n+    // all modules information is put here\n+    Artifact modulesInfoFile =\n+        CppHelper.getCompileOutputArtifact(\n+            actionConstructionContext,\n+            label,\n+            CppHelper.getArtifactNameForCategory(\n+                ccToolchain,\n+                ArtifactCategory.CPP_MODULES_INFO,\n+                getOutputNameBaseWith(label.getName(), usePic)),\n+            configuration);\n+    if (usePic) {\n+      result.addPicModulesInfoFile(modulesInfoFile);\n+    } else {\n+      result.addModulesInfoFile(modulesInfoFile);\n+    }\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      ArtifactCategory outputCategory = ArtifactCategory.CPP_MODULE;\n+      if (Objects.equals(ccToolchain.getCompiler(), \"gcc\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_GCM;\n+      } else if (Objects.equals(ccToolchain.getCompiler(), \"msvc-cl\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_IFC;\n+      }\n+      var moduleFile =\n+          CppHelper.getCompileModuleOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain, outputCategory, getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      moduleFileMapBuilder.put(sourceArtifact, moduleFile);\n+      // dependencies information are put in .ddi file\n+      // the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+      var ddiOutputName =\n+          CppHelper.getArtifactNameForCategory(\n+              ccToolchain,\n+              ArtifactCategory.CPP_MODULES_DDI,\n+              getOutputNameBaseWith(outputName, usePic));\n+      Artifact ddiFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext, label, ddiOutputName, configuration);\n+      commandLineBuilder.add(\n+          CommandLine.of(\n+              ImmutableList.of(\"-d\", ddiFile.getExecPathString(), moduleFile.getExecPathString())));\n+      createScanDepsAction(source.getLabel(), sourceArtifact, usePic, ddiFile, ddiOutputName);\n+      ddiFileSetBuilder.add(ddiFile);\n+      ddiFileMapBuilder.put(sourceArtifact, ddiFile);\n+    }\n+    createAggDdiAction(\n+        ddiFileSetBuilder.build(),\n+        commandLineBuilder.build(),\n+        ccCompilationContext.getModulesInfoFiles(usePic),\n+        modulesInfoFile);\n+    ImmutableMap<Artifact, Artifact.DerivedArtifact> moduleFileMap = moduleFileMapBuilder.build();\n+    ImmutableMap<Artifact, Artifact> ddiFileMap = ddiFileMapBuilder.build();\n+    var allModuleFilesBuilder =\n+        NestedSetBuilder.<Artifact.DerivedArtifact>stableOrder().addAll(moduleFileMap.values());\n+    var depModuleFiles = ccCompilationContext.getModuleFiles(usePic);\n+    if (depModuleFiles != null) {\n+      allModuleFilesBuilder.addTransitive(depModuleFiles);\n+    }\n+    var allModuleFiles = allModuleFilesBuilder.build();\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+\n+      Label sourceLabel = source.getLabel();\n+      CppCompileActionBuilder builder = initializeCompileAction(sourceArtifact);\n+      builder.setPicMode(usePic);\n+      builder.setActionName(CppActionNames.CPP20_MODULE_COMPILE);\n+\n+      builder\n+          .addMandatoryInputs(additionalCompilationInputs)\n+          .addAdditionalIncludeScanningRoots(additionalIncludeScanningRoots);\n+\n+      boolean bitcodeOutput =\n+          featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)\n+              && CppFileTypes.LTO_SOURCE.matches(sourceArtifact.getFilename());\n+\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      Artifact.DerivedArtifact moduleFile = moduleFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(moduleFile);\n+      builder.setAdditionalOutputs(ImmutableList.of(moduleFile));\n+      builder.setModuleFiles(allModuleFiles);\n+      if (usePic) {\n+        result.addPicCpp20ModuleFile(moduleFile);\n+      } else {\n+        result.addCpp20ModuleFile(moduleFile);\n+      }\n+\n+      // all -fmodule-file=<module-name>=<path/to/bmi> flags are put in .modmap file\n+      var modmapFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      // all path/to/bmi are put in .modmap.input file,\n+      // which is convenient to get all bmi in CppCompileAction\n+      var modmapInputFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP_INPUT,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      var ddiFile = ddiFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(ddiFile);\n+      createGenModmapAction(ddiFile, modulesInfoFile, modmapFile, modmapInputFile);",
        "comment_created_at": "2025-07-04T06:55:07+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "see https://github.com/bazelbuild/bazel/pull/26471",
        "pr_file_module": null
      },
      {
        "comment_id": "2194731146",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CcCompilationHelper.java",
        "discussion_id": "2169305306",
        "commented_code": "@@ -950,13 +970,287 @@ private ImmutableSet<Artifact> getSourceArtifactsByType(\n     return result.build();\n   }\n \n+  private CcCompilationOutputs createCcCompileActionsWithCpp20Module()\n+      throws RuleErrorException, EvalException, InterruptedException {\n+    Preconditions.checkState(\n+        featureConfiguration.isEnabled(CppRuleClasses.CPP_MODULES),\n+        \"to use C++20 Modules, the feature CPP_MODULES must be enabled\");\n+    Preconditions.checkNotNull(ccCompilationContext);\n+    CcCompilationOutputs.Builder result = CcCompilationOutputs.builder();\n+    // merge module interfaces and ordinary sources\n+    Map<Artifact, CppSource> sourcesMap = new LinkedHashMap<>();\n+    sourcesMap.putAll(compilationUnitSources);\n+    sourcesMap.putAll(moduleInterfaceSources);\n+    ImmutableMap<Artifact, String> outputNameMap =\n+        calculateOutputNameMapByType(sourcesMap, /* prefixDir= */ null);\n+    if (generateNoPicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ false, outputNameMap);\n+    }\n+    if (generatePicAction) {\n+      createCcCompileActionsWithCpp20ModuleHelper(result, /* usePic= */ true, outputNameMap);\n+    }\n+    return result.build();\n+  }\n+\n+  private void createCcCompileActionsWithCpp20ModuleHelper(\n+      CcCompilationOutputs.Builder result,\n+      boolean usePic,\n+      ImmutableMap<Artifact, String> outputNameMap)\n+      throws RuleErrorException, EvalException, InterruptedException {\n+\n+    ImmutableMap.Builder<Artifact, Artifact.DerivedArtifact> moduleFileMapBuilder =\n+        new ImmutableMap.Builder<>();\n+    ImmutableMap.Builder<Artifact, Artifact> ddiFileMapBuilder = new ImmutableMap.Builder<>();\n+    NestedSetBuilder<Artifact> ddiFileSetBuilder = NestedSetBuilder.stableOrder();\n+    ImmutableList.Builder<CommandLine> commandLineBuilder = new ImmutableList.Builder<>();\n+\n+    // declare <target-name>.CXXModules.json\n+    // all modules information is put here\n+    Artifact modulesInfoFile =\n+        CppHelper.getCompileOutputArtifact(\n+            actionConstructionContext,\n+            label,\n+            CppHelper.getArtifactNameForCategory(\n+                ccToolchain,\n+                ArtifactCategory.CPP_MODULES_INFO,\n+                getOutputNameBaseWith(label.getName(), usePic)),\n+            configuration);\n+    if (usePic) {\n+      result.addPicModulesInfoFile(modulesInfoFile);\n+    } else {\n+      result.addModulesInfoFile(modulesInfoFile);\n+    }\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      ArtifactCategory outputCategory = ArtifactCategory.CPP_MODULE;\n+      if (Objects.equals(ccToolchain.getCompiler(), \"gcc\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_GCM;\n+      } else if (Objects.equals(ccToolchain.getCompiler(), \"msvc-cl\")) {\n+        outputCategory = ArtifactCategory.CPP_MODULE_IFC;\n+      }\n+      var moduleFile =\n+          CppHelper.getCompileModuleOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain, outputCategory, getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      moduleFileMapBuilder.put(sourceArtifact, moduleFile);\n+      // dependencies information are put in .ddi file\n+      // the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+      var ddiOutputName =\n+          CppHelper.getArtifactNameForCategory(\n+              ccToolchain,\n+              ArtifactCategory.CPP_MODULES_DDI,\n+              getOutputNameBaseWith(outputName, usePic));\n+      Artifact ddiFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext, label, ddiOutputName, configuration);\n+      commandLineBuilder.add(\n+          CommandLine.of(\n+              ImmutableList.of(\"-d\", ddiFile.getExecPathString(), moduleFile.getExecPathString())));\n+      createScanDepsAction(source.getLabel(), sourceArtifact, usePic, ddiFile, ddiOutputName);\n+      ddiFileSetBuilder.add(ddiFile);\n+      ddiFileMapBuilder.put(sourceArtifact, ddiFile);\n+    }\n+    createAggDdiAction(\n+        ddiFileSetBuilder.build(),\n+        commandLineBuilder.build(),\n+        ccCompilationContext.getModulesInfoFiles(usePic),\n+        modulesInfoFile);\n+    ImmutableMap<Artifact, Artifact.DerivedArtifact> moduleFileMap = moduleFileMapBuilder.build();\n+    ImmutableMap<Artifact, Artifact> ddiFileMap = ddiFileMapBuilder.build();\n+    var allModuleFilesBuilder =\n+        NestedSetBuilder.<Artifact.DerivedArtifact>stableOrder().addAll(moduleFileMap.values());\n+    var depModuleFiles = ccCompilationContext.getModuleFiles(usePic);\n+    if (depModuleFiles != null) {\n+      allModuleFilesBuilder.addTransitive(depModuleFiles);\n+    }\n+    var allModuleFiles = allModuleFilesBuilder.build();\n+    for (CppSource source : moduleInterfaceSources.values()) {\n+      Artifact sourceArtifact = source.getSource();\n+\n+      Label sourceLabel = source.getLabel();\n+      CppCompileActionBuilder builder = initializeCompileAction(sourceArtifact);\n+      builder.setPicMode(usePic);\n+      builder.setActionName(CppActionNames.CPP20_MODULE_COMPILE);\n+\n+      builder\n+          .addMandatoryInputs(additionalCompilationInputs)\n+          .addAdditionalIncludeScanningRoots(additionalIncludeScanningRoots);\n+\n+      boolean bitcodeOutput =\n+          featureConfiguration.isEnabled(CppRuleClasses.THIN_LTO)\n+              && CppFileTypes.LTO_SOURCE.matches(sourceArtifact.getFilename());\n+\n+      String outputName = outputNameMap.get(sourceArtifact);\n+      Artifact.DerivedArtifact moduleFile = moduleFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(moduleFile);\n+      builder.setAdditionalOutputs(ImmutableList.of(moduleFile));\n+      builder.setModuleFiles(allModuleFiles);\n+      if (usePic) {\n+        result.addPicCpp20ModuleFile(moduleFile);\n+      } else {\n+        result.addCpp20ModuleFile(moduleFile);\n+      }\n+\n+      // all -fmodule-file=<module-name>=<path/to/bmi> flags are put in .modmap file\n+      var modmapFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      // all path/to/bmi are put in .modmap.input file,\n+      // which is convenient to get all bmi in CppCompileAction\n+      var modmapInputFile =\n+          CppHelper.getCompileOutputArtifact(\n+              actionConstructionContext,\n+              label,\n+              CppHelper.getArtifactNameForCategory(\n+                  ccToolchain,\n+                  ArtifactCategory.CPP_MODULES_MODMAP_INPUT,\n+                  getOutputNameBaseWith(outputName, usePic)),\n+              configuration);\n+      var ddiFile = ddiFileMap.get(sourceArtifact);\n+      Preconditions.checkNotNull(ddiFile);\n+      createGenModmapAction(ddiFile, modulesInfoFile, modmapFile, modmapInputFile);",
        "comment_created_at": "2025-07-09T11:05:24+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "Done\r\n\r\nhttps://github.com/bazelbuild/bazel/commit/7638d5360e173ac5f043adc2d55893644cc6f4af",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1949460337",
    "pr_number": 24265,
    "pr_file": "src/main/java/com/google/devtools/build/lib/exec/SpawnStrategyRegistry.java",
    "created_at": "2025-02-10T16:22:42+00:00",
    "commented_code": "}\n   }\n \n+  private static class StrategyPlatformFilter {\n+    private final StrategyMapper strategyMapper;\n+    private final ImmutableMap<Label, ImmutableList<SpawnStrategy>> platformToStrategies;",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1949460337",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24265,
        "pr_file": "src/main/java/com/google/devtools/build/lib/exec/SpawnStrategyRegistry.java",
        "discussion_id": "1949460337",
        "commented_code": "@@ -595,6 +627,46 @@ public String toString() {\n     }\n   }\n \n+  private static class StrategyPlatformFilter {\n+    private final StrategyMapper strategyMapper;\n+    private final ImmutableMap<Label, ImmutableList<SpawnStrategy>> platformToStrategies;",
        "comment_created_at": "2025-02-10T16:22:42+00:00",
        "comment_author": "katre",
        "comment_body": "Use an `com.google.common.collect.ImmutableListMultimap`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175084613",
    "pr_number": 24265,
    "pr_file": "src/main/java/com/google/devtools/build/lib/exec/SpawnStrategyRegistry.java",
    "created_at": "2025-06-30T13:28:17+00:00",
    "commented_code": "}\n   }\n \n+  private static class StrategyPlatformFilter {\n+    private final StrategyMapper strategyMapper;\n+    private final ImmutableListMultimap<Label, SpawnStrategy> platformToStrategies;\n+\n+    private StrategyPlatformFilter(\n+      StrategyMapper strategyMapper,\n+      ImmutableListMultimap<Label, SpawnStrategy> platformToStrategies) {\n+      this.strategyMapper = strategyMapper;\n+      this.platformToStrategies = platformToStrategies;\n+    }\n+\n+    public <T extends SpawnStrategy> List<T> getStrategies(\n+        Spawn spawn, List<T> candidateStrategies) {\n+      var platformLabel = spawn.getExecutionPlatformLabel();\n+      Preconditions.checkNotNull(platformLabel, \"Attempting to spawn action without an execution platform.\");\n+\n+      if (platformToStrategies.containsKey(platformLabel)) {\n+        var allowedStrategies = platformToStrategies.get(platformLabel);\n+        List<T> filteredStrategies = new ArrayList<>();\n+        for (var strategy : candidateStrategies) {\n+          if (allowedStrategies.contains(strategy)) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2175084613",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24265,
        "pr_file": "src/main/java/com/google/devtools/build/lib/exec/SpawnStrategyRegistry.java",
        "discussion_id": "2175084613",
        "commented_code": "@@ -595,6 +631,51 @@ public String toString() {\n     }\n   }\n \n+  private static class StrategyPlatformFilter {\n+    private final StrategyMapper strategyMapper;\n+    private final ImmutableListMultimap<Label, SpawnStrategy> platformToStrategies;\n+\n+    private StrategyPlatformFilter(\n+      StrategyMapper strategyMapper,\n+      ImmutableListMultimap<Label, SpawnStrategy> platformToStrategies) {\n+      this.strategyMapper = strategyMapper;\n+      this.platformToStrategies = platformToStrategies;\n+    }\n+\n+    public <T extends SpawnStrategy> List<T> getStrategies(\n+        Spawn spawn, List<T> candidateStrategies) {\n+      var platformLabel = spawn.getExecutionPlatformLabel();\n+      Preconditions.checkNotNull(platformLabel, \"Attempting to spawn action without an execution platform.\");\n+\n+      if (platformToStrategies.containsKey(platformLabel)) {\n+        var allowedStrategies = platformToStrategies.get(platformLabel);\n+        List<T> filteredStrategies = new ArrayList<>();\n+        for (var strategy : candidateStrategies) {\n+          if (allowedStrategies.contains(strategy)) {",
        "comment_created_at": "2025-06-30T13:28:17+00:00",
        "comment_author": "katre",
        "comment_body": "This is treating the `allowedStrategies` as a set, and ignoring the ordering.\r\n\r\na) I assumed that `--allowed_strategies_by_exec_platform=@platforms//host=sandbox,standalone` implies that sandbox is preferred over standalone: is that not the intended semantics?\r\nb) Is something else (possibly the ordering in`candidateStrategies` enforcing that?\r\n\r\nI am specifically interested in the case where the flags are `--spawn_strategy=standalone,sandbox --allowed_strategies_by_exec_platform=@platforms//host=sandbox,standalone` (ie, they are reversed between the flags). I assume that if the platform matches, the ordering from `--allowed_strategies_by_exec_platform` has precedence. Please confirm if this is intended, and make sure the code enforces it (and consider adding a test for this case).",
        "pr_file_module": null
      },
      {
        "comment_id": "2202318224",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24265,
        "pr_file": "src/main/java/com/google/devtools/build/lib/exec/SpawnStrategyRegistry.java",
        "discussion_id": "2175084613",
        "commented_code": "@@ -595,6 +631,51 @@ public String toString() {\n     }\n   }\n \n+  private static class StrategyPlatformFilter {\n+    private final StrategyMapper strategyMapper;\n+    private final ImmutableListMultimap<Label, SpawnStrategy> platformToStrategies;\n+\n+    private StrategyPlatformFilter(\n+      StrategyMapper strategyMapper,\n+      ImmutableListMultimap<Label, SpawnStrategy> platformToStrategies) {\n+      this.strategyMapper = strategyMapper;\n+      this.platformToStrategies = platformToStrategies;\n+    }\n+\n+    public <T extends SpawnStrategy> List<T> getStrategies(\n+        Spawn spawn, List<T> candidateStrategies) {\n+      var platformLabel = spawn.getExecutionPlatformLabel();\n+      Preconditions.checkNotNull(platformLabel, \"Attempting to spawn action without an execution platform.\");\n+\n+      if (platformToStrategies.containsKey(platformLabel)) {\n+        var allowedStrategies = platformToStrategies.get(platformLabel);\n+        List<T> filteredStrategies = new ArrayList<>();\n+        for (var strategy : candidateStrategies) {\n+          if (allowedStrategies.contains(strategy)) {",
        "comment_created_at": "2025-07-12T04:48:42+00:00",
        "comment_author": "Silic0nS0ldier",
        "comment_body": "The intent was that `--allowed_strategies_by_exec_platform` only served to filter out disallowed strategies, preserving order of candidate strategies. That said this was not accounted for in the proposal, documentation nor covered by tests. Good catch!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2087283873",
    "pr_number": 26056,
    "pr_file": "src/main/java/com/google/devtools/common/options/RegexPatternOption.java",
    "created_at": "2025-05-13T17:06:45+00:00",
    "commented_code": "@AutoValue\n public abstract class RegexPatternOption {\n   static RegexPatternOption create(Pattern regexPattern) {\n-    return new AutoValue_RegexPatternOption(Preconditions.checkNotNull(regexPattern));\n+    return new AutoValue_RegexPatternOption(\n+        Preconditions.checkNotNull(regexPattern), RegexUtil.asOptimizedMatchingPredicate(regexPattern));\n   }\n \n+  /** The original regex pattern. */\n   public abstract Pattern regexPattern();",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2087283873",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26056,
        "pr_file": "src/main/java/com/google/devtools/common/options/RegexPatternOption.java",
        "discussion_id": "2087283873",
        "commented_code": "@@ -29,11 +31,19 @@\n @AutoValue\n public abstract class RegexPatternOption {\n   static RegexPatternOption create(Pattern regexPattern) {\n-    return new AutoValue_RegexPatternOption(Preconditions.checkNotNull(regexPattern));\n+    return new AutoValue_RegexPatternOption(\n+        Preconditions.checkNotNull(regexPattern), RegexUtil.asOptimizedMatchingPredicate(regexPattern));\n   }\n \n+  /** The original regex pattern. */\n   public abstract Pattern regexPattern();",
        "comment_created_at": "2025-05-13T17:06:45+00:00",
        "comment_author": "fmeum",
        "comment_body": "@tjgq This made me realize that the internal string encoding can cause Unicode matchers in regex to not match as expected. To be fully correct, we would need to reencode all paths before matching them and also reencode the pattern. Do you think that's relevant enough to change? (just to be clear, this is preexisting)",
        "pr_file_module": null
      },
      {
        "comment_id": "2088719426",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26056,
        "pr_file": "src/main/java/com/google/devtools/common/options/RegexPatternOption.java",
        "discussion_id": "2087283873",
        "commented_code": "@@ -29,11 +31,19 @@\n @AutoValue\n public abstract class RegexPatternOption {\n   static RegexPatternOption create(Pattern regexPattern) {\n-    return new AutoValue_RegexPatternOption(Preconditions.checkNotNull(regexPattern));\n+    return new AutoValue_RegexPatternOption(\n+        Preconditions.checkNotNull(regexPattern), RegexUtil.asOptimizedMatchingPredicate(regexPattern));\n   }\n \n+  /** The original regex pattern. */\n   public abstract Pattern regexPattern();",
        "comment_created_at": "2025-05-14T11:29:12+00:00",
        "comment_author": "tjgq",
        "comment_body": "Yeah, I think it's worth fixing in a separate PR (alternatively, please file an issue if you don't plan to fix it for now).",
        "pr_file_module": null
      },
      {
        "comment_id": "2089421148",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26056,
        "pr_file": "src/main/java/com/google/devtools/common/options/RegexPatternOption.java",
        "discussion_id": "2087283873",
        "commented_code": "@@ -29,11 +31,19 @@\n @AutoValue\n public abstract class RegexPatternOption {\n   static RegexPatternOption create(Pattern regexPattern) {\n-    return new AutoValue_RegexPatternOption(Preconditions.checkNotNull(regexPattern));\n+    return new AutoValue_RegexPatternOption(\n+        Preconditions.checkNotNull(regexPattern), RegexUtil.asOptimizedMatchingPredicate(regexPattern));\n   }\n \n+  /** The original regex pattern. */\n   public abstract Pattern regexPattern();",
        "comment_created_at": "2025-05-14T17:32:23+00:00",
        "comment_author": "fmeum",
        "comment_body": "https://github.com/bazelbuild/bazel/issues/26070",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2088759741",
    "pr_number": 26056,
    "pr_file": "src/main/java/com/google/devtools/build/lib/util/RegexUtil.java",
    "created_at": "2025-05-14T11:53:57+00:00",
    "commented_code": "+package com.google.devtools.build.lib.util;\n+\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/** A utility class for regex-related operations. */\n+public final class RegexUtil {\n+  // If a regex pattern matches this pattern, it matches like a literal string after unescaping\n+  // dots. Both `\\` and `.` are disallowed unless they appear as `\\.`.\n+  private static final Pattern LITERAL_PATTERN_WITH_DOT_UNESCAPED =\n+      Pattern.compile(\"(?:[^\\\\[\\\\](){}^$|*+?.\\\\\\\\]|\\\\\\\\\\\\.)*\");\n+\n+  // If a regex matches this pattern, it matches on the suffix of a string. We need to rule out\n+  // possessive and reluctant quantifiers, which are the only possible characters after the \".*\"\n+  // prefix that make it unsafe to drop.\n+  private static final Pattern EXTRACT_SUFFIX_MATCH =\n+      Pattern.compile(\"\\\\^?\\\\.\\\\*(?<suffix>[^?+].*)?\");\n+\n+  /**\n+   * Returns a {@link Predicate} that matches the input string against the regex pattern with the\n+   * same semantics as {@link Matcher#matches()}, but more optimized and as if the pattern was\n+   * compiled with {@link Pattern#DOTALL} and {@link Pattern#UNIX_LINES}.\n+   */\n+  public static Predicate<String> asOptimizedMatchingPredicate(Pattern regexPattern) {\n+    String pattern = regexPattern.pattern();\n+    if (pattern.contains(\"|\") || pattern.contains(\"\\\\Q\")) {\n+      // Alternations make it so that appending \"$\" may not force a match to the end.\n+      // Unmatched \\Q...\\E sequences can have the same effect.\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    // Recognize a pattern that starts with \".*\" and drop it so that the engine sees the next part\n+    // of the pattern as the beginning and potentially optimizes the literal search.\n+    // We don't apply the same transformation to the end of the pattern since it is harder to\n+    // determine if a \".*\" suffix is safe to drop due to backslash escapes.\n+    Matcher suffixMatch = EXTRACT_SUFFIX_MATCH.matcher(pattern);\n+    if (!suffixMatch.matches()) {\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    String suffixPattern = suffixMatch.group(\"suffix\");\n+    // A null suffixPattern implies the regex is equivalent to \".*\", which matches any input string.\n+    if (suffixPattern == null) {\n+      return s -> true;\n+    }\n+    // If the pattern matches a literal suffix, optimize to a string suffix\n+    // match, which is by far the fastest way to match.\n+    if (LITERAL_PATTERN_WITH_DOT_UNESCAPED.matcher(suffixPattern).matches()) {\n+      String literalSuffix = suffixPattern.replace(\"\\\\.\", \".\");\n+      return s -> s.endsWith(literalSuffix);\n+    }\n+    // Turn the \"match\" pattern into an equivalent \"find\" pattern, since these are the only ones\n+    // that benefit from the Boyer-Moore optimization in the Java regex engine.\n+    // https://github.com/openjdk/jdk/blob/50dced88ff1aed23bb4c8fe9e4a08e6cc200b897/src/java.base/share/classes/java/util/regex/Pattern.java#L1959-L1969\n+    // Guard against the surprising edge case where $ can match right before a single final line\n+    // terminator (only \n due to Pattern.UNIX_LINES).",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2088759741",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26056,
        "pr_file": "src/main/java/com/google/devtools/build/lib/util/RegexUtil.java",
        "discussion_id": "2088759741",
        "commented_code": "@@ -0,0 +1,62 @@\n+package com.google.devtools.build.lib.util;\n+\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/** A utility class for regex-related operations. */\n+public final class RegexUtil {\n+  // If a regex pattern matches this pattern, it matches like a literal string after unescaping\n+  // dots. Both `\\` and `.` are disallowed unless they appear as `\\.`.\n+  private static final Pattern LITERAL_PATTERN_WITH_DOT_UNESCAPED =\n+      Pattern.compile(\"(?:[^\\\\[\\\\](){}^$|*+?.\\\\\\\\]|\\\\\\\\\\\\.)*\");\n+\n+  // If a regex matches this pattern, it matches on the suffix of a string. We need to rule out\n+  // possessive and reluctant quantifiers, which are the only possible characters after the \".*\"\n+  // prefix that make it unsafe to drop.\n+  private static final Pattern EXTRACT_SUFFIX_MATCH =\n+      Pattern.compile(\"\\\\^?\\\\.\\\\*(?<suffix>[^?+].*)?\");\n+\n+  /**\n+   * Returns a {@link Predicate} that matches the input string against the regex pattern with the\n+   * same semantics as {@link Matcher#matches()}, but more optimized and as if the pattern was\n+   * compiled with {@link Pattern#DOTALL} and {@link Pattern#UNIX_LINES}.\n+   */\n+  public static Predicate<String> asOptimizedMatchingPredicate(Pattern regexPattern) {\n+    String pattern = regexPattern.pattern();\n+    if (pattern.contains(\"|\") || pattern.contains(\"\\\\Q\")) {\n+      // Alternations make it so that appending \"$\" may not force a match to the end.\n+      // Unmatched \\Q...\\E sequences can have the same effect.\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    // Recognize a pattern that starts with \".*\" and drop it so that the engine sees the next part\n+    // of the pattern as the beginning and potentially optimizes the literal search.\n+    // We don't apply the same transformation to the end of the pattern since it is harder to\n+    // determine if a \".*\" suffix is safe to drop due to backslash escapes.\n+    Matcher suffixMatch = EXTRACT_SUFFIX_MATCH.matcher(pattern);\n+    if (!suffixMatch.matches()) {\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    String suffixPattern = suffixMatch.group(\"suffix\");\n+    // A null suffixPattern implies the regex is equivalent to \".*\", which matches any input string.\n+    if (suffixPattern == null) {\n+      return s -> true;\n+    }\n+    // If the pattern matches a literal suffix, optimize to a string suffix\n+    // match, which is by far the fastest way to match.\n+    if (LITERAL_PATTERN_WITH_DOT_UNESCAPED.matcher(suffixPattern).matches()) {\n+      String literalSuffix = suffixPattern.replace(\"\\\\.\", \".\");\n+      return s -> s.endsWith(literalSuffix);\n+    }\n+    // Turn the \"match\" pattern into an equivalent \"find\" pattern, since these are the only ones\n+    // that benefit from the Boyer-Moore optimization in the Java regex engine.\n+    // https://github.com/openjdk/jdk/blob/50dced88ff1aed23bb4c8fe9e4a08e6cc200b897/src/java.base/share/classes/java/util/regex/Pattern.java#L1959-L1969\n+    // Guard against the surprising edge case where $ can match right before a single final line\n+    // terminator (only \\n due to Pattern.UNIX_LINES).",
        "comment_created_at": "2025-05-14T11:53:57+00:00",
        "comment_author": "tjgq",
        "comment_body": "But why do we need to compile the regex with `Pattern.UNIX_LINES` to begin with? If we omitted it, wouldn't `^$` match only against the beginning/end of input? This is my understanding of the `Pattern` documentation, and it seems to be experimentally true (`Pattern.compile(\"abc$\").matcher().match(\"abc\\n\")` is false).",
        "pr_file_module": null
      },
      {
        "comment_id": "2089271882",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26056,
        "pr_file": "src/main/java/com/google/devtools/build/lib/util/RegexUtil.java",
        "discussion_id": "2088759741",
        "commented_code": "@@ -0,0 +1,62 @@\n+package com.google.devtools.build.lib.util;\n+\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/** A utility class for regex-related operations. */\n+public final class RegexUtil {\n+  // If a regex pattern matches this pattern, it matches like a literal string after unescaping\n+  // dots. Both `\\` and `.` are disallowed unless they appear as `\\.`.\n+  private static final Pattern LITERAL_PATTERN_WITH_DOT_UNESCAPED =\n+      Pattern.compile(\"(?:[^\\\\[\\\\](){}^$|*+?.\\\\\\\\]|\\\\\\\\\\\\.)*\");\n+\n+  // If a regex matches this pattern, it matches on the suffix of a string. We need to rule out\n+  // possessive and reluctant quantifiers, which are the only possible characters after the \".*\"\n+  // prefix that make it unsafe to drop.\n+  private static final Pattern EXTRACT_SUFFIX_MATCH =\n+      Pattern.compile(\"\\\\^?\\\\.\\\\*(?<suffix>[^?+].*)?\");\n+\n+  /**\n+   * Returns a {@link Predicate} that matches the input string against the regex pattern with the\n+   * same semantics as {@link Matcher#matches()}, but more optimized and as if the pattern was\n+   * compiled with {@link Pattern#DOTALL} and {@link Pattern#UNIX_LINES}.\n+   */\n+  public static Predicate<String> asOptimizedMatchingPredicate(Pattern regexPattern) {\n+    String pattern = regexPattern.pattern();\n+    if (pattern.contains(\"|\") || pattern.contains(\"\\\\Q\")) {\n+      // Alternations make it so that appending \"$\" may not force a match to the end.\n+      // Unmatched \\Q...\\E sequences can have the same effect.\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    // Recognize a pattern that starts with \".*\" and drop it so that the engine sees the next part\n+    // of the pattern as the beginning and potentially optimizes the literal search.\n+    // We don't apply the same transformation to the end of the pattern since it is harder to\n+    // determine if a \".*\" suffix is safe to drop due to backslash escapes.\n+    Matcher suffixMatch = EXTRACT_SUFFIX_MATCH.matcher(pattern);\n+    if (!suffixMatch.matches()) {\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    String suffixPattern = suffixMatch.group(\"suffix\");\n+    // A null suffixPattern implies the regex is equivalent to \".*\", which matches any input string.\n+    if (suffixPattern == null) {\n+      return s -> true;\n+    }\n+    // If the pattern matches a literal suffix, optimize to a string suffix\n+    // match, which is by far the fastest way to match.\n+    if (LITERAL_PATTERN_WITH_DOT_UNESCAPED.matcher(suffixPattern).matches()) {\n+      String literalSuffix = suffixPattern.replace(\"\\\\.\", \".\");\n+      return s -> s.endsWith(literalSuffix);\n+    }\n+    // Turn the \"match\" pattern into an equivalent \"find\" pattern, since these are the only ones\n+    // that benefit from the Boyer-Moore optimization in the Java regex engine.\n+    // https://github.com/openjdk/jdk/blob/50dced88ff1aed23bb4c8fe9e4a08e6cc200b897/src/java.base/share/classes/java/util/regex/Pattern.java#L1959-L1969\n+    // Guard against the surprising edge case where $ can match right before a single final line\n+    // terminator (only \\n due to Pattern.UNIX_LINES).",
        "comment_created_at": "2025-05-14T15:57:19+00:00",
        "comment_author": "fmeum",
        "comment_body": "While `Pattern.compile(\"abc$\").matcher(\"abc\\n\").matches()` is `false`, `Pattern.compile(\"abc$\").matcher(\"abc\\n\").find()` is `true`. That's because `$` does indeed match *before* a final line terminator (which contradicts the docs, I think), but the implicit anchoring bounds of `matches` still result in `false` since the line terminator itself remains unmatched.\r\n\r\nThat's why we need the negative lookahead and `UNIX_LINES` just happens to simplify that lookahead as we only have to match a single character.\r\n\r\n(If you agree that the docs are wrong, let me know and I'll send a PR to the JDK)",
        "pr_file_module": null
      },
      {
        "comment_id": "2089640171",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26056,
        "pr_file": "src/main/java/com/google/devtools/build/lib/util/RegexUtil.java",
        "discussion_id": "2088759741",
        "commented_code": "@@ -0,0 +1,62 @@\n+package com.google.devtools.build.lib.util;\n+\n+import java.util.function.Predicate;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/** A utility class for regex-related operations. */\n+public final class RegexUtil {\n+  // If a regex pattern matches this pattern, it matches like a literal string after unescaping\n+  // dots. Both `\\` and `.` are disallowed unless they appear as `\\.`.\n+  private static final Pattern LITERAL_PATTERN_WITH_DOT_UNESCAPED =\n+      Pattern.compile(\"(?:[^\\\\[\\\\](){}^$|*+?.\\\\\\\\]|\\\\\\\\\\\\.)*\");\n+\n+  // If a regex matches this pattern, it matches on the suffix of a string. We need to rule out\n+  // possessive and reluctant quantifiers, which are the only possible characters after the \".*\"\n+  // prefix that make it unsafe to drop.\n+  private static final Pattern EXTRACT_SUFFIX_MATCH =\n+      Pattern.compile(\"\\\\^?\\\\.\\\\*(?<suffix>[^?+].*)?\");\n+\n+  /**\n+   * Returns a {@link Predicate} that matches the input string against the regex pattern with the\n+   * same semantics as {@link Matcher#matches()}, but more optimized and as if the pattern was\n+   * compiled with {@link Pattern#DOTALL} and {@link Pattern#UNIX_LINES}.\n+   */\n+  public static Predicate<String> asOptimizedMatchingPredicate(Pattern regexPattern) {\n+    String pattern = regexPattern.pattern();\n+    if (pattern.contains(\"|\") || pattern.contains(\"\\\\Q\")) {\n+      // Alternations make it so that appending \"$\" may not force a match to the end.\n+      // Unmatched \\Q...\\E sequences can have the same effect.\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    // Recognize a pattern that starts with \".*\" and drop it so that the engine sees the next part\n+    // of the pattern as the beginning and potentially optimizes the literal search.\n+    // We don't apply the same transformation to the end of the pattern since it is harder to\n+    // determine if a \".*\" suffix is safe to drop due to backslash escapes.\n+    Matcher suffixMatch = EXTRACT_SUFFIX_MATCH.matcher(pattern);\n+    if (!suffixMatch.matches()) {\n+      return s -> regexPattern.matcher(s).matches();\n+    }\n+    String suffixPattern = suffixMatch.group(\"suffix\");\n+    // A null suffixPattern implies the regex is equivalent to \".*\", which matches any input string.\n+    if (suffixPattern == null) {\n+      return s -> true;\n+    }\n+    // If the pattern matches a literal suffix, optimize to a string suffix\n+    // match, which is by far the fastest way to match.\n+    if (LITERAL_PATTERN_WITH_DOT_UNESCAPED.matcher(suffixPattern).matches()) {\n+      String literalSuffix = suffixPattern.replace(\"\\\\.\", \".\");\n+      return s -> s.endsWith(literalSuffix);\n+    }\n+    // Turn the \"match\" pattern into an equivalent \"find\" pattern, since these are the only ones\n+    // that benefit from the Boyer-Moore optimization in the Java regex engine.\n+    // https://github.com/openjdk/jdk/blob/50dced88ff1aed23bb4c8fe9e4a08e6cc200b897/src/java.base/share/classes/java/util/regex/Pattern.java#L1959-L1969\n+    // Guard against the surprising edge case where $ can match right before a single final line\n+    // terminator (only \\n due to Pattern.UNIX_LINES).",
        "comment_created_at": "2025-05-14T19:53:28+00:00",
        "comment_author": "tjgq",
        "comment_body": "Nevermind, I re-read the `Pattern` documentation and it does vindicate the `find` behavior:\r\n\r\n```\r\nIf MULTILINE mode is not activated, the regular expression ^ ignores line terminators and only matches at the beginning of the entire input sequence. The regular expression $ matches at the end of the entire input sequence, but also matches just before the last line terminator if this is not followed by any other input character.\r\n```\r\n\r\ni.e., the treatment of line terminators is not the same for `^` and `$`.\r\n\r\nAnother alternative would be to use `\\z` instead of `$` which *I believe* doesn't suffer from the final line terminator edge case even for `find` (but the current version with lookahead is fine too).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1242294098",
    "pr_number": 18669,
    "pr_file": "src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java",
    "created_at": "2023-06-26T14:29:44+00:00",
    "commented_code": "private final AtomicBoolean shutdown = new AtomicBoolean(false);\n   private final AtomicBoolean buildInterrupted = new AtomicBoolean(false);\n \n+  private boolean isActionCompatibleWithXPlatformCache(Spawn spawn) {\n+    String repo = spawn.getResourceOwner().getOwner().getLabel().getPackageIdentifier().getRepository().getName();\n+    if (!repo.isEmpty()) {\n+      return false;\n+    }\n+    String mnemonic = spawn.getResourceOwner().getMnemonic();\n+    return remoteOptions.remoteXPlatSupportedMnemonics.contains(mnemonic);\n+  }\n+\n+  private boolean isInputRemovedForXPlatform(PathFragment pathFragment) {\n+    String path = pathFragment.getPathString();\n+    return remoteOptions.remoteXPlatRemovedInputs.stream().anyMatch(s -> path.indexOf(s) >= 0);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1242294098",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 18669,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/RemoteExecutionService.java",
        "discussion_id": "1242294098",
        "commented_code": "@@ -175,6 +176,25 @@ public class RemoteExecutionService {\n   private final AtomicBoolean shutdown = new AtomicBoolean(false);\n   private final AtomicBoolean buildInterrupted = new AtomicBoolean(false);\n \n+  private boolean isActionCompatibleWithXPlatformCache(Spawn spawn) {\n+    String repo = spawn.getResourceOwner().getOwner().getLabel().getPackageIdentifier().getRepository().getName();\n+    if (!repo.isEmpty()) {\n+      return false;\n+    }\n+    String mnemonic = spawn.getResourceOwner().getMnemonic();\n+    return remoteOptions.remoteXPlatSupportedMnemonics.contains(mnemonic);\n+  }\n+\n+  private boolean isInputRemovedForXPlatform(PathFragment pathFragment) {\n+    String path = pathFragment.getPathString();\n+    return remoteOptions.remoteXPlatRemovedInputs.stream().anyMatch(s -> path.indexOf(s) >= 0);",
        "comment_created_at": "2023-06-26T14:29:44+00:00",
        "comment_author": "arunkumar9t2",
        "comment_body": "Similar to https://github.com/bazelbuild/bazel/pull/15638 if we use regex here, it could simplify declaration when we have lot of inputs to exclude.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1955776304",
    "pr_number": 25280,
    "pr_file": "src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleResolutionFunctionTest.java",
    "created_at": "2025-02-14T08:56:36+00:00",
    "commented_code": "assertDoesNotContainEvent(\"hello from b@1.0\");\n     assertDoesNotContainEvent(\"hello from b@1.1\");\n   }\n+\n+  @Test\n+  public void nodep_unfulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0',repo_name=None)\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1')\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).doesNotContainKey(createModuleKey(\"c\", \"1.0\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.0\"));\n+  }\n+\n+  @Test\n+  public void nodep_fulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0')\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1',repo_name=None)\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).containsKey(createModuleKey(\"d\", \"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"c\", \"1.0\")).getDeps()).doesNotContainKey(\"d\");\n+  }\n+\n+  @Test\n+  public void nodep_crossesCompatLevelBoundary() throws Exception {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1955776304",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25280,
        "pr_file": "src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleResolutionFunctionTest.java",
        "discussion_id": "1955776304",
        "commented_code": "@@ -365,4 +366,106 @@ public void testPrintBehavior() throws Exception {\n     assertDoesNotContainEvent(\"hello from b@1.0\");\n     assertDoesNotContainEvent(\"hello from b@1.1\");\n   }\n+\n+  @Test\n+  public void nodep_unfulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0',repo_name=None)\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1')\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).doesNotContainKey(createModuleKey(\"c\", \"1.0\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.0\"));\n+  }\n+\n+  @Test\n+  public void nodep_fulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0')\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1',repo_name=None)\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).containsKey(createModuleKey(\"d\", \"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"c\", \"1.0\")).getDeps()).doesNotContainKey(\"d\");\n+  }\n+\n+  @Test\n+  public void nodep_crossesCompatLevelBoundary() throws Exception {",
        "comment_created_at": "2025-02-14T08:56:36+00:00",
        "comment_author": "fmeum",
        "comment_body": "Could you add a test for a fulfilled no-dep that crosses a compat level boundary (and thus causes the build to fail)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1962778005",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25280,
        "pr_file": "src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleResolutionFunctionTest.java",
        "discussion_id": "1955776304",
        "commented_code": "@@ -365,4 +366,106 @@ public void testPrintBehavior() throws Exception {\n     assertDoesNotContainEvent(\"hello from b@1.0\");\n     assertDoesNotContainEvent(\"hello from b@1.1\");\n   }\n+\n+  @Test\n+  public void nodep_unfulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0',repo_name=None)\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1')\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).doesNotContainKey(createModuleKey(\"c\", \"1.0\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.0\"));\n+  }\n+\n+  @Test\n+  public void nodep_fulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0')\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1',repo_name=None)\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).containsKey(createModuleKey(\"d\", \"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"c\", \"1.0\")).getDeps()).doesNotContainKey(\"d\");\n+  }\n+\n+  @Test\n+  public void nodep_crossesCompatLevelBoundary() throws Exception {",
        "comment_created_at": "2025-02-20T02:44:07+00:00",
        "comment_author": "Wyverald",
        "comment_body": "maybe I'm misunderstanding you, but a nodep edge crossing compat level boundaries is ignored (like this test asserts) unless there's a yes-dep edge cross that compat level boundary too. But that would be a moot test because there would be an error with or without the nodep edge.",
        "pr_file_module": null
      },
      {
        "comment_id": "1963539908",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25280,
        "pr_file": "src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleResolutionFunctionTest.java",
        "discussion_id": "1955776304",
        "commented_code": "@@ -365,4 +366,106 @@ public void testPrintBehavior() throws Exception {\n     assertDoesNotContainEvent(\"hello from b@1.0\");\n     assertDoesNotContainEvent(\"hello from b@1.1\");\n   }\n+\n+  @Test\n+  public void nodep_unfulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0',repo_name=None)\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1')\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).doesNotContainKey(createModuleKey(\"c\", \"1.0\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.0\"));\n+  }\n+\n+  @Test\n+  public void nodep_fulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0')\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1',repo_name=None)\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).containsKey(createModuleKey(\"d\", \"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"c\", \"1.0\")).getDeps()).doesNotContainKey(\"d\");\n+  }\n+\n+  @Test\n+  public void nodep_crossesCompatLevelBoundary() throws Exception {",
        "comment_created_at": "2025-02-20T13:11:06+00:00",
        "comment_author": "fmeum",
        "comment_body": "Sorry for the confusion, it took me some time to figure out how to specify the behavior I would like to see. It's not directly related to compatibility level crossing, but its implementation may constrain how we handle that.\r\n\r\nI would like to see the following test pass (when pasted into `DiscoveryTest.java`). Crucically, `ddd@1.0` never has its module file downloaded and also doesn't show up in the dep graph. This would make nodeps even less costly to add. \r\n\r\nIf we can't get this behavior that's also fine, I would just like to make sure we have tried at a point where we won't need a backwards incompatible change.\r\n\r\n```java\r\n  @Test\r\n  public void testNodep_ineffectiveUpdate() throws Exception {\r\n    scratch.file(\r\n        workspaceRoot.getRelative(\"MODULE.bazel\").getPathString(),\r\n        \"\"\"\r\n        module(name='aaa',version='0.1')\r\n        bazel_dep(name='bbb',version='1.0')\r\n        bazel_dep(name='ccc',version='1.0')\r\n        \"\"\");\r\n\r\n    FakeRegistry registry =\r\n        registryFactory\r\n            .newFakeRegistry(\"/foo\")\r\n            .addModule(\r\n                createModuleKey(\"bbb\", \"1.0\"),\r\n                \"module(name='bbb', version='1.0');bazel_dep(name='ddd', version='2.0')\")\r\n            .addModule(\r\n                createModuleKey(\"ccc\", \"1.0\"),\r\n                \"module(name='ccc', version='1.0');bazel_dep(name='ddd',version='1.0',repo_name=None)\")\r\n            .addModule(createModuleKey(\"ddd\", \"1.0\"), \"module(name='ddd', version='1.0')\")\r\n            .addModule(createModuleKey(\"ddd\", \"2.0\"), \"module(name='ddd', version='2.0')\");\r\n    ModuleFileFunction.REGISTRIES.set(differencer, ImmutableSet.of(registry.getUrl()));\r\n\r\n    EvaluationResult<DiscoveryValue> result =\r\n        evaluator.evaluate(ImmutableList.of(DiscoveryValue.KEY), evaluationContext);\r\n    if (result.hasError()) {\r\n      fail(result.getError().toString());\r\n    }\r\n    DiscoveryValue discoveryValue = result.get(DiscoveryValue.KEY);\r\n    assertThat(discoveryValue.depGraph().entrySet())\r\n        .containsExactly(\r\n            InterimModuleBuilder.create(\"aaa\", \"0.1\")\r\n                .setKey(ModuleKey.ROOT)\r\n                .addDep(\"bbb\", createModuleKey(\"bbb\", \"1.0\"))\r\n                .addDep(\"ccc\", createModuleKey(\"ccc\", \"1.0\"))\r\n                .buildEntry(),\r\n            InterimModuleBuilder.create(\"bbb\", \"1.0\")\r\n                .addDep(\"ddd\", createModuleKey(\"ddd\", \"2.0\"))\r\n                .setRegistry(registry)\r\n                .buildEntry(),\r\n            InterimModuleBuilder.create(\"ccc\", \"1.0\")\r\n                .setRegistry(registry)\r\n                .addNodepDep(createModuleKey(\"ddd\", \"1.0\"))\r\n                .buildEntry(),\r\n            InterimModuleBuilder.create(\"ddd\", \"2.0\").setRegistry(registry).buildEntry());\r\n    assertThat(discoveryValue.registryFileHashes().keySet())\r\n        .containsExactly(\r\n            registry.getUrl() + \"/modules/bbb/1.0/MODULE.bazel\",\r\n            registry.getUrl() + \"/modules/ccc/1.0/MODULE.bazel\",\r\n            registry.getUrl() + \"/modules/ddd/2.0/MODULE.bazel\");\r\n  }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1964233542",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25280,
        "pr_file": "src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleResolutionFunctionTest.java",
        "discussion_id": "1955776304",
        "commented_code": "@@ -365,4 +366,106 @@ public void testPrintBehavior() throws Exception {\n     assertDoesNotContainEvent(\"hello from b@1.0\");\n     assertDoesNotContainEvent(\"hello from b@1.1\");\n   }\n+\n+  @Test\n+  public void nodep_unfulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0',repo_name=None)\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1')\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).doesNotContainKey(createModuleKey(\"c\", \"1.0\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.0\"));\n+  }\n+\n+  @Test\n+  public void nodep_fulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0')\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1',repo_name=None)\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).containsKey(createModuleKey(\"d\", \"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"c\", \"1.0\")).getDeps()).doesNotContainKey(\"d\");\n+  }\n+\n+  @Test\n+  public void nodep_crossesCompatLevelBoundary() throws Exception {",
        "comment_created_at": "2025-02-20T19:41:12+00:00",
        "comment_author": "Wyverald",
        "comment_body": "I have reservations about such a test case because\r\n\r\n1) it's technically unsafe to assert that a lower version cannot possibly affect the dependency graph, since a lower version can have a higher version of a dep. (See my other comment.)\r\n2) yes-dep edges have the same behavior -- if the `ccc@1.0->ddd@1.0` edge in your test case were a normal bazel_dep, we would also not skip that edge. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1967232333",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25280,
        "pr_file": "src/test/java/com/google/devtools/build/lib/bazel/bzlmod/BazelModuleResolutionFunctionTest.java",
        "discussion_id": "1955776304",
        "commented_code": "@@ -365,4 +366,106 @@ public void testPrintBehavior() throws Exception {\n     assertDoesNotContainEvent(\"hello from b@1.0\");\n     assertDoesNotContainEvent(\"hello from b@1.1\");\n   }\n+\n+  @Test\n+  public void nodep_unfulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0',repo_name=None)\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1')\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).doesNotContainKey(createModuleKey(\"c\", \"1.0\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.0\"));\n+  }\n+\n+  @Test\n+  public void nodep_fulfilled() throws Exception {\n+    scratch.overwriteFile(\n+        \"MODULE.bazel\",\n+        \"\"\"\n+        bazel_dep(name='b',version='1.0')\n+        bazel_dep(name='c',version='1.0')\n+        \"\"\");\n+\n+    registry\n+        .addModule(\n+            createModuleKey(\"b\", \"1.0\"),\n+            \"module(name='b', version='1.0');bazel_dep(name='d', version='1.0')\")\n+        .addModule(\n+            createModuleKey(\"c\", \"1.0\"),\n+            \"module(name='c', version='1.0');bazel_dep(name='d',version='1.1',repo_name=None)\")\n+        .addModule(createModuleKey(\"d\", \"1.0\"), \"module(name='d', version='1.0')\")\n+        .addModule(createModuleKey(\"d\", \"1.1\"), \"module(name='d', version='1.1')\");\n+    invalidatePackages(false);\n+\n+    EvaluationResult<BazelModuleResolutionValue> result =\n+        SkyframeExecutorTestUtils.evaluate(\n+            skyframeExecutor, BazelModuleResolutionValue.KEY, false, reporter);\n+\n+    if (result.hasError()) {\n+      fail(result.getError().toString());\n+    }\n+    var depGraph = result.get(BazelModuleResolutionValue.KEY).getResolvedDepGraph();\n+    assertThat(depGraph).containsKey(createModuleKey(\"d\", \"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"b\", \"1.0\")).getDeps().get(\"d\").version())\n+        .isEqualTo(Version.parse(\"1.1\"));\n+    assertThat(depGraph.get(createModuleKey(\"c\", \"1.0\")).getDeps()).doesNotContainKey(\"d\");\n+  }\n+\n+  @Test\n+  public void nodep_crossesCompatLevelBoundary() throws Exception {",
        "comment_created_at": "2025-02-24T08:58:43+00:00",
        "comment_author": "fmeum",
        "comment_body": "1. Isn't that only unsafe in the sense that changing this behavior later would be a breaking change? I don't think that taking the versions of deps of \"ineffective\" nodeps into account is required for the resolution result to be considered reasonable.\r\n2. That's correct and I certainly don't want to change that. But for both a \"nodep\" dep or a \"lower version constraint\" (whatever we brand this new feature as), it's potentially wasteful.\r\n\r\nI don't consider making nodeps behave like deps in this sense a big problem, but it could come back to hurt us later. Nodeps will mostly be used in N:1 dep situations with somewhat large (protobuf) or really large (boost) N. In many cases, users at a slightly larger scale will use many of these N modules and likely have them updated to latest anyway, which would mean that nodeps as is would roughly double the number of module files visited while not being relevant for the resolution outcome most of the time. Gradual performance degradation is what worries me most here as it is 1) hard to attribute to nodeps and 2) hard to fix retroactively as per your point 1. I may be arguing for premature optimization here, but it's unfortunately not just an internal algorithm :-)",
        "pr_file_module": null
      }
    ]
  }
]