[
  {
    "discussion_id": "1572213559",
    "pr_number": 16430,
    "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleConfiguredTargetUtil.java",
    "created_at": "2024-04-19T11:12:59+00:00",
    "commented_code": "RunfilesSupport runfilesSupport = null;\n       if (!computedDefaultRunfiles.isEmpty()) {\n         Preconditions.checkNotNull(executable, \"executable must not be null\");\n-        runfilesSupport =\n-            RunfilesSupport.withExecutable(ruleContext, computedDefaultRunfiles, executable);\n+        if (starlarkArgsProvided) {\n+          runfilesSupport = RunfilesSupport.withExecutableNoArgs(\n+              ruleContext, computedDefaultRunfiles, executable);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1572213559",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 16430,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleConfiguredTargetUtil.java",
        "discussion_id": "1572213559",
        "commented_code": "@@ -643,8 +658,13 @@ private static void addSimpleProviders(\n       RunfilesSupport runfilesSupport = null;\n       if (!computedDefaultRunfiles.isEmpty()) {\n         Preconditions.checkNotNull(executable, \"executable must not be null\");\n-        runfilesSupport =\n-            RunfilesSupport.withExecutable(ruleContext, computedDefaultRunfiles, executable);\n+        if (starlarkArgsProvided) {\n+          runfilesSupport = RunfilesSupport.withExecutableNoArgs(\n+              ruleContext, computedDefaultRunfiles, executable);",
        "comment_created_at": "2024-04-19T11:12:59+00:00",
        "comment_author": "lberki",
        "comment_body": "What is the argument against creating a `RunfilesSupport.withExecutableAndArgs()` method that overrides the argv computed from the attributes of the rule? That looks simpler than plumbing another set of arguments to `RunCommand` / `TestActionBuilder` and carefully making sure that the one in `RunEnvironmentInfo` overrides the one in `RunfilesSupport`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1576070095",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 16430,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkRuleConfiguredTargetUtil.java",
        "discussion_id": "1572213559",
        "commented_code": "@@ -643,8 +658,13 @@ private static void addSimpleProviders(\n       RunfilesSupport runfilesSupport = null;\n       if (!computedDefaultRunfiles.isEmpty()) {\n         Preconditions.checkNotNull(executable, \"executable must not be null\");\n-        runfilesSupport =\n-            RunfilesSupport.withExecutable(ruleContext, computedDefaultRunfiles, executable);\n+        if (starlarkArgsProvided) {\n+          runfilesSupport = RunfilesSupport.withExecutableNoArgs(\n+              ruleContext, computedDefaultRunfiles, executable);",
        "comment_created_at": "2024-04-23T11:09:22+00:00",
        "comment_author": "illicitonion",
        "comment_body": "@fmeum ^^",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1943345814",
    "pr_number": 24921,
    "pr_file": "src/main/java/com/google/devtools/build/lib/actions/FileArtifactValue.java",
    "created_at": "2025-02-05T17:08:01+00:00",
    "commented_code": "}\n   }\n \n+  public static final class FileWriteOutputArtifactValue extends FileArtifactValue",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1943345814",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24921,
        "pr_file": "src/main/java/com/google/devtools/build/lib/actions/FileArtifactValue.java",
        "discussion_id": "1943345814",
        "commented_code": "@@ -1004,6 +1017,109 @@ public boolean wasModifiedSinceDigest(Path path) {\n     }\n   }\n \n+  public static final class FileWriteOutputArtifactValue extends FileArtifactValue",
        "comment_created_at": "2025-02-05T17:08:01+00:00",
        "comment_author": "tjgq",
        "comment_body": "This class should be private and interacted with exclusively through the `FileArtifactValue` API - `instanceof` checks aren't guaranteed to work, since a `ResolvedSymlinkArtifactValue` can now wrap any other `FileArtifactValue`.\r\n\r\nMy preference would be for `FileWriteOutputArtifactValue` to implement the same sub-API as `InlineFileArtifactValue`: return `true` from `isInline` and implement `getInputStream`. Is this a viable approach?\r\n\r\nOtherwise, the alternative is to add `canWriteTo` and `writeTo` methods to `FileArtifactValue`, but I'd like to avoid expanding the API if possible (unfortunately, we can't avoid it by refactoring in the opposite direction -`writeTo` isn't a good fit for the internal uses of `InlineFileArtifactValue#getInputStream`).",
        "pr_file_module": null
      },
      {
        "comment_id": "1962056558",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24921,
        "pr_file": "src/main/java/com/google/devtools/build/lib/actions/FileArtifactValue.java",
        "discussion_id": "1943345814",
        "commented_code": "@@ -1004,6 +1017,109 @@ public boolean wasModifiedSinceDigest(Path path) {\n     }\n   }\n \n+  public static final class FileWriteOutputArtifactValue extends FileArtifactValue",
        "comment_created_at": "2025-02-19T17:01:23+00:00",
        "comment_author": "fmeum",
        "comment_body": "I made `FileWriteOutputArtifactValue` private, but also added `writeTo` to `FileArtifactValue` with a default implementation in terms of `getInputStream`. Having it implement `StreamWriter` just like `VirtualActionInput` is just very convenient for the use sites. Let me know if you find this too intrusive and I can refactor this further.",
        "pr_file_module": null
      },
      {
        "comment_id": "1962258918",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24921,
        "pr_file": "src/main/java/com/google/devtools/build/lib/actions/FileArtifactValue.java",
        "discussion_id": "1943345814",
        "commented_code": "@@ -1004,6 +1017,109 @@ public boolean wasModifiedSinceDigest(Path path) {\n     }\n   }\n \n+  public static final class FileWriteOutputArtifactValue extends FileArtifactValue",
        "comment_created_at": "2025-02-19T19:31:49+00:00",
        "comment_author": "tjgq",
        "comment_body": "This works, thanks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2081537998",
    "pr_number": 26037,
    "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/toolchains/ToolchainResolutionDebugPrinter.java",
    "created_at": "2025-05-09T12:09:57+00:00",
    "commented_code": "// limitations under the License.\n package com.google.devtools.build.lib.skyframe.toolchains;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n import static java.util.stream.Collectors.joining;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.devtools.build.lib.analysis.config.ToolchainTypeRequirement;\n import com.google.devtools.build.lib.analysis.platform.ConstraintValueInfo;\n import com.google.devtools.build.lib.analysis.platform.ToolchainTypeInfo;\n import com.google.devtools.build.lib.cmdline.Label;\n+import com.google.devtools.build.lib.cmdline.RepositoryMapping;\n+import com.google.devtools.build.lib.cmdline.RepositoryName;\n import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n import com.google.devtools.build.lib.events.ExtendedEventHandler;\n+import com.google.devtools.build.lib.skyframe.RepositoryMappingValue;\n+import com.google.devtools.build.skyframe.SkyFunction;\n import com.google.errorprone.annotations.FormatMethod;\n import com.google.errorprone.annotations.FormatString;\n+import java.util.HashSet;\n import java.util.Map;\n \n /** A helper interface for printing debug messages from toolchain resolution. */\n public sealed interface ToolchainResolutionDebugPrinter {\n \n-  static ToolchainResolutionDebugPrinter create(boolean debug, ExtendedEventHandler eventHandler) {\n-    if (debug) {\n-      return new EventHandlerImpl(eventHandler);\n+  static ToolchainResolutionDebugPrinter create(boolean debug, SkyFunction.Environment env)\n+      throws InterruptedException {\n+    if (!debug) {\n+      return new NoopPrinter();\n     }\n-    return new NoopPrinter();\n+    var mainRepositoryMapping =\n+        (RepositoryMappingValue) env.getValue(RepositoryMappingValue.key(RepositoryName.MAIN));\n+    checkNotNull(\n+        mainRepositoryMapping,\n+        \"expected main repository mapping to have been computed when resolving toolchains\");\n+    return env.getState(() -> new EventHandlerImpl(mainRepositoryMapping.repositoryMapping()));\n   }\n \n   boolean debugEnabled();\n \n-  /** Report on which toolchains were selected. */\n-  void reportSelectedToolchains(\n+  void startDebugging(\n+      EventHandler eventHandler,",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2081537998",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26037,
        "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/toolchains/ToolchainResolutionDebugPrinter.java",
        "discussion_id": "2081537998",
        "commented_code": "@@ -13,43 +13,69 @@\n // limitations under the License.\n package com.google.devtools.build.lib.skyframe.toolchains;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n import static java.util.stream.Collectors.joining;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.devtools.build.lib.analysis.config.ToolchainTypeRequirement;\n import com.google.devtools.build.lib.analysis.platform.ConstraintValueInfo;\n import com.google.devtools.build.lib.analysis.platform.ToolchainTypeInfo;\n import com.google.devtools.build.lib.cmdline.Label;\n+import com.google.devtools.build.lib.cmdline.RepositoryMapping;\n+import com.google.devtools.build.lib.cmdline.RepositoryName;\n import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n import com.google.devtools.build.lib.events.ExtendedEventHandler;\n+import com.google.devtools.build.lib.skyframe.RepositoryMappingValue;\n+import com.google.devtools.build.skyframe.SkyFunction;\n import com.google.errorprone.annotations.FormatMethod;\n import com.google.errorprone.annotations.FormatString;\n+import java.util.HashSet;\n import java.util.Map;\n \n /** A helper interface for printing debug messages from toolchain resolution. */\n public sealed interface ToolchainResolutionDebugPrinter {\n \n-  static ToolchainResolutionDebugPrinter create(boolean debug, ExtendedEventHandler eventHandler) {\n-    if (debug) {\n-      return new EventHandlerImpl(eventHandler);\n+  static ToolchainResolutionDebugPrinter create(boolean debug, SkyFunction.Environment env)\n+      throws InterruptedException {\n+    if (!debug) {\n+      return new NoopPrinter();\n     }\n-    return new NoopPrinter();\n+    var mainRepositoryMapping =\n+        (RepositoryMappingValue) env.getValue(RepositoryMappingValue.key(RepositoryName.MAIN));\n+    checkNotNull(\n+        mainRepositoryMapping,\n+        \"expected main repository mapping to have been computed when resolving toolchains\");\n+    return env.getState(() -> new EventHandlerImpl(mainRepositoryMapping.repositoryMapping()));\n   }\n \n   boolean debugEnabled();\n \n-  /** Report on which toolchains were selected. */\n-  void reportSelectedToolchains(\n+  void startDebugging(\n+      EventHandler eventHandler,",
        "comment_created_at": "2025-05-09T12:09:57+00:00",
        "comment_author": "katre",
        "comment_body": "Since the `eventHandler` ultimately comes from the `SkyFunction.Environment`, why not save it during the `create` call? Why pass it to every method? Are the instances changing?",
        "pr_file_module": null
      },
      {
        "comment_id": "2081590073",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26037,
        "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/toolchains/ToolchainResolutionDebugPrinter.java",
        "discussion_id": "2081537998",
        "commented_code": "@@ -13,43 +13,69 @@\n // limitations under the License.\n package com.google.devtools.build.lib.skyframe.toolchains;\n \n+import static com.google.common.base.Preconditions.checkNotNull;\n import static java.util.stream.Collectors.joining;\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.ImmutableSetMultimap;\n+import com.google.devtools.build.lib.analysis.config.ToolchainTypeRequirement;\n import com.google.devtools.build.lib.analysis.platform.ConstraintValueInfo;\n import com.google.devtools.build.lib.analysis.platform.ToolchainTypeInfo;\n import com.google.devtools.build.lib.cmdline.Label;\n+import com.google.devtools.build.lib.cmdline.RepositoryMapping;\n+import com.google.devtools.build.lib.cmdline.RepositoryName;\n import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n import com.google.devtools.build.lib.events.ExtendedEventHandler;\n+import com.google.devtools.build.lib.skyframe.RepositoryMappingValue;\n+import com.google.devtools.build.skyframe.SkyFunction;\n import com.google.errorprone.annotations.FormatMethod;\n import com.google.errorprone.annotations.FormatString;\n+import java.util.HashSet;\n import java.util.Map;\n \n /** A helper interface for printing debug messages from toolchain resolution. */\n public sealed interface ToolchainResolutionDebugPrinter {\n \n-  static ToolchainResolutionDebugPrinter create(boolean debug, ExtendedEventHandler eventHandler) {\n-    if (debug) {\n-      return new EventHandlerImpl(eventHandler);\n+  static ToolchainResolutionDebugPrinter create(boolean debug, SkyFunction.Environment env)\n+      throws InterruptedException {\n+    if (!debug) {\n+      return new NoopPrinter();\n     }\n-    return new NoopPrinter();\n+    var mainRepositoryMapping =\n+        (RepositoryMappingValue) env.getValue(RepositoryMappingValue.key(RepositoryName.MAIN));\n+    checkNotNull(\n+        mainRepositoryMapping,\n+        \"expected main repository mapping to have been computed when resolving toolchains\");\n+    return env.getState(() -> new EventHandlerImpl(mainRepositoryMapping.repositoryMapping()));\n   }\n \n   boolean debugEnabled();\n \n-  /** Report on which toolchains were selected. */\n-  void reportSelectedToolchains(\n+  void startDebugging(\n+      EventHandler eventHandler,",
        "comment_created_at": "2025-05-09T12:41:36+00:00",
        "comment_author": "fmeum",
        "comment_body": "Yes, there is a check in Skyframe that specifically guards against this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2014084053",
    "pr_number": 25448,
    "pr_file": "src/main/java/com/google/devtools/build/lib/remote/common/BulkTransferException.java",
    "created_at": "2025-03-26T12:54:54+00:00",
    "commented_code": "}\n \n   /**\n-   * Returns a map whose keys are the textual representation of a digest, and whose values are the\n-   * corresponding action inputs\n-   *\n-   * <p>Use {@code Function<String, ActionInput>} to avoid the heavy dependency on {@code\n-   * InputMetadataProvider}, whose getInput method provides the argument to this method.\n+   * Returns a {@link LostArtifacts} instance that is non-empty if and only if all suppressed\n+   * exceptions are caused by cache misses.\n    */\n-  public ImmutableMap<String, ActionInput> getLostInputs(\n-      Function<String, ActionInput> actionInputResolver) {\n+  public LostArtifacts getLostArtifacts(InputMetadataProvider metadataProvider) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2014084053",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25448,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/common/BulkTransferException.java",
        "discussion_id": "2014084053",
        "commented_code": "@@ -74,31 +80,28 @@ public static boolean allCausedByCacheNotFoundException(Throwable e) {\n   }\n \n   /**\n-   * Returns a map whose keys are the textual representation of a digest, and whose values are the\n-   * corresponding action inputs\n-   *\n-   * <p>Use {@code Function<String, ActionInput>} to avoid the heavy dependency on {@code\n-   * InputMetadataProvider}, whose getInput method provides the argument to this method.\n+   * Returns a {@link LostArtifacts} instance that is non-empty if and only if all suppressed\n+   * exceptions are caused by cache misses.\n    */\n-  public ImmutableMap<String, ActionInput> getLostInputs(\n-      Function<String, ActionInput> actionInputResolver) {\n+  public LostArtifacts getLostArtifacts(InputMetadataProvider metadataProvider) {",
        "comment_created_at": "2025-03-26T12:54:54+00:00",
        "comment_author": "coeuvre",
        "comment_body": "Why `Function<String, ActionInput>` is not enough?",
        "pr_file_module": null
      },
      {
        "comment_id": "2014279690",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25448,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/common/BulkTransferException.java",
        "discussion_id": "2014084053",
        "commented_code": "@@ -74,31 +80,28 @@ public static boolean allCausedByCacheNotFoundException(Throwable e) {\n   }\n \n   /**\n-   * Returns a map whose keys are the textual representation of a digest, and whose values are the\n-   * corresponding action inputs\n-   *\n-   * <p>Use {@code Function<String, ActionInput>} to avoid the heavy dependency on {@code\n-   * InputMetadataProvider}, whose getInput method provides the argument to this method.\n+   * Returns a {@link LostArtifacts} instance that is non-empty if and only if all suppressed\n+   * exceptions are caused by cache misses.\n    */\n-  public ImmutableMap<String, ActionInput> getLostInputs(\n-      Function<String, ActionInput> actionInputResolver) {\n+  public LostArtifacts getLostArtifacts(InputMetadataProvider metadataProvider) {",
        "comment_created_at": "2025-03-26T14:21:16+00:00",
        "comment_author": "fmeum",
        "comment_body": "It's still enough and I just switched back. `InputMetadataProvider` is now always a transitive dep of `BulkTransferException`, which is what I initially wanted to avoid - but `LostArtifacts` brings that with it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1886381898",
    "pr_number": 24618,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java",
    "created_at": "2024-12-16T08:37:13+00:00",
    "commented_code": "Event.warn(String.format(\"Error parsing the .netrc file: %s.\", e.getMessage())));\n       }\n       try {\n+        String configPath = repoOptions.downloaderConfig == null ? null : repoOptions.downloaderConfig.getPathString();\n         UrlRewriter rewriter =\n             UrlRewriter.getDownloaderUrlRewriter(\n-                env.getWorkspace(), repoOptions.downloaderConfig, env.getReporter());\n+                env.getWorkspace(), configPath, env.getReporter());",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1886381898",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24618,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/BazelRepositoryModule.java",
        "discussion_id": "1886381898",
        "commented_code": "@@ -394,9 +394,10 @@ public void beforeCommand(CommandEnvironment env) throws AbruptExitException {\n                 Event.warn(String.format(\"Error parsing the .netrc file: %s.\", e.getMessage())));\n       }\n       try {\n+        String configPath = repoOptions.downloaderConfig == null ? null : repoOptions.downloaderConfig.getPathString();\n         UrlRewriter rewriter =\n             UrlRewriter.getDownloaderUrlRewriter(\n-                env.getWorkspace(), repoOptions.downloaderConfig, env.getReporter());\n+                env.getWorkspace(), configPath, env.getReporter());",
        "comment_created_at": "2024-12-16T08:37:13+00:00",
        "comment_author": "fmeum",
        "comment_body": "Nit: Could you change the signature of this method to accept a `PathFragment` instead of a `String`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "693630494",
    "pr_number": 13852,
    "pr_file": "src/main/java/com/google/devtools/build/lib/remote/util/Utils.java",
    "created_at": "2021-08-23T03:36:26+00:00",
    "commented_code": "}\n \n   @SuppressWarnings(\"ProtoParseWithRegistry\")\n-  public static ListenableFuture<ActionResult> downloadAsActionResult(\n+  public static ListenableFuture<CachedActionResult> downloadAsActionResult(",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "693630494",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 13852,
        "pr_file": "src/main/java/com/google/devtools/build/lib/remote/util/Utils.java",
        "discussion_id": "693630494",
        "commented_code": "@@ -381,16 +382,18 @@ public static String grpcAwareErrorMessage(IOException e) {\n   }\n \n   @SuppressWarnings(\"ProtoParseWithRegistry\")\n-  public static ListenableFuture<ActionResult> downloadAsActionResult(\n+  public static ListenableFuture<CachedActionResult> downloadAsActionResult(",
        "comment_created_at": "2021-08-23T03:36:26+00:00",
        "comment_author": "coeuvre",
        "comment_body": "Please keep this method returning `ListenableFuture<ActionResult>` and construct `CachedActionResult` at the call sites so we can avoid passing magic strings e.g. \"disk\", \"remote\".",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1694951759",
    "pr_number": 22957,
    "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppModuleMapAction.java",
    "created_at": "2024-07-29T10:03:41+00:00",
    "commented_code": "boolean compiledModule,\n       boolean moduleMapHomeIsCwd,\n       boolean generateSubmodules,\n-      boolean externDependencies) {\n+      boolean externDependencies,\n+      OutputPathsMode outputPathsMode,\n+      BiFunction<ImmutableMap<String, String>, String, ImmutableMap<String, String>>\n+          modifyExecutionInfo) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1694951759",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22957,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppModuleMapAction.java",
        "discussion_id": "1694951759",
        "commented_code": "@@ -77,7 +89,10 @@ public CppModuleMapAction(\n       boolean compiledModule,\n       boolean moduleMapHomeIsCwd,\n       boolean generateSubmodules,\n-      boolean externDependencies) {\n+      boolean externDependencies,\n+      OutputPathsMode outputPathsMode,\n+      BiFunction<ImmutableMap<String, String>, String, ImmutableMap<String, String>>\n+          modifyExecutionInfo) {",
        "comment_created_at": "2024-07-29T10:03:41+00:00",
        "comment_author": "comius",
        "comment_body": "This design of passing in a BiFunction, checking if it would result in one key SUPPORTS_PATH_MAPPING and then modifying the execution info by adding that key, looks fishy.\r\n\r\nI'd be more comfortable passing in `ImmutableMap<String, String> executionInfo` and following SpawnAction example. Interning it and returning it in getExecutionInfo.\r\n\r\nIt will probably require a bit more internal testing, but it's also more future proof.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1694998563",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22957,
        "pr_file": "src/main/java/com/google/devtools/build/lib/rules/cpp/CppModuleMapAction.java",
        "discussion_id": "1694951759",
        "commented_code": "@@ -77,7 +89,10 @@ public CppModuleMapAction(\n       boolean compiledModule,\n       boolean moduleMapHomeIsCwd,\n       boolean generateSubmodules,\n-      boolean externDependencies) {\n+      boolean externDependencies,\n+      OutputPathsMode outputPathsMode,\n+      BiFunction<ImmutableMap<String, String>, String, ImmutableMap<String, String>>\n+          modifyExecutionInfo) {",
        "comment_created_at": "2024-07-29T10:42:29+00:00",
        "comment_author": "fmeum",
        "comment_body": "I am now passing in the execution info map directly. I still need some extra logic to save a field (which would result in a larger instance size), PTAL.",
        "pr_file_module": null
      }
    ]
  }
]