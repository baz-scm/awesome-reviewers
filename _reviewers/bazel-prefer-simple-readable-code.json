[
  {
    "discussion_id": "2279132788",
    "pr_number": 22553,
    "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
    "created_at": "2025-08-15T14:50:19+00:00",
    "commented_code": ")\n \n     cc_outputs_builder = cc_internal.create_cc_compilation_outputs_builder()\n-    _create_cc_compile_actions(\n-        action_construction_context = ctx,\n-        additional_compilation_inputs = additional_inputs,\n-        additional_include_scanning_roots = additional_include_scanning_roots,\n-        cc_compilation_context = cc_compilation_context,\n-        cc_toolchain = cc_toolchain,\n-        compilation_unit_sources = compilation_unit_sources,\n-        configuration = ctx.configuration,\n-        conlyopts = conly_flags,\n-        copts = user_compile_flags,\n-        copts_filter = copts_filter_object,\n-        cpp_configuration = cpp_configuration,\n-        cxxopts = cxx_flags,\n-        fdo_context = fdo_context,\n-        feature_configuration = feature_configuration,\n-        generate_no_pic_action = generate_no_pic_action,\n-        generate_pic_action = generate_pic_action,\n-        is_code_coverage_enabled = code_coverage_enabled,\n-        label = label,\n-        private_headers = private_hdrs_artifacts,\n-        public_headers = public_hdrs_artifacts,\n-        purpose = purpose if purpose else \"\",\n-        separate_module_headers = separate_module_headers,\n-        language = language,\n-        outputs = cc_outputs_builder,\n-        common_compile_build_variables = common_compile_build_variables,\n-        auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n-        fdo_build_variables = fdo_build_variables,\n-    )\n+    if feature_configuration.is_enabled(\"cpp_modules\"):\n+        _create_cc_compile_actions_with_cpp20_module(",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2279132788",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279132788",
        "commented_code": "@@ -311,37 +321,73 @@ def compile(\n     )\n \n     cc_outputs_builder = cc_internal.create_cc_compilation_outputs_builder()\n-    _create_cc_compile_actions(\n-        action_construction_context = ctx,\n-        additional_compilation_inputs = additional_inputs,\n-        additional_include_scanning_roots = additional_include_scanning_roots,\n-        cc_compilation_context = cc_compilation_context,\n-        cc_toolchain = cc_toolchain,\n-        compilation_unit_sources = compilation_unit_sources,\n-        configuration = ctx.configuration,\n-        conlyopts = conly_flags,\n-        copts = user_compile_flags,\n-        copts_filter = copts_filter_object,\n-        cpp_configuration = cpp_configuration,\n-        cxxopts = cxx_flags,\n-        fdo_context = fdo_context,\n-        feature_configuration = feature_configuration,\n-        generate_no_pic_action = generate_no_pic_action,\n-        generate_pic_action = generate_pic_action,\n-        is_code_coverage_enabled = code_coverage_enabled,\n-        label = label,\n-        private_headers = private_hdrs_artifacts,\n-        public_headers = public_hdrs_artifacts,\n-        purpose = purpose if purpose else \"\",\n-        separate_module_headers = separate_module_headers,\n-        language = language,\n-        outputs = cc_outputs_builder,\n-        common_compile_build_variables = common_compile_build_variables,\n-        auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n-        fdo_build_variables = fdo_build_variables,\n-    )\n+    if feature_configuration.is_enabled(\"cpp_modules\"):\n+        _create_cc_compile_actions_with_cpp20_module(",
        "comment_created_at": "2025-08-15T14:50:19+00:00",
        "comment_author": "fmeum",
        "comment_body": "This duplication is errorprone. What do you think of extending the existing `_create_cc_compile_actions` with the new `module_interfaces_sources` parameter and, in that function, branching on whether it is non-empty?",
        "pr_file_module": null
      },
      {
        "comment_id": "2281781441",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279132788",
        "commented_code": "@@ -311,37 +321,73 @@ def compile(\n     )\n \n     cc_outputs_builder = cc_internal.create_cc_compilation_outputs_builder()\n-    _create_cc_compile_actions(\n-        action_construction_context = ctx,\n-        additional_compilation_inputs = additional_inputs,\n-        additional_include_scanning_roots = additional_include_scanning_roots,\n-        cc_compilation_context = cc_compilation_context,\n-        cc_toolchain = cc_toolchain,\n-        compilation_unit_sources = compilation_unit_sources,\n-        configuration = ctx.configuration,\n-        conlyopts = conly_flags,\n-        copts = user_compile_flags,\n-        copts_filter = copts_filter_object,\n-        cpp_configuration = cpp_configuration,\n-        cxxopts = cxx_flags,\n-        fdo_context = fdo_context,\n-        feature_configuration = feature_configuration,\n-        generate_no_pic_action = generate_no_pic_action,\n-        generate_pic_action = generate_pic_action,\n-        is_code_coverage_enabled = code_coverage_enabled,\n-        label = label,\n-        private_headers = private_hdrs_artifacts,\n-        public_headers = public_hdrs_artifacts,\n-        purpose = purpose if purpose else \"\",\n-        separate_module_headers = separate_module_headers,\n-        language = language,\n-        outputs = cc_outputs_builder,\n-        common_compile_build_variables = common_compile_build_variables,\n-        auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n-        fdo_build_variables = fdo_build_variables,\n-    )\n+    if feature_configuration.is_enabled(\"cpp_modules\"):\n+        _create_cc_compile_actions_with_cpp20_module(",
        "comment_created_at": "2025-08-18T09:07:52+00:00",
        "comment_author": "PikachuHyA",
        "comment_body": "I've moved `_create_cc_compile_actions_with_cpp20_module` into `_create_cc_compile_actions`. Could you give me more advice on how to keep the code maintainable and clear?",
        "pr_file_module": null
      },
      {
        "comment_id": "2282005532",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279132788",
        "commented_code": "@@ -311,37 +321,73 @@ def compile(\n     )\n \n     cc_outputs_builder = cc_internal.create_cc_compilation_outputs_builder()\n-    _create_cc_compile_actions(\n-        action_construction_context = ctx,\n-        additional_compilation_inputs = additional_inputs,\n-        additional_include_scanning_roots = additional_include_scanning_roots,\n-        cc_compilation_context = cc_compilation_context,\n-        cc_toolchain = cc_toolchain,\n-        compilation_unit_sources = compilation_unit_sources,\n-        configuration = ctx.configuration,\n-        conlyopts = conly_flags,\n-        copts = user_compile_flags,\n-        copts_filter = copts_filter_object,\n-        cpp_configuration = cpp_configuration,\n-        cxxopts = cxx_flags,\n-        fdo_context = fdo_context,\n-        feature_configuration = feature_configuration,\n-        generate_no_pic_action = generate_no_pic_action,\n-        generate_pic_action = generate_pic_action,\n-        is_code_coverage_enabled = code_coverage_enabled,\n-        label = label,\n-        private_headers = private_hdrs_artifacts,\n-        public_headers = public_hdrs_artifacts,\n-        purpose = purpose if purpose else \"\",\n-        separate_module_headers = separate_module_headers,\n-        language = language,\n-        outputs = cc_outputs_builder,\n-        common_compile_build_variables = common_compile_build_variables,\n-        auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n-        fdo_build_variables = fdo_build_variables,\n-    )\n+    if feature_configuration.is_enabled(\"cpp_modules\"):\n+        _create_cc_compile_actions_with_cpp20_module(",
        "comment_created_at": "2025-08-18T10:33:00+00:00",
        "comment_author": "fmeum",
        "comment_body": "This looks good as as, thanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2279162093",
    "pr_number": 22553,
    "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
    "created_at": "2025-08-15T15:06:47+00:00",
    "commented_code": "(private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],\n+        mnemonic = \"CppGenModmap\",\n+        progress_message = \"Generating C++20 modules modmap %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_cc_compile_actions_with_cpp20_module_helper(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables,\n+        use_pic,\n+        output_name_map):\n+    direct_module_files = []\n+    source_to_module_file_map = {}\n+    source_to_ddi_file_map = {}\n+    modules_info_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_INFO,\n+            output_name = label.name,\n+        ),\n+    )\n+    if use_pic:\n+        outputs.add_pic_modules_info_file(modules_info_file)\n+    else:\n+        outputs.add_modules_info_file(modules_info_file)\n+\n+    native_cc_semantics = cc_common_internal.get_cpp_semantics(language = language)\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        ouptut_category = artifact_category.CPP_MODULE\n+        module_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = ouptut_category,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        direct_module_files.append(module_file)\n+        source_to_module_file_map[source_artifact] = module_file\n+\n+        # dependencies information are put in .ddi file\n+        # the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+        ddi_output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_DDI,\n+            output_name = output_name_base,\n+        )\n+        ddi_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = ddi_output_name,\n+        )\n+        _create_scan_deps_action(\n+            action_construction_context = action_construction_context,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            copts_filter = copts_filter,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            feature_configuration = feature_configuration,\n+            label = label,\n+            common_toolchain_variables = common_compile_build_variables,\n+            language = language,\n+            native_cc_semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            source_label = source_label,\n+            use_pic = use_pic,\n+            ddi_file = ddi_file,\n+            ddi_output_name = ddi_output_name,\n+        )\n+        source_to_ddi_file_map[source_artifact] = ddi_file\n+\n+    _create_aggregate_ddi_action(\n+        actions = actions,\n+        cc_toolchain = cc_toolchain,\n+        ddi_files = source_to_ddi_file_map.values(),\n+        direct_module_files = direct_module_files,\n+        transitive_modules_info_files = cc_compilation_context.modules_info_files(use_pic = use_pic),\n+        modules_info_file = modules_info_file,\n+    )\n+    compiled_basenames = set()\n+    all_module_files = depset(direct_module_files, transitive = [cc_compilation_context.module_files(use_pic = use_pic)])\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+        module_file = source_to_module_file_map[source_artifact]\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+            outputs.add_pic_cpp20_module_file(module_file)\n+        else:\n+            output_name_base = output_name\n+            outputs.add_cpp20_module_file(module_file)\n+\n+        modmap_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        modmap_input_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        _create_gen_modmap_action(\n+            actions = actions,\n+            cc_toolchain = cc_toolchain,\n+            ddi_file = source_to_ddi_file_map.get(source_artifact),\n+            modules_info_file = modules_info_file,\n+            modmap_file = modmap_file,\n+            modmap_input_file = modmap_input_file,\n+        )\n+        cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            copts_filter = copts_filter,\n+            feature_configuration = feature_configuration,\n+            semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            module_files = all_module_files,\n+            modmap_file = modmap_file,\n+            modmap_input_file = modmap_input_file,\n+            action_name = ACTION_NAMES.cpp20_module_compile,\n+            additional_outputs = [module_file],\n+        )\n+\n+        compiled_basenames.add(_basename_without_extension(source_artifact))\n+\n+        cc_internal.create_compile_source_action_from_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            fdo_context = fdo_context,\n+            auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n+            feature_configuration = feature_configuration,\n+            generate_no_pic_action = not use_pic,\n+            generate_pic_action = use_pic,\n+            label = label,\n+            common_compile_build_variables = common_compile_build_variables,\n+            fdo_build_variables = fdo_build_variables,\n+            cpp_semantics = native_cc_semantics,\n+            source_label = source_label,\n+            output_name = output_name,\n+            outputs = outputs,\n+            source_artifact = source_artifact,\n+            cpp_compile_action_builder = cpp_compile_action_builder,\n+            output_category = artifact_category.CLIF_OUTPUT_PROTO if cpp_source.type == CPP_SOURCE_TYPE_CLIF_INPUT_PROTO else artifact_category.OBJECT_FILE,\n+            cpp_module_map = cc_compilation_context.module_map(),\n+            add_object = True,\n+            enable_coverage = is_code_coverage_enabled,\n+            generate_dwo = should_create_per_object_debug_info(feature_configuration, cpp_configuration),\n+            bitcode_output = bitcode_output,\n+            additional_build_variables = {\n+                \"cpp_module_output_file\": module_file.path,\n+                \"cpp_module_modmap_file\": modmap_file.path\n+            }\n+        )\n+    for cpp_source in compilation_unit_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        additional_build_variables = {}\n+        modmap_file = None\n+        modmap_input_file = None\n+        # Only C++ compilation unit will be compiled with C++20 Modules.\n+        if \".\" + source_artifact.extension in extensions.CC_SOURCE:\n+            modmap_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+            modmap_input_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+\n+            ddi_output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_DDI,\n+                output_name = output_name_base,\n+            )\n+            ddi_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = ddi_output_name,\n+            )\n+            _create_scan_deps_action(\n+                action_construction_context = action_construction_context,\n+                additional_compilation_inputs = additional_compilation_inputs,\n+                additional_include_scanning_roots = additional_include_scanning_roots,\n+                cc_compilation_context = cc_compilation_context,\n+                cc_toolchain = cc_toolchain,\n+                configuration = configuration,\n+                conlyopts = conlyopts,\n+                copts = copts,\n+                copts_filter = copts_filter,\n+                cpp_configuration = cpp_configuration,\n+                cxxopts = cxxopts,\n+                feature_configuration = feature_configuration,\n+                label = label,\n+                common_toolchain_variables = common_compile_build_variables,\n+                language = language,\n+                native_cc_semantics = native_cc_semantics,\n+                source_artifact = source_artifact,\n+                source_label = source_label,\n+                use_pic = use_pic,\n+                ddi_file = ddi_file,\n+                ddi_output_name = ddi_output_name,\n+            )\n+            modmap_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+            modmap_input_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+            additional_build_variables[\"cpp_module_modmap_file\"] = modmap_file.path\n+            _create_gen_modmap_action(\n+                actions = actions,\n+                cc_toolchain = cc_toolchain,\n+                ddi_file = ddi_file,\n+                modules_info_file = modules_info_file,\n+                modmap_file = modmap_file,\n+                modmap_input_file = modmap_input_file,\n+            )\n+        cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            copts_filter = copts_filter,\n+            feature_configuration = feature_configuration,\n+            semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            module_files = all_module_files,\n+            modmap_file = modmap_file,\n+            modmap_input_file = modmap_input_file,\n+        )\n+        compiled_basenames.add(_basename_without_extension(source_artifact))\n+        cc_internal.create_compile_source_action_from_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            fdo_context = fdo_context,\n+            auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n+            feature_configuration = feature_configuration,\n+            generate_no_pic_action = not use_pic,\n+            generate_pic_action = use_pic,\n+            label = label,\n+            common_compile_build_variables = common_compile_build_variables,\n+            fdo_build_variables = fdo_build_variables,\n+            cpp_semantics = native_cc_semantics,\n+            source_label = source_label,\n+            output_name = output_name,\n+            outputs = outputs,\n+            source_artifact = source_artifact,\n+            cpp_compile_action_builder = cpp_compile_action_builder,\n+            output_category = artifact_category.CLIF_OUTPUT_PROTO if cpp_source.type == CPP_SOURCE_TYPE_CLIF_INPUT_PROTO else artifact_category.OBJECT_FILE,\n+            cpp_module_map = cc_compilation_context.module_map(),\n+            add_object = True,\n+            enable_coverage = is_code_coverage_enabled,\n+            generate_dwo = should_create_per_object_debug_info(feature_configuration, cpp_configuration),\n+            bitcode_output = bitcode_output,\n+            additional_build_variables = additional_build_variables,\n+        )\n+\n+def _create_cc_compile_actions_with_cpp20_module(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        generate_no_pic_action,\n+        generate_pic_action,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables):\n+    \"\"\"Constructs the C++ compiler actions with C++20 modules support.\n+    \"\"\"\n+    output_name_prefix_dir = cc_internal.compute_output_name_prefix_dir(configuration = configuration, purpose = purpose)\n+    output_name_map = _calculate_output_name_map_by_type(compilation_unit_sources | module_interfaces_sources, output_name_prefix_dir)\n+    if generate_no_pic_action:",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2279162093",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279162093",
        "commented_code": "@@ -436,6 +493,602 @@ def _should_provide_header_modules(\n         (private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],\n+        mnemonic = \"CppGenModmap\",\n+        progress_message = \"Generating C++20 modules modmap %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_cc_compile_actions_with_cpp20_module_helper(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables,\n+        use_pic,\n+        output_name_map):\n+    direct_module_files = []\n+    source_to_module_file_map = {}\n+    source_to_ddi_file_map = {}\n+    modules_info_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_INFO,\n+            output_name = label.name,\n+        ),\n+    )\n+    if use_pic:\n+        outputs.add_pic_modules_info_file(modules_info_file)\n+    else:\n+        outputs.add_modules_info_file(modules_info_file)\n+\n+    native_cc_semantics = cc_common_internal.get_cpp_semantics(language = language)\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        ouptut_category = artifact_category.CPP_MODULE\n+        module_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = ouptut_category,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        direct_module_files.append(module_file)\n+        source_to_module_file_map[source_artifact] = module_file\n+\n+        # dependencies information are put in .ddi file\n+        # the format is https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html\n+        ddi_output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.CPP_MODULES_DDI,\n+            output_name = output_name_base,\n+        )\n+        ddi_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = ddi_output_name,\n+        )\n+        _create_scan_deps_action(\n+            action_construction_context = action_construction_context,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            copts_filter = copts_filter,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            feature_configuration = feature_configuration,\n+            label = label,\n+            common_toolchain_variables = common_compile_build_variables,\n+            language = language,\n+            native_cc_semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            source_label = source_label,\n+            use_pic = use_pic,\n+            ddi_file = ddi_file,\n+            ddi_output_name = ddi_output_name,\n+        )\n+        source_to_ddi_file_map[source_artifact] = ddi_file\n+\n+    _create_aggregate_ddi_action(\n+        actions = actions,\n+        cc_toolchain = cc_toolchain,\n+        ddi_files = source_to_ddi_file_map.values(),\n+        direct_module_files = direct_module_files,\n+        transitive_modules_info_files = cc_compilation_context.modules_info_files(use_pic = use_pic),\n+        modules_info_file = modules_info_file,\n+    )\n+    compiled_basenames = set()\n+    all_module_files = depset(direct_module_files, transitive = [cc_compilation_context.module_files(use_pic = use_pic)])\n+    for cpp_source in module_interfaces_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+        module_file = source_to_module_file_map[source_artifact]\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+            outputs.add_pic_cpp20_module_file(module_file)\n+        else:\n+            output_name_base = output_name\n+            outputs.add_cpp20_module_file(module_file)\n+\n+        modmap_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        modmap_input_file = _get_compile_output_file(\n+            action_construction_context,\n+            label,\n+            output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                output_name = output_name_base,\n+            ),\n+        )\n+        _create_gen_modmap_action(\n+            actions = actions,\n+            cc_toolchain = cc_toolchain,\n+            ddi_file = source_to_ddi_file_map.get(source_artifact),\n+            modules_info_file = modules_info_file,\n+            modmap_file = modmap_file,\n+            modmap_input_file = modmap_input_file,\n+        )\n+        cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            copts_filter = copts_filter,\n+            feature_configuration = feature_configuration,\n+            semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            module_files = all_module_files,\n+            modmap_file = modmap_file,\n+            modmap_input_file = modmap_input_file,\n+            action_name = ACTION_NAMES.cpp20_module_compile,\n+            additional_outputs = [module_file],\n+        )\n+\n+        compiled_basenames.add(_basename_without_extension(source_artifact))\n+\n+        cc_internal.create_compile_source_action_from_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            fdo_context = fdo_context,\n+            auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n+            feature_configuration = feature_configuration,\n+            generate_no_pic_action = not use_pic,\n+            generate_pic_action = use_pic,\n+            label = label,\n+            common_compile_build_variables = common_compile_build_variables,\n+            fdo_build_variables = fdo_build_variables,\n+            cpp_semantics = native_cc_semantics,\n+            source_label = source_label,\n+            output_name = output_name,\n+            outputs = outputs,\n+            source_artifact = source_artifact,\n+            cpp_compile_action_builder = cpp_compile_action_builder,\n+            output_category = artifact_category.CLIF_OUTPUT_PROTO if cpp_source.type == CPP_SOURCE_TYPE_CLIF_INPUT_PROTO else artifact_category.OBJECT_FILE,\n+            cpp_module_map = cc_compilation_context.module_map(),\n+            add_object = True,\n+            enable_coverage = is_code_coverage_enabled,\n+            generate_dwo = should_create_per_object_debug_info(feature_configuration, cpp_configuration),\n+            bitcode_output = bitcode_output,\n+            additional_build_variables = {\n+                \"cpp_module_output_file\": module_file.path,\n+                \"cpp_module_modmap_file\": modmap_file.path\n+            }\n+        )\n+    for cpp_source in compilation_unit_sources.values():\n+        source_artifact = cpp_source.file\n+        output_name = output_name_map[source_artifact]\n+        source_label = cpp_source.label\n+        bitcode_output = feature_configuration.is_enabled(\"thin_lto\") and ((\".\" + source_artifact.extension) in LTO_SOURCE_EXTENSIONS)\n+\n+        if use_pic:\n+            output_name_base = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.PIC_FILE,\n+                output_name = output_name,\n+            )\n+        else:\n+            output_name_base = output_name\n+\n+        additional_build_variables = {}\n+        modmap_file = None\n+        modmap_input_file = None\n+        # Only C++ compilation unit will be compiled with C++20 Modules.\n+        if \".\" + source_artifact.extension in extensions.CC_SOURCE:\n+            modmap_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+            modmap_input_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+\n+            ddi_output_name = cc_internal.get_artifact_name_for_category(\n+                cc_toolchain = cc_toolchain,\n+                category = artifact_category.CPP_MODULES_DDI,\n+                output_name = output_name_base,\n+            )\n+            ddi_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = ddi_output_name,\n+            )\n+            _create_scan_deps_action(\n+                action_construction_context = action_construction_context,\n+                additional_compilation_inputs = additional_compilation_inputs,\n+                additional_include_scanning_roots = additional_include_scanning_roots,\n+                cc_compilation_context = cc_compilation_context,\n+                cc_toolchain = cc_toolchain,\n+                configuration = configuration,\n+                conlyopts = conlyopts,\n+                copts = copts,\n+                copts_filter = copts_filter,\n+                cpp_configuration = cpp_configuration,\n+                cxxopts = cxxopts,\n+                feature_configuration = feature_configuration,\n+                label = label,\n+                common_toolchain_variables = common_compile_build_variables,\n+                language = language,\n+                native_cc_semantics = native_cc_semantics,\n+                source_artifact = source_artifact,\n+                source_label = source_label,\n+                use_pic = use_pic,\n+                ddi_file = ddi_file,\n+                ddi_output_name = ddi_output_name,\n+            )\n+            modmap_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+            modmap_input_file = _get_compile_output_file(\n+                action_construction_context,\n+                label,\n+                output_name = cc_internal.get_artifact_name_for_category(\n+                    cc_toolchain = cc_toolchain,\n+                    category = artifact_category.CPP_MODULES_MODMAP_INPUT,\n+                    output_name = output_name_base,\n+                ),\n+            )\n+            additional_build_variables[\"cpp_module_modmap_file\"] = modmap_file.path\n+            _create_gen_modmap_action(\n+                actions = actions,\n+                cc_toolchain = cc_toolchain,\n+                ddi_file = ddi_file,\n+                modules_info_file = modules_info_file,\n+                modmap_file = modmap_file,\n+                modmap_input_file = modmap_input_file,\n+            )\n+        cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            copts_filter = copts_filter,\n+            feature_configuration = feature_configuration,\n+            semantics = native_cc_semantics,\n+            source_artifact = source_artifact,\n+            additional_compilation_inputs = additional_compilation_inputs,\n+            additional_include_scanning_roots = additional_include_scanning_roots,\n+            module_files = all_module_files,\n+            modmap_file = modmap_file,\n+            modmap_input_file = modmap_input_file,\n+        )\n+        compiled_basenames.add(_basename_without_extension(source_artifact))\n+        cc_internal.create_compile_source_action_from_builder(\n+            action_construction_context = action_construction_context,\n+            cc_compilation_context = cc_compilation_context,\n+            cc_toolchain = cc_toolchain,\n+            configuration = configuration,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cpp_configuration = cpp_configuration,\n+            cxxopts = cxxopts,\n+            fdo_context = fdo_context,\n+            auxiliary_fdo_inputs = auxiliary_fdo_inputs,\n+            feature_configuration = feature_configuration,\n+            generate_no_pic_action = not use_pic,\n+            generate_pic_action = use_pic,\n+            label = label,\n+            common_compile_build_variables = common_compile_build_variables,\n+            fdo_build_variables = fdo_build_variables,\n+            cpp_semantics = native_cc_semantics,\n+            source_label = source_label,\n+            output_name = output_name,\n+            outputs = outputs,\n+            source_artifact = source_artifact,\n+            cpp_compile_action_builder = cpp_compile_action_builder,\n+            output_category = artifact_category.CLIF_OUTPUT_PROTO if cpp_source.type == CPP_SOURCE_TYPE_CLIF_INPUT_PROTO else artifact_category.OBJECT_FILE,\n+            cpp_module_map = cc_compilation_context.module_map(),\n+            add_object = True,\n+            enable_coverage = is_code_coverage_enabled,\n+            generate_dwo = should_create_per_object_debug_info(feature_configuration, cpp_configuration),\n+            bitcode_output = bitcode_output,\n+            additional_build_variables = additional_build_variables,\n+        )\n+\n+def _create_cc_compile_actions_with_cpp20_module(\n+        *,\n+        actions,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        compilation_unit_sources,\n+        module_interfaces_sources,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,\n+        cxxopts,\n+        fdo_context,\n+        feature_configuration,\n+        generate_no_pic_action,\n+        generate_pic_action,\n+        is_code_coverage_enabled,\n+        label,\n+        private_headers,\n+        public_headers,\n+        purpose,\n+        language,\n+        outputs,\n+        common_compile_build_variables,\n+        auxiliary_fdo_inputs,\n+        fdo_build_variables):\n+    \"\"\"Constructs the C++ compiler actions with C++20 modules support.\n+    \"\"\"\n+    output_name_prefix_dir = cc_internal.compute_output_name_prefix_dir(configuration = configuration, purpose = purpose)\n+    output_name_map = _calculate_output_name_map_by_type(compilation_unit_sources | module_interfaces_sources, output_name_prefix_dir)\n+    if generate_no_pic_action:",
        "comment_created_at": "2025-08-15T15:06:47+00:00",
        "comment_author": "fmeum",
        "comment_body": "Avoid the duplicated long call via logic like this:\r\n```starlark\r\nuse_pic_values = []\r\nif generate_no_pic_action:\r\n  use_pic_values.append(false)\r\nif generate_pic_action:\r\n  use_pic_values.append(true)\r\n\r\nfor use_pic in use_pic_values:\r\n  ...\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1666588938",
    "pr_number": 16954,
    "pr_file": "tools/cpp/validate_static_library.sh.tpl",
    "created_at": "2024-07-05T09:40:23+00:00",
    "commented_code": "+#!/usr/bin/env bash\n+#\n+# Copyright 2023 The Bazel Authors. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+set -euo pipefail\n+\n+# Find all duplicate symbols in the given static library:\n+# 1. Use nm to list all global symbols in the library in POSIX format:\n+#    libstatic.a[my_object.o]: my_function T 1234 abcd\n+# 2. Use sed to transform the output to a format that can be sorted by symbol\n+#    name and is readable by humans:\n+#    my_object.o: T my_function\n+#    By using the `t` and `d` commands, lines for symbols of type U (undefined)\n+#    as well as V and W (weak) and their local lowercase variants are removed.\n+# 3. Use sort to sort the lines by symbol name.\n+# 4. Use uniq to only keep the lines corresponding to duplicate symbols.\n+# 5. Use c++filt to demangle the symbol names.\n+#    c++filt is applied to the duplicated symbols instead of using the -C flag\n+#    of nm because it is not in POSIX and demangled names may not be unique\n+#    (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=35201).\n+DUPLICATE_SYMBOLS=$(\n+  \"%{nm}\" -A -g -P %{nm_extra_args} \"$1\" |\n+  sed -E -e 's/.*\\[([^][]+)\\]: (.+) ([A-TX-Z]) [a-f0-9]+ [a-f0-9]+/\\1: \\3 \\2/g' -e t -e d |",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1666588938",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 16954,
        "pr_file": "tools/cpp/validate_static_library.sh.tpl",
        "discussion_id": "1666588938",
        "commented_code": "@@ -0,0 +1,44 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright 2023 The Bazel Authors. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+set -euo pipefail\n+\n+# Find all duplicate symbols in the given static library:\n+# 1. Use nm to list all global symbols in the library in POSIX format:\n+#    libstatic.a[my_object.o]: my_function T 1234 abcd\n+# 2. Use sed to transform the output to a format that can be sorted by symbol\n+#    name and is readable by humans:\n+#    my_object.o: T my_function\n+#    By using the `t` and `d` commands, lines for symbols of type U (undefined)\n+#    as well as V and W (weak) and their local lowercase variants are removed.\n+# 3. Use sort to sort the lines by symbol name.\n+# 4. Use uniq to only keep the lines corresponding to duplicate symbols.\n+# 5. Use c++filt to demangle the symbol names.\n+#    c++filt is applied to the duplicated symbols instead of using the -C flag\n+#    of nm because it is not in POSIX and demangled names may not be unique\n+#    (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=35201).\n+DUPLICATE_SYMBOLS=$(\n+  \"%{nm}\" -A -g -P %{nm_extra_args} \"$1\" |\n+  sed -E -e 's/.*\\[([^][]+)\\]: (.+) ([A-TX-Z]) [a-f0-9]+ [a-f0-9]+/\\1: \\3 \\2/g' -e t -e d |",
        "comment_created_at": "2024-07-05T09:40:23+00:00",
        "comment_author": "comius",
        "comment_body": "Can this sed be simplified?\r\n\r\nMy suggestions:\r\n- the last part `[a-f0-9]+ [a-f0-9]+` of the matcher is not used in the output, so it could be removed\r\n- `\\[([^][]+)\\]` is quite complex, is the occurence of `[` or `]` in any other strings even possible? if not, then do just `\\[(.*)\\]`. It's easier to understand.\r\n- shouldn't `sed -E -e <> -e t -e d` do the same as `sed -E <>`? If that's the case remove `-e`s.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1666746461",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 16954,
        "pr_file": "tools/cpp/validate_static_library.sh.tpl",
        "discussion_id": "1666588938",
        "commented_code": "@@ -0,0 +1,44 @@\n+#!/usr/bin/env bash\n+#\n+# Copyright 2023 The Bazel Authors. All rights reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+set -euo pipefail\n+\n+# Find all duplicate symbols in the given static library:\n+# 1. Use nm to list all global symbols in the library in POSIX format:\n+#    libstatic.a[my_object.o]: my_function T 1234 abcd\n+# 2. Use sed to transform the output to a format that can be sorted by symbol\n+#    name and is readable by humans:\n+#    my_object.o: T my_function\n+#    By using the `t` and `d` commands, lines for symbols of type U (undefined)\n+#    as well as V and W (weak) and their local lowercase variants are removed.\n+# 3. Use sort to sort the lines by symbol name.\n+# 4. Use uniq to only keep the lines corresponding to duplicate symbols.\n+# 5. Use c++filt to demangle the symbol names.\n+#    c++filt is applied to the duplicated symbols instead of using the -C flag\n+#    of nm because it is not in POSIX and demangled names may not be unique\n+#    (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=35201).\n+DUPLICATE_SYMBOLS=$(\n+  \"%{nm}\" -A -g -P %{nm_extra_args} \"$1\" |\n+  sed -E -e 's/.*\\[([^][]+)\\]: (.+) ([A-TX-Z]) [a-f0-9]+ [a-f0-9]+/\\1: \\3 \\2/g' -e t -e d |",
        "comment_created_at": "2024-07-05T12:25:34+00:00",
        "comment_author": "fmeum",
        "comment_body": "1. We need to match this part so that it is consumed and replaced, otherwise it would end up in the `sed` output. I could use another wildcard, but using two wildcards around a part we need to match exactly seemed too brittle to me.\n2. It may appear in file names, which is why i wanted this match to be as precise as possible. It is only relevant in edge cases though (and maybe not even there).\n3. `t` and `d` additionally drop unmatched lines, which is required to drop some symbol types that should be ignored. Default sed doesn't do that as far as I know.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1666591892",
    "pr_number": 16954,
    "pr_file": "src/main/starlark/builtins_bzl/common/cc/cc_helper.bzl",
    "created_at": "2024-07-05T09:42:59+00:00",
    "commented_code": "tokenize = _tokenize,\n     should_use_pic = _should_use_pic,\n     check_cpp_modules = _check_cpp_modules,\n+    get_base_name = _get_base_name,",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1666591892",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 16954,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/cc_helper.bzl",
        "discussion_id": "1666591892",
        "commented_code": "@@ -1266,4 +1266,6 @@ cc_helper = struct(\n     tokenize = _tokenize,\n     should_use_pic = _should_use_pic,\n     check_cpp_modules = _check_cpp_modules,\n+    get_base_name = _get_base_name,",
        "comment_created_at": "2024-07-05T09:42:59+00:00",
        "comment_author": "comius",
        "comment_body": "I'd prefer if paths.basename was used from common/paths.bzl\r\n\r\nI'd also avoid `replace_name` and do ad hoc string concatenation instead.\r\n\r\nMy concern is that cc_helper is just growing and adding a bunch of functions of various quality, readers of the code don't necessarily immediately understand.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1963586019",
    "pr_number": 24417,
    "pr_file": "src/test/java/net/starlark/java/eval/testdata/json.star",
    "created_at": "2025-02-20T13:40:17+00:00",
    "commented_code": "assert_eq(json.encode(\"/\"), '\"/\"')\n assert_eq(json.encode(\"\\\\\"), r'\"\\\\\"')\n assert_eq(json.encode(\"\"), '\"\"')\n-assert_eq(json.encode(\"\ud83d\ude39\"[:1]), '\"\ufffd\"')  # invalid UTF-16 -> replacement char U+FFFD\n+# TODO: Invalid UTF-8 byte sequences are not replaced with U+FFFD.\n+assert_eq(json.encode(\"\ud83d\ude39\"[:1]), '\"\ufffd\"') if not _utf8_byte_strings else None # invalid UTF-16 -> replacement char U+FFFD",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1963586019",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24417,
        "pr_file": "src/test/java/net/starlark/java/eval/testdata/json.star",
        "discussion_id": "1963586019",
        "commented_code": "@@ -25,7 +25,8 @@ assert_eq(json.encode(\"\\\"\"), r'\"\\\"\"')\n assert_eq(json.encode(\"/\"), '\"/\"')\n assert_eq(json.encode(\"\\\\\"), r'\"\\\\\"')\n assert_eq(json.encode(\"\"), '\"\"')\n-assert_eq(json.encode(\"\ud83d\ude39\"[:1]), '\"\ufffd\"')  # invalid UTF-16 -> replacement char U+FFFD\n+# TODO: Invalid UTF-8 byte sequences are not replaced with U+FFFD.\n+assert_eq(json.encode(\"\ud83d\ude39\"[:1]), '\"\ufffd\"') if not _utf8_byte_strings else None # invalid UTF-16 -> replacement char U+FFFD",
        "comment_created_at": "2025-02-20T13:40:17+00:00",
        "comment_author": "tjgq",
        "comment_body": "Isn't this just an obfuscated way of writing:\r\n\r\n```\r\nif not _utf8_byte_strings:\r\n  assert_eq(json.encode(...))\r\n```\r\n\r\nor is there a reason we can't use that syntax in these test files?",
        "pr_file_module": null
      },
      {
        "comment_id": "1963744085",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24417,
        "pr_file": "src/test/java/net/starlark/java/eval/testdata/json.star",
        "discussion_id": "1963586019",
        "commented_code": "@@ -25,7 +25,8 @@ assert_eq(json.encode(\"\\\"\"), r'\"\\\"\"')\n assert_eq(json.encode(\"/\"), '\"/\"')\n assert_eq(json.encode(\"\\\\\"), r'\"\\\\\"')\n assert_eq(json.encode(\"\"), '\"\"')\n-assert_eq(json.encode(\"\ud83d\ude39\"[:1]), '\"\ufffd\"')  # invalid UTF-16 -> replacement char U+FFFD\n+# TODO: Invalid UTF-8 byte sequences are not replaced with U+FFFD.\n+assert_eq(json.encode(\"\ud83d\ude39\"[:1]), '\"\ufffd\"') if not _utf8_byte_strings else None # invalid UTF-16 -> replacement char U+FFFD",
        "comment_created_at": "2025-02-20T15:03:49+00:00",
        "comment_author": "fmeum",
        "comment_body": "Top-level ifs are not allowed:\r\n```\r\n./src/test/java/net/starlark/java/eval/testdata/json.star:29:1: if statements are not allowed at the top level. You may move it inside a function or use an if expression (x if condition else y).\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1844533974",
    "pr_number": 24344,
    "pr_file": "src/main/cpp/archive_utils.h",
    "created_at": "2024-11-15T21:34:42+00:00",
    "commented_code": "std::vector<std::string> *files,\n                               std::string *install_md5);\n \n-struct DurationMillis {\n- public:\n-  const uint64_t millis;\n-\n-  DurationMillis() : millis(kUnknownDuration) {}\n-  DurationMillis(const uint64_t ms) : millis(ms) {}\n-\n-  bool IsUnknown() const { return millis == kUnknownDuration; }\n-\n- private:\n-  // Value representing that a timing event never occurred or is unknown.\n-  static constexpr uint64_t kUnknownDuration = 0;\n-};\n-\n // DurationMillis that tracks if an archive was extracted.\n struct ExtractionDurationMillis : DurationMillis {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1844533974",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24344,
        "pr_file": "src/main/cpp/archive_utils.h",
        "discussion_id": "1844533974",
        "commented_code": "@@ -29,26 +30,12 @@ void DetermineArchiveContents(const std::string &archive_path,\n                               std::vector<std::string> *files,\n                               std::string *install_md5);\n \n-struct DurationMillis {\n- public:\n-  const uint64_t millis;\n-\n-  DurationMillis() : millis(kUnknownDuration) {}\n-  DurationMillis(const uint64_t ms) : millis(ms) {}\n-\n-  bool IsUnknown() const { return millis == kUnknownDuration; }\n-\n- private:\n-  // Value representing that a timing event never occurred or is unknown.\n-  static constexpr uint64_t kUnknownDuration = 0;\n-};\n-\n // DurationMillis that tracks if an archive was extracted.\n struct ExtractionDurationMillis : DurationMillis {",
        "comment_created_at": "2024-11-15T21:34:42+00:00",
        "comment_author": "tjgq",
        "comment_body": "I wonder if we really need this class: we either did an extraction and know the time it took, or we didn't and we don't; we never inspect `archive_extracted`, except in tests. Wouldn't a `DurationMillis` suffice, with \"unknown\" signifying \"not extracted\"?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1819069191",
    "pr_number": 24010,
    "pr_file": "src/main/cpp/option_processor_windows.cc",
    "created_at": "2024-10-28T13:34:53+00:00",
    "commented_code": "+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"src/main/cpp/option_processor-internal.h\"\n+\n+#include <algorithm>\n+#include <string>\n+\n+#include \"src/main/cpp/util/strings.h\"\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+namespace blaze::internal {\n+\n+#if defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  int pos = env_str->find_first_of('=');\n+  if (pos == string::npos) return;\n+  std::string name = env_str->substr(0, pos);\n+  if (name == \"PATH\") {\n+    env_str->assign(\"PATH=\" + env_str->substr(pos + 1));\n+  } else if (name == \"TMP\") {\n+    // A valid Windows path \"c:/foo\" is also a valid Unix path list of\n+    // [\"c\", \"/foo\"] so must use ConvertPath here. See GitHub issue #1684.\n+    env_str->assign(\"TMP=\" + blaze_util::ConvertPath(env_str->substr(pos + 1)));\n+  }\n+}\n+\n+#else // not defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  static constexpr const char *vars_to_uppercase[] = {\"PATH\", \"SYSTEMROOT\",\n+                                                      \"SYSTEMDRIVE\",\n+                                                      \"TEMP\", \"TEMPDIR\", \"TMP\"};\n+\n+  std::size_t pos = env_str->find_first_of('=');\n+  if (pos == std::string::npos) return;\n+\n+  std::string name = env_str->substr(0, pos);\n+  // We do not care about locale. All variable names are ASCII.\n+  std::transform(name.begin(), name.end(), name.begin(), ::toupper);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1819069191",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24010,
        "pr_file": "src/main/cpp/option_processor_windows.cc",
        "discussion_id": "1819069191",
        "commented_code": "@@ -0,0 +1,94 @@\n+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"src/main/cpp/option_processor-internal.h\"\n+\n+#include <algorithm>\n+#include <string>\n+\n+#include \"src/main/cpp/util/strings.h\"\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+namespace blaze::internal {\n+\n+#if defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  int pos = env_str->find_first_of('=');\n+  if (pos == string::npos) return;\n+  std::string name = env_str->substr(0, pos);\n+  if (name == \"PATH\") {\n+    env_str->assign(\"PATH=\" + env_str->substr(pos + 1));\n+  } else if (name == \"TMP\") {\n+    // A valid Windows path \"c:/foo\" is also a valid Unix path list of\n+    // [\"c\", \"/foo\"] so must use ConvertPath here. See GitHub issue #1684.\n+    env_str->assign(\"TMP=\" + blaze_util::ConvertPath(env_str->substr(pos + 1)));\n+  }\n+}\n+\n+#else // not defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  static constexpr const char *vars_to_uppercase[] = {\"PATH\", \"SYSTEMROOT\",\n+                                                      \"SYSTEMDRIVE\",\n+                                                      \"TEMP\", \"TEMPDIR\", \"TMP\"};\n+\n+  std::size_t pos = env_str->find_first_of('=');\n+  if (pos == std::string::npos) return;\n+\n+  std::string name = env_str->substr(0, pos);\n+  // We do not care about locale. All variable names are ASCII.\n+  std::transform(name.begin(), name.end(), name.begin(), ::toupper);",
        "comment_created_at": "2024-10-28T13:34:53+00:00",
        "comment_author": "tjgq",
        "comment_body": "Since we're already taking a dep on absl elsewhere, can you use `AsciiStrToUpper` here for better readability?",
        "pr_file_module": null
      }
    ]
  }
]