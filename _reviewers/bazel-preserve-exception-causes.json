[
  {
    "discussion_id": "1925001502",
    "pr_number": 24945,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Version.java",
    "created_at": "2025-01-22T09:37:42+00:00",
    "commented_code": "* compared differently based on whether it's digits-only or not.\n    */\n   @AutoCodec\n-  record Identifier(boolean isDigitsOnly, int asNumber, String asString)\n+  record Identifier(boolean isDigitsOnly, long asNumber, String asString)\n       implements Comparable<Identifier> {\n     static Identifier from(String string) throws ParseException {\n       if (Strings.isNullOrEmpty(string)) {\n         throw new ParseException(\"identifier is empty\");\n       }\n       if (string.chars().allMatch(Character::isDigit)) {\n-        return new Identifier(true, Integer.parseInt(string), string);\n+        try {\n+          return new Identifier(true, Long.parseUnsignedLong(string), string);\n+        } catch (NumberFormatException e) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1925001502",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24945,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Version.java",
        "discussion_id": "1925001502",
        "commented_code": "@@ -91,22 +91,26 @@ public record Version(\n    * compared differently based on whether it's digits-only or not.\n    */\n   @AutoCodec\n-  record Identifier(boolean isDigitsOnly, int asNumber, String asString)\n+  record Identifier(boolean isDigitsOnly, long asNumber, String asString)\n       implements Comparable<Identifier> {\n     static Identifier from(String string) throws ParseException {\n       if (Strings.isNullOrEmpty(string)) {\n         throw new ParseException(\"identifier is empty\");\n       }\n       if (string.chars().allMatch(Character::isDigit)) {\n-        return new Identifier(true, Integer.parseInt(string), string);\n+        try {\n+          return new Identifier(true, Long.parseUnsignedLong(string), string);\n+        } catch (NumberFormatException e) {",
        "comment_created_at": "2025-01-22T09:37:42+00:00",
        "comment_author": "meteorcloudy",
        "comment_body": "Got this check:\r\n\r\nThis catch block catches an exception and re-throws another, but swallows the caught exception rather than setting it as a cause. This can make debugging harder.\r\n\r\n@fmeum Can you please fix this?",
        "pr_file_module": null
      },
      {
        "comment_id": "1925060731",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24945,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/bzlmod/Version.java",
        "discussion_id": "1925001502",
        "commented_code": "@@ -91,22 +91,26 @@ public record Version(\n    * compared differently based on whether it's digits-only or not.\n    */\n   @AutoCodec\n-  record Identifier(boolean isDigitsOnly, int asNumber, String asString)\n+  record Identifier(boolean isDigitsOnly, long asNumber, String asString)\n       implements Comparable<Identifier> {\n     static Identifier from(String string) throws ParseException {\n       if (Strings.isNullOrEmpty(string)) {\n         throw new ParseException(\"identifier is empty\");\n       }\n       if (string.chars().allMatch(Character::isDigit)) {\n-        return new Identifier(true, Integer.parseInt(string), string);\n+        try {\n+          return new Identifier(true, Long.parseUnsignedLong(string), string);\n+        } catch (NumberFormatException e) {",
        "comment_created_at": "2025-01-22T10:16:34+00:00",
        "comment_author": "fmeum",
        "comment_body": "Should be fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1926055216",
    "pr_number": 24944,
    "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/SkyframeUtil.java",
    "created_at": "2025-01-22T22:20:47+00:00",
    "commented_code": "+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.devtools.build.lib.skyframe;\n+\n+import com.google.common.base.Utf8;\n+import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n+import com.google.devtools.build.lib.packages.semantics.BuildLanguageOptions.Utf8EnforcementMode;\n+import java.util.Optional;\n+import net.starlark.java.syntax.Location;\n+import net.starlark.java.syntax.ParserInput;\n+\n+/** Helper functions for Skyframe. */\n+public final class SkyframeUtil {\n+\n+  /**\n+   * Produces a {@link ParserInput} from the raw bytes of a file while optionally enforcing that the\n+   * contents are valid UTF-8.\n+   *\n+   * <p><b>Warnings and errors are reported to the {@link EventHandler}.</b>\n+   *\n+   * @return an optional with a {@link ParserInput} if the bytes are valid UTF-8 or the enforcement\n+   *     mode is not {@link Utf8EnforcementMode#ERROR}, or an empty {@link Optional} otherwise.\n+   */\n+  // This method is the only one that is supposed to use the deprecated ParserInput.fromLatin1\n+  // method.\n+  @SuppressWarnings(\"deprecation\")\n+  public static Optional<ParserInput> createParserInput(\n+      byte[] bytes, String file, Utf8EnforcementMode utf8EnforcementMode, EventHandler reporter) {\n+    switch (utf8EnforcementMode) {\n+      case OFF -> {}\n+      case WARNING -> {\n+        if (!Utf8.isWellFormed(bytes)) {\n+          reporter.handle(\n+              Event.warn(\n+                  Location.fromFile(file),\n+                  \"not a valid UTF-8 encoded file; this can lead to inconsistent behavior and\"\n+                      + \" will be disallowed in a future version of Bazel\"));\n+        }\n+      }\n+      case ERROR -> {\n+        if (!Utf8.isWellFormed(bytes)) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1926055216",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24944,
        "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/SkyframeUtil.java",
        "discussion_id": "1926055216",
        "commented_code": "@@ -0,0 +1,67 @@\n+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.devtools.build.lib.skyframe;\n+\n+import com.google.common.base.Utf8;\n+import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n+import com.google.devtools.build.lib.packages.semantics.BuildLanguageOptions.Utf8EnforcementMode;\n+import java.util.Optional;\n+import net.starlark.java.syntax.Location;\n+import net.starlark.java.syntax.ParserInput;\n+\n+/** Helper functions for Skyframe. */\n+public final class SkyframeUtil {\n+\n+  /**\n+   * Produces a {@link ParserInput} from the raw bytes of a file while optionally enforcing that the\n+   * contents are valid UTF-8.\n+   *\n+   * <p><b>Warnings and errors are reported to the {@link EventHandler}.</b>\n+   *\n+   * @return an optional with a {@link ParserInput} if the bytes are valid UTF-8 or the enforcement\n+   *     mode is not {@link Utf8EnforcementMode#ERROR}, or an empty {@link Optional} otherwise.\n+   */\n+  // This method is the only one that is supposed to use the deprecated ParserInput.fromLatin1\n+  // method.\n+  @SuppressWarnings(\"deprecation\")\n+  public static Optional<ParserInput> createParserInput(\n+      byte[] bytes, String file, Utf8EnforcementMode utf8EnforcementMode, EventHandler reporter) {\n+    switch (utf8EnforcementMode) {\n+      case OFF -> {}\n+      case WARNING -> {\n+        if (!Utf8.isWellFormed(bytes)) {\n+          reporter.handle(\n+              Event.warn(\n+                  Location.fromFile(file),\n+                  \"not a valid UTF-8 encoded file; this can lead to inconsistent behavior and\"\n+                      + \" will be disallowed in a future version of Bazel\"));\n+        }\n+      }\n+      case ERROR -> {\n+        if (!Utf8.isWellFormed(bytes)) {",
        "comment_created_at": "2025-01-22T22:20:47+00:00",
        "comment_author": "tetromino",
        "comment_body": "Instead of returning an empty optional, I'd recommend throwing an exception.\r\n\r\nThis would allow callers to easily put your exception's message into their own exceptions without needing to stream and stringify events (or they can just throw their own exception with your exception as the cause).",
        "pr_file_module": null
      },
      {
        "comment_id": "1932338120",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24944,
        "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/SkyframeUtil.java",
        "discussion_id": "1926055216",
        "commented_code": "@@ -0,0 +1,67 @@\n+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.devtools.build.lib.skyframe;\n+\n+import com.google.common.base.Utf8;\n+import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n+import com.google.devtools.build.lib.packages.semantics.BuildLanguageOptions.Utf8EnforcementMode;\n+import java.util.Optional;\n+import net.starlark.java.syntax.Location;\n+import net.starlark.java.syntax.ParserInput;\n+\n+/** Helper functions for Skyframe. */\n+public final class SkyframeUtil {\n+\n+  /**\n+   * Produces a {@link ParserInput} from the raw bytes of a file while optionally enforcing that the\n+   * contents are valid UTF-8.\n+   *\n+   * <p><b>Warnings and errors are reported to the {@link EventHandler}.</b>\n+   *\n+   * @return an optional with a {@link ParserInput} if the bytes are valid UTF-8 or the enforcement\n+   *     mode is not {@link Utf8EnforcementMode#ERROR}, or an empty {@link Optional} otherwise.\n+   */\n+  // This method is the only one that is supposed to use the deprecated ParserInput.fromLatin1\n+  // method.\n+  @SuppressWarnings(\"deprecation\")\n+  public static Optional<ParserInput> createParserInput(\n+      byte[] bytes, String file, Utf8EnforcementMode utf8EnforcementMode, EventHandler reporter) {\n+    switch (utf8EnforcementMode) {\n+      case OFF -> {}\n+      case WARNING -> {\n+        if (!Utf8.isWellFormed(bytes)) {\n+          reporter.handle(\n+              Event.warn(\n+                  Location.fromFile(file),\n+                  \"not a valid UTF-8 encoded file; this can lead to inconsistent behavior and\"\n+                      + \" will be disallowed in a future version of Bazel\"));\n+        }\n+      }\n+      case ERROR -> {\n+        if (!Utf8.isWellFormed(bytes)) {",
        "comment_created_at": "2025-01-28T15:03:17+00:00",
        "comment_author": "fmeum",
        "comment_body": "This is nicer indeed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1962229359",
    "pr_number": 24921,
    "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/LocalTemplateExpansionStrategy.java",
    "created_at": "2025-02-19T19:08:00+00:00",
    "commented_code": "TemplateExpansionContext.TemplateMetadata templateMetadata)\n       throws InterruptedException, ExecException {\n     try {\n+      // If writeOutputToFile may retain the writer, make sure that it doesn't capture the\n+      // expanded template string. Since expansion may throw and the writer must not, expand the\n+      // template once before calling writeOutputToFile. It is assumed to be deterministic, so if\n+      // it doesn't throw once, it won't throw again.\n       final String expandedTemplate =\n           getExpandedTemplateUnsafe(\n               templateMetadata.template(), templateMetadata.substitutions(), ctx.getPathResolver());\n-      DeterministicWriter deterministicWriter =\n-          out -> out.write(expandedTemplate.getBytes(ISO_8859_1));\n-      return ctx.getContext(FileWriteActionContext.class)\n-          .writeOutputToFile(\n-              action,\n-              ctx,\n-              deterministicWriter,\n-              templateMetadata.makeExecutable(),\n-              /* isRemotable= */ true);\n+      FileWriteActionContext fileWriteActionContext = ctx.getContext(FileWriteActionContext.class);\n+      DeterministicWriter deterministicWriter;\n+      if (fileWriteActionContext.mayRetainWriter()) {\n+        ArtifactPathResolver pathResolver = ctx.getPathResolver();\n+        deterministicWriter =\n+            out -> {\n+              try {\n+                out.write(\n+                    StringUnsafe.getInternalStringBytes(\n+                        getExpandedTemplateUnsafe(\n+                            templateMetadata.template(),\n+                            templateMetadata.substitutions(),\n+                            pathResolver)));\n+              } catch (EvalException e) {\n+                throw new IllegalStateException(\n+                    \"Template expansion is not deterministic, first succeeded and then failed with: \"\n+                        + e.getMessage(),\n+                    e);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1962229359",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24921,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/LocalTemplateExpansionStrategy.java",
        "discussion_id": "1962229359",
        "commented_code": "@@ -44,18 +44,43 @@ public ImmutableList<SpawnResult> expandTemplate(\n       TemplateExpansionContext.TemplateMetadata templateMetadata)\n       throws InterruptedException, ExecException {\n     try {\n+      // If writeOutputToFile may retain the writer, make sure that it doesn't capture the\n+      // expanded template string. Since expansion may throw and the writer must not, expand the\n+      // template once before calling writeOutputToFile. It is assumed to be deterministic, so if\n+      // it doesn't throw once, it won't throw again.\n       final String expandedTemplate =\n           getExpandedTemplateUnsafe(\n               templateMetadata.template(), templateMetadata.substitutions(), ctx.getPathResolver());\n-      DeterministicWriter deterministicWriter =\n-          out -> out.write(expandedTemplate.getBytes(ISO_8859_1));\n-      return ctx.getContext(FileWriteActionContext.class)\n-          .writeOutputToFile(\n-              action,\n-              ctx,\n-              deterministicWriter,\n-              templateMetadata.makeExecutable(),\n-              /* isRemotable= */ true);\n+      FileWriteActionContext fileWriteActionContext = ctx.getContext(FileWriteActionContext.class);\n+      DeterministicWriter deterministicWriter;\n+      if (fileWriteActionContext.mayRetainWriter()) {\n+        ArtifactPathResolver pathResolver = ctx.getPathResolver();\n+        deterministicWriter =\n+            out -> {\n+              try {\n+                out.write(\n+                    StringUnsafe.getInternalStringBytes(\n+                        getExpandedTemplateUnsafe(\n+                            templateMetadata.template(),\n+                            templateMetadata.substitutions(),\n+                            pathResolver)));\n+              } catch (EvalException e) {\n+                throw new IllegalStateException(\n+                    \"Template expansion is not deterministic, first succeeded and then failed with: \"\n+                        + e.getMessage(),\n+                    e);",
        "comment_created_at": "2025-02-19T19:08:00+00:00",
        "comment_author": "tjgq",
        "comment_body": "It looks like the `getExpandedTemplateUnsafe` implementation doesn't actually throw `EvalException` (and there are no google3 overrides). Can we just amend the method signature?",
        "pr_file_module": null
      },
      {
        "comment_id": "1963263681",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24921,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/LocalTemplateExpansionStrategy.java",
        "discussion_id": "1962229359",
        "commented_code": "@@ -44,18 +44,43 @@ public ImmutableList<SpawnResult> expandTemplate(\n       TemplateExpansionContext.TemplateMetadata templateMetadata)\n       throws InterruptedException, ExecException {\n     try {\n+      // If writeOutputToFile may retain the writer, make sure that it doesn't capture the\n+      // expanded template string. Since expansion may throw and the writer must not, expand the\n+      // template once before calling writeOutputToFile. It is assumed to be deterministic, so if\n+      // it doesn't throw once, it won't throw again.\n       final String expandedTemplate =\n           getExpandedTemplateUnsafe(\n               templateMetadata.template(), templateMetadata.substitutions(), ctx.getPathResolver());\n-      DeterministicWriter deterministicWriter =\n-          out -> out.write(expandedTemplate.getBytes(ISO_8859_1));\n-      return ctx.getContext(FileWriteActionContext.class)\n-          .writeOutputToFile(\n-              action,\n-              ctx,\n-              deterministicWriter,\n-              templateMetadata.makeExecutable(),\n-              /* isRemotable= */ true);\n+      FileWriteActionContext fileWriteActionContext = ctx.getContext(FileWriteActionContext.class);\n+      DeterministicWriter deterministicWriter;\n+      if (fileWriteActionContext.mayRetainWriter()) {\n+        ArtifactPathResolver pathResolver = ctx.getPathResolver();\n+        deterministicWriter =\n+            out -> {\n+              try {\n+                out.write(\n+                    StringUnsafe.getInternalStringBytes(\n+                        getExpandedTemplateUnsafe(\n+                            templateMetadata.template(),\n+                            templateMetadata.substitutions(),\n+                            pathResolver)));\n+              } catch (EvalException e) {\n+                throw new IllegalStateException(\n+                    \"Template expansion is not deterministic, first succeeded and then failed with: \"\n+                        + e.getMessage(),\n+                    e);",
        "comment_created_at": "2025-02-20T10:07:55+00:00",
        "comment_author": "fmeum",
        "comment_body": "It looks like it does throw via the call to `Substitution#getValue`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1838928621",
    "pr_number": 24305,
    "pr_file": "src/main/java/com/google/devtools/build/lib/query2/query/output/StreamedProtoOutputFormatter.java",
    "created_at": "2024-11-12T23:04:15+00:00",
    "commented_code": "public OutputFormatterCallback<Target> createPostFactoStreamCallback(\n       final OutputStream out, final QueryOptions options, LabelPrinter labelPrinter) {\n     return new OutputFormatterCallback<Target>() {\n+      private final LabelPrinter ourLabelPrinter = labelPrinter;\n+\n       @Override\n       public void processOutput(Iterable<Target> partialResult)\n           throws IOException, InterruptedException {\n-        for (Target target : partialResult) {\n-          toTargetProtoBuffer(target, labelPrinter).writeDelimitedTo(out);\n+        try {\n+          StreamSupport.stream(partialResult.spliterator(), /* parallel= */true)\n+              .map(this::toProto)\n+              .map(StreamedProtoOutputFormatter::writeDelimited)\n+              .forEach(this::writeToOutputStreamThreadSafe);\n+        } catch (WrappedIOException e) {\n+          throw e.getCause();\n+        } catch (WrappedInterruptedException e) {\n+          throw e.getCause();\n+        }\n+      }\n+\n+      private Build.Target toProto(Target target) {\n+        try {\n+          return toTargetProtoBuffer(target, ourLabelPrinter);\n+        } catch (InterruptedException e) {\n+          throw new WrappedInterruptedException(e);\n+        }\n+      }\n+\n+      private synchronized void writeToOutputStreamThreadSafe(ByteArrayOutputStream bout) {\n+        try {\n+          bout.writeTo(out);\n+        } catch (IOException e) {\n+          throw new RuntimeException(e);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1838928621",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24305,
        "pr_file": "src/main/java/com/google/devtools/build/lib/query2/query/output/StreamedProtoOutputFormatter.java",
        "discussion_id": "1838928621",
        "commented_code": "@@ -34,13 +38,70 @@ public String getName() {\n   public OutputFormatterCallback<Target> createPostFactoStreamCallback(\n       final OutputStream out, final QueryOptions options, LabelPrinter labelPrinter) {\n     return new OutputFormatterCallback<Target>() {\n+      private final LabelPrinter ourLabelPrinter = labelPrinter;\n+\n       @Override\n       public void processOutput(Iterable<Target> partialResult)\n           throws IOException, InterruptedException {\n-        for (Target target : partialResult) {\n-          toTargetProtoBuffer(target, labelPrinter).writeDelimitedTo(out);\n+        try {\n+          StreamSupport.stream(partialResult.spliterator(), /* parallel= */true)\n+              .map(this::toProto)\n+              .map(StreamedProtoOutputFormatter::writeDelimited)\n+              .forEach(this::writeToOutputStreamThreadSafe);\n+        } catch (WrappedIOException e) {\n+          throw e.getCause();\n+        } catch (WrappedInterruptedException e) {\n+          throw e.getCause();\n+        }\n+      }\n+\n+      private Build.Target toProto(Target target) {\n+        try {\n+          return toTargetProtoBuffer(target, ourLabelPrinter);\n+        } catch (InterruptedException e) {\n+          throw new WrappedInterruptedException(e);\n+        }\n+      }\n+\n+      private synchronized void writeToOutputStreamThreadSafe(ByteArrayOutputStream bout) {\n+        try {\n+          bout.writeTo(out);\n+        } catch (IOException e) {\n+          throw new RuntimeException(e);",
        "comment_created_at": "2024-11-12T23:04:15+00:00",
        "comment_author": "fmeum",
        "comment_body": "```suggestion\n          throw new WrappedIOException(e);\n```\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1838958470",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24305,
        "pr_file": "src/main/java/com/google/devtools/build/lib/query2/query/output/StreamedProtoOutputFormatter.java",
        "discussion_id": "1838928621",
        "commented_code": "@@ -34,13 +38,70 @@ public String getName() {\n   public OutputFormatterCallback<Target> createPostFactoStreamCallback(\n       final OutputStream out, final QueryOptions options, LabelPrinter labelPrinter) {\n     return new OutputFormatterCallback<Target>() {\n+      private final LabelPrinter ourLabelPrinter = labelPrinter;\n+\n       @Override\n       public void processOutput(Iterable<Target> partialResult)\n           throws IOException, InterruptedException {\n-        for (Target target : partialResult) {\n-          toTargetProtoBuffer(target, labelPrinter).writeDelimitedTo(out);\n+        try {\n+          StreamSupport.stream(partialResult.spliterator(), /* parallel= */true)\n+              .map(this::toProto)\n+              .map(StreamedProtoOutputFormatter::writeDelimited)\n+              .forEach(this::writeToOutputStreamThreadSafe);\n+        } catch (WrappedIOException e) {\n+          throw e.getCause();\n+        } catch (WrappedInterruptedException e) {\n+          throw e.getCause();\n+        }\n+      }\n+\n+      private Build.Target toProto(Target target) {\n+        try {\n+          return toTargetProtoBuffer(target, ourLabelPrinter);\n+        } catch (InterruptedException e) {\n+          throw new WrappedInterruptedException(e);\n+        }\n+      }\n+\n+      private synchronized void writeToOutputStreamThreadSafe(ByteArrayOutputStream bout) {\n+        try {\n+          bout.writeTo(out);\n+        } catch (IOException e) {\n+          throw new RuntimeException(e);",
        "comment_created_at": "2024-11-12T23:21:26+00:00",
        "comment_author": "keithl-stripe",
        "comment_body": "good catch!! fixed.",
        "pr_file_module": null
      }
    ]
  }
]