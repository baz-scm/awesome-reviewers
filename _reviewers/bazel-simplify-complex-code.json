[
  {
    "discussion_id": "885423544",
    "pr_number": 15594,
    "pr_file": "src/main/java/net/starlark/java/eval/Eval.java",
    "created_at": "2022-05-31T09:36:57+00:00",
    "commented_code": "// AND and OR require short-circuit evaluation.\n     switch (binop.getOperator()) {\n       case AND:\n-        return Starlark.truth(x) ? eval(fr, binop.getY()) : x;\n+        if (Starlark.truth(x)) {\n+          return eval(fr, binop.getY());\n+        } else {\n+          CoverageRecorder.getInstance().recordVirtualJump(binop);\n+          return x;\n+        }",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "885423544",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 15594,
        "pr_file": "src/main/java/net/starlark/java/eval/Eval.java",
        "discussion_id": "885423544",
        "commented_code": "@@ -533,9 +548,19 @@ private static Object evalBinaryOperator(StarlarkThread.Frame fr, BinaryOperator\n     // AND and OR require short-circuit evaluation.\n     switch (binop.getOperator()) {\n       case AND:\n-        return Starlark.truth(x) ? eval(fr, binop.getY()) : x;\n+        if (Starlark.truth(x)) {\n+          return eval(fr, binop.getY());\n+        } else {\n+          CoverageRecorder.getInstance().recordVirtualJump(binop);\n+          return x;\n+        }",
        "comment_created_at": "2022-05-31T09:36:57+00:00",
        "comment_author": "sluongng",
        "comment_body": "could be rewritten without `else`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2004211680",
    "pr_number": 25540,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/commands/ModCommand.java",
    "created_at": "2025-03-19T20:13:22+00:00",
    "commented_code": "}\n \n     try (var stdin = CharSource.wrap(buildozerInput).asByteSource(UTF_8).openStream()) {\n-      new CommandBuilder()\n+      if (write) {\n+        new CommandBuilder()\n+            .setWorkingDir(env.getWorkspace())\n+            .addArg(modTidyValue.buildozer().getPathString())\n+            .addArg(\"-f\")\n+            .addArg(\"-\")",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2004211680",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25540,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/commands/ModCommand.java",
        "discussion_id": "2004211680",
        "commented_code": "@@ -565,14 +567,28 @@ private BlazeCommandResult runTidy(CommandEnvironment env, BazelModTidyValue mod\n     }\n \n     try (var stdin = CharSource.wrap(buildozerInput).asByteSource(UTF_8).openStream()) {\n-      new CommandBuilder()\n+      if (write) {\n+        new CommandBuilder()\n+            .setWorkingDir(env.getWorkspace())\n+            .addArg(modTidyValue.buildozer().getPathString())\n+            .addArg(\"-f\")\n+            .addArg(\"-\")",
        "comment_created_at": "2025-03-19T20:13:22+00:00",
        "comment_author": "fmeum",
        "comment_body": "Could we share the common part of the construction of the builder between the branches?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983448529",
    "pr_number": 25368,
    "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkCustomCommandLine.java",
    "created_at": "2025-03-06T14:22:39+00:00",
    "commented_code": "@Override\n     public int numArgs() {\n-      return (beforeEach != null ? 2 : 1) * stringValues.size();\n+      return (beforeEach != null ? 2 : 1) * values.size();\n     }\n \n     @Override\n-    public int totalArgLength() {\n+    public int totalArgLength(PathMapper pathMapper) {\n       int total = 0;\n-      for (String arg : stringValues) {\n-        total += arg.length();\n+      for (Object arg : values) {\n+        switch (arg) {\n+          case String string -> total += string.length();\n+          case DerivedArtifact artifact ->\n+              total +=\n+                  artifact.getExecPathString().length()\n+                      + pathMapper.computeExecPathLengthDiff(artifact);\n+          default -> throw new AssertionError(\"Unexpected value type: \" + arg);\n+        }\n       }\n       if (formatEach != null) {\n-        total += SingleStringArgFormatter.formattedLength(formatEach) * stringValues.size();\n+        total += SingleStringArgFormatter.formattedLength(formatEach) * values.size();\n       }\n       if (beforeEach != null) {\n-        total += beforeEach.length() * stringValues.size();\n+        total += beforeEach.length() * values.size();\n       }\n       return total + numArgs();\n     }\n   }\n \n   /** Preprocessed version of a {@link VectorArg} originating from {@code Args.add_joined}. */\n   private static final class JoinedPreprocessedVectorArg implements PreprocessedArg {\n-    private final List<String> stringValues;\n+    private final List<Object /* String | DerivedArtifact */> values;\n     @Nullable private final String formatEach;\n     private final String joinWith;\n     @Nullable private final String formatJoined;\n \n     JoinedPreprocessedVectorArg(\n-        List<String> stringValues,\n+        List<Object /* String | DerivedArtifact */> values,\n         @Nullable String formatEach,\n         String joinWith,\n         @Nullable String formatJoined) {\n-      this.stringValues = stringValues;\n+      this.values = values;\n       this.formatEach = formatEach;\n       this.joinWith = joinWith;\n       this.formatJoined = formatJoined;\n     }\n \n     @Override\n-    public Iterator<String> iterator() {\n-      Iterator<String> it = stringValues.iterator();\n+    public Iterator<String> iterator(PathMapper pathMapper) {\n+      Iterator<String> it =\n+          Iterables.transform(\n+                  values,\n+                  value ->",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1983448529",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25368,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/starlark/StarlarkCustomCommandLine.java",
        "discussion_id": "1983448529",
        "commented_code": "@@ -1521,46 +1602,63 @@ public Iterator<String> iterator() {\n \n     @Override\n     public int numArgs() {\n-      return (beforeEach != null ? 2 : 1) * stringValues.size();\n+      return (beforeEach != null ? 2 : 1) * values.size();\n     }\n \n     @Override\n-    public int totalArgLength() {\n+    public int totalArgLength(PathMapper pathMapper) {\n       int total = 0;\n-      for (String arg : stringValues) {\n-        total += arg.length();\n+      for (Object arg : values) {\n+        switch (arg) {\n+          case String string -> total += string.length();\n+          case DerivedArtifact artifact ->\n+              total +=\n+                  artifact.getExecPathString().length()\n+                      + pathMapper.computeExecPathLengthDiff(artifact);\n+          default -> throw new AssertionError(\"Unexpected value type: \" + arg);\n+        }\n       }\n       if (formatEach != null) {\n-        total += SingleStringArgFormatter.formattedLength(formatEach) * stringValues.size();\n+        total += SingleStringArgFormatter.formattedLength(formatEach) * values.size();\n       }\n       if (beforeEach != null) {\n-        total += beforeEach.length() * stringValues.size();\n+        total += beforeEach.length() * values.size();\n       }\n       return total + numArgs();\n     }\n   }\n \n   /** Preprocessed version of a {@link VectorArg} originating from {@code Args.add_joined}. */\n   private static final class JoinedPreprocessedVectorArg implements PreprocessedArg {\n-    private final List<String> stringValues;\n+    private final List<Object /* String | DerivedArtifact */> values;\n     @Nullable private final String formatEach;\n     private final String joinWith;\n     @Nullable private final String formatJoined;\n \n     JoinedPreprocessedVectorArg(\n-        List<String> stringValues,\n+        List<Object /* String | DerivedArtifact */> values,\n         @Nullable String formatEach,\n         String joinWith,\n         @Nullable String formatJoined) {\n-      this.stringValues = stringValues;\n+      this.values = values;\n       this.formatEach = formatEach;\n       this.joinWith = joinWith;\n       this.formatJoined = formatJoined;\n     }\n \n     @Override\n-    public Iterator<String> iterator() {\n-      Iterator<String> it = stringValues.iterator();\n+    public Iterator<String> iterator(PathMapper pathMapper) {\n+      Iterator<String> it =\n+          Iterables.transform(\n+                  values,\n+                  value ->",
        "comment_created_at": "2025-03-06T14:22:39+00:00",
        "comment_author": "justinhorvitz",
        "comment_body": "Same transform is done `UnjoinedPreprocessedVectorArg`. Worth sharing a helper method like `pathMap(Object, PathMapper)`? I think it makes sense to not hide the call to `Iterables.transform` in the helper method.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1984145901",
    "pr_number": 25368,
    "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/StrippingPathMapper.java",
    "created_at": "2025-03-06T22:38:48+00:00",
    "commented_code": "return PathMapper.super.mapRoot(artifact);\n   }\n \n-  private boolean isSupportedInputType(ActionInput artifact) {\n+  private boolean isSupported(ActionInput artifact) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1984145901",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 25368,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/actions/StrippingPathMapper.java",
        "discussion_id": "1984145901",
        "commented_code": "@@ -204,10 +213,10 @@ public FileRootApi mapRoot(Artifact artifact) {\n     return PathMapper.super.mapRoot(artifact);\n   }\n \n-  private boolean isSupportedInputType(ActionInput artifact) {\n+  private boolean isSupported(ActionInput artifact) {",
        "comment_created_at": "2025-03-06T22:38:48+00:00",
        "comment_author": "justinhorvitz",
        "comment_body": "Break into early returns to make the conditions cleaner.\r\n\r\n```java\r\nif (artifact instanceof DerivedArtifact) {\r\n  return true;\r\n}\r\nif (artifact instanceof BasicActionInput || artifact instanceof VirtualActionInput) {\r\n  return isOutputPath(artifact, outputRoot);\r\n}\r\nreturn false;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2099064343",
    "pr_number": 26092,
    "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
    "created_at": "2025-05-21T00:09:52+00:00",
    "commented_code": "+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(\n+            ImmutableList.of(() -> run(functionName, input, memLimits)),\n+            timeout.toMillis(),\n+            TimeUnit.MILLISECONDS);\n+      } catch (TimeoutException e) {\n+        errMessage = String.format(\"Error executing %s: timed out\", functionName);\n+      } catch (ExecutionException e) {\n+        errMessage = String.format(\"Error executing %s: %s\", functionName, e.getCause().getMessage());\n+      }\n+      return StarlarkWasmExecutionResult.newErr(errMessage);\n+    }\n+  }\n+\n+  private StarlarkWasmExecutionResult run(String execFunc, byte[] input, MemoryLimits memLimits)\n+      throws EvalException, InterruptedException {\n+    Instance instance;\n+    Profiler prof = Profiler.instance();\n+    try {\n+      instance = Instance.builder(wasmModule)\n+          .withMemoryLimits(memLimits)\n+          // Disable calling `_start()`, which is the entry point for WASI-style\n+          // command modules.\n+          .withStart(false)\n+          // Chicory documentation recommends ByteArrayMemory for OpenJDK\n+          // https://chicory.dev/docs/advanced/memory\n+          .withMemoryFactory(limits -> { return new ByteArrayMemory(limits); })\n+          .build();\n+      // If `_initialize()` is present then call it to perform early setup.\n+      ExportFunction initFn = instance.export(\"_initialize\");\n+      if (initFn != null) {\n+        try (SilentCloseable c = prof.profile(WASM_EXEC, \"initialize\")) {\n+          initFn.apply();\n+        }\n+      }\n+    } catch (ChicoryException e) {\n+      throw new EvalException(e);\n+    }\n+\n+    var memory = instance.memory();\n+    ExportFunction allocFn = instance.export(allocateFn);\n+    // FIXME: Is this check needed? Might be redundant with validateModule().\n+    if (allocFn == null) {\n+      throw Starlark.errorf(\"WebAssembly module doesn't export \\\"%s\\\"\", allocateFn);\n+    }\n+    ExportFunction execFn = instance.export(execFunc);\n+    // FIXME: Validate execFn has the expected signature?\n+    if (execFn == null) {\n+      throw Starlark.errorf(\"WebAssembly module doesn't export \\\"%s\\\"\", execFunc);\n+    }\n+\n+    int inputLen = Math.toIntExact(input.length);\n+    int inputPtr = alloc(allocateFn, allocFn, inputLen, 1);\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, \"copy input\")) {\n+      memory.write(inputPtr, input);\n+    }\n+\n+    // struct { output_ptr_ptr: **u8, output_len_ptr: *u32 }\n+    int paramsPtr = alloc(allocateFn, allocFn, 8, 4);\n+    int outputPtrPtr = paramsPtr;\n+    int outputLenPtr = paramsPtr + 4;\n+    memory.writeI32(outputPtrPtr, 0);\n+    memory.writeI32(outputLenPtr, 0);\n+\n+    long[] execResult;\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, \"execute\")) {\n+      execResult = execFn.apply(inputPtr, inputLen, outputPtrPtr, outputLenPtr);\n+    }\n+\n+    // FIXME: Not 100% sure this check is necessary, but the ambiguity between\n+    // signed/unsigned in Java vs WebAssembly makes me nervous.\n+    //\n+    // Might be unnecessary if the function signature is verified before execution?\n+    long returnCode = execResult[0];\n+    if (returnCode < 0 || returnCode > 0xFFFFFFFFL) {\n+      returnCode = 0xFFFFFFFFL;\n+    }\n+    int outputPtr = memory.readInt(outputPtrPtr);\n+    int outputLen = memory.readInt(outputLenPtr);\n+\n+    String output = \"\";\n+    if (outputLen > 0) {\n+      try (SilentCloseable c = prof.profile(WASM_EXEC, \"copy output\")) {\n+        byte[] outputBytes = memory.readBytes(outputPtr, outputLen);\n+        output = new String(outputBytes, ISO_8859_1);\n+      }\n+    }\n+    return StarlarkWasmExecutionResult.newOk(returnCode, output);\n+  }\n+\n+  private static void validateModule(WasmModule wasmModule, String allocateFn) throws EvalException {\n+    var exports = wasmModule.exportSection();\n+    int exportCount = exports.exportCount();\n+    for (int ii = 0; ii < exportCount; ii++) {\n+      var export = exports.getExport(ii);\n+      if (export.name().equals(allocateFn)) {\n+        // FIXME: Validate exported type is a function and has the expected signature?\n+        return;\n+      }\n+    }\n+    throw Starlark.errorf(\"WebAssembly module doesn't contain an export named \\\"%s\\\"\", allocateFn);\n+  }\n+\n+  MemoryLimits getMemLimits(long memLimitBytes) {\n+    int initialPages = 1;\n+    int memLimitPages = getMemLimitPages(memLimitBytes);\n+\n+    if (wasmModule.memorySection().isPresent()) {\n+      var memories = wasmModule.memorySection().get();\n+      int memoryCount = memories.memoryCount();\n+      for (int ii = 0; ii < memoryCount; ii++) {\n+        MemoryLimits limits = memories.getMemory(ii).limits();\n+        if (limits.initialPages() > initialPages) {\n+          initialPages = limits.initialPages();\n+        }\n+      }\n+    }\n+    if (initialPages > memLimitPages) {\n+      // FIXME: Should probably throw an exception. The execution will likely fail anyway, and\n+      // throwing an exception from this point would provide more relevant details.\n+      initialPages = memLimitPages;\n+    }\n+    return new MemoryLimits(initialPages, memLimitPages);\n+  }\n+\n+  static int getMemLimitPages(long memLimitBytes) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2099064343",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26092,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
        "discussion_id": "2099064343",
        "commented_code": "@@ -0,0 +1,278 @@\n+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(\n+            ImmutableList.of(() -> run(functionName, input, memLimits)),\n+            timeout.toMillis(),\n+            TimeUnit.MILLISECONDS);\n+      } catch (TimeoutException e) {\n+        errMessage = String.format(\"Error executing %s: timed out\", functionName);\n+      } catch (ExecutionException e) {\n+        errMessage = String.format(\"Error executing %s: %s\", functionName, e.getCause().getMessage());\n+      }\n+      return StarlarkWasmExecutionResult.newErr(errMessage);\n+    }\n+  }\n+\n+  private StarlarkWasmExecutionResult run(String execFunc, byte[] input, MemoryLimits memLimits)\n+      throws EvalException, InterruptedException {\n+    Instance instance;\n+    Profiler prof = Profiler.instance();\n+    try {\n+      instance = Instance.builder(wasmModule)\n+          .withMemoryLimits(memLimits)\n+          // Disable calling `_start()`, which is the entry point for WASI-style\n+          // command modules.\n+          .withStart(false)\n+          // Chicory documentation recommends ByteArrayMemory for OpenJDK\n+          // https://chicory.dev/docs/advanced/memory\n+          .withMemoryFactory(limits -> { return new ByteArrayMemory(limits); })\n+          .build();\n+      // If `_initialize()` is present then call it to perform early setup.\n+      ExportFunction initFn = instance.export(\"_initialize\");\n+      if (initFn != null) {\n+        try (SilentCloseable c = prof.profile(WASM_EXEC, \"initialize\")) {\n+          initFn.apply();\n+        }\n+      }\n+    } catch (ChicoryException e) {\n+      throw new EvalException(e);\n+    }\n+\n+    var memory = instance.memory();\n+    ExportFunction allocFn = instance.export(allocateFn);\n+    // FIXME: Is this check needed? Might be redundant with validateModule().\n+    if (allocFn == null) {\n+      throw Starlark.errorf(\"WebAssembly module doesn't export \\\"%s\\\"\", allocateFn);\n+    }\n+    ExportFunction execFn = instance.export(execFunc);\n+    // FIXME: Validate execFn has the expected signature?\n+    if (execFn == null) {\n+      throw Starlark.errorf(\"WebAssembly module doesn't export \\\"%s\\\"\", execFunc);\n+    }\n+\n+    int inputLen = Math.toIntExact(input.length);\n+    int inputPtr = alloc(allocateFn, allocFn, inputLen, 1);\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, \"copy input\")) {\n+      memory.write(inputPtr, input);\n+    }\n+\n+    // struct { output_ptr_ptr: **u8, output_len_ptr: *u32 }\n+    int paramsPtr = alloc(allocateFn, allocFn, 8, 4);\n+    int outputPtrPtr = paramsPtr;\n+    int outputLenPtr = paramsPtr + 4;\n+    memory.writeI32(outputPtrPtr, 0);\n+    memory.writeI32(outputLenPtr, 0);\n+\n+    long[] execResult;\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, \"execute\")) {\n+      execResult = execFn.apply(inputPtr, inputLen, outputPtrPtr, outputLenPtr);\n+    }\n+\n+    // FIXME: Not 100% sure this check is necessary, but the ambiguity between\n+    // signed/unsigned in Java vs WebAssembly makes me nervous.\n+    //\n+    // Might be unnecessary if the function signature is verified before execution?\n+    long returnCode = execResult[0];\n+    if (returnCode < 0 || returnCode > 0xFFFFFFFFL) {\n+      returnCode = 0xFFFFFFFFL;\n+    }\n+    int outputPtr = memory.readInt(outputPtrPtr);\n+    int outputLen = memory.readInt(outputLenPtr);\n+\n+    String output = \"\";\n+    if (outputLen > 0) {\n+      try (SilentCloseable c = prof.profile(WASM_EXEC, \"copy output\")) {\n+        byte[] outputBytes = memory.readBytes(outputPtr, outputLen);\n+        output = new String(outputBytes, ISO_8859_1);\n+      }\n+    }\n+    return StarlarkWasmExecutionResult.newOk(returnCode, output);\n+  }\n+\n+  private static void validateModule(WasmModule wasmModule, String allocateFn) throws EvalException {\n+    var exports = wasmModule.exportSection();\n+    int exportCount = exports.exportCount();\n+    for (int ii = 0; ii < exportCount; ii++) {\n+      var export = exports.getExport(ii);\n+      if (export.name().equals(allocateFn)) {\n+        // FIXME: Validate exported type is a function and has the expected signature?\n+        return;\n+      }\n+    }\n+    throw Starlark.errorf(\"WebAssembly module doesn't contain an export named \\\"%s\\\"\", allocateFn);\n+  }\n+\n+  MemoryLimits getMemLimits(long memLimitBytes) {\n+    int initialPages = 1;\n+    int memLimitPages = getMemLimitPages(memLimitBytes);\n+\n+    if (wasmModule.memorySection().isPresent()) {\n+      var memories = wasmModule.memorySection().get();\n+      int memoryCount = memories.memoryCount();\n+      for (int ii = 0; ii < memoryCount; ii++) {\n+        MemoryLimits limits = memories.getMemory(ii).limits();\n+        if (limits.initialPages() > initialPages) {\n+          initialPages = limits.initialPages();\n+        }\n+      }\n+    }\n+    if (initialPages > memLimitPages) {\n+      // FIXME: Should probably throw an exception. The execution will likely fail anyway, and\n+      // throwing an exception from this point would provide more relevant details.\n+      initialPages = memLimitPages;\n+    }\n+    return new MemoryLimits(initialPages, memLimitPages);\n+  }\n+\n+  static int getMemLimitPages(long memLimitBytes) {",
        "comment_created_at": "2025-05-21T00:09:52+00:00",
        "comment_author": "Wyverald",
        "comment_body": "this function can be replaced with `Math.min(MAX_PAGES, Math.ceilDiv(memLimitBytes, PAGE_SIZE))`. IMO it's also more readable that way, as it clearly describes the intent.",
        "pr_file_module": null
      },
      {
        "comment_id": "2099469179",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26092,
        "pr_file": "src/main/java/com/google/devtools/build/lib/bazel/repository/starlark/StarlarkWasmModule.java",
        "discussion_id": "2099064343",
        "commented_code": "@@ -0,0 +1,278 @@\n+// Copyright 2025 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.devtools.build.lib.bazel.repository.starlark;\n+\n+import static com.dylibso.chicory.runtime.Memory.PAGE_SIZE;\n+import static com.dylibso.chicory.wasm.types.MemoryLimits.MAX_PAGES;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_LOAD;\n+import static com.google.devtools.build.lib.profiler.ProfilerTask.WASM_EXEC;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+import com.dylibso.chicory.runtime.ByteArrayMemory;\n+import com.dylibso.chicory.runtime.ExportFunction;\n+import com.dylibso.chicory.runtime.Instance;\n+import com.dylibso.chicory.wasm.ChicoryException;\n+import com.dylibso.chicory.wasm.types.MemoryLimits;\n+import com.dylibso.chicory.wasm.WasmModule;\n+import com.google.common.collect.ImmutableList;\n+import com.google.devtools.build.docgen.annot.DocCategory;\n+import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;\n+import com.google.devtools.build.lib.profiler.Profiler;\n+import com.google.devtools.build.lib.profiler.SilentCloseable;\n+import java.time.Duration;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import net.starlark.java.annot.StarlarkBuiltin;\n+import net.starlark.java.annot.StarlarkMethod;\n+import net.starlark.java.eval.EvalException;\n+import net.starlark.java.eval.Printer;\n+import net.starlark.java.eval.Starlark;\n+import net.starlark.java.eval.StarlarkValue;\n+\n+@Immutable\n+@StarlarkBuiltin(\n+    name = \"wasm_module\",\n+    category = DocCategory.BUILTIN,\n+    doc = \"A WebAssembly module loaded by <code>repository_ctx.load_wasm()</code>.\")\n+final class StarlarkWasmModule implements StarlarkValue {\n+  private final StarlarkPath path;\n+  private final Object origPath;\n+  private final WasmModule wasmModule;\n+  private final String allocateFn;\n+\n+  public StarlarkWasmModule(\n+      StarlarkPath path,\n+      Object origPath,\n+      byte[] moduleContent,\n+      String allocateFn)\n+      throws EvalException {\n+    WasmModule wasmModule;\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c1 = prof.profile(WASM_LOAD, () -> \"load \" + path.toString())) {\n+      try (SilentCloseable c2 = prof.profile(WASM_LOAD, \"parse\")) {\n+        try {\n+          wasmModule = com.dylibso.chicory.wasm.Parser.parse(moduleContent);\n+        } catch (ChicoryException e) {\n+          throw new EvalException(e);\n+        }\n+      }\n+      validateModule(wasmModule, allocateFn);\n+    }\n+\n+    this.path = path;\n+    this.origPath = origPath;\n+    this.wasmModule = wasmModule;\n+    this.allocateFn = allocateFn;\n+  }\n+\n+  @Override\n+  public boolean isImmutable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void repr(Printer printer) {\n+    printer.append(\"<wasm_module path=\");\n+    printer.repr(origPath);\n+    printer.append(\">\");\n+  }\n+\n+  public StarlarkPath getPath() {\n+    return path;\n+  }\n+\n+  @StarlarkMethod(\n+      name = \"path\",\n+      structField = true,\n+      doc = \"The path this WebAssembly module was loaded from.\")\n+  public Object getOrigPath() {\n+    return origPath;\n+  }\n+\n+  public StarlarkWasmExecutionResult execute(\n+      String functionName,\n+      byte[] input,\n+      Duration timeout,\n+      long memLimitBytes)\n+      throws EvalException, InterruptedException {\n+    Profiler prof = Profiler.instance();\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, () -> \"execute \" + functionName)) {\n+      var memLimits = getMemLimits(memLimitBytes);\n+      // Perform initialization and execution in a separate thread so it can be interrupted\n+      // in case of timeout.\n+      var wasmThreadFactory =\n+          Thread.ofPlatform().name(Thread.currentThread().getName() + \"_wasm\").factory();\n+      StarlarkWasmExecutionResult result;\n+      String errMessage;\n+      try (var executor = Executors.newSingleThreadExecutor(wasmThreadFactory)) {\n+        return executor.invokeAny(\n+            ImmutableList.of(() -> run(functionName, input, memLimits)),\n+            timeout.toMillis(),\n+            TimeUnit.MILLISECONDS);\n+      } catch (TimeoutException e) {\n+        errMessage = String.format(\"Error executing %s: timed out\", functionName);\n+      } catch (ExecutionException e) {\n+        errMessage = String.format(\"Error executing %s: %s\", functionName, e.getCause().getMessage());\n+      }\n+      return StarlarkWasmExecutionResult.newErr(errMessage);\n+    }\n+  }\n+\n+  private StarlarkWasmExecutionResult run(String execFunc, byte[] input, MemoryLimits memLimits)\n+      throws EvalException, InterruptedException {\n+    Instance instance;\n+    Profiler prof = Profiler.instance();\n+    try {\n+      instance = Instance.builder(wasmModule)\n+          .withMemoryLimits(memLimits)\n+          // Disable calling `_start()`, which is the entry point for WASI-style\n+          // command modules.\n+          .withStart(false)\n+          // Chicory documentation recommends ByteArrayMemory for OpenJDK\n+          // https://chicory.dev/docs/advanced/memory\n+          .withMemoryFactory(limits -> { return new ByteArrayMemory(limits); })\n+          .build();\n+      // If `_initialize()` is present then call it to perform early setup.\n+      ExportFunction initFn = instance.export(\"_initialize\");\n+      if (initFn != null) {\n+        try (SilentCloseable c = prof.profile(WASM_EXEC, \"initialize\")) {\n+          initFn.apply();\n+        }\n+      }\n+    } catch (ChicoryException e) {\n+      throw new EvalException(e);\n+    }\n+\n+    var memory = instance.memory();\n+    ExportFunction allocFn = instance.export(allocateFn);\n+    // FIXME: Is this check needed? Might be redundant with validateModule().\n+    if (allocFn == null) {\n+      throw Starlark.errorf(\"WebAssembly module doesn't export \\\"%s\\\"\", allocateFn);\n+    }\n+    ExportFunction execFn = instance.export(execFunc);\n+    // FIXME: Validate execFn has the expected signature?\n+    if (execFn == null) {\n+      throw Starlark.errorf(\"WebAssembly module doesn't export \\\"%s\\\"\", execFunc);\n+    }\n+\n+    int inputLen = Math.toIntExact(input.length);\n+    int inputPtr = alloc(allocateFn, allocFn, inputLen, 1);\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, \"copy input\")) {\n+      memory.write(inputPtr, input);\n+    }\n+\n+    // struct { output_ptr_ptr: **u8, output_len_ptr: *u32 }\n+    int paramsPtr = alloc(allocateFn, allocFn, 8, 4);\n+    int outputPtrPtr = paramsPtr;\n+    int outputLenPtr = paramsPtr + 4;\n+    memory.writeI32(outputPtrPtr, 0);\n+    memory.writeI32(outputLenPtr, 0);\n+\n+    long[] execResult;\n+    try (SilentCloseable c = prof.profile(WASM_EXEC, \"execute\")) {\n+      execResult = execFn.apply(inputPtr, inputLen, outputPtrPtr, outputLenPtr);\n+    }\n+\n+    // FIXME: Not 100% sure this check is necessary, but the ambiguity between\n+    // signed/unsigned in Java vs WebAssembly makes me nervous.\n+    //\n+    // Might be unnecessary if the function signature is verified before execution?\n+    long returnCode = execResult[0];\n+    if (returnCode < 0 || returnCode > 0xFFFFFFFFL) {\n+      returnCode = 0xFFFFFFFFL;\n+    }\n+    int outputPtr = memory.readInt(outputPtrPtr);\n+    int outputLen = memory.readInt(outputLenPtr);\n+\n+    String output = \"\";\n+    if (outputLen > 0) {\n+      try (SilentCloseable c = prof.profile(WASM_EXEC, \"copy output\")) {\n+        byte[] outputBytes = memory.readBytes(outputPtr, outputLen);\n+        output = new String(outputBytes, ISO_8859_1);\n+      }\n+    }\n+    return StarlarkWasmExecutionResult.newOk(returnCode, output);\n+  }\n+\n+  private static void validateModule(WasmModule wasmModule, String allocateFn) throws EvalException {\n+    var exports = wasmModule.exportSection();\n+    int exportCount = exports.exportCount();\n+    for (int ii = 0; ii < exportCount; ii++) {\n+      var export = exports.getExport(ii);\n+      if (export.name().equals(allocateFn)) {\n+        // FIXME: Validate exported type is a function and has the expected signature?\n+        return;\n+      }\n+    }\n+    throw Starlark.errorf(\"WebAssembly module doesn't contain an export named \\\"%s\\\"\", allocateFn);\n+  }\n+\n+  MemoryLimits getMemLimits(long memLimitBytes) {\n+    int initialPages = 1;\n+    int memLimitPages = getMemLimitPages(memLimitBytes);\n+\n+    if (wasmModule.memorySection().isPresent()) {\n+      var memories = wasmModule.memorySection().get();\n+      int memoryCount = memories.memoryCount();\n+      for (int ii = 0; ii < memoryCount; ii++) {\n+        MemoryLimits limits = memories.getMemory(ii).limits();\n+        if (limits.initialPages() > initialPages) {\n+          initialPages = limits.initialPages();\n+        }\n+      }\n+    }\n+    if (initialPages > memLimitPages) {\n+      // FIXME: Should probably throw an exception. The execution will likely fail anyway, and\n+      // throwing an exception from this point would provide more relevant details.\n+      initialPages = memLimitPages;\n+    }\n+    return new MemoryLimits(initialPages, memLimitPages);\n+  }\n+\n+  static int getMemLimitPages(long memLimitBytes) {",
        "comment_created_at": "2025-05-21T06:34:28+00:00",
        "comment_author": "jmillikin",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2081785831",
    "pr_number": 26035,
    "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/config/ConfigMatchingProvider.java",
    "created_at": "2025-05-09T14:16:54+00:00",
    "commented_code": "* <p>e.g. If merging where one is InError and the other is No, then currently will propagate the\n    * errors, versus a more aggressive future approach could just propagate No.)\n    */\n-  // TODO(twigg): This is more cleanly implemented when Java record is available.\n-  public static interface MatchResult {\n-    // Only InError should return non-null.\n-    public abstract @Nullable String getError();\n-\n-    public static final MatchResult MATCH = HasResult.MATCH;\n-    public static final MatchResult NOMATCH = HasResult.NOMATCH;\n-\n-    /** Some specified error makes the match question irresolvable. */\n-    @AutoValue\n-    public abstract class InError implements MatchResult {\n-      public static InError create(String error) {\n-        return new AutoValue_ConfigMatchingProvider_MatchResult_InError(error);\n+  public sealed interface MatchResult {\n+    @AutoCodec\n+    public record Match() implements MatchResult {}\n+\n+    MatchResult MATCH = new Match();\n+\n+    @AutoCodec\n+    public record NoMatch(ImmutableList<Diff> diffs) implements MatchResult {\n+      @AutoCodec.Instantiator\n+      public NoMatch {}\n+\n+      public NoMatch(Diff diff) {\n+        this(ImmutableList.of(diff));\n       }\n-    }\n \n-    public static MatchResult create(boolean matches) {\n-      return matches ? MATCH : NOMATCH;\n+      @AutoCodec\n+      public record Diff(Label what, String got, String want) {}",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2081785831",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26035,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/config/ConfigMatchingProvider.java",
        "discussion_id": "2081785831",
        "commented_code": "@@ -45,38 +45,63 @@ public abstract class ConfigMatchingProvider implements TransitiveInfoProvider {\n    * <p>e.g. If merging where one is InError and the other is No, then currently will propagate the\n    * errors, versus a more aggressive future approach could just propagate No.)\n    */\n-  // TODO(twigg): This is more cleanly implemented when Java record is available.\n-  public static interface MatchResult {\n-    // Only InError should return non-null.\n-    public abstract @Nullable String getError();\n-\n-    public static final MatchResult MATCH = HasResult.MATCH;\n-    public static final MatchResult NOMATCH = HasResult.NOMATCH;\n-\n-    /** Some specified error makes the match question irresolvable. */\n-    @AutoValue\n-    public abstract class InError implements MatchResult {\n-      public static InError create(String error) {\n-        return new AutoValue_ConfigMatchingProvider_MatchResult_InError(error);\n+  public sealed interface MatchResult {\n+    @AutoCodec\n+    public record Match() implements MatchResult {}\n+\n+    MatchResult MATCH = new Match();\n+\n+    @AutoCodec\n+    public record NoMatch(ImmutableList<Diff> diffs) implements MatchResult {\n+      @AutoCodec.Instantiator\n+      public NoMatch {}\n+\n+      public NoMatch(Diff diff) {\n+        this(ImmutableList.of(diff));\n       }\n-    }\n \n-    public static MatchResult create(boolean matches) {\n-      return matches ? MATCH : NOMATCH;\n+      @AutoCodec\n+      public record Diff(Label what, String got, String want) {}",
        "comment_created_at": "2025-05-09T14:16:54+00:00",
        "comment_author": "katre",
        "comment_body": "I'm very worried about mixing up the want and got parameters. Any way this can be a builder style, so users can call `Diff.of(what).want(want).got(got).build()`? It's more verbose but less errorprone.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2081793130",
    "pr_number": 26035,
    "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/platform/ConstraintValueInfo.java",
    "created_at": "2025-05-09T14:20:59+00:00",
    "commented_code": "* method.\n    */\n   public ConfigMatchingProvider configMatchingProvider(PlatformInfo platformInfo) {\n+    ConstraintValueInfo platformValue = platformInfo.constraints().get(this.constraint());\n     return ConfigMatchingProvider.create(\n         label,\n         ImmutableMultimap.of(),\n         ImmutableMap.of(),\n         ImmutableSet.of(),\n-        ConfigMatchingProvider.MatchResult.create(\n-            platformInfo.constraints().hasConstraintValue(this)));\n+        equals(platformValue)",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2081793130",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 26035,
        "pr_file": "src/main/java/com/google/devtools/build/lib/analysis/platform/ConstraintValueInfo.java",
        "discussion_id": "2081793130",
        "commented_code": "@@ -73,13 +74,19 @@ public Label label() {\n    * method.\n    */\n   public ConfigMatchingProvider configMatchingProvider(PlatformInfo platformInfo) {\n+    ConstraintValueInfo platformValue = platformInfo.constraints().get(this.constraint());\n     return ConfigMatchingProvider.create(\n         label,\n         ImmutableMultimap.of(),\n         ImmutableMap.of(),\n         ImmutableSet.of(),\n-        ConfigMatchingProvider.MatchResult.create(\n-            platformInfo.constraints().hasConstraintValue(this)));\n+        equals(platformValue)",
        "comment_created_at": "2025-05-09T14:20:59+00:00",
        "comment_author": "katre",
        "comment_body": "Change to `this.equals(platformValue)`. because I was very confused trying to figure out what was happening here.\r\n\r\nIt might also be nice to combine the entire thing into a new `computeMatchResult` that does the `equals` check and creates the `MATCH` or `NoMatch` instance.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1717482909",
    "pr_number": 21609,
    "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/TestSummaryPrinter.java",
    "created_at": "2024-08-14T19:58:39+00:00",
    "commented_code": "if (summary.getFailedTestCasesStatus() != FailedTestCasesStatus.FULL) {\n             terminalPrinter.print(\n+                    Mode.WARNING\n+                            + \"    (some shards did not report details, list of failed test\"\n+                            + \" cases incomplete)\n\"\n+                            + Mode.DEFAULT);\n+          }\n+        }\n+      }\n+    } else if (showAllTestCasesDetailed) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1717482909",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 21609,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/TestSummaryPrinter.java",
        "discussion_id": "1717482909",
        "commented_code": "@@ -184,12 +189,42 @@ public static void print(\n \n           if (summary.getFailedTestCasesStatus() != FailedTestCasesStatus.FULL) {\n             terminalPrinter.print(\n+                    Mode.WARNING\n+                            + \"    (some shards did not report details, list of failed test\"\n+                            + \" cases incomplete)\\n\"\n+                            + Mode.DEFAULT);\n+          }\n+        }\n+      }\n+    } else if (showAllTestCasesDetailed) {",
        "comment_created_at": "2024-08-14T19:58:39+00:00",
        "comment_author": "genrym",
        "comment_body": "this method became pretty big, maybe split each if case to separate private method",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "936810591",
    "pr_number": 14470,
    "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java",
    "created_at": "2022-08-03T15:33:09+00:00",
    "commented_code": "@AllowConcurrentEvents\n   public void actionResultReceived(ActionResultReceivedEvent event) {\n     spawnStats.countActionResult(event.getActionResult());\n-  }\n+    Optional<Duration> cpuUserTimeForActionsDuration = event.getActionResult().cumulativeCommandExecutionUserTime();",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "936810591",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 14470,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/BuildSummaryStatsModule.java",
        "discussion_id": "936810591",
        "commented_code": "@@ -109,7 +117,20 @@ public void executionPhaseFinish(@SuppressWarnings(\"unused\") ExecutionFinishedEv\n   @AllowConcurrentEvents\n   public void actionResultReceived(ActionResultReceivedEvent event) {\n     spawnStats.countActionResult(event.getActionResult());\n-  }\n+    Optional<Duration> cpuUserTimeForActionsDuration = event.getActionResult().cumulativeCommandExecutionUserTime();",
        "comment_created_at": "2022-08-03T15:33:09+00:00",
        "comment_author": "wilwell",
        "comment_body": "Code is duplicationg, could you please create a function for this. Something like:\r\n```addCPUTime(Duration sumDuration, Duration termDuration)```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1925284428",
    "pr_number": 24949,
    "pr_file": "src/main/java/com/google/devtools/build/lib/query2/aquery/ActionGraphTextOutputFormatterCallback.java",
    "created_at": "2025-01-22T13:01:51+00:00",
    "commented_code": "}\n \n     stringBuilder.append('\n');\n+  }\n \n-    printStream.write(stringBuilder.toString().getBytes(UTF_8));\n+  private void writeCommand(ActionAnalysisMetadata action, StringBuilder stringBuilder)\n+      throws IOException, CommandLineExpansionException, InterruptedException, EvalException {\n+    if (!(action instanceof CommandAction)) {\n+      return;\n+    }\n+\n+    boolean first = true;\n+    for (String arg :\n+        ((CommandAction) action)\n+            .getArguments().stream()\n+                .map(a -> internalToEscapedUnicode(a))\n+                .collect(toImmutableList())) {\n+      if (!first) {\n+        stringBuilder.append(' ');\n+      }\n+      ScriptUtil.emitCommandElement(stringBuilder, arg, first);",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1925284428",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24949,
        "pr_file": "src/main/java/com/google/devtools/build/lib/query2/aquery/ActionGraphTextOutputFormatterCallback.java",
        "discussion_id": "1925284428",
        "commented_code": "@@ -338,8 +361,27 @@ private void writeAction(ActionAnalysisMetadata action, PrintStream printStream)\n     }\n \n     stringBuilder.append('\\n');\n+  }\n \n-    printStream.write(stringBuilder.toString().getBytes(UTF_8));\n+  private void writeCommand(ActionAnalysisMetadata action, StringBuilder stringBuilder)\n+      throws IOException, CommandLineExpansionException, InterruptedException, EvalException {\n+    if (!(action instanceof CommandAction)) {\n+      return;\n+    }\n+\n+    boolean first = true;\n+    for (String arg :\n+        ((CommandAction) action)\n+            .getArguments().stream()\n+                .map(a -> internalToEscapedUnicode(a))\n+                .collect(toImmutableList())) {\n+      if (!first) {\n+        stringBuilder.append(' ');\n+      }\n+      ScriptUtil.emitCommandElement(stringBuilder, arg, first);",
        "comment_created_at": "2025-01-22T13:01:51+00:00",
        "comment_author": "joeleba",
        "comment_body": "nit: add inline comments for the method call. E.g. \r\n```\r\n ScriptUtil.emitCommandElement(/* message= */ stringBuilder, /* commandElement= */ arg, /* isBinary= */ first);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1926149842",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24949,
        "pr_file": "src/main/java/com/google/devtools/build/lib/query2/aquery/ActionGraphTextOutputFormatterCallback.java",
        "discussion_id": "1925284428",
        "commented_code": "@@ -338,8 +361,27 @@ private void writeAction(ActionAnalysisMetadata action, PrintStream printStream)\n     }\n \n     stringBuilder.append('\\n');\n+  }\n \n-    printStream.write(stringBuilder.toString().getBytes(UTF_8));\n+  private void writeCommand(ActionAnalysisMetadata action, StringBuilder stringBuilder)\n+      throws IOException, CommandLineExpansionException, InterruptedException, EvalException {\n+    if (!(action instanceof CommandAction)) {\n+      return;\n+    }\n+\n+    boolean first = true;\n+    for (String arg :\n+        ((CommandAction) action)\n+            .getArguments().stream()\n+                .map(a -> internalToEscapedUnicode(a))\n+                .collect(toImmutableList())) {\n+      if (!first) {\n+        stringBuilder.append(' ');\n+      }\n+      ScriptUtil.emitCommandElement(stringBuilder, arg, first);",
        "comment_created_at": "2025-01-23T00:12:14+00:00",
        "comment_author": "pcc",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1926034194",
    "pr_number": 24944,
    "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/SkyframeUtil.java",
    "created_at": "2025-01-22T21:58:17+00:00",
    "commented_code": "+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.devtools.build.lib.skyframe;\n+\n+import com.google.common.base.Utf8;\n+import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n+import com.google.devtools.build.lib.packages.semantics.BuildLanguageOptions.Utf8EnforcementMode;\n+import java.util.Optional;\n+import net.starlark.java.syntax.Location;\n+import net.starlark.java.syntax.ParserInput;\n+\n+/** Helper functions for Skyframe. */\n+public final class SkyframeUtil {\n+\n+  /**\n+   * Produces a {@link ParserInput} from the raw bytes of a file while optionally enforcing that the\n+   * contents are valid UTF-8.\n+   *\n+   * <p><b>Warnings and errors are reported to the {@link EventHandler}.</b>\n+   *\n+   * @return an optional with a {@link ParserInput} if the bytes are valid UTF-8 or the enforcement\n+   *     mode is not {@link Utf8EnforcementMode#ERROR}, or an empty {@link Optional} otherwise.\n+   */\n+  // This method is the only one that is supposed to use the deprecated ParserInput.fromLatin1\n+  // method.\n+  @SuppressWarnings(\"deprecation\")\n+  public static Optional<ParserInput> createParserInput(\n+      byte[] bytes, String file, Utf8EnforcementMode utf8EnforcementMode, EventHandler reporter) {\n+    switch (utf8EnforcementMode) {\n+      case OFF -> {}\n+      case WARNING -> {\n+        if (!Utf8.isWellFormed(bytes)) {\n+          reporter.handle(\n+              Event.warn(\n+                  Location.fromFile(file),\n+                  \"not a valid UTF-8 encoded file; this can lead to inconsistent behavior and\"",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1926034194",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24944,
        "pr_file": "src/main/java/com/google/devtools/build/lib/skyframe/SkyframeUtil.java",
        "discussion_id": "1926034194",
        "commented_code": "@@ -0,0 +1,67 @@\n+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+package com.google.devtools.build.lib.skyframe;\n+\n+import com.google.common.base.Utf8;\n+import com.google.devtools.build.lib.events.Event;\n+import com.google.devtools.build.lib.events.EventHandler;\n+import com.google.devtools.build.lib.packages.semantics.BuildLanguageOptions.Utf8EnforcementMode;\n+import java.util.Optional;\n+import net.starlark.java.syntax.Location;\n+import net.starlark.java.syntax.ParserInput;\n+\n+/** Helper functions for Skyframe. */\n+public final class SkyframeUtil {\n+\n+  /**\n+   * Produces a {@link ParserInput} from the raw bytes of a file while optionally enforcing that the\n+   * contents are valid UTF-8.\n+   *\n+   * <p><b>Warnings and errors are reported to the {@link EventHandler}.</b>\n+   *\n+   * @return an optional with a {@link ParserInput} if the bytes are valid UTF-8 or the enforcement\n+   *     mode is not {@link Utf8EnforcementMode#ERROR}, or an empty {@link Optional} otherwise.\n+   */\n+  // This method is the only one that is supposed to use the deprecated ParserInput.fromLatin1\n+  // method.\n+  @SuppressWarnings(\"deprecation\")\n+  public static Optional<ParserInput> createParserInput(\n+      byte[] bytes, String file, Utf8EnforcementMode utf8EnforcementMode, EventHandler reporter) {\n+    switch (utf8EnforcementMode) {\n+      case OFF -> {}\n+      case WARNING -> {\n+        if (!Utf8.isWellFormed(bytes)) {\n+          reporter.handle(\n+              Event.warn(\n+                  Location.fromFile(file),\n+                  \"not a valid UTF-8 encoded file; this can lead to inconsistent behavior and\"",
        "comment_created_at": "2025-01-22T21:58:17+00:00",
        "comment_author": "tetromino",
        "comment_body": "Nit: put the error message in a constant?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1819097848",
    "pr_number": 24010,
    "pr_file": "src/main/java/com/google/devtools/build/lib/actions/ParameterFile.java",
    "created_at": "2024-10-28T13:52:11+00:00",
    "commented_code": "public static final FileType PARAMETER_FILE = FileType.of(\".params\");\n \n-  /**\n-   * Creates a parameter file with the given parameters.\n-   */\n-  private ParameterFile() {\n-  }\n-  /**\n-   * Derives an path from a given path by appending <code>\".params\"</code>.\n-   */\n+  /** Creates a parameter file with the given parameters. */\n+  private ParameterFile() {}\n+\n+  /** Derives an path from a given path by appending <code>\".params\"</code>. */\n   public static PathFragment derivePath(PathFragment original) {\n     return derivePath(original, \"2\");\n   }\n \n-  /**\n-   * Derives an path from a given path by appending <code>\".params\"</code>.\n-   */\n+  /** Derives an path from a given path by appending <code>\".params\"</code>. */\n   public static PathFragment derivePath(PathFragment original, String flavor) {\n     return original.replaceName(original.getBaseName() + \"-\" + flavor + \".params\");\n   }\n \n   /** Writes an argument list to a parameter file. */\n   public static void writeParameterFile(\n-      OutputStream out, Iterable<String> arguments, ParameterFileType type, Charset charset)\n-      throws IOException {\n+      OutputStream out, Iterable<String> arguments, ParameterFileType type) throws IOException {\n     OutputStream bufferedOut = new BufferedOutputStream(out);\n     switch (type) {\n-      case SHELL_QUOTED -> writeContent(bufferedOut, ShellEscaper.escapeAll(arguments), charset);\n-      case GCC_QUOTED ->\n-          writeContent(bufferedOut, GccParamFileEscaper.escapeAll(arguments), charset);\n-      case UNQUOTED -> writeContent(bufferedOut, arguments, charset);\n-      case WINDOWS ->\n-          writeContent(bufferedOut, WindowsParamFileEscaper.escapeAll(arguments), charset);\n-    }\n-  }\n-\n-  private static void writeContent(\n-      OutputStream outputStream, Iterable<String> arguments, Charset charset) throws IOException {\n-    if (charset.equals(ISO_8859_1)) {\n-      writeContentLatin1(outputStream, arguments);\n-    } else if (charset.equals(UTF_8)) {\n-      writeContentUtf8(outputStream, arguments);\n-    } else {\n-      // Generic charset support\n-      OutputStreamWriter out = new OutputStreamWriter(outputStream, charset);\n-      for (String line : arguments) {\n-        out.write(line);\n-        out.write('\n');\n-      }\n-      out.flush();\n+      case SHELL_QUOTED -> writeContent(bufferedOut, ShellEscaper.escapeAll(arguments));\n+      case GCC_QUOTED -> writeContent(bufferedOut, GccParamFileEscaper.escapeAll(arguments));\n+      case UNQUOTED -> writeContent(bufferedOut, arguments);\n+      case WINDOWS -> writeContent(bufferedOut, WindowsParamFileEscaper.escapeAll(arguments));\n     }\n   }\n \n-  /**\n-   * Fast LATIN-1 path that avoids GC overhead. This takes advantage of the fact that strings are\n-   * encoded as either LATIN-1 or UTF-16 under JDK9+. When LATIN-1 we can simply copy the byte\n-   * buffer, when UTF-16 we can fail loudly.\n-   */\n-  private static void writeContentLatin1(OutputStream outputStream, Iterable<String> arguments)\n+  private static void writeContent(OutputStream out, Iterable<String> arguments)\n       throws IOException {\n     StringUnsafe stringUnsafe = StringUnsafe.getInstance();\n     for (String line : arguments) {\n-      if (stringUnsafe.getCoder(line) == StringUnsafe.LATIN1) {\n-        byte[] bytes = stringUnsafe.getByteArray(line);\n-        outputStream.write(bytes);\n-      } else {\n-        // Error case, encode with '?' characters\n-        ByteBuffer encodedBytes = ISO_8859_1.encode(CharBuffer.wrap(line));\n-        outputStream.write(\n-            encodedBytes.array(),\n-            encodedBytes.arrayOffset(),\n-            encodedBytes.arrayOffset() + encodedBytes.limit());\n-      }\n-      outputStream.write('\n');\n-    }\n-    outputStream.flush();\n-  }\n-\n-  /**\n-   * Fast UTF-8 path that tries to coder GC overhead. This takes advantage of the fact that strings\n-   * are encoded as either LATIN-1 or UTF-16 under JDK9+. When LATIN-1 we can check if the buffer is\n-   * ASCII and copy that directly (since this is both valid LATIN-1 and UTF-8), in all other cases\n-   * we must re-encode.\n-   */\n-  private static void writeContentUtf8(OutputStream outputStream, Iterable<String> arguments)\n-      throws IOException {\n-    CharsetEncoder encoder = UTF_8.newEncoder();\n-    StringUnsafe stringUnsafe = StringUnsafe.getInstance();\n-    for (String line : arguments) {\n-      byte[] bytes = stringUnsafe.getByteArray(line);\n-      if (stringUnsafe.getCoder(line) == StringUnsafe.LATIN1 && isAscii(bytes)) {\n-        outputStream.write(bytes);\n-      } else if (!StringUtil.reencodeInternalToExternal(line).equals(line)) {\n-        // We successfully decoded line from utf8 - meaning it was already encoded as utf8.\n-        // We do not want to double-encode.\n-        outputStream.write(bytes);\n-      } else {\n-        ByteBuffer encodedBytes = encoder.encode(CharBuffer.wrap(line));\n-        outputStream.write(\n-            encodedBytes.array(),\n-            encodedBytes.arrayOffset(),\n-            encodedBytes.arrayOffset() + encodedBytes.limit());\n-      }\n-      outputStream.write('\n');\n-    }\n-    outputStream.flush();\n-  }\n-\n-  private static boolean isAscii(byte[] latin1Bytes) {\n-    boolean hiBitSet = false;\n-    int n = latin1Bytes.length;\n-    for (int i = 0; i < n; ++i) {\n-      hiBitSet |= ((latin1Bytes[i] & 0x80) != 0);\n+      Preconditions.checkArgument(\n+          stringUnsafe.getCoder(line) == StringUnsafe.LATIN1,\n+          \"Expected internal string, got: %s (%s)\",",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1819097848",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24010,
        "pr_file": "src/main/java/com/google/devtools/build/lib/actions/ParameterFile.java",
        "discussion_id": "1819097848",
        "commented_code": "@@ -81,119 +72,44 @@ public enum ParameterFileType {\n \n   public static final FileType PARAMETER_FILE = FileType.of(\".params\");\n \n-  /**\n-   * Creates a parameter file with the given parameters.\n-   */\n-  private ParameterFile() {\n-  }\n-  /**\n-   * Derives an path from a given path by appending <code>\".params\"</code>.\n-   */\n+  /** Creates a parameter file with the given parameters. */\n+  private ParameterFile() {}\n+\n+  /** Derives an path from a given path by appending <code>\".params\"</code>. */\n   public static PathFragment derivePath(PathFragment original) {\n     return derivePath(original, \"2\");\n   }\n \n-  /**\n-   * Derives an path from a given path by appending <code>\".params\"</code>.\n-   */\n+  /** Derives an path from a given path by appending <code>\".params\"</code>. */\n   public static PathFragment derivePath(PathFragment original, String flavor) {\n     return original.replaceName(original.getBaseName() + \"-\" + flavor + \".params\");\n   }\n \n   /** Writes an argument list to a parameter file. */\n   public static void writeParameterFile(\n-      OutputStream out, Iterable<String> arguments, ParameterFileType type, Charset charset)\n-      throws IOException {\n+      OutputStream out, Iterable<String> arguments, ParameterFileType type) throws IOException {\n     OutputStream bufferedOut = new BufferedOutputStream(out);\n     switch (type) {\n-      case SHELL_QUOTED -> writeContent(bufferedOut, ShellEscaper.escapeAll(arguments), charset);\n-      case GCC_QUOTED ->\n-          writeContent(bufferedOut, GccParamFileEscaper.escapeAll(arguments), charset);\n-      case UNQUOTED -> writeContent(bufferedOut, arguments, charset);\n-      case WINDOWS ->\n-          writeContent(bufferedOut, WindowsParamFileEscaper.escapeAll(arguments), charset);\n-    }\n-  }\n-\n-  private static void writeContent(\n-      OutputStream outputStream, Iterable<String> arguments, Charset charset) throws IOException {\n-    if (charset.equals(ISO_8859_1)) {\n-      writeContentLatin1(outputStream, arguments);\n-    } else if (charset.equals(UTF_8)) {\n-      writeContentUtf8(outputStream, arguments);\n-    } else {\n-      // Generic charset support\n-      OutputStreamWriter out = new OutputStreamWriter(outputStream, charset);\n-      for (String line : arguments) {\n-        out.write(line);\n-        out.write('\\n');\n-      }\n-      out.flush();\n+      case SHELL_QUOTED -> writeContent(bufferedOut, ShellEscaper.escapeAll(arguments));\n+      case GCC_QUOTED -> writeContent(bufferedOut, GccParamFileEscaper.escapeAll(arguments));\n+      case UNQUOTED -> writeContent(bufferedOut, arguments);\n+      case WINDOWS -> writeContent(bufferedOut, WindowsParamFileEscaper.escapeAll(arguments));\n     }\n   }\n \n-  /**\n-   * Fast LATIN-1 path that avoids GC overhead. This takes advantage of the fact that strings are\n-   * encoded as either LATIN-1 or UTF-16 under JDK9+. When LATIN-1 we can simply copy the byte\n-   * buffer, when UTF-16 we can fail loudly.\n-   */\n-  private static void writeContentLatin1(OutputStream outputStream, Iterable<String> arguments)\n+  private static void writeContent(OutputStream out, Iterable<String> arguments)\n       throws IOException {\n     StringUnsafe stringUnsafe = StringUnsafe.getInstance();\n     for (String line : arguments) {\n-      if (stringUnsafe.getCoder(line) == StringUnsafe.LATIN1) {\n-        byte[] bytes = stringUnsafe.getByteArray(line);\n-        outputStream.write(bytes);\n-      } else {\n-        // Error case, encode with '?' characters\n-        ByteBuffer encodedBytes = ISO_8859_1.encode(CharBuffer.wrap(line));\n-        outputStream.write(\n-            encodedBytes.array(),\n-            encodedBytes.arrayOffset(),\n-            encodedBytes.arrayOffset() + encodedBytes.limit());\n-      }\n-      outputStream.write('\\n');\n-    }\n-    outputStream.flush();\n-  }\n-\n-  /**\n-   * Fast UTF-8 path that tries to coder GC overhead. This takes advantage of the fact that strings\n-   * are encoded as either LATIN-1 or UTF-16 under JDK9+. When LATIN-1 we can check if the buffer is\n-   * ASCII and copy that directly (since this is both valid LATIN-1 and UTF-8), in all other cases\n-   * we must re-encode.\n-   */\n-  private static void writeContentUtf8(OutputStream outputStream, Iterable<String> arguments)\n-      throws IOException {\n-    CharsetEncoder encoder = UTF_8.newEncoder();\n-    StringUnsafe stringUnsafe = StringUnsafe.getInstance();\n-    for (String line : arguments) {\n-      byte[] bytes = stringUnsafe.getByteArray(line);\n-      if (stringUnsafe.getCoder(line) == StringUnsafe.LATIN1 && isAscii(bytes)) {\n-        outputStream.write(bytes);\n-      } else if (!StringUtil.reencodeInternalToExternal(line).equals(line)) {\n-        // We successfully decoded line from utf8 - meaning it was already encoded as utf8.\n-        // We do not want to double-encode.\n-        outputStream.write(bytes);\n-      } else {\n-        ByteBuffer encodedBytes = encoder.encode(CharBuffer.wrap(line));\n-        outputStream.write(\n-            encodedBytes.array(),\n-            encodedBytes.arrayOffset(),\n-            encodedBytes.arrayOffset() + encodedBytes.limit());\n-      }\n-      outputStream.write('\\n');\n-    }\n-    outputStream.flush();\n-  }\n-\n-  private static boolean isAscii(byte[] latin1Bytes) {\n-    boolean hiBitSet = false;\n-    int n = latin1Bytes.length;\n-    for (int i = 0; i < n; ++i) {\n-      hiBitSet |= ((latin1Bytes[i] & 0x80) != 0);\n+      Preconditions.checkArgument(\n+          stringUnsafe.getCoder(line) == StringUnsafe.LATIN1,\n+          \"Expected internal string, got: %s (%s)\",",
        "comment_created_at": "2024-10-28T13:52:11+00:00",
        "comment_author": "tjgq",
        "comment_body": "Let's maybe move this assertion (which also appears in other places) into a utility method in `StringUnsafe`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1781029795",
    "pr_number": 23766,
    "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/TestSummary.java",
    "created_at": "2024-09-30T12:35:52+00:00",
    "commented_code": "// Don't count test cases that were not run.\n         return 0;\n       }\n-      if (testCase.getStatus() != TestCase.Status.PASSED) {\n-        this.summary.failedTestCases.add(testCase);\n-      }\n-\n-      if (testCase.getStatus() == Status.PASSED) {\n-        this.summary.passedTestCases.add(testCase);\n+      switch (testCase.getStatus()) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1781029795",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23766,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/TestSummary.java",
        "discussion_id": "1781029795",
        "commented_code": "@@ -216,12 +216,15 @@ private int traverseTestCases(TestCase testCase) {\n         // Don't count test cases that were not run.\n         return 0;\n       }\n-      if (testCase.getStatus() != TestCase.Status.PASSED) {\n-        this.summary.failedTestCases.add(testCase);\n-      }\n-\n-      if (testCase.getStatus() == Status.PASSED) {\n-        this.summary.passedTestCases.add(testCase);\n+      switch (testCase.getStatus()) {",
        "comment_created_at": "2024-09-30T12:35:52+00:00",
        "comment_author": "fmeum",
        "comment_body": "This can use a switch expression for an exhaustiveness test.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1781030179",
    "pr_number": 23766,
    "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/TestSummaryPrinter.java",
    "created_at": "2024-09-30T12:36:11+00:00",
    "commented_code": "timeSummary = \"\";\n     }\n \n-    Mode mode = (testCase.getStatus() == Status.PASSED) ? Mode.INFO : Mode.ERROR;\n+    Mode mode;\n+    switch (testCase.getStatus()) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1781030179",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 23766,
        "pr_file": "src/main/java/com/google/devtools/build/lib/runtime/TestSummaryPrinter.java",
        "discussion_id": "1781030179",
        "commented_code": "@@ -227,7 +229,17 @@ static void printTestCase(AnsiTerminalPrinter terminalPrinter, TestCase testCase\n       timeSummary = \"\";\n     }\n \n-    Mode mode = (testCase.getStatus() == Status.PASSED) ? Mode.INFO : Mode.ERROR;\n+    Mode mode;\n+    switch (testCase.getStatus()) {",
        "comment_created_at": "2024-09-30T12:36:11+00:00",
        "comment_author": "fmeum",
        "comment_body": "Same as above, use a switch expression.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1669376734",
    "pr_number": 19702,
    "pr_file": "src/main/java/com/google/devtools/build/lib/packages/SelectorValue.java",
    "created_at": "2024-07-08T21:54:49+00:00",
    "commented_code": "public void repr(Printer printer) {\n     printer.append(\"select(\").repr(dictionary).append(\")\");\n   }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1669376734",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 19702,
        "pr_file": "src/main/java/com/google/devtools/build/lib/packages/SelectorValue.java",
        "discussion_id": "1669376734",
        "commented_code": "@@ -90,4 +91,23 @@ public SelectorList binaryOp(TokenKind op, Object that, boolean thisLeft) throws\n   public void repr(Printer printer) {\n     printer.append(\"select(\").repr(dictionary).append(\")\");\n   }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {",
        "comment_created_at": "2024-07-08T21:54:49+00:00",
        "comment_author": "tetromino",
        "comment_body": "You can simplify this to `if (!(o instanceof SelectorValue))`",
        "pr_file_module": null
      }
    ]
  }
]