[
  {
    "discussion_id": "2279148049",
    "pr_number": 22553,
    "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
    "created_at": "2025-08-15T14:58:41+00:00",
    "commented_code": "(private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "2279148049",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 22553,
        "pr_file": "src/main/starlark/builtins_bzl/common/cc/compile/compile.bzl",
        "discussion_id": "2279148049",
        "commented_code": "@@ -436,6 +493,602 @@ def _should_provide_header_modules(\n         (private_headers or public_headers)\n     )\n \n+def _create_scan_deps_action(\n+        *,\n+        action_construction_context,\n+        additional_compilation_inputs,\n+        additional_include_scanning_roots,\n+        cc_compilation_context,\n+        cc_toolchain,\n+        configuration,\n+        conlyopts,\n+        copts,\n+        copts_filter,\n+        cpp_configuration,  # Note: this is from the cc_toolchain, and is NOT the same as ctx.fragments.cpp\n+        cxxopts,\n+        feature_configuration,\n+        label,\n+        common_toolchain_variables,\n+        language,\n+        native_cc_semantics,\n+        source_artifact,\n+        source_label,\n+        use_pic,\n+        ddi_file,\n+        ddi_output_name):\n+    dotd_file = _get_compile_output_file(\n+        action_construction_context,\n+        label,\n+        output_name = cc_internal.get_artifact_name_for_category(\n+            cc_toolchain = cc_toolchain,\n+            category = artifact_category.INCLUDED_FILE_LIST,\n+            output_name = ddi_output_name,\n+        ),\n+    ) if (\n+        _dotd_files_enabled(native_cc_semantics, configuration, feature_configuration) and\n+        _use_dotd_file(feature_configuration, source_artifact)\n+    ) else None\n+    specific_compile_build_variables = get_specific_compile_build_variables(\n+        feature_configuration,\n+        use_pic = use_pic,\n+        source_file = source_artifact,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        cpp_module_map = cc_compilation_context.module_map(),\n+        direct_module_maps = cc_compilation_context.direct_module_maps,\n+        user_compile_flags = _get_copts(\n+            language = language,\n+            cpp_configuration = cpp_configuration,\n+            source_file = source_artifact,\n+            conlyopts = conlyopts,\n+            copts = copts,\n+            cxxopts = cxxopts,\n+            label = source_label,\n+        ),\n+    )\n+    compile_variables = cc_internal.combine_cc_toolchain_variables(\n+        common_toolchain_variables,\n+        specific_compile_build_variables,\n+    )\n+    cpp_compile_action_builder = cc_internal.create_cpp_compile_action_builder(\n+        action_construction_context = action_construction_context,\n+        cc_compilation_context = cc_compilation_context,\n+        cc_toolchain = cc_toolchain,\n+        configuration = configuration,\n+        copts_filter = copts_filter,\n+        feature_configuration = feature_configuration,\n+        semantics = native_cc_semantics,\n+        source_artifact = source_artifact,\n+        additional_compilation_inputs = additional_compilation_inputs,\n+        additional_include_scanning_roots = additional_include_scanning_roots,\n+        output_file = ddi_file,\n+        dotd_file = dotd_file,\n+        action_name = ACTION_NAMES.cpp_module_deps_scanning,\n+    )\n+    cc_internal.create_cpp_compile_action(\n+        action_construction_context = action_construction_context,\n+        compile_action_builder = cpp_compile_action_builder,\n+        compile_build_variables = compile_variables,\n+        cpp_semantics = native_cc_semantics,\n+        configuration = configuration,\n+        feature_configuration = feature_configuration,\n+    )\n+\n+def _create_aggregate_ddi_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_files,\n+        direct_module_files,\n+        transitive_modules_info_files,\n+        modules_info_file):\n+    aggregate_ddi_tool = cc_toolchain._aggregate_ddi\n+    if aggregate_ddi_tool == None:\n+        fail(\"the 'aggregate_ddi' tool is not defined in the C++ toolchain\")\n+\n+    # ctx = cc_internal.actions2ctx_cheat(actions)\n+    args = actions.args()\n+    args.add_all(ddi_files, before_each = \"-d\")\n+    args.add_all(direct_module_files, before_each = \"-f\")\n+    args.add_all(transitive_modules_info_files, before_each = \"-m\")\n+    args.add(\"-o\", modules_info_file)\n+    actions.run(\n+        outputs = [modules_info_file],\n+        # inputs = depset(ddi_files + direct_module_files, transitive = [transitive_modules_info_files]),\n+        inputs = depset(ddi_files, transitive = [transitive_modules_info_files]),\n+        executable = aggregate_ddi_tool,\n+        tools = [aggregate_ddi_tool],\n+        arguments = [args],\n+        mnemonic = \"CppAggregateDdi\",\n+        progress_message = \"Generating C++20 modules info %{output}\",\n+        toolchain = \"@bazel_tools//tools/cpp:toolchain_type\",\n+    )\n+\n+def _create_gen_modmap_action(\n+        *,\n+        actions,\n+        cc_toolchain,\n+        ddi_file,\n+        modules_info_file,\n+        modmap_file,\n+        modmap_input_file):\n+    gen_modmap_tool = cc_toolchain.generate_modmap\n+    if gen_modmap_tool == None:\n+        fail(\"the 'generate_modmap' tool is not defined in the C++ toolchain\")\n+    actions.run(\n+        outputs = [modmap_file, modmap_input_file],\n+        inputs = [ddi_file, modules_info_file],\n+        executable = gen_modmap_tool,\n+        tools = [gen_modmap_tool],\n+        arguments = [cc_toolchain.compiler, ddi_file.path, modules_info_file.path, modmap_file.path],",
        "comment_created_at": "2025-08-15T14:58:41+00:00",
        "comment_author": "fmeum",
        "comment_body": "Please use `args` for this as well - it will allow this action to opt into [path mapping](https://github.com/bazelbuild/bazel/discussions/22658) later as it avoids using `.path`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "913287813",
    "pr_number": 15799,
    "pr_file": "src/main/java/com/google/devtools/build/lib/buildeventstream/proto/build_event_stream.proto",
    "created_at": "2022-07-04T22:52:52+00:00",
    "commented_code": "int64 wall_time_in_ms = 2;\n     // The elapsed wall time in milliseconds during the analysis phase.\n     int64 analysis_phase_time_in_ms = 3;\n+    // The critical path time in milliseconds during this build.\n+    int64 critical_path_time_in_ms = 4;",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "913287813",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 15799,
        "pr_file": "src/main/java/com/google/devtools/build/lib/buildeventstream/proto/build_event_stream.proto",
        "discussion_id": "913287813",
        "commented_code": "@@ -946,6 +946,8 @@ message BuildMetrics {\n     int64 wall_time_in_ms = 2;\n     // The elapsed wall time in milliseconds during the analysis phase.\n     int64 analysis_phase_time_in_ms = 3;\n+    // The critical path time in milliseconds during this build.\n+    int64 critical_path_time_in_ms = 4;",
        "comment_created_at": "2022-07-04T22:52:52+00:00",
        "comment_author": "Yannic",
        "comment_body": "Please use `google.protobuf.Duration` instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "914960659",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 15799,
        "pr_file": "src/main/java/com/google/devtools/build/lib/buildeventstream/proto/build_event_stream.proto",
        "discussion_id": "913287813",
        "commented_code": "@@ -946,6 +946,8 @@ message BuildMetrics {\n     int64 wall_time_in_ms = 2;\n     // The elapsed wall time in milliseconds during the analysis phase.\n     int64 analysis_phase_time_in_ms = 3;\n+    // The critical path time in milliseconds during this build.\n+    int64 critical_path_time_in_ms = 4;",
        "comment_created_at": "2022-07-06T15:11:03+00:00",
        "comment_author": "crydell-ericsson",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1819073831",
    "pr_number": 24010,
    "pr_file": "src/main/cpp/option_processor_windows.cc",
    "created_at": "2024-10-28T13:37:41+00:00",
    "commented_code": "+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"src/main/cpp/option_processor-internal.h\"\n+\n+#include <algorithm>\n+#include <string>\n+\n+#include \"src/main/cpp/util/strings.h\"\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+namespace blaze::internal {\n+\n+#if defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  int pos = env_str->find_first_of('=');\n+  if (pos == string::npos) return;\n+  std::string name = env_str->substr(0, pos);\n+  if (name == \"PATH\") {\n+    env_str->assign(\"PATH=\" + env_str->substr(pos + 1));\n+  } else if (name == \"TMP\") {\n+    // A valid Windows path \"c:/foo\" is also a valid Unix path list of\n+    // [\"c\", \"/foo\"] so must use ConvertPath here. See GitHub issue #1684.\n+    env_str->assign(\"TMP=\" + blaze_util::ConvertPath(env_str->substr(pos + 1)));\n+  }\n+}\n+\n+#else // not defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  static constexpr const char *vars_to_uppercase[] = {\"PATH\", \"SYSTEMROOT\",\n+                                                      \"SYSTEMDRIVE\",\n+                                                      \"TEMP\", \"TEMPDIR\", \"TMP\"};\n+\n+  std::size_t pos = env_str->find_first_of('=');\n+  if (pos == std::string::npos) return;\n+\n+  std::string name = env_str->substr(0, pos);\n+  // We do not care about locale. All variable names are ASCII.\n+  std::transform(name.begin(), name.end(), name.begin(), ::toupper);\n+  if (std::find(std::begin(vars_to_uppercase), std::end(vars_to_uppercase),\n+                name) != std::end(vars_to_uppercase)) {\n+    env_str->assign(name + \"=\" + env_str->substr(pos + 1));\n+  }\n+}\n+\n+#endif  // defined(__CYGWIN__)\n+\n+static bool IsValidEnvName(const char* p) {",
    "repo_full_name": "bazelbuild/bazel",
    "discussion_comments": [
      {
        "comment_id": "1819073831",
        "repo_full_name": "bazelbuild/bazel",
        "pr_number": 24010,
        "pr_file": "src/main/cpp/option_processor_windows.cc",
        "discussion_id": "1819073831",
        "commented_code": "@@ -0,0 +1,94 @@\n+// Copyright 2024 The Bazel Authors. All rights reserved.\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"src/main/cpp/option_processor-internal.h\"\n+\n+#include <algorithm>\n+#include <string>\n+\n+#include \"src/main/cpp/util/strings.h\"\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+namespace blaze::internal {\n+\n+#if defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  int pos = env_str->find_first_of('=');\n+  if (pos == string::npos) return;\n+  std::string name = env_str->substr(0, pos);\n+  if (name == \"PATH\") {\n+    env_str->assign(\"PATH=\" + env_str->substr(pos + 1));\n+  } else if (name == \"TMP\") {\n+    // A valid Windows path \"c:/foo\" is also a valid Unix path list of\n+    // [\"c\", \"/foo\"] so must use ConvertPath here. See GitHub issue #1684.\n+    env_str->assign(\"TMP=\" + blaze_util::ConvertPath(env_str->substr(pos + 1)));\n+  }\n+}\n+\n+#else // not defined(__CYGWIN__)\n+\n+static void PreprocessEnvString(std::string *env_str) {\n+  static constexpr const char *vars_to_uppercase[] = {\"PATH\", \"SYSTEMROOT\",\n+                                                      \"SYSTEMDRIVE\",\n+                                                      \"TEMP\", \"TEMPDIR\", \"TMP\"};\n+\n+  std::size_t pos = env_str->find_first_of('=');\n+  if (pos == std::string::npos) return;\n+\n+  std::string name = env_str->substr(0, pos);\n+  // We do not care about locale. All variable names are ASCII.\n+  std::transform(name.begin(), name.end(), name.begin(), ::toupper);\n+  if (std::find(std::begin(vars_to_uppercase), std::end(vars_to_uppercase),\n+                name) != std::end(vars_to_uppercase)) {\n+    env_str->assign(name + \"=\" + env_str->substr(pos + 1));\n+  }\n+}\n+\n+#endif  // defined(__CYGWIN__)\n+\n+static bool IsValidEnvName(const char* p) {",
        "comment_created_at": "2024-10-28T13:37:41+00:00",
        "comment_author": "tjgq",
        "comment_body": "Modify this to accept a `std::string_view`, then the `c_str()` in the caller becomes unnecessary.",
        "pr_file_module": null
      }
    ]
  }
]