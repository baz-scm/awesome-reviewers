[
  {
    "discussion_id": "2271958375",
    "pr_number": 3955,
    "pr_file": "packages/better-auth/src/plugins/organization/routes/crud-members.ts",
    "created_at": "2025-08-13T03:06:03+00:00",
    "commented_code": "});\n \t\t\t}\n \n+\t\t\tif (updaterIsCreator) {",
    "repo_full_name": "better-auth/better-auth",
    "discussion_comments": [
      {
        "comment_id": "2271958375",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3955,
        "pr_file": "packages/better-auth/src/plugins/organization/routes/crud-members.ts",
        "discussion_id": "2271958375",
        "commented_code": "@@ -471,6 +473,26 @@ export const updateMemberRole = <O extends OrganizationOptions>(option: O) =>\n \t\t\t\t});\n \t\t\t}\n \n+\t\t\tif (updaterIsCreator) {",
        "comment_created_at": "2025-08-13T03:06:03+00:00",
        "comment_author": "Bekacru",
        "comment_body": "we should probably check here if `memberIsUpdatingThemselves` before making listMembers call",
        "pr_file_module": null
      },
      {
        "comment_id": "2273888759",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3955,
        "pr_file": "packages/better-auth/src/plugins/organization/routes/crud-members.ts",
        "discussion_id": "2271958375",
        "commented_code": "@@ -471,6 +473,26 @@ export const updateMemberRole = <O extends OrganizationOptions>(option: O) =>\n \t\t\t\t});\n \t\t\t}\n \n+\t\t\tif (updaterIsCreator) {",
        "comment_created_at": "2025-08-13T15:51:35+00:00",
        "comment_author": "gwoodbridge",
        "comment_body": "Moved check for `memberIsUpdatingThemselves`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234199601",
    "pr_number": 3620,
    "pr_file": "packages/stripe/src/index.ts",
    "created_at": "2025-07-28T00:34:32+00:00",
    "commented_code": "},\n \t\t),\n \t} as const;\n+\n+\tconst usageBasedBillingEndpoints = {\n+\t\ttrackUsage: createAuthEndpoint(\n+\t\t\t\"/usage/track\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tplan: z.string(),\n+\t\t\t\t\tstripeCustomerId: z.string(),",
    "repo_full_name": "better-auth/better-auth",
    "discussion_comments": [
      {
        "comment_id": "2234199601",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3620,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2234199601",
        "commented_code": "@@ -1029,6 +1030,208 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst usageBasedBillingEndpoints = {\n+\t\ttrackUsage: createAuthEndpoint(\n+\t\t\t\"/usage/track\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tplan: z.string(),\n+\t\t\t\t\tstripeCustomerId: z.string(),",
        "comment_created_at": "2025-07-28T00:34:32+00:00",
        "comment_author": "Bekacru",
        "comment_body": "stripeCustomerId shouldn't be expected from the user. It should either be read for the session or they should provide a different reference id",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2211884336",
    "pr_number": 3327,
    "pr_file": "packages/stripe/src/index.ts",
    "created_at": "2025-07-17T00:27:30+00:00",
    "commented_code": "},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\t\t\t\tif (\n+\t\t\t\t\t!displayName ||\n+\t\t\t\t\t!eventName ||\n+\t\t\t\t\t!aggregationFormula ||\n+\t\t\t\t\t!stripeCustomerId\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\t\t\t\tif (!meterId || !updatedDisplayName) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId } = ctx.body;\n+\t\t\t\tif (!meterId) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing Meter ID\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {",
    "repo_full_name": "better-auth/better-auth",
    "discussion_comments": [
      {
        "comment_id": "2211884336",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2211884336",
        "commented_code": "@@ -923,6 +925,365 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\t\t\t\tif (\n+\t\t\t\t\t!displayName ||\n+\t\t\t\t\t!eventName ||\n+\t\t\t\t\t!aggregationFormula ||\n+\t\t\t\t\t!stripeCustomerId\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\t\t\t\tif (!meterId || !updatedDisplayName) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId } = ctx.body;\n+\t\t\t\tif (!meterId) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing Meter ID\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {",
        "comment_created_at": "2025-07-17T00:27:30+00:00",
        "comment_author": "ping-maxwell",
        "comment_body": "I'm not too familiar with Stripe billing APIs, but would this endpoint mean that anyone can query it and get a list of metered billings?\nSorry if it's a dumb question ",
        "pr_file_module": null
      },
      {
        "comment_id": "2211941102",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2211884336",
        "commented_code": "@@ -923,6 +925,365 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\t\t\t\tif (\n+\t\t\t\t\t!displayName ||\n+\t\t\t\t\t!eventName ||\n+\t\t\t\t\t!aggregationFormula ||\n+\t\t\t\t\t!stripeCustomerId\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\t\t\t\tif (!meterId || !updatedDisplayName) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId } = ctx.body;\n+\t\t\t\tif (!meterId) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing Meter ID\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {",
        "comment_created_at": "2025-07-17T01:22:29+00:00",
        "comment_author": "dagmawibabi",
        "comment_body": "No, not anyone can get a list of billing meters. Access to Stripe's billing meters is restricted and requires proper authentication. \r\n\r\n    Only authenticated Stripe account holders with the appropriate permissions can retrieve billing meter information.\r\n    You need a valid API key to make requests to the Stripe API, including retrieving billing meter data.\r\n    The API request to list billing meters would typically be made server-side in a secure environment, not from client-side code accessible to the public.",
        "pr_file_module": null
      },
      {
        "comment_id": "2212050998",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2211884336",
        "commented_code": "@@ -923,6 +925,365 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\t\t\t\tif (\n+\t\t\t\t\t!displayName ||\n+\t\t\t\t\t!eventName ||\n+\t\t\t\t\t!aggregationFormula ||\n+\t\t\t\t\t!stripeCustomerId\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\t\t\t\tif (!meterId || !updatedDisplayName) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId } = ctx.body;\n+\t\t\t\tif (!meterId) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing Meter ID\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {",
        "comment_created_at": "2025-07-17T03:04:48+00:00",
        "comment_author": "ping-maxwell",
        "comment_body": "I can understand the stripe's client.billing.meters requiring the API key to call, but I mean for the `/metered-billing/list` endpoint. Couldn't someone just call that endpoint and then they will get the data or am I missing something?",
        "pr_file_module": null
      },
      {
        "comment_id": "2214427053",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2211884336",
        "commented_code": "@@ -923,6 +925,365 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\t\t\t\tif (\n+\t\t\t\t\t!displayName ||\n+\t\t\t\t\t!eventName ||\n+\t\t\t\t\t!aggregationFormula ||\n+\t\t\t\t\t!stripeCustomerId\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\t\t\t\tif (!meterId || !updatedDisplayName) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing required fields\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\t// Check for required fields\n+\t\t\t\tconst { meterId } = ctx.body;\n+\t\t\t\tif (!meterId) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Missing Meter ID\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {",
        "comment_created_at": "2025-07-17T22:32:56+00:00",
        "comment_author": "dagmawibabi",
        "comment_body": "Okay I got what you meant, thanks, it now checks for session. Let me know if it's something I can improve. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2214505710",
    "pr_number": 3327,
    "pr_file": "packages/stripe/src/index.ts",
    "created_at": "2025-07-17T23:45:28+00:00",
    "commented_code": "},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst session = await ctx.context.session;",
    "repo_full_name": "better-auth/better-auth",
    "discussion_comments": [
      {
        "comment_id": "2214505710",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2214505710",
        "commented_code": "@@ -923,6 +925,328 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst session = await ctx.context.session;",
        "comment_created_at": "2025-07-17T23:45:28+00:00",
        "comment_author": "ping-maxwell",
        "comment_body": "I don't mean to be nit-picky, but just a tip for you \ud83d\udc40\n\nI recommend using the session-middleware (see [here](https://github.com/better-auth/better-auth/blob/8bcc35285613fe9ef59f6bf3c93e30c9f5ec93fb/packages/better-auth/src/plugins/organization/routes/crud-members.ts#L499)) this makes it so that the request must have a session otherwise it's rejected automatically.\n\nAlternatively if you want to write it manually I recommend using `getSessionFromCtx` helper function  to get the session rather than `ctx.context.session`",
        "pr_file_module": null
      },
      {
        "comment_id": "2214518772",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2214505710",
        "commented_code": "@@ -923,6 +925,328 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst session = await ctx.context.session;",
        "comment_created_at": "2025-07-17T23:54:58+00:00",
        "comment_author": "dagmawibabi",
        "comment_body": "I used getSessionFromCtx in the previous commit but for some reason it didn't pass the tests, but will use the session middleware now. \n\n(always nit pick please whenever u review my code, only way I can improve)",
        "pr_file_module": null
      },
      {
        "comment_id": "2214520894",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2214505710",
        "commented_code": "@@ -923,6 +925,328 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst session = await ctx.context.session;",
        "comment_created_at": "2025-07-17T23:56:04+00:00",
        "comment_author": "dagmawibabi",
        "comment_body": "@ping-maxwell check current commit and lmk",
        "pr_file_module": null
      },
      {
        "comment_id": "2214557109",
        "repo_full_name": "better-auth/better-auth",
        "pr_number": 3327,
        "pr_file": "packages/stripe/src/index.ts",
        "discussion_id": "2214505710",
        "commented_code": "@@ -923,6 +925,328 @@ export const stripe = <O extends StripeOptions>(options: O) => {\n \t\t\t},\n \t\t),\n \t} as const;\n+\n+\tconst meteredBillingEndpoints = {\n+\t\tcreateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/create\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tdisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\teventName: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"The name of the meter event to record usage for. Corresponds with the event_name field on meter events.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\taggregationFormula: z.nativeEnum(AggregationFormula, {\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Specifies how events are aggregated. Allowed values are 'count' to count the number of events, 'sum' to sum each event's value and 'last' to take the last event's value in the window.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tstripeCustomerId: z.string({\n+\t\t\t\t\t\tdescription:\n+\t\t\t\t\t\t\t\"Map a meter event to a customer by passing a customer ID in the event's payload.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { displayName, eventName, aggregationFormula, stripeCustomerId } =\n+\t\t\t\t\tctx.body;\n+\n+\t\t\t\t// Check for valid aggregation formula\n+\t\t\t\tif (\n+\t\t\t\t\taggregationFormula !== \"count\" &&\n+\t\t\t\t\taggregationFormula !== \"sum\" &&\n+\t\t\t\t\taggregationFormula !== \"last\"\n+\t\t\t\t) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Invalid default aggregation formula\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Check if user exists\n+\t\t\t\tconst user = await ctx.context.adapter.findOne<User>({\n+\t\t\t\t\tmodel: \"user\",\n+\t\t\t\t\twhere: [\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tfield: \"stripeCustomerId\",\n+\t\t\t\t\t\t\tvalue: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t],\n+\t\t\t\t});\n+\t\t\t\tif (!user) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"User not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Create Meter\n+\t\t\t\tconst createMetereResponse = await client.billing.meters\n+\t\t\t\t\t.create({\n+\t\t\t\t\t\tdisplay_name: displayName,\n+\t\t\t\t\t\tevent_name: eventName,\n+\t\t\t\t\t\tdefault_aggregation: {\n+\t\t\t\t\t\t\tformula: aggregationFormula,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tvalue_settings: {\n+\t\t\t\t\t\t\tevent_payload_key: \"value\",\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tcustomer_mapping: {\n+\t\t\t\t\t\t\ttype: \"by_id\",\n+\t\t\t\t\t\t\tevent_payload_key: stripeCustomerId,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...createMetereResponse,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tupdateMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/update\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t\tupdatedDisplayName: z.string({\n+\t\t\t\t\t\tdescription: \"The meter's new name. Not visible to the customer.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId, updatedDisplayName } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Update Meter\n+\t\t\t\tconst updateMeterSession = await client.billing.meters\n+\t\t\t\t\t.update(meterId, {\n+\t\t\t\t\t\tdisplay_name: updatedDisplayName,\n+\t\t\t\t\t})\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...updateMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tretrieveMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/retrieve\",\n+\t\t\t{\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: z.object({\n+\t\t\t\t\tmeterId: z.string({\n+\t\t\t\t\t\tdescription: \"Unique identifier for the meter.\",\n+\t\t\t\t\t}),\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst { meterId } = ctx.body;\n+\n+\t\t\t\t// Check if meter exists\n+\t\t\t\tconst meter = await client.billing.meters.retrieve(meterId);\n+\t\t\t\tif (!meter) {\n+\t\t\t\t\tthrow new APIError(\"BAD_REQUEST\", {\n+\t\t\t\t\t\tmessage: \"Meter not found\",\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\t// Retrieve Meter\n+\t\t\t\tconst retrieveMeterSession = await client.billing.meters\n+\t\t\t\t\t.retrieve(meterId)\n+\t\t\t\t\t.catch(async (e) => {\n+\t\t\t\t\t\tthrow ctx.error(\"BAD_REQUEST\", {\n+\t\t\t\t\t\t\tmessage: e.message,\n+\t\t\t\t\t\t\tcode: e.code,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t\t\treturn ctx.json({\n+\t\t\t\t\t...retrieveMeterSession,\n+\t\t\t\t});\n+\t\t\t},\n+\t\t),\n+\n+\t\tlistMeteredBilling: createAuthEndpoint(\n+\t\t\t\"/metered-billing/list\",\n+\t\t\t{\n+\t\t\t\tmethod: \"GET\",\n+\t\t\t},\n+\t\t\tasync (ctx) => {\n+\t\t\t\tconst session = await ctx.context.session;",
        "comment_created_at": "2025-07-18T00:12:45+00:00",
        "comment_author": "ping-maxwell",
        "comment_body": "Yeah looks good",
        "pr_file_module": null
      }
    ]
  }
]