[
  {
    "discussion_id": "18854937",
    "pr_number": 4,
    "pr_file": "boto3/resources/collection.py",
    "created_at": "2014-10-14T20:12:18+00:00",
    "commented_code": "+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+import logging\n+\n+from botocore import xform_name\n+\n+from .params import create_request_parameters\n+from .response import ResourceHandler\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class ResourceCollection(object):\n+    \"\"\"\n+    Represents a collection of resources, which can be iterated through,\n+    optionally with filtering. Collections automatically handle pagination\n+    for you.\n+\n+    See :ref:`guide_collections` for a high-level overview of collections,\n+    including when remote service requests are performed.\n+\n+    :type definition: dict\n+    :param definition: Collection definition\n+    :type parent: ServiceResource\n+    :param parent: The collection's parent resource\n+    :type py_operation_name: string\n+    :param py_operation_name: Snake-cased operation name\n+    :type handler: :py:class:`~boto3.resources.response.ResourceHandler`\n+    :param handler: The resource response handler used to create resource\n+                    instances\n+\n+    :ivar parent: The collection's parent resource\n+    :ivar params: A dict of key value pairs to send as parameters to the\n+                  underlying service operation\n+\n+    \"\"\"\n+    def __init__(self, definition, parent, py_operation_name, handler,\n+                 **kwargs):\n+        self.definition = definition\n+        self.parent = parent\n+        self.py_operation_name = py_operation_name\n+        self.handler = handler\n+        self.params = kwargs\n+\n+    def __repr__(self):\n+        return '{0}({1}, {2})'.format(\n+            self.__class__.__name__,\n+            self.parent,\n+            '{0}.{1}'.format(\n+                self.parent.meta['service_name'],\n+                self.definition.get('resource', {}).get('type')\n+            )\n+        )\n+\n+    def __iter__(self):\n+        \"\"\"\n+        A generator which yields resource instances after doing the\n+        appropriate service operation calls and handling any pagination\n+        on your behalf.\n+        \"\"\"\n+        client = self.parent.meta['client']\n+        cleaned_params = self.params.copy()\n+        limit = cleaned_params.pop('limit', None)\n+        page_size = cleaned_params.pop('page_size', None)\n+\n+        params = create_request_parameters(self.parent,\n+            self.definition.get('request', {}))\n+        params.update(cleaned_params)\n+\n+        # Is this a paginated operation? If so, we need to get an\n+        # iterator for the various pages. If not, then we simply\n+        # call the operation and return the result as a single\n+        # page in a list. For non-paginated results, we just ignore\n+        # the page size parameter.\n+        if client.can_paginate(self.py_operation_name):\n+            paginator = client.get_paginator(self.py_operation_name)\n+            pages = paginator.paginate(limit=limit,\n+                page_size=page_size, **params)\n+        else:\n+            logger.info('Calling %s:%s with %r',\n+                        self.parent.meta['service_name'],\n+            self.py_operation_name, params)\n+            pages = [getattr(client, self.py_operation_name)(**params)]\n+\n+        # Now that we have a page iterator or single page of results\n+        # we start processing and yielding individual items.\n+        count = 0\n+        for page in pages:\n+            for item in self.handler(self.parent, params, page):\n+                yield item\n+\n+                # If the limit is set and has been reached, then\n+                # we stop processing items here.\n+                count += 1\n+                if limit is not None and count >= limit:\n+                    return\n+\n+    def __getitem__(self, k):\n+        \"\"\"\n+        Enable array indexing and slicing, for example:\n+\n+            >>> collection.all()[2]\n+            Item2\n+            >>> collection.all()[:5]\n+            [Item1, Item2, Item3, Item4, Item5]\n+        \"\"\"\n+        return list(self)[k]",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "18854937",
        "repo_full_name": "boto/boto3",
        "pr_number": 4,
        "pr_file": "boto3/resources/collection.py",
        "discussion_id": "18854937",
        "commented_code": "@@ -0,0 +1,282 @@\n+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+import logging\n+\n+from botocore import xform_name\n+\n+from .params import create_request_parameters\n+from .response import ResourceHandler\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class ResourceCollection(object):\n+    \"\"\"\n+    Represents a collection of resources, which can be iterated through,\n+    optionally with filtering. Collections automatically handle pagination\n+    for you.\n+\n+    See :ref:`guide_collections` for a high-level overview of collections,\n+    including when remote service requests are performed.\n+\n+    :type definition: dict\n+    :param definition: Collection definition\n+    :type parent: ServiceResource\n+    :param parent: The collection's parent resource\n+    :type py_operation_name: string\n+    :param py_operation_name: Snake-cased operation name\n+    :type handler: :py:class:`~boto3.resources.response.ResourceHandler`\n+    :param handler: The resource response handler used to create resource\n+                    instances\n+\n+    :ivar parent: The collection's parent resource\n+    :ivar params: A dict of key value pairs to send as parameters to the\n+                  underlying service operation\n+\n+    \"\"\"\n+    def __init__(self, definition, parent, py_operation_name, handler,\n+                 **kwargs):\n+        self.definition = definition\n+        self.parent = parent\n+        self.py_operation_name = py_operation_name\n+        self.handler = handler\n+        self.params = kwargs\n+\n+    def __repr__(self):\n+        return '{0}({1}, {2})'.format(\n+            self.__class__.__name__,\n+            self.parent,\n+            '{0}.{1}'.format(\n+                self.parent.meta['service_name'],\n+                self.definition.get('resource', {}).get('type')\n+            )\n+        )\n+\n+    def __iter__(self):\n+        \"\"\"\n+        A generator which yields resource instances after doing the\n+        appropriate service operation calls and handling any pagination\n+        on your behalf.\n+        \"\"\"\n+        client = self.parent.meta['client']\n+        cleaned_params = self.params.copy()\n+        limit = cleaned_params.pop('limit', None)\n+        page_size = cleaned_params.pop('page_size', None)\n+\n+        params = create_request_parameters(self.parent,\n+            self.definition.get('request', {}))\n+        params.update(cleaned_params)\n+\n+        # Is this a paginated operation? If so, we need to get an\n+        # iterator for the various pages. If not, then we simply\n+        # call the operation and return the result as a single\n+        # page in a list. For non-paginated results, we just ignore\n+        # the page size parameter.\n+        if client.can_paginate(self.py_operation_name):\n+            paginator = client.get_paginator(self.py_operation_name)\n+            pages = paginator.paginate(limit=limit,\n+                page_size=page_size, **params)\n+        else:\n+            logger.info('Calling %s:%s with %r',\n+                        self.parent.meta['service_name'],\n+            self.py_operation_name, params)\n+            pages = [getattr(client, self.py_operation_name)(**params)]\n+\n+        # Now that we have a page iterator or single page of results\n+        # we start processing and yielding individual items.\n+        count = 0\n+        for page in pages:\n+            for item in self.handler(self.parent, params, page):\n+                yield item\n+\n+                # If the limit is set and has been reached, then\n+                # we stop processing items here.\n+                count += 1\n+                if limit is not None and count >= limit:\n+                    return\n+\n+    def __getitem__(self, k):\n+        \"\"\"\n+        Enable array indexing and slicing, for example:\n+\n+            >>> collection.all()[2]\n+            Item2\n+            >>> collection.all()[:5]\n+            [Item1, Item2, Item3, Item4, Item5]\n+        \"\"\"\n+        return list(self)[k]",
        "comment_created_at": "2014-10-14T20:12:18+00:00",
        "comment_author": "danielgtaylor",
        "comment_body": "We spoke about this in person, but I'll add a note here for others. Currently, it iterates through the entire set, creates a resource instance for each entry, then throws away everything outside of the slice. It is very inefficient, but provides a stable API that can be made more efficient in the future (potentially). Important notes:\n- We should be able to set a `limit` on some (or all?) calls\n- We should be able to only create resource instances for the items we return\n- We currently support negative indexing\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "18927293",
    "pr_number": 4,
    "pr_file": "boto3/resources/collection.py",
    "created_at": "2014-10-15T22:20:06+00:00",
    "commented_code": "+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+import logging\n+\n+from botocore import xform_name\n+\n+from .params import create_request_parameters\n+from .response import ResourceHandler\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class ResourceCollection(object):\n+    \"\"\"\n+    Represents a collection of resources, which can be iterated through,\n+    optionally with filtering. Collections automatically handle pagination\n+    for you.\n+\n+    See :ref:`guide_collections` for a high-level overview of collections,\n+    including when remote service requests are performed.\n+\n+    :type definition: dict\n+    :param definition: Collection definition\n+    :type parent: ServiceResource\n+    :param parent: The collection's parent resource\n+    :type py_operation_name: string\n+    :param py_operation_name: Snake-cased operation name\n+    :type handler: :py:class:`~boto3.resources.response.ResourceHandler`\n+    :param handler: The resource response handler used to create resource\n+                    instances\n+\n+    :ivar parent: The collection's parent resource\n+    :ivar params: A dict of key value pairs to send as parameters to the\n+                  underlying service operation\n+\n+    \"\"\"\n+    def __init__(self, definition, parent, py_operation_name, handler,\n+                 **kwargs):\n+        self.definition = definition\n+        self.parent = parent\n+        self.py_operation_name = py_operation_name\n+        self.handler = handler\n+        self.params = kwargs\n+\n+    def __repr__(self):\n+        return '{0}({1}, {2})'.format(\n+            self.__class__.__name__,\n+            self.parent,\n+            '{0}.{1}'.format(\n+                self.parent.meta['service_name'],\n+                self.definition.get('resource', {}).get('type')\n+            )\n+        )\n+\n+    def __iter__(self):\n+        \"\"\"\n+        A generator which yields resource instances after doing the\n+        appropriate service operation calls and handling any pagination\n+        on your behalf.\n+        \"\"\"\n+        client = self.parent.meta['client']\n+        cleaned_params = self.params.copy()\n+        limit = cleaned_params.pop('limit', None)\n+        page_size = cleaned_params.pop('page_size', None)\n+\n+        params = create_request_parameters(self.parent,\n+            self.definition.get('request', {}))\n+        params.update(cleaned_params)\n+\n+        # Is this a paginated operation? If so, we need to get an\n+        # iterator for the various pages. If not, then we simply\n+        # call the operation and return the result as a single\n+        # page in a list. For non-paginated results, we just ignore\n+        # the page size parameter.\n+        if client.can_paginate(self.py_operation_name):\n+            paginator = client.get_paginator(self.py_operation_name)\n+            pages = paginator.paginate(limit=limit,\n+                page_size=page_size, **params)\n+        else:\n+            logger.info('Calling %s:%s with %r',\n+                        self.parent.meta['service_name'],\n+            self.py_operation_name, params)\n+            pages = [getattr(client, self.py_operation_name)(**params)]\n+\n+        # Now that we have a page iterator or single page of results\n+        # we start processing and yielding individual items.\n+        count = 0\n+        for page in pages:\n+            for item in self.handler(self.parent, params, page):\n+                yield item\n+\n+                # If the limit is set and has been reached, then\n+                # we stop processing items here.\n+                count += 1\n+                if limit is not None and count >= limit:\n+                    return\n+\n+    def __getitem__(self, k):\n+        \"\"\"\n+        Enable array indexing and slicing, for example:\n+\n+            >>> collection.all()[2]\n+            Item2\n+            >>> collection.all()[:5]\n+            [Item1, Item2, Item3, Item4, Item5]\n+        \"\"\"\n+        return list(self)[k]",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "18927293",
        "repo_full_name": "boto/boto3",
        "pr_number": 4,
        "pr_file": "boto3/resources/collection.py",
        "discussion_id": "18927293",
        "commented_code": "@@ -0,0 +1,282 @@\n+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+import logging\n+\n+from botocore import xform_name\n+\n+from .params import create_request_parameters\n+from .response import ResourceHandler\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class ResourceCollection(object):\n+    \"\"\"\n+    Represents a collection of resources, which can be iterated through,\n+    optionally with filtering. Collections automatically handle pagination\n+    for you.\n+\n+    See :ref:`guide_collections` for a high-level overview of collections,\n+    including when remote service requests are performed.\n+\n+    :type definition: dict\n+    :param definition: Collection definition\n+    :type parent: ServiceResource\n+    :param parent: The collection's parent resource\n+    :type py_operation_name: string\n+    :param py_operation_name: Snake-cased operation name\n+    :type handler: :py:class:`~boto3.resources.response.ResourceHandler`\n+    :param handler: The resource response handler used to create resource\n+                    instances\n+\n+    :ivar parent: The collection's parent resource\n+    :ivar params: A dict of key value pairs to send as parameters to the\n+                  underlying service operation\n+\n+    \"\"\"\n+    def __init__(self, definition, parent, py_operation_name, handler,\n+                 **kwargs):\n+        self.definition = definition\n+        self.parent = parent\n+        self.py_operation_name = py_operation_name\n+        self.handler = handler\n+        self.params = kwargs\n+\n+    def __repr__(self):\n+        return '{0}({1}, {2})'.format(\n+            self.__class__.__name__,\n+            self.parent,\n+            '{0}.{1}'.format(\n+                self.parent.meta['service_name'],\n+                self.definition.get('resource', {}).get('type')\n+            )\n+        )\n+\n+    def __iter__(self):\n+        \"\"\"\n+        A generator which yields resource instances after doing the\n+        appropriate service operation calls and handling any pagination\n+        on your behalf.\n+        \"\"\"\n+        client = self.parent.meta['client']\n+        cleaned_params = self.params.copy()\n+        limit = cleaned_params.pop('limit', None)\n+        page_size = cleaned_params.pop('page_size', None)\n+\n+        params = create_request_parameters(self.parent,\n+            self.definition.get('request', {}))\n+        params.update(cleaned_params)\n+\n+        # Is this a paginated operation? If so, we need to get an\n+        # iterator for the various pages. If not, then we simply\n+        # call the operation and return the result as a single\n+        # page in a list. For non-paginated results, we just ignore\n+        # the page size parameter.\n+        if client.can_paginate(self.py_operation_name):\n+            paginator = client.get_paginator(self.py_operation_name)\n+            pages = paginator.paginate(limit=limit,\n+                page_size=page_size, **params)\n+        else:\n+            logger.info('Calling %s:%s with %r',\n+                        self.parent.meta['service_name'],\n+            self.py_operation_name, params)\n+            pages = [getattr(client, self.py_operation_name)(**params)]\n+\n+        # Now that we have a page iterator or single page of results\n+        # we start processing and yielding individual items.\n+        count = 0\n+        for page in pages:\n+            for item in self.handler(self.parent, params, page):\n+                yield item\n+\n+                # If the limit is set and has been reached, then\n+                # we stop processing items here.\n+                count += 1\n+                if limit is not None and count >= limit:\n+                    return\n+\n+    def __getitem__(self, k):\n+        \"\"\"\n+        Enable array indexing and slicing, for example:\n+\n+            >>> collection.all()[2]\n+            Item2\n+            >>> collection.all()[:5]\n+            [Item1, Item2, Item3, Item4, Item5]\n+        \"\"\"\n+        return list(self)[k]",
        "comment_created_at": "2014-10-15T22:20:06+00:00",
        "comment_author": "jamesls",
        "comment_body": "So I remember discussing that we should _not_ add this.  I'm -1 against slicing because it's entirely dependent on the service whether this can be done efficiently (it typically can't), and I think that users will expect an efficient implementation and will be surprised why foo[-1] could take hours (and be really expensive).\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "18969755",
    "pr_number": 4,
    "pr_file": "boto3/resources/collection.py",
    "created_at": "2014-10-16T17:02:40+00:00",
    "commented_code": "+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+import logging\n+\n+from botocore import xform_name\n+\n+from .params import create_request_parameters\n+from .response import ResourceHandler\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class ResourceCollection(object):\n+    \"\"\"\n+    Represents a collection of resources, which can be iterated through,\n+    optionally with filtering. Collections automatically handle pagination\n+    for you.\n+\n+    See :ref:`guide_collections` for a high-level overview of collections,\n+    including when remote service requests are performed.\n+\n+    :type definition: dict\n+    :param definition: Collection definition\n+    :type parent: ServiceResource\n+    :param parent: The collection's parent resource\n+    :type py_operation_name: string\n+    :param py_operation_name: Snake-cased operation name\n+    :type handler: :py:class:`~boto3.resources.response.ResourceHandler`\n+    :param handler: The resource response handler used to create resource\n+                    instances\n+\n+    :ivar parent: The collection's parent resource\n+    :ivar params: A dict of key value pairs to send as parameters to the\n+                  underlying service operation\n+\n+    \"\"\"\n+    def __init__(self, definition, parent, py_operation_name, handler,\n+                 **kwargs):\n+        self.definition = definition\n+        self.parent = parent\n+        self.py_operation_name = py_operation_name\n+        self.handler = handler\n+        self.params = kwargs\n+\n+    def __repr__(self):\n+        return '{0}({1}, {2})'.format(\n+            self.__class__.__name__,\n+            self.parent,\n+            '{0}.{1}'.format(\n+                self.parent.meta['service_name'],\n+                self.definition.get('resource', {}).get('type')\n+            )\n+        )\n+\n+    def __iter__(self):\n+        \"\"\"\n+        A generator which yields resource instances after doing the\n+        appropriate service operation calls and handling any pagination\n+        on your behalf.\n+        \"\"\"\n+        client = self.parent.meta['client']\n+        cleaned_params = self.params.copy()\n+        limit = cleaned_params.pop('limit', None)\n+        page_size = cleaned_params.pop('page_size', None)\n+\n+        params = create_request_parameters(self.parent,\n+            self.definition.get('request', {}))\n+        params.update(cleaned_params)\n+\n+        # Is this a paginated operation? If so, we need to get an\n+        # iterator for the various pages. If not, then we simply\n+        # call the operation and return the result as a single\n+        # page in a list. For non-paginated results, we just ignore\n+        # the page size parameter.\n+        if client.can_paginate(self.py_operation_name):\n+            paginator = client.get_paginator(self.py_operation_name)\n+            pages = paginator.paginate(limit=limit,\n+                page_size=page_size, **params)\n+        else:\n+            logger.info('Calling %s:%s with %r',\n+                        self.parent.meta['service_name'],\n+            self.py_operation_name, params)\n+            pages = [getattr(client, self.py_operation_name)(**params)]\n+\n+        # Now that we have a page iterator or single page of results\n+        # we start processing and yielding individual items.\n+        count = 0\n+        for page in pages:\n+            for item in self.handler(self.parent, params, page):\n+                yield item\n+\n+                # If the limit is set and has been reached, then\n+                # we stop processing items here.\n+                count += 1\n+                if limit is not None and count >= limit:\n+                    return\n+\n+    def __getitem__(self, k):\n+        \"\"\"\n+        Enable array indexing and slicing, for example:\n+\n+            >>> collection.all()[2]\n+            Item2\n+            >>> collection.all()[:5]\n+            [Item1, Item2, Item3, Item4, Item5]\n+        \"\"\"\n+        return list(self)[k]",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "18969755",
        "repo_full_name": "boto/boto3",
        "pr_number": 4,
        "pr_file": "boto3/resources/collection.py",
        "discussion_id": "18969755",
        "commented_code": "@@ -0,0 +1,282 @@\n+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+import logging\n+\n+from botocore import xform_name\n+\n+from .params import create_request_parameters\n+from .response import ResourceHandler\n+\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class ResourceCollection(object):\n+    \"\"\"\n+    Represents a collection of resources, which can be iterated through,\n+    optionally with filtering. Collections automatically handle pagination\n+    for you.\n+\n+    See :ref:`guide_collections` for a high-level overview of collections,\n+    including when remote service requests are performed.\n+\n+    :type definition: dict\n+    :param definition: Collection definition\n+    :type parent: ServiceResource\n+    :param parent: The collection's parent resource\n+    :type py_operation_name: string\n+    :param py_operation_name: Snake-cased operation name\n+    :type handler: :py:class:`~boto3.resources.response.ResourceHandler`\n+    :param handler: The resource response handler used to create resource\n+                    instances\n+\n+    :ivar parent: The collection's parent resource\n+    :ivar params: A dict of key value pairs to send as parameters to the\n+                  underlying service operation\n+\n+    \"\"\"\n+    def __init__(self, definition, parent, py_operation_name, handler,\n+                 **kwargs):\n+        self.definition = definition\n+        self.parent = parent\n+        self.py_operation_name = py_operation_name\n+        self.handler = handler\n+        self.params = kwargs\n+\n+    def __repr__(self):\n+        return '{0}({1}, {2})'.format(\n+            self.__class__.__name__,\n+            self.parent,\n+            '{0}.{1}'.format(\n+                self.parent.meta['service_name'],\n+                self.definition.get('resource', {}).get('type')\n+            )\n+        )\n+\n+    def __iter__(self):\n+        \"\"\"\n+        A generator which yields resource instances after doing the\n+        appropriate service operation calls and handling any pagination\n+        on your behalf.\n+        \"\"\"\n+        client = self.parent.meta['client']\n+        cleaned_params = self.params.copy()\n+        limit = cleaned_params.pop('limit', None)\n+        page_size = cleaned_params.pop('page_size', None)\n+\n+        params = create_request_parameters(self.parent,\n+            self.definition.get('request', {}))\n+        params.update(cleaned_params)\n+\n+        # Is this a paginated operation? If so, we need to get an\n+        # iterator for the various pages. If not, then we simply\n+        # call the operation and return the result as a single\n+        # page in a list. For non-paginated results, we just ignore\n+        # the page size parameter.\n+        if client.can_paginate(self.py_operation_name):\n+            paginator = client.get_paginator(self.py_operation_name)\n+            pages = paginator.paginate(limit=limit,\n+                page_size=page_size, **params)\n+        else:\n+            logger.info('Calling %s:%s with %r',\n+                        self.parent.meta['service_name'],\n+            self.py_operation_name, params)\n+            pages = [getattr(client, self.py_operation_name)(**params)]\n+\n+        # Now that we have a page iterator or single page of results\n+        # we start processing and yielding individual items.\n+        count = 0\n+        for page in pages:\n+            for item in self.handler(self.parent, params, page):\n+                yield item\n+\n+                # If the limit is set and has been reached, then\n+                # we stop processing items here.\n+                count += 1\n+                if limit is not None and count >= limit:\n+                    return\n+\n+    def __getitem__(self, k):\n+        \"\"\"\n+        Enable array indexing and slicing, for example:\n+\n+            >>> collection.all()[2]\n+            Item2\n+            >>> collection.all()[:5]\n+            [Item1, Item2, Item3, Item4, Item5]\n+        \"\"\"\n+        return list(self)[k]",
        "comment_created_at": "2014-10-16T17:02:40+00:00",
        "comment_author": "danielgtaylor",
        "comment_body": "I'm removing this for now so that we can reconvene and discuss (and get the rest of this merged), but I am **very strongly** in favor of providing a mechanism that is **sometimes** more efficient over one that is **never** efficient. I would rather we use documentation to explain this than force customers into the most expensive operations all the time. We can also disable negative slicing, which is what Django does, if that's a big concern. In that case you'd need to explicitly cast to a list before doing a negative slice, which makes it clear what is happening under the hood.\n",
        "pr_file_module": null
      }
    ]
  }
]