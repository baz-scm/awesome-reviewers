[
  {
    "discussion_id": "633949330",
    "pr_number": 2848,
    "pr_file": "docs/source/guide/resources.rst",
    "created_at": "2021-05-18T00:28:33+00:00",
    "commented_code": "Multithreading and multiprocessing\n---------------------------------\n-It is recommended to create a resource instance for each thread / process in a multithreaded or multiprocess application rather than sharing a single instance among the threads / processes. For example::\n+----------------------------------\n+SDK object instances are **not** thread safe in almost all cases and should not be shared across threads or processes. You should create a new SDK object for each thread or process::",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "633949330",
        "repo_full_name": "boto/boto3",
        "pr_number": 2848,
        "pr_file": "docs/source/guide/resources.rst",
        "discussion_id": "633949330",
        "commented_code": "@@ -199,22 +199,32 @@ keyword arguments. Examples of waiters include::\n \n \n Multithreading and multiprocessing\n---------------------------------\n-It is recommended to create a resource instance for each thread / process in a multithreaded or multiprocess application rather than sharing a single instance among the threads / processes. For example::\n+----------------------------------\n+SDK object instances are **not** thread safe in almost all cases and should not be shared across threads or processes. You should create a new SDK object for each thread or process::",
        "comment_created_at": "2021-05-18T00:28:33+00:00",
        "comment_author": "nateprewitt",
        "comment_body": "I know this came out of @mattsb42-aws's recommendation, but the phrasing here may be slightly heavy handed. Rather than caution against any use of parallelism, we should try to help define the safety boundaries. In general, creating a session is a heavy-duty operation that can significantly (sometimes prohibitively) increase cold-start time for Docker/AWS Lambda use cases.\r\n\r\nFor basic usage, like handing around a client to perform some operation (e.g. s3's `list_buckets` or ec2's `start_instances`), things are thread-safe.\r\n\r\nSafety gets a bit murkier when introducing a `Resource`, `Session`, and client attributes that could potentially interact with the underlying session (e.g `client.meta`, the botocore event system, etc).\r\n\r\nSo I'm going to propose a slight change in tack. We have different sections for each of these three primitives and instead of building on the note that we probably shouldn't have merged originally, let's get the distinctions moved to the correct places.\r\n\r\n* [Clients](https://github.com/boto/boto3/blob/develop/docs/source/guide/clients.rst)\r\n* [Resources](https://github.com/boto/boto3/blob/develop/docs/source/guide/resources.rst)\r\n* [Sessions](https://github.com/boto/boto3/blob/develop/docs/source/guide/session.rst)\r\n\r\nSince, this section is specifically about `Resource`s, let's start there. We can safely state something like:\r\n\r\n\"~SDK object~ Resource instances are **not** thread safe ~in almost all cases~. These special classes contain additional meta data that cannot be shared. ~You should~ It's recommended to create a new ~SDK object~ Resource for each thread or process\"\r\n\r\nThen let's remove everything from `note::` downward.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "633955949",
    "pr_number": 2848,
    "pr_file": "docs/source/guide/resources.rst",
    "created_at": "2021-05-18T00:49:30+00:00",
    "commented_code": "Multithreading and multiprocessing\n---------------------------------\n-It is recommended to create a resource instance for each thread / process in a multithreaded or multiprocess application rather than sharing a single instance among the threads / processes. For example::\n+----------------------------------\n+SDK object instances are **not** thread safe in almost all cases and should not be shared across threads or processes. You should create a new SDK object for each thread or process::\n \n     import boto3\n     import boto3.session\n     import threading\n \n     class MyTask(threading.Thread):\n         def run(self):\n+            # Here we create a new session per thread\n             session = boto3.session.Session()\n+\n+            # Next, we create a resource client using our thread's session object\n             s3 = session.resource('s3')\n-            # ... do some work with S3 ...\n+\n+            # Put your thread-safe code here\n \n In the example above, each thread would have its own Boto3 session and its own instance of the S3 resource. This is a good idea because resources contain shared data when loaded and calling actions, accessing properties, or manually loading or reloading the resource can modify this data.\n \n .. note::\n-    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above. \n-    \n-    Low-level clients **are** thread safe. When using a low-level client, it is recommended to instantiate your client then pass that client object to each of your threads. \n+    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above.\n+\n+    Sessions are **not** thread safe. This is due to shared meta data, similar to Resource.",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "633955949",
        "repo_full_name": "boto/boto3",
        "pr_number": 2848,
        "pr_file": "docs/source/guide/resources.rst",
        "discussion_id": "633955949",
        "commented_code": "@@ -199,22 +199,32 @@ keyword arguments. Examples of waiters include::\n \n \n Multithreading and multiprocessing\n---------------------------------\n-It is recommended to create a resource instance for each thread / process in a multithreaded or multiprocess application rather than sharing a single instance among the threads / processes. For example::\n+----------------------------------\n+SDK object instances are **not** thread safe in almost all cases and should not be shared across threads or processes. You should create a new SDK object for each thread or process::\n \n     import boto3\n     import boto3.session\n     import threading\n \n     class MyTask(threading.Thread):\n         def run(self):\n+            # Here we create a new session per thread\n             session = boto3.session.Session()\n+\n+            # Next, we create a resource client using our thread's session object\n             s3 = session.resource('s3')\n-            # ... do some work with S3 ...\n+\n+            # Put your thread-safe code here\n \n In the example above, each thread would have its own Boto3 session and its own instance of the S3 resource. This is a good idea because resources contain shared data when loaded and calling actions, accessing properties, or manually loading or reloading the resource can modify this data.\n \n .. note::\n-    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above. \n-    \n-    Low-level clients **are** thread safe. When using a low-level client, it is recommended to instantiate your client then pass that client object to each of your threads. \n+    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above.\n+\n+    Sessions are **not** thread safe. This is due to shared meta data, similar to Resource.",
        "comment_created_at": "2021-05-18T00:49:30+00:00",
        "comment_author": "nateprewitt",
        "comment_body": "Session actually already has a pretty good explanation that [mirrors](https://github.com/boto/boto3/blob/develop/docs/source/guide/session.rst#multithreading-or-multiprocessing-with-sessions) this. Let's change the wording there slightly though:\r\n\r\n\"~You should~ It's recommended to create a new `Session` object for each thread or process:\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "633978575",
    "pr_number": 2848,
    "pr_file": "docs/source/guide/resources.rst",
    "created_at": "2021-05-18T02:02:09+00:00",
    "commented_code": "Multithreading and multiprocessing\n---------------------------------\n-It is recommended to create a resource instance for each thread / process in a multithreaded or multiprocess application rather than sharing a single instance among the threads / processes. For example::\n+----------------------------------\n+SDK object instances are **not** thread safe in almost all cases and should not be shared across threads or processes. You should create a new SDK object for each thread or process::\n \n     import boto3\n     import boto3.session\n     import threading\n \n     class MyTask(threading.Thread):\n         def run(self):\n+            # Here we create a new session per thread\n             session = boto3.session.Session()\n+\n+            # Next, we create a resource client using our thread's session object\n             s3 = session.resource('s3')\n-            # ... do some work with S3 ...\n+\n+            # Put your thread-safe code here\n \n In the example above, each thread would have its own Boto3 session and its own instance of the S3 resource. This is a good idea because resources contain shared data when loaded and calling actions, accessing properties, or manually loading or reloading the resource can modify this data.\n \n .. note::\n-    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above. \n-    \n-    Low-level clients **are** thread safe. When using a low-level client, it is recommended to instantiate your client then pass that client object to each of your threads. \n+    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above.\n+\n+    Sessions are **not** thread safe. This is due to shared meta data, similar to Resource.\n+\n+    Low-level clients **are** thread safe in a **threaded environment** in all cases when using the client's attached operation methods (i.e. ``s3.get_object``). However, clients are **not** thread safe if you are explicitly using the client to interact with the underlying Session (i.e. using ``s3.meta``, ``s3.exceptions``, or ``s3.waiter_names``).",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "633978575",
        "repo_full_name": "boto/boto3",
        "pr_number": 2848,
        "pr_file": "docs/source/guide/resources.rst",
        "discussion_id": "633978575",
        "commented_code": "@@ -199,22 +199,32 @@ keyword arguments. Examples of waiters include::\n \n \n Multithreading and multiprocessing\n---------------------------------\n-It is recommended to create a resource instance for each thread / process in a multithreaded or multiprocess application rather than sharing a single instance among the threads / processes. For example::\n+----------------------------------\n+SDK object instances are **not** thread safe in almost all cases and should not be shared across threads or processes. You should create a new SDK object for each thread or process::\n \n     import boto3\n     import boto3.session\n     import threading\n \n     class MyTask(threading.Thread):\n         def run(self):\n+            # Here we create a new session per thread\n             session = boto3.session.Session()\n+\n+            # Next, we create a resource client using our thread's session object\n             s3 = session.resource('s3')\n-            # ... do some work with S3 ...\n+\n+            # Put your thread-safe code here\n \n In the example above, each thread would have its own Boto3 session and its own instance of the S3 resource. This is a good idea because resources contain shared data when loaded and calling actions, accessing properties, or manually loading or reloading the resource can modify this data.\n \n .. note::\n-    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above. \n-    \n-    Low-level clients **are** thread safe. When using a low-level client, it is recommended to instantiate your client then pass that client object to each of your threads. \n+    Resources are **not** thread safe. These special classes contain additional meta data that cannot be shared between threads. When using a Resource, it is recommended to instantiate a new Resource for each thread, as is shown in the example above.\n+\n+    Sessions are **not** thread safe. This is due to shared meta data, similar to Resource.\n+\n+    Low-level clients **are** thread safe in a **threaded environment** in all cases when using the client's attached operation methods (i.e. ``s3.get_object``). However, clients are **not** thread safe if you are explicitly using the client to interact with the underlying Session (i.e. using ``s3.meta``, ``s3.exceptions``, or ``s3.waiter_names``).",
        "comment_created_at": "2021-05-18T02:02:09+00:00",
        "comment_author": "nateprewitt",
        "comment_body": "For clients, we'll need to get a new section added to the bottom of the [guide](https://github.com/boto/boto3/blob/develop/docs/source/guide/clients.rst), similar to Resource and Session.\r\n\r\nFeel free to riff on this if you feel there's better phrasing or layout, but something along these lines would be a great start:\r\n\r\n## Multithreading or multiprocessing with Clients\r\nUnlike Resources and Sessions, clients **are** generally _thread-safe_. There are some caveats, defined below, to be aware of though.\r\n\r\n### Caveats\r\n\r\n**Multi-Processing:** While clients are _thread-safe_, they cannot be shared across processes due to their networking implementation. Doing so may lead to incorrect response ordering when calling services.\r\n\r\n**Shared Metadata:** Clients expose metadata to the end user through a few attributes (namely `meta`, `exceptions` and `waiter_names`). These are safe to read but any mutations should not be considered thread-safe.\r\n\r\n**Custom [Botocore Events](https://botocore.amazonaws.com/v1/documentation/api/latest/topics/events.html):** Botocore (the library Boto3 is built on) allows advanced users to provide their own custom event hooks which may interact with boto3's client. The majority of users will not need to use these interfaces, but those that do should no longer consider their clients thread-safe without careful review.\r\n\r\n### General Example\r\n\r\n```python\r\nimport boto3.session\r\nfrom concurrent.futures import ThreadPoolExecutor\r\n\r\ndef do_s3_task(client, task_definition):\r\n    # Put your thread-safe code here\r\n\r\ndef my_workflow():\r\n    # Create a session and use it to make our client\r\n    session = boto3.session.Session()\r\n    s3_client = session.client('s3')\r\n\r\n    # Define some work to be done, this can be anything\r\n    my_tasks = [ ... ]\r\n\r\n    # Dispatch work tasks with our s3_client\r\n    with ThreadPoolExecutor(max_workers=8) as executor:\r\n        futures = [executor.submit(do_s3_task, s3_client, task) for task in my_tasks]\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "28440001",
    "pr_number": 88,
    "pr_file": "docs/source/guide/resources.rst",
    "created_at": "2015-04-15T17:06:12+00:00",
    "commented_code": "# EC2: Wait for an instance to reach the running state.\n     instance.wait_until_running()\n+\n+\n+Multithreading\n+--------------\n+It is recommended to create a resource instance for each thread in a multithreaded application rather than sharing a single instance among the threads. For example::\n+\n+    import boto3\n+    import threading\n+\n+    class MyTask(threading.Thread):\n+        def run(self):\n+            s3 = boto3.resource('s3')",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "28440001",
        "repo_full_name": "boto/boto3",
        "pr_number": 88,
        "pr_file": "docs/source/guide/resources.rst",
        "discussion_id": "28440001",
        "commented_code": "@@ -185,3 +185,18 @@ keyword arguments. Examples of waiters include::\n \n     # EC2: Wait for an instance to reach the running state.\n     instance.wait_until_running()\n+\n+\n+Multithreading\n+--------------\n+It is recommended to create a resource instance for each thread in a multithreaded application rather than sharing a single instance among the threads. For example::\n+\n+    import boto3\n+    import threading\n+\n+    class MyTask(threading.Thread):\n+        def run(self):\n+            s3 = boto3.resource('s3')",
        "comment_created_at": "2015-04-15T17:06:12+00:00",
        "comment_author": "jamesls",
        "comment_body": "I'd prefer to move the resource creation out of the thread code, since resource creation isn't guaranteed to be thread safe if you're pulling from the same default session.  Either that or update this to also use separate sessions.\n",
        "pr_file_module": null
      }
    ]
  }
]