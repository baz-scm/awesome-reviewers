[
  {
    "discussion_id": "30761640",
    "pr_number": 103,
    "pr_file": "tests/integration/test_dynamodb.py",
    "created_at": "2015-05-20T23:51:50+00:00",
    "commented_code": "+# Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+import copy\n+from decimal import Decimal\n+\n+import boto3.session\n+from boto3.dynamodb.types import Binary\n+from boto3.dynamodb.conditions import Attr, Key\n+from tests import unittest, unique_id\n+\n+\n+class BaseDynamoDBTest(unittest.TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.session = boto3.session.Session(region_name='us-west-2')\n+        cls.dynamodb = cls.session.resource('dynamodb')\n+        cls.table_name = unique_id('boto3db')\n+        cls.item_data = {\n+            'MyHashKey': 'mykey',\n+            'MyNull': None,\n+            'MyBool': True,\n+            'MyString': 'mystring',\n+            'MyNumber': Decimal('1.25'),\n+            'MyBinary': Binary(b'\\x01'),\n+            'MyStringSet': set(['foo']),\n+            'MyNumberSet': set([Decimal('1.25')]),\n+            'MyBinarySet': set([Binary(b'\\x01')]),\n+            'MyList': ['foo'],\n+            'MyMap': {'foo': 'bar'}\n+        }\n+        cls.table = cls.dynamodb.create_table(\n+            TableName=cls.table_name,\n+            ProvisionedThroughput={\"ReadCapacityUnits\": 5,\n+                                   \"WriteCapacityUnits\": 5},\n+            KeySchema=[{\"AttributeName\": \"MyHashKey\", \"KeyType\": \"HASH\"}],\n+            AttributeDefinitions=[{\"AttributeName\": \"MyHashKey\",\n+                                   \"AttributeType\": \"S\"}])\n+        waiter = cls.dynamodb.meta.client.get_waiter('table_exists')\n+        waiter.wait(TableName=cls.table_name)\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.table.delete()\n+\n+\n+class TestDynamoDBTypes(BaseDynamoDBTest):\n+    def test_put_get_item(self):\n+        self.table.put_item(Item=copy.deepcopy(self.item_data))\n+        self.addCleanup(self.table.delete_item, Key={'MyHashKey': 'mykey'})\n+        response = self.table.get_item(Key={'MyHashKey': 'mykey'})\n+        self.assertEqual(response['Item'], self.item_data)\n+\n+\n+class TestDynamoDBConditions(BaseDynamoDBTest):\n+    @classmethod\n+    def setUpClass(cls):\n+        super(TestDynamoDBConditions, cls).setUpClass()\n+        cls.table.put_item(Item=copy.deepcopy(cls.item_data))\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.table.delete_item(Key={'MyHashKey': 'mykey'})\n+        super(TestDynamoDBConditions, cls).setUpClass()\n+\n+    def test_filter_expression(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyHashKey').eq('mykey'))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_key_condition_expression(self):\n+        response = self.table.query(\n+            KeyConditionExpression=Key('MyHashKey').eq('mykey'))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_key_condition_with_filter_condition_expression(self):\n+        response = self.table.query(\n+            KeyConditionExpression=Key('MyHashKey').eq('mykey'),\n+            FilterExpression=Attr('MyString').eq('mystring'))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_less_than(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').lt(Decimal('1.26')))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_less_than_equal(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').lte(Decimal('1.26')))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_greater_than(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').gt(Decimal('1.24')))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_greater_than_equal(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').gte(Decimal('1.24')))\n+        self.assertEqual(response['Count'], 1)",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "30761640",
        "repo_full_name": "boto/boto3",
        "pr_number": 103,
        "pr_file": "tests/integration/test_dynamodb.py",
        "discussion_id": "30761640",
        "commented_code": "@@ -0,0 +1,182 @@\n+# Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+import copy\n+from decimal import Decimal\n+\n+import boto3.session\n+from boto3.dynamodb.types import Binary\n+from boto3.dynamodb.conditions import Attr, Key\n+from tests import unittest, unique_id\n+\n+\n+class BaseDynamoDBTest(unittest.TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.session = boto3.session.Session(region_name='us-west-2')\n+        cls.dynamodb = cls.session.resource('dynamodb')\n+        cls.table_name = unique_id('boto3db')\n+        cls.item_data = {\n+            'MyHashKey': 'mykey',\n+            'MyNull': None,\n+            'MyBool': True,\n+            'MyString': 'mystring',\n+            'MyNumber': Decimal('1.25'),\n+            'MyBinary': Binary(b'\\x01'),\n+            'MyStringSet': set(['foo']),\n+            'MyNumberSet': set([Decimal('1.25')]),\n+            'MyBinarySet': set([Binary(b'\\x01')]),\n+            'MyList': ['foo'],\n+            'MyMap': {'foo': 'bar'}\n+        }\n+        cls.table = cls.dynamodb.create_table(\n+            TableName=cls.table_name,\n+            ProvisionedThroughput={\"ReadCapacityUnits\": 5,\n+                                   \"WriteCapacityUnits\": 5},\n+            KeySchema=[{\"AttributeName\": \"MyHashKey\", \"KeyType\": \"HASH\"}],\n+            AttributeDefinitions=[{\"AttributeName\": \"MyHashKey\",\n+                                   \"AttributeType\": \"S\"}])\n+        waiter = cls.dynamodb.meta.client.get_waiter('table_exists')\n+        waiter.wait(TableName=cls.table_name)\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.table.delete()\n+\n+\n+class TestDynamoDBTypes(BaseDynamoDBTest):\n+    def test_put_get_item(self):\n+        self.table.put_item(Item=copy.deepcopy(self.item_data))\n+        self.addCleanup(self.table.delete_item, Key={'MyHashKey': 'mykey'})\n+        response = self.table.get_item(Key={'MyHashKey': 'mykey'})\n+        self.assertEqual(response['Item'], self.item_data)\n+\n+\n+class TestDynamoDBConditions(BaseDynamoDBTest):\n+    @classmethod\n+    def setUpClass(cls):\n+        super(TestDynamoDBConditions, cls).setUpClass()\n+        cls.table.put_item(Item=copy.deepcopy(cls.item_data))\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.table.delete_item(Key={'MyHashKey': 'mykey'})\n+        super(TestDynamoDBConditions, cls).setUpClass()\n+\n+    def test_filter_expression(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyHashKey').eq('mykey'))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_key_condition_expression(self):\n+        response = self.table.query(\n+            KeyConditionExpression=Key('MyHashKey').eq('mykey'))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_key_condition_with_filter_condition_expression(self):\n+        response = self.table.query(\n+            KeyConditionExpression=Key('MyHashKey').eq('mykey'),\n+            FilterExpression=Attr('MyString').eq('mystring'))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_less_than(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').lt(Decimal('1.26')))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_less_than_equal(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').lte(Decimal('1.26')))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_greater_than(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').gt(Decimal('1.24')))\n+        self.assertEqual(response['Count'], 1)\n+\n+    def test_condition_greater_than_equal(self):\n+        response = self.table.scan(\n+            FilterExpression=Attr('MyNumber').gte(Decimal('1.24')))\n+        self.assertEqual(response['Count'], 1)",
        "comment_created_at": "2015-05-20T23:51:50+00:00",
        "comment_author": "jamesls",
        "comment_body": "Can we test the specific condition we're filtering/querying for (I'm asking for all of the tests in this class)?\nFor example,  `r = FilterExpression=Attr('MyNumber').gte(Decimal('1.24'))), r['Items'].values()[0] < 1.24`.\n\nIt would put additional context in the test rather than requiring the user to scroll up and see why the count should be 1.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "30762115",
    "pr_number": 103,
    "pr_file": "tests/unit/dynamodb/test_transform.py",
    "created_at": "2015-05-20T23:59:08+00:00",
    "commented_code": "+# Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+import copy\n+from tests import unittest, mock\n+\n+from botocore.model import ServiceModel, OperationModel\n+\n+from boto3.dynamodb.transform import ParameterTransformer\n+from boto3.dynamodb.transform import transform_attribute_value_input\n+from boto3.dynamodb.transform import transform_attribute_value_output\n+from boto3.dynamodb.transform import transform_condition_expressions\n+from boto3.dynamodb.transform import register_high_level_interface\n+from boto3.dynamodb.conditions import Attr, Key\n+\n+\n+class BaseTransformationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.target_shape_name = 'MyShape'\n+        self.original_value = 'orginal'\n+        self.transformed_value = 'transformed'\n+        self.transformer = ParameterTransformer()\n+        self.json_model = {}\n+        self.nested_json_model = {}\n+        self.setup_models()\n+        self.build_models()\n+\n+    def setup_models(self):\n+        self.json_model = {\n+            'operations': {\n+                'SampleOperation': {\n+                    'name': 'SampleOperation',\n+                    'input': {'shape': 'SampleOperationInputOutput'},\n+                    'output': {'shape': 'SampleOperationInputOutput'}\n+                }\n+            },\n+            'shapes': {\n+                self.target_shape_name: {\n+                    'type': 'string'\n+                },\n+                'List': {\n+                    'type': 'list',\n+                    'member': {'shape': self.target_shape_name}\n+                },\n+                'Map': {\n+                    'type': 'map',\n+                    'key': {'shape': 'Name'},\n+                    'value': {'shape': self.target_shape_name}\n+                },\n+                'Structure': {\n+                    'type': 'structure',\n+                    'members': {\n+                        'Member': {'shape': self.target_shape_name}\n+                    }\n+                },\n+                'SampleOperationInputOutput': {\n+                    'type': 'structure',\n+                    'members': {\n+                        'Structure': {'shape': 'Structure'},\n+                        'Map': {'shape': 'Map'},\n+                        'List': {'shape': 'List'},\n+                    }\n+                },\n+                'Name': {\n+                    'type': 'string'\n+                }\n+            }\n+        }\n+\n+        # Create a more complicated model to test the ability to recurse\n+        # through a structure.\n+        self.nested_json_model = copy.deepcopy(self.json_model)\n+        shapes = self.nested_json_model['shapes']\n+        shapes['SampleOperationInputOutput']['members'] = {\n+            'Structure': {'shape': 'WrapperStructure'},\n+            'Map': {'shape': 'WrapperMap'},\n+            'List': {'shape': 'WrapperList'}\n+        }\n+        shapes['WrapperStructure'] = {\n+            'type': 'structure',\n+            'members': {'Structure': {'shape': 'Structure'}}\n+        }\n+        shapes['WrapperMap'] = {\n+            'type': 'map',\n+            'key': {'shape': 'Name'},\n+            'value': {'shape': 'Map'}\n+        }\n+        shapes['WrapperList'] = {\n+            'type': 'list',\n+            'member': {'shape': 'List'}\n+        }\n+\n+    def build_models(self):\n+        self.service_model = ServiceModel(self.json_model)\n+        self.operation_model = OperationModel(\n+            self.json_model['operations']['SampleOperation'],\n+            self.service_model\n+        )\n+\n+        self.nested_service_model = ServiceModel(self.nested_json_model)\n+        self.nested_operation_model = OperationModel(\n+            self.nested_json_model['operations']['SampleOperation'],\n+            self.nested_service_model\n+        )\n+\n+\n+class TestInputOutputTransformer(BaseTransformationTest):\n+    def setUp(self):\n+        super(TestInputOutputTransformer, self).setUp()\n+        self.transformation = lambda params: self.transformed_value\n+\n+    def test_transform_structure(self):",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "30762115",
        "repo_full_name": "boto/boto3",
        "pr_number": 103,
        "pr_file": "tests/unit/dynamodb/test_transform.py",
        "discussion_id": "30762115",
        "commented_code": "@@ -0,0 +1,390 @@\n+# Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+import copy\n+from tests import unittest, mock\n+\n+from botocore.model import ServiceModel, OperationModel\n+\n+from boto3.dynamodb.transform import ParameterTransformer\n+from boto3.dynamodb.transform import transform_attribute_value_input\n+from boto3.dynamodb.transform import transform_attribute_value_output\n+from boto3.dynamodb.transform import transform_condition_expressions\n+from boto3.dynamodb.transform import register_high_level_interface\n+from boto3.dynamodb.conditions import Attr, Key\n+\n+\n+class BaseTransformationTest(unittest.TestCase):\n+    def setUp(self):\n+        self.target_shape_name = 'MyShape'\n+        self.original_value = 'orginal'\n+        self.transformed_value = 'transformed'\n+        self.transformer = ParameterTransformer()\n+        self.json_model = {}\n+        self.nested_json_model = {}\n+        self.setup_models()\n+        self.build_models()\n+\n+    def setup_models(self):\n+        self.json_model = {\n+            'operations': {\n+                'SampleOperation': {\n+                    'name': 'SampleOperation',\n+                    'input': {'shape': 'SampleOperationInputOutput'},\n+                    'output': {'shape': 'SampleOperationInputOutput'}\n+                }\n+            },\n+            'shapes': {\n+                self.target_shape_name: {\n+                    'type': 'string'\n+                },\n+                'List': {\n+                    'type': 'list',\n+                    'member': {'shape': self.target_shape_name}\n+                },\n+                'Map': {\n+                    'type': 'map',\n+                    'key': {'shape': 'Name'},\n+                    'value': {'shape': self.target_shape_name}\n+                },\n+                'Structure': {\n+                    'type': 'structure',\n+                    'members': {\n+                        'Member': {'shape': self.target_shape_name}\n+                    }\n+                },\n+                'SampleOperationInputOutput': {\n+                    'type': 'structure',\n+                    'members': {\n+                        'Structure': {'shape': 'Structure'},\n+                        'Map': {'shape': 'Map'},\n+                        'List': {'shape': 'List'},\n+                    }\n+                },\n+                'Name': {\n+                    'type': 'string'\n+                }\n+            }\n+        }\n+\n+        # Create a more complicated model to test the ability to recurse\n+        # through a structure.\n+        self.nested_json_model = copy.deepcopy(self.json_model)\n+        shapes = self.nested_json_model['shapes']\n+        shapes['SampleOperationInputOutput']['members'] = {\n+            'Structure': {'shape': 'WrapperStructure'},\n+            'Map': {'shape': 'WrapperMap'},\n+            'List': {'shape': 'WrapperList'}\n+        }\n+        shapes['WrapperStructure'] = {\n+            'type': 'structure',\n+            'members': {'Structure': {'shape': 'Structure'}}\n+        }\n+        shapes['WrapperMap'] = {\n+            'type': 'map',\n+            'key': {'shape': 'Name'},\n+            'value': {'shape': 'Map'}\n+        }\n+        shapes['WrapperList'] = {\n+            'type': 'list',\n+            'member': {'shape': 'List'}\n+        }\n+\n+    def build_models(self):\n+        self.service_model = ServiceModel(self.json_model)\n+        self.operation_model = OperationModel(\n+            self.json_model['operations']['SampleOperation'],\n+            self.service_model\n+        )\n+\n+        self.nested_service_model = ServiceModel(self.nested_json_model)\n+        self.nested_operation_model = OperationModel(\n+            self.nested_json_model['operations']['SampleOperation'],\n+            self.nested_service_model\n+        )\n+\n+\n+class TestInputOutputTransformer(BaseTransformationTest):\n+    def setUp(self):\n+        super(TestInputOutputTransformer, self).setUp()\n+        self.transformation = lambda params: self.transformed_value\n+\n+    def test_transform_structure(self):",
        "comment_created_at": "2015-05-20T23:59:08+00:00",
        "comment_author": "jamesls",
        "comment_body": "Just wanted to capture this discussion here.  It would be great if we could add additional context into this test so that the user doesn't have to scroll around the file to see exactly what's being tested.\n\nI think the test can still be concise, but if could somehow show the linking between the shape name and triggering the transform, that would help with readability:\n\n```\nshape_to_transform = 'mytransform'\nshape = self.create_input_shape({'Structure': {\"TransformMe\": shape_to_transform, 'LeaveAlone': 'unmodifiedShape'}})\n\ntransformer.transform(shape, ...., target_shape=shape_to_transform)\n\nverify 'TransformMe' was transformed, verify 'LeaveAlone' wasn't.\n\n```\n\nSomething like that would make it clear what's going on.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "30652121",
    "pr_number": 106,
    "pr_file": "tests/unit/dynamodb/test_conditions.py",
    "created_at": "2015-05-19T21:55:41+00:00",
    "commented_code": "+# Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+from tests import unittest\n+\n+from boto3.exceptions import DynanmoDBOperationNotSupportedError\n+from boto3.exceptions import DynamoDBNeedsConditionError\n+from boto3.exceptions import DynamoDBNeedsKeyConditionError\n+from boto3.dynamodb.conditions import Attr, Key\n+from boto3.dynamodb.conditions import And, Or, Not, Equals, LessThan\n+from boto3.dynamodb.conditions import LessThanEquals, GreaterThan\n+from boto3.dynamodb.conditions import GreaterThanEquals, BeginsWith, Between\n+from boto3.dynamodb.conditions import NotEquals, In, AttributeExists\n+from boto3.dynamodb.conditions import AttributeNotExists, Contains, Size\n+from boto3.dynamodb.conditions import AttributeType\n+from boto3.dynamodb.conditions import ConditionExpressionBuilder\n+\n+\n+class TestK(unittest.TestCase):\n+    def setUp(self):\n+        self.attr = Key('mykey')\n+        self.attr2 = Key('myotherkey')\n+        self.value = 'foo'\n+        self.value2 = 'foo2'\n+\n+    def test_and(self):\n+        with self.assertRaisesRegexp(\n+                DynanmoDBOperationNotSupportedError, 'AND'):\n+            self.attr & self.attr2\n+\n+    def test_or(self):\n+        with self.assertRaisesRegexp(\n+                DynanmoDBOperationNotSupportedError, 'OR'):\n+            self.attr | self.attr2\n+\n+    def test_not(self):\n+        with self.assertRaisesRegexp(\n+                DynanmoDBOperationNotSupportedError, 'NOT'):\n+            ~self.attr\n+\n+    def test_eq(self):\n+        self.assertEqual(\n+            self.attr.eq(self.value), Equals(self.attr, self.value))\n+\n+    def test_lt(self):\n+        self.assertEqual(\n+            self.attr.lt(self.value), LessThan(self.attr, self.value))\n+\n+    def test_lte(self):\n+        self.assertEqual(\n+            self.attr.lte(self.value), LessThanEquals(self.attr, self.value))\n+\n+    def test_gt(self):\n+        self.assertEqual(\n+            self.attr.gt(self.value), GreaterThan(self.attr, self.value))\n+\n+    def test_gte(self):\n+        self.assertEqual(\n+            self.attr.gte(self.value),\n+            GreaterThanEquals(self.attr, self.value))\n+\n+    def test_begins_with(self):\n+        self.assertEqual(self.attr.begins_with(self.value),\n+                         BeginsWith(self.attr, self.value))\n+\n+    def test_between(self):\n+        self.assertEqual(self.attr.between(self.value, self.value2),\n+                         Between(self.attr, self.value, self.value2))\n+\n+\n+class TestA(TestK):\n+    def setUp(self):\n+        self.attr = Attr('mykey')\n+        self.attr2 = Attr('myotherkey')\n+        self.value = 'foo'\n+        self.value2 = 'foo2'\n+\n+    def test_ne(self):\n+        self.assertEqual(self.attr.ne(self.value),\n+                         NotEquals(self.attr, self.value))\n+\n+    def test_is_in(self):\n+        self.assertEqual(self.attr.is_in([self.value]),\n+                         In(self.attr, [self.value]))\n+\n+    def test_exists(self):\n+        self.assertEqual(self.attr.exists(), AttributeExists(self.attr))\n+\n+    def test_not_exists(self):\n+        self.assertEqual(self.attr.not_exists(), AttributeNotExists(self.attr))\n+\n+    def test_contains(self):\n+        self.assertEqual(self.attr.contains(self.value),\n+                         Contains(self.attr, self.value))\n+\n+    def test_size(self):\n+        self.assertEqual(self.attr.size(), Size(self.attr))\n+\n+    def test_attribute_type(self):\n+        self.assertEqual(self.attr.attribute_type(self.value),\n+                         AttributeType(self.attr, self.value))\n+\n+\n+class TestConditions(unittest.TestCase):\n+    def setUp(self):\n+        self.value = Attr('mykey')\n+        self.value2 = 'foo'\n+\n+    def assert_expression_dict(self, condition, exp_format,\n+                               exp_operator, values):\n+        expression_dict = condition.get_expression()\n+        self.assertEqual(expression_dict['format'], exp_format)",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "30652121",
        "repo_full_name": "boto/boto3",
        "pr_number": 106,
        "pr_file": "tests/unit/dynamodb/test_conditions.py",
        "discussion_id": "30652121",
        "commented_code": "@@ -0,0 +1,453 @@\n+# Copyright 2015 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the \"license\" file accompanying this file. This file is\n+# distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+from tests import unittest\n+\n+from boto3.exceptions import DynanmoDBOperationNotSupportedError\n+from boto3.exceptions import DynamoDBNeedsConditionError\n+from boto3.exceptions import DynamoDBNeedsKeyConditionError\n+from boto3.dynamodb.conditions import Attr, Key\n+from boto3.dynamodb.conditions import And, Or, Not, Equals, LessThan\n+from boto3.dynamodb.conditions import LessThanEquals, GreaterThan\n+from boto3.dynamodb.conditions import GreaterThanEquals, BeginsWith, Between\n+from boto3.dynamodb.conditions import NotEquals, In, AttributeExists\n+from boto3.dynamodb.conditions import AttributeNotExists, Contains, Size\n+from boto3.dynamodb.conditions import AttributeType\n+from boto3.dynamodb.conditions import ConditionExpressionBuilder\n+\n+\n+class TestK(unittest.TestCase):\n+    def setUp(self):\n+        self.attr = Key('mykey')\n+        self.attr2 = Key('myotherkey')\n+        self.value = 'foo'\n+        self.value2 = 'foo2'\n+\n+    def test_and(self):\n+        with self.assertRaisesRegexp(\n+                DynanmoDBOperationNotSupportedError, 'AND'):\n+            self.attr & self.attr2\n+\n+    def test_or(self):\n+        with self.assertRaisesRegexp(\n+                DynanmoDBOperationNotSupportedError, 'OR'):\n+            self.attr | self.attr2\n+\n+    def test_not(self):\n+        with self.assertRaisesRegexp(\n+                DynanmoDBOperationNotSupportedError, 'NOT'):\n+            ~self.attr\n+\n+    def test_eq(self):\n+        self.assertEqual(\n+            self.attr.eq(self.value), Equals(self.attr, self.value))\n+\n+    def test_lt(self):\n+        self.assertEqual(\n+            self.attr.lt(self.value), LessThan(self.attr, self.value))\n+\n+    def test_lte(self):\n+        self.assertEqual(\n+            self.attr.lte(self.value), LessThanEquals(self.attr, self.value))\n+\n+    def test_gt(self):\n+        self.assertEqual(\n+            self.attr.gt(self.value), GreaterThan(self.attr, self.value))\n+\n+    def test_gte(self):\n+        self.assertEqual(\n+            self.attr.gte(self.value),\n+            GreaterThanEquals(self.attr, self.value))\n+\n+    def test_begins_with(self):\n+        self.assertEqual(self.attr.begins_with(self.value),\n+                         BeginsWith(self.attr, self.value))\n+\n+    def test_between(self):\n+        self.assertEqual(self.attr.between(self.value, self.value2),\n+                         Between(self.attr, self.value, self.value2))\n+\n+\n+class TestA(TestK):\n+    def setUp(self):\n+        self.attr = Attr('mykey')\n+        self.attr2 = Attr('myotherkey')\n+        self.value = 'foo'\n+        self.value2 = 'foo2'\n+\n+    def test_ne(self):\n+        self.assertEqual(self.attr.ne(self.value),\n+                         NotEquals(self.attr, self.value))\n+\n+    def test_is_in(self):\n+        self.assertEqual(self.attr.is_in([self.value]),\n+                         In(self.attr, [self.value]))\n+\n+    def test_exists(self):\n+        self.assertEqual(self.attr.exists(), AttributeExists(self.attr))\n+\n+    def test_not_exists(self):\n+        self.assertEqual(self.attr.not_exists(), AttributeNotExists(self.attr))\n+\n+    def test_contains(self):\n+        self.assertEqual(self.attr.contains(self.value),\n+                         Contains(self.attr, self.value))\n+\n+    def test_size(self):\n+        self.assertEqual(self.attr.size(), Size(self.attr))\n+\n+    def test_attribute_type(self):\n+        self.assertEqual(self.attr.attribute_type(self.value),\n+                         AttributeType(self.attr, self.value))\n+\n+\n+class TestConditions(unittest.TestCase):\n+    def setUp(self):\n+        self.value = Attr('mykey')\n+        self.value2 = 'foo'\n+\n+    def assert_expression_dict(self, condition, exp_format,\n+                               exp_operator, values):\n+        expression_dict = condition.get_expression()\n+        self.assertEqual(expression_dict['format'], exp_format)",
        "comment_created_at": "2015-05-19T21:55:41+00:00",
        "comment_author": "jamesls",
        "comment_body": "can we just used assertDictEqual?  It should give decent error messages on assertion failures.  It also a little confusing to me at first because this is caleed assert_expression_dict but we never actually pass it a dict to compare against.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "27618938",
    "pr_number": 80,
    "pr_file": "tests/integration/test_s3.py",
    "created_at": "2015-04-01T22:37:01+00:00",
    "commented_code": "contents = bucket.Object('mp-test.txt').get()['Body'].read()\n         self.assertEqual(contents, b'hello, world!')\n+\n+\n+class TestS3Transfers(unittest.TestCase):\n+    \"\"\"Tests for the high level boto3.s3.transfer module.\"\"\"\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.region = 'us-west-2'\n+        cls.session = boto3.session.Session(region_name=cls.region)\n+        cls.client = cls.session.client('s3', cls.region)\n+        cls.bucket_name = 'boto3-integ-transfer-%s-%s' % (\n+            int(time.time()), random.randint(1, 100))\n+        cls.client.create_bucket(\n+            Bucket=cls.bucket_name,\n+            CreateBucketConfiguration={'LocationConstraint': cls.region})\n+\n+    def setUp(self):\n+        self.files = FileCreator()\n+\n+    def tearDown(self):\n+        self.files.remove_all()\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.client.delete_bucket(Bucket=cls.bucket_name)\n+\n+    def delete_object(self, key):\n+        self.client.delete_object(\n+            Bucket=self.bucket_name,\n+            Key=key)\n+\n+    def object_exists(self, key):\n+        self.client.head_object(Bucket=self.bucket_name,\n+                                Key=key)\n+        return True\n+\n+    def create_s3_transfer(self):\n+        return boto3.s3.transfer.S3Transfer(self.client)\n+\n+    def test_upload_below_threshold(self):\n+        transfer = self.create_s3_transfer()\n+        filename = self.files.create_file_with_size(\n+            'foo.txt', filesize=1024 * 1024)\n+        transfer.upload_file(filename, self.bucket_name,\n+                             'foo.txt')\n+        self.addCleanup(self.delete_object, 'foo.txt')\n+\n+        self.assertTrue(self.object_exists('foo.txt'))",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "27618938",
        "repo_full_name": "boto/boto3",
        "pr_number": 80,
        "pr_file": "tests/integration/test_s3.py",
        "discussion_id": "27618938",
        "commented_code": "@@ -121,3 +218,146 @@ def test_s3_multipart(self):\n \n         contents = bucket.Object('mp-test.txt').get()['Body'].read()\n         self.assertEqual(contents, b'hello, world!')\n+\n+\n+class TestS3Transfers(unittest.TestCase):\n+    \"\"\"Tests for the high level boto3.s3.transfer module.\"\"\"\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        cls.region = 'us-west-2'\n+        cls.session = boto3.session.Session(region_name=cls.region)\n+        cls.client = cls.session.client('s3', cls.region)\n+        cls.bucket_name = 'boto3-integ-transfer-%s-%s' % (\n+            int(time.time()), random.randint(1, 100))\n+        cls.client.create_bucket(\n+            Bucket=cls.bucket_name,\n+            CreateBucketConfiguration={'LocationConstraint': cls.region})\n+\n+    def setUp(self):\n+        self.files = FileCreator()\n+\n+    def tearDown(self):\n+        self.files.remove_all()\n+\n+    @classmethod\n+    def tearDownClass(cls):\n+        cls.client.delete_bucket(Bucket=cls.bucket_name)\n+\n+    def delete_object(self, key):\n+        self.client.delete_object(\n+            Bucket=self.bucket_name,\n+            Key=key)\n+\n+    def object_exists(self, key):\n+        self.client.head_object(Bucket=self.bucket_name,\n+                                Key=key)\n+        return True\n+\n+    def create_s3_transfer(self):\n+        return boto3.s3.transfer.S3Transfer(self.client)\n+\n+    def test_upload_below_threshold(self):\n+        transfer = self.create_s3_transfer()\n+        filename = self.files.create_file_with_size(\n+            'foo.txt', filesize=1024 * 1024)\n+        transfer.upload_file(filename, self.bucket_name,\n+                             'foo.txt')\n+        self.addCleanup(self.delete_object, 'foo.txt')\n+\n+        self.assertTrue(self.object_exists('foo.txt'))",
        "comment_created_at": "2015-04-01T22:37:01+00:00",
        "comment_author": "danielgtaylor",
        "comment_body": "Should we also be asserting that the file size was below the configured threshold? It seems like we're making assumptions in the tests about defaults in the code that may change over time.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "24449155",
    "pr_number": 62,
    "pr_file": "tests/integration/test_s3.py",
    "created_at": "2015-02-10T20:50:04+00:00",
    "commented_code": "self.assertEqual(obj.bucket_name, self.bucket_name)\n         self.assertEqual(obj.key, 'test.txt')\n+\n+    def test_s3_multipart(self):\n+        # Create the bucket\n+        bucket = self.create_bucket_resource(self.bucket_name)\n+        bucket.wait_until_exists()\n+\n+        # Create the multipart upload\n+        mpu = bucket.Object('mp-test.txt').initiate_multipart_upload()\n+        self.addCleanup(mpu.abort)\n+\n+        # Create and upload a part\n+        part = mpu.Part(1)\n+        response = part.upload(b'hello, world!')\n+\n+        # Complete the upload, which requires info on all of the parts\n+        part_info = {\n+            'Parts': [\n+                {\n+                    'PartNumber': 1,\n+                    'ETag': response['ETag']\n+                }\n+            ]\n+        }\n+\n+        mpu.complete(MultipartUpload=part_info)\n+        self.addCleanup(bucket.Object('mp-test.txt').delete)",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "24449155",
        "repo_full_name": "boto/boto3",
        "pr_number": 62,
        "pr_file": "tests/integration/test_s3.py",
        "discussion_id": "24449155",
        "commented_code": "@@ -92,3 +92,29 @@ def test_can_create_object_directly(self):\n \n         self.assertEqual(obj.bucket_name, self.bucket_name)\n         self.assertEqual(obj.key, 'test.txt')\n+\n+    def test_s3_multipart(self):\n+        # Create the bucket\n+        bucket = self.create_bucket_resource(self.bucket_name)\n+        bucket.wait_until_exists()\n+\n+        # Create the multipart upload\n+        mpu = bucket.Object('mp-test.txt').initiate_multipart_upload()\n+        self.addCleanup(mpu.abort)\n+\n+        # Create and upload a part\n+        part = mpu.Part(1)\n+        response = part.upload(b'hello, world!')\n+\n+        # Complete the upload, which requires info on all of the parts\n+        part_info = {\n+            'Parts': [\n+                {\n+                    'PartNumber': 1,\n+                    'ETag': response['ETag']\n+                }\n+            ]\n+        }\n+\n+        mpu.complete(MultipartUpload=part_info)\n+        self.addCleanup(bucket.Object('mp-test.txt').delete)",
        "comment_created_at": "2015-02-10T20:50:04+00:00",
        "comment_author": "jamesls",
        "comment_body": "This test doesn't assert anything.  What about downloading the object and verifying its contents are `b'hello, world!'`?\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "23870318",
    "pr_number": 51,
    "pr_file": "tests/unit/resources/test_factory.py",
    "created_at": "2015-01-30T20:32:55+00:00",
    "commented_code": "}\n         }\n \n-        resource = self.load('test', 'test', {}, defs, None)()\n+        resource = self.load('test', 'test', model, defs, None)()\n         q = resource.Queue(url='test')\n \n         self.assertIsInstance(q, ServiceResource,\n             'Dangling resource created with kwargs is not a ServiceResource')\n \n     def test_dangling_resource_shares_client(self):\n+        model = {",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "23870318",
        "repo_full_name": "boto/boto3",
        "pr_number": 51,
        "pr_file": "tests/unit/resources/test_factory.py",
        "discussion_id": "23870318",
        "commented_code": "@@ -188,13 +233,25 @@ def test_dangling_resource_create_with_kwarg(self):\n             }\n         }\n \n-        resource = self.load('test', 'test', {}, defs, None)()\n+        resource = self.load('test', 'test', model, defs, None)()\n         q = resource.Queue(url='test')\n \n         self.assertIsInstance(q, ServiceResource,\n             'Dangling resource created with kwargs is not a ServiceResource')\n \n     def test_dangling_resource_shares_client(self):\n+        model = {",
        "comment_created_at": "2015-01-30T20:32:55+00:00",
        "comment_author": "kyleknap",
        "comment_body": "If you are going to use the same model a bunch of times in the test. It may be easier to just add it in the the `setUp()` as a property of the test class and then override it in the test method if needed.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "19820424",
    "pr_number": 12,
    "pr_file": "tests/unit/test_session.py",
    "created_at": "2014-11-04T17:40:26+00:00",
    "commented_code": "def test_create_client(self):\n         bc_session = self.bc_session_cls.return_value\n \n-        session = Session()\n-        client = session.client('sqs')\n+        session = Session(region_name='us-east-1')",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "19820424",
        "repo_full_name": "boto/boto3",
        "pr_number": 12,
        "pr_file": "tests/unit/test_session.py",
        "discussion_id": "19820424",
        "commented_code": "@@ -63,11 +63,13 @@ def test_get_available_resources(self):\n     def test_create_client(self):\n         bc_session = self.bc_session_cls.return_value\n \n-        session = Session()\n-        client = session.client('sqs')\n+        session = Session(region_name='us-east-1')",
        "comment_created_at": "2014-11-04T17:40:26+00:00",
        "comment_author": "kyleknap",
        "comment_body": "I would just make it a separate test for testing if region gets overridden. I feel that warrants a separate test since this test just makes sure that the botocore session is used to make the client. \n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "18934832",
    "pr_number": 4,
    "pr_file": "tests/unit/resources/test_collection.py",
    "created_at": "2014-10-16T01:56:48+00:00",
    "commented_code": "+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the 'License'). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the 'license' file accompanying this file. This file is\n+# distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+from boto3.resources.collection import CollectionManager\n+from boto3.resources.factory import ResourceFactory\n+from tests import BaseTestCase, mock\n+\n+\n+class TestResourceCollection(BaseTestCase):",
    "repo_full_name": "boto/boto3",
    "discussion_comments": [
      {
        "comment_id": "18934832",
        "repo_full_name": "boto/boto3",
        "pr_number": 4,
        "pr_file": "tests/unit/resources/test_collection.py",
        "discussion_id": "18934832",
        "commented_code": "@@ -0,0 +1,179 @@\n+# Copyright 2014 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the 'License'). You\n+# may not use this file except in compliance with the License. A copy of\n+# the License is located at\n+#\n+# http://aws.amazon.com/apache2.0/\n+#\n+# or in the 'license' file accompanying this file. This file is\n+# distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF\n+# ANY KIND, either express or implied. See the License for the specific\n+# language governing permissions and limitations under the License.\n+\n+from boto3.resources.collection import CollectionManager\n+from boto3.resources.factory import ResourceFactory\n+from tests import BaseTestCase, mock\n+\n+\n+class TestResourceCollection(BaseTestCase):",
        "comment_created_at": "2014-10-16T01:56:48+00:00",
        "comment_author": "jamesls",
        "comment_body": "fwiw, I find these tests a bit hard to follow.\n\nI much preferred the other style of tests where you'd setup a resource def in the unit test so you could clearly see what the expectations were.  For example, in test_iteration_manager, it's not clear from just reading the test why `list(collection)` should be raising a `TypeError`.  Or in test_filters_non_paginated, it's not made clear (without looking at the setUp), that we're calling client.get_frobs because request.oepration == GetFrobs.\n",
        "pr_file_module": null
      }
    ]
  }
]