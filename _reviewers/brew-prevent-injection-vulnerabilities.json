[
  {
    "discussion_id": "2123436250",
    "pr_number": 20041,
    "pr_file": "Library/Homebrew/mcp_server.rb",
    "created_at": "2025-06-03T10:48:03+00:00",
    "commented_code": "+# typed: strict\n+# frozen_string_literal: true\n+\n+# This is a standalone Ruby script as MCP servers need a faster startup time\n+# than a normal Homebrew Ruby command allows.\n+require_relative \"standalone\"\n+require \"json\"\n+require \"fileutils\"\n+\n+module Homebrew\n+  # Provides a Model Context Protocol (MCP) server for Homebrew.\n+  # See https://modelcontextprotocol.io/introduction for more information.\n+  #\n+  # https://modelcontextprotocol.io/docs/tools/inspector is useful for testing.\n+  class McpServer\n+    HOMEBREW_BREW_FILE = T.let(ENV.fetch(\"HOMEBREW_BREW_FILE\").freeze, String)\n+    HOMEBREW_VERSION = T.let(ENV.fetch(\"HOMEBREW_VERSION\").freeze, String)\n+    JSON_RPC_VERSION = T.let(\"2.0\", String)\n+    MCP_PROTOCOL_VERSION = T.let(\"2025-03-26\", String)\n+    ERROR_CODE = T.let(-32601, Integer)\n+\n+    SERVER_INFO = T.let({\n+      name:    \"brew-mcp-server\",\n+      version: HOMEBREW_VERSION,\n+    }.freeze, T::Hash[Symbol, String])\n+\n+    FORMULA_OR_CASK_PROPERTIES = T.let({\n+      formula_or_cask: {\n+        type:        \"string\",\n+        description: \"Formula or cask name\",\n+      },\n+    }.freeze, T::Hash[Symbol, T.anything])\n+\n+    # NOTE: Cursor (as of June 2025) will only query/use a maximum of 40 tools.\n+    TOOLS = T.let({\n+      search:    {\n+        name:        \"search\",\n+        description: \"Perform a substring search of cask tokens and formula names for <text>. \" \\\n+                     \"If <text> is flanked by slashes, it is interpreted as a regular expression.\",\n+        command:     \"brew search\",\n+        inputSchema: {\n+          type:       \"object\",\n+          properties: {\n+            text_or_regex: {\n+              type:        \"string\",\n+              description: \"Text or regex to search for\",\n+            },\n+          },\n+        },\n+        required:    [\"text_or_regex\"],\n+      },\n+      info:      {\n+        name:        \"info\",\n+        description: \"Display brief statistics for your Homebrew installation. \" \\\n+                     \"If a <formula> or <cask> is provided, show summary of information about it.\",\n+        command:     \"brew info\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+      },\n+      install:   {\n+        name:        \"install\",\n+        description: \"Install a <formula> or <cask>.\",\n+        command:     \"brew install\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+        required:    [\"formula_or_cask\"],\n+      },\n+      update:    {\n+        name:        \"update\",\n+        description: \"Fetch the newest version of Homebrew and all formulae from GitHub using `git` and \" \\\n+                     \"perform any necessary migrations.\",\n+        command:     \"brew update\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      upgrade:   {\n+        name:        \"upgrade\",\n+        description: \"Upgrade outdated casks and outdated, unpinned formulae using the same options they were \" \\\n+                     \"originally installed with, plus any appended brew formula options. If <cask> or <formula> \" \\\n+                     \"are specified, upgrade only the given <cask> or <formula> kegs (unless they are pinned).\",\n+        command:     \"brew upgrade\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+      },\n+      uninstall: {\n+        name:        \"uninstall\",\n+        description: \"Uninstall a <formula> or <cask>.\",\n+        command:     \"brew uninstall\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+        required:    [\"formula_or_cask\"],\n+      },\n+      list:      {\n+        name:        \"list\",\n+        description: \"List all installed formulae and casks. \" \\\n+                     \"If <formula> is provided, summarise the paths within its current keg. \" \\\n+                     \"If <cask> is provided, list its artifacts.\",\n+        command:     \"brew list\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+      },\n+      config:    {\n+        name:        \"config\",\n+        description: \"Show Homebrew and system configuration info useful for debugging. \" \\\n+                     \"If you file a bug report, you will be required to provide this information.\",\n+        command:     \"brew config\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      doctor:    {\n+        name:        \"doctor\",\n+        description: \"Check your system for potential problems. Will exit with a non-zero status \" \\\n+                     \"if any potential problems are found. \" \\\n+                     \"Please note that these warnings are just used to help the Homebrew maintainers \" \\\n+                     \"with debugging if you file an issue. If everything you use Homebrew for \" \\\n+                     \"is working fine: please don't worry or file an issue; just ignore this.\",\n+        command:     \"brew doctor\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      commands:  {\n+        name:        \"commands\",\n+        description: \"Show lists of built-in and external commands.\",\n+        command:     \"brew commands\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      help:      {\n+        name:        \"help\",\n+        description: \"Outputs the usage instructions for `brew` <command>.\",\n+        command:     \"brew help\",\n+        inputSchema: {\n+          type:       \"object\",\n+          properties: {\n+            command: {\n+              type:        \"string\",\n+              description: \"Command to get help for\",\n+            },\n+          },\n+        },\n+      },\n+    }.freeze, T::Hash[Symbol, T::Hash[Symbol, T.anything]])\n+\n+    sig { params(stdin: T.any(IO, StringIO), stdout: T.any(IO, StringIO), stderr: T.any(IO, StringIO)).void }\n+    def initialize(stdin: $stdin, stdout: $stdout, stderr: $stderr)\n+      debug_switch = ARGV.include?(\"--debug\") || ARGV.include?(\"-d\")\n+      @debug_logging = T.let(debug_switch, T::Boolean)\n+      @stdin = T.let(stdin, T.any(IO, StringIO))\n+      @stdout = T.let(stdout, T.any(IO, StringIO))\n+      @stderr = T.let(stderr, T.any(IO, StringIO))\n+    end\n+\n+    sig { returns(T::Boolean) }\n+    def debug_logging? = @debug_logging\n+\n+    sig { void }\n+    def run\n+      @stderr.puts \"==> Started Homebrew MCP server...\"\n+\n+      loop do\n+        input = @stdin.gets\n+        next if input.nil? || input.strip.empty?\n+\n+        request = JSON.parse(input)\n+        debug(\"Request: #{JSON.pretty_generate(request)}\")\n+\n+        response = handle_request(request)\n+        if response.nil?\n+          debug(\"Response: nil\")\n+          next\n+        end\n+\n+        debug(\"Response: #{JSON.pretty_generate(response)}\")\n+        output = JSON.dump(response).strip\n+        @stdout.puts(output)\n+        @stdout.flush\n+      end\n+    rescue Interrupt\n+      exit 0\n+    rescue => e\n+      log(\"Error: #{e.message}\")\n+      exit 1\n+    end\n+\n+    sig { params(text: String).void }\n+    def debug(text)\n+      return unless debug_logging?\n+\n+      log(text)\n+    end\n+\n+    sig { params(text: String).void }\n+    def log(text)\n+      @stderr.puts(text)\n+      @stderr.flush\n+    end\n+\n+    sig { params(request: T::Hash[String, T.untyped]).returns(T.nilable(T::Hash[Symbol, T.anything])) }\n+    def handle_request(request)\n+      id = request[\"id\"]\n+      return if id.nil?\n+\n+      case request[\"method\"]\n+      when \"initialize\"\n+        respond_result(id, {\n+          protocolVersion: MCP_PROTOCOL_VERSION,\n+          capabilities:    {\n+            tools:     { listChanged: false },\n+            prompts:   {},\n+            resources: {},\n+            logging:   {},\n+            roots:     {},\n+          },\n+          serverInfo:      SERVER_INFO,\n+        })\n+      when \"resources/list\"\n+        respond_result(id, { resources: [] })\n+      when \"resources/templates/list\"\n+        respond_result(id, { resourceTemplates: [] })\n+      when \"prompts/list\"\n+        respond_result(id, { prompts: [] })\n+      when \"ping\"\n+        respond_result(id)\n+      when \"get_server_info\"\n+        respond_result(id, SERVER_INFO)\n+      when \"logging/setLevel\"\n+        @debug_logging = request[\"params\"][\"level\"] == \"debug\"\n+        respond_result(id)\n+      when \"notifications/initialized\", \"notifications/cancelled\"\n+        respond_result\n+      when \"tools/list\"\n+        respond_result(id, { tools: TOOLS.values })\n+      when \"tools/call\"\n+        if (tool = TOOLS.fetch(request[\"params\"][\"name\"].to_sym, nil))\n+          arguments = request[\"params\"][\"arguments\"]\n+          argument = arguments.fetch(\"formula_or_cask\", \"\")\n+          argument = arguments.fetch(\"text_or_regex\", \"\") if argument.strip.empty?\n+          argument = arguments.fetch(\"command\", \"\") if argument.strip.empty?\n+          brew_command = T.cast(tool.fetch(:command), String)\n+                          .delete_prefix(\"brew \")\n+          full_command = [HOMEBREW_BREW_FILE, brew_command, argument].compact",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "2123436250",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 20041,
        "pr_file": "Library/Homebrew/mcp_server.rb",
        "discussion_id": "2123436250",
        "commented_code": "@@ -0,0 +1,259 @@\n+# typed: strict\n+# frozen_string_literal: true\n+\n+# This is a standalone Ruby script as MCP servers need a faster startup time\n+# than a normal Homebrew Ruby command allows.\n+require_relative \"standalone\"\n+require \"json\"\n+require \"fileutils\"\n+\n+module Homebrew\n+  # Provides a Model Context Protocol (MCP) server for Homebrew.\n+  # See https://modelcontextprotocol.io/introduction for more information.\n+  #\n+  # https://modelcontextprotocol.io/docs/tools/inspector is useful for testing.\n+  class McpServer\n+    HOMEBREW_BREW_FILE = T.let(ENV.fetch(\"HOMEBREW_BREW_FILE\").freeze, String)\n+    HOMEBREW_VERSION = T.let(ENV.fetch(\"HOMEBREW_VERSION\").freeze, String)\n+    JSON_RPC_VERSION = T.let(\"2.0\", String)\n+    MCP_PROTOCOL_VERSION = T.let(\"2025-03-26\", String)\n+    ERROR_CODE = T.let(-32601, Integer)\n+\n+    SERVER_INFO = T.let({\n+      name:    \"brew-mcp-server\",\n+      version: HOMEBREW_VERSION,\n+    }.freeze, T::Hash[Symbol, String])\n+\n+    FORMULA_OR_CASK_PROPERTIES = T.let({\n+      formula_or_cask: {\n+        type:        \"string\",\n+        description: \"Formula or cask name\",\n+      },\n+    }.freeze, T::Hash[Symbol, T.anything])\n+\n+    # NOTE: Cursor (as of June 2025) will only query/use a maximum of 40 tools.\n+    TOOLS = T.let({\n+      search:    {\n+        name:        \"search\",\n+        description: \"Perform a substring search of cask tokens and formula names for <text>. \" \\\n+                     \"If <text> is flanked by slashes, it is interpreted as a regular expression.\",\n+        command:     \"brew search\",\n+        inputSchema: {\n+          type:       \"object\",\n+          properties: {\n+            text_or_regex: {\n+              type:        \"string\",\n+              description: \"Text or regex to search for\",\n+            },\n+          },\n+        },\n+        required:    [\"text_or_regex\"],\n+      },\n+      info:      {\n+        name:        \"info\",\n+        description: \"Display brief statistics for your Homebrew installation. \" \\\n+                     \"If a <formula> or <cask> is provided, show summary of information about it.\",\n+        command:     \"brew info\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+      },\n+      install:   {\n+        name:        \"install\",\n+        description: \"Install a <formula> or <cask>.\",\n+        command:     \"brew install\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+        required:    [\"formula_or_cask\"],\n+      },\n+      update:    {\n+        name:        \"update\",\n+        description: \"Fetch the newest version of Homebrew and all formulae from GitHub using `git` and \" \\\n+                     \"perform any necessary migrations.\",\n+        command:     \"brew update\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      upgrade:   {\n+        name:        \"upgrade\",\n+        description: \"Upgrade outdated casks and outdated, unpinned formulae using the same options they were \" \\\n+                     \"originally installed with, plus any appended brew formula options. If <cask> or <formula> \" \\\n+                     \"are specified, upgrade only the given <cask> or <formula> kegs (unless they are pinned).\",\n+        command:     \"brew upgrade\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+      },\n+      uninstall: {\n+        name:        \"uninstall\",\n+        description: \"Uninstall a <formula> or <cask>.\",\n+        command:     \"brew uninstall\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+        required:    [\"formula_or_cask\"],\n+      },\n+      list:      {\n+        name:        \"list\",\n+        description: \"List all installed formulae and casks. \" \\\n+                     \"If <formula> is provided, summarise the paths within its current keg. \" \\\n+                     \"If <cask> is provided, list its artifacts.\",\n+        command:     \"brew list\",\n+        inputSchema: { type: \"object\", properties: FORMULA_OR_CASK_PROPERTIES },\n+      },\n+      config:    {\n+        name:        \"config\",\n+        description: \"Show Homebrew and system configuration info useful for debugging. \" \\\n+                     \"If you file a bug report, you will be required to provide this information.\",\n+        command:     \"brew config\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      doctor:    {\n+        name:        \"doctor\",\n+        description: \"Check your system for potential problems. Will exit with a non-zero status \" \\\n+                     \"if any potential problems are found. \" \\\n+                     \"Please note that these warnings are just used to help the Homebrew maintainers \" \\\n+                     \"with debugging if you file an issue. If everything you use Homebrew for \" \\\n+                     \"is working fine: please don't worry or file an issue; just ignore this.\",\n+        command:     \"brew doctor\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      commands:  {\n+        name:        \"commands\",\n+        description: \"Show lists of built-in and external commands.\",\n+        command:     \"brew commands\",\n+        inputSchema: { type: \"object\", properties: {} },\n+      },\n+      help:      {\n+        name:        \"help\",\n+        description: \"Outputs the usage instructions for `brew` <command>.\",\n+        command:     \"brew help\",\n+        inputSchema: {\n+          type:       \"object\",\n+          properties: {\n+            command: {\n+              type:        \"string\",\n+              description: \"Command to get help for\",\n+            },\n+          },\n+        },\n+      },\n+    }.freeze, T::Hash[Symbol, T::Hash[Symbol, T.anything]])\n+\n+    sig { params(stdin: T.any(IO, StringIO), stdout: T.any(IO, StringIO), stderr: T.any(IO, StringIO)).void }\n+    def initialize(stdin: $stdin, stdout: $stdout, stderr: $stderr)\n+      debug_switch = ARGV.include?(\"--debug\") || ARGV.include?(\"-d\")\n+      @debug_logging = T.let(debug_switch, T::Boolean)\n+      @stdin = T.let(stdin, T.any(IO, StringIO))\n+      @stdout = T.let(stdout, T.any(IO, StringIO))\n+      @stderr = T.let(stderr, T.any(IO, StringIO))\n+    end\n+\n+    sig { returns(T::Boolean) }\n+    def debug_logging? = @debug_logging\n+\n+    sig { void }\n+    def run\n+      @stderr.puts \"==> Started Homebrew MCP server...\"\n+\n+      loop do\n+        input = @stdin.gets\n+        next if input.nil? || input.strip.empty?\n+\n+        request = JSON.parse(input)\n+        debug(\"Request: #{JSON.pretty_generate(request)}\")\n+\n+        response = handle_request(request)\n+        if response.nil?\n+          debug(\"Response: nil\")\n+          next\n+        end\n+\n+        debug(\"Response: #{JSON.pretty_generate(response)}\")\n+        output = JSON.dump(response).strip\n+        @stdout.puts(output)\n+        @stdout.flush\n+      end\n+    rescue Interrupt\n+      exit 0\n+    rescue => e\n+      log(\"Error: #{e.message}\")\n+      exit 1\n+    end\n+\n+    sig { params(text: String).void }\n+    def debug(text)\n+      return unless debug_logging?\n+\n+      log(text)\n+    end\n+\n+    sig { params(text: String).void }\n+    def log(text)\n+      @stderr.puts(text)\n+      @stderr.flush\n+    end\n+\n+    sig { params(request: T::Hash[String, T.untyped]).returns(T.nilable(T::Hash[Symbol, T.anything])) }\n+    def handle_request(request)\n+      id = request[\"id\"]\n+      return if id.nil?\n+\n+      case request[\"method\"]\n+      when \"initialize\"\n+        respond_result(id, {\n+          protocolVersion: MCP_PROTOCOL_VERSION,\n+          capabilities:    {\n+            tools:     { listChanged: false },\n+            prompts:   {},\n+            resources: {},\n+            logging:   {},\n+            roots:     {},\n+          },\n+          serverInfo:      SERVER_INFO,\n+        })\n+      when \"resources/list\"\n+        respond_result(id, { resources: [] })\n+      when \"resources/templates/list\"\n+        respond_result(id, { resourceTemplates: [] })\n+      when \"prompts/list\"\n+        respond_result(id, { prompts: [] })\n+      when \"ping\"\n+        respond_result(id)\n+      when \"get_server_info\"\n+        respond_result(id, SERVER_INFO)\n+      when \"logging/setLevel\"\n+        @debug_logging = request[\"params\"][\"level\"] == \"debug\"\n+        respond_result(id)\n+      when \"notifications/initialized\", \"notifications/cancelled\"\n+        respond_result\n+      when \"tools/list\"\n+        respond_result(id, { tools: TOOLS.values })\n+      when \"tools/call\"\n+        if (tool = TOOLS.fetch(request[\"params\"][\"name\"].to_sym, nil))\n+          arguments = request[\"params\"][\"arguments\"]\n+          argument = arguments.fetch(\"formula_or_cask\", \"\")\n+          argument = arguments.fetch(\"text_or_regex\", \"\") if argument.strip.empty?\n+          argument = arguments.fetch(\"command\", \"\") if argument.strip.empty?\n+          brew_command = T.cast(tool.fetch(:command), String)\n+                          .delete_prefix(\"brew \")\n+          full_command = [HOMEBREW_BREW_FILE, brew_command, argument].compact",
        "comment_created_at": "2025-06-03T10:48:03+00:00",
        "comment_author": "Copilot",
        "comment_body": "Interpolating `full_command` directly into backticks can allow shell injection if any argument contains malicious characters. Consider escaping each argument with `Shellwords.escape` or using a safe API to invoke external processes.\n```suggestion\n          full_command = [HOMEBREW_BREW_FILE, brew_command, argument].compact\n                                                                     .map { |arg| Shellwords.escape(arg) }\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2015554906",
    "pr_number": 19621,
    "pr_file": "Library/Homebrew/formula_creator.rb",
    "created_at": "2025-03-27T03:46:41+00:00",
    "commented_code": "r = Resource.new\n           r.url(@url)\n           r.owner = self\n-          @sha256 = r.fetch.sha256 if r.download_strategy == CurlDownloadStrategy\n+          filepath = r.fetch\n+          if IO.read(filepath, 100).strip.start_with?(\"<!DOCTYPE html>\")",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "2015554906",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19621,
        "pr_file": "Library/Homebrew/formula_creator.rb",
        "discussion_id": "2015554906",
        "commented_code": "@@ -82,7 +82,11 @@\n           r = Resource.new\n           r.url(@url)\n           r.owner = self\n-          @sha256 = r.fetch.sha256 if r.download_strategy == CurlDownloadStrategy\n+          filepath = r.fetch\n+          if IO.read(filepath, 100).strip.start_with?(\"<!DOCTYPE html>\")",
        "comment_created_at": "2025-03-27T03:46:41+00:00",
        "comment_author": "github-advanced-security[bot]",
        "comment_body": "## Use of `Kernel.open` or `IO.read` or similar sinks with a non-constant value\n\nCall to IO.read with a non-constant value. Consider replacing it with File.read.\n\n[Show more details](https://github.com/Homebrew/brew/security/code-scanning/68)",
        "pr_file_module": null
      },
      {
        "comment_id": "2015600007",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19621,
        "pr_file": "Library/Homebrew/formula_creator.rb",
        "discussion_id": "2015554906",
        "commented_code": "@@ -82,7 +82,11 @@\n           r = Resource.new\n           r.url(@url)\n           r.owner = self\n-          @sha256 = r.fetch.sha256 if r.download_strategy == CurlDownloadStrategy\n+          filepath = r.fetch\n+          if IO.read(filepath, 100).strip.start_with?(\"<!DOCTYPE html>\")",
        "comment_created_at": "2025-03-27T04:11:05+00:00",
        "comment_author": "abitrolly",
        "comment_body": "https://codeql.github.com/codeql-query-help/ruby/rb-non-constant-kernel-open/\r\n\r\n> If Kernel.open is given a file name that starts with a | character, it will execute the remaining string as a shell command.\r\n\r\nI thought `Kernel` should be more low level interface.",
        "pr_file_module": null
      },
      {
        "comment_id": "2015618708",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19621,
        "pr_file": "Library/Homebrew/formula_creator.rb",
        "discussion_id": "2015554906",
        "commented_code": "@@ -82,7 +82,11 @@\n           r = Resource.new\n           r.url(@url)\n           r.owner = self\n-          @sha256 = r.fetch.sha256 if r.download_strategy == CurlDownloadStrategy\n+          filepath = r.fetch\n+          if IO.read(filepath, 100).strip.start_with?(\"<!DOCTYPE html>\")",
        "comment_created_at": "2025-03-27T04:31:29+00:00",
        "comment_author": "abitrolly",
        "comment_body": "Fixed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1874342930",
    "pr_number": 18895,
    "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
    "created_at": "2024-12-07T06:37:36+00:00",
    "commented_code": ").returns(T::Hash[Symbol, T.untyped])\n         }\n         def self.find_versions(url:, regex: nil, **unused, &block)\n+          # Extract package name and JSON API URL\n           generated = generate_input_values(url)\n+          return {} if generated[:url].nil?\n+\n+          # Parse JSON and get the latest version\n+          begin\n+            response = URI.open(generated[:url]).read",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1874342930",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18895,
        "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
        "discussion_id": "1874342930",
        "commented_code": "@@ -89,9 +78,24 @@\n           ).returns(T::Hash[Symbol, T.untyped])\n         }\n         def self.find_versions(url:, regex: nil, **unused, &block)\n+          # Extract package name and JSON API URL\n           generated = generate_input_values(url)\n+          return {} if generated[:url].nil?\n+\n+          # Parse JSON and get the latest version\n+          begin\n+            response = URI.open(generated[:url]).read",
        "comment_created_at": "2024-12-07T06:37:36+00:00",
        "comment_author": "github-advanced-security[bot]",
        "comment_body": "## Use of `Kernel.open` or `IO.read` or similar sinks with a non-constant value\n\nCall to URI.open with a non-constant value. Consider replacing it with URI(<uri>).open.\n\n[Show more details](https://github.com/Homebrew/brew/security/code-scanning/59)",
        "pr_file_module": null
      }
    ]
  }
]