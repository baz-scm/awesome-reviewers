[
  {
    "discussion_id": "1983752816",
    "pr_number": 19437,
    "pr_file": "Library/Homebrew/cask/audit.rb",
    "created_at": "2025-03-06T17:10:09+00:00",
    "commented_code": "return unless cask.livecheck_defined?\n       return unless (url = cask.livecheck.url)\n       return if url.is_a?(Symbol)\n+      return if (options = cask.livecheck.options).post_form || options.post_json",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1983752816",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19437,
        "pr_file": "Library/Homebrew/cask/audit.rb",
        "discussion_id": "1983752816",
        "commented_code": "@@ -949,6 +949,7 @@ def audit_livecheck_https_availability\n       return unless cask.livecheck_defined?\n       return unless (url = cask.livecheck.url)\n       return if url.is_a?(Symbol)\n+      return if (options = cask.livecheck.options).post_form || options.post_json",
        "comment_created_at": "2025-03-06T17:10:09+00:00",
        "comment_author": "dduugg",
        "comment_body": "There's a lot happening on this line, consider:\r\n```suggestion\r\n\r\n      options = cask.livecheck.options\r\n      return if options.post_form || options.post_json\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1983755987",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19437,
        "pr_file": "Library/Homebrew/cask/audit.rb",
        "discussion_id": "1983752816",
        "commented_code": "@@ -949,6 +949,7 @@ def audit_livecheck_https_availability\n       return unless cask.livecheck_defined?\n       return unless (url = cask.livecheck.url)\n       return if url.is_a?(Symbol)\n+      return if (options = cask.livecheck.options).post_form || options.post_json",
        "comment_created_at": "2025-03-06T17:12:15+00:00",
        "comment_author": "samford",
        "comment_body": "I was on the fence about inlining the definition (from the standpoint of clarity), so this makes sense to me üëç",
        "pr_file_module": null
      },
      {
        "comment_id": "1983773557",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19437,
        "pr_file": "Library/Homebrew/cask/audit.rb",
        "discussion_id": "1983752816",
        "commented_code": "@@ -949,6 +949,7 @@ def audit_livecheck_https_availability\n       return unless cask.livecheck_defined?\n       return unless (url = cask.livecheck.url)\n       return if url.is_a?(Symbol)\n+      return if (options = cask.livecheck.options).post_form || options.post_json",
        "comment_created_at": "2025-03-06T17:24:38+00:00",
        "comment_author": "dduugg",
        "comment_body": "I hear you, it does break up a nice sequence of guard clauses. ü§∑ ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1925324305",
    "pr_number": 19094,
    "pr_file": "Library/Homebrew/utils/pypi.rb",
    "created_at": "2025-01-22T13:29:05+00:00",
    "commented_code": "# Resolve the dependency tree of all input packages\n     show_info = !print_only && !silent\n     ohai \"Retrieving PyPI dependencies for \\\"#{input_packages.join(\" \")}\\\"...\" if show_info\n-    found_packages = pip_report(input_packages, python_name:, print_stderr: verbose && show_info)\n+    print_stderr = !(verbose && show_info).nil?",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1925324305",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19094,
        "pr_file": "Library/Homebrew/utils/pypi.rb",
        "discussion_id": "1925324305",
        "commented_code": "@@ -327,12 +330,16 @@ def self.update_python_resources!(formula, version: nil, package_name: nil, extr\n     # Resolve the dependency tree of all input packages\n     show_info = !print_only && !silent\n     ohai \"Retrieving PyPI dependencies for \\\"#{input_packages.join(\" \")}\\\"...\" if show_info\n-    found_packages = pip_report(input_packages, python_name:, print_stderr: verbose && show_info)\n+    print_stderr = !(verbose && show_info).nil?",
        "comment_created_at": "2025-01-22T13:29:05+00:00",
        "comment_author": "MikeMcQuaid",
        "comment_body": "```suggestion\r\n    print_stderr = if verbose && show_info\r\n      true\r\n    else\r\n      false\r\n    end\r\n```\r\nis a bit easier to read",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1905907847",
    "pr_number": 18874,
    "pr_file": "Library/Homebrew/extend/os/linux/cask/installer.rb",
    "created_at": "2025-01-07T18:51:12+00:00",
    "commented_code": "sig { void }\n         def check_stanza_os_requirements\n-          raise ::Cask::CaskError, \"macOS is required for this software.\"\n+          raise ::Cask::CaskError, \"macOS is required for this software.\" unless artifacts.reject do |k|\n+            k.is_a?(::Cask::Artifact::Font)\n+          end.empty?",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1905907847",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18874,
        "pr_file": "Library/Homebrew/extend/os/linux/cask/installer.rb",
        "discussion_id": "1905907847",
        "commented_code": "@@ -13,7 +13,9 @@ module Installer\n \n         sig { void }\n         def check_stanza_os_requirements\n-          raise ::Cask::CaskError, \"macOS is required for this software.\"\n+          raise ::Cask::CaskError, \"macOS is required for this software.\" unless artifacts.reject do |k|\n+            k.is_a?(::Cask::Artifact::Font)\n+          end.empty?",
        "comment_created_at": "2025-01-07T18:51:12+00:00",
        "comment_author": "dduugg",
        "comment_body": "Is this equivalent logic? (The triple negative of `unless`/`reject`/`empty?` hurts my tiny üß†)\r\n```suggestion\r\n          raise ::Cask::CaskError, \"macOS is required for this software.\" if artifacts.any? do |k|\r\n            k.is_a?(::Cask::Artifact::Font)\r\n          end\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1905978064",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18874,
        "pr_file": "Library/Homebrew/extend/os/linux/cask/installer.rb",
        "discussion_id": "1905907847",
        "commented_code": "@@ -13,7 +13,9 @@ module Installer\n \n         sig { void }\n         def check_stanza_os_requirements\n-          raise ::Cask::CaskError, \"macOS is required for this software.\"\n+          raise ::Cask::CaskError, \"macOS is required for this software.\" unless artifacts.reject do |k|\n+            k.is_a?(::Cask::Artifact::Font)\n+          end.empty?",
        "comment_created_at": "2025-01-07T20:01:48+00:00",
        "comment_author": "SMillerDev",
        "comment_body": "So, it needs to fail if it has anything other than a font. Because only fonts will be supported (in this PR)",
        "pr_file_module": null
      },
      {
        "comment_id": "1906002403",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18874,
        "pr_file": "Library/Homebrew/extend/os/linux/cask/installer.rb",
        "discussion_id": "1905907847",
        "commented_code": "@@ -13,7 +13,9 @@ module Installer\n \n         sig { void }\n         def check_stanza_os_requirements\n-          raise ::Cask::CaskError, \"macOS is required for this software.\"\n+          raise ::Cask::CaskError, \"macOS is required for this software.\" unless artifacts.reject do |k|\n+            k.is_a?(::Cask::Artifact::Font)\n+          end.empty?",
        "comment_created_at": "2025-01-07T20:29:01+00:00",
        "comment_author": "dduugg",
        "comment_body": "TY! In that case, this would be the idiomatic implementation:\r\n\r\n```ruby\r\n        def check_stanza_os_requirements\r\n          return if artifacts.all?(::Cask::Artifact::Font)\r\n\r\n          raise ::Cask::CaskError, \"macOS is required for this software.\"\r\n        end\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1906010619",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18874,
        "pr_file": "Library/Homebrew/extend/os/linux/cask/installer.rb",
        "discussion_id": "1905907847",
        "commented_code": "@@ -13,7 +13,9 @@ module Installer\n \n         sig { void }\n         def check_stanza_os_requirements\n-          raise ::Cask::CaskError, \"macOS is required for this software.\"\n+          raise ::Cask::CaskError, \"macOS is required for this software.\" unless artifacts.reject do |k|\n+            k.is_a?(::Cask::Artifact::Font)\n+          end.empty?",
        "comment_created_at": "2025-01-07T20:36:25+00:00",
        "comment_author": "SMillerDev",
        "comment_body": "Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1939639576",
    "pr_number": 19217,
    "pr_file": "Library/Homebrew/dev-cmd/verify.rb",
    "created_at": "2025-02-03T16:00:26+00:00",
    "commented_code": "+# typed: strict\n+# frozen_string_literal: true\n+\n+require \"abstract_command\"\n+require \"formula\"\n+require \"date\"\n+require \"attestation\"\n+\n+module Homebrew\n+  module DevCmd\n+    class VerifyCmd < AbstractCommand\n+      cmd_args do\n+        description <<~EOS\n+          Verify the build provenance of bottles using GitHub's attestation tools.\n+          This is done by first fetching the given bottles, and then verifying\n+          their provenance.\n+\n+          Note that this command depends on the GitHub CLI. Run `brew install gh`.\n+        EOS\n+        flag   \"--os=\",\n+               description: \"Download for the given operating system.\" \\\n+                            \"(Pass `all` to download for all operating systems.)\"\n+        flag   \"--arch=\",\n+               description: \"Download for the given CPU architecture.\" \\\n+                            \"(Pass `all` to download for all architectures.)\"\n+        flag   \"--bottle-tag=\",\n+               description: \"Download a bottle for given tag.\"\n+        switch \"--deps\",\n+               description: \"Also download dependencies for any listed <formula>.\"\n+        switch \"-f\", \"--force\",\n+               description: \"Remove a previously cached version and re-fetch.\"\n+        switch \"-j\", \"--json\",\n+               description: \"Return JSON for the attestation data for each bottle.\"\n+        conflicts \"--os\", \"--bottle-tag\"\n+        conflicts \"--arch\", \"--bottle-tag\"\n+        named_args [:formula], min: 1\n+      end\n+\n+      sig { override.void }\n+      def run\n+        bucket = if args.deps?\n+          args.named.to_formulae.flat_map do |formula|\n+            [formula, *formula.recursive_dependencies.map(&:to_formula)]\n+          end\n+        else\n+          args.named.to_formulae\n+        end.uniq\n+\n+        os_arch_combinations = args.os_arch_combinations\n+        json_results = []\n+        bucket.each do |formula|\n+          os_arch_combinations.each do |os, arch|\n+            SimulateSystem.with(os:, arch:) do\n+              bottle_tag = if (bottle_tag = args.bottle_tag&.to_sym)\n+                Utils::Bottles::Tag.from_symbol(bottle_tag)\n+              else\n+                Utils::Bottles::Tag.new(system: os, arch:)\n+              end\n+\n+              bottle = formula.bottle_for_tag(bottle_tag)\n+\n+              if bottle.nil?\n+                opoo \"Bottle for tag #{bottle_tag.to_sym.inspect} is unavailable.\"\n+                next",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1939639576",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19217,
        "pr_file": "Library/Homebrew/dev-cmd/verify.rb",
        "discussion_id": "1939639576",
        "commented_code": "@@ -0,0 +1,87 @@\n+# typed: strict\n+# frozen_string_literal: true\n+\n+require \"abstract_command\"\n+require \"formula\"\n+require \"date\"\n+require \"attestation\"\n+\n+module Homebrew\n+  module DevCmd\n+    class VerifyCmd < AbstractCommand\n+      cmd_args do\n+        description <<~EOS\n+          Verify the build provenance of bottles using GitHub's attestation tools.\n+          This is done by first fetching the given bottles, and then verifying\n+          their provenance.\n+\n+          Note that this command depends on the GitHub CLI. Run `brew install gh`.\n+        EOS\n+        flag   \"--os=\",\n+               description: \"Download for the given operating system.\" \\\n+                            \"(Pass `all` to download for all operating systems.)\"\n+        flag   \"--arch=\",\n+               description: \"Download for the given CPU architecture.\" \\\n+                            \"(Pass `all` to download for all architectures.)\"\n+        flag   \"--bottle-tag=\",\n+               description: \"Download a bottle for given tag.\"\n+        switch \"--deps\",\n+               description: \"Also download dependencies for any listed <formula>.\"\n+        switch \"-f\", \"--force\",\n+               description: \"Remove a previously cached version and re-fetch.\"\n+        switch \"-j\", \"--json\",\n+               description: \"Return JSON for the attestation data for each bottle.\"\n+        conflicts \"--os\", \"--bottle-tag\"\n+        conflicts \"--arch\", \"--bottle-tag\"\n+        named_args [:formula], min: 1\n+      end\n+\n+      sig { override.void }\n+      def run\n+        bucket = if args.deps?\n+          args.named.to_formulae.flat_map do |formula|\n+            [formula, *formula.recursive_dependencies.map(&:to_formula)]\n+          end\n+        else\n+          args.named.to_formulae\n+        end.uniq\n+\n+        os_arch_combinations = args.os_arch_combinations\n+        json_results = []\n+        bucket.each do |formula|\n+          os_arch_combinations.each do |os, arch|\n+            SimulateSystem.with(os:, arch:) do\n+              bottle_tag = if (bottle_tag = args.bottle_tag&.to_sym)\n+                Utils::Bottles::Tag.from_symbol(bottle_tag)\n+              else\n+                Utils::Bottles::Tag.new(system: os, arch:)\n+              end\n+\n+              bottle = formula.bottle_for_tag(bottle_tag)\n+\n+              if bottle.nil?\n+                opoo \"Bottle for tag #{bottle_tag.to_sym.inspect} is unavailable.\"\n+                next",
        "comment_created_at": "2025-02-03T16:00:26+00:00",
        "comment_author": "dduugg",
        "comment_body": "Could this be rewritten to use an `else` clause instead? And maybe swap to put the desired outcome first?\r\n\r\n```\r\nif bottle\r\n  ‚Ä¶\r\nelse\r\n  opoo ‚Ä¶\r\nend\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1959334289",
    "pr_number": 19254,
    "pr_file": "Library/Homebrew/cmd/install.rb",
    "created_at": "2025-02-18T09:06:25+00:00",
    "commented_code": "Install.perform_preinstall_checks_once\n         Install.check_cc_argv(args.cc)\n \n+        ask_input = lambda {",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1959334289",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19254,
        "pr_file": "Library/Homebrew/cmd/install.rb",
        "discussion_id": "1959334289",
        "commented_code": "@@ -302,6 +307,98 @@ def run\n         Install.perform_preinstall_checks_once\n         Install.check_cc_argv(args.cc)\n \n+        ask_input = lambda {",
        "comment_created_at": "2025-02-18T09:06:25+00:00",
        "comment_author": "MikeMcQuaid",
        "comment_body": "Can these be dedicated methods rather than a lambda? The method this is part of is getting very long and we don't typically use `lambda` like this just for variable scoping.",
        "pr_file_module": null
      }
    ]
  }
]