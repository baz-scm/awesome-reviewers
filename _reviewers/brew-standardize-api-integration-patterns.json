[
  {
    "discussion_id": "2005581290",
    "pr_number": 19552,
    "pr_file": "Library/Homebrew/bundle/services.rb",
    "created_at": "2025-03-20T12:55:35+00:00",
    "commented_code": "+# typed: strict\n+# frozen_string_literal: true\n+\n+require \"formula\"\n+require \"services/system\"\n+\n+module Homebrew\n+  module Bundle\n+    module Services\n+      sig {\n+        params(\n+          entries: T::Array[Homebrew::Bundle::Dsl::Entry],\n+          _block:  T.proc.params(info: T::Hash[String, T.anything], service_file: Pathname).void,\n+        ).void\n+      }\n+      private_class_method def self.map_entries(entries, &_block)\n+        formula_versions = {}\n+        ENV.each do |key, value|\n+          match = key.match(/^HOMEBREW_BUNDLE_EXEC_FORMULA_VERSION_(.+)$/)\n+          next if match.blank?\n+\n+          formula_name = match[1]\n+          next if formula_name.blank?\n+\n+          ENV.delete(key)\n+          formula_versions[formula_name.downcase] = value\n+        end\n+\n+        entries.filter_map do |entry|\n+          next if entry.type != :brew\n+\n+          formula = Formula[entry.name]\n+          next unless formula.any_version_installed?\n+\n+          version = formula_versions[entry.name.downcase]\n+          prefix = formula.rack/version if version\n+\n+          service_file = if prefix&.directory?\n+            if Homebrew::Services::System.launchctl?\n+              prefix/\"#{formula.plist_name}.plist\"\n+            else\n+              prefix/\"#{formula.service_name}.service\"\n+            end\n+          end\n+\n+          unless service_file&.file?\n+            prefix = formula.any_installed_prefix\n+            next if prefix.nil?\n+\n+            service_file = if Homebrew::Services::System.launchctl?\n+              prefix/\"#{formula.plist_name}.plist\"\n+            else\n+              prefix/\"#{formula.service_name}.service\"\n+            end\n+          end\n+\n+          next unless service_file.file?\n+\n+          # We parse from a command invocation so that brew wrappers can invoke special actions\n+          # for the elevated nature of `brew services`\n+          output = Utils.safe_popen_read(HOMEBREW_BREW_FILE, \"services\", \"info\", \"--json\", formula.full_name)",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "2005581290",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19552,
        "pr_file": "Library/Homebrew/bundle/services.rb",
        "discussion_id": "2005581290",
        "commented_code": "@@ -0,0 +1,92 @@\n+# typed: strict\n+# frozen_string_literal: true\n+\n+require \"formula\"\n+require \"services/system\"\n+\n+module Homebrew\n+  module Bundle\n+    module Services\n+      sig {\n+        params(\n+          entries: T::Array[Homebrew::Bundle::Dsl::Entry],\n+          _block:  T.proc.params(info: T::Hash[String, T.anything], service_file: Pathname).void,\n+        ).void\n+      }\n+      private_class_method def self.map_entries(entries, &_block)\n+        formula_versions = {}\n+        ENV.each do |key, value|\n+          match = key.match(/^HOMEBREW_BUNDLE_EXEC_FORMULA_VERSION_(.+)$/)\n+          next if match.blank?\n+\n+          formula_name = match[1]\n+          next if formula_name.blank?\n+\n+          ENV.delete(key)\n+          formula_versions[formula_name.downcase] = value\n+        end\n+\n+        entries.filter_map do |entry|\n+          next if entry.type != :brew\n+\n+          formula = Formula[entry.name]\n+          next unless formula.any_version_installed?\n+\n+          version = formula_versions[entry.name.downcase]\n+          prefix = formula.rack/version if version\n+\n+          service_file = if prefix&.directory?\n+            if Homebrew::Services::System.launchctl?\n+              prefix/\"#{formula.plist_name}.plist\"\n+            else\n+              prefix/\"#{formula.service_name}.service\"\n+            end\n+          end\n+\n+          unless service_file&.file?\n+            prefix = formula.any_installed_prefix\n+            next if prefix.nil?\n+\n+            service_file = if Homebrew::Services::System.launchctl?\n+              prefix/\"#{formula.plist_name}.plist\"\n+            else\n+              prefix/\"#{formula.service_name}.service\"\n+            end\n+          end\n+\n+          next unless service_file.file?\n+\n+          # We parse from a command invocation so that brew wrappers can invoke special actions\n+          # for the elevated nature of `brew services`\n+          output = Utils.safe_popen_read(HOMEBREW_BREW_FILE, \"services\", \"info\", \"--json\", formula.full_name)",
        "comment_created_at": "2025-03-20T12:55:35+00:00",
        "comment_author": "MikeMcQuaid",
        "comment_body": "Does `brew services list --json` contain the information we need? If so, would be nice to use that instead. If not, maybe it'd be nice to add that information in there.",
        "pr_file_module": null
      },
      {
        "comment_id": "2006799748",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19552,
        "pr_file": "Library/Homebrew/bundle/services.rb",
        "discussion_id": "2005581290",
        "commented_code": "@@ -0,0 +1,92 @@\n+# typed: strict\n+# frozen_string_literal: true\n+\n+require \"formula\"\n+require \"services/system\"\n+\n+module Homebrew\n+  module Bundle\n+    module Services\n+      sig {\n+        params(\n+          entries: T::Array[Homebrew::Bundle::Dsl::Entry],\n+          _block:  T.proc.params(info: T::Hash[String, T.anything], service_file: Pathname).void,\n+        ).void\n+      }\n+      private_class_method def self.map_entries(entries, &_block)\n+        formula_versions = {}\n+        ENV.each do |key, value|\n+          match = key.match(/^HOMEBREW_BUNDLE_EXEC_FORMULA_VERSION_(.+)$/)\n+          next if match.blank?\n+\n+          formula_name = match[1]\n+          next if formula_name.blank?\n+\n+          ENV.delete(key)\n+          formula_versions[formula_name.downcase] = value\n+        end\n+\n+        entries.filter_map do |entry|\n+          next if entry.type != :brew\n+\n+          formula = Formula[entry.name]\n+          next unless formula.any_version_installed?\n+\n+          version = formula_versions[entry.name.downcase]\n+          prefix = formula.rack/version if version\n+\n+          service_file = if prefix&.directory?\n+            if Homebrew::Services::System.launchctl?\n+              prefix/\"#{formula.plist_name}.plist\"\n+            else\n+              prefix/\"#{formula.service_name}.service\"\n+            end\n+          end\n+\n+          unless service_file&.file?\n+            prefix = formula.any_installed_prefix\n+            next if prefix.nil?\n+\n+            service_file = if Homebrew::Services::System.launchctl?\n+              prefix/\"#{formula.plist_name}.plist\"\n+            else\n+              prefix/\"#{formula.service_name}.service\"\n+            end\n+          end\n+\n+          next unless service_file.file?\n+\n+          # We parse from a command invocation so that brew wrappers can invoke special actions\n+          # for the elevated nature of `brew services`\n+          output = Utils.safe_popen_read(HOMEBREW_BREW_FILE, \"services\", \"info\", \"--json\", formula.full_name)",
        "comment_created_at": "2025-03-21T03:50:23+00:00",
        "comment_author": "Bo98",
        "comment_body": "`list` is a small subset of `info`. I use 4 fields from the JSON, 3 of which are not in `list`.\r\n\r\nCould maybe add them though we'd be near the point of making it not a subset anymore.\r\n\r\nI think maybe a better option is to allow `info` to take in multiple arguments: https://github.com/Homebrew/brew/pull/19565",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "810911801",
    "pr_number": 12898,
    "pr_file": "Library/Homebrew/env_config.rb",
    "created_at": "2022-02-21T09:08:31+00:00",
    "commented_code": "\"of Ruby is new enough.\",\n         boolean:     true,\n       },\n+      HOMEBREW_GITHUB_API_URL:                   {\n+        description: \"Use this URL for accessing the GitHub API, such as https://git.example.com/api/v3\" \\\n+                     \"for a GitHub Enterprise Server. \",\n+      },",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "810911801",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 12898,
        "pr_file": "Library/Homebrew/env_config.rb",
        "discussion_id": "810911801",
        "commented_code": "@@ -162,6 +162,10 @@ module EnvConfig\n                      \"of Ruby is new enough.\",\n         boolean:     true,\n       },\n+      HOMEBREW_GITHUB_API_URL:                   {\n+        description: \"Use this URL for accessing the GitHub API, such as https://git.example.com/api/v3\" \\\n+                     \"for a GitHub Enterprise Server. \",\n+      },",
        "comment_created_at": "2022-02-21T09:08:31+00:00",
        "comment_author": "MikeMcQuaid",
        "comment_body": "I think this needs to be more specific as to where it's used. It's not using this instead for e.g. all GitHub searches.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1941545537",
    "pr_number": 19233,
    "pr_file": "Library/Homebrew/livecheck/strategy.rb",
    "created_at": "2025-02-04T16:50:58+00:00",
    "commented_code": "end\n       end\n \n+      # Creates `curl` `--data` or `--json` arguments (for `POST` requests`\n+      # from `livecheck` block `url` options.\n+      sig { params(url_options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }\n+      def post_args(url_options)\n+        type = if (data = url_options[:data])\n+          :data\n+        elsif (data = url_options[:json])\n+          :json\n+        end\n+        return [] if !type || !data\n+\n+        case data\n+        when Hash\n+          if type == :json\n+            require \"json\"\n+            [\"--#{type}\", JSON.generate(data)]\n+          else\n+            require \"uri\"\n+            [\"--#{type}\", URI.encode_www_form(data)]\n+          end\n+        else\n+          [\"--#{type}\", data]\n+        end\n+      end\n+\n       # Collects HTTP response headers, starting with the provided URL.\n       # Redirections will be followed and all the response headers are\n       # collected into an array of hashes.\n       #\n       # @param url [String] the URL to fetch\n+      # @param url_options [Hash] options to modify curl behavior\n       # @param homebrew_curl [Boolean] whether to use brewed curl with the URL\n       # @return [Array]\n-      sig { params(url: String, homebrew_curl: T::Boolean).returns(T::Array[T::Hash[String, String]]) }\n-      def self.page_headers(url, homebrew_curl: false)\n+      sig {\n+        params(\n+          url:           String,\n+          url_options:   T::Hash[Symbol, T.untyped],\n+          homebrew_curl: T::Boolean,\n+        ).returns(T::Array[T::Hash[String, String]])\n+      }\n+      def self.page_headers(url, url_options: {}, homebrew_curl: false)\n         headers = []\n \n+        curl_post_args = [\"--request\", \"POST\", *post_args(url_options)] if url_options[:using] == :post",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1941545537",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19233,
        "pr_file": "Library/Homebrew/livecheck/strategy.rb",
        "discussion_id": "1941545537",
        "commented_code": "@@ -166,20 +166,55 @@ def from_url(url, livecheck_strategy: nil, regex_provided: false, block_provided\n         end\n       end\n \n+      # Creates `curl` `--data` or `--json` arguments (for `POST` requests`\n+      # from `livecheck` block `url` options.\n+      sig { params(url_options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }\n+      def post_args(url_options)\n+        type = if (data = url_options[:data])\n+          :data\n+        elsif (data = url_options[:json])\n+          :json\n+        end\n+        return [] if !type || !data\n+\n+        case data\n+        when Hash\n+          if type == :json\n+            require \"json\"\n+            [\"--#{type}\", JSON.generate(data)]\n+          else\n+            require \"uri\"\n+            [\"--#{type}\", URI.encode_www_form(data)]\n+          end\n+        else\n+          [\"--#{type}\", data]\n+        end\n+      end\n+\n       # Collects HTTP response headers, starting with the provided URL.\n       # Redirections will be followed and all the response headers are\n       # collected into an array of hashes.\n       #\n       # @param url [String] the URL to fetch\n+      # @param url_options [Hash] options to modify curl behavior\n       # @param homebrew_curl [Boolean] whether to use brewed curl with the URL\n       # @return [Array]\n-      sig { params(url: String, homebrew_curl: T::Boolean).returns(T::Array[T::Hash[String, String]]) }\n-      def self.page_headers(url, homebrew_curl: false)\n+      sig {\n+        params(\n+          url:           String,\n+          url_options:   T::Hash[Symbol, T.untyped],\n+          homebrew_curl: T::Boolean,\n+        ).returns(T::Array[T::Hash[String, String]])\n+      }\n+      def self.page_headers(url, url_options: {}, homebrew_curl: false)\n         headers = []\n \n+        curl_post_args = [\"--request\", \"POST\", *post_args(url_options)] if url_options[:using] == :post",
        "comment_created_at": "2025-02-04T16:50:58+00:00",
        "comment_author": "samford",
        "comment_body": "I went with `using: :post` as the way of setting up a `POST` request (aligning with the existing options for formula `url`s) but `method: :post` may make more sense.\r\n\r\nIf there isn't any particular benefit to the `using` terminology in this context, I think `method` does a better job of indicating the purpose and what curl is doing behind the scenes. Besides that, `using` may confuse people into thinking that livecheck is also using `DownloadStrategy` and that all the same arguments are supported (neither of which is true).",
        "pr_file_module": null
      },
      {
        "comment_id": "1942987805",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19233,
        "pr_file": "Library/Homebrew/livecheck/strategy.rb",
        "discussion_id": "1941545537",
        "commented_code": "@@ -166,20 +166,55 @@ def from_url(url, livecheck_strategy: nil, regex_provided: false, block_provided\n         end\n       end\n \n+      # Creates `curl` `--data` or `--json` arguments (for `POST` requests`\n+      # from `livecheck` block `url` options.\n+      sig { params(url_options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }\n+      def post_args(url_options)\n+        type = if (data = url_options[:data])\n+          :data\n+        elsif (data = url_options[:json])\n+          :json\n+        end\n+        return [] if !type || !data\n+\n+        case data\n+        when Hash\n+          if type == :json\n+            require \"json\"\n+            [\"--#{type}\", JSON.generate(data)]\n+          else\n+            require \"uri\"\n+            [\"--#{type}\", URI.encode_www_form(data)]\n+          end\n+        else\n+          [\"--#{type}\", data]\n+        end\n+      end\n+\n       # Collects HTTP response headers, starting with the provided URL.\n       # Redirections will be followed and all the response headers are\n       # collected into an array of hashes.\n       #\n       # @param url [String] the URL to fetch\n+      # @param url_options [Hash] options to modify curl behavior\n       # @param homebrew_curl [Boolean] whether to use brewed curl with the URL\n       # @return [Array]\n-      sig { params(url: String, homebrew_curl: T::Boolean).returns(T::Array[T::Hash[String, String]]) }\n-      def self.page_headers(url, homebrew_curl: false)\n+      sig {\n+        params(\n+          url:           String,\n+          url_options:   T::Hash[Symbol, T.untyped],\n+          homebrew_curl: T::Boolean,\n+        ).returns(T::Array[T::Hash[String, String]])\n+      }\n+      def self.page_headers(url, url_options: {}, homebrew_curl: false)\n         headers = []\n \n+        curl_post_args = [\"--request\", \"POST\", *post_args(url_options)] if url_options[:using] == :post",
        "comment_created_at": "2025-02-05T13:54:16+00:00",
        "comment_author": "samford",
        "comment_body": "Thinking about this some more, the using `option` in the mail formula `url` is also used to specify brewed curl (i.e., `using: :homebrew_curl`) but we may need to use both together in livecheck. I went ahead and updated this to use `method: :post`, as that would also allow us to have a `using: :homebrew_curl` `url` option in the near future. We may use a different name (e.g., `homebrew_curl: true`) for the aforementioned reasons around the `using` terminology but this is just another reason to use `method` instead.\r\n\r\n[For what it's worth, there are a few packages where we can't infer `homebrew_curl` and need to explicitly specify it. That's currently part of the `options` feature but the `url_options` setup in this PR should allow me to add `homebrew_curl` support sooner in a follow-up PR to this.]",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1943024572",
    "pr_number": 19233,
    "pr_file": "Library/Homebrew/livecheck/strategy.rb",
    "created_at": "2025-02-05T14:16:49+00:00",
    "commented_code": "end\n       end\n \n+      # Creates `curl` `--data` or `--json` arguments (for `POST` requests`\n+      # from `livecheck` block `url` options.\n+      sig { params(url_options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }\n+      def post_args(url_options)\n+        type = if (data = url_options[:data].presence)\n+          :data\n+        elsif (data = url_options[:json].presence)\n+          :json\n+        end\n+        return [] if !type || !data\n+\n+        case data\n+        when Hash\n+          if type == :json\n+            require \"json\"\n+            [\"--#{type}\", JSON.generate(data)]\n+          else\n+            require \"uri\"\n+            [\"--#{type}\", URI.encode_www_form(data)]\n+          end\n+        else\n+          [\"--#{type}\", data]\n+        end",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1943024572",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 19233,
        "pr_file": "Library/Homebrew/livecheck/strategy.rb",
        "discussion_id": "1943024572",
        "commented_code": "@@ -166,20 +166,55 @@ def from_url(url, livecheck_strategy: nil, regex_provided: false, block_provided\n         end\n       end\n \n+      # Creates `curl` `--data` or `--json` arguments (for `POST` requests`\n+      # from `livecheck` block `url` options.\n+      sig { params(url_options: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }\n+      def post_args(url_options)\n+        type = if (data = url_options[:data].presence)\n+          :data\n+        elsif (data = url_options[:json].presence)\n+          :json\n+        end\n+        return [] if !type || !data\n+\n+        case data\n+        when Hash\n+          if type == :json\n+            require \"json\"\n+            [\"--#{type}\", JSON.generate(data)]\n+          else\n+            require \"uri\"\n+            [\"--#{type}\", URI.encode_www_form(data)]\n+          end\n+        else\n+          [\"--#{type}\", data]\n+        end",
        "comment_created_at": "2025-02-05T14:16:49+00:00",
        "comment_author": "samford",
        "comment_body": "`post_args` provides support for data that's a string (already in the expected format) or a hash (that will be converted to the expected format). This allows for some flexibility but I imagine we will mostly standardize on one format in core/cask (with rare exceptions).\r\n\r\nHashes are probably the easiest to work with and maintain but we may encounter weird servers that don't like the encoding from `URI::encode_www_form` and we would need to use a pre-formatted string in those cases. [It's rare but I have a vague memory of having to do something like that before (outside of Homebrew) with unusual servers. That said, I may be conflating this with `+`/`%20` in query string parameters.]\r\n\r\nAlternatively, if we don't think string support is strictly necessary (or something that people want/need), we could omit it here and add it back in the future if/when needed.\r\n\r\nEdit: We decided to drop `post_args` string support until it's needed (https://github.com/Homebrew/brew/pull/19233#discussion_r1945077742).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1874534358",
    "pr_number": 18895,
    "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
    "created_at": "2024-12-07T17:07:04+00:00",
    "commented_code": "# typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1874534358",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18895,
        "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
        "discussion_id": "1874534358",
        "commented_code": "@@ -1,19 +1,21 @@\n # typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+",
        "comment_created_at": "2024-12-07T17:07:04+00:00",
        "comment_author": "samford",
        "comment_body": "```suggestion\r\n```\r\n\r\n* We use `Json` strategy methods within strategies that parse JSON, as in the [`Crate` strategy](https://github.com/Homebrew/brew/blob/405cedad235fa9d6960e19b78705d0f43094b140/Library/Homebrew/livecheck/strategy/crate.rb).\r\n* We use `Strategy#page_content` (or `Strategy#page_headers`) to fetch content within strategies (i.e., we don't use `Utils::Curl` directly in strategies).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1874535121",
    "pr_number": 18895,
    "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
    "created_at": "2024-12-07T17:12:43+00:00",
    "commented_code": "# typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+\n module Homebrew\n   module Livecheck\n     module Strategy\n       # The {Pypi} strategy identifies versions of software at pypi.org by\n-      # checking project pages for archive files.\n+      # using the JSON API endpoint.\n       #\n-      # PyPI URLs have a standard format but the hexadecimal text between\n-      # `/packages/` and the filename varies:\n+      # PyPI URLs have a standard format:\n       #\n       # * `https://files.pythonhosted.org/packages/<hex>/<hex>/<long_hex>/example-1.2.3.tar.gz`\n       #\n-      # As such, the default regex only targets the filename at the end of the\n-      # URL.\n+      # This method uses the `info.version` field in the JSON response to\n+      # determine the latest stable version.",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1874535121",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18895,
        "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
        "discussion_id": "1874535121",
        "commented_code": "@@ -1,19 +1,21 @@\n # typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+\n module Homebrew\n   module Livecheck\n     module Strategy\n       # The {Pypi} strategy identifies versions of software at pypi.org by\n-      # checking project pages for archive files.\n+      # using the JSON API endpoint.\n       #\n-      # PyPI URLs have a standard format but the hexadecimal text between\n-      # `/packages/` and the filename varies:\n+      # PyPI URLs have a standard format:\n       #\n       # * `https://files.pythonhosted.org/packages/<hex>/<hex>/<long_hex>/example-1.2.3.tar.gz`\n       #\n-      # As such, the default regex only targets the filename at the end of the\n-      # URL.\n+      # This method uses the `info.version` field in the JSON response to\n+      # determine the latest stable version.",
        "comment_created_at": "2024-12-07T17:12:43+00:00",
        "comment_author": "samford",
        "comment_body": "One thing worth confirming is whether the `version` returned from the API is simply the newest release or if it's specifically the newest _non-yanked_ release. The `info` object in the JSON field also has a `yanked` boolean field (like the objects in the `releases` and `urls` arrays), which suggests that it may be possible for the newest version to be a yanked release.\r\n\r\nTo confirm this, we would need to find a package where the latest release is a yanked release to see what the API returns. If the `version` value isn't guaranteed to be a non-yanked version, then we would need to iterate through `urls` (`releases` is deprecated, according to the [JSON API documentation](https://docs.pypi.org/api/json/)).",
        "pr_file_module": null
      },
      {
        "comment_id": "1874542558",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18895,
        "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
        "discussion_id": "1874535121",
        "commented_code": "@@ -1,19 +1,21 @@\n # typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+\n module Homebrew\n   module Livecheck\n     module Strategy\n       # The {Pypi} strategy identifies versions of software at pypi.org by\n-      # checking project pages for archive files.\n+      # using the JSON API endpoint.\n       #\n-      # PyPI URLs have a standard format but the hexadecimal text between\n-      # `/packages/` and the filename varies:\n+      # PyPI URLs have a standard format:\n       #\n       # * `https://files.pythonhosted.org/packages/<hex>/<hex>/<long_hex>/example-1.2.3.tar.gz`\n       #\n-      # As such, the default regex only targets the filename at the end of the\n-      # URL.\n+      # This method uses the `info.version` field in the JSON response to\n+      # determine the latest stable version.",
        "comment_created_at": "2024-12-07T18:11:21+00:00",
        "comment_author": "cho-m",
        "comment_body": "Might need to find an example to test, but the code may prioritize non-yanked/non-prerelease:\r\n* https://github.com/pypi/warehouse/blob/main/warehouse/routes.py#L618-L619\r\n  ```py\r\n          \"/pypi/{name}/json\",\r\n          factory=\"warehouse.legacy.api.json.latest_release_factory\",\r\n  ```\r\n* https://github.com/pypi/warehouse/blob/main/warehouse/legacy/api/json.py#L211-L214\r\n  ```py\r\n              .order_by(\r\n                  Release.yanked.asc(),\r\n                  Release.is_prerelease.nullslast(),\r\n                  Release._pypi_ordering.desc(),\r\n  ```\r\n\r\nIn which case, the `yanked` boolean field would only be `true` if all releases are yanked.",
        "pr_file_module": null
      },
      {
        "comment_id": "1874589718",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18895,
        "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
        "discussion_id": "1874535121",
        "commented_code": "@@ -1,19 +1,21 @@\n # typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+\n module Homebrew\n   module Livecheck\n     module Strategy\n       # The {Pypi} strategy identifies versions of software at pypi.org by\n-      # checking project pages for archive files.\n+      # using the JSON API endpoint.\n       #\n-      # PyPI URLs have a standard format but the hexadecimal text between\n-      # `/packages/` and the filename varies:\n+      # PyPI URLs have a standard format:\n       #\n       # * `https://files.pythonhosted.org/packages/<hex>/<hex>/<long_hex>/example-1.2.3.tar.gz`\n       #\n-      # As such, the default regex only targets the filename at the end of the\n-      # URL.\n+      # This method uses the `info.version` field in the JSON response to\n+      # determine the latest stable version.",
        "comment_created_at": "2024-12-08T01:14:58+00:00",
        "comment_author": "samford",
        "comment_body": "Oh nice, thanks for digging up related code. I was hoping that they prioritized the latest non-yanked release. It still wouldn't hurt to confirm with a package where the newest release is yanked but that's reassuring enough for us to move ahead with this PR for now.\r\n\r\nI wonder if there's an intelligent way of easily finding a PyPI project where the newest release is yanked besides checking random packages until we find a match (that would be like finding a needle in a haystack) 😆\r\n\r\nIt would probably be easier to create a PyPI project for testing, create some test releases, yank the newest one, check the API response, and then delete the project. I don't know anything about PyPI, so I'm not sure how okay they would be with that but that may be an idea.",
        "pr_file_module": null
      },
      {
        "comment_id": "1874596727",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18895,
        "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
        "discussion_id": "1874535121",
        "commented_code": "@@ -1,19 +1,21 @@\n # typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+\n module Homebrew\n   module Livecheck\n     module Strategy\n       # The {Pypi} strategy identifies versions of software at pypi.org by\n-      # checking project pages for archive files.\n+      # using the JSON API endpoint.\n       #\n-      # PyPI URLs have a standard format but the hexadecimal text between\n-      # `/packages/` and the filename varies:\n+      # PyPI URLs have a standard format:\n       #\n       # * `https://files.pythonhosted.org/packages/<hex>/<hex>/<long_hex>/example-1.2.3.tar.gz`\n       #\n-      # As such, the default regex only targets the filename at the end of the\n-      # URL.\n+      # This method uses the `info.version` field in the JSON response to\n+      # determine the latest stable version.",
        "comment_created_at": "2024-12-08T02:03:18+00:00",
        "comment_author": "cho-m",
        "comment_body": "Did find one from searching Gentoo's commit history. \r\n\r\nhttps://pypi.org/project/cleo/#history\r\n```console\r\n❯ curl -sL https://pypi.org/pypi/cleo/json | jq -r '.info | [.version, .yanked] | @csv'\r\n\"2.1.0\",false\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1874605074",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18895,
        "pr_file": "Library/Homebrew/livecheck/strategy/pypi.rb",
        "discussion_id": "1874535121",
        "commented_code": "@@ -1,19 +1,21 @@\n # typed: strict\n # frozen_string_literal: true\n \n+require \"json\"\n+require \"utils/curl\"\n+\n module Homebrew\n   module Livecheck\n     module Strategy\n       # The {Pypi} strategy identifies versions of software at pypi.org by\n-      # checking project pages for archive files.\n+      # using the JSON API endpoint.\n       #\n-      # PyPI URLs have a standard format but the hexadecimal text between\n-      # `/packages/` and the filename varies:\n+      # PyPI URLs have a standard format:\n       #\n       # * `https://files.pythonhosted.org/packages/<hex>/<hex>/<long_hex>/example-1.2.3.tar.gz`\n       #\n-      # As such, the default regex only targets the filename at the end of the\n-      # URL.\n+      # This method uses the `info.version` field in the JSON response to\n+      # determine the latest stable version.",
        "comment_created_at": "2024-12-08T03:35:16+00:00",
        "comment_author": "samford",
        "comment_body": "Oh wow, great work finding that example. That's exactly how I was hoping PyPI would handle that situation (i.e., 2.2.1 and and 2.2.0 are the newest releases and they're both yanked, so PyPI uses 2.1.0 as the `version` in the JSON API since it's the newest non-yanked release). Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861349132",
    "pr_number": 18839,
    "pr_file": "Library/Homebrew/livecheck/livecheck.rb",
    "created_at": "2024-11-27T23:44:06+00:00",
    "commented_code": "},\n         }\n \n-        resource_version_info[:meta] = { livecheckable: has_livecheckable, url: {} }\n+        resource_version_info[:meta] = {\n+          has_livecheck_block: has_livecheck_block,\n+          # TODO: Remove `livecheckable` field after aliases are removed\n+          livecheckable:       has_livecheck_block,",
    "repo_full_name": "Homebrew/brew",
    "discussion_comments": [
      {
        "comment_id": "1861349132",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18839,
        "pr_file": "Library/Homebrew/livecheck/livecheck.rb",
        "discussion_id": "1861349132",
        "commented_code": "@@ -978,7 +982,12 @@ def self.resource_version(\n           },\n         }\n \n-        resource_version_info[:meta] = { livecheckable: has_livecheckable, url: {} }\n+        resource_version_info[:meta] = {\n+          has_livecheck_block: has_livecheck_block,\n+          # TODO: Remove `livecheckable` field after aliases are removed\n+          livecheckable:       has_livecheck_block,",
        "comment_created_at": "2024-11-27T23:44:06+00:00",
        "comment_author": "samford",
        "comment_body": "Similar to going through a deprecation phase with `#livecheckable?`, this keeps the existing `livecheckable` field in the verbose JSON output for the time being.\r\n\r\nHowever, this is a different situation, as there's nothing like `odeprecated` to make it clear that the field name has changed to `has_livecheck_block` and it makes the verbose JSON output longer (by duplicating fields). Having both fields at the same time may also lead to some confusion about whether `has_livecheck_block` and `livecheckable` mean different things, so it may be worse than simply dropping the old field entirely. Keeping the `livecheckable` field for now would only delay the point when any third-party code will break, so dropping the old field may be fine and would certainly simplify some of the changes here.\r\n\r\nThat said, I'm not aware of any third-party projects that use the verbose JSON output, so I'm not sure if there's any particular benefit here. As above, I have some personal projects that parse verbose livecheck JSON output and I'll need to update those to handle the new `has_livecheck_block` field name (checking for the older `livecheckable` name if not found) but that's an easy change.",
        "pr_file_module": null
      },
      {
        "comment_id": "1861489024",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18839,
        "pr_file": "Library/Homebrew/livecheck/livecheck.rb",
        "discussion_id": "1861349132",
        "commented_code": "@@ -978,7 +982,12 @@ def self.resource_version(\n           },\n         }\n \n-        resource_version_info[:meta] = { livecheckable: has_livecheckable, url: {} }\n+        resource_version_info[:meta] = {\n+          has_livecheck_block: has_livecheck_block,\n+          # TODO: Remove `livecheckable` field after aliases are removed\n+          livecheckable:       has_livecheck_block,",
        "comment_created_at": "2024-11-28T04:22:30+00:00",
        "comment_author": "apainintheneck",
        "comment_body": "Yeah, this is one of the difficult things with the JSON representation since it's public but we can't smoothly deprecate anything. My 2 cents are that it should be fine to remove since it's probably not something people rely upon much assuming that it's communicated in the release notes.",
        "pr_file_module": null
      },
      {
        "comment_id": "1866034513",
        "repo_full_name": "Homebrew/brew",
        "pr_number": 18839,
        "pr_file": "Library/Homebrew/livecheck/livecheck.rb",
        "discussion_id": "1861349132",
        "commented_code": "@@ -978,7 +982,12 @@ def self.resource_version(\n           },\n         }\n \n-        resource_version_info[:meta] = { livecheckable: has_livecheckable, url: {} }\n+        resource_version_info[:meta] = {\n+          has_livecheck_block: has_livecheck_block,\n+          # TODO: Remove `livecheckable` field after aliases are removed\n+          livecheckable:       has_livecheck_block,",
        "comment_created_at": "2024-12-02T15:15:37+00:00",
        "comment_author": "samford",
        "comment_body": "I removed the `livecheckable` field from the JSON output in the latest push, so we will only have `obj[:meta][:livecheck_defined]` going forward 👍",
        "pr_file_module": null
      }
    ]
  }
]