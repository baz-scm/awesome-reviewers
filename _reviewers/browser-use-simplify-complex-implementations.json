[
  {
    "discussion_id": "2163783175",
    "pr_number": 2084,
    "pr_file": "browser_use/controller/service.py",
    "created_at": "2025-06-24T12:04:45+00:00",
    "commented_code": "initial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
    "repo_full_name": "browser-use/browser-use",
    "discussion_comments": [
      {
        "comment_id": "2163783175",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T12:04:45+00:00",
        "comment_author": "mertunsall",
        "comment_body": "This can be changed to:\r\n\r\n```suggestion\r\n\t\t\tif browser_session.is_file_input(element_node):\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2163784416",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T12:05:14+00:00",
        "comment_author": "mertunsall",
        "comment_body": "can you test if this works? if good, we can merge",
        "pr_file_module": null
      },
      {
        "comment_id": "2163906454",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T12:47:14+00:00",
        "comment_author": "DanielTea",
        "comment_body": "had it in a single line before but ruff was complaining: ruff-format..............................................................Failed\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2163940748",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T12:58:07+00:00",
        "comment_author": "DanielTea",
        "comment_body": "@mertunsall  yes for my commit it works, all the tests are running fine, upload and click on conversion works again (your change i couldn't test):\r\n\r\n \r\n\r\n![image](https://github.com/user-attachments/assets/7088495b-8bff-4e28-9374-90f61dffb825)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2163943346",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T12:59:15+00:00",
        "comment_author": "DanielTea",
        "comment_body": "> can you test if this works? if good, we can merge\r\n\r\nhm the linter doesnt like your change: https://github.com/browser-use/browser-use/actions/runs/15850831131/job/44683602848?pr=2084",
        "pr_file_module": null
      },
      {
        "comment_id": "2164452977",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T16:31:34+00:00",
        "comment_author": "mertunsall",
        "comment_body": "I think adding a check for whether element is None or not should help, can you do it? then it should pass linter and we can merge ",
        "pr_file_module": null
      },
      {
        "comment_id": "2164455211",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T16:32:55+00:00",
        "comment_author": "mertunsall",
        "comment_body": "mine does exactly the same thing, just doesn\u2019t repeat code",
        "pr_file_module": null
      },
      {
        "comment_id": "2164549786",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 2084,
        "pr_file": "browser_use/controller/service.py",
        "discussion_id": "2163783175",
        "commented_code": "@@ -240,7 +240,12 @@ async def click_element_by_index(params: ClickElementAction, browser_session: Br\n \t\t\tinitial_pages = len(browser_session.tabs)\n \n \t\t\t# if element has file uploader then dont click\n-\t\t\tif await browser_session.is_file_input_by_index(params.index):\n+\t\t\t# Check if element is actually a file input (not just contains file-related keywords)\n+\t\t\tif (\n+\t\t\t\telement_node\n+\t\t\t\tand element_node.tag_name.lower() == 'input'\n+\t\t\t\tand element_node.attributes.get('type', '').lower() == 'file'\n+\t\t\t):",
        "comment_created_at": "2025-06-24T17:30:22+00:00",
        "comment_author": "DanielTea",
        "comment_body": "\r\n\r\n\r\n> I think adding a check for whether element is None or not should help, can you do it? then it should pass linter and we can merge\r\n\r\n\r\n@mertunsall done, and it runs sucessfully: \r\n\r\n![image](https://github.com/user-attachments/assets/a510bfe2-bb8c-4d1c-adfa-d0a75babbb39)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2131429494",
    "pr_number": 1911,
    "pr_file": "browser_use/agent/service.py",
    "created_at": "2025-06-06T03:18:38+00:00",
    "commented_code": "except Exception as e:\n \t\t\tlogger.error(f'Error during cleanup: {e}')\n \n+\tdef extract_playwright_actions(self, output_path: str | Path = None, include_initial_actions: bool = True) -> list[dict]:\n+\t\t\"\"\"\n+\t\tExtract Playwright actions from the agent's history and save as JSON for developer testing.\n+\n+\t\tArgs:\n+\t\t\toutput_path: Optional path to save the extracted actions as JSON\n+\t\t\tinclude_initial_actions: Whether to include initial actions in the extracted list\n+\n+\t\tReturns:\n+\t\t\tList of action dictionaries with action_name, params, and result\n+\t\t\"\"\"\n+\t\tplaywright_actions = []\n+\n+\t\t# First, check if there are any initial actions and we should include them\n+\t\tif include_initial_actions and hasattr(self, 'initial_actions') and self.initial_actions:\n+\t\t\tlogger.debug(f'Including {len(self.initial_actions)} initial actions in Playwright script')\n+\t\t\tfor action in self.initial_actions:\n+\t\t\t\t# Skip None actions to prevent AttributeError\n+\t\t\t\tif action is None:\n+\t\t\t\t\tcontinue\n+\t\t\t\taction_data = action.model_dump(exclude_unset=True)\n+\t\t\t\taction_name = next(iter(action_data.keys()), 'unknown')\n+\t\t\t\tparams = action_data.get(action_name, {})\n+\t\t\t\tplaywright_actions.append(\n+\t\t\t\t\t{\n+\t\t\t\t\t\t'action_name': action_name,\n+\t\t\t\t\t\t'params': params,\n+\t\t\t\t\t\t'result': None,  # Initial actions don't have results in the same format\n+\t\t\t\t\t}\n+\t\t\t\t)\n+\n+\t\t# Then extract actions from history\n+\t\tfor history_item in self.state.history.history:\n+\t\t\tif not history_item.model_output:\n+\t\t\t\tcontinue\n+\t\t\tactions = history_item.model_output.action\n+\t\t\tresults = history_item.result\n+\t\t\tfor i, action in enumerate(actions):\n+\t\t\t\t# Skip None actions to prevent AttributeError\n+\t\t\t\tif action is None:\n+\t\t\t\t\tcontinue\n+\t\t\t\taction_data = action.model_dump(exclude_unset=True)\n+\t\t\t\taction_name = next(iter(action_data.keys()), 'unknown')\n+\t\t\t\tparams = action_data.get(action_name, {})\n+\t\t\t\tresult = None\n+\t\t\t\tif i < len(results):\n+\t\t\t\t\tresult = results[i].model_dump()\n+\t\t\t\tplaywright_actions.append({'action_name': action_name, 'params': params, 'result': result})\n+\n+\t\t# Save to file if output_path is provided and logging level is debug\n+\t\tif output_path and os.environ.get('BROWSER_USE_LOGGING_LEVEL', '').lower() == 'debug':\n+\t\t\tlogger.debug(f'Saving Playwright actions to {output_path} (debug mode enabled)')\n+\t\t\tpath_obj = Path(output_path)\n+\t\t\tpath_obj.parent.mkdir(parents=True, exist_ok=True)\n+\t\t\twith open(path_obj, 'w', encoding='utf-8') as f:\n+\t\t\t\tjson.dump(playwright_actions, f, indent=2, default=str)\n+\n+\t\treturn playwright_actions\n+\n+\tasync def generate_playwright_script(\n+\t\tself, actions: list[dict] = None, output_path: str | Path = None, headless: bool = False, script_name: str = None\n+\t) -> str:\n+\t\t\"\"\"\n+\t\tGenerate a Playwright script from the extracted actions using an LLM approach.\n+\n+\t\tThis method takes browser-use actions and converts them into a standalone Playwright script\n+\t\tthat can be run independently. The script includes proper error handling, cleanup, and\n+\t\tPlaywright expect assertions for validation.\n+\n+\t\tArgs:\n+\t\t\tactions: List of action dictionaries. If None, will extract actions from history.\n+\t\t\toutput_path: Path to save the generated script. If None, will generate a path.\n+\t\t\theadless: Whether to run the browser in headless mode in the generated script\n+\t\t\tscript_name: Custom name for the script file. If None, will generate from task.\n+\n+\t\tReturns:\n+\t\t\tThe generated Playwright script as a string\n+\t\t\"\"\"\n+\t\t# If actions not provided, extract them from history\n+\t\tif actions is None:\n+\t\t\tactions = self.extract_playwright_actions()\n+\n+\t\tif not actions:\n+\t\t\tlogger.warning('No actions found in history to generate Playwright script')\n+\t\t\treturn ''\n+\n+\t\t# Generate a default output path if none provided\n+\t\tif output_path is None:\n+\t\t\t# Create a timestamp for uniqueness\n+\t\t\ttimestamp = time.strftime('%Y%m%d_%H%M%S')\n+\n+\t\t\t# Generate a name from the task if not provided\n+\t\t\tif script_name is None:\n+\t\t\t\t# Extract a short name from the task description\n+\t\t\t\ttask_words = self.task.lower().split()\n+\t\t\t\t# Use first 5 words or fewer if task is shorter\n+\t\t\t\tword_limit = min(5, len(task_words))\n+\t\t\t\tscript_name = '_'.join(task_words[:word_limit]).replace('https://', '').replace('/', '_')\n+\t\t\t\t# Clean up the name to be filesystem-friendly\n+\t\t\t\tscript_name = re.sub(r'[^\\w\\-_.]', '_', script_name)\n+\t\t\t\t# Truncate if too long\n+\t\t\t\tif len(script_name) > 50:\n+\t\t\t\t\tscript_name = script_name[:50]\n+\n+\t\t\t# Create the output directory at project root\n+\t\t\troot_dir = Path(__file__).parents[2]  # Go up 2 levels from service.py to reach the project root\n+\t\t\toutput_dir = root_dir / 'output' / 'playwright_scripts'\n+\t\t\toutput_dir.mkdir(parents=True, exist_ok=True)\n+\n+\t\t\t# Combine everything into a path\n+\t\t\toutput_path = output_dir / f'{script_name}_{timestamp}.py'\n+\n+\t\t# Prepare the detailed prompt for the LLM\n+\t\t# This prompt is structured to guide the LLM in generating a complete, robust Playwright script\n+\t\t# that includes proper error handling, cleanup, and validation assertions\n+\t\tprompt = f\"\"\"\n+\t\tYou are an expert in converting browser actions to Playwright Python scripts.\n+\t\tBelow is a list of browser actions performed by a browser-use agent.\n+\t\tConvert these actions into a complete, runnable Playwright Python script.\n+\t\t\n+\t\tThe script should:\n+\t\t1. Include all necessary imports (playwright, asyncio, logging, etc.)\n+\t\t2. Set up the Playwright browser with headless={headless}\n+\t\t3. Implement proper error handling with try/except/finally blocks\n+\t\t4. Use best practices for selectors (prefer stable selectors like text content, role, etc.)\n+\t\t5. Include helpful comments explaining each major step\n+\t\t6. Add Playwright expect assertions after important actions to verify:\n+\t\t   - Page navigation was successful (check URL or page title)\n+\t\t   - Elements are visible before interacting with them\n+\t\t   - Form submissions worked correctly (check for success messages)\n+\t\t   - Expected content appears after actions (verify text is present)\n+\t\t\n+\t\tHere are the actions to convert:\n+\t\t```json\n+\t\t{json.dumps(actions, indent=2, default=str)}\n+\t\t```\n+\t\t\n+\t\tThe browser-use actions may not map directly to Playwright commands. Here's a guide for common translations:\n+\t\t- go_to_url: page.goto(url)\n+\t\t- click_element_by_index: Find the element using a selector and click it\n+\t\t- input_text: page.fill(selector, text) or page.type(selector, text)\n+\t\t- extract_text: page.text_content(selector)\n+\t\t- scroll: page.mouse.wheel(delta_x, delta_y) or other scroll methods\n+\t\t\n+\t\tExamples of expect assertions to include:\n+\t\t- expect(page).to_have_url(\"https://example.com/expected-page\")\n+\t\t- expect(page.locator(\"text=Success\")).to_be_visible()\n+\t\t- expect(page.locator(\"#item-count\")).to_have_text(\"1 item\")\n+\t\t- expect(page.locator(\"button:has-text('Submit')\")).to_be_enabled()\n+\t\t\n+\t\tProvide ONLY the complete Python script without any explanations.\n+\t\t\"\"\"\n+\n+\t\t# Create a system message to set the LLM's role and expertise context\n+\t\t# This helps guide the LLM to generate high-quality Playwright scripts\n+\t\tsystem_message = SystemMessage(\n+\t\t\tcontent='You are an expert Playwright automation developer with deep knowledge of web testing best practices.'\n+\t\t)\n+\n+\t\t# Create a human message containing our detailed prompt with instructions and examples\n+\t\thuman_message = HumanMessage(content=prompt)\n+\n+\t\t# Invoke the LLM asynchronously with both messages\n+\t\t# The system message sets the context, and the human message provides the specific task\n+\t\tlogger.debug('Invoking LLM to generate Playwright script')\n+\t\tresponse = await self.llm.ainvoke([system_message, human_message])\n+\n+\t\t# Extract the script content from the LLM's response\n+\t\t# This will contain the complete Playwright Python script\n+\t\tscript_content = response.content\n+\n+\t\t# Clean up the script to remove any markdown formatting that the LLM might have included\n+\t\t# LLMs often return code in markdown code blocks with ```python and ``` delimiters\n+\t\tlogger.debug('Cleaning up generated script content')\n+\t\tif script_content.startswith('```python'):\n+\t\t\tscript_content = script_content.split('```python', 1)[1]\n+\t\telif script_content.startswith('```'):\n+\t\t\tscript_content = script_content.split('```', 1)[1]\n+\t\tif script_content.endswith('```'):\n+\t\t\tscript_content = script_content.rsplit('```', 1)[0]",
    "repo_full_name": "browser-use/browser-use",
    "discussion_comments": [
      {
        "comment_id": "2131429494",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 1911,
        "pr_file": "browser_use/agent/service.py",
        "discussion_id": "2131429494",
        "commented_code": "@@ -1868,6 +1868,207 @@ async def close(self):\n \t\texcept Exception as e:\n \t\t\tlogger.error(f'Error during cleanup: {e}')\n \n+\tdef extract_playwright_actions(self, output_path: str | Path = None, include_initial_actions: bool = True) -> list[dict]:\n+\t\t\"\"\"\n+\t\tExtract Playwright actions from the agent's history and save as JSON for developer testing.\n+\n+\t\tArgs:\n+\t\t\toutput_path: Optional path to save the extracted actions as JSON\n+\t\t\tinclude_initial_actions: Whether to include initial actions in the extracted list\n+\n+\t\tReturns:\n+\t\t\tList of action dictionaries with action_name, params, and result\n+\t\t\"\"\"\n+\t\tplaywright_actions = []\n+\n+\t\t# First, check if there are any initial actions and we should include them\n+\t\tif include_initial_actions and hasattr(self, 'initial_actions') and self.initial_actions:\n+\t\t\tlogger.debug(f'Including {len(self.initial_actions)} initial actions in Playwright script')\n+\t\t\tfor action in self.initial_actions:\n+\t\t\t\t# Skip None actions to prevent AttributeError\n+\t\t\t\tif action is None:\n+\t\t\t\t\tcontinue\n+\t\t\t\taction_data = action.model_dump(exclude_unset=True)\n+\t\t\t\taction_name = next(iter(action_data.keys()), 'unknown')\n+\t\t\t\tparams = action_data.get(action_name, {})\n+\t\t\t\tplaywright_actions.append(\n+\t\t\t\t\t{\n+\t\t\t\t\t\t'action_name': action_name,\n+\t\t\t\t\t\t'params': params,\n+\t\t\t\t\t\t'result': None,  # Initial actions don't have results in the same format\n+\t\t\t\t\t}\n+\t\t\t\t)\n+\n+\t\t# Then extract actions from history\n+\t\tfor history_item in self.state.history.history:\n+\t\t\tif not history_item.model_output:\n+\t\t\t\tcontinue\n+\t\t\tactions = history_item.model_output.action\n+\t\t\tresults = history_item.result\n+\t\t\tfor i, action in enumerate(actions):\n+\t\t\t\t# Skip None actions to prevent AttributeError\n+\t\t\t\tif action is None:\n+\t\t\t\t\tcontinue\n+\t\t\t\taction_data = action.model_dump(exclude_unset=True)\n+\t\t\t\taction_name = next(iter(action_data.keys()), 'unknown')\n+\t\t\t\tparams = action_data.get(action_name, {})\n+\t\t\t\tresult = None\n+\t\t\t\tif i < len(results):\n+\t\t\t\t\tresult = results[i].model_dump()\n+\t\t\t\tplaywright_actions.append({'action_name': action_name, 'params': params, 'result': result})\n+\n+\t\t# Save to file if output_path is provided and logging level is debug\n+\t\tif output_path and os.environ.get('BROWSER_USE_LOGGING_LEVEL', '').lower() == 'debug':\n+\t\t\tlogger.debug(f'Saving Playwright actions to {output_path} (debug mode enabled)')\n+\t\t\tpath_obj = Path(output_path)\n+\t\t\tpath_obj.parent.mkdir(parents=True, exist_ok=True)\n+\t\t\twith open(path_obj, 'w', encoding='utf-8') as f:\n+\t\t\t\tjson.dump(playwright_actions, f, indent=2, default=str)\n+\n+\t\treturn playwright_actions\n+\n+\tasync def generate_playwright_script(\n+\t\tself, actions: list[dict] = None, output_path: str | Path = None, headless: bool = False, script_name: str = None\n+\t) -> str:\n+\t\t\"\"\"\n+\t\tGenerate a Playwright script from the extracted actions using an LLM approach.\n+\n+\t\tThis method takes browser-use actions and converts them into a standalone Playwright script\n+\t\tthat can be run independently. The script includes proper error handling, cleanup, and\n+\t\tPlaywright expect assertions for validation.\n+\n+\t\tArgs:\n+\t\t\tactions: List of action dictionaries. If None, will extract actions from history.\n+\t\t\toutput_path: Path to save the generated script. If None, will generate a path.\n+\t\t\theadless: Whether to run the browser in headless mode in the generated script\n+\t\t\tscript_name: Custom name for the script file. If None, will generate from task.\n+\n+\t\tReturns:\n+\t\t\tThe generated Playwright script as a string\n+\t\t\"\"\"\n+\t\t# If actions not provided, extract them from history\n+\t\tif actions is None:\n+\t\t\tactions = self.extract_playwright_actions()\n+\n+\t\tif not actions:\n+\t\t\tlogger.warning('No actions found in history to generate Playwright script')\n+\t\t\treturn ''\n+\n+\t\t# Generate a default output path if none provided\n+\t\tif output_path is None:\n+\t\t\t# Create a timestamp for uniqueness\n+\t\t\ttimestamp = time.strftime('%Y%m%d_%H%M%S')\n+\n+\t\t\t# Generate a name from the task if not provided\n+\t\t\tif script_name is None:\n+\t\t\t\t# Extract a short name from the task description\n+\t\t\t\ttask_words = self.task.lower().split()\n+\t\t\t\t# Use first 5 words or fewer if task is shorter\n+\t\t\t\tword_limit = min(5, len(task_words))\n+\t\t\t\tscript_name = '_'.join(task_words[:word_limit]).replace('https://', '').replace('/', '_')\n+\t\t\t\t# Clean up the name to be filesystem-friendly\n+\t\t\t\tscript_name = re.sub(r'[^\\w\\-_.]', '_', script_name)\n+\t\t\t\t# Truncate if too long\n+\t\t\t\tif len(script_name) > 50:\n+\t\t\t\t\tscript_name = script_name[:50]\n+\n+\t\t\t# Create the output directory at project root\n+\t\t\troot_dir = Path(__file__).parents[2]  # Go up 2 levels from service.py to reach the project root\n+\t\t\toutput_dir = root_dir / 'output' / 'playwright_scripts'\n+\t\t\toutput_dir.mkdir(parents=True, exist_ok=True)\n+\n+\t\t\t# Combine everything into a path\n+\t\t\toutput_path = output_dir / f'{script_name}_{timestamp}.py'\n+\n+\t\t# Prepare the detailed prompt for the LLM\n+\t\t# This prompt is structured to guide the LLM in generating a complete, robust Playwright script\n+\t\t# that includes proper error handling, cleanup, and validation assertions\n+\t\tprompt = f\"\"\"\n+\t\tYou are an expert in converting browser actions to Playwright Python scripts.\n+\t\tBelow is a list of browser actions performed by a browser-use agent.\n+\t\tConvert these actions into a complete, runnable Playwright Python script.\n+\t\t\n+\t\tThe script should:\n+\t\t1. Include all necessary imports (playwright, asyncio, logging, etc.)\n+\t\t2. Set up the Playwright browser with headless={headless}\n+\t\t3. Implement proper error handling with try/except/finally blocks\n+\t\t4. Use best practices for selectors (prefer stable selectors like text content, role, etc.)\n+\t\t5. Include helpful comments explaining each major step\n+\t\t6. Add Playwright expect assertions after important actions to verify:\n+\t\t   - Page navigation was successful (check URL or page title)\n+\t\t   - Elements are visible before interacting with them\n+\t\t   - Form submissions worked correctly (check for success messages)\n+\t\t   - Expected content appears after actions (verify text is present)\n+\t\t\n+\t\tHere are the actions to convert:\n+\t\t```json\n+\t\t{json.dumps(actions, indent=2, default=str)}\n+\t\t```\n+\t\t\n+\t\tThe browser-use actions may not map directly to Playwright commands. Here's a guide for common translations:\n+\t\t- go_to_url: page.goto(url)\n+\t\t- click_element_by_index: Find the element using a selector and click it\n+\t\t- input_text: page.fill(selector, text) or page.type(selector, text)\n+\t\t- extract_text: page.text_content(selector)\n+\t\t- scroll: page.mouse.wheel(delta_x, delta_y) or other scroll methods\n+\t\t\n+\t\tExamples of expect assertions to include:\n+\t\t- expect(page).to_have_url(\"https://example.com/expected-page\")\n+\t\t- expect(page.locator(\"text=Success\")).to_be_visible()\n+\t\t- expect(page.locator(\"#item-count\")).to_have_text(\"1 item\")\n+\t\t- expect(page.locator(\"button:has-text('Submit')\")).to_be_enabled()\n+\t\t\n+\t\tProvide ONLY the complete Python script without any explanations.\n+\t\t\"\"\"\n+\n+\t\t# Create a system message to set the LLM's role and expertise context\n+\t\t# This helps guide the LLM to generate high-quality Playwright scripts\n+\t\tsystem_message = SystemMessage(\n+\t\t\tcontent='You are an expert Playwright automation developer with deep knowledge of web testing best practices.'\n+\t\t)\n+\n+\t\t# Create a human message containing our detailed prompt with instructions and examples\n+\t\thuman_message = HumanMessage(content=prompt)\n+\n+\t\t# Invoke the LLM asynchronously with both messages\n+\t\t# The system message sets the context, and the human message provides the specific task\n+\t\tlogger.debug('Invoking LLM to generate Playwright script')\n+\t\tresponse = await self.llm.ainvoke([system_message, human_message])\n+\n+\t\t# Extract the script content from the LLM's response\n+\t\t# This will contain the complete Playwright Python script\n+\t\tscript_content = response.content\n+\n+\t\t# Clean up the script to remove any markdown formatting that the LLM might have included\n+\t\t# LLMs often return code in markdown code blocks with ```python and ``` delimiters\n+\t\tlogger.debug('Cleaning up generated script content')\n+\t\tif script_content.startswith('```python'):\n+\t\t\tscript_content = script_content.split('```python', 1)[1]\n+\t\telif script_content.startswith('```'):\n+\t\t\tscript_content = script_content.split('```', 1)[1]\n+\t\tif script_content.endswith('```'):\n+\t\t\tscript_content = script_content.rsplit('```', 1)[0]",
        "comment_created_at": "2025-06-06T03:18:38+00:00",
        "comment_author": "servusdei2018",
        "comment_body": "```diff\r\n- if script_content.startswith('```python'):\r\n-     script_content = script_content.split('```python', 1)[1]\r\n- elif script_content.startswith('```'):\r\n-     script_content = script_content.split('```', 1)[1]\r\n- if script_content.endswith('```'):\r\n-     script_content = script_content.rsplit('```', 1)[0]\r\n+ script_content = script_content.replace('```python', '').replace('```', '')\r\n```\r\n\r\nThis could be a oneliner, and prevents a possible `IndexError`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2131640444",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 1911,
        "pr_file": "browser_use/agent/service.py",
        "discussion_id": "2131429494",
        "commented_code": "@@ -1868,6 +1868,207 @@ async def close(self):\n \t\texcept Exception as e:\n \t\t\tlogger.error(f'Error during cleanup: {e}')\n \n+\tdef extract_playwright_actions(self, output_path: str | Path = None, include_initial_actions: bool = True) -> list[dict]:\n+\t\t\"\"\"\n+\t\tExtract Playwright actions from the agent's history and save as JSON for developer testing.\n+\n+\t\tArgs:\n+\t\t\toutput_path: Optional path to save the extracted actions as JSON\n+\t\t\tinclude_initial_actions: Whether to include initial actions in the extracted list\n+\n+\t\tReturns:\n+\t\t\tList of action dictionaries with action_name, params, and result\n+\t\t\"\"\"\n+\t\tplaywright_actions = []\n+\n+\t\t# First, check if there are any initial actions and we should include them\n+\t\tif include_initial_actions and hasattr(self, 'initial_actions') and self.initial_actions:\n+\t\t\tlogger.debug(f'Including {len(self.initial_actions)} initial actions in Playwright script')\n+\t\t\tfor action in self.initial_actions:\n+\t\t\t\t# Skip None actions to prevent AttributeError\n+\t\t\t\tif action is None:\n+\t\t\t\t\tcontinue\n+\t\t\t\taction_data = action.model_dump(exclude_unset=True)\n+\t\t\t\taction_name = next(iter(action_data.keys()), 'unknown')\n+\t\t\t\tparams = action_data.get(action_name, {})\n+\t\t\t\tplaywright_actions.append(\n+\t\t\t\t\t{\n+\t\t\t\t\t\t'action_name': action_name,\n+\t\t\t\t\t\t'params': params,\n+\t\t\t\t\t\t'result': None,  # Initial actions don't have results in the same format\n+\t\t\t\t\t}\n+\t\t\t\t)\n+\n+\t\t# Then extract actions from history\n+\t\tfor history_item in self.state.history.history:\n+\t\t\tif not history_item.model_output:\n+\t\t\t\tcontinue\n+\t\t\tactions = history_item.model_output.action\n+\t\t\tresults = history_item.result\n+\t\t\tfor i, action in enumerate(actions):\n+\t\t\t\t# Skip None actions to prevent AttributeError\n+\t\t\t\tif action is None:\n+\t\t\t\t\tcontinue\n+\t\t\t\taction_data = action.model_dump(exclude_unset=True)\n+\t\t\t\taction_name = next(iter(action_data.keys()), 'unknown')\n+\t\t\t\tparams = action_data.get(action_name, {})\n+\t\t\t\tresult = None\n+\t\t\t\tif i < len(results):\n+\t\t\t\t\tresult = results[i].model_dump()\n+\t\t\t\tplaywright_actions.append({'action_name': action_name, 'params': params, 'result': result})\n+\n+\t\t# Save to file if output_path is provided and logging level is debug\n+\t\tif output_path and os.environ.get('BROWSER_USE_LOGGING_LEVEL', '').lower() == 'debug':\n+\t\t\tlogger.debug(f'Saving Playwright actions to {output_path} (debug mode enabled)')\n+\t\t\tpath_obj = Path(output_path)\n+\t\t\tpath_obj.parent.mkdir(parents=True, exist_ok=True)\n+\t\t\twith open(path_obj, 'w', encoding='utf-8') as f:\n+\t\t\t\tjson.dump(playwright_actions, f, indent=2, default=str)\n+\n+\t\treturn playwright_actions\n+\n+\tasync def generate_playwright_script(\n+\t\tself, actions: list[dict] = None, output_path: str | Path = None, headless: bool = False, script_name: str = None\n+\t) -> str:\n+\t\t\"\"\"\n+\t\tGenerate a Playwright script from the extracted actions using an LLM approach.\n+\n+\t\tThis method takes browser-use actions and converts them into a standalone Playwright script\n+\t\tthat can be run independently. The script includes proper error handling, cleanup, and\n+\t\tPlaywright expect assertions for validation.\n+\n+\t\tArgs:\n+\t\t\tactions: List of action dictionaries. If None, will extract actions from history.\n+\t\t\toutput_path: Path to save the generated script. If None, will generate a path.\n+\t\t\theadless: Whether to run the browser in headless mode in the generated script\n+\t\t\tscript_name: Custom name for the script file. If None, will generate from task.\n+\n+\t\tReturns:\n+\t\t\tThe generated Playwright script as a string\n+\t\t\"\"\"\n+\t\t# If actions not provided, extract them from history\n+\t\tif actions is None:\n+\t\t\tactions = self.extract_playwright_actions()\n+\n+\t\tif not actions:\n+\t\t\tlogger.warning('No actions found in history to generate Playwright script')\n+\t\t\treturn ''\n+\n+\t\t# Generate a default output path if none provided\n+\t\tif output_path is None:\n+\t\t\t# Create a timestamp for uniqueness\n+\t\t\ttimestamp = time.strftime('%Y%m%d_%H%M%S')\n+\n+\t\t\t# Generate a name from the task if not provided\n+\t\t\tif script_name is None:\n+\t\t\t\t# Extract a short name from the task description\n+\t\t\t\ttask_words = self.task.lower().split()\n+\t\t\t\t# Use first 5 words or fewer if task is shorter\n+\t\t\t\tword_limit = min(5, len(task_words))\n+\t\t\t\tscript_name = '_'.join(task_words[:word_limit]).replace('https://', '').replace('/', '_')\n+\t\t\t\t# Clean up the name to be filesystem-friendly\n+\t\t\t\tscript_name = re.sub(r'[^\\w\\-_.]', '_', script_name)\n+\t\t\t\t# Truncate if too long\n+\t\t\t\tif len(script_name) > 50:\n+\t\t\t\t\tscript_name = script_name[:50]\n+\n+\t\t\t# Create the output directory at project root\n+\t\t\troot_dir = Path(__file__).parents[2]  # Go up 2 levels from service.py to reach the project root\n+\t\t\toutput_dir = root_dir / 'output' / 'playwright_scripts'\n+\t\t\toutput_dir.mkdir(parents=True, exist_ok=True)\n+\n+\t\t\t# Combine everything into a path\n+\t\t\toutput_path = output_dir / f'{script_name}_{timestamp}.py'\n+\n+\t\t# Prepare the detailed prompt for the LLM\n+\t\t# This prompt is structured to guide the LLM in generating a complete, robust Playwright script\n+\t\t# that includes proper error handling, cleanup, and validation assertions\n+\t\tprompt = f\"\"\"\n+\t\tYou are an expert in converting browser actions to Playwright Python scripts.\n+\t\tBelow is a list of browser actions performed by a browser-use agent.\n+\t\tConvert these actions into a complete, runnable Playwright Python script.\n+\t\t\n+\t\tThe script should:\n+\t\t1. Include all necessary imports (playwright, asyncio, logging, etc.)\n+\t\t2. Set up the Playwright browser with headless={headless}\n+\t\t3. Implement proper error handling with try/except/finally blocks\n+\t\t4. Use best practices for selectors (prefer stable selectors like text content, role, etc.)\n+\t\t5. Include helpful comments explaining each major step\n+\t\t6. Add Playwright expect assertions after important actions to verify:\n+\t\t   - Page navigation was successful (check URL or page title)\n+\t\t   - Elements are visible before interacting with them\n+\t\t   - Form submissions worked correctly (check for success messages)\n+\t\t   - Expected content appears after actions (verify text is present)\n+\t\t\n+\t\tHere are the actions to convert:\n+\t\t```json\n+\t\t{json.dumps(actions, indent=2, default=str)}\n+\t\t```\n+\t\t\n+\t\tThe browser-use actions may not map directly to Playwright commands. Here's a guide for common translations:\n+\t\t- go_to_url: page.goto(url)\n+\t\t- click_element_by_index: Find the element using a selector and click it\n+\t\t- input_text: page.fill(selector, text) or page.type(selector, text)\n+\t\t- extract_text: page.text_content(selector)\n+\t\t- scroll: page.mouse.wheel(delta_x, delta_y) or other scroll methods\n+\t\t\n+\t\tExamples of expect assertions to include:\n+\t\t- expect(page).to_have_url(\"https://example.com/expected-page\")\n+\t\t- expect(page.locator(\"text=Success\")).to_be_visible()\n+\t\t- expect(page.locator(\"#item-count\")).to_have_text(\"1 item\")\n+\t\t- expect(page.locator(\"button:has-text('Submit')\")).to_be_enabled()\n+\t\t\n+\t\tProvide ONLY the complete Python script without any explanations.\n+\t\t\"\"\"\n+\n+\t\t# Create a system message to set the LLM's role and expertise context\n+\t\t# This helps guide the LLM to generate high-quality Playwright scripts\n+\t\tsystem_message = SystemMessage(\n+\t\t\tcontent='You are an expert Playwright automation developer with deep knowledge of web testing best practices.'\n+\t\t)\n+\n+\t\t# Create a human message containing our detailed prompt with instructions and examples\n+\t\thuman_message = HumanMessage(content=prompt)\n+\n+\t\t# Invoke the LLM asynchronously with both messages\n+\t\t# The system message sets the context, and the human message provides the specific task\n+\t\tlogger.debug('Invoking LLM to generate Playwright script')\n+\t\tresponse = await self.llm.ainvoke([system_message, human_message])\n+\n+\t\t# Extract the script content from the LLM's response\n+\t\t# This will contain the complete Playwright Python script\n+\t\tscript_content = response.content\n+\n+\t\t# Clean up the script to remove any markdown formatting that the LLM might have included\n+\t\t# LLMs often return code in markdown code blocks with ```python and ``` delimiters\n+\t\tlogger.debug('Cleaning up generated script content')\n+\t\tif script_content.startswith('```python'):\n+\t\t\tscript_content = script_content.split('```python', 1)[1]\n+\t\telif script_content.startswith('```'):\n+\t\t\tscript_content = script_content.split('```', 1)[1]\n+\t\tif script_content.endswith('```'):\n+\t\t\tscript_content = script_content.rsplit('```', 1)[0]",
        "comment_created_at": "2025-06-06T07:08:46+00:00",
        "comment_author": "ThusharaJ",
        "comment_body": "@servusdei2018 thanx for the comment. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2052685340",
    "pr_number": 1437,
    "pr_file": "browser_use/agent/playwright_script_generator.py",
    "created_at": "2025-04-21T17:00:32+00:00",
    "commented_code": "+import json\n+import logging\n+import os # Added os import\n+from typing import List, Optional, Dict, Any\n+\n+# Import necessary config types\n+from browser_use.browser.browser import BrowserConfig\n+from browser_use.browser.context import BrowserContextConfig\n+# --- End Import ---\n+\n+logger = logging.getLogger(__name__)\n+\n+# Define a custom exception for action failures within the generated script\n+class PlaywrightActionError(Exception):\n+    \"\"\"Custom exception for errors during Playwright script action execution.\"\"\"\n+    pass\n+\n+class PlaywrightScriptGenerator:\n+    \"\"\"Generates a Playwright script from AgentHistoryList.\"\"\"\n+\n+    def __init__(\n+        self,\n+        history_list: List[Dict[str, Any]],\n+        sensitive_data_keys: Optional[List[str]] = None,\n+        browser_config: Optional[BrowserConfig] = None,\n+        context_config: Optional[BrowserContextConfig] = None,\n+    ):\n+        \"\"\"\n+        Initializes the script generator.\n+\n+        Args:\n+            history_list: A list of dictionaries, where each dictionary represents an AgentHistory item.\n+                         Expected to be raw dictionaries from `AgentHistoryList.model_dump()`.\n+            sensitive_data_keys: A list of keys used as placeholders for sensitive data.\n+            browser_config: Configuration from the original Browser instance.\n+            context_config: Configuration from the original BrowserContext instance.\n+        \"\"\"\n+        self.history = history_list\n+        self.sensitive_data_keys = sensitive_data_keys or []\n+        self.browser_config = browser_config\n+        self.context_config = context_config\n+        self._imports_helpers_added = False\n+        self._page_counter = 0 # Track pages for tab management\n+\n+    def _generate_browser_launch_args(self) -> str:\n+        \"\"\"Generates the arguments string for browser launch based on BrowserConfig.\"\"\"\n+        if not self.browser_config:\n+            # Default launch if no config provided\n+            return \"headless=False\"\n+\n+        args_dict = {\n+            \"headless\": self.browser_config.headless,\n+            # Add other relevant launch options here based on self.browser_config\n+            # Example: 'proxy': self.browser_config.proxy.model_dump() if self.browser_config.proxy else None\n+            # Example: 'args': self.browser_config.extra_browser_args # Be careful inheriting args\n+        }\n+        if self.browser_config.proxy:\n+            args_dict[\"proxy\"] = self.browser_config.proxy.model_dump()\n+\n+        # Filter out None values\n+        args_dict = {k: v for k, v in args_dict.items() if v is not None}\n+\n+        # Format as keyword arguments string\n+        args_str = \", \".join(f\"{key}={repr(value)}\" for key, value in args_dict.items())\n+        return args_str\n+\n+    def _generate_context_options(self) -> str:\n+        \"\"\"Generates the options string for context creation based on BrowserContextConfig.\"\"\"\n+        if not self.context_config:\n+            return \"\" # Default context\n+\n+        options_dict = {}\n+\n+        # Map relevant BrowserContextConfig fields to Playwright context options\n+        if self.context_config.user_agent:\n+            options_dict[\"user_agent\"] = self.context_config.user_agent\n+        if self.context_config.locale:\n+            options_dict[\"locale\"] = self.context_config.locale\n+        if self.context_config.permissions:\n+            options_dict[\"permissions\"] = self.context_config.permissions\n+        if self.context_config.geolocation:\n+            options_dict[\"geolocation\"] = self.context_config.geolocation\n+        if self.context_config.timezone_id:\n+            options_dict[\"timezone_id\"] = self.context_config.timezone_id\n+        if self.context_config.http_credentials:\n+            options_dict[\"http_credentials\"] = self.context_config.http_credentials\n+        if self.context_config.is_mobile is not None:\n+            options_dict[\"is_mobile\"] = self.context_config.is_mobile\n+        if self.context_config.has_touch is not None:\n+            options_dict[\"has_touch\"] = self.context_config.has_touch\n+        if self.context_config.save_recording_path:\n+             options_dict[\"record_video_dir\"] = self.context_config.save_recording_path\n+        if self.context_config.save_har_path:\n+             options_dict[\"record_har_path\"] = self.context_config.save_har_path\n+\n+        # Handle viewport/window size\n+        if self.context_config.no_viewport:\n+            options_dict[\"no_viewport\"] = True\n+        elif self.context_config.browser_window_size:\n+            options_dict[\"viewport\"] = {\n+                \"width\": self.context_config.browser_window_size.width,\n+                \"height\": self.context_config.browser_window_size.height\n+            }\n+\n+        # Note: cookies_file and save_downloads_path are handled separately\n+\n+        # Filter out None values\n+        options_dict = {k: v for k, v in options_dict.items() if v is not None}\n+\n+        # Format as keyword arguments string\n+        options_str = \", \".join(f\"{key}={repr(value)}\" for key, value in options_dict.items())\n+        return options_str\n+\n+    def _get_imports_and_helpers(self) -> List[str]:\n+        \"\"\"Generates necessary import statements and helper functions.\"\"\"\n+        # Updated _try_locate_and_act to raise PlaywrightActionError on failure\n+        try_locate_and_act_code = \"\"\"\n+class PlaywrightActionError(Exception):\n+    \\\"\\\"\\\"Custom exception for errors during Playwright script action execution.\\\"\\\"\\\"\n+    pass\n+\n+async def _try_locate_and_act(page: Page, selector: str, action_type: str, text: str | None = None, step_info: str = '') -> None:\n+    \\\"\\\"\\\"\n+    Attempts an action (click/fill) with XPath fallback by trimming prefixes.\n+    Raises PlaywrightActionError if the action fails after all fallbacks.\n+    \\\"\\\"\\\"\n+    print(f\"Attempting {action_type} ({step_info}) using selector: {repr(selector)}\")\n+    original_selector = selector\n+    MAX_FALLBACKS = 50 # Increased fallbacks\n+    # Increased timeouts for potentially slow pages\n+    INITIAL_TIMEOUT = 10000 # Milliseconds for the first attempt (10 seconds)\n+    FALLBACK_TIMEOUT = 1000 # Shorter timeout for fallback attempts (1 second)\n+\n+    try:\n+        locator = page.locator(selector).first\n+        if action_type == 'click':\n+            await locator.click(timeout=INITIAL_TIMEOUT)\n+        elif action_type == 'fill' and text is not None:\n+            await locator.fill(text, timeout=INITIAL_TIMEOUT)\n+        else:\n+            # This case should ideally not happen if called correctly\n+            raise PlaywrightActionError(f\"Invalid action_type '{action_type}' or missing text for fill. ({step_info})\")\n+        print(f\"  Action '{action_type}' successful with original selector.\")\n+        await page.wait_for_timeout(500) # Wait after successful action\n+        return # Successful exit\n+    except Exception as e:\n+        print(f\"  Warning: Action '{action_type}' failed with original selector ({repr(selector)}): {e}. Starting fallback...\")\n+\n+        # Fallback only works for XPath selectors\n+        if not selector.startswith('xpath='):\n+            # Raise error immediately if not XPath, as fallback won't work\n+            raise PlaywrightActionError(f\"Action '{action_type}' failed. Fallback not possible for non-XPath selector: {repr(selector)}. ({step_info})\")\n+\n+        xpath_parts = selector.split('=', 1)\n+        if len(xpath_parts) < 2:\n+             raise PlaywrightActionError(f\"Action '{action_type}' failed. Could not extract XPath string from selector: {repr(selector)}. ({step_info})\")\n+        xpath = xpath_parts[1] # Correctly get the XPath string\n+\n+        segments = [seg for seg in xpath.split('/') if seg]\n+\n+        for i in range(1, min(MAX_FALLBACKS + 1, len(segments))):\n+            trimmed_xpath_raw = '/'.join(segments[i:])\n+            fallback_xpath = f'xpath=//{trimmed_xpath_raw}'\n+\n+            print(f'    Fallback attempt {i}/{MAX_FALLBACKS}: Trying selector: {repr(fallback_xpath)}')\n+            try:\n+                locator = page.locator(fallback_xpath).first\n+                if action_type == 'click':\n+                     await locator.click(timeout=FALLBACK_TIMEOUT)\n+                elif action_type == 'fill' and text is not None:\n+                    try:\n+                        await locator.clear(timeout=FALLBACK_TIMEOUT)\n+                        await page.wait_for_timeout(100)\n+                    except Exception as clear_error:\n+                         print(f\"    Warning: Failed to clear field during fallback ({step_info}): {clear_error}\")\n+                    await locator.fill(text, timeout=FALLBACK_TIMEOUT)\n+\n+                print(f\"    Action '{action_type}' successful with fallback selector: {repr(fallback_xpath)}\")\n+                await page.wait_for_timeout(500)\n+                return # Successful exit after fallback\n+            except Exception as fallback_e:\n+                print(f'    Fallback attempt {i} failed: {fallback_e}')\n+                if i == MAX_FALLBACKS:\n+                    # Raise exception after exhausting fallbacks\n+                    raise PlaywrightActionError(f\"Action '{action_type}' failed after {MAX_FALLBACKS} fallback attempts. Original selector: {repr(original_selector)}. ({step_info})\")\n+\n+    # This part should not be reachable if logic is correct, but added as safeguard\n+    raise PlaywrightActionError(f\"Action '{action_type}' failed unexpectedly for {repr(original_selector)}. ({step_info})\")\n+\n+\"\"\"\n+        return [\n+            \"import asyncio\",\n+            \"import json\",\n+            \"import os\",\n+            \"import sys\",\n+            \"from pathlib import Path\", # Added Path import\n+            \"import urllib.parse\", # Needed for search_google\n+            \"from playwright.async_api import async_playwright, Page, BrowserContext\", # Added BrowserContext\n+            \"from dotenv import load_dotenv\",\n+            \"\",\n+            \"# Load environment variables\",\n+            \"load_dotenv(override=True)\",\n+            \"\",\n+            \"# --- Helper Function for Replacing Sensitive Data ---\",\n+            \"def replace_sensitive_data(text: str, sensitive_map: dict) -> str:\",\n+            '    \"\"\"Replaces sensitive data placeholders in text.\"\"\"',\n+            \"    if not isinstance(text, str): return text\",\n+            \"    for placeholder, value in sensitive_map.items():\",\n+            \"        replacement_value = str(value) if value is not None else ''\",\n+            \"        text = text.replace(f'<secret>{placeholder}</secret>', replacement_value)\",\n+            \"    return text\",\n+            \"\",\n+            \"# --- Helper Function for Robust Action Execution ---\",\n+            try_locate_and_act_code, # Include the updated helper\n+            \"\"\n+        ]\n+\n+    def _get_sensitive_data_definitions(self) -> List[str]:\n+        \"\"\"Generates the SENSITIVE_DATA dictionary definition.\"\"\"\n+        if not self.sensitive_data_keys:\n+            return [\"SENSITIVE_DATA = {}\", \"\"]\n+\n+        lines = [\"# Sensitive data placeholders mapped to environment variables\"]\n+        lines.append(\"SENSITIVE_DATA = {\")\n+        for key in self.sensitive_data_keys:\n+            env_var_name = key.upper()\n+            default_value_placeholder = f'YOUR_{env_var_name}'\n+            lines.append(f'    \"{key}\": os.getenv(\"{env_var_name}\", {json.dumps(default_value_placeholder)}),')\n+        lines.append(\"}\")\n+        lines.append(\"\")\n+        return lines\n+\n+    def _get_selector_for_action(self, history_item: dict, action_index_in_step: int) -> Optional[str]:\n+        \"\"\"\n+        Gets the selector (preferring XPath) for a given action index within a history step.\n+        Formats the XPath correctly for Playwright.\n+        \"\"\"\n+        state = history_item.get('state')\n+        if not isinstance(state, dict): return None\n+        interacted_elements = state.get('interacted_element')\n+        if not isinstance(interacted_elements, list): return None\n+        if action_index_in_step >= len(interacted_elements): return None\n+        element_data = interacted_elements[action_index_in_step]\n+        if not isinstance(element_data, dict): return None\n+\n+        # Prioritize XPath\n+        xpath = element_data.get('xpath')\n+        if isinstance(xpath, str) and xpath.strip():\n+            if not xpath.startswith('xpath=') and not xpath.startswith('/') and not xpath.startswith('//'):\n+                xpath_selector = f'xpath=//{xpath}' # Make relative if not already\n+            elif not xpath.startswith('xpath='):\n+                xpath_selector = f'xpath={xpath}' # Add prefix if missing\n+            else:\n+                xpath_selector = xpath\n+            return xpath_selector\n+\n+        # Fallback to CSS selector if XPath is missing\n+        css_selector = element_data.get('css_selector')\n+        if isinstance(css_selector, str) and css_selector.strip():\n+             return css_selector # Use CSS selector as is\n+\n+        logger.warning(f\"Could not find a usable XPath or CSS selector for action index {action_index_in_step} (element index {element_data.get('highlight_index', 'N/A')}).\")\n+        return None\n+\n+    def _map_action_to_playwright(self, action_dict: dict, history_item: dict, previous_history_item: Optional[dict], action_index_in_step: int, step_info_str: str) -> List[str]:",
    "repo_full_name": "browser-use/browser-use",
    "discussion_comments": [
      {
        "comment_id": "2052717683",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 1437,
        "pr_file": "browser_use/agent/playwright_script_generator.py",
        "discussion_id": "2052685340",
        "commented_code": "@@ -0,0 +1,686 @@\n+import json\n+import logging\n+import os # Added os import\n+from typing import List, Optional, Dict, Any\n+\n+# Import necessary config types\n+from browser_use.browser.browser import BrowserConfig\n+from browser_use.browser.context import BrowserContextConfig\n+# --- End Import ---\n+\n+logger = logging.getLogger(__name__)\n+\n+# Define a custom exception for action failures within the generated script\n+class PlaywrightActionError(Exception):\n+    \"\"\"Custom exception for errors during Playwright script action execution.\"\"\"\n+    pass\n+\n+class PlaywrightScriptGenerator:\n+    \"\"\"Generates a Playwright script from AgentHistoryList.\"\"\"\n+\n+    def __init__(\n+        self,\n+        history_list: List[Dict[str, Any]],\n+        sensitive_data_keys: Optional[List[str]] = None,\n+        browser_config: Optional[BrowserConfig] = None,\n+        context_config: Optional[BrowserContextConfig] = None,\n+    ):\n+        \"\"\"\n+        Initializes the script generator.\n+\n+        Args:\n+            history_list: A list of dictionaries, where each dictionary represents an AgentHistory item.\n+                         Expected to be raw dictionaries from `AgentHistoryList.model_dump()`.\n+            sensitive_data_keys: A list of keys used as placeholders for sensitive data.\n+            browser_config: Configuration from the original Browser instance.\n+            context_config: Configuration from the original BrowserContext instance.\n+        \"\"\"\n+        self.history = history_list\n+        self.sensitive_data_keys = sensitive_data_keys or []\n+        self.browser_config = browser_config\n+        self.context_config = context_config\n+        self._imports_helpers_added = False\n+        self._page_counter = 0 # Track pages for tab management\n+\n+    def _generate_browser_launch_args(self) -> str:\n+        \"\"\"Generates the arguments string for browser launch based on BrowserConfig.\"\"\"\n+        if not self.browser_config:\n+            # Default launch if no config provided\n+            return \"headless=False\"\n+\n+        args_dict = {\n+            \"headless\": self.browser_config.headless,\n+            # Add other relevant launch options here based on self.browser_config\n+            # Example: 'proxy': self.browser_config.proxy.model_dump() if self.browser_config.proxy else None\n+            # Example: 'args': self.browser_config.extra_browser_args # Be careful inheriting args\n+        }\n+        if self.browser_config.proxy:\n+            args_dict[\"proxy\"] = self.browser_config.proxy.model_dump()\n+\n+        # Filter out None values\n+        args_dict = {k: v for k, v in args_dict.items() if v is not None}\n+\n+        # Format as keyword arguments string\n+        args_str = \", \".join(f\"{key}={repr(value)}\" for key, value in args_dict.items())\n+        return args_str\n+\n+    def _generate_context_options(self) -> str:\n+        \"\"\"Generates the options string for context creation based on BrowserContextConfig.\"\"\"\n+        if not self.context_config:\n+            return \"\" # Default context\n+\n+        options_dict = {}\n+\n+        # Map relevant BrowserContextConfig fields to Playwright context options\n+        if self.context_config.user_agent:\n+            options_dict[\"user_agent\"] = self.context_config.user_agent\n+        if self.context_config.locale:\n+            options_dict[\"locale\"] = self.context_config.locale\n+        if self.context_config.permissions:\n+            options_dict[\"permissions\"] = self.context_config.permissions\n+        if self.context_config.geolocation:\n+            options_dict[\"geolocation\"] = self.context_config.geolocation\n+        if self.context_config.timezone_id:\n+            options_dict[\"timezone_id\"] = self.context_config.timezone_id\n+        if self.context_config.http_credentials:\n+            options_dict[\"http_credentials\"] = self.context_config.http_credentials\n+        if self.context_config.is_mobile is not None:\n+            options_dict[\"is_mobile\"] = self.context_config.is_mobile\n+        if self.context_config.has_touch is not None:\n+            options_dict[\"has_touch\"] = self.context_config.has_touch\n+        if self.context_config.save_recording_path:\n+             options_dict[\"record_video_dir\"] = self.context_config.save_recording_path\n+        if self.context_config.save_har_path:\n+             options_dict[\"record_har_path\"] = self.context_config.save_har_path\n+\n+        # Handle viewport/window size\n+        if self.context_config.no_viewport:\n+            options_dict[\"no_viewport\"] = True\n+        elif self.context_config.browser_window_size:\n+            options_dict[\"viewport\"] = {\n+                \"width\": self.context_config.browser_window_size.width,\n+                \"height\": self.context_config.browser_window_size.height\n+            }\n+\n+        # Note: cookies_file and save_downloads_path are handled separately\n+\n+        # Filter out None values\n+        options_dict = {k: v for k, v in options_dict.items() if v is not None}\n+\n+        # Format as keyword arguments string\n+        options_str = \", \".join(f\"{key}={repr(value)}\" for key, value in options_dict.items())\n+        return options_str\n+\n+    def _get_imports_and_helpers(self) -> List[str]:\n+        \"\"\"Generates necessary import statements and helper functions.\"\"\"\n+        # Updated _try_locate_and_act to raise PlaywrightActionError on failure\n+        try_locate_and_act_code = \"\"\"\n+class PlaywrightActionError(Exception):\n+    \\\"\\\"\\\"Custom exception for errors during Playwright script action execution.\\\"\\\"\\\"\n+    pass\n+\n+async def _try_locate_and_act(page: Page, selector: str, action_type: str, text: str | None = None, step_info: str = '') -> None:\n+    \\\"\\\"\\\"\n+    Attempts an action (click/fill) with XPath fallback by trimming prefixes.\n+    Raises PlaywrightActionError if the action fails after all fallbacks.\n+    \\\"\\\"\\\"\n+    print(f\"Attempting {action_type} ({step_info}) using selector: {repr(selector)}\")\n+    original_selector = selector\n+    MAX_FALLBACKS = 50 # Increased fallbacks\n+    # Increased timeouts for potentially slow pages\n+    INITIAL_TIMEOUT = 10000 # Milliseconds for the first attempt (10 seconds)\n+    FALLBACK_TIMEOUT = 1000 # Shorter timeout for fallback attempts (1 second)\n+\n+    try:\n+        locator = page.locator(selector).first\n+        if action_type == 'click':\n+            await locator.click(timeout=INITIAL_TIMEOUT)\n+        elif action_type == 'fill' and text is not None:\n+            await locator.fill(text, timeout=INITIAL_TIMEOUT)\n+        else:\n+            # This case should ideally not happen if called correctly\n+            raise PlaywrightActionError(f\"Invalid action_type '{action_type}' or missing text for fill. ({step_info})\")\n+        print(f\"  Action '{action_type}' successful with original selector.\")\n+        await page.wait_for_timeout(500) # Wait after successful action\n+        return # Successful exit\n+    except Exception as e:\n+        print(f\"  Warning: Action '{action_type}' failed with original selector ({repr(selector)}): {e}. Starting fallback...\")\n+\n+        # Fallback only works for XPath selectors\n+        if not selector.startswith('xpath='):\n+            # Raise error immediately if not XPath, as fallback won't work\n+            raise PlaywrightActionError(f\"Action '{action_type}' failed. Fallback not possible for non-XPath selector: {repr(selector)}. ({step_info})\")\n+\n+        xpath_parts = selector.split('=', 1)\n+        if len(xpath_parts) < 2:\n+             raise PlaywrightActionError(f\"Action '{action_type}' failed. Could not extract XPath string from selector: {repr(selector)}. ({step_info})\")\n+        xpath = xpath_parts[1] # Correctly get the XPath string\n+\n+        segments = [seg for seg in xpath.split('/') if seg]\n+\n+        for i in range(1, min(MAX_FALLBACKS + 1, len(segments))):\n+            trimmed_xpath_raw = '/'.join(segments[i:])\n+            fallback_xpath = f'xpath=//{trimmed_xpath_raw}'\n+\n+            print(f'    Fallback attempt {i}/{MAX_FALLBACKS}: Trying selector: {repr(fallback_xpath)}')\n+            try:\n+                locator = page.locator(fallback_xpath).first\n+                if action_type == 'click':\n+                     await locator.click(timeout=FALLBACK_TIMEOUT)\n+                elif action_type == 'fill' and text is not None:\n+                    try:\n+                        await locator.clear(timeout=FALLBACK_TIMEOUT)\n+                        await page.wait_for_timeout(100)\n+                    except Exception as clear_error:\n+                         print(f\"    Warning: Failed to clear field during fallback ({step_info}): {clear_error}\")\n+                    await locator.fill(text, timeout=FALLBACK_TIMEOUT)\n+\n+                print(f\"    Action '{action_type}' successful with fallback selector: {repr(fallback_xpath)}\")\n+                await page.wait_for_timeout(500)\n+                return # Successful exit after fallback\n+            except Exception as fallback_e:\n+                print(f'    Fallback attempt {i} failed: {fallback_e}')\n+                if i == MAX_FALLBACKS:\n+                    # Raise exception after exhausting fallbacks\n+                    raise PlaywrightActionError(f\"Action '{action_type}' failed after {MAX_FALLBACKS} fallback attempts. Original selector: {repr(original_selector)}. ({step_info})\")\n+\n+    # This part should not be reachable if logic is correct, but added as safeguard\n+    raise PlaywrightActionError(f\"Action '{action_type}' failed unexpectedly for {repr(original_selector)}. ({step_info})\")\n+\n+\"\"\"\n+        return [\n+            \"import asyncio\",\n+            \"import json\",\n+            \"import os\",\n+            \"import sys\",\n+            \"from pathlib import Path\", # Added Path import\n+            \"import urllib.parse\", # Needed for search_google\n+            \"from playwright.async_api import async_playwright, Page, BrowserContext\", # Added BrowserContext\n+            \"from dotenv import load_dotenv\",\n+            \"\",\n+            \"# Load environment variables\",\n+            \"load_dotenv(override=True)\",\n+            \"\",\n+            \"# --- Helper Function for Replacing Sensitive Data ---\",\n+            \"def replace_sensitive_data(text: str, sensitive_map: dict) -> str:\",\n+            '    \"\"\"Replaces sensitive data placeholders in text.\"\"\"',\n+            \"    if not isinstance(text, str): return text\",\n+            \"    for placeholder, value in sensitive_map.items():\",\n+            \"        replacement_value = str(value) if value is not None else ''\",\n+            \"        text = text.replace(f'<secret>{placeholder}</secret>', replacement_value)\",\n+            \"    return text\",\n+            \"\",\n+            \"# --- Helper Function for Robust Action Execution ---\",\n+            try_locate_and_act_code, # Include the updated helper\n+            \"\"\n+        ]\n+\n+    def _get_sensitive_data_definitions(self) -> List[str]:\n+        \"\"\"Generates the SENSITIVE_DATA dictionary definition.\"\"\"\n+        if not self.sensitive_data_keys:\n+            return [\"SENSITIVE_DATA = {}\", \"\"]\n+\n+        lines = [\"# Sensitive data placeholders mapped to environment variables\"]\n+        lines.append(\"SENSITIVE_DATA = {\")\n+        for key in self.sensitive_data_keys:\n+            env_var_name = key.upper()\n+            default_value_placeholder = f'YOUR_{env_var_name}'\n+            lines.append(f'    \"{key}\": os.getenv(\"{env_var_name}\", {json.dumps(default_value_placeholder)}),')\n+        lines.append(\"}\")\n+        lines.append(\"\")\n+        return lines\n+\n+    def _get_selector_for_action(self, history_item: dict, action_index_in_step: int) -> Optional[str]:\n+        \"\"\"\n+        Gets the selector (preferring XPath) for a given action index within a history step.\n+        Formats the XPath correctly for Playwright.\n+        \"\"\"\n+        state = history_item.get('state')\n+        if not isinstance(state, dict): return None\n+        interacted_elements = state.get('interacted_element')\n+        if not isinstance(interacted_elements, list): return None\n+        if action_index_in_step >= len(interacted_elements): return None\n+        element_data = interacted_elements[action_index_in_step]\n+        if not isinstance(element_data, dict): return None\n+\n+        # Prioritize XPath\n+        xpath = element_data.get('xpath')\n+        if isinstance(xpath, str) and xpath.strip():\n+            if not xpath.startswith('xpath=') and not xpath.startswith('/') and not xpath.startswith('//'):\n+                xpath_selector = f'xpath=//{xpath}' # Make relative if not already\n+            elif not xpath.startswith('xpath='):\n+                xpath_selector = f'xpath={xpath}' # Add prefix if missing\n+            else:\n+                xpath_selector = xpath\n+            return xpath_selector\n+\n+        # Fallback to CSS selector if XPath is missing\n+        css_selector = element_data.get('css_selector')\n+        if isinstance(css_selector, str) and css_selector.strip():\n+             return css_selector # Use CSS selector as is\n+\n+        logger.warning(f\"Could not find a usable XPath or CSS selector for action index {action_index_in_step} (element index {element_data.get('highlight_index', 'N/A')}).\")\n+        return None\n+\n+    def _map_action_to_playwright(self, action_dict: dict, history_item: dict, previous_history_item: Optional[dict], action_index_in_step: int, step_info_str: str) -> List[str]:",
        "comment_created_at": "2025-04-21T17:00:32+00:00",
        "comment_author": "RogelioRichmanAstronaut",
        "comment_body": "This issue has been addressed by refactoring the `_map_action_to_playwright` method.\r\n\r\nA dictionary dispatch pattern was implemented:\r\n- A dictionary `_action_handlers` now maps action type strings to specific handler methods.\r\n- Private helper methods (e.g., `_map_go_to_url`, `_map_input_text`) encapsulate the logic for each action.\r\n- The main `_map_action_to_playwright` method is now significantly shorter, primarily responsible for looking up and calling the correct handler via the dictionary.\r\n\r\nThis resolves the concerns regarding excessive length, maintenance difficulty, and error-proneness associated with the previous large conditional structure.\r\ncommit: fcd334246c77e63a47b75da8b7467becaa958cdc",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2047736261",
    "pr_number": 1395,
    "pr_file": "eval/service.py",
    "created_at": "2025-04-16T20:49:49+00:00",
    "commented_code": "+# ==============================================================================================================\n+# Documentation for this evaluation file.\n+# The import\n+\n+\n+# Here is the command to run the evaluation:\n+# python eval/service.py --parallel_runs 5 --parallel_evaluations 5 --max-steps 25 --start 0 --end 100\n+# options:\n+# --parallel_runs: Number of parallel tasks to run\n+# --max-steps: Maximum steps per task\n+# --start: Start index\n+# --end: End index (exclusive)\n+# --headless: Run in headless mode\n+\n+# Here is the command to run the evaluation only:\n+# python eval/service.py --evaluate-only\n+# options:\n+# --parallel_evaluations: Number of parallel evaluations to run\n+\n+# To run a new evaluation, you need to first clear the saved_trajectories folder.\n+# rm -rf saved_trajectories\n+# Otherwise, the evaluation will continue on from the last saved trajectory.\n+# ==============================================================================================================\n+\n+\n+# ==============================================================================================================\n+# This is the LLM as a judge evaluation system from the OSU-NLP Group paper\n+# Any adaptiations made should be explicitly stated here:\n+# Adaptations:\n+# We are using our langchain wrapper for the OpenAI API\n+# This means we changed model.generate to model.invoke. The behavior of the model should be identical.\n+# Added a Online_Mind2Web_eval_with_retry wrapper with retry logic in case of API rate limiting or other issues.\n+\n+\n+# @article{xue2025illusionprogressassessingcurrent,\n+#       title={An Illusion of Progress? Assessing the Current State of Web Agents},\n+#       author={Tianci Xue and Weijian Qi and Tianneng Shi and Chan Hee Song and Boyu Gou and Dawn Song and Huan Sun and Yu Su},\n+#       year={2025},\n+#       eprint={2504.01382},\n+#       archivePrefix={arXiv},\n+#       primaryClass={cs.AI},\n+#       url={https://arxiv.org/abs/2504.01382},\n+# }\n+\n+# @inproceedings{deng2023mind2web,\n+#  author = {Deng, Xiang and Gu, Yu and Zheng, Boyuan and Chen, Shijie and Stevens, Sam and Wang, Boshi and Sun, Huan and Su, Yu},\n+#  booktitle = {Advances in Neural Information Processing Systems},\n+#  editor = {A. Oh and T. Naumann and A. Globerson and K. Saenko and M. Hardt and S. Levine},\n+#  pages = {28091--28114},\n+#  publisher = {Curran Associates, Inc.},\n+#  title = {Mind2Web: Towards a Generalist Agent for the Web},\n+#  url = {https://proceedings.neurips.cc/paper_files/paper/2023/file/5950bf290a1570ea401bf98882128160-Paper-Datasets_and_Benchmarks.pdf},\n+#  volume = {36},\n+#  year = {2023}\n+# }\n+# ==============================================================================================================\n+import asyncio\n+import base64\n+import io\n+import logging\n+import re\n+\n+from PIL import Image\n+\n+MAX_IMAGE = 5\n+\n+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n+logger = logging.getLogger(__name__)\n+\n+\n+def encode_image(image):\n+\t\"\"\"Convert a PIL image to base64 string.\"\"\"\n+\tif image.mode == 'RGBA':\n+\t\timage = image.convert('RGB')\n+\tbuffered = io.BytesIO()\n+\timage.save(buffered, format='JPEG')\n+\treturn base64.b64encode(buffered.getvalue()).decode('utf-8')\n+\n+\n+async def identify_key_points(task, model):\n+\tsystem_msg = \"\"\"You are an expert tasked with analyzing a given task to identify the key points explicitly stated in the task description.\n+\n+**Objective**: Carefully analyze the task description and extract the critical elements explicitly mentioned in the task for achieving its goal.\n+\n+**Instructions**:\n+1. Read the task description carefully.\n+2. Identify and extract **key points** directly stated in the task description.\n+   - A **key point** is a critical element, condition, or step explicitly mentioned in the task description.\n+   - Do not infer or add any unstated elements.\n+   - Words such as \"best,\" \"highest,\" \"cheapest,\" \"latest,\" \"most recent,\" \"lowest,\" \"closest,\" \"highest-rated,\" \"largest,\" and \"newest\" must go through the sort function(e.g., the key point should be \"Filter by highest\").\n+\n+**Respond with**:\n+- **Key Points**: A numbered list of the explicit key points for completing this task, one per line, without explanations or additional details.\"\"\"\n+\tprompt = \"\"\"Task: {task}\"\"\"\n+\ttext = prompt.format(task=task)\n+\tmessages = [\n+\t\t{'role': 'system', 'content': system_msg},\n+\t\t{\n+\t\t\t'role': 'user',\n+\t\t\t'content': [{'type': 'text', 'text': text}],\n+\t\t},\n+\t]\n+\tresponse = await asyncio.to_thread(model.invoke, messages)\n+\treturn response.content\n+\n+\n+async def judge_image(task, image_path, key_points, model):\n+\tsystem_msg = \"\"\"You are an expert evaluator tasked with determining whether an image contains information about the necessary steps to complete a task.\n+\n+**Objective**: Analyze the provided image and decide if it shows essential steps or evidence required for completing the task. Use your reasoning to explain your decision before assigning a score.\n+\n+**Instructions**:\n+1. Provide a detailed description of the image, including its contents, visible elements, text (if any), and any notable features.\n+\n+2. Carefully examine the image and evaluate whether it contains necessary steps or evidence crucial to task completion:  \n+- Identify key points that could be relevant to task completion, such as actions, progress indicators, tool usage, applied filters, or step-by-step instructions.  \n+- Does the image show actions, progress indicators, or critical information directly related to completing the task?  \n+- Is this information indispensable for understanding or ensuring task success?\n+- If the image contains partial but relevant information, consider its usefulness rather than dismissing it outright.\n+\n+3. Provide your response in the following format:  \n+- **Reasoning**: Explain your thought process and observations. Mention specific elements in the image that indicate necessary steps, evidence, or lack thereof.  \n+- **Score**: Assign a score based on the reasoning, using the following scale:  \n+    - **1**: The image does not contain any necessary steps or relevant information.  \n+    - **2**: The image contains minimal or ambiguous information, unlikely to be essential.  \n+    - **3**: The image includes some relevant steps or hints but lacks clarity or completeness.  \n+    - **4**: The image contains important steps or evidence that are highly relevant but not fully comprehensive.  \n+    - **5**: The image clearly displays necessary steps or evidence crucial for completing the task.\n+\n+Respond with:  \n+1. **Reasoning**: [Your explanation]  \n+2. **Score**: [1-5]\"\"\"\n+\n+\tjpg_base64_str = encode_image(Image.open(image_path))\n+\n+\tprompt = \"\"\"**Task**: {task}\n+\n+**Key Points for Task Completion**: {key_points}\n+\n+The snapshot of the web page is shown in the image.\"\"\"\n+\ttext = prompt.format(task=task, key_points=key_points)\n+\n+\tmessages = [\n+\t\t{'role': 'system', 'content': system_msg},\n+\t\t{\n+\t\t\t'role': 'user',\n+\t\t\t'content': [\n+\t\t\t\t{'type': 'text', 'text': text},\n+\t\t\t\t{\n+\t\t\t\t\t'type': 'image_url',\n+\t\t\t\t\t'image_url': {'url': f'data:image/jpeg;base64,{jpg_base64_str}', 'detail': 'high'},\n+\t\t\t\t},\n+\t\t\t],\n+\t\t},\n+\t]\n+\tresponse = await asyncio.to_thread(model.invoke, messages)\n+\treturn response.content\n+\n+\n+async def Online_Mind2Web_eval(task, last_actions, images_path, model, score_threshold):\n+\tsystem_msg = \"\"\"You are an expert in evaluating the performance of a web navigation agent. The agent is designed to help a human user navigate a website to complete a task. Given the user's task, the agent's action history, key points for task completion, some potentially important web pages in the agent's trajectory and their reasons, your goal is to determine whether the agent has completed the task and achieved all requirements.\n+\n+Your response must strictly follow the following evaluation criteria!\n+*Important Evaluation Criteria*:\n+1: The filtered results must be displayed correctly. If filters were not properly applied (i.e., missing selection, missing confirmation, or no visible effect in results), the task is not considered successful.\n+2: You must carefully check whether these snapshots and action history meet these key points. Ensure that specific filter conditions, such as \"best,\" \"highest,\" \"cheapest,\" \"latest,\" \"most recent,\" \"lowest,\" \"closest,\" \"highest-rated,\" \"largest,\" and \"newest\" are correctly applied using the filter function(e.g., sort function).\n+3: Certain key points or requirements should be applied by the filter. Otherwise, a search with all requirements as input will be deemed a failure since it cannot guarantee that all results meet the requirements!\n+4: If the task requires filtering by a specific range of money, years, or the number of beds and bathrooms, the applied filter must exactly match the given requirement. Any deviation results in failure. To ensure the task is successful, the applied filter must precisely match the specified range without being too broad or too narrow.\n+Examples of Failure Cases:\n+- If the requirement is less than $50, but the applied filter is less than $25, it is a failure.\n+- If the requirement is $1500-$2500, but the applied filter is $2000-$2500, it is a failure.\n+- If the requirement is $25-$200, but the applied filter is $0-$200, it is a failure.\n+- If the required years are 2004-2012, but the filter applied is 2001-2012, it is a failure.\n+- If the required years are before 2015, but the applied filter is 2000-2014, it is a failure.\n+- If the task requires exactly 2 beds, but the filter applied is 2+ beds, it is a failure.\n+5: Some tasks require a submission action or a display of results to be considered successful.\n+6: If the retrieved information is invalid or empty(e.g., No match was found), but the agent has correctly performed the required action, it should still be considered successful.\n+7: If the current page already displays all available items, then applying a filter is not necessary. As long as the agent selects items that meet the requirements (e.g., the cheapest or lowest price), the task is still considered successful.\n+\n+*IMPORTANT*\n+Format your response into two lines as shown below:\n+\n+Thoughts: <your thoughts and reasoning process based on double-checking each key points and the evaluation criteria>\n+Status: \"success\" or \"failure\"\n+\"\"\"\n+\tprompt = \"\"\"User Task: {task}\n+\n+Key Points: {key_points}\n+\n+Action History:\n+{last_actions}\n+\n+The potentially important snapshots of the webpage in the agent's trajectory and their reasons:\n+{thoughts}\"\"\"\n+\n+\tkey_points = await identify_key_points(task, model)\n+\tkey_points = key_points.replace('\n\n', '\n')\n+\n+\ttry:\n+\t\tkey_points = key_points.split('**Key Points**:')[1]\n+\t\tkey_points = '\n'.join(line.lstrip() for line in key_points.splitlines())\n+\texcept IndexError:\n+\t\tkey_points = key_points.split('Key Points:')[-1]\n+\t\tkey_points = '\n'.join(line.lstrip() for line in key_points.splitlines())\n+\n+\ttasks = [judge_image(task, image_path, key_points, model) for image_path in images_path]\n+\timage_responses = await asyncio.gather(*tasks)\n+\n+\twhole_content_img = []\n+\twhole_thoughts = []\n+\trecord = []\n+\tpattern = r'[1-5]'\n+\tfor response, image_path in zip(image_responses, images_path):\n+\t\ttry:\n+\t\t\tscore_text = response.split('Score')[1]\n+\t\t\tthought = response.split('**Reasoning**:')[-1].strip().lstrip('\n').split('\n\n')[0].replace('\n', ' ')\n+\t\t\tscore = re.findall(pattern, score_text)[0]\n+\t\t\trecord.append({'Response': response, 'Score': int(score)})\n+\t\texcept Exception as e:\n+\t\t\tlogger.error(f'Error processing response: {e}')\n+\t\t\tscore = 0\n+\t\t\trecord.append({'Response': response, 'Score': 0})\n+\n+\t\tif int(score) >= score_threshold:\n+\t\t\tjpg_base64_str = encode_image(Image.open(image_path))\n+\t\t\twhole_content_img.append(\n+\t\t\t\t{'type': 'image_url', 'image_url': {'url': f'data:image/png;base64,{jpg_base64_str}', 'detail': 'high'}}\n+\t\t\t)\n+\t\t\tif thought != '':\n+\t\t\t\twhole_thoughts.append(thought)\n+\n+\twhole_content_img = whole_content_img[:MAX_IMAGE]\n+\twhole_thoughts = whole_thoughts[:MAX_IMAGE]\n+\tif len(whole_content_img) == 0:\n+\t\tprompt = \"\"\"User Task: {task}\n+\n+Key Points: {key_points}\n+\n+Action History:\n+{last_actions}\"\"\"\n+\ttext = prompt.format(\n+\t\ttask=task,\n+\t\tlast_actions='\n'.join(f'{i + 1}. {action}' for i, action in enumerate(last_actions)),\n+\t\tkey_points=key_points,\n+\t\tthoughts='\n'.join(f'{i + 1}. {thought}' for i, thought in enumerate(whole_thoughts)),\n+\t)\n+\n+\tmessages = [\n+\t\t{'role': 'system', 'content': system_msg},\n+\t\t{'role': 'user', 'content': [{'type': 'text', 'text': text}] + whole_content_img},\n+\t]\n+\treturn messages, text, system_msg, record, key_points\n+\n+\n+async def Online_Mind2Web_eval_with_retry(task, last_actions, images_path, model, score_threshold, max_retries=3):\n+\t\"\"\"\n+\tWrapper for Online_Mind2Web_eval with retry logic.\n+\n+\tArgs:\n+\t    task: The task description\n+\t    last_actions: List of actions taken\n+\t    images_path: List of image paths\n+\t    model: The model to use for evaluation\n+\t    score_threshold: Score threshold for image filtering\n+\t    max_retries: Maximum number of retry attempts\n+\n+\tReturns:\n+\t    Tuple of (messages, text, system_msg, record, key_points) or None if all retries fail\n+\t\"\"\"\n+\tfor attempt in range(max_retries):\n+\t\ttry:\n+\t\t\treturn await Online_Mind2Web_eval(task, last_actions, images_path, model, score_threshold)\n+\t\texcept Exception as e:\n+\t\t\tif attempt == max_retries - 1:  # Last attempt\n+\t\t\t\tlogger.error(f'Failed to evaluate after {max_retries} attempts. Error: {str(e)}')\n+\t\t\t\traise\n+\t\t\tlogger.warning(f'Attempt {attempt + 1} failed. Retrying... Error: {str(e)}')\n+\t\t\tawait asyncio.sleep(2**attempt)  # Exponential backoff\n+\n+\n+# ==============================================================================================================\n+\n+\n+# ==============================================================================================================\n+# A service for evaluating the performance of the agent\n+# ==============================================================================================================\n+import argparse\n+import json\n+from datetime import datetime\n+from pathlib import Path\n+from typing import Dict, List, Optional\n+\n+from dotenv import load_dotenv\n+from langchain_openai import ChatOpenAI\n+\n+from browser_use import Agent, Browser, BrowserConfig\n+\n+\n+class Task:\n+\tdef __init__(self, task_id, confirmed_task, website, reference_length, level):\n+\t\tself.task_id = task_id\n+\t\tself.confirmed_task = confirmed_task\n+\t\tself.website = website\n+\t\tself.reference_length = reference_length\n+\t\tself.level = level\n+\n+\tdef __str__(self):\n+\t\treturn f'Task(task_id={self.task_id}, confirmed_task={self.confirmed_task}, website={self.website}, reference_length={self.reference_length}, level={self.level})'\n+\n+\tdef __repr__(self):\n+\t\treturn self.__str__()\n+\n+\n+class TaskTracker:\n+\tdef __init__(self, task_id: str, task_text: str):\n+\t\tself.task_id = task_id\n+\t\tself.task_text = task_text\n+\t\tself.result_folder = Path(f'saved_trajectories/{task_id}')\n+\t\tself.trajectory_folder = self.result_folder / 'trajectory'\n+\t\tself.step_results = []\n+\t\tself.step_counter = 0\n+\t\tself.screenshots = []\n+\t\tself.setup_folders()\n+\n+\tdef setup_folders(self):\n+\t\t\"\"\"Create the necessary folder structure\"\"\"\n+\t\tself.result_folder.mkdir(parents=True, exist_ok=True)\n+\t\tself.trajectory_folder.mkdir(parents=True, exist_ok=True)\n+\n+\tasync def on_step_start(self, agent):\n+\t\t\"\"\"Record information at the start of a step\"\"\"\n+\t\tself.current_step = {'step_number': self.step_counter, 'start_time': datetime.now().isoformat(), 'actions': []}\n+\n+\tasync def on_step_end(self, agent):\n+\t\t\"\"\"Record information at the end of a step\"\"\"\n+\t\t# Take screenshot\n+\t\tbrowser_context = agent.browser_context\n+\t\tscreenshot_b64 = await browser_context.take_screenshot()\n+\t\tscreenshot_path = self.trajectory_folder / f'step_{self.step_counter}.png'\n+\n+\t\t# Save screenshot to file\n+\t\twith open(screenshot_path, 'wb') as f:\n+\t\t\tf.write(base64.b64decode(screenshot_b64))\n+\n+\t\t# Save screenshot path\n+\t\tself.screenshots.append(str(screenshot_path))\n+\n+\t\t# Record action and result\n+\t\tif agent.state.last_result:\n+\t\t\tfor result in agent.state.last_result:\n+\t\t\t\tself.current_step['actions'].append(\n+\t\t\t\t\t{\n+\t\t\t\t\t\t'content': result.extracted_content,\n+\t\t\t\t\t\t'error': result.error,\n+\t\t\t\t\t\t'is_done': result.is_done,\n+\t\t\t\t\t\t'success': result.success,\n+\t\t\t\t\t}\n+\t\t\t\t)\n+\n+\t\t# Record end time\n+\t\tself.current_step['end_time'] = datetime.now().isoformat()\n+\t\tself.current_step['screenshot_path'] = str(screenshot_path)\n+\n+\t\t# Add to step results\n+\t\tself.step_results.append(self.current_step)\n+\t\tself.step_counter += 1\n+\n+\t\t# Save intermediate results\n+\t\tself.save_results()  # Save progress after each step\n+\n+\tdef save_results(self):\n+\t\t\"\"\"Save the consolidated results\"\"\"\n+\t\t# Create the final result object\n+\n+\t\tformatted_result = {\n+\t\t\t'task_id': self.task_id,\n+\t\t\t'task': self.task_text,\n+\t\t\t'steps': self.step_results,\n+\t\t\t'action_history': [step['actions'][-1]['content'] for step in self.step_results],\n+\t\t\t'screenshot_paths': self.screenshots,\n+\t\t\t'final_result_response': self.step_results[-1]['actions'][-1]['content']\n+\t\t\tif self.step_results[-1]['actions'][-1]['is_done']\n+\t\t\telse None,",
    "repo_full_name": "browser-use/browser-use",
    "discussion_comments": [
      {
        "comment_id": "2047736261",
        "repo_full_name": "browser-use/browser-use",
        "pr_number": 1395,
        "pr_file": "eval/service.py",
        "discussion_id": "2047736261",
        "commented_code": "@@ -0,0 +1,695 @@\n+# ==============================================================================================================\n+# Documentation for this evaluation file.\n+# The import\n+\n+\n+# Here is the command to run the evaluation:\n+# python eval/service.py --parallel_runs 5 --parallel_evaluations 5 --max-steps 25 --start 0 --end 100\n+# options:\n+# --parallel_runs: Number of parallel tasks to run\n+# --max-steps: Maximum steps per task\n+# --start: Start index\n+# --end: End index (exclusive)\n+# --headless: Run in headless mode\n+\n+# Here is the command to run the evaluation only:\n+# python eval/service.py --evaluate-only\n+# options:\n+# --parallel_evaluations: Number of parallel evaluations to run\n+\n+# To run a new evaluation, you need to first clear the saved_trajectories folder.\n+# rm -rf saved_trajectories\n+# Otherwise, the evaluation will continue on from the last saved trajectory.\n+# ==============================================================================================================\n+\n+\n+# ==============================================================================================================\n+# This is the LLM as a judge evaluation system from the OSU-NLP Group paper\n+# Any adaptiations made should be explicitly stated here:\n+# Adaptations:\n+# We are using our langchain wrapper for the OpenAI API\n+# This means we changed model.generate to model.invoke. The behavior of the model should be identical.\n+# Added a Online_Mind2Web_eval_with_retry wrapper with retry logic in case of API rate limiting or other issues.\n+\n+\n+# @article{xue2025illusionprogressassessingcurrent,\n+#       title={An Illusion of Progress? Assessing the Current State of Web Agents},\n+#       author={Tianci Xue and Weijian Qi and Tianneng Shi and Chan Hee Song and Boyu Gou and Dawn Song and Huan Sun and Yu Su},\n+#       year={2025},\n+#       eprint={2504.01382},\n+#       archivePrefix={arXiv},\n+#       primaryClass={cs.AI},\n+#       url={https://arxiv.org/abs/2504.01382},\n+# }\n+\n+# @inproceedings{deng2023mind2web,\n+#  author = {Deng, Xiang and Gu, Yu and Zheng, Boyuan and Chen, Shijie and Stevens, Sam and Wang, Boshi and Sun, Huan and Su, Yu},\n+#  booktitle = {Advances in Neural Information Processing Systems},\n+#  editor = {A. Oh and T. Naumann and A. Globerson and K. Saenko and M. Hardt and S. Levine},\n+#  pages = {28091--28114},\n+#  publisher = {Curran Associates, Inc.},\n+#  title = {Mind2Web: Towards a Generalist Agent for the Web},\n+#  url = {https://proceedings.neurips.cc/paper_files/paper/2023/file/5950bf290a1570ea401bf98882128160-Paper-Datasets_and_Benchmarks.pdf},\n+#  volume = {36},\n+#  year = {2023}\n+# }\n+# ==============================================================================================================\n+import asyncio\n+import base64\n+import io\n+import logging\n+import re\n+\n+from PIL import Image\n+\n+MAX_IMAGE = 5\n+\n+logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n+logger = logging.getLogger(__name__)\n+\n+\n+def encode_image(image):\n+\t\"\"\"Convert a PIL image to base64 string.\"\"\"\n+\tif image.mode == 'RGBA':\n+\t\timage = image.convert('RGB')\n+\tbuffered = io.BytesIO()\n+\timage.save(buffered, format='JPEG')\n+\treturn base64.b64encode(buffered.getvalue()).decode('utf-8')\n+\n+\n+async def identify_key_points(task, model):\n+\tsystem_msg = \"\"\"You are an expert tasked with analyzing a given task to identify the key points explicitly stated in the task description.\n+\n+**Objective**: Carefully analyze the task description and extract the critical elements explicitly mentioned in the task for achieving its goal.\n+\n+**Instructions**:\n+1. Read the task description carefully.\n+2. Identify and extract **key points** directly stated in the task description.\n+   - A **key point** is a critical element, condition, or step explicitly mentioned in the task description.\n+   - Do not infer or add any unstated elements.\n+   - Words such as \"best,\" \"highest,\" \"cheapest,\" \"latest,\" \"most recent,\" \"lowest,\" \"closest,\" \"highest-rated,\" \"largest,\" and \"newest\" must go through the sort function(e.g., the key point should be \"Filter by highest\").\n+\n+**Respond with**:\n+- **Key Points**: A numbered list of the explicit key points for completing this task, one per line, without explanations or additional details.\"\"\"\n+\tprompt = \"\"\"Task: {task}\"\"\"\n+\ttext = prompt.format(task=task)\n+\tmessages = [\n+\t\t{'role': 'system', 'content': system_msg},\n+\t\t{\n+\t\t\t'role': 'user',\n+\t\t\t'content': [{'type': 'text', 'text': text}],\n+\t\t},\n+\t]\n+\tresponse = await asyncio.to_thread(model.invoke, messages)\n+\treturn response.content\n+\n+\n+async def judge_image(task, image_path, key_points, model):\n+\tsystem_msg = \"\"\"You are an expert evaluator tasked with determining whether an image contains information about the necessary steps to complete a task.\n+\n+**Objective**: Analyze the provided image and decide if it shows essential steps or evidence required for completing the task. Use your reasoning to explain your decision before assigning a score.\n+\n+**Instructions**:\n+1. Provide a detailed description of the image, including its contents, visible elements, text (if any), and any notable features.\n+\n+2. Carefully examine the image and evaluate whether it contains necessary steps or evidence crucial to task completion:  \n+- Identify key points that could be relevant to task completion, such as actions, progress indicators, tool usage, applied filters, or step-by-step instructions.  \n+- Does the image show actions, progress indicators, or critical information directly related to completing the task?  \n+- Is this information indispensable for understanding or ensuring task success?\n+- If the image contains partial but relevant information, consider its usefulness rather than dismissing it outright.\n+\n+3. Provide your response in the following format:  \n+- **Reasoning**: Explain your thought process and observations. Mention specific elements in the image that indicate necessary steps, evidence, or lack thereof.  \n+- **Score**: Assign a score based on the reasoning, using the following scale:  \n+    - **1**: The image does not contain any necessary steps or relevant information.  \n+    - **2**: The image contains minimal or ambiguous information, unlikely to be essential.  \n+    - **3**: The image includes some relevant steps or hints but lacks clarity or completeness.  \n+    - **4**: The image contains important steps or evidence that are highly relevant but not fully comprehensive.  \n+    - **5**: The image clearly displays necessary steps or evidence crucial for completing the task.\n+\n+Respond with:  \n+1. **Reasoning**: [Your explanation]  \n+2. **Score**: [1-5]\"\"\"\n+\n+\tjpg_base64_str = encode_image(Image.open(image_path))\n+\n+\tprompt = \"\"\"**Task**: {task}\n+\n+**Key Points for Task Completion**: {key_points}\n+\n+The snapshot of the web page is shown in the image.\"\"\"\n+\ttext = prompt.format(task=task, key_points=key_points)\n+\n+\tmessages = [\n+\t\t{'role': 'system', 'content': system_msg},\n+\t\t{\n+\t\t\t'role': 'user',\n+\t\t\t'content': [\n+\t\t\t\t{'type': 'text', 'text': text},\n+\t\t\t\t{\n+\t\t\t\t\t'type': 'image_url',\n+\t\t\t\t\t'image_url': {'url': f'data:image/jpeg;base64,{jpg_base64_str}', 'detail': 'high'},\n+\t\t\t\t},\n+\t\t\t],\n+\t\t},\n+\t]\n+\tresponse = await asyncio.to_thread(model.invoke, messages)\n+\treturn response.content\n+\n+\n+async def Online_Mind2Web_eval(task, last_actions, images_path, model, score_threshold):\n+\tsystem_msg = \"\"\"You are an expert in evaluating the performance of a web navigation agent. The agent is designed to help a human user navigate a website to complete a task. Given the user's task, the agent's action history, key points for task completion, some potentially important web pages in the agent's trajectory and their reasons, your goal is to determine whether the agent has completed the task and achieved all requirements.\n+\n+Your response must strictly follow the following evaluation criteria!\n+*Important Evaluation Criteria*:\n+1: The filtered results must be displayed correctly. If filters were not properly applied (i.e., missing selection, missing confirmation, or no visible effect in results), the task is not considered successful.\n+2: You must carefully check whether these snapshots and action history meet these key points. Ensure that specific filter conditions, such as \"best,\" \"highest,\" \"cheapest,\" \"latest,\" \"most recent,\" \"lowest,\" \"closest,\" \"highest-rated,\" \"largest,\" and \"newest\" are correctly applied using the filter function(e.g., sort function).\n+3: Certain key points or requirements should be applied by the filter. Otherwise, a search with all requirements as input will be deemed a failure since it cannot guarantee that all results meet the requirements!\n+4: If the task requires filtering by a specific range of money, years, or the number of beds and bathrooms, the applied filter must exactly match the given requirement. Any deviation results in failure. To ensure the task is successful, the applied filter must precisely match the specified range without being too broad or too narrow.\n+Examples of Failure Cases:\n+- If the requirement is less than $50, but the applied filter is less than $25, it is a failure.\n+- If the requirement is $1500-$2500, but the applied filter is $2000-$2500, it is a failure.\n+- If the requirement is $25-$200, but the applied filter is $0-$200, it is a failure.\n+- If the required years are 2004-2012, but the filter applied is 2001-2012, it is a failure.\n+- If the required years are before 2015, but the applied filter is 2000-2014, it is a failure.\n+- If the task requires exactly 2 beds, but the filter applied is 2+ beds, it is a failure.\n+5: Some tasks require a submission action or a display of results to be considered successful.\n+6: If the retrieved information is invalid or empty(e.g., No match was found), but the agent has correctly performed the required action, it should still be considered successful.\n+7: If the current page already displays all available items, then applying a filter is not necessary. As long as the agent selects items that meet the requirements (e.g., the cheapest or lowest price), the task is still considered successful.\n+\n+*IMPORTANT*\n+Format your response into two lines as shown below:\n+\n+Thoughts: <your thoughts and reasoning process based on double-checking each key points and the evaluation criteria>\n+Status: \"success\" or \"failure\"\n+\"\"\"\n+\tprompt = \"\"\"User Task: {task}\n+\n+Key Points: {key_points}\n+\n+Action History:\n+{last_actions}\n+\n+The potentially important snapshots of the webpage in the agent's trajectory and their reasons:\n+{thoughts}\"\"\"\n+\n+\tkey_points = await identify_key_points(task, model)\n+\tkey_points = key_points.replace('\\n\\n', '\\n')\n+\n+\ttry:\n+\t\tkey_points = key_points.split('**Key Points**:')[1]\n+\t\tkey_points = '\\n'.join(line.lstrip() for line in key_points.splitlines())\n+\texcept IndexError:\n+\t\tkey_points = key_points.split('Key Points:')[-1]\n+\t\tkey_points = '\\n'.join(line.lstrip() for line in key_points.splitlines())\n+\n+\ttasks = [judge_image(task, image_path, key_points, model) for image_path in images_path]\n+\timage_responses = await asyncio.gather(*tasks)\n+\n+\twhole_content_img = []\n+\twhole_thoughts = []\n+\trecord = []\n+\tpattern = r'[1-5]'\n+\tfor response, image_path in zip(image_responses, images_path):\n+\t\ttry:\n+\t\t\tscore_text = response.split('Score')[1]\n+\t\t\tthought = response.split('**Reasoning**:')[-1].strip().lstrip('\\n').split('\\n\\n')[0].replace('\\n', ' ')\n+\t\t\tscore = re.findall(pattern, score_text)[0]\n+\t\t\trecord.append({'Response': response, 'Score': int(score)})\n+\t\texcept Exception as e:\n+\t\t\tlogger.error(f'Error processing response: {e}')\n+\t\t\tscore = 0\n+\t\t\trecord.append({'Response': response, 'Score': 0})\n+\n+\t\tif int(score) >= score_threshold:\n+\t\t\tjpg_base64_str = encode_image(Image.open(image_path))\n+\t\t\twhole_content_img.append(\n+\t\t\t\t{'type': 'image_url', 'image_url': {'url': f'data:image/png;base64,{jpg_base64_str}', 'detail': 'high'}}\n+\t\t\t)\n+\t\t\tif thought != '':\n+\t\t\t\twhole_thoughts.append(thought)\n+\n+\twhole_content_img = whole_content_img[:MAX_IMAGE]\n+\twhole_thoughts = whole_thoughts[:MAX_IMAGE]\n+\tif len(whole_content_img) == 0:\n+\t\tprompt = \"\"\"User Task: {task}\n+\n+Key Points: {key_points}\n+\n+Action History:\n+{last_actions}\"\"\"\n+\ttext = prompt.format(\n+\t\ttask=task,\n+\t\tlast_actions='\\n'.join(f'{i + 1}. {action}' for i, action in enumerate(last_actions)),\n+\t\tkey_points=key_points,\n+\t\tthoughts='\\n'.join(f'{i + 1}. {thought}' for i, thought in enumerate(whole_thoughts)),\n+\t)\n+\n+\tmessages = [\n+\t\t{'role': 'system', 'content': system_msg},\n+\t\t{'role': 'user', 'content': [{'type': 'text', 'text': text}] + whole_content_img},\n+\t]\n+\treturn messages, text, system_msg, record, key_points\n+\n+\n+async def Online_Mind2Web_eval_with_retry(task, last_actions, images_path, model, score_threshold, max_retries=3):\n+\t\"\"\"\n+\tWrapper for Online_Mind2Web_eval with retry logic.\n+\n+\tArgs:\n+\t    task: The task description\n+\t    last_actions: List of actions taken\n+\t    images_path: List of image paths\n+\t    model: The model to use for evaluation\n+\t    score_threshold: Score threshold for image filtering\n+\t    max_retries: Maximum number of retry attempts\n+\n+\tReturns:\n+\t    Tuple of (messages, text, system_msg, record, key_points) or None if all retries fail\n+\t\"\"\"\n+\tfor attempt in range(max_retries):\n+\t\ttry:\n+\t\t\treturn await Online_Mind2Web_eval(task, last_actions, images_path, model, score_threshold)\n+\t\texcept Exception as e:\n+\t\t\tif attempt == max_retries - 1:  # Last attempt\n+\t\t\t\tlogger.error(f'Failed to evaluate after {max_retries} attempts. Error: {str(e)}')\n+\t\t\t\traise\n+\t\t\tlogger.warning(f'Attempt {attempt + 1} failed. Retrying... Error: {str(e)}')\n+\t\t\tawait asyncio.sleep(2**attempt)  # Exponential backoff\n+\n+\n+# ==============================================================================================================\n+\n+\n+# ==============================================================================================================\n+# A service for evaluating the performance of the agent\n+# ==============================================================================================================\n+import argparse\n+import json\n+from datetime import datetime\n+from pathlib import Path\n+from typing import Dict, List, Optional\n+\n+from dotenv import load_dotenv\n+from langchain_openai import ChatOpenAI\n+\n+from browser_use import Agent, Browser, BrowserConfig\n+\n+\n+class Task:\n+\tdef __init__(self, task_id, confirmed_task, website, reference_length, level):\n+\t\tself.task_id = task_id\n+\t\tself.confirmed_task = confirmed_task\n+\t\tself.website = website\n+\t\tself.reference_length = reference_length\n+\t\tself.level = level\n+\n+\tdef __str__(self):\n+\t\treturn f'Task(task_id={self.task_id}, confirmed_task={self.confirmed_task}, website={self.website}, reference_length={self.reference_length}, level={self.level})'\n+\n+\tdef __repr__(self):\n+\t\treturn self.__str__()\n+\n+\n+class TaskTracker:\n+\tdef __init__(self, task_id: str, task_text: str):\n+\t\tself.task_id = task_id\n+\t\tself.task_text = task_text\n+\t\tself.result_folder = Path(f'saved_trajectories/{task_id}')\n+\t\tself.trajectory_folder = self.result_folder / 'trajectory'\n+\t\tself.step_results = []\n+\t\tself.step_counter = 0\n+\t\tself.screenshots = []\n+\t\tself.setup_folders()\n+\n+\tdef setup_folders(self):\n+\t\t\"\"\"Create the necessary folder structure\"\"\"\n+\t\tself.result_folder.mkdir(parents=True, exist_ok=True)\n+\t\tself.trajectory_folder.mkdir(parents=True, exist_ok=True)\n+\n+\tasync def on_step_start(self, agent):\n+\t\t\"\"\"Record information at the start of a step\"\"\"\n+\t\tself.current_step = {'step_number': self.step_counter, 'start_time': datetime.now().isoformat(), 'actions': []}\n+\n+\tasync def on_step_end(self, agent):\n+\t\t\"\"\"Record information at the end of a step\"\"\"\n+\t\t# Take screenshot\n+\t\tbrowser_context = agent.browser_context\n+\t\tscreenshot_b64 = await browser_context.take_screenshot()\n+\t\tscreenshot_path = self.trajectory_folder / f'step_{self.step_counter}.png'\n+\n+\t\t# Save screenshot to file\n+\t\twith open(screenshot_path, 'wb') as f:\n+\t\t\tf.write(base64.b64decode(screenshot_b64))\n+\n+\t\t# Save screenshot path\n+\t\tself.screenshots.append(str(screenshot_path))\n+\n+\t\t# Record action and result\n+\t\tif agent.state.last_result:\n+\t\t\tfor result in agent.state.last_result:\n+\t\t\t\tself.current_step['actions'].append(\n+\t\t\t\t\t{\n+\t\t\t\t\t\t'content': result.extracted_content,\n+\t\t\t\t\t\t'error': result.error,\n+\t\t\t\t\t\t'is_done': result.is_done,\n+\t\t\t\t\t\t'success': result.success,\n+\t\t\t\t\t}\n+\t\t\t\t)\n+\n+\t\t# Record end time\n+\t\tself.current_step['end_time'] = datetime.now().isoformat()\n+\t\tself.current_step['screenshot_path'] = str(screenshot_path)\n+\n+\t\t# Add to step results\n+\t\tself.step_results.append(self.current_step)\n+\t\tself.step_counter += 1\n+\n+\t\t# Save intermediate results\n+\t\tself.save_results()  # Save progress after each step\n+\n+\tdef save_results(self):\n+\t\t\"\"\"Save the consolidated results\"\"\"\n+\t\t# Create the final result object\n+\n+\t\tformatted_result = {\n+\t\t\t'task_id': self.task_id,\n+\t\t\t'task': self.task_text,\n+\t\t\t'steps': self.step_results,\n+\t\t\t'action_history': [step['actions'][-1]['content'] for step in self.step_results],\n+\t\t\t'screenshot_paths': self.screenshots,\n+\t\t\t'final_result_response': self.step_results[-1]['actions'][-1]['content']\n+\t\t\tif self.step_results[-1]['actions'][-1]['is_done']\n+\t\t\telse None,",
        "comment_created_at": "2025-04-16T20:49:49+00:00",
        "comment_author": "pirate",
        "comment_body": "personal preference but I kinda like the new python walrus operator feature for stuff like this\r\n```suggestion\r\n\t\t\t'final_result_response': (\r\n\t\t\t\tlast_action['content']\r\n\t\t\t\tif (last_action := self.step_results[-1]['actions'][-1])['is_done']\r\n\t\t\t\telse None\r\n\t\t\t),\r\n```",
        "pr_file_module": null
      }
    ]
  }
]