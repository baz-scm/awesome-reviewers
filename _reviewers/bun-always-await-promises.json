[
  {
    "discussion_id": "2177100810",
    "pr_number": 20382,
    "pr_file": "test/js/bun/http/bun-serve-htmlbundle.test.ts",
    "created_at": "2025-07-01T10:08:17+00:00",
    "commented_code": "+import { type HTMLBundle } from \"bun\";\n+import { expect, test } from \"bun:test\";\n+import { tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+const dir = tempDirWithFiles(\"htmlbundle\", {\n+  \"index.html\": \"<!DOCTYPE html><html><body>Hello HTML</body></html>\",\n+});\n+\n+const { default: html }: { default: HTMLBundle } = await import(join(dir, \"index.html\"));\n+\n+test(\"fetch routes HTMLBundle\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": html,\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  expect(await res.text()).toContain(\"Hello HTML\");\n+  const missing = await fetch(`${server.url}/index.html`);\n+  expect(missing.status).toBe(404);\n+  await server.stop();\n+});\n+\n+test(\"fetch Sleep 1s Response(HTMLBundle)\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": async () => {\n+        Bun.sleep(1000);",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2177100810",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20382,
        "pr_file": "test/js/bun/http/bun-serve-htmlbundle.test.ts",
        "discussion_id": "2177100810",
        "commented_code": "@@ -0,0 +1,74 @@\n+import { type HTMLBundle } from \"bun\";\n+import { expect, test } from \"bun:test\";\n+import { tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+const dir = tempDirWithFiles(\"htmlbundle\", {\n+  \"index.html\": \"<!DOCTYPE html><html><body>Hello HTML</body></html>\",\n+});\n+\n+const { default: html }: { default: HTMLBundle } = await import(join(dir, \"index.html\"));\n+\n+test(\"fetch routes HTMLBundle\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": html,\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  expect(await res.text()).toContain(\"Hello HTML\");\n+  const missing = await fetch(`${server.url}/index.html`);\n+  expect(missing.status).toBe(404);\n+  await server.stop();\n+});\n+\n+test(\"fetch Sleep 1s Response(HTMLBundle)\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": async () => {\n+        Bun.sleep(1000);",
        "comment_created_at": "2025-07-01T10:08:17+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "The `Bun.sleep()` function returns a Promise that should be awaited in this async function. Without the `await` keyword, the function will continue execution immediately without pausing, which defeats the purpose of the sleep operation. Consider changing to `await Bun.sleep(1000);` to ensure the function properly waits for 1 second before returning the response.\n```suggestion\n        await Bun.sleep(1000);\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2176307635",
    "pr_number": 20745,
    "pr_file": "src/js/builtins/Bake.ts",
    "created_at": "2025-07-01T02:48:25+00:00",
    "commented_code": "});\n         if (paramGetter[Symbol.asyncIterator] != undefined) {\n           for await (const params of paramGetter) {\n-            callRouteGenerator(type, i, layouts, pageModule, params);\n+            await callRouteGenerator(type, i, layouts, pageModule, params);",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2176307635",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20745,
        "pr_file": "src/js/builtins/Bake.ts",
        "discussion_id": "2176307635",
        "commented_code": "@@ -130,11 +130,11 @@ export function renderRoutesForProdStatic(\n         });\n         if (paramGetter[Symbol.asyncIterator] != undefined) {\n           for await (const params of paramGetter) {\n-            callRouteGenerator(type, i, layouts, pageModule, params);\n+            await callRouteGenerator(type, i, layouts, pageModule, params);",
        "comment_created_at": "2025-07-01T02:48:25+00:00",
        "comment_author": "Jarred-Sumner",
        "comment_body": "This should check if it returned a Promise and if that Promise is not resolved, and only then use await.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2156093394",
    "pr_number": 20481,
    "pr_file": "src/js/builtins/ReadableStreamInternals.ts",
    "created_at": "2025-06-19T04:38:19+00:00",
    "commented_code": "return $readStreamIntoSink(stream, sink, true);\n }\n \n+$linkTimeConstant;\n+export function assignStreamIntoResumableSink(stream, sink) {\n+  const highWaterMark = $getByIdDirectPrivate(stream, \"highWaterMark\") || 0;\n+  let error: Error | null = null;\n+  let closed = false;\n+  try {\n+    // always call start even if reader throws\n+\n+    sink.start({ highWaterMark });\n+\n+    var reader = stream.getReader();\n+    async function drainReaderIntoSink() {\n+      if (error || closed) return;\n+\n+      try {\n+        while (true) {\n+          var { value, done } = await reader.read();\n+          if (closed) break;\n+\n+          if (done) {\n+            closed = true;\n+            // lets cover just in case we have a value when done is true\n+            // this shouldn't happen but just in case\n+            if (value) {\n+              sink.write(value);\n+            }\n+            // clean end\n+            return sink.end();",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2156093394",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20481,
        "pr_file": "src/js/builtins/ReadableStreamInternals.ts",
        "discussion_id": "2156093394",
        "commented_code": "@@ -758,6 +758,74 @@ export function assignToStream(stream, sink) {\n   return $readStreamIntoSink(stream, sink, true);\n }\n \n+$linkTimeConstant;\n+export function assignStreamIntoResumableSink(stream, sink) {\n+  const highWaterMark = $getByIdDirectPrivate(stream, \"highWaterMark\") || 0;\n+  let error: Error | null = null;\n+  let closed = false;\n+  try {\n+    // always call start even if reader throws\n+\n+    sink.start({ highWaterMark });\n+\n+    var reader = stream.getReader();\n+    async function drainReaderIntoSink() {\n+      if (error || closed) return;\n+\n+      try {\n+        while (true) {\n+          var { value, done } = await reader.read();\n+          if (closed) break;\n+\n+          if (done) {\n+            closed = true;\n+            // lets cover just in case we have a value when done is true\n+            // this shouldn't happen but just in case\n+            if (value) {\n+              sink.write(value);\n+            }\n+            // clean end\n+            return sink.end();",
        "comment_created_at": "2025-06-19T04:38:19+00:00",
        "comment_author": "Jarred-Sumner",
        "comment_body": "sink.end can return a promise, so we should await it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2145979890",
    "pr_number": 20356,
    "pr_file": "test/js/bun/http/bun-serve-htmlbundle.test.ts",
    "created_at": "2025-06-13T19:47:29+00:00",
    "commented_code": "+import { type HTMLBundle } from \"bun\";\n+import { expect, test } from \"bun:test\";\n+import { tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+const dir = tempDirWithFiles(\"htmlbundle\", {\n+  \"index.html\": \"<!DOCTYPE html><html><body>Hello HTML</body></html>\",\n+});\n+\n+const { default: html }: { default: HTMLBundle } = await import(join(dir, \"index.html\"));\n+\n+test(\"fetch routes HTMLBundle\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": html,\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  expect(await res.text()).toContain(\"Hello HTML\");\n+  const missing = await fetch(`${server.url}/index.html`);\n+  expect(missing.status).toBe(404);\n+  await server.stop();\n+});\n+\n+test(\"fetch Sleep 1s Response(HTMLBundle)\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": async () => {\n+        Bun.sleep(1000);\n+        return new Response(html);\n+      },\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  expect(await res.text()).toContain(\"Hello HTML\");\n+  const missing = await fetch(`${server.url}/index.html`);\n+  expect(missing.status).toBe(404);\n+});\n+\n+test(\"fetch Response(HTMLBundle)\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": new Response(html),\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  await server.stop();\n+  expect(await res.text()).toContain(\"Hello HTML\");",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2145979890",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20356,
        "pr_file": "test/js/bun/http/bun-serve-htmlbundle.test.ts",
        "discussion_id": "2145979890",
        "commented_code": "@@ -0,0 +1,73 @@\n+import { type HTMLBundle } from \"bun\";\n+import { expect, test } from \"bun:test\";\n+import { tempDirWithFiles } from \"harness\";\n+import { join } from \"path\";\n+\n+const dir = tempDirWithFiles(\"htmlbundle\", {\n+  \"index.html\": \"<!DOCTYPE html><html><body>Hello HTML</body></html>\",\n+});\n+\n+const { default: html }: { default: HTMLBundle } = await import(join(dir, \"index.html\"));\n+\n+test(\"fetch routes HTMLBundle\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": html,\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  expect(await res.text()).toContain(\"Hello HTML\");\n+  const missing = await fetch(`${server.url}/index.html`);\n+  expect(missing.status).toBe(404);\n+  await server.stop();\n+});\n+\n+test(\"fetch Sleep 1s Response(HTMLBundle)\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": async () => {\n+        Bun.sleep(1000);\n+        return new Response(html);\n+      },\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  expect(await res.text()).toContain(\"Hello HTML\");\n+  const missing = await fetch(`${server.url}/index.html`);\n+  expect(missing.status).toBe(404);\n+});\n+\n+test(\"fetch Response(HTMLBundle)\", async () => {\n+  using server = Bun.serve({\n+    port: 0,\n+    routes: {\n+      \"/\": new Response(html),\n+    },\n+  });\n+\n+  const res = await fetch(server.url);\n+  await server.stop();\n+  expect(await res.text()).toContain(\"Hello HTML\");",
        "comment_created_at": "2025-06-13T19:47:29+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "Consider moving the `server.stop()` call after the assertions to prevent potential race conditions. Currently, the server is stopped before checking the response content, which could lead to inconsistent test results if the response processing is delayed. A more reliable pattern would be:\n\n```js\nconst res = await fetch(server.url);\nexpect(await res.text()).toContain(\"Hello HTML\");\nawait server.stop();\n```\n\nThis ensures the server remains available throughout the response processing.\n```suggestion\n  const res = await fetch(server.url);\n  expect(await res.text()).toContain(\"Hello HTML\");\n  await server.stop();\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  }
]