[
  {
    "discussion_id": "2146246201",
    "pr_number": 20364,
    "pr_file": "packages/bun-usockets/src/crypto/root_certs.cpp",
    "created_at": "2025-06-13T23:00:53+00:00",
    "commented_code": "return NULL;\n   }\n \n-  static X509 *root_cert_instances[root_certs_size] = {NULL};\n-  static STACK_OF(X509) *root_extra_cert_instances = NULL;\n-\n-  us_internal_init_root_certs(root_cert_instances, root_extra_cert_instances);\n+  us_default_ca_certificates *default_ca_certificates = us_get_default_ca_certificates();\n \n   // load all root_cert_instances on the default ca store\n   for (size_t i = 0; i < root_certs_size; i++) {\n-    X509 *cert = root_cert_instances[i];\n+    X509 *cert = default_ca_certificates->root_cert_instances[i];\n     if (cert == NULL)\n       continue;\n     X509_up_ref(cert);\n     X509_STORE_add_cert(store, cert);\n   }\n \n-  if (root_extra_cert_instances) {\n-    for (int i = 0; i < sk_X509_num(root_extra_cert_instances); i++) {\n-      X509 *cert = sk_X509_value(root_extra_cert_instances, i);\n+  if (default_ca_certificates->root_extra_cert_instances) {",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2146246201",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20364,
        "pr_file": "packages/bun-usockets/src/crypto/root_certs.cpp",
        "discussion_id": "2146246201",
        "commented_code": "@@ -145,23 +161,20 @@ extern \"C\" X509_STORE *us_get_default_ca_store() {\n     return NULL;\n   }\n \n-  static X509 *root_cert_instances[root_certs_size] = {NULL};\n-  static STACK_OF(X509) *root_extra_cert_instances = NULL;\n-\n-  us_internal_init_root_certs(root_cert_instances, root_extra_cert_instances);\n+  us_default_ca_certificates *default_ca_certificates = us_get_default_ca_certificates();\n \n   // load all root_cert_instances on the default ca store\n   for (size_t i = 0; i < root_certs_size; i++) {\n-    X509 *cert = root_cert_instances[i];\n+    X509 *cert = default_ca_certificates->root_cert_instances[i];\n     if (cert == NULL)\n       continue;\n     X509_up_ref(cert);\n     X509_STORE_add_cert(store, cert);\n   }\n \n-  if (root_extra_cert_instances) {\n-    for (int i = 0; i < sk_X509_num(root_extra_cert_instances); i++) {\n-      X509 *cert = sk_X509_value(root_extra_cert_instances, i);\n+  if (default_ca_certificates->root_extra_cert_instances) {",
        "comment_created_at": "2025-06-13T23:00:53+00:00",
        "comment_author": "cirospaciari",
        "comment_body": "since root_extra_cert_instances is a pointer I would do `auto instances = default_ca_certificates->root_extra_cert_instances;` and avoid doing `default_ca_certificates->root_extra_cert_instances` on each iteration",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2132972369",
    "pr_number": 20232,
    "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
    "created_at": "2025-06-06T22:25:30+00:00",
    "commented_code": "RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2132972369",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20232,
        "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
        "discussion_id": "2132972369",
        "commented_code": "@@ -2362,6 +2366,129 @@ JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetParamCount, (JSGlobalObject * lexicalG\n     RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);",
        "comment_created_at": "2025-06-06T22:25:30+00:00",
        "comment_author": "Jarred-Sumner",
        "comment_body": "Since sqlite3_step can potentially take awhile, let's use a `MarkedArgumentBuffer args` so the GC doesn't see the JSArray until it's about to be returned.",
        "pr_file_module": null
      },
      {
        "comment_id": "2133042650",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20232,
        "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
        "discussion_id": "2132972369",
        "commented_code": "@@ -2362,6 +2366,129 @@ JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetParamCount, (JSGlobalObject * lexicalG\n     RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);",
        "comment_created_at": "2025-06-06T23:02:25+00:00",
        "comment_author": "crishoj",
        "comment_body": "Could also postpone creation of the `JSArray` until after `sqlite3_step`? \r\nAssuming `sqlite3_column_type(stmt, i)` is fast, we're pretty much ready to return at that point.",
        "pr_file_module": null
      },
      {
        "comment_id": "2133083444",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20232,
        "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
        "discussion_id": "2132972369",
        "commented_code": "@@ -2362,6 +2366,129 @@ JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetParamCount, (JSGlobalObject * lexicalG\n     RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);",
        "comment_created_at": "2025-06-06T23:54:51+00:00",
        "comment_author": "crishoj",
        "comment_body": "nvm \u2014\u00a0now I see",
        "pr_file_module": null
      }
    ]
  }
]