[
  {
    "discussion_id": "2130956073",
    "pr_number": 20214,
    "pr_file": "src/bake/DevServer.zig",
    "created_at": "2025-06-05T23:43:53+00:00",
    "commented_code": "if (dev.has_tailwind_plugin_hack) |*map| {\n             const first_1024 = code.buffer[0..@min(code.buffer.len, 1024)];\n             if (std.mem.indexOf(u8, first_1024, \"tailwind\") != null) {\n-                try map.put(dev.allocator, key, {});\n+                try map.put(dev.allocator, try dev.allocator.dupe(u8, key), {});",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2130956073",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20214,
        "pr_file": "src/bake/DevServer.zig",
        "discussion_id": "2130956073",
        "commented_code": "@@ -2411,7 +2414,7 @@ pub fn finalizeBundle(\n         if (dev.has_tailwind_plugin_hack) |*map| {\n             const first_1024 = code.buffer[0..@min(code.buffer.len, 1024)];\n             if (std.mem.indexOf(u8, first_1024, \"tailwind\") != null) {\n-                try map.put(dev.allocator, key, {});\n+                try map.put(dev.allocator, try dev.allocator.dupe(u8, key), {});",
        "comment_created_at": "2025-06-05T23:43:53+00:00",
        "comment_author": "190n",
        "comment_body": "If dupe succeeds and put fails we leak the key\r\n```suggestion\r\n                const stable_key = try dev.allocator.dupe(u8, key);\r\n                errdefer dev.allocator.free(stable_key);\r\n                try map.put(dev.allocator, stable_key, {});\r\n\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2130961759",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20214,
        "pr_file": "src/bake/DevServer.zig",
        "discussion_id": "2130956073",
        "commented_code": "@@ -2411,7 +2414,7 @@ pub fn finalizeBundle(\n         if (dev.has_tailwind_plugin_hack) |*map| {\n             const first_1024 = code.buffer[0..@min(code.buffer.len, 1024)];\n             if (std.mem.indexOf(u8, first_1024, \"tailwind\") != null) {\n-                try map.put(dev.allocator, key, {});\n+                try map.put(dev.allocator, try dev.allocator.dupe(u8, key), {});",
        "comment_created_at": "2025-06-05T23:45:56+00:00",
        "comment_author": "190n",
        "comment_body": "also agree on keeping `getOrPut` since this leaks the key if there was an existing entry",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2103962220",
    "pr_number": 19766,
    "pr_file": "src/bun.zig",
    "created_at": "2025-05-23T07:14:15+00:00",
    "commented_code": "pub var argv: [][:0]const u8 = &[_][:0]const u8{};\n \n+fn appendOptionsEnv(env: []const u8, args: *std.ArrayList([:0]const u8), allocator: std.mem.Allocator) !void {\n+    var i: usize = 0;\n+    var offset_in_args: usize = 1;\n+    while (i < env.len) {\n+        // skip whitespace\n+        while (i < env.len and std.ascii.isWhitespace(env[i])) : (i += 1) {}\n+        if (i >= env.len) break;\n+\n+        // Handle all command-line arguments with quotes preserved\n+        const start = i;\n+        var j = i;\n+\n+        // Check if this is an option (starts with --)\n+        const is_option = j + 2 <= env.len and env[j] == '-' and env[j + 1] == '-';\n+\n+        if (is_option) {\n+            // Find the end of the option flag (--flag)\n+            while (j < env.len and !std.ascii.isWhitespace(env[j]) and env[j] != '=') : (j += 1) {}\n+\n+            var found_equals = false;\n+\n+            // Check for equals sign\n+            if (j < env.len and env[j] == '=') {\n+                found_equals = true;\n+                j += 1; // Move past the equals sign\n+            } else if (j < env.len and std.ascii.isWhitespace(env[j])) {\n+                j += 1; // Move past the space\n+                // Skip any additional whitespace\n+                while (j < env.len and std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Handle quoted values\n+            if (j < env.len and (env[j] == '\\'' or env[j] == '\"')) {\n+                const quote_char = env[j];\n+                j += 1; // Move past opening quote\n+\n+                // Find the closing quote\n+                while (j < env.len and env[j] != quote_char) : (j += 1) {}\n+                if (j < env.len) j += 1; // Move past closing quote\n+            } else if (found_equals) {\n+                // If we had --flag=value (no quotes), find next whitespace\n+                while (j < env.len and !std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Copy the entire argument including quotes\n+            const arg_len = j - start;\n+            const arg = try allocator.allocSentinel(u8, arg_len, 0);\n+            @memcpy(arg, env[start..j]);\n+            try args.insert(offset_in_args, arg);\n+            offset_in_args += 1;\n+\n+            i = j;\n+            continue;\n+        }\n+\n+        // Non-option arguments or standalone values\n+        var buf = std.ArrayList(u8).init(allocator);\n+\n+        var in_single = false;\n+        var in_double = false;\n+        var escape = false;\n+        while (i < env.len) : (i += 1) {\n+            const ch = env[i];\n+            if (escape) {\n+                try buf.append(ch);\n+                escape = false;\n+                continue;\n+            }\n+\n+            if (ch == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+\n+            if (in_single) {\n+                if (ch == '\\'') {\n+                    in_single = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (in_double) {\n+                if (ch == '\"') {\n+                    in_double = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (ch == '\\'') {\n+                in_single = true;\n+            } else if (ch == '\"') {\n+                in_double = true;\n+            } else if (std.ascii.isWhitespace(ch)) {\n+                break;\n+            } else {\n+                try buf.append(ch);\n+            }\n+        }\n+\n+        try buf.append(0);\n+        const owned = try buf.toOwnedSlice();\n+        try args.insert(offset_in_args, owned[0 .. owned.len - 1 :0]);\n+        offset_in_args += 1;\n+    }",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2103968228",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19766,
        "pr_file": "src/bun.zig",
        "discussion_id": "2103962220",
        "commented_code": "@@ -1986,6 +1986,116 @@ pub const StatFS = switch (Environment.os) {\n \n pub var argv: [][:0]const u8 = &[_][:0]const u8{};\n \n+fn appendOptionsEnv(env: []const u8, args: *std.ArrayList([:0]const u8), allocator: std.mem.Allocator) !void {\n+    var i: usize = 0;\n+    var offset_in_args: usize = 1;\n+    while (i < env.len) {\n+        // skip whitespace\n+        while (i < env.len and std.ascii.isWhitespace(env[i])) : (i += 1) {}\n+        if (i >= env.len) break;\n+\n+        // Handle all command-line arguments with quotes preserved\n+        const start = i;\n+        var j = i;\n+\n+        // Check if this is an option (starts with --)\n+        const is_option = j + 2 <= env.len and env[j] == '-' and env[j + 1] == '-';\n+\n+        if (is_option) {\n+            // Find the end of the option flag (--flag)\n+            while (j < env.len and !std.ascii.isWhitespace(env[j]) and env[j] != '=') : (j += 1) {}\n+\n+            var found_equals = false;\n+\n+            // Check for equals sign\n+            if (j < env.len and env[j] == '=') {\n+                found_equals = true;\n+                j += 1; // Move past the equals sign\n+            } else if (j < env.len and std.ascii.isWhitespace(env[j])) {\n+                j += 1; // Move past the space\n+                // Skip any additional whitespace\n+                while (j < env.len and std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Handle quoted values\n+            if (j < env.len and (env[j] == '\\'' or env[j] == '\"')) {\n+                const quote_char = env[j];\n+                j += 1; // Move past opening quote\n+\n+                // Find the closing quote\n+                while (j < env.len and env[j] != quote_char) : (j += 1) {}\n+                if (j < env.len) j += 1; // Move past closing quote\n+            } else if (found_equals) {\n+                // If we had --flag=value (no quotes), find next whitespace\n+                while (j < env.len and !std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Copy the entire argument including quotes\n+            const arg_len = j - start;\n+            const arg = try allocator.allocSentinel(u8, arg_len, 0);\n+            @memcpy(arg, env[start..j]);\n+            try args.insert(offset_in_args, arg);\n+            offset_in_args += 1;\n+\n+            i = j;\n+            continue;\n+        }\n+\n+        // Non-option arguments or standalone values\n+        var buf = std.ArrayList(u8).init(allocator);\n+\n+        var in_single = false;\n+        var in_double = false;\n+        var escape = false;\n+        while (i < env.len) : (i += 1) {\n+            const ch = env[i];\n+            if (escape) {\n+                try buf.append(ch);\n+                escape = false;\n+                continue;\n+            }\n+\n+            if (ch == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+\n+            if (in_single) {\n+                if (ch == '\\'') {\n+                    in_single = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (in_double) {\n+                if (ch == '\"') {\n+                    in_double = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (ch == '\\'') {\n+                in_single = true;\n+            } else if (ch == '\"') {\n+                in_double = true;\n+            } else if (std.ascii.isWhitespace(ch)) {\n+                break;\n+            } else {\n+                try buf.append(ch);\n+            }\n+        }\n+\n+        try buf.append(0);\n+        const owned = try buf.toOwnedSlice();\n+        try args.insert(offset_in_args, owned[0 .. owned.len - 1 :0]);\n+        offset_in_args += 1;\n+    }",
        "comment_created_at": "2025-05-23T07:18:24+00:00",
        "comment_author": "nektro",
        "comment_body": "buf.toOwnedSlice handles this",
        "pr_file_module": null
      }
    ]
  }
]