[
  {
    "discussion_id": "2189280304",
    "pr_number": 20863,
    "pr_file": "src/sourcemap/JSSourceMap.zig",
    "created_at": "2025-07-07T07:58:11+00:00",
    "commented_code": "+/// This implements the JavaScript SourceMap class from Node.js.\n+///\n+const JSSourceMap = @This();\n+\n+sourcemap: *bun.sourcemap.ParsedSourceMap,\n+sources: []bun.String = &.{},\n+\n+fn findSourceMap(\n+    globalObject: *JSGlobalObject,\n+    callFrame: *CallFrame,\n+) bun.JSError!JSValue {\n+    const source_url_value = callFrame.argument(0);\n+    if (!source_url_value.isString()) {\n+        return .js_undefined;\n+    }\n+\n+    var source_url_string = try bun.String.fromJS(source_url_value, globalObject);\n+    defer source_url_string.deref();\n+\n+    var source_url_slice = source_url_string.toUTF8(bun.default_allocator);\n+    defer source_url_slice.deinit();\n+\n+    var source_url = source_url_slice.slice();\n+    if (bun.strings.hasPrefix(source_url, \"node:\") or bun.strings.hasPrefix(source_url, \"bun:\") or bun.strings.hasPrefix(source_url, \"data:\")) {\n+        return .js_undefined;\n+    }\n+\n+    if (bun.strings.indexOf(source_url, \"://\")) |source_url_index| {\n+        if (bun.strings.eqlComptime(source_url[0..source_url_index], \"file\")) {\n+            const path = bun.JSC.URL.pathFromFileURL(source_url_string);\n+\n+            if (path.tag == .Dead) {\n+                return globalObject.ERR(.INVALID_URL, \"Invalid URL: {s}\", .{source_url}).throw();\n+            }\n+\n+            source_url_string.deref();\n+            source_url_slice.deinit();",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2189280304",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20863,
        "pr_file": "src/sourcemap/JSSourceMap.zig",
        "discussion_id": "2189280304",
        "commented_code": "@@ -0,0 +1,248 @@\n+/// This implements the JavaScript SourceMap class from Node.js.\n+///\n+const JSSourceMap = @This();\n+\n+sourcemap: *bun.sourcemap.ParsedSourceMap,\n+sources: []bun.String = &.{},\n+\n+fn findSourceMap(\n+    globalObject: *JSGlobalObject,\n+    callFrame: *CallFrame,\n+) bun.JSError!JSValue {\n+    const source_url_value = callFrame.argument(0);\n+    if (!source_url_value.isString()) {\n+        return .js_undefined;\n+    }\n+\n+    var source_url_string = try bun.String.fromJS(source_url_value, globalObject);\n+    defer source_url_string.deref();\n+\n+    var source_url_slice = source_url_string.toUTF8(bun.default_allocator);\n+    defer source_url_slice.deinit();\n+\n+    var source_url = source_url_slice.slice();\n+    if (bun.strings.hasPrefix(source_url, \"node:\") or bun.strings.hasPrefix(source_url, \"bun:\") or bun.strings.hasPrefix(source_url, \"data:\")) {\n+        return .js_undefined;\n+    }\n+\n+    if (bun.strings.indexOf(source_url, \"://\")) |source_url_index| {\n+        if (bun.strings.eqlComptime(source_url[0..source_url_index], \"file\")) {\n+            const path = bun.JSC.URL.pathFromFileURL(source_url_string);\n+\n+            if (path.tag == .Dead) {\n+                return globalObject.ERR(.INVALID_URL, \"Invalid URL: {s}\", .{source_url}).throw();\n+            }\n+\n+            source_url_string.deref();\n+            source_url_slice.deinit();",
        "comment_created_at": "2025-07-07T07:58:11+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "There appears to be a potential double-cleanup issue in this code. The `source_url_string.deref()` and `source_url_slice.deinit()` calls are executed manually here, but these same resources are already scheduled for cleanup with `defer` statements at the beginning of the function. This could lead to double-freeing memory, which might cause crashes or undefined behavior.\n\nConsider either:\n1. Removing these manual cleanup calls since the defers will handle them, or\n2. Using a pattern like `var needs_cleanup = true` with the defers, then setting `needs_cleanup = false` after the manual cleanup to prevent the deferred cleanup from running.\n\n```zig\n// Example of option 2:\nvar source_url_string_needs_cleanup = true;\nvar source_url_slice_needs_cleanup = true;\ndefer if (source_url_string_needs_cleanup) source_url_string.deref();\ndefer if (source_url_slice_needs_cleanup) source_url_slice.deinit();\n\n// Later in the code:\nsource_url_string.deref();\nsource_url_slice.deinit();\nsource_url_string_needs_cleanup = false;\nsource_url_slice_needs_cleanup = false;\n```\n```suggestion\n            // Resources will be cleaned up by defer statements\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment) (based on [custom rules](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment&view=settings))*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2189280359",
    "pr_number": 20863,
    "pr_file": "src/sourcemap/JSSourceMap.zig",
    "created_at": "2025-07-07T07:58:13+00:00",
    "commented_code": "+/// This implements the JavaScript SourceMap class from Node.js.\n+///\n+const JSSourceMap = @This();\n+\n+sourcemap: *bun.sourcemap.ParsedSourceMap,\n+sources: []bun.String = &.{},\n+\n+fn findSourceMap(\n+    globalObject: *JSGlobalObject,\n+    callFrame: *CallFrame,\n+) bun.JSError!JSValue {\n+    const source_url_value = callFrame.argument(0);\n+    if (!source_url_value.isString()) {\n+        return .js_undefined;\n+    }\n+\n+    var source_url_string = try bun.String.fromJS(source_url_value, globalObject);\n+    defer source_url_string.deref();\n+\n+    var source_url_slice = source_url_string.toUTF8(bun.default_allocator);\n+    defer source_url_slice.deinit();\n+\n+    var source_url = source_url_slice.slice();\n+    if (bun.strings.hasPrefix(source_url, \"node:\") or bun.strings.hasPrefix(source_url, \"bun:\") or bun.strings.hasPrefix(source_url, \"data:\")) {\n+        return .js_undefined;\n+    }\n+\n+    if (bun.strings.indexOf(source_url, \"://\")) |source_url_index| {\n+        if (bun.strings.eqlComptime(source_url[0..source_url_index], \"file\")) {\n+            const path = bun.JSC.URL.pathFromFileURL(source_url_string);\n+\n+            if (path.tag == .Dead) {\n+                return globalObject.ERR(.INVALID_URL, \"Invalid URL: {s}\", .{source_url}).throw();\n+            }\n+\n+            source_url_string.deref();\n+            source_url_slice.deinit();\n+            source_url_slice = path.toUTF8(bun.default_allocator);\n+            source_url = source_url_slice.slice();\n+        }\n+    }\n+\n+    const vm = globalObject.bunVM();\n+    const source_map = vm.source_mappings.get(source_url) orelse return .js_undefined;\n+    const fake_sources_array = bun.default_allocator.alloc(bun.String, 1) catch return globalObject.throwOutOfMemory();\n+    fake_sources_array[0] = source_url_string.dupeRef();\n+    const this = bun.new(JSSourceMap, .{\n+        .sourcemap = source_map,\n+        .sources = fake_sources_array,\n+    });\n+\n+    return this.toJS(globalObject);",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2189280359",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20863,
        "pr_file": "src/sourcemap/JSSourceMap.zig",
        "discussion_id": "2189280359",
        "commented_code": "@@ -0,0 +1,248 @@\n+/// This implements the JavaScript SourceMap class from Node.js.\n+///\n+const JSSourceMap = @This();\n+\n+sourcemap: *bun.sourcemap.ParsedSourceMap,\n+sources: []bun.String = &.{},\n+\n+fn findSourceMap(\n+    globalObject: *JSGlobalObject,\n+    callFrame: *CallFrame,\n+) bun.JSError!JSValue {\n+    const source_url_value = callFrame.argument(0);\n+    if (!source_url_value.isString()) {\n+        return .js_undefined;\n+    }\n+\n+    var source_url_string = try bun.String.fromJS(source_url_value, globalObject);\n+    defer source_url_string.deref();\n+\n+    var source_url_slice = source_url_string.toUTF8(bun.default_allocator);\n+    defer source_url_slice.deinit();\n+\n+    var source_url = source_url_slice.slice();\n+    if (bun.strings.hasPrefix(source_url, \"node:\") or bun.strings.hasPrefix(source_url, \"bun:\") or bun.strings.hasPrefix(source_url, \"data:\")) {\n+        return .js_undefined;\n+    }\n+\n+    if (bun.strings.indexOf(source_url, \"://\")) |source_url_index| {\n+        if (bun.strings.eqlComptime(source_url[0..source_url_index], \"file\")) {\n+            const path = bun.JSC.URL.pathFromFileURL(source_url_string);\n+\n+            if (path.tag == .Dead) {\n+                return globalObject.ERR(.INVALID_URL, \"Invalid URL: {s}\", .{source_url}).throw();\n+            }\n+\n+            source_url_string.deref();\n+            source_url_slice.deinit();\n+            source_url_slice = path.toUTF8(bun.default_allocator);\n+            source_url = source_url_slice.slice();\n+        }\n+    }\n+\n+    const vm = globalObject.bunVM();\n+    const source_map = vm.source_mappings.get(source_url) orelse return .js_undefined;\n+    const fake_sources_array = bun.default_allocator.alloc(bun.String, 1) catch return globalObject.throwOutOfMemory();\n+    fake_sources_array[0] = source_url_string.dupeRef();\n+    const this = bun.new(JSSourceMap, .{\n+        .sourcemap = source_map,\n+        .sources = fake_sources_array,\n+    });\n+\n+    return this.toJS(globalObject);",
        "comment_created_at": "2025-07-07T07:58:13+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "Consider adding an `errdefer` statement after allocating `fake_sources_array` to ensure proper cleanup if an error occurs between allocation and returning. Currently, if `toJS()` fails, the allocated memory won't be freed, potentially causing a memory leak.\n\n```zig\nconst fake_sources_array = bun.default_allocator.alloc(bun.String, 1) catch return globalObject.throwOutOfMemory();\nerrdefer bun.default_allocator.free(fake_sources_array);\n```\n```suggestion\n    const fake_sources_array = bun.default_allocator.alloc(bun.String, 1) catch return globalObject.throwOutOfMemory();\n    errdefer bun.default_allocator.free(fake_sources_array);\n    fake_sources_array[0] = source_url_string.dupeRef();\n    const this = bun.new(JSSourceMap, .{\n        .sourcemap = source_map,\n        .sources = fake_sources_array,\n    });\n\n    return this.toJS(globalObject);\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2133794656",
    "pr_number": 20198,
    "pr_file": "src/bun.js/api/server/FileRoute.zig",
    "created_at": "2025-06-07T12:26:40+00:00",
    "commented_code": "+const FileRoute = @This();\n+\n+ref_count: RefCount,\n+server: ?AnyServer = null,\n+blob: Blob,\n+headers: Headers = .{ .allocator = bun.default_allocator },\n+status_code: u16,\n+stat_hash: bun.fs.StatHash = .{},\n+has_last_modified_header: bool,\n+has_content_length_header: bool,\n+\n+pub const InitOptions = struct {\n+    server: ?AnyServer,\n+    status_code: u16 = 200,\n+};\n+\n+pub fn lastModifiedDate(this: *const FileRoute) ?u64 {\n+    if (this.has_last_modified_header) {\n+        if (this.headers.get(\"last-modified\")) |last_modified| {\n+            var string = bun.String.init(last_modified);\n+            defer string.deref();\n+            const date_f64 = bun.String.parseDate(&string, bun.JSC.VirtualMachine.get().global);\n+            if (!std.math.isNan(date_f64) and std.math.isFinite(date_f64)) {\n+                return @intFromFloat(date_f64);\n+            }\n+        }\n+    }\n+\n+    if (this.stat_hash.last_modified_u64 > 0) {\n+        return this.stat_hash.last_modified_u64;\n+    }\n+\n+    return null;\n+}\n+\n+pub fn initFromBlob(blob: Blob, opts: InitOptions) *FileRoute {\n+    const headers = Headers.from(null, bun.default_allocator, .{ .body = &.{ .Blob = blob } }) catch bun.outOfMemory();\n+    return bun.new(FileRoute, .{\n+        .ref_count = .init(),\n+        .server = opts.server,\n+        .blob = blob,\n+        .headers = headers,\n+        .status_code = opts.status_code,\n+    });\n+}\n+\n+fn deinit(this: *FileRoute) void {\n+    this.blob.deinit();\n+    this.headers.deinit();\n+    bun.destroy(this);\n+}\n+\n+pub fn memoryCost(this: *const FileRoute) usize {\n+    return @sizeOf(FileRoute) + this.headers.memoryCost() + this.blob.reported_estimated_size;\n+}\n+\n+pub fn fromJS(globalThis: *JSC.JSGlobalObject, argument: JSC.JSValue) bun.JSError!?*FileRoute {\n+    if (argument.as(JSC.WebCore.Response)) |response| {\n+        response.body.value.toBlobIfPossible();\n+        if (response.body.value == .Blob and response.body.value.Blob.needsToReadFile()) {\n+            if (response.body.value.Blob.store.?.data.file.pathlike == .fd) {\n+                return globalThis.throwTODO(\"Support serving files from a file descriptor. Please pass a path instead.\");\n+            }\n+\n+            var blob = response.body.value.use();\n+\n+            blob.globalThis = globalThis;\n+            blob.allocator = null;\n+            response.body.value = .{ .Blob = blob.dupe() };\n+            const headers = Headers.from(response.init.headers, bun.default_allocator, .{ .body = &.{ .Blob = blob } }) catch bun.outOfMemory();\n+\n+            return bun.new(FileRoute, .{\n+                .ref_count = .init(),\n+                .server = null,\n+                .blob = blob,\n+                .headers = headers,\n+                .has_last_modified_header = headers.get(\"last-modified\") != null,\n+                .has_content_length_header = headers.get(\"content-length\") != null,\n+                .status_code = response.statusCode(),\n+            });\n+        }\n+    }\n+    if (argument.as(Blob)) |blob| {\n+        if (blob.needsToReadFile()) {\n+            var b = blob.dupe();\n+            b.globalThis = globalThis;\n+            b.allocator = null;\n+            return bun.new(FileRoute, .{\n+                .ref_count = .init(),\n+                .server = null,\n+                .blob = b,\n+                .headers = Headers.from(null, bun.default_allocator, .{ .body = &.{ .Blob = b } }) catch bun.outOfMemory(),\n+                .has_content_length_header = false,\n+                .has_last_modified_header = false,\n+                .status_code = 200,\n+            });\n+        }\n+    }\n+    return null;\n+}\n+\n+fn writeHeaders(this: *FileRoute, resp: AnyResponse) void {\n+    const entries = this.headers.entries.slice();\n+    const names = entries.items(.name);\n+    const values = entries.items(.value);\n+    const buf = this.headers.buf.items;\n+\n+    switch (resp) {\n+        inline .SSL, .TCP => |s| {\n+            for (names, values) |name, value| {\n+                s.writeHeader(name.slice(buf), value.slice(buf));\n+            }\n+        },\n+    }\n+\n+    if (!this.has_last_modified_header) {\n+        if (this.stat_hash.lastModified()) |last_modified| {\n+            resp.writeHeader(\"last-modified\", last_modified);\n+        }\n+    }\n+\n+    if (this.has_content_length_header) {\n+        resp.markWroteContentLengthHeader();\n+    }\n+}\n+\n+fn writeStatusCode(_: *FileRoute, status: u16, resp: AnyResponse) void {\n+    switch (resp) {\n+        .SSL => |r| writeStatus(true, r, status),\n+        .TCP => |r| writeStatus(false, r, status),\n+    }\n+}\n+\n+pub fn onHEADRequest(this: *FileRoute, req: *uws.Request, resp: AnyResponse) void {\n+    bun.debugAssert(this.server != null);\n+\n+    this.on(req, resp, .HEAD);\n+}\n+\n+pub fn onRequest(this: *FileRoute, req: *uws.Request, resp: AnyResponse) void {\n+    this.on(req, resp, bun.http.Method.find(req.method()) orelse .GET);\n+}\n+\n+pub fn on(this: *FileRoute, req: *uws.Request, resp: AnyResponse, method: bun.http.Method) void {\n+    bun.debugAssert(this.server != null);\n+    this.ref();\n+    if (this.server) |server| {\n+        server.onPendingRequest();\n+        resp.timeout(server.config().idleTimeout);\n+    }\n+    const path = this.blob.store.?.getPath() orelse {\n+        req.setYield(true);\n+        this.deref();\n+        return;\n+    };\n+\n+    const open_flags = bun.O.RDONLY | bun.O.CLOEXEC | bun.O.NONBLOCK;\n+    const fd_result = bun.sys.openA(\n+        path,\n+        open_flags,\n+        0,\n+    );\n+    if (fd_result == .err) {\n+        req.setYield(true);\n+        this.deref();\n+        return;\n+    }\n+\n+    const fd = fd_result.result.makeLibUVOwned() catch {\n+        req.setYield(true);\n+        this.deref();\n+        return;\n+    };",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2133794656",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20198,
        "pr_file": "src/bun.js/api/server/FileRoute.zig",
        "discussion_id": "2133794656",
        "commented_code": "@@ -0,0 +1,576 @@\n+const FileRoute = @This();\n+\n+ref_count: RefCount,\n+server: ?AnyServer = null,\n+blob: Blob,\n+headers: Headers = .{ .allocator = bun.default_allocator },\n+status_code: u16,\n+stat_hash: bun.fs.StatHash = .{},\n+has_last_modified_header: bool,\n+has_content_length_header: bool,\n+\n+pub const InitOptions = struct {\n+    server: ?AnyServer,\n+    status_code: u16 = 200,\n+};\n+\n+pub fn lastModifiedDate(this: *const FileRoute) ?u64 {\n+    if (this.has_last_modified_header) {\n+        if (this.headers.get(\"last-modified\")) |last_modified| {\n+            var string = bun.String.init(last_modified);\n+            defer string.deref();\n+            const date_f64 = bun.String.parseDate(&string, bun.JSC.VirtualMachine.get().global);\n+            if (!std.math.isNan(date_f64) and std.math.isFinite(date_f64)) {\n+                return @intFromFloat(date_f64);\n+            }\n+        }\n+    }\n+\n+    if (this.stat_hash.last_modified_u64 > 0) {\n+        return this.stat_hash.last_modified_u64;\n+    }\n+\n+    return null;\n+}\n+\n+pub fn initFromBlob(blob: Blob, opts: InitOptions) *FileRoute {\n+    const headers = Headers.from(null, bun.default_allocator, .{ .body = &.{ .Blob = blob } }) catch bun.outOfMemory();\n+    return bun.new(FileRoute, .{\n+        .ref_count = .init(),\n+        .server = opts.server,\n+        .blob = blob,\n+        .headers = headers,\n+        .status_code = opts.status_code,\n+    });\n+}\n+\n+fn deinit(this: *FileRoute) void {\n+    this.blob.deinit();\n+    this.headers.deinit();\n+    bun.destroy(this);\n+}\n+\n+pub fn memoryCost(this: *const FileRoute) usize {\n+    return @sizeOf(FileRoute) + this.headers.memoryCost() + this.blob.reported_estimated_size;\n+}\n+\n+pub fn fromJS(globalThis: *JSC.JSGlobalObject, argument: JSC.JSValue) bun.JSError!?*FileRoute {\n+    if (argument.as(JSC.WebCore.Response)) |response| {\n+        response.body.value.toBlobIfPossible();\n+        if (response.body.value == .Blob and response.body.value.Blob.needsToReadFile()) {\n+            if (response.body.value.Blob.store.?.data.file.pathlike == .fd) {\n+                return globalThis.throwTODO(\"Support serving files from a file descriptor. Please pass a path instead.\");\n+            }\n+\n+            var blob = response.body.value.use();\n+\n+            blob.globalThis = globalThis;\n+            blob.allocator = null;\n+            response.body.value = .{ .Blob = blob.dupe() };\n+            const headers = Headers.from(response.init.headers, bun.default_allocator, .{ .body = &.{ .Blob = blob } }) catch bun.outOfMemory();\n+\n+            return bun.new(FileRoute, .{\n+                .ref_count = .init(),\n+                .server = null,\n+                .blob = blob,\n+                .headers = headers,\n+                .has_last_modified_header = headers.get(\"last-modified\") != null,\n+                .has_content_length_header = headers.get(\"content-length\") != null,\n+                .status_code = response.statusCode(),\n+            });\n+        }\n+    }\n+    if (argument.as(Blob)) |blob| {\n+        if (blob.needsToReadFile()) {\n+            var b = blob.dupe();\n+            b.globalThis = globalThis;\n+            b.allocator = null;\n+            return bun.new(FileRoute, .{\n+                .ref_count = .init(),\n+                .server = null,\n+                .blob = b,\n+                .headers = Headers.from(null, bun.default_allocator, .{ .body = &.{ .Blob = b } }) catch bun.outOfMemory(),\n+                .has_content_length_header = false,\n+                .has_last_modified_header = false,\n+                .status_code = 200,\n+            });\n+        }\n+    }\n+    return null;\n+}\n+\n+fn writeHeaders(this: *FileRoute, resp: AnyResponse) void {\n+    const entries = this.headers.entries.slice();\n+    const names = entries.items(.name);\n+    const values = entries.items(.value);\n+    const buf = this.headers.buf.items;\n+\n+    switch (resp) {\n+        inline .SSL, .TCP => |s| {\n+            for (names, values) |name, value| {\n+                s.writeHeader(name.slice(buf), value.slice(buf));\n+            }\n+        },\n+    }\n+\n+    if (!this.has_last_modified_header) {\n+        if (this.stat_hash.lastModified()) |last_modified| {\n+            resp.writeHeader(\"last-modified\", last_modified);\n+        }\n+    }\n+\n+    if (this.has_content_length_header) {\n+        resp.markWroteContentLengthHeader();\n+    }\n+}\n+\n+fn writeStatusCode(_: *FileRoute, status: u16, resp: AnyResponse) void {\n+    switch (resp) {\n+        .SSL => |r| writeStatus(true, r, status),\n+        .TCP => |r| writeStatus(false, r, status),\n+    }\n+}\n+\n+pub fn onHEADRequest(this: *FileRoute, req: *uws.Request, resp: AnyResponse) void {\n+    bun.debugAssert(this.server != null);\n+\n+    this.on(req, resp, .HEAD);\n+}\n+\n+pub fn onRequest(this: *FileRoute, req: *uws.Request, resp: AnyResponse) void {\n+    this.on(req, resp, bun.http.Method.find(req.method()) orelse .GET);\n+}\n+\n+pub fn on(this: *FileRoute, req: *uws.Request, resp: AnyResponse, method: bun.http.Method) void {\n+    bun.debugAssert(this.server != null);\n+    this.ref();\n+    if (this.server) |server| {\n+        server.onPendingRequest();\n+        resp.timeout(server.config().idleTimeout);\n+    }\n+    const path = this.blob.store.?.getPath() orelse {\n+        req.setYield(true);\n+        this.deref();\n+        return;\n+    };\n+\n+    const open_flags = bun.O.RDONLY | bun.O.CLOEXEC | bun.O.NONBLOCK;\n+    const fd_result = bun.sys.openA(\n+        path,\n+        open_flags,\n+        0,\n+    );\n+    if (fd_result == .err) {\n+        req.setYield(true);\n+        this.deref();\n+        return;\n+    }\n+\n+    const fd = fd_result.result.makeLibUVOwned() catch {\n+        req.setYield(true);\n+        this.deref();\n+        return;\n+    };",
        "comment_created_at": "2025-06-07T12:26:40+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "The code correctly handles errors from `openA` but has a potential file descriptor leak when `makeLibUVOwned` fails. In this case, the file descriptor obtained from `fd_result.result` should be closed before returning. Consider adding a cleanup step:\n\n```zig\nconst fd = fd_result.result.makeLibUVOwned() catch {\n    // Close the raw file descriptor to prevent leaks\n    bun.sys.close(fd_result.result);\n    req.setYield(true);\n    this.deref();\n    return;\n};\n```\n\nThis ensures proper resource cleanup in all error paths.\n```suggestion\n\n    if (fd_result == .err) {\n        req.setYield(true);\n        this.deref();\n        return;\n    }\n\n    const fd = fd_result.result.makeLibUVOwned() catch {\n        // Close the raw file descriptor to prevent leaks\n        bun.sys.close(fd_result.result);\n        req.setYield(true);\n        this.deref();\n        return;\n    };\n\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2130956073",
    "pr_number": 20214,
    "pr_file": "src/bake/DevServer.zig",
    "created_at": "2025-06-05T23:43:53+00:00",
    "commented_code": "if (dev.has_tailwind_plugin_hack) |*map| {\n             const first_1024 = code.buffer[0..@min(code.buffer.len, 1024)];\n             if (std.mem.indexOf(u8, first_1024, \"tailwind\") != null) {\n-                try map.put(dev.allocator, key, {});\n+                try map.put(dev.allocator, try dev.allocator.dupe(u8, key), {});",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2130956073",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20214,
        "pr_file": "src/bake/DevServer.zig",
        "discussion_id": "2130956073",
        "commented_code": "@@ -2411,7 +2414,7 @@ pub fn finalizeBundle(\n         if (dev.has_tailwind_plugin_hack) |*map| {\n             const first_1024 = code.buffer[0..@min(code.buffer.len, 1024)];\n             if (std.mem.indexOf(u8, first_1024, \"tailwind\") != null) {\n-                try map.put(dev.allocator, key, {});\n+                try map.put(dev.allocator, try dev.allocator.dupe(u8, key), {});",
        "comment_created_at": "2025-06-05T23:43:53+00:00",
        "comment_author": "190n",
        "comment_body": "If dupe succeeds and put fails we leak the key\r\n```suggestion\r\n                const stable_key = try dev.allocator.dupe(u8, key);\r\n                errdefer dev.allocator.free(stable_key);\r\n                try map.put(dev.allocator, stable_key, {});\r\n\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2130961759",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20214,
        "pr_file": "src/bake/DevServer.zig",
        "discussion_id": "2130956073",
        "commented_code": "@@ -2411,7 +2414,7 @@ pub fn finalizeBundle(\n         if (dev.has_tailwind_plugin_hack) |*map| {\n             const first_1024 = code.buffer[0..@min(code.buffer.len, 1024)];\n             if (std.mem.indexOf(u8, first_1024, \"tailwind\") != null) {\n-                try map.put(dev.allocator, key, {});\n+                try map.put(dev.allocator, try dev.allocator.dupe(u8, key), {});",
        "comment_created_at": "2025-06-05T23:45:56+00:00",
        "comment_author": "190n",
        "comment_body": "also agree on keeping `getOrPut` since this leaks the key if there was an existing entry",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2103962220",
    "pr_number": 19766,
    "pr_file": "src/bun.zig",
    "created_at": "2025-05-23T07:14:15+00:00",
    "commented_code": "pub var argv: [][:0]const u8 = &[_][:0]const u8{};\n \n+fn appendOptionsEnv(env: []const u8, args: *std.ArrayList([:0]const u8), allocator: std.mem.Allocator) !void {\n+    var i: usize = 0;\n+    var offset_in_args: usize = 1;\n+    while (i < env.len) {\n+        // skip whitespace\n+        while (i < env.len and std.ascii.isWhitespace(env[i])) : (i += 1) {}\n+        if (i >= env.len) break;\n+\n+        // Handle all command-line arguments with quotes preserved\n+        const start = i;\n+        var j = i;\n+\n+        // Check if this is an option (starts with --)\n+        const is_option = j + 2 <= env.len and env[j] == '-' and env[j + 1] == '-';\n+\n+        if (is_option) {\n+            // Find the end of the option flag (--flag)\n+            while (j < env.len and !std.ascii.isWhitespace(env[j]) and env[j] != '=') : (j += 1) {}\n+\n+            var found_equals = false;\n+\n+            // Check for equals sign\n+            if (j < env.len and env[j] == '=') {\n+                found_equals = true;\n+                j += 1; // Move past the equals sign\n+            } else if (j < env.len and std.ascii.isWhitespace(env[j])) {\n+                j += 1; // Move past the space\n+                // Skip any additional whitespace\n+                while (j < env.len and std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Handle quoted values\n+            if (j < env.len and (env[j] == '\\'' or env[j] == '\"')) {\n+                const quote_char = env[j];\n+                j += 1; // Move past opening quote\n+\n+                // Find the closing quote\n+                while (j < env.len and env[j] != quote_char) : (j += 1) {}\n+                if (j < env.len) j += 1; // Move past closing quote\n+            } else if (found_equals) {\n+                // If we had --flag=value (no quotes), find next whitespace\n+                while (j < env.len and !std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Copy the entire argument including quotes\n+            const arg_len = j - start;\n+            const arg = try allocator.allocSentinel(u8, arg_len, 0);\n+            @memcpy(arg, env[start..j]);\n+            try args.insert(offset_in_args, arg);\n+            offset_in_args += 1;\n+\n+            i = j;\n+            continue;\n+        }\n+\n+        // Non-option arguments or standalone values\n+        var buf = std.ArrayList(u8).init(allocator);\n+\n+        var in_single = false;\n+        var in_double = false;\n+        var escape = false;\n+        while (i < env.len) : (i += 1) {\n+            const ch = env[i];\n+            if (escape) {\n+                try buf.append(ch);\n+                escape = false;\n+                continue;\n+            }\n+\n+            if (ch == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+\n+            if (in_single) {\n+                if (ch == '\\'') {\n+                    in_single = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (in_double) {\n+                if (ch == '\"') {\n+                    in_double = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (ch == '\\'') {\n+                in_single = true;\n+            } else if (ch == '\"') {\n+                in_double = true;\n+            } else if (std.ascii.isWhitespace(ch)) {\n+                break;\n+            } else {\n+                try buf.append(ch);\n+            }\n+        }\n+\n+        try buf.append(0);\n+        const owned = try buf.toOwnedSlice();\n+        try args.insert(offset_in_args, owned[0 .. owned.len - 1 :0]);\n+        offset_in_args += 1;\n+    }",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2103962220",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19766,
        "pr_file": "src/bun.zig",
        "discussion_id": "2103962220",
        "commented_code": "@@ -1986,6 +1986,116 @@ pub const StatFS = switch (Environment.os) {\n \n pub var argv: [][:0]const u8 = &[_][:0]const u8{};\n \n+fn appendOptionsEnv(env: []const u8, args: *std.ArrayList([:0]const u8), allocator: std.mem.Allocator) !void {\n+    var i: usize = 0;\n+    var offset_in_args: usize = 1;\n+    while (i < env.len) {\n+        // skip whitespace\n+        while (i < env.len and std.ascii.isWhitespace(env[i])) : (i += 1) {}\n+        if (i >= env.len) break;\n+\n+        // Handle all command-line arguments with quotes preserved\n+        const start = i;\n+        var j = i;\n+\n+        // Check if this is an option (starts with --)\n+        const is_option = j + 2 <= env.len and env[j] == '-' and env[j + 1] == '-';\n+\n+        if (is_option) {\n+            // Find the end of the option flag (--flag)\n+            while (j < env.len and !std.ascii.isWhitespace(env[j]) and env[j] != '=') : (j += 1) {}\n+\n+            var found_equals = false;\n+\n+            // Check for equals sign\n+            if (j < env.len and env[j] == '=') {\n+                found_equals = true;\n+                j += 1; // Move past the equals sign\n+            } else if (j < env.len and std.ascii.isWhitespace(env[j])) {\n+                j += 1; // Move past the space\n+                // Skip any additional whitespace\n+                while (j < env.len and std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Handle quoted values\n+            if (j < env.len and (env[j] == '\\'' or env[j] == '\"')) {\n+                const quote_char = env[j];\n+                j += 1; // Move past opening quote\n+\n+                // Find the closing quote\n+                while (j < env.len and env[j] != quote_char) : (j += 1) {}\n+                if (j < env.len) j += 1; // Move past closing quote\n+            } else if (found_equals) {\n+                // If we had --flag=value (no quotes), find next whitespace\n+                while (j < env.len and !std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Copy the entire argument including quotes\n+            const arg_len = j - start;\n+            const arg = try allocator.allocSentinel(u8, arg_len, 0);\n+            @memcpy(arg, env[start..j]);\n+            try args.insert(offset_in_args, arg);\n+            offset_in_args += 1;\n+\n+            i = j;\n+            continue;\n+        }\n+\n+        // Non-option arguments or standalone values\n+        var buf = std.ArrayList(u8).init(allocator);\n+\n+        var in_single = false;\n+        var in_double = false;\n+        var escape = false;\n+        while (i < env.len) : (i += 1) {\n+            const ch = env[i];\n+            if (escape) {\n+                try buf.append(ch);\n+                escape = false;\n+                continue;\n+            }\n+\n+            if (ch == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+\n+            if (in_single) {\n+                if (ch == '\\'') {\n+                    in_single = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (in_double) {\n+                if (ch == '\"') {\n+                    in_double = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (ch == '\\'') {\n+                in_single = true;\n+            } else if (ch == '\"') {\n+                in_double = true;\n+            } else if (std.ascii.isWhitespace(ch)) {\n+                break;\n+            } else {\n+                try buf.append(ch);\n+            }\n+        }\n+\n+        try buf.append(0);\n+        const owned = try buf.toOwnedSlice();\n+        try args.insert(offset_in_args, owned[0 .. owned.len - 1 :0]);\n+        offset_in_args += 1;\n+    }",
        "comment_created_at": "2025-05-23T07:14:15+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "The `buf` ArrayList should be properly cleaned up with a `defer buf.deinit();` statement after initialization. This ensures memory is released even if an error occurs during the append operations. Without this cleanup, memory leaks could occur in error scenarios.\n```suggestion\n        var buf = std.ArrayList(u8).init(allocator);\n        defer buf.deinit();\n\n        var in_single = false;\n        var in_double = false;\n        var escape = false;\n        while (i < env.len) : (i += 1) {\n            const ch = env[i];\n            if (escape) {\n                try buf.append(ch);\n                escape = false;\n                continue;\n            }\n\n            if (ch == '\\\\') {\n                escape = true;\n                continue;\n            }\n\n            if (in_single) {\n                if (ch == '\\'') {\n                    in_single = false;\n                } else {\n                    try buf.append(ch);\n                }\n                continue;\n            }\n\n            if (in_double) {\n                if (ch == '\"') {\n                    in_double = false;\n                } else {\n                    try buf.append(ch);\n                }\n                continue;\n            }\n\n            if (ch == '\\'') {\n                in_single = true;\n            } else if (ch == '\"') {\n                in_double = true;\n            } else if (std.ascii.isWhitespace(ch)) {\n                break;\n            } else {\n                try buf.append(ch);\n            }\n        }\n\n        try buf.append(0);\n        const owned = try buf.toOwnedSlice();\n        try args.insert(offset_in_args, owned[0 .. owned.len - 1 :0]);\n        offset_in_args += 1;\n    }\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      },
      {
        "comment_id": "2103968228",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19766,
        "pr_file": "src/bun.zig",
        "discussion_id": "2103962220",
        "commented_code": "@@ -1986,6 +1986,116 @@ pub const StatFS = switch (Environment.os) {\n \n pub var argv: [][:0]const u8 = &[_][:0]const u8{};\n \n+fn appendOptionsEnv(env: []const u8, args: *std.ArrayList([:0]const u8), allocator: std.mem.Allocator) !void {\n+    var i: usize = 0;\n+    var offset_in_args: usize = 1;\n+    while (i < env.len) {\n+        // skip whitespace\n+        while (i < env.len and std.ascii.isWhitespace(env[i])) : (i += 1) {}\n+        if (i >= env.len) break;\n+\n+        // Handle all command-line arguments with quotes preserved\n+        const start = i;\n+        var j = i;\n+\n+        // Check if this is an option (starts with --)\n+        const is_option = j + 2 <= env.len and env[j] == '-' and env[j + 1] == '-';\n+\n+        if (is_option) {\n+            // Find the end of the option flag (--flag)\n+            while (j < env.len and !std.ascii.isWhitespace(env[j]) and env[j] != '=') : (j += 1) {}\n+\n+            var found_equals = false;\n+\n+            // Check for equals sign\n+            if (j < env.len and env[j] == '=') {\n+                found_equals = true;\n+                j += 1; // Move past the equals sign\n+            } else if (j < env.len and std.ascii.isWhitespace(env[j])) {\n+                j += 1; // Move past the space\n+                // Skip any additional whitespace\n+                while (j < env.len and std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Handle quoted values\n+            if (j < env.len and (env[j] == '\\'' or env[j] == '\"')) {\n+                const quote_char = env[j];\n+                j += 1; // Move past opening quote\n+\n+                // Find the closing quote\n+                while (j < env.len and env[j] != quote_char) : (j += 1) {}\n+                if (j < env.len) j += 1; // Move past closing quote\n+            } else if (found_equals) {\n+                // If we had --flag=value (no quotes), find next whitespace\n+                while (j < env.len and !std.ascii.isWhitespace(env[j])) : (j += 1) {}\n+            }\n+\n+            // Copy the entire argument including quotes\n+            const arg_len = j - start;\n+            const arg = try allocator.allocSentinel(u8, arg_len, 0);\n+            @memcpy(arg, env[start..j]);\n+            try args.insert(offset_in_args, arg);\n+            offset_in_args += 1;\n+\n+            i = j;\n+            continue;\n+        }\n+\n+        // Non-option arguments or standalone values\n+        var buf = std.ArrayList(u8).init(allocator);\n+\n+        var in_single = false;\n+        var in_double = false;\n+        var escape = false;\n+        while (i < env.len) : (i += 1) {\n+            const ch = env[i];\n+            if (escape) {\n+                try buf.append(ch);\n+                escape = false;\n+                continue;\n+            }\n+\n+            if (ch == '\\\\') {\n+                escape = true;\n+                continue;\n+            }\n+\n+            if (in_single) {\n+                if (ch == '\\'') {\n+                    in_single = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (in_double) {\n+                if (ch == '\"') {\n+                    in_double = false;\n+                } else {\n+                    try buf.append(ch);\n+                }\n+                continue;\n+            }\n+\n+            if (ch == '\\'') {\n+                in_single = true;\n+            } else if (ch == '\"') {\n+                in_double = true;\n+            } else if (std.ascii.isWhitespace(ch)) {\n+                break;\n+            } else {\n+                try buf.append(ch);\n+            }\n+        }\n+\n+        try buf.append(0);\n+        const owned = try buf.toOwnedSlice();\n+        try args.insert(offset_in_args, owned[0 .. owned.len - 1 :0]);\n+        offset_in_args += 1;\n+    }",
        "comment_created_at": "2025-05-23T07:18:24+00:00",
        "comment_author": "nektro",
        "comment_body": "buf.toOwnedSlice handles this",
        "pr_file_module": null
      }
    ]
  }
]