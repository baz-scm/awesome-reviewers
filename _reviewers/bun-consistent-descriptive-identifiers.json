[
  {
    "discussion_id": "2201901696",
    "pr_number": 20977,
    "pr_file": "test/integration/bun-types/bun-types.test.ts",
    "created_at": "2025-07-11T21:22:02+00:00",
    "commented_code": "}\n });\n \n-async function diagnose(fixtureDir: string, tsconfig: Partial<ts.CompilerOptions>) {\n+async function diagnose(\n+  fixtureDir: string,\n+  config: {\n+    /** Extra tsconfig compiler options */\n+    options?: Partial<ts.CompilerOptions>;\n+    /** Specify extra files to include in the build */\n+    files?: Record<string, string>;\n+  } = {},\n+) {\n+  const tsconfig = config.options ?? {};\n+  const extraFiles = config.files;",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2201901696",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20977,
        "pr_file": "test/integration/bun-types/bun-types.test.ts",
        "discussion_id": "2201901696",
        "commented_code": "@@ -73,14 +73,34 @@ beforeAll(async () => {\n   }\n });\n \n-async function diagnose(fixtureDir: string, tsconfig: Partial<ts.CompilerOptions>) {\n+async function diagnose(\n+  fixtureDir: string,\n+  config: {\n+    /** Extra tsconfig compiler options */\n+    options?: Partial<ts.CompilerOptions>;\n+    /** Specify extra files to include in the build */\n+    files?: Record<string, string>;\n+  } = {},\n+) {\n+  const tsconfig = config.options ?? {};\n+  const extraFiles = config.files;",
        "comment_created_at": "2025-07-11T21:22:02+00:00",
        "comment_author": "Copilot",
        "comment_body": "[nitpick] The `files` field in the config object overlaps with the local `files` array in `diagnose`. Consider renaming it to `extraFiles` to improve clarity and avoid confusion.\n```suggestion\n    extraFiles?: Record<string, string>;\n  } = {},\n) {\n  const tsconfig = config.options ?? {};\n  const extraFiles = config.extraFiles;\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2062956776",
    "pr_number": 19167,
    "pr_file": "packages/bun-types/bun.d.ts",
    "created_at": "2025-04-28T06:20:50+00:00",
    "commented_code": "export function parse(input: string): object;\n   }\n \n+  /**\n+   * CSV related APIs\n+   */\n+  namespace CSV {\n+    /**\n+     * Options for parsing CSV strings.\n+     */\n+    export interface CSVParserOptions {\n+      /**\n+       * Whether the CSV has a header row.\n+       * If true, returns an array of objects. If false, returns an array of arrays.\n+       * @default true\n+       */\n+      header?: boolean;\n+      /**\n+       * The delimiter character to use.\n+       * @default ','\n+       */\n+      delimiter?: string;\n+      /**\n+       * Whether to allow comments in the CSV.\n+       * @default true\n+       */\n+      comments?: boolean;\n+      /**\n+       * The character used to denote comments.\n+       * @default '#'\n+       */\n+      commentChar?: string;\n+      /**\n+       * Whether to trim whitespace from fields.\n+       * @default false\n+       */\n+      trim_whitespace?: boolean;\n+      /**\n+       * Whether to enable dynamic typing for fields.\n+       * @default false\n+       */\n+      dynamic_typing?: boolean;",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2062956776",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19167,
        "pr_file": "packages/bun-types/bun.d.ts",
        "discussion_id": "2062956776",
        "commented_code": "@@ -610,6 +610,98 @@ declare module \"bun\" {\n     export function parse(input: string): object;\n   }\n \n+  /**\n+   * CSV related APIs\n+   */\n+  namespace CSV {\n+    /**\n+     * Options for parsing CSV strings.\n+     */\n+    export interface CSVParserOptions {\n+      /**\n+       * Whether the CSV has a header row.\n+       * If true, returns an array of objects. If false, returns an array of arrays.\n+       * @default true\n+       */\n+      header?: boolean;\n+      /**\n+       * The delimiter character to use.\n+       * @default ','\n+       */\n+      delimiter?: string;\n+      /**\n+       * Whether to allow comments in the CSV.\n+       * @default true\n+       */\n+      comments?: boolean;\n+      /**\n+       * The character used to denote comments.\n+       * @default '#'\n+       */\n+      commentChar?: string;\n+      /**\n+       * Whether to trim whitespace from fields.\n+       * @default false\n+       */\n+      trim_whitespace?: boolean;\n+      /**\n+       * Whether to enable dynamic typing for fields.\n+       * @default false\n+       */\n+      dynamic_typing?: boolean;",
        "comment_created_at": "2025-04-28T06:20:50+00:00",
        "comment_author": "KilianB",
        "comment_body": "Camel case. And could you add a more descriptive comment. Currently I have no idea what the setting does. \n\nAccording to papa parse this will auto convert numbers and booleans, has this been implemented? A test for this would be great.",
        "pr_file_module": null
      },
      {
        "comment_id": "2063639046",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19167,
        "pr_file": "packages/bun-types/bun.d.ts",
        "discussion_id": "2062956776",
        "commented_code": "@@ -610,6 +610,98 @@ declare module \"bun\" {\n     export function parse(input: string): object;\n   }\n \n+  /**\n+   * CSV related APIs\n+   */\n+  namespace CSV {\n+    /**\n+     * Options for parsing CSV strings.\n+     */\n+    export interface CSVParserOptions {\n+      /**\n+       * Whether the CSV has a header row.\n+       * If true, returns an array of objects. If false, returns an array of arrays.\n+       * @default true\n+       */\n+      header?: boolean;\n+      /**\n+       * The delimiter character to use.\n+       * @default ','\n+       */\n+      delimiter?: string;\n+      /**\n+       * Whether to allow comments in the CSV.\n+       * @default true\n+       */\n+      comments?: boolean;\n+      /**\n+       * The character used to denote comments.\n+       * @default '#'\n+       */\n+      commentChar?: string;\n+      /**\n+       * Whether to trim whitespace from fields.\n+       * @default false\n+       */\n+      trim_whitespace?: boolean;\n+      /**\n+       * Whether to enable dynamic typing for fields.\n+       * @default false\n+       */\n+      dynamic_typing?: boolean;",
        "comment_created_at": "2025-04-28T13:16:21+00:00",
        "comment_author": "mastermakrela",
        "comment_body": "I'll add more info (and docs page) when I'm done with the implementation.\n\nThe tests are already there, but they don't pass as mentioned here: https://github.com/oven-sh/bun/pull/19167#issuecomment-2833640563\n\nI had to define the interface, so TS wouldn't complain ;) ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2203846235",
    "pr_number": 20645,
    "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
    "created_at": "2025-07-14T04:54:52+00:00",
    "commented_code": "+import { spawn, type ChildProcess } from \"node:child_process\";\n+import * as fs from \"node:fs/promises\";\n+import * as net from \"node:net\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import {\n+  getAvailablePort,\n+  NodeSocketDebugAdapter,\n+  TCPSocketSignal,\n+  UnixSignal,\n+} from \"../../../../bun-debug-adapter-protocol\";\n+import type { JSC } from \"../../../../bun-inspector-protocol\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export const debug = vscode.window.createOutputChannel(\"Bun - Test Runner\");\n+\n+export type TestNode = {\n+  name: string;\n+  type: \"describe\" | \"test\" | \"it\";\n+  line: number;\n+  children: TestNode[];\n+  parent?: TestNode;\n+  startIdx: number;\n+};\n+\n+export interface TestError {\n+  message: string;\n+  file: string;\n+  line: number;\n+  column: number;\n+}\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+  private debugAdapter: NodeSocketDebugAdapter | null = null;\n+  private signal: UnixSignal | TCPSocketSignal | null = null;\n+\n+  private inspectorToVSCode = new Map<number, vscode.TestItem>();\n+  private vscodeToInspector = new Map<string, number>();\n+\n+  private testErrors = new Map<number, TestError>();\n+  private lastStartedTestId: number | null = null;\n+  private currentRun: vscode.TestRun | null = null;\n+\n+  private testResultHistory = new Map<\n+    string,\n+    { status: \"passed\" | \"failed\" | \"skipped\"; message?: vscode.TestMessage; duration?: number }\n+  >();\n+  private currentRunType: \"file\" | \"individual\" = \"file\";\n+  private requestedTestIds: Set<string> = new Set();\n+  private discoveredTestIds: Set<string> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+    this.initializeSignal();\n+  }\n+\n+  private async initializeSignal(): Promise<void> {\n+    try {\n+      this.signal = await this.createSignal();\n+      await this.signal.ready;\n+      debug.appendLine(`Signal initialized at: ${this.signal.url}`);\n+\n+      this.signal.on(\"Signal.Socket.connect\", (socket: net.Socket) => {\n+        debug.appendLine(\"Bun connected to signal socket\");\n+        this.handleSocketConnection(socket, this.currentRun!);\n+      });\n+\n+      this.signal.on(\"Signal.error\", (error: Error) => {\n+        debug.appendLine(`Signal error: ${error.message}`);\n+      });\n+    } catch (error) {\n+      debug.appendLine(`Failed to initialize signal: ${error}`);\n+    }\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      if (!testItem) return;\n+      return this.discoverTests(testItem);\n+    };\n+\n+    this.testController.refreshHandler = async token => {\n+      const files = await this.discoverInitialTests(token);\n+      if (!files?.length) return;\n+\n+      const filePaths = new Set(files.map(f => f.fsPath));\n+      for (const [, testItem] of this.testController.items) {\n+        if (testItem.uri && !filePaths.has(testItem.uri.fsPath)) {\n+          this.testController.items.delete(testItem.id);\n+        }\n+      }\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    vscode.window.visibleTextEditors.forEach(editor => {\n+      this.handleOpenDocument(editor.document);\n+    });\n+\n+    vscode.workspace.textDocuments.forEach(doc => {\n+      this.handleOpenDocument(doc);\n+    });\n+\n+    vscode.workspace.onDidOpenTextDocument(this.handleOpenDocument.bind(this), null, this.disposables);\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.discoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(cancellationToken?: vscode.CancellationToken): Promise<vscode.Uri[] | undefined> {\n+    try {\n+      const tests = await this.findTestFiles(cancellationToken);\n+      this.createFileTestItems(tests);\n+      return tests;\n+    } catch {\n+      return undefined;\n+    }\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFiles(cancellationToken?: vscode.CancellationToken): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs(cancellationToken);\n+    const tests = await vscode.workspace.findFiles(\n+      this.customFilePattern(),\n+      \"node_modules\",\n+      undefined,\n+      cancellationToken,\n+    );\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(cancellationToken?: vscode.CancellationToken): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\n+      \"**/.gitignore\",\n+      \"**/node_modules/**\",\n+      undefined,\n+      cancellationToken,\n+    );\n+    const ignoreGlobs = new Set([\"**/node_modules/**\"]);\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, { encoding: \"utf8\" });\n+        const lines = content\n+          .split(\"\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.add(line.trim());\n+          } else {\n+            ignoreGlobs.add(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch {}\n+    }\n+\n+    return [...ignoreGlobs.values()];\n+  }\n+\n+  private createFileTestItems(files: vscode.Uri[]): void {\n+    if (files.length === 0) {\n+      return;\n+    }\n+\n+    for (const file of files) {\n+      let fileTestItem = this.testController.items.get(windowsVscodeUri(file.fsPath));\n+      if (!fileTestItem) {\n+        fileTestItem = this.testController.createTestItem(\n+          file.toString(),\n+          path.relative(this.workspaceFolder.uri.fsPath, file.fsPath) || file.fsPath,\n+          file,\n+        );\n+        fileTestItem.children.replace([]);\n+        fileTestItem.canResolveChildren = true;\n+        this.testController.items.add(fileTestItem);\n+      }\n+    }\n+  }\n+\n+  private async setupWatchers(): Promise<void> {\n+    const fileWatcher = vscode.workspace.createFileSystemWatcher(\n+      new vscode.RelativePattern(this.workspaceFolder, this.customFilePattern()),\n+    );\n+\n+    const refreshTestsForFile = (uri: vscode.Uri) => {\n+      if (uri.toString().includes(\"node_modules\")) return;\n+\n+      const existing = this.testController.items.get(windowsVscodeUri(uri.fsPath));\n+      if (existing) {\n+        existing.children.replace([]);\n+        this.discoverTests(existing);\n+      } else {\n+        this.discoverTests(false, uri.fsPath);\n+      }\n+    };\n+\n+    fileWatcher.onDidChange(refreshTestsForFile);\n+    fileWatcher.onDidCreate(refreshTestsForFile);\n+    fileWatcher.onDidDelete(uri => {\n+      const existing = this.testController.items.get(windowsVscodeUri(uri.fsPath));\n+      if (existing) {\n+        existing.children.replace([]);\n+        this.testController.items.delete(existing.id);\n+      }\n+    });\n+\n+    this.disposables.push(fileWatcher);\n+  }\n+\n+  private getBunExecutionConfig() {\n+    const customFlag = vscode.workspace.getConfiguration(\"bun.test\").get(\"customFlag\", \"\").trim();\n+    const customScriptSetting = vscode.workspace.getConfiguration(\"bun.test\").get(\"customScript\", \"bun test\").trim();\n+    const customScript = customScriptSetting.length ? customScriptSetting : \"bun test\";\n+\n+    const [cmd, ...args] = customScript.split(/\\s+/);\n+\n+    let bunCommand = \"bun\";\n+    if (cmd === \"bun\") {\n+      const bunRuntime = vscode.workspace.getConfiguration(\"bun\").get<string>(\"runtime\", \"bun\");\n+      bunCommand = bunRuntime || \"bun\";\n+    } else {\n+      bunCommand = cmd;\n+    }\n+\n+    const testArgs = args.length ? args : [\"test\"];\n+    if (customFlag) {\n+      testArgs.push(customFlag);\n+    }\n+\n+    return { bunCommand, testArgs };\n+  }\n+\n+  private async discoverTests(testItem?: vscode.TestItem | false, filePath?: string): Promise<void> {\n+    let targetPath = filePath;\n+    if (!targetPath && testItem) {\n+      targetPath = testItem?.uri?.fsPath || this.workspaceFolder.uri.fsPath;\n+    }\n+    if (!targetPath) {\n+      return;\n+    }\n+\n+    try {\n+      const fileContent = await fs.readFile(targetPath, \"utf8\");\n+      const testNodes = this.parseTestBlocks(fileContent);\n+\n+      const fileUri = vscode.Uri.file(windowsVscodeUri(targetPath));\n+      let fileTestItem = testItem || this.testController.items.get(windowsVscodeUri(targetPath));\n+      if (!fileTestItem) {\n+        fileTestItem = this.testController.createTestItem(\n+          fileUri.toString(),\n+          path.relative(this.workspaceFolder.uri.fsPath, targetPath),\n+          fileUri,\n+        );\n+        this.testController.items.add(fileTestItem);\n+      }\n+      fileTestItem.children.replace([]);\n+      fileTestItem.canResolveChildren = false;\n+\n+      this.addTestNodes(testNodes, fileTestItem, targetPath);\n+    } catch {}\n+  }\n+\n+  private parseTestBlocks(fileContent: string): TestNode[] {\n+    const cleanContent = fileContent\n+      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, match => match.replace(/[^\n\\r]/g, \" \"))\n+      .replace(/\\/\\/.*$/gm, match => \" \".repeat(match.length));\n+\n+    const testRegex =\n+      /\\b(describe|test|it)(?:\\.(?:skip|todo|failing|only))?(?:\\.(?:if|todoIf|skipIf)\\s*\\([^)]*\\))?(?:\\.each\\s*\\([^)]*\\))?\\s*\\(\\s*(['\"`])((?:\\\\\\2|.)*?)\\2\\s*(?:,|\\))/g;\n+\n+    const stack: TestNode[] = [];\n+    const root: TestNode[] = [];\n+    let match: RegExpExecArray | null;\n+\n+    match = testRegex.exec(cleanContent);\n+    while (match !== null) {\n+      const [full, type, , name] = match;\n+      const line = cleanContent.slice(0, match.index).split(\"\n\").length - 1;\n+\n+      while (\n+        stack.length > 0 &&\n+        match.index > stack[stack.length - 1].startIdx &&\n+        this.getBraceDepth(cleanContent, stack[stack.length - 1].startIdx, match.index) <= 0\n+      ) {\n+        stack.pop();\n+      }\n+\n+      const expandedNodes = this.expandEachTests(full, name, cleanContent, match.index, type as TestNode[\"type\"], line);\n+\n+      for (const node of expandedNodes) {\n+        if (stack.length === 0) {\n+          root.push(node);\n+        } else {\n+          stack[stack.length - 1].children.push(node);\n+        }\n+\n+        if (type === \"describe\") {\n+          stack.push(node);\n+        }\n+      }\n+      match = testRegex.exec(cleanContent);\n+    }\n+\n+    return root;\n+  }\n+\n+  private getBraceDepth(content: string, start: number, end: number): number {\n+    const section = content.slice(start, end);\n+    let depth = 0;\n+    let inString = false;\n+    let inTemplate = false;\n+    let stringChar = \"\";\n+    let escaped = false;\n+\n+    for (let i = 0; i < section.length; i++) {\n+      const char = section[i];\n+\n+      if (escaped) {\n+        escaped = false;\n+        continue;\n+      }\n+      if (char === \"\\\\\") {\n+        escaped = true;\n+        continue;\n+      }\n+\n+      if (!inTemplate && (char === '\"' || char === \"'\")) {\n+        if (!inString) {\n+          inString = true;\n+          stringChar = char;\n+        } else if (char === stringChar) {\n+          inString = false;\n+        }\n+        continue;\n+      }\n+\n+      if (char === \"`\") {\n+        inTemplate = !inTemplate;\n+        continue;\n+      }\n+\n+      if (!inString && !inTemplate) {\n+        if (char === \"{\") depth++;\n+        else if (char === \"}\") depth--;\n+      }\n+    }\n+\n+    return depth;\n+  }\n+\n+  private expandEachTests(\n+    fullMatch: string,\n+    name: string,\n+    content: string,\n+    index: number,\n+    type: TestNode[\"type\"],\n+    line: number,\n+  ): TestNode[] {\n+    if (!fullMatch.includes(\".each\")) {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+\n+    const eachMatch = content.slice(index).match(/\\.each\\s*\\(\\s*(\\[[\\s\\S]*?\\])\\s*\\)/);\n+    if (!eachMatch) {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+\n+    const arrayString = eachMatch[1].replace(/,\\s*(?=[\\]\\}])/g, \"\");\n+\n+    try {\n+      const eachValues = JSON.parse(arrayString);\n+      if (!Array.isArray(eachValues)) {\n+        throw new Error(\"Not an array\");\n+      }\n+\n+      return eachValues.map(val => {\n+        let testName = name;\n+        if (Array.isArray(val)) {\n+          let idx = 0;\n+          testName = testName.replace(/%[isfd]/g, () => {\n+            const v = val[idx++];\n+            return typeof v === \"object\" ? JSON.stringify(v) : String(v);\n+          });\n+        } else {\n+          testName = testName.replace(/%[isfd]/g, () => {\n+            return typeof val === \"object\" ? JSON.stringify(val) : String(val);\n+          });\n+        }\n+\n+        return {\n+          name: testName,\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        };\n+      });\n+    } catch {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+  }\n+\n+  private addTestNodes(nodes: TestNode[], parent: vscode.TestItem, filePath: string, parentPath = \"\"): void {\n+    for (const node of nodes) {\n+      const nodePath = parentPath\n+        ? `${parentPath} > ${this.escapeTestName(node.name)}`\n+        : this.escapeTestName(node.name);\n+      const testId = `${filePath}#${nodePath}`;\n+\n+      const testItem = this.testController.createTestItem(testId, this.stripAnsi(node.name), vscode.Uri.file(filePath));\n+\n+      testItem.tags = [new vscode.TestTag(node.type === \"describe\" ? \"describe\" : \"test\")];\n+\n+      if (typeof node.line === \"number\") {\n+        testItem.range = new vscode.Range(\n+          new vscode.Position(node.line, 0),\n+          new vscode.Position(node.line, node.name.length),\n+        );\n+      }\n+\n+      parent.children.add(testItem);\n+\n+      if (node.children.length > 0) {\n+        this.addTestNodes(node.children, testItem, filePath, nodePath);\n+      }\n+      testItem.canResolveChildren = false;\n+    }\n+  }\n+\n+  private stripAnsi(source: string): string {\n+    return source.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g, \"\");\n+  }\n+\n+  private escapeTestName(source: string): string {\n+    return source.replace(/[^a-zA-Z0-9_\\ ]/g, \"\\\\$&\");",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2203846235",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20645,
        "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
        "discussion_id": "2203846235",
        "commented_code": "@@ -0,0 +1,1325 @@\n+import { spawn, type ChildProcess } from \"node:child_process\";\n+import * as fs from \"node:fs/promises\";\n+import * as net from \"node:net\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import {\n+  getAvailablePort,\n+  NodeSocketDebugAdapter,\n+  TCPSocketSignal,\n+  UnixSignal,\n+} from \"../../../../bun-debug-adapter-protocol\";\n+import type { JSC } from \"../../../../bun-inspector-protocol\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export const debug = vscode.window.createOutputChannel(\"Bun - Test Runner\");\n+\n+export type TestNode = {\n+  name: string;\n+  type: \"describe\" | \"test\" | \"it\";\n+  line: number;\n+  children: TestNode[];\n+  parent?: TestNode;\n+  startIdx: number;\n+};\n+\n+export interface TestError {\n+  message: string;\n+  file: string;\n+  line: number;\n+  column: number;\n+}\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+  private debugAdapter: NodeSocketDebugAdapter | null = null;\n+  private signal: UnixSignal | TCPSocketSignal | null = null;\n+\n+  private inspectorToVSCode = new Map<number, vscode.TestItem>();\n+  private vscodeToInspector = new Map<string, number>();\n+\n+  private testErrors = new Map<number, TestError>();\n+  private lastStartedTestId: number | null = null;\n+  private currentRun: vscode.TestRun | null = null;\n+\n+  private testResultHistory = new Map<\n+    string,\n+    { status: \"passed\" | \"failed\" | \"skipped\"; message?: vscode.TestMessage; duration?: number }\n+  >();\n+  private currentRunType: \"file\" | \"individual\" = \"file\";\n+  private requestedTestIds: Set<string> = new Set();\n+  private discoveredTestIds: Set<string> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+    this.initializeSignal();\n+  }\n+\n+  private async initializeSignal(): Promise<void> {\n+    try {\n+      this.signal = await this.createSignal();\n+      await this.signal.ready;\n+      debug.appendLine(`Signal initialized at: ${this.signal.url}`);\n+\n+      this.signal.on(\"Signal.Socket.connect\", (socket: net.Socket) => {\n+        debug.appendLine(\"Bun connected to signal socket\");\n+        this.handleSocketConnection(socket, this.currentRun!);\n+      });\n+\n+      this.signal.on(\"Signal.error\", (error: Error) => {\n+        debug.appendLine(`Signal error: ${error.message}`);\n+      });\n+    } catch (error) {\n+      debug.appendLine(`Failed to initialize signal: ${error}`);\n+    }\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      if (!testItem) return;\n+      return this.discoverTests(testItem);\n+    };\n+\n+    this.testController.refreshHandler = async token => {\n+      const files = await this.discoverInitialTests(token);\n+      if (!files?.length) return;\n+\n+      const filePaths = new Set(files.map(f => f.fsPath));\n+      for (const [, testItem] of this.testController.items) {\n+        if (testItem.uri && !filePaths.has(testItem.uri.fsPath)) {\n+          this.testController.items.delete(testItem.id);\n+        }\n+      }\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    vscode.window.visibleTextEditors.forEach(editor => {\n+      this.handleOpenDocument(editor.document);\n+    });\n+\n+    vscode.workspace.textDocuments.forEach(doc => {\n+      this.handleOpenDocument(doc);\n+    });\n+\n+    vscode.workspace.onDidOpenTextDocument(this.handleOpenDocument.bind(this), null, this.disposables);\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.discoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(cancellationToken?: vscode.CancellationToken): Promise<vscode.Uri[] | undefined> {\n+    try {\n+      const tests = await this.findTestFiles(cancellationToken);\n+      this.createFileTestItems(tests);\n+      return tests;\n+    } catch {\n+      return undefined;\n+    }\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFiles(cancellationToken?: vscode.CancellationToken): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs(cancellationToken);\n+    const tests = await vscode.workspace.findFiles(\n+      this.customFilePattern(),\n+      \"node_modules\",\n+      undefined,\n+      cancellationToken,\n+    );\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(cancellationToken?: vscode.CancellationToken): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\n+      \"**/.gitignore\",\n+      \"**/node_modules/**\",\n+      undefined,\n+      cancellationToken,\n+    );\n+    const ignoreGlobs = new Set([\"**/node_modules/**\"]);\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, { encoding: \"utf8\" });\n+        const lines = content\n+          .split(\"\\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.add(line.trim());\n+          } else {\n+            ignoreGlobs.add(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch {}\n+    }\n+\n+    return [...ignoreGlobs.values()];\n+  }\n+\n+  private createFileTestItems(files: vscode.Uri[]): void {\n+    if (files.length === 0) {\n+      return;\n+    }\n+\n+    for (const file of files) {\n+      let fileTestItem = this.testController.items.get(windowsVscodeUri(file.fsPath));\n+      if (!fileTestItem) {\n+        fileTestItem = this.testController.createTestItem(\n+          file.toString(),\n+          path.relative(this.workspaceFolder.uri.fsPath, file.fsPath) || file.fsPath,\n+          file,\n+        );\n+        fileTestItem.children.replace([]);\n+        fileTestItem.canResolveChildren = true;\n+        this.testController.items.add(fileTestItem);\n+      }\n+    }\n+  }\n+\n+  private async setupWatchers(): Promise<void> {\n+    const fileWatcher = vscode.workspace.createFileSystemWatcher(\n+      new vscode.RelativePattern(this.workspaceFolder, this.customFilePattern()),\n+    );\n+\n+    const refreshTestsForFile = (uri: vscode.Uri) => {\n+      if (uri.toString().includes(\"node_modules\")) return;\n+\n+      const existing = this.testController.items.get(windowsVscodeUri(uri.fsPath));\n+      if (existing) {\n+        existing.children.replace([]);\n+        this.discoverTests(existing);\n+      } else {\n+        this.discoverTests(false, uri.fsPath);\n+      }\n+    };\n+\n+    fileWatcher.onDidChange(refreshTestsForFile);\n+    fileWatcher.onDidCreate(refreshTestsForFile);\n+    fileWatcher.onDidDelete(uri => {\n+      const existing = this.testController.items.get(windowsVscodeUri(uri.fsPath));\n+      if (existing) {\n+        existing.children.replace([]);\n+        this.testController.items.delete(existing.id);\n+      }\n+    });\n+\n+    this.disposables.push(fileWatcher);\n+  }\n+\n+  private getBunExecutionConfig() {\n+    const customFlag = vscode.workspace.getConfiguration(\"bun.test\").get(\"customFlag\", \"\").trim();\n+    const customScriptSetting = vscode.workspace.getConfiguration(\"bun.test\").get(\"customScript\", \"bun test\").trim();\n+    const customScript = customScriptSetting.length ? customScriptSetting : \"bun test\";\n+\n+    const [cmd, ...args] = customScript.split(/\\s+/);\n+\n+    let bunCommand = \"bun\";\n+    if (cmd === \"bun\") {\n+      const bunRuntime = vscode.workspace.getConfiguration(\"bun\").get<string>(\"runtime\", \"bun\");\n+      bunCommand = bunRuntime || \"bun\";\n+    } else {\n+      bunCommand = cmd;\n+    }\n+\n+    const testArgs = args.length ? args : [\"test\"];\n+    if (customFlag) {\n+      testArgs.push(customFlag);\n+    }\n+\n+    return { bunCommand, testArgs };\n+  }\n+\n+  private async discoverTests(testItem?: vscode.TestItem | false, filePath?: string): Promise<void> {\n+    let targetPath = filePath;\n+    if (!targetPath && testItem) {\n+      targetPath = testItem?.uri?.fsPath || this.workspaceFolder.uri.fsPath;\n+    }\n+    if (!targetPath) {\n+      return;\n+    }\n+\n+    try {\n+      const fileContent = await fs.readFile(targetPath, \"utf8\");\n+      const testNodes = this.parseTestBlocks(fileContent);\n+\n+      const fileUri = vscode.Uri.file(windowsVscodeUri(targetPath));\n+      let fileTestItem = testItem || this.testController.items.get(windowsVscodeUri(targetPath));\n+      if (!fileTestItem) {\n+        fileTestItem = this.testController.createTestItem(\n+          fileUri.toString(),\n+          path.relative(this.workspaceFolder.uri.fsPath, targetPath),\n+          fileUri,\n+        );\n+        this.testController.items.add(fileTestItem);\n+      }\n+      fileTestItem.children.replace([]);\n+      fileTestItem.canResolveChildren = false;\n+\n+      this.addTestNodes(testNodes, fileTestItem, targetPath);\n+    } catch {}\n+  }\n+\n+  private parseTestBlocks(fileContent: string): TestNode[] {\n+    const cleanContent = fileContent\n+      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, match => match.replace(/[^\\n\\r]/g, \" \"))\n+      .replace(/\\/\\/.*$/gm, match => \" \".repeat(match.length));\n+\n+    const testRegex =\n+      /\\b(describe|test|it)(?:\\.(?:skip|todo|failing|only))?(?:\\.(?:if|todoIf|skipIf)\\s*\\([^)]*\\))?(?:\\.each\\s*\\([^)]*\\))?\\s*\\(\\s*(['\"`])((?:\\\\\\2|.)*?)\\2\\s*(?:,|\\))/g;\n+\n+    const stack: TestNode[] = [];\n+    const root: TestNode[] = [];\n+    let match: RegExpExecArray | null;\n+\n+    match = testRegex.exec(cleanContent);\n+    while (match !== null) {\n+      const [full, type, , name] = match;\n+      const line = cleanContent.slice(0, match.index).split(\"\\n\").length - 1;\n+\n+      while (\n+        stack.length > 0 &&\n+        match.index > stack[stack.length - 1].startIdx &&\n+        this.getBraceDepth(cleanContent, stack[stack.length - 1].startIdx, match.index) <= 0\n+      ) {\n+        stack.pop();\n+      }\n+\n+      const expandedNodes = this.expandEachTests(full, name, cleanContent, match.index, type as TestNode[\"type\"], line);\n+\n+      for (const node of expandedNodes) {\n+        if (stack.length === 0) {\n+          root.push(node);\n+        } else {\n+          stack[stack.length - 1].children.push(node);\n+        }\n+\n+        if (type === \"describe\") {\n+          stack.push(node);\n+        }\n+      }\n+      match = testRegex.exec(cleanContent);\n+    }\n+\n+    return root;\n+  }\n+\n+  private getBraceDepth(content: string, start: number, end: number): number {\n+    const section = content.slice(start, end);\n+    let depth = 0;\n+    let inString = false;\n+    let inTemplate = false;\n+    let stringChar = \"\";\n+    let escaped = false;\n+\n+    for (let i = 0; i < section.length; i++) {\n+      const char = section[i];\n+\n+      if (escaped) {\n+        escaped = false;\n+        continue;\n+      }\n+      if (char === \"\\\\\") {\n+        escaped = true;\n+        continue;\n+      }\n+\n+      if (!inTemplate && (char === '\"' || char === \"'\")) {\n+        if (!inString) {\n+          inString = true;\n+          stringChar = char;\n+        } else if (char === stringChar) {\n+          inString = false;\n+        }\n+        continue;\n+      }\n+\n+      if (char === \"`\") {\n+        inTemplate = !inTemplate;\n+        continue;\n+      }\n+\n+      if (!inString && !inTemplate) {\n+        if (char === \"{\") depth++;\n+        else if (char === \"}\") depth--;\n+      }\n+    }\n+\n+    return depth;\n+  }\n+\n+  private expandEachTests(\n+    fullMatch: string,\n+    name: string,\n+    content: string,\n+    index: number,\n+    type: TestNode[\"type\"],\n+    line: number,\n+  ): TestNode[] {\n+    if (!fullMatch.includes(\".each\")) {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+\n+    const eachMatch = content.slice(index).match(/\\.each\\s*\\(\\s*(\\[[\\s\\S]*?\\])\\s*\\)/);\n+    if (!eachMatch) {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+\n+    const arrayString = eachMatch[1].replace(/,\\s*(?=[\\]\\}])/g, \"\");\n+\n+    try {\n+      const eachValues = JSON.parse(arrayString);\n+      if (!Array.isArray(eachValues)) {\n+        throw new Error(\"Not an array\");\n+      }\n+\n+      return eachValues.map(val => {\n+        let testName = name;\n+        if (Array.isArray(val)) {\n+          let idx = 0;\n+          testName = testName.replace(/%[isfd]/g, () => {\n+            const v = val[idx++];\n+            return typeof v === \"object\" ? JSON.stringify(v) : String(v);\n+          });\n+        } else {\n+          testName = testName.replace(/%[isfd]/g, () => {\n+            return typeof val === \"object\" ? JSON.stringify(val) : String(val);\n+          });\n+        }\n+\n+        return {\n+          name: testName,\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        };\n+      });\n+    } catch {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+  }\n+\n+  private addTestNodes(nodes: TestNode[], parent: vscode.TestItem, filePath: string, parentPath = \"\"): void {\n+    for (const node of nodes) {\n+      const nodePath = parentPath\n+        ? `${parentPath} > ${this.escapeTestName(node.name)}`\n+        : this.escapeTestName(node.name);\n+      const testId = `${filePath}#${nodePath}`;\n+\n+      const testItem = this.testController.createTestItem(testId, this.stripAnsi(node.name), vscode.Uri.file(filePath));\n+\n+      testItem.tags = [new vscode.TestTag(node.type === \"describe\" ? \"describe\" : \"test\")];\n+\n+      if (typeof node.line === \"number\") {\n+        testItem.range = new vscode.Range(\n+          new vscode.Position(node.line, 0),\n+          new vscode.Position(node.line, node.name.length),\n+        );\n+      }\n+\n+      parent.children.add(testItem);\n+\n+      if (node.children.length > 0) {\n+        this.addTestNodes(node.children, testItem, filePath, nodePath);\n+      }\n+      testItem.canResolveChildren = false;\n+    }\n+  }\n+\n+  private stripAnsi(source: string): string {\n+    return source.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g, \"\");\n+  }\n+\n+  private escapeTestName(source: string): string {\n+    return source.replace(/[^a-zA-Z0-9_\\ ]/g, \"\\\\$&\");",
        "comment_created_at": "2025-07-14T04:54:52+00:00",
        "comment_author": "Jarred-Sumner",
        "comment_body": "Tests may have json in the name. This should just be a strip ansi IMO",
        "pr_file_module": null
      },
      {
        "comment_id": "2203851610",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20645,
        "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
        "discussion_id": "2203846235",
        "commented_code": "@@ -0,0 +1,1325 @@\n+import { spawn, type ChildProcess } from \"node:child_process\";\n+import * as fs from \"node:fs/promises\";\n+import * as net from \"node:net\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import {\n+  getAvailablePort,\n+  NodeSocketDebugAdapter,\n+  TCPSocketSignal,\n+  UnixSignal,\n+} from \"../../../../bun-debug-adapter-protocol\";\n+import type { JSC } from \"../../../../bun-inspector-protocol\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export const debug = vscode.window.createOutputChannel(\"Bun - Test Runner\");\n+\n+export type TestNode = {\n+  name: string;\n+  type: \"describe\" | \"test\" | \"it\";\n+  line: number;\n+  children: TestNode[];\n+  parent?: TestNode;\n+  startIdx: number;\n+};\n+\n+export interface TestError {\n+  message: string;\n+  file: string;\n+  line: number;\n+  column: number;\n+}\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+  private debugAdapter: NodeSocketDebugAdapter | null = null;\n+  private signal: UnixSignal | TCPSocketSignal | null = null;\n+\n+  private inspectorToVSCode = new Map<number, vscode.TestItem>();\n+  private vscodeToInspector = new Map<string, number>();\n+\n+  private testErrors = new Map<number, TestError>();\n+  private lastStartedTestId: number | null = null;\n+  private currentRun: vscode.TestRun | null = null;\n+\n+  private testResultHistory = new Map<\n+    string,\n+    { status: \"passed\" | \"failed\" | \"skipped\"; message?: vscode.TestMessage; duration?: number }\n+  >();\n+  private currentRunType: \"file\" | \"individual\" = \"file\";\n+  private requestedTestIds: Set<string> = new Set();\n+  private discoveredTestIds: Set<string> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+    this.initializeSignal();\n+  }\n+\n+  private async initializeSignal(): Promise<void> {\n+    try {\n+      this.signal = await this.createSignal();\n+      await this.signal.ready;\n+      debug.appendLine(`Signal initialized at: ${this.signal.url}`);\n+\n+      this.signal.on(\"Signal.Socket.connect\", (socket: net.Socket) => {\n+        debug.appendLine(\"Bun connected to signal socket\");\n+        this.handleSocketConnection(socket, this.currentRun!);\n+      });\n+\n+      this.signal.on(\"Signal.error\", (error: Error) => {\n+        debug.appendLine(`Signal error: ${error.message}`);\n+      });\n+    } catch (error) {\n+      debug.appendLine(`Failed to initialize signal: ${error}`);\n+    }\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      if (!testItem) return;\n+      return this.discoverTests(testItem);\n+    };\n+\n+    this.testController.refreshHandler = async token => {\n+      const files = await this.discoverInitialTests(token);\n+      if (!files?.length) return;\n+\n+      const filePaths = new Set(files.map(f => f.fsPath));\n+      for (const [, testItem] of this.testController.items) {\n+        if (testItem.uri && !filePaths.has(testItem.uri.fsPath)) {\n+          this.testController.items.delete(testItem.id);\n+        }\n+      }\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    vscode.window.visibleTextEditors.forEach(editor => {\n+      this.handleOpenDocument(editor.document);\n+    });\n+\n+    vscode.workspace.textDocuments.forEach(doc => {\n+      this.handleOpenDocument(doc);\n+    });\n+\n+    vscode.workspace.onDidOpenTextDocument(this.handleOpenDocument.bind(this), null, this.disposables);\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.discoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(cancellationToken?: vscode.CancellationToken): Promise<vscode.Uri[] | undefined> {\n+    try {\n+      const tests = await this.findTestFiles(cancellationToken);\n+      this.createFileTestItems(tests);\n+      return tests;\n+    } catch {\n+      return undefined;\n+    }\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFiles(cancellationToken?: vscode.CancellationToken): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs(cancellationToken);\n+    const tests = await vscode.workspace.findFiles(\n+      this.customFilePattern(),\n+      \"node_modules\",\n+      undefined,\n+      cancellationToken,\n+    );\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(cancellationToken?: vscode.CancellationToken): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\n+      \"**/.gitignore\",\n+      \"**/node_modules/**\",\n+      undefined,\n+      cancellationToken,\n+    );\n+    const ignoreGlobs = new Set([\"**/node_modules/**\"]);\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, { encoding: \"utf8\" });\n+        const lines = content\n+          .split(\"\\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.add(line.trim());\n+          } else {\n+            ignoreGlobs.add(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch {}\n+    }\n+\n+    return [...ignoreGlobs.values()];\n+  }\n+\n+  private createFileTestItems(files: vscode.Uri[]): void {\n+    if (files.length === 0) {\n+      return;\n+    }\n+\n+    for (const file of files) {\n+      let fileTestItem = this.testController.items.get(windowsVscodeUri(file.fsPath));\n+      if (!fileTestItem) {\n+        fileTestItem = this.testController.createTestItem(\n+          file.toString(),\n+          path.relative(this.workspaceFolder.uri.fsPath, file.fsPath) || file.fsPath,\n+          file,\n+        );\n+        fileTestItem.children.replace([]);\n+        fileTestItem.canResolveChildren = true;\n+        this.testController.items.add(fileTestItem);\n+      }\n+    }\n+  }\n+\n+  private async setupWatchers(): Promise<void> {\n+    const fileWatcher = vscode.workspace.createFileSystemWatcher(\n+      new vscode.RelativePattern(this.workspaceFolder, this.customFilePattern()),\n+    );\n+\n+    const refreshTestsForFile = (uri: vscode.Uri) => {\n+      if (uri.toString().includes(\"node_modules\")) return;\n+\n+      const existing = this.testController.items.get(windowsVscodeUri(uri.fsPath));\n+      if (existing) {\n+        existing.children.replace([]);\n+        this.discoverTests(existing);\n+      } else {\n+        this.discoverTests(false, uri.fsPath);\n+      }\n+    };\n+\n+    fileWatcher.onDidChange(refreshTestsForFile);\n+    fileWatcher.onDidCreate(refreshTestsForFile);\n+    fileWatcher.onDidDelete(uri => {\n+      const existing = this.testController.items.get(windowsVscodeUri(uri.fsPath));\n+      if (existing) {\n+        existing.children.replace([]);\n+        this.testController.items.delete(existing.id);\n+      }\n+    });\n+\n+    this.disposables.push(fileWatcher);\n+  }\n+\n+  private getBunExecutionConfig() {\n+    const customFlag = vscode.workspace.getConfiguration(\"bun.test\").get(\"customFlag\", \"\").trim();\n+    const customScriptSetting = vscode.workspace.getConfiguration(\"bun.test\").get(\"customScript\", \"bun test\").trim();\n+    const customScript = customScriptSetting.length ? customScriptSetting : \"bun test\";\n+\n+    const [cmd, ...args] = customScript.split(/\\s+/);\n+\n+    let bunCommand = \"bun\";\n+    if (cmd === \"bun\") {\n+      const bunRuntime = vscode.workspace.getConfiguration(\"bun\").get<string>(\"runtime\", \"bun\");\n+      bunCommand = bunRuntime || \"bun\";\n+    } else {\n+      bunCommand = cmd;\n+    }\n+\n+    const testArgs = args.length ? args : [\"test\"];\n+    if (customFlag) {\n+      testArgs.push(customFlag);\n+    }\n+\n+    return { bunCommand, testArgs };\n+  }\n+\n+  private async discoverTests(testItem?: vscode.TestItem | false, filePath?: string): Promise<void> {\n+    let targetPath = filePath;\n+    if (!targetPath && testItem) {\n+      targetPath = testItem?.uri?.fsPath || this.workspaceFolder.uri.fsPath;\n+    }\n+    if (!targetPath) {\n+      return;\n+    }\n+\n+    try {\n+      const fileContent = await fs.readFile(targetPath, \"utf8\");\n+      const testNodes = this.parseTestBlocks(fileContent);\n+\n+      const fileUri = vscode.Uri.file(windowsVscodeUri(targetPath));\n+      let fileTestItem = testItem || this.testController.items.get(windowsVscodeUri(targetPath));\n+      if (!fileTestItem) {\n+        fileTestItem = this.testController.createTestItem(\n+          fileUri.toString(),\n+          path.relative(this.workspaceFolder.uri.fsPath, targetPath),\n+          fileUri,\n+        );\n+        this.testController.items.add(fileTestItem);\n+      }\n+      fileTestItem.children.replace([]);\n+      fileTestItem.canResolveChildren = false;\n+\n+      this.addTestNodes(testNodes, fileTestItem, targetPath);\n+    } catch {}\n+  }\n+\n+  private parseTestBlocks(fileContent: string): TestNode[] {\n+    const cleanContent = fileContent\n+      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, match => match.replace(/[^\\n\\r]/g, \" \"))\n+      .replace(/\\/\\/.*$/gm, match => \" \".repeat(match.length));\n+\n+    const testRegex =\n+      /\\b(describe|test|it)(?:\\.(?:skip|todo|failing|only))?(?:\\.(?:if|todoIf|skipIf)\\s*\\([^)]*\\))?(?:\\.each\\s*\\([^)]*\\))?\\s*\\(\\s*(['\"`])((?:\\\\\\2|.)*?)\\2\\s*(?:,|\\))/g;\n+\n+    const stack: TestNode[] = [];\n+    const root: TestNode[] = [];\n+    let match: RegExpExecArray | null;\n+\n+    match = testRegex.exec(cleanContent);\n+    while (match !== null) {\n+      const [full, type, , name] = match;\n+      const line = cleanContent.slice(0, match.index).split(\"\\n\").length - 1;\n+\n+      while (\n+        stack.length > 0 &&\n+        match.index > stack[stack.length - 1].startIdx &&\n+        this.getBraceDepth(cleanContent, stack[stack.length - 1].startIdx, match.index) <= 0\n+      ) {\n+        stack.pop();\n+      }\n+\n+      const expandedNodes = this.expandEachTests(full, name, cleanContent, match.index, type as TestNode[\"type\"], line);\n+\n+      for (const node of expandedNodes) {\n+        if (stack.length === 0) {\n+          root.push(node);\n+        } else {\n+          stack[stack.length - 1].children.push(node);\n+        }\n+\n+        if (type === \"describe\") {\n+          stack.push(node);\n+        }\n+      }\n+      match = testRegex.exec(cleanContent);\n+    }\n+\n+    return root;\n+  }\n+\n+  private getBraceDepth(content: string, start: number, end: number): number {\n+    const section = content.slice(start, end);\n+    let depth = 0;\n+    let inString = false;\n+    let inTemplate = false;\n+    let stringChar = \"\";\n+    let escaped = false;\n+\n+    for (let i = 0; i < section.length; i++) {\n+      const char = section[i];\n+\n+      if (escaped) {\n+        escaped = false;\n+        continue;\n+      }\n+      if (char === \"\\\\\") {\n+        escaped = true;\n+        continue;\n+      }\n+\n+      if (!inTemplate && (char === '\"' || char === \"'\")) {\n+        if (!inString) {\n+          inString = true;\n+          stringChar = char;\n+        } else if (char === stringChar) {\n+          inString = false;\n+        }\n+        continue;\n+      }\n+\n+      if (char === \"`\") {\n+        inTemplate = !inTemplate;\n+        continue;\n+      }\n+\n+      if (!inString && !inTemplate) {\n+        if (char === \"{\") depth++;\n+        else if (char === \"}\") depth--;\n+      }\n+    }\n+\n+    return depth;\n+  }\n+\n+  private expandEachTests(\n+    fullMatch: string,\n+    name: string,\n+    content: string,\n+    index: number,\n+    type: TestNode[\"type\"],\n+    line: number,\n+  ): TestNode[] {\n+    if (!fullMatch.includes(\".each\")) {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+\n+    const eachMatch = content.slice(index).match(/\\.each\\s*\\(\\s*(\\[[\\s\\S]*?\\])\\s*\\)/);\n+    if (!eachMatch) {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+\n+    const arrayString = eachMatch[1].replace(/,\\s*(?=[\\]\\}])/g, \"\");\n+\n+    try {\n+      const eachValues = JSON.parse(arrayString);\n+      if (!Array.isArray(eachValues)) {\n+        throw new Error(\"Not an array\");\n+      }\n+\n+      return eachValues.map(val => {\n+        let testName = name;\n+        if (Array.isArray(val)) {\n+          let idx = 0;\n+          testName = testName.replace(/%[isfd]/g, () => {\n+            const v = val[idx++];\n+            return typeof v === \"object\" ? JSON.stringify(v) : String(v);\n+          });\n+        } else {\n+          testName = testName.replace(/%[isfd]/g, () => {\n+            return typeof val === \"object\" ? JSON.stringify(val) : String(val);\n+          });\n+        }\n+\n+        return {\n+          name: testName,\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        };\n+      });\n+    } catch {\n+      return [\n+        {\n+          name: name.replace(/\\\\/g, \"\"),\n+          type,\n+          line,\n+          children: [],\n+          startIdx: index,\n+        },\n+      ];\n+    }\n+  }\n+\n+  private addTestNodes(nodes: TestNode[], parent: vscode.TestItem, filePath: string, parentPath = \"\"): void {\n+    for (const node of nodes) {\n+      const nodePath = parentPath\n+        ? `${parentPath} > ${this.escapeTestName(node.name)}`\n+        : this.escapeTestName(node.name);\n+      const testId = `${filePath}#${nodePath}`;\n+\n+      const testItem = this.testController.createTestItem(testId, this.stripAnsi(node.name), vscode.Uri.file(filePath));\n+\n+      testItem.tags = [new vscode.TestTag(node.type === \"describe\" ? \"describe\" : \"test\")];\n+\n+      if (typeof node.line === \"number\") {\n+        testItem.range = new vscode.Range(\n+          new vscode.Position(node.line, 0),\n+          new vscode.Position(node.line, node.name.length),\n+        );\n+      }\n+\n+      parent.children.add(testItem);\n+\n+      if (node.children.length > 0) {\n+        this.addTestNodes(node.children, testItem, filePath, nodePath);\n+      }\n+      testItem.canResolveChildren = false;\n+    }\n+  }\n+\n+  private stripAnsi(source: string): string {\n+    return source.replace(/[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g, \"\");\n+  }\n+\n+  private escapeTestName(source: string): string {\n+    return source.replace(/[^a-zA-Z0-9_\\ ]/g, \"\\\\$&\");",
        "comment_created_at": "2025-07-14T05:01:09+00:00",
        "comment_author": "RiskyMH",
        "comment_body": "This escape is mainly for --test-name-patterm to remove special characters, and to keep ` > ` as the separator for the name and parent describes. I proabibly could have done a block list instead though.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2180528293",
    "pr_number": 19189,
    "pr_file": "scripts/debug-coredump.ts",
    "created_at": "2025-07-02T16:44:43+00:00",
    "commented_code": "+import fs from \"node:fs\";\n+import { tmpdir } from \"node:os\";\n+import { basename, join } from \"node:path\";\n+import { parseArgs } from \"node:util\";\n+\n+// usage: bun debug-coredump.ts\n+// -p <PID of the test that crashed> (buildkite should show this)\n+// -b <URL to the bun-profile.zip artifact for the appropriate platform>\n+// -c <URL to the bun-cores.tar.gz.age artifact for the appropriate platform>\n+// -d <debugger> (default: lldb)\n+const {\n+  values: {\n+    pid: stringPid,\n+    [\"build-url\"]: buildUrl,\n+    [\"cores-url\"]: coresUrl,\n+    [\"identity-file\"]: identityFile,",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2180528293",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19189,
        "pr_file": "scripts/debug-coredump.ts",
        "discussion_id": "2180528293",
        "commented_code": "@@ -0,0 +1,70 @@\n+import fs from \"node:fs\";\n+import { tmpdir } from \"node:os\";\n+import { basename, join } from \"node:path\";\n+import { parseArgs } from \"node:util\";\n+\n+// usage: bun debug-coredump.ts\n+// -p <PID of the test that crashed> (buildkite should show this)\n+// -b <URL to the bun-profile.zip artifact for the appropriate platform>\n+// -c <URL to the bun-cores.tar.gz.age artifact for the appropriate platform>\n+// -d <debugger> (default: lldb)\n+const {\n+  values: {\n+    pid: stringPid,\n+    [\"build-url\"]: buildUrl,\n+    [\"cores-url\"]: coresUrl,\n+    [\"identity-file\"]: identityFile,",
        "comment_created_at": "2025-07-02T16:44:43+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "The `identityFile` parameter is parsed from command line arguments but never used in the script. Instead, the script relies on the `AGE_CORES_IDENTITY` environment variable for decryption. Consider either removing this unused parameter or modifying the script to use the provided identity file when specified.\n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  }
]