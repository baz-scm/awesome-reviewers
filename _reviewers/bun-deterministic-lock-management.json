[
  {
    "discussion_id": "2132861567",
    "pr_number": 19940,
    "pr_file": "src/bun.js/web_worker.zig",
    "created_at": "2025-06-06T20:19:23+00:00",
    "commented_code": "vm_to_deinit = vm;\n     }\n     var arena = this.arena;\n-\n+    this.lifecycle_handle.?.onTermination();\n     WebWorker__dispatchExit(globalObject, cpp_worker, exit_code);\n     if (loop) |loop_| {\n         loop_.internal_loop_data.jsc_vm = null;\n     }\n \n     bun.uws.onThreadExit();\n-    this.deinit();\n+    this.freeWithoutDeinit();\n \n     if (vm_to_deinit) |vm| {\n         vm.deinit(); // NOTE: deinit here isn't implemented, so freeing workers will leak the vm.\n     }\n     bun.deleteAllPoolsForThreadExit();\n+\n     if (arena) |*arena_| {\n         arena_.deinit();\n     }\n \n+    this.deref();\n     bun.exitThread();\n }\n \n+pub export fn WebWorkerLifecycleHandle__requestTermination(handle: ?*WebWorkerLifecycleHandle) void {\n+    if (handle) |h| {\n+        h.requestTermination();\n+    }\n+}\n+\n+/// Manages the complex timing surrounding web worker creation and destruction\n+const WebWorkerLifecycleHandle = struct {\n+    const RefCount = bun.ptr.ThreadSafeRefCount(@This(), \"ref_count\", WebWorkerLifecycleHandle.deinit, .{});\n+    pub const ref = WebWorkerLifecycleHandle.RefCount.ref;\n+    pub const deref = WebWorkerLifecycleHandle.RefCount.deref;\n+\n+    mutex: bun.Mutex = .{},\n+    worker: ?*WebWorker = null,\n+    requested_terminate: std.atomic.Value(bool) = .init(false),\n+    ref_count: WebWorkerLifecycleHandle.RefCount,\n+\n+    pub const new = bun.TrivialNew(WebWorkerLifecycleHandle);\n+\n+    pub fn createWebWorker(\n+        cpp_worker: *void,\n+        parent: *jsc.VirtualMachine,\n+        name_str: bun.String,\n+        specifier_str: bun.String,\n+        error_message: *bun.String,\n+        parent_context_id: u32,\n+        this_context_id: u32,\n+        mini: bool,\n+        default_unref: bool,\n+        eval_mode: bool,\n+        argv_ptr: ?[*]WTFStringImpl,\n+        argv_len: usize,\n+        inherit_execArgv: bool,\n+        execArgv_ptr: ?[*]WTFStringImpl,\n+        execArgv_len: usize,\n+        preload_modules_ptr: ?[*]bun.String,\n+        preload_modules_len: usize,\n+    ) callconv(.c) *WebWorkerLifecycleHandle {\n+        const worker = create(cpp_worker, parent, name_str, specifier_str, error_message, parent_context_id, this_context_id, mini, default_unref, eval_mode, argv_ptr, argv_len, inherit_execArgv, execArgv_ptr, execArgv_len, preload_modules_ptr, preload_modules_len);\n+        const handle = WebWorkerLifecycleHandle.new(.{\n+            .worker = worker,\n+            .ref_count = .init(),\n+        });\n+        worker.?.lifecycle_handle = handle;\n+        return handle;\n+    }\n+\n+    pub fn deinit(this: *WebWorkerLifecycleHandle) void {\n+        bun.destroy(this);\n+    }\n+\n+    pub fn requestTermination(self: *WebWorkerLifecycleHandle) void {\n+        if (self.requested_terminate.load(.acquire)) {\n+            return;\n+        }\n+\n+        self.ref();\n+        self.mutex.lock();",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2132861567",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19940,
        "pr_file": "src/bun.js/web_worker.zig",
        "discussion_id": "2132861567",
        "commented_code": "@@ -593,31 +619,129 @@ pub fn exitAndDeinit(this: *WebWorker) noreturn {\n         vm_to_deinit = vm;\n     }\n     var arena = this.arena;\n-\n+    this.lifecycle_handle.?.onTermination();\n     WebWorker__dispatchExit(globalObject, cpp_worker, exit_code);\n     if (loop) |loop_| {\n         loop_.internal_loop_data.jsc_vm = null;\n     }\n \n     bun.uws.onThreadExit();\n-    this.deinit();\n+    this.freeWithoutDeinit();\n \n     if (vm_to_deinit) |vm| {\n         vm.deinit(); // NOTE: deinit here isn't implemented, so freeing workers will leak the vm.\n     }\n     bun.deleteAllPoolsForThreadExit();\n+\n     if (arena) |*arena_| {\n         arena_.deinit();\n     }\n \n+    this.deref();\n     bun.exitThread();\n }\n \n+pub export fn WebWorkerLifecycleHandle__requestTermination(handle: ?*WebWorkerLifecycleHandle) void {\n+    if (handle) |h| {\n+        h.requestTermination();\n+    }\n+}\n+\n+/// Manages the complex timing surrounding web worker creation and destruction\n+const WebWorkerLifecycleHandle = struct {\n+    const RefCount = bun.ptr.ThreadSafeRefCount(@This(), \"ref_count\", WebWorkerLifecycleHandle.deinit, .{});\n+    pub const ref = WebWorkerLifecycleHandle.RefCount.ref;\n+    pub const deref = WebWorkerLifecycleHandle.RefCount.deref;\n+\n+    mutex: bun.Mutex = .{},\n+    worker: ?*WebWorker = null,\n+    requested_terminate: std.atomic.Value(bool) = .init(false),\n+    ref_count: WebWorkerLifecycleHandle.RefCount,\n+\n+    pub const new = bun.TrivialNew(WebWorkerLifecycleHandle);\n+\n+    pub fn createWebWorker(\n+        cpp_worker: *void,\n+        parent: *jsc.VirtualMachine,\n+        name_str: bun.String,\n+        specifier_str: bun.String,\n+        error_message: *bun.String,\n+        parent_context_id: u32,\n+        this_context_id: u32,\n+        mini: bool,\n+        default_unref: bool,\n+        eval_mode: bool,\n+        argv_ptr: ?[*]WTFStringImpl,\n+        argv_len: usize,\n+        inherit_execArgv: bool,\n+        execArgv_ptr: ?[*]WTFStringImpl,\n+        execArgv_len: usize,\n+        preload_modules_ptr: ?[*]bun.String,\n+        preload_modules_len: usize,\n+    ) callconv(.c) *WebWorkerLifecycleHandle {\n+        const worker = create(cpp_worker, parent, name_str, specifier_str, error_message, parent_context_id, this_context_id, mini, default_unref, eval_mode, argv_ptr, argv_len, inherit_execArgv, execArgv_ptr, execArgv_len, preload_modules_ptr, preload_modules_len);\n+        const handle = WebWorkerLifecycleHandle.new(.{\n+            .worker = worker,\n+            .ref_count = .init(),\n+        });\n+        worker.?.lifecycle_handle = handle;\n+        return handle;\n+    }\n+\n+    pub fn deinit(this: *WebWorkerLifecycleHandle) void {\n+        bun.destroy(this);\n+    }\n+\n+    pub fn requestTermination(self: *WebWorkerLifecycleHandle) void {\n+        if (self.requested_terminate.load(.acquire)) {\n+            return;\n+        }\n+\n+        self.ref();\n+        self.mutex.lock();",
        "comment_created_at": "2025-06-06T20:19:23+00:00",
        "comment_author": "190n",
        "comment_body": "add\r\n\r\n```zig\r\ndefer self.mutex.unlock();\r\ndefer self.deref();\r\n```\r\n\r\nand then we can lose the copies of this cleanup along the exit paths",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2132866109",
    "pr_number": 19940,
    "pr_file": "src/bun.js/web_worker.zig",
    "created_at": "2025-06-06T20:23:31+00:00",
    "commented_code": "vm_to_deinit = vm;\n     }\n     var arena = this.arena;\n-\n+    this.lifecycle_handle.?.onTermination();\n     WebWorker__dispatchExit(globalObject, cpp_worker, exit_code);\n     if (loop) |loop_| {\n         loop_.internal_loop_data.jsc_vm = null;\n     }\n \n     bun.uws.onThreadExit();\n-    this.deinit();\n+    this.freeWithoutDeinit();\n \n     if (vm_to_deinit) |vm| {\n         vm.deinit(); // NOTE: deinit here isn't implemented, so freeing workers will leak the vm.\n     }\n     bun.deleteAllPoolsForThreadExit();\n+\n     if (arena) |*arena_| {\n         arena_.deinit();\n     }\n \n+    this.deref();\n     bun.exitThread();\n }\n \n+pub export fn WebWorkerLifecycleHandle__requestTermination(handle: ?*WebWorkerLifecycleHandle) void {\n+    if (handle) |h| {\n+        h.requestTermination();\n+    }\n+}\n+\n+/// Manages the complex timing surrounding web worker creation and destruction\n+const WebWorkerLifecycleHandle = struct {\n+    const RefCount = bun.ptr.ThreadSafeRefCount(@This(), \"ref_count\", WebWorkerLifecycleHandle.deinit, .{});\n+    pub const ref = WebWorkerLifecycleHandle.RefCount.ref;\n+    pub const deref = WebWorkerLifecycleHandle.RefCount.deref;\n+\n+    mutex: bun.Mutex = .{},\n+    worker: ?*WebWorker = null,\n+    requested_terminate: std.atomic.Value(bool) = .init(false),\n+    ref_count: WebWorkerLifecycleHandle.RefCount,\n+\n+    pub const new = bun.TrivialNew(WebWorkerLifecycleHandle);\n+\n+    pub fn createWebWorker(\n+        cpp_worker: *void,\n+        parent: *jsc.VirtualMachine,\n+        name_str: bun.String,\n+        specifier_str: bun.String,\n+        error_message: *bun.String,\n+        parent_context_id: u32,\n+        this_context_id: u32,\n+        mini: bool,\n+        default_unref: bool,\n+        eval_mode: bool,\n+        argv_ptr: ?[*]WTFStringImpl,\n+        argv_len: usize,\n+        inherit_execArgv: bool,\n+        execArgv_ptr: ?[*]WTFStringImpl,\n+        execArgv_len: usize,\n+        preload_modules_ptr: ?[*]bun.String,\n+        preload_modules_len: usize,\n+    ) callconv(.c) *WebWorkerLifecycleHandle {\n+        const worker = create(cpp_worker, parent, name_str, specifier_str, error_message, parent_context_id, this_context_id, mini, default_unref, eval_mode, argv_ptr, argv_len, inherit_execArgv, execArgv_ptr, execArgv_len, preload_modules_ptr, preload_modules_len);\n+        const handle = WebWorkerLifecycleHandle.new(.{\n+            .worker = worker,\n+            .ref_count = .init(),\n+        });\n+        worker.?.lifecycle_handle = handle;\n+        return handle;\n+    }\n+\n+    pub fn deinit(this: *WebWorkerLifecycleHandle) void {\n+        bun.destroy(this);\n+    }\n+\n+    pub fn requestTermination(self: *WebWorkerLifecycleHandle) void {\n+        if (self.requested_terminate.load(.acquire)) {\n+            return;\n+        }\n+\n+        self.ref();\n+        self.mutex.lock();\n+\n+        if (self.requested_terminate.swap(true, .monotonic)) {\n+            self.mutex.unlock();\n+            self.deref();\n+            return;\n+        }\n+\n+        if (self.worker) |worker| {\n+            self.worker = null;\n+            worker.notifyNeedTermination();\n+            self.mutex.unlock();\n+            worker.deref();\n+        } else {\n+            self.mutex.unlock();\n+            // Let the reference counting system handle deinitialization\n+            self.deref();\n+        }\n+\n+        self.deref();\n+    }\n+\n+    pub fn onTermination(self: *WebWorkerLifecycleHandle) void {\n+        self.ref();\n+        self.mutex.lock();",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2132866109",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19940,
        "pr_file": "src/bun.js/web_worker.zig",
        "discussion_id": "2132866109",
        "commented_code": "@@ -593,31 +619,129 @@ pub fn exitAndDeinit(this: *WebWorker) noreturn {\n         vm_to_deinit = vm;\n     }\n     var arena = this.arena;\n-\n+    this.lifecycle_handle.?.onTermination();\n     WebWorker__dispatchExit(globalObject, cpp_worker, exit_code);\n     if (loop) |loop_| {\n         loop_.internal_loop_data.jsc_vm = null;\n     }\n \n     bun.uws.onThreadExit();\n-    this.deinit();\n+    this.freeWithoutDeinit();\n \n     if (vm_to_deinit) |vm| {\n         vm.deinit(); // NOTE: deinit here isn't implemented, so freeing workers will leak the vm.\n     }\n     bun.deleteAllPoolsForThreadExit();\n+\n     if (arena) |*arena_| {\n         arena_.deinit();\n     }\n \n+    this.deref();\n     bun.exitThread();\n }\n \n+pub export fn WebWorkerLifecycleHandle__requestTermination(handle: ?*WebWorkerLifecycleHandle) void {\n+    if (handle) |h| {\n+        h.requestTermination();\n+    }\n+}\n+\n+/// Manages the complex timing surrounding web worker creation and destruction\n+const WebWorkerLifecycleHandle = struct {\n+    const RefCount = bun.ptr.ThreadSafeRefCount(@This(), \"ref_count\", WebWorkerLifecycleHandle.deinit, .{});\n+    pub const ref = WebWorkerLifecycleHandle.RefCount.ref;\n+    pub const deref = WebWorkerLifecycleHandle.RefCount.deref;\n+\n+    mutex: bun.Mutex = .{},\n+    worker: ?*WebWorker = null,\n+    requested_terminate: std.atomic.Value(bool) = .init(false),\n+    ref_count: WebWorkerLifecycleHandle.RefCount,\n+\n+    pub const new = bun.TrivialNew(WebWorkerLifecycleHandle);\n+\n+    pub fn createWebWorker(\n+        cpp_worker: *void,\n+        parent: *jsc.VirtualMachine,\n+        name_str: bun.String,\n+        specifier_str: bun.String,\n+        error_message: *bun.String,\n+        parent_context_id: u32,\n+        this_context_id: u32,\n+        mini: bool,\n+        default_unref: bool,\n+        eval_mode: bool,\n+        argv_ptr: ?[*]WTFStringImpl,\n+        argv_len: usize,\n+        inherit_execArgv: bool,\n+        execArgv_ptr: ?[*]WTFStringImpl,\n+        execArgv_len: usize,\n+        preload_modules_ptr: ?[*]bun.String,\n+        preload_modules_len: usize,\n+    ) callconv(.c) *WebWorkerLifecycleHandle {\n+        const worker = create(cpp_worker, parent, name_str, specifier_str, error_message, parent_context_id, this_context_id, mini, default_unref, eval_mode, argv_ptr, argv_len, inherit_execArgv, execArgv_ptr, execArgv_len, preload_modules_ptr, preload_modules_len);\n+        const handle = WebWorkerLifecycleHandle.new(.{\n+            .worker = worker,\n+            .ref_count = .init(),\n+        });\n+        worker.?.lifecycle_handle = handle;\n+        return handle;\n+    }\n+\n+    pub fn deinit(this: *WebWorkerLifecycleHandle) void {\n+        bun.destroy(this);\n+    }\n+\n+    pub fn requestTermination(self: *WebWorkerLifecycleHandle) void {\n+        if (self.requested_terminate.load(.acquire)) {\n+            return;\n+        }\n+\n+        self.ref();\n+        self.mutex.lock();\n+\n+        if (self.requested_terminate.swap(true, .monotonic)) {\n+            self.mutex.unlock();\n+            self.deref();\n+            return;\n+        }\n+\n+        if (self.worker) |worker| {\n+            self.worker = null;\n+            worker.notifyNeedTermination();\n+            self.mutex.unlock();\n+            worker.deref();\n+        } else {\n+            self.mutex.unlock();\n+            // Let the reference counting system handle deinitialization\n+            self.deref();\n+        }\n+\n+        self.deref();\n+    }\n+\n+    pub fn onTermination(self: *WebWorkerLifecycleHandle) void {\n+        self.ref();\n+        self.mutex.lock();",
        "comment_created_at": "2025-06-06T20:23:31+00:00",
        "comment_author": "190n",
        "comment_body": "add\r\n\r\n```zig\r\ndefer self.mutex.unlock();\r\ndefer self.deref();\r\n```\r\n\r\nthen delete the copies along the exit paths",
        "pr_file_module": null
      }
    ]
  }
]