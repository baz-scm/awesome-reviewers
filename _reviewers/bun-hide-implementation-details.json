[
  {
    "discussion_id": "2191463312",
    "pr_number": 20881,
    "pr_file": "src/codegen/cppbind.ts",
    "created_at": "2025-07-08T04:44:42+00:00",
    "commented_code": "+import { mkdir } from \"fs/promises\";\n+import { join, relative } from \"path\";\n+import CppPath from \"tree-sitter-cpp/tree-sitter-cpp.wasm\";\n+import { Language, Node, Parser, Query } from \"web-tree-sitter\";\n+import { sharedTypes, typeDeclarations } from \"./shared-types\";\n+\n+// https://tree-sitter.github.io/tree-sitter/7-playground.html\n+\n+type Point = {\n+  line: number;\n+  column: number;\n+};\n+type Srcloc = {\n+  file: string;\n+  start: Point;\n+  end: Point;\n+};\n+type CppFn = {\n+  name: string;\n+  returnType: CppType;\n+  parameters: CppParameter[];\n+  position: Srcloc;\n+  tag: ExportTag;\n+};\n+type CppParameter = {\n+  type: CppType;\n+  name: string;\n+};\n+type CppType =\n+  | {\n+      type: \"pointer\";\n+      child: CppType;\n+      position: Srcloc;\n+      isConst: boolean;\n+    }\n+  | {\n+      type: \"reference\";\n+      child: CppType;\n+      position: Srcloc;\n+      isConst: boolean;\n+    }\n+  | {\n+      type: \"named\";\n+      name: string;\n+      position: Srcloc;\n+    };\n+\n+type PositionedError = {\n+  position: Srcloc;\n+  message: string;\n+  notes: { position: Srcloc; message: string }[];\n+};\n+const errors: PositionedError[] = [];\n+function appendError(position: Srcloc, message: string): PositionedError {\n+  const error: PositionedError = { position, message, notes: [] };\n+  errors.push(error);\n+  return error;\n+}\n+function appendErrorFromCatch(error: unknown, position: Srcloc): PositionedError {\n+  if (error instanceof PositionedErrorClass) {\n+    return appendError(error.position, error.message);\n+  }\n+  if (error instanceof Error) {\n+    return appendError(position, error.message);\n+  }\n+  return appendError(position, \"unknown error: \" + JSON.stringify(error));\n+}\n+function throwError(position: Srcloc, message: string): never {\n+  throw new PositionedErrorClass(position, message);\n+}\n+function nodePosition(file: string, node: SyntaxNode): Srcloc {\n+  return {\n+    file,\n+    start: { line: node.startPosition.row + 1, column: node.startPosition.column + 1 },\n+    end: { line: node.endPosition.row + 1, column: node.endPosition.column + 1 },\n+  };\n+}\n+function assertNever(value: never): never {\n+  throw new Error(\"assertNever\");\n+}\n+class PositionedErrorClass extends Error {\n+  constructor(\n+    public position: Srcloc,\n+    message: string,\n+  ) {\n+    super(message);\n+  }\n+}\n+\n+function processRootmostType(file: string, types: SyntaxNode[]): CppType {\n+  const type = types[0];\n+  if (!type) throwError(nodePosition(file, types[0]), \"no type found\");\n+  return { type: \"named\", name: type.text, position: nodePosition(file, type) };\n+}\n+\n+function processDeclarator(\n+  file: string,\n+  node: SyntaxNode,\n+  rootmostType?: CppType,\n+): { type: CppType; final: SyntaxNode } {\n+  // example: int* spiral() is:\n+  // type: primitive_type[int], declarator: pointer_declarator[ declarator: function_declarator[ declarator: identifier[spiral], parameters: parame\n+\n+  const declarators = node.childrenForFieldName(\"declarator\");\n+  const declarator = declarators[0];\n+  if (!declarator) throwError(nodePosition(file, declarators[0]), \"no declarator found\");\n+\n+  rootmostType ??= processRootmostType(file, node.childrenForFieldName(\"type\"));\n+  if (!rootmostType) throwError(nodePosition(file, node), \"no rootmost type found\");\n+\n+  const isConst = node.children.some(child => child.type === \"type_qualifier\" && child.text === \"const\");\n+  if (declarator.type === \"pointer_declarator\") {\n+    return processDeclarator(file, declarator, {\n+      type: \"pointer\",\n+      child: rootmostType,\n+      position: nodePosition(file, declarator),\n+      isConst,\n+    });\n+  }\n+  if (declarator.type === \"reference_declarator\") {\n+    return processDeclarator(file, declarator, {\n+      type: \"reference\",\n+      child: rootmostType,\n+      position: nodePosition(file, declarator),\n+      isConst,\n+    });\n+  }\n+  return { type: rootmostType, final: declarator };\n+}\n+\n+function processFunction(file: string, node: SyntaxNode, tag: ExportTag): CppFn {\n+  // void* spiral()\n+\n+  const declarator = processDeclarator(file, node);\n+  if (!declarator) throwError(nodePosition(file, node.childrenForFieldName(\"declarator\")[0]), \"no declarator found\");\n+  const final = declarator.final;\n+  if (final.type !== \"function_declarator\") {\n+    throwError(nodePosition(file, final), \"not a function_declarator: \" + final.type);\n+  }\n+  const name = final.childrenForFieldName(\"declarator\")[0];\n+  if (!name) throwError(nodePosition(file, final.childrenForFieldName(\"declarator\")[0]), \"no name found\");\n+  const parameterList = final.childrenForFieldName(\"parameters\")[0];\n+  if (!parameterList || parameterList.type !== \"parameter_list\")\n+    throwError(nodePosition(file, final.childrenForFieldName(\"parameters\")[0]), \"no parameter list found\");\n+\n+  const parameters: CppParameter[] = [];\n+  for (const parameter of parameterList.children) {\n+    if (parameter.type !== \"parameter_declaration\") continue;\n+\n+    const declarator = processDeclarator(file, parameter);\n+    if (!declarator)\n+      throwError(\n+        nodePosition(file, parameter.childrenForFieldName(\"declarator\")[0]),\n+        \"no declarator found for parameter\",\n+      );\n+    const name = declarator.final;\n+    if (!name) throwError(nodePosition(file, parameter), \"no name found for parameter\");\n+\n+    parameters.push({ type: declarator.type, name: name.text });\n+  }\n+\n+  return {\n+    returnType: declarator.type,\n+    name: name.text,\n+    parameters,\n+    position: nodePosition(file, name),\n+    tag,\n+  };\n+}\n+\n+type ExportTag = \"check_slow\" | \"zero_is_throw\" | \"nothrow\";\n+type ShouldExport = {\n+  value?: {\n+    tag: ExportTag;\n+    position: Srcloc;\n+  };\n+};\n+\n+const sharedTypesText = await Bun.file(\"src/codegen/shared-types.ts\").text();\n+const sharedTypesLines = sharedTypesText.split(\"\n\");\n+let sharedTypesLine = 0;\n+let sharedTypesColumn = 0;\n+let sharedTypesColumnEnd = 0;\n+for (const line of sharedTypesLines) {\n+  sharedTypesLine++;\n+  if (line.includes(\"export const sharedTypes\")) {\n+    sharedTypesColumn = line.indexOf(\"sharedTypes\") + 1;\n+    sharedTypesColumnEnd = sharedTypesColumn + \"sharedTypes\".length;\n+    break;\n+  }\n+}\n+\n+const errorsForTypes: Map<string, PositionedError> = new Map();\n+function generateZigType(type: CppType, subLevel?: boolean) {\n+  if (type.type === \"pointer\") {\n+    if (type.isConst) return `*const ${generateZigType(type.child, true)}`;\n+    return `*${generateZigType(type.child, true)}`;\n+  }\n+  if (type.type === \"reference\") {\n+    if (type.isConst) return `*const ${generateZigType(type.child, true)}`;\n+    return `*${generateZigType(type.child, true)}`;\n+  }\n+  if (type.type === \"named\" && type.name === \"void\") {\n+    if (subLevel) return \"anyopaque\";\n+    return \"void\";\n+  }\n+  if (type.type === \"named\") {\n+    const sharedType = sharedTypes[type.name];\n+    if (sharedType) return sharedType;\n+    const error = errorsForTypes.has(type.name)\n+      ? errorsForTypes.get(type.name)!\n+      : appendError(\n+          {\n+            file: \"src/codegen/shared-types.ts\",\n+            start: { line: sharedTypesLine, column: sharedTypesColumn },\n+            end: { line: sharedTypesLine, column: sharedTypesColumnEnd },\n+          },\n+          \"sharedTypes is missing type: \" + JSON.stringify(type.name),\n+        );\n+    errorsForTypes.set(type.name, error);\n+    error.notes.push({ position: type.position, message: \"used in exported function here\" });\n+    return \"anyopaque\";\n+  }\n+  assertNever(type);\n+}\n+function formatZigName(name: string): string {\n+  if (name.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) return name;\n+  return \"@\" + JSON.stringify(name);\n+}\n+function generateZigParameterList(parameters: CppParameter[]): string {\n+  return parameters.map(p => `${formatZigName(p.name)}: ${generateZigType(p.type, false)}`).join(\", \");\n+}\n+function generateZigSourceComment(dstDir: string, resultSourceLinks: string[], fn: CppFn): string {\n+  const fileName = relative(dstDir, fn.position.file);\n+  resultSourceLinks.push(`${fn.name}:${fileName}:${fn.position.start.line}:${fn.position.start.column}`);\n+  return `    /// Source: ${fn.name}`;\n+}\n+\n+function closest(node: Node | null, type: string): Node | null {\n+  while (node) {\n+    if (node.type === type) return node;\n+    node = node.parent;\n+  }\n+  return null;\n+}\n+\n+async function processFile(parserAndQueries: ParserAndQueries, file: string, allFunctions: CppFn[]) {\n+  const sourceCode = await Bun.file(file).text();\n+  if (!sourceCode.includes(\"ZIG_EXPORT\")) return;\n+  const tree = parserAndQueries.parser.parse(sourceCode);\n+  if (!tree) return appendError({ file, start: { line: 0, column: 0 }, end: { line: 0, column: 0 } }, \"no tree found\");\n+\n+  const matches = parserAndQueries.query.matches(tree.rootNode);\n+\n+  for (const match of matches) {\n+    const identifierCapture = match.captures.find(c => c.name === \"attribute.identifier\");\n+    const fnCapture = match.captures.find(c => c.name === \"fn\");\n+    if (!identifierCapture || !fnCapture) continue;\n+\n+    const linkage = closest(fnCapture.node, \"linkage_specification\");\n+    const value = linkage?.childrenForFieldName(\"value\")[0];\n+    if (!linkage || value?.type !== \"string_literal\" || value.text !== '\"C\"') {\n+      appendError(nodePosition(file, fnCapture.node), 'exported function must be extern \"C\"');\n+    }\n+\n+    const tagStr = identifierCapture.node.text;\n+    let tag: ExportTag | undefined;\n+\n+    if (tagStr === \"nothrow\" || tagStr === \"zero_is_throw\" || tagStr === \"check_slow\") {\n+      tag = tagStr;\n+    } else {\n+      appendError(nodePosition(file, identifierCapture.node), \"tag must be nothrow, zero_is_throw, or check_slow\");\n+      tag = \"nothrow\";\n+    }\n+\n+    try {\n+      const result = processFunction(file, fnCapture.node, tag);\n+      allFunctions.push(result);\n+    } catch (e) {\n+      appendErrorFromCatch(e, nodePosition(file, fnCapture.node));\n+    }\n+  }\n+  // processNode(file, cursor, allFunctions, {}, false, []);\n+}\n+\n+async function renderError(position: Srcloc, message: string, label: string, color: string) {\n+  const fileContent = await Bun.file(position.file).text();\n+  const lines = fileContent.split(\"\n\");\n+  const line = lines[position.start.line - 1];\n+\n+  console.error(\n+    `\\x1b[m${position.file}:${position.start.line}:${position.start.column}: ${color}\\x1b[1m${label}:\\x1b[m ${message}`,\n+  );\n+  const before = `${position.start.column} |   ${line.substring(0, position.start.column - 1)}`;\n+  const after = line.substring(position.start.column - 1);\n+  console.error(`\\x1b[90m${before}${after}\\x1b[m`);\n+  let length = position.start.line === position.end.line ? position.end.column - position.start.column : 1;\n+  console.error(`\\x1b[m${\" \".repeat(Bun.stringWidth(before))}${color}^${\"~\".repeat(Math.max(length - 1, 0))}\\x1b[m`);\n+}\n+\n+function generateZigFn(\n+  fn: CppFn,\n+  resultRaw: string[],\n+  resultBindings: string[],\n+  resultSourceLinks: string[],\n+  dstDir: string,\n+): void {\n+  if (fn.tag === \"nothrow\") {\n+    if (resultBindings.length) resultBindings.push(\"\");\n+    resultBindings.push(\n+      generateZigSourceComment(dstDir, resultSourceLinks, fn),\n+      `    pub extern fn ${formatZigName(fn.name)}(${generateZigParameterList(fn.parameters)}) ${generateZigType(fn.returnType)};`,\n+    );\n+  } else if (fn.tag === \"check_slow\" || fn.tag === \"zero_is_throw\") {\n+    if (resultRaw.length) resultRaw.push(\"\");\n+    if (resultBindings.length) resultBindings.push(\"\");\n+    resultRaw.push(\n+      generateZigSourceComment(dstDir, resultSourceLinks, fn),\n+      `    extern fn ${formatZigName(fn.name)}(${generateZigParameterList(fn.parameters)}) ${generateZigType(fn.returnType)};`,\n+    );\n+    const globalThisArg = fn.parameters.find(param => generateZigType(param.type) === \"*JSC.JSGlobalObject\");\n+    if (!globalThisArg) throwError(fn.position, \"no globalThis argument found\");\n+    const callName = fn.tag === \"check_slow\" ? \"fromJSHostCallGeneric\" : \"fromJSHostCall\";\n+    resultBindings.push(\n+      `    pub inline fn ${formatZigName(fn.name)}(${generateZigParameterList(fn.parameters)}) bun.JSError!${generateZigType(fn.returnType)} {`,\n+      `        return bun.JSC.${callName}(${formatZigName(globalThisArg.name)}, @src(), raw.${formatZigName(fn.name)}, .{ ${fn.parameters.map(p => formatZigName(p.name)).join(\", \")} });`,\n+      `    }`,",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2191463312",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20881,
        "pr_file": "src/codegen/cppbind.ts",
        "discussion_id": "2191463312",
        "commented_code": "@@ -0,0 +1,450 @@\n+import { mkdir } from \"fs/promises\";\n+import { join, relative } from \"path\";\n+import CppPath from \"tree-sitter-cpp/tree-sitter-cpp.wasm\";\n+import { Language, Node, Parser, Query } from \"web-tree-sitter\";\n+import { sharedTypes, typeDeclarations } from \"./shared-types\";\n+\n+// https://tree-sitter.github.io/tree-sitter/7-playground.html\n+\n+type Point = {\n+  line: number;\n+  column: number;\n+};\n+type Srcloc = {\n+  file: string;\n+  start: Point;\n+  end: Point;\n+};\n+type CppFn = {\n+  name: string;\n+  returnType: CppType;\n+  parameters: CppParameter[];\n+  position: Srcloc;\n+  tag: ExportTag;\n+};\n+type CppParameter = {\n+  type: CppType;\n+  name: string;\n+};\n+type CppType =\n+  | {\n+      type: \"pointer\";\n+      child: CppType;\n+      position: Srcloc;\n+      isConst: boolean;\n+    }\n+  | {\n+      type: \"reference\";\n+      child: CppType;\n+      position: Srcloc;\n+      isConst: boolean;\n+    }\n+  | {\n+      type: \"named\";\n+      name: string;\n+      position: Srcloc;\n+    };\n+\n+type PositionedError = {\n+  position: Srcloc;\n+  message: string;\n+  notes: { position: Srcloc; message: string }[];\n+};\n+const errors: PositionedError[] = [];\n+function appendError(position: Srcloc, message: string): PositionedError {\n+  const error: PositionedError = { position, message, notes: [] };\n+  errors.push(error);\n+  return error;\n+}\n+function appendErrorFromCatch(error: unknown, position: Srcloc): PositionedError {\n+  if (error instanceof PositionedErrorClass) {\n+    return appendError(error.position, error.message);\n+  }\n+  if (error instanceof Error) {\n+    return appendError(position, error.message);\n+  }\n+  return appendError(position, \"unknown error: \" + JSON.stringify(error));\n+}\n+function throwError(position: Srcloc, message: string): never {\n+  throw new PositionedErrorClass(position, message);\n+}\n+function nodePosition(file: string, node: SyntaxNode): Srcloc {\n+  return {\n+    file,\n+    start: { line: node.startPosition.row + 1, column: node.startPosition.column + 1 },\n+    end: { line: node.endPosition.row + 1, column: node.endPosition.column + 1 },\n+  };\n+}\n+function assertNever(value: never): never {\n+  throw new Error(\"assertNever\");\n+}\n+class PositionedErrorClass extends Error {\n+  constructor(\n+    public position: Srcloc,\n+    message: string,\n+  ) {\n+    super(message);\n+  }\n+}\n+\n+function processRootmostType(file: string, types: SyntaxNode[]): CppType {\n+  const type = types[0];\n+  if (!type) throwError(nodePosition(file, types[0]), \"no type found\");\n+  return { type: \"named\", name: type.text, position: nodePosition(file, type) };\n+}\n+\n+function processDeclarator(\n+  file: string,\n+  node: SyntaxNode,\n+  rootmostType?: CppType,\n+): { type: CppType; final: SyntaxNode } {\n+  // example: int* spiral() is:\n+  // type: primitive_type[int], declarator: pointer_declarator[ declarator: function_declarator[ declarator: identifier[spiral], parameters: parame\n+\n+  const declarators = node.childrenForFieldName(\"declarator\");\n+  const declarator = declarators[0];\n+  if (!declarator) throwError(nodePosition(file, declarators[0]), \"no declarator found\");\n+\n+  rootmostType ??= processRootmostType(file, node.childrenForFieldName(\"type\"));\n+  if (!rootmostType) throwError(nodePosition(file, node), \"no rootmost type found\");\n+\n+  const isConst = node.children.some(child => child.type === \"type_qualifier\" && child.text === \"const\");\n+  if (declarator.type === \"pointer_declarator\") {\n+    return processDeclarator(file, declarator, {\n+      type: \"pointer\",\n+      child: rootmostType,\n+      position: nodePosition(file, declarator),\n+      isConst,\n+    });\n+  }\n+  if (declarator.type === \"reference_declarator\") {\n+    return processDeclarator(file, declarator, {\n+      type: \"reference\",\n+      child: rootmostType,\n+      position: nodePosition(file, declarator),\n+      isConst,\n+    });\n+  }\n+  return { type: rootmostType, final: declarator };\n+}\n+\n+function processFunction(file: string, node: SyntaxNode, tag: ExportTag): CppFn {\n+  // void* spiral()\n+\n+  const declarator = processDeclarator(file, node);\n+  if (!declarator) throwError(nodePosition(file, node.childrenForFieldName(\"declarator\")[0]), \"no declarator found\");\n+  const final = declarator.final;\n+  if (final.type !== \"function_declarator\") {\n+    throwError(nodePosition(file, final), \"not a function_declarator: \" + final.type);\n+  }\n+  const name = final.childrenForFieldName(\"declarator\")[0];\n+  if (!name) throwError(nodePosition(file, final.childrenForFieldName(\"declarator\")[0]), \"no name found\");\n+  const parameterList = final.childrenForFieldName(\"parameters\")[0];\n+  if (!parameterList || parameterList.type !== \"parameter_list\")\n+    throwError(nodePosition(file, final.childrenForFieldName(\"parameters\")[0]), \"no parameter list found\");\n+\n+  const parameters: CppParameter[] = [];\n+  for (const parameter of parameterList.children) {\n+    if (parameter.type !== \"parameter_declaration\") continue;\n+\n+    const declarator = processDeclarator(file, parameter);\n+    if (!declarator)\n+      throwError(\n+        nodePosition(file, parameter.childrenForFieldName(\"declarator\")[0]),\n+        \"no declarator found for parameter\",\n+      );\n+    const name = declarator.final;\n+    if (!name) throwError(nodePosition(file, parameter), \"no name found for parameter\");\n+\n+    parameters.push({ type: declarator.type, name: name.text });\n+  }\n+\n+  return {\n+    returnType: declarator.type,\n+    name: name.text,\n+    parameters,\n+    position: nodePosition(file, name),\n+    tag,\n+  };\n+}\n+\n+type ExportTag = \"check_slow\" | \"zero_is_throw\" | \"nothrow\";\n+type ShouldExport = {\n+  value?: {\n+    tag: ExportTag;\n+    position: Srcloc;\n+  };\n+};\n+\n+const sharedTypesText = await Bun.file(\"src/codegen/shared-types.ts\").text();\n+const sharedTypesLines = sharedTypesText.split(\"\\n\");\n+let sharedTypesLine = 0;\n+let sharedTypesColumn = 0;\n+let sharedTypesColumnEnd = 0;\n+for (const line of sharedTypesLines) {\n+  sharedTypesLine++;\n+  if (line.includes(\"export const sharedTypes\")) {\n+    sharedTypesColumn = line.indexOf(\"sharedTypes\") + 1;\n+    sharedTypesColumnEnd = sharedTypesColumn + \"sharedTypes\".length;\n+    break;\n+  }\n+}\n+\n+const errorsForTypes: Map<string, PositionedError> = new Map();\n+function generateZigType(type: CppType, subLevel?: boolean) {\n+  if (type.type === \"pointer\") {\n+    if (type.isConst) return `*const ${generateZigType(type.child, true)}`;\n+    return `*${generateZigType(type.child, true)}`;\n+  }\n+  if (type.type === \"reference\") {\n+    if (type.isConst) return `*const ${generateZigType(type.child, true)}`;\n+    return `*${generateZigType(type.child, true)}`;\n+  }\n+  if (type.type === \"named\" && type.name === \"void\") {\n+    if (subLevel) return \"anyopaque\";\n+    return \"void\";\n+  }\n+  if (type.type === \"named\") {\n+    const sharedType = sharedTypes[type.name];\n+    if (sharedType) return sharedType;\n+    const error = errorsForTypes.has(type.name)\n+      ? errorsForTypes.get(type.name)!\n+      : appendError(\n+          {\n+            file: \"src/codegen/shared-types.ts\",\n+            start: { line: sharedTypesLine, column: sharedTypesColumn },\n+            end: { line: sharedTypesLine, column: sharedTypesColumnEnd },\n+          },\n+          \"sharedTypes is missing type: \" + JSON.stringify(type.name),\n+        );\n+    errorsForTypes.set(type.name, error);\n+    error.notes.push({ position: type.position, message: \"used in exported function here\" });\n+    return \"anyopaque\";\n+  }\n+  assertNever(type);\n+}\n+function formatZigName(name: string): string {\n+  if (name.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) return name;\n+  return \"@\" + JSON.stringify(name);\n+}\n+function generateZigParameterList(parameters: CppParameter[]): string {\n+  return parameters.map(p => `${formatZigName(p.name)}: ${generateZigType(p.type, false)}`).join(\", \");\n+}\n+function generateZigSourceComment(dstDir: string, resultSourceLinks: string[], fn: CppFn): string {\n+  const fileName = relative(dstDir, fn.position.file);\n+  resultSourceLinks.push(`${fn.name}:${fileName}:${fn.position.start.line}:${fn.position.start.column}`);\n+  return `    /// Source: ${fn.name}`;\n+}\n+\n+function closest(node: Node | null, type: string): Node | null {\n+  while (node) {\n+    if (node.type === type) return node;\n+    node = node.parent;\n+  }\n+  return null;\n+}\n+\n+async function processFile(parserAndQueries: ParserAndQueries, file: string, allFunctions: CppFn[]) {\n+  const sourceCode = await Bun.file(file).text();\n+  if (!sourceCode.includes(\"ZIG_EXPORT\")) return;\n+  const tree = parserAndQueries.parser.parse(sourceCode);\n+  if (!tree) return appendError({ file, start: { line: 0, column: 0 }, end: { line: 0, column: 0 } }, \"no tree found\");\n+\n+  const matches = parserAndQueries.query.matches(tree.rootNode);\n+\n+  for (const match of matches) {\n+    const identifierCapture = match.captures.find(c => c.name === \"attribute.identifier\");\n+    const fnCapture = match.captures.find(c => c.name === \"fn\");\n+    if (!identifierCapture || !fnCapture) continue;\n+\n+    const linkage = closest(fnCapture.node, \"linkage_specification\");\n+    const value = linkage?.childrenForFieldName(\"value\")[0];\n+    if (!linkage || value?.type !== \"string_literal\" || value.text !== '\"C\"') {\n+      appendError(nodePosition(file, fnCapture.node), 'exported function must be extern \"C\"');\n+    }\n+\n+    const tagStr = identifierCapture.node.text;\n+    let tag: ExportTag | undefined;\n+\n+    if (tagStr === \"nothrow\" || tagStr === \"zero_is_throw\" || tagStr === \"check_slow\") {\n+      tag = tagStr;\n+    } else {\n+      appendError(nodePosition(file, identifierCapture.node), \"tag must be nothrow, zero_is_throw, or check_slow\");\n+      tag = \"nothrow\";\n+    }\n+\n+    try {\n+      const result = processFunction(file, fnCapture.node, tag);\n+      allFunctions.push(result);\n+    } catch (e) {\n+      appendErrorFromCatch(e, nodePosition(file, fnCapture.node));\n+    }\n+  }\n+  // processNode(file, cursor, allFunctions, {}, false, []);\n+}\n+\n+async function renderError(position: Srcloc, message: string, label: string, color: string) {\n+  const fileContent = await Bun.file(position.file).text();\n+  const lines = fileContent.split(\"\\n\");\n+  const line = lines[position.start.line - 1];\n+\n+  console.error(\n+    `\\x1b[m${position.file}:${position.start.line}:${position.start.column}: ${color}\\x1b[1m${label}:\\x1b[m ${message}`,\n+  );\n+  const before = `${position.start.column} |   ${line.substring(0, position.start.column - 1)}`;\n+  const after = line.substring(position.start.column - 1);\n+  console.error(`\\x1b[90m${before}${after}\\x1b[m`);\n+  let length = position.start.line === position.end.line ? position.end.column - position.start.column : 1;\n+  console.error(`\\x1b[m${\" \".repeat(Bun.stringWidth(before))}${color}^${\"~\".repeat(Math.max(length - 1, 0))}\\x1b[m`);\n+}\n+\n+function generateZigFn(\n+  fn: CppFn,\n+  resultRaw: string[],\n+  resultBindings: string[],\n+  resultSourceLinks: string[],\n+  dstDir: string,\n+): void {\n+  if (fn.tag === \"nothrow\") {\n+    if (resultBindings.length) resultBindings.push(\"\");\n+    resultBindings.push(\n+      generateZigSourceComment(dstDir, resultSourceLinks, fn),\n+      `    pub extern fn ${formatZigName(fn.name)}(${generateZigParameterList(fn.parameters)}) ${generateZigType(fn.returnType)};`,\n+    );\n+  } else if (fn.tag === \"check_slow\" || fn.tag === \"zero_is_throw\") {\n+    if (resultRaw.length) resultRaw.push(\"\");\n+    if (resultBindings.length) resultBindings.push(\"\");\n+    resultRaw.push(\n+      generateZigSourceComment(dstDir, resultSourceLinks, fn),\n+      `    extern fn ${formatZigName(fn.name)}(${generateZigParameterList(fn.parameters)}) ${generateZigType(fn.returnType)};`,\n+    );\n+    const globalThisArg = fn.parameters.find(param => generateZigType(param.type) === \"*JSC.JSGlobalObject\");\n+    if (!globalThisArg) throwError(fn.position, \"no globalThis argument found\");\n+    const callName = fn.tag === \"check_slow\" ? \"fromJSHostCallGeneric\" : \"fromJSHostCall\";\n+    resultBindings.push(\n+      `    pub inline fn ${formatZigName(fn.name)}(${generateZigParameterList(fn.parameters)}) bun.JSError!${generateZigType(fn.returnType)} {`,\n+      `        return bun.JSC.${callName}(${formatZigName(globalThisArg.name)}, @src(), raw.${formatZigName(fn.name)}, .{ ${fn.parameters.map(p => formatZigName(p.name)).join(\", \")} });`,\n+      `    }`,",
        "comment_created_at": "2025-07-08T04:44:42+00:00",
        "comment_author": "nektro",
        "comment_body": "i think the generated file should vendor its own copy of `fromJSHostCall` and `fromJSHostCallGeneric` and we can deprecate the ones in `bun.jsc.host_fn` to move onto this system. getting rid of them will have to hold off just a bit since i have some changes that will conflict a bunch if done so, but we should def move towards this system and itd move less code if the impl here wasn't dependent on the old one",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2112746678",
    "pr_number": 18962,
    "pr_file": "packages/bun-types/overrides.d.ts",
    "created_at": "2025-05-28T21:01:18+00:00",
    "commented_code": "function connect(options: BunConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n }\n+\n+declare module \"net\" {\n+  type SocketHandleData = { self: Socket; req?: object };",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2112746678",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 18962,
        "pr_file": "packages/bun-types/overrides.d.ts",
        "discussion_id": "2112746678",
        "commented_code": "@@ -204,3 +204,11 @@ declare module \"tls\" {\n \n   function connect(options: BunConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n }\n+\n+declare module \"net\" {\n+  type SocketHandleData = { self: Socket; req?: object };",
        "comment_created_at": "2025-05-28T21:01:18+00:00",
        "comment_author": "alii",
        "comment_body": "This SocketHandleData type shouldn't look like it comes from `'net'`, as it means someone could do this which is confusing and looks like something node-related\r\n\r\n```ts\r\nimport type {SocketHandleData} from 'node:net';\r\n```\r\n\r\nI'd suggest moving this type to `'bun'` module or just inline it in the type parameter of _handle below\r\n\r\nWith that said, is it actually necessary/valuable for Bun to surface the _handle so clearly like this? It forces us into supporting it and not breaking it in the future. If the answer is yes, we could consider marking it as immediately deprecated so that editors show a strikethrough on the symbol when consuming it",
        "pr_file_module": null
      },
      {
        "comment_id": "2112769244",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 18962,
        "pr_file": "packages/bun-types/overrides.d.ts",
        "discussion_id": "2112746678",
        "commented_code": "@@ -204,3 +204,11 @@ declare module \"tls\" {\n \n   function connect(options: BunConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n }\n+\n+declare module \"net\" {\n+  type SocketHandleData = { self: Socket; req?: object };",
        "comment_created_at": "2025-05-28T21:15:21+00:00",
        "comment_author": "nektro",
        "comment_body": "> It forces us into supporting it and not breaking it in the future.\r\n\r\ni dont agree this is necessarily the case. i think documenting these _ fields can be one of the ways our reference can be more complete than node's docs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2112769989",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 18962,
        "pr_file": "packages/bun-types/overrides.d.ts",
        "discussion_id": "2112746678",
        "commented_code": "@@ -204,3 +204,11 @@ declare module \"tls\" {\n \n   function connect(options: BunConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n }\n+\n+declare module \"net\" {\n+  type SocketHandleData = { self: Socket; req?: object };",
        "comment_created_at": "2025-05-28T21:15:54+00:00",
        "comment_author": "nektro",
        "comment_body": "yes i can move SocketHandleData",
        "pr_file_module": null
      },
      {
        "comment_id": "2112827969",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 18962,
        "pr_file": "packages/bun-types/overrides.d.ts",
        "discussion_id": "2112746678",
        "commented_code": "@@ -204,3 +204,11 @@ declare module \"tls\" {\n \n   function connect(options: BunConnectionOptions, secureConnectListener?: () => void): TLSSocket;\n }\n+\n+declare module \"net\" {\n+  type SocketHandleData = { self: Socket; req?: object };",
        "comment_created_at": "2025-05-28T22:07:51+00:00",
        "comment_author": "nektro",
        "comment_body": "talked irl too; agree with u, moving to private ",
        "pr_file_module": null
      }
    ]
  }
]