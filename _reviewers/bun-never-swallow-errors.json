[
  {
    "discussion_id": "2198474457",
    "pr_number": 20645,
    "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
    "created_at": "2025-07-10T18:55:26+00:00",
    "commented_code": "+import { spawn, type ChildProcess } from \"node:child_process\";\n+import { randomUUID } from \"node:crypto\";\n+import * as fsSync from \"node:fs\";\n+import * as fs from \"node:fs/promises\";\n+import { tmpdir } from \"node:os\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import { parseString as xmlParseString } from \"xml2js\";\n+import type { BunFileResult, BunTestResult, TestNode } from \"./types\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      await this.staticDiscoverTests(testItem);\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    const openEditors = vscode.window.visibleTextEditors;\n+    for (const editor of openEditors) {\n+      this.handleOpenDocument(editor.document);\n+    }\n+\n+    vscode.workspace.onDidOpenTextDocument(\n+      document => {\n+        this.handleOpenDocument(document);\n+      },\n+      null,\n+      this.disposables,\n+    );\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.staticDiscoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(): Promise<void> {\n+    try {\n+      const tests = await this.findTestFiles();\n+      this.createFileTestItems(tests);\n+    } catch (error) {\n+      // Silent error handling\n+    }\n+  }\n+\n+  private async findTestFiles(): Promise<vscode.Uri[]> {\n+    return await this.findTestFilesWithGitignore();\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFilesWithGitignore(): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs();\n+    const tests = await vscode.workspace.findFiles(this.customFilePattern(), \"node_modules\");\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\"**/.gitignore\", \"**/node_modules/**\");\n+    const ignoreGlobs = [\"**/node_modules/**\"];\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, \"utf8\");\n+        const lines = content\n+          .split(\"\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.push(line.trim());\n+          } else {\n+            ignoreGlobs.push(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch (err) {\n+        // Silent error handling",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2198474457",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20645,
        "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
        "discussion_id": "2198474457",
        "commented_code": "@@ -0,0 +1,1424 @@\n+import { spawn, type ChildProcess } from \"node:child_process\";\n+import { randomUUID } from \"node:crypto\";\n+import * as fsSync from \"node:fs\";\n+import * as fs from \"node:fs/promises\";\n+import { tmpdir } from \"node:os\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import { parseString as xmlParseString } from \"xml2js\";\n+import type { BunFileResult, BunTestResult, TestNode } from \"./types\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      await this.staticDiscoverTests(testItem);\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    const openEditors = vscode.window.visibleTextEditors;\n+    for (const editor of openEditors) {\n+      this.handleOpenDocument(editor.document);\n+    }\n+\n+    vscode.workspace.onDidOpenTextDocument(\n+      document => {\n+        this.handleOpenDocument(document);\n+      },\n+      null,\n+      this.disposables,\n+    );\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.staticDiscoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(): Promise<void> {\n+    try {\n+      const tests = await this.findTestFiles();\n+      this.createFileTestItems(tests);\n+    } catch (error) {\n+      // Silent error handling\n+    }\n+  }\n+\n+  private async findTestFiles(): Promise<vscode.Uri[]> {\n+    return await this.findTestFilesWithGitignore();\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFilesWithGitignore(): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs();\n+    const tests = await vscode.workspace.findFiles(this.customFilePattern(), \"node_modules\");\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\"**/.gitignore\", \"**/node_modules/**\");\n+    const ignoreGlobs = [\"**/node_modules/**\"];\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, \"utf8\");\n+        const lines = content\n+          .split(\"\\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.push(line.trim());\n+          } else {\n+            ignoreGlobs.push(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch (err) {\n+        // Silent error handling",
        "comment_created_at": "2025-07-10T18:55:26+00:00",
        "comment_author": "alii",
        "comment_body": "does vscode offer a way to report errors but not be immediately visible to the user? Not fond of quietly eating errors - someone could fall into this case and never know why the feature is broken",
        "pr_file_module": null
      },
      {
        "comment_id": "2198509362",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20645,
        "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
        "discussion_id": "2198474457",
        "commented_code": "@@ -0,0 +1,1424 @@\n+import { spawn, type ChildProcess } from \"node:child_process\";\n+import { randomUUID } from \"node:crypto\";\n+import * as fsSync from \"node:fs\";\n+import * as fs from \"node:fs/promises\";\n+import { tmpdir } from \"node:os\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import { parseString as xmlParseString } from \"xml2js\";\n+import type { BunFileResult, BunTestResult, TestNode } from \"./types\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      await this.staticDiscoverTests(testItem);\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    const openEditors = vscode.window.visibleTextEditors;\n+    for (const editor of openEditors) {\n+      this.handleOpenDocument(editor.document);\n+    }\n+\n+    vscode.workspace.onDidOpenTextDocument(\n+      document => {\n+        this.handleOpenDocument(document);\n+      },\n+      null,\n+      this.disposables,\n+    );\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.staticDiscoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(): Promise<void> {\n+    try {\n+      const tests = await this.findTestFiles();\n+      this.createFileTestItems(tests);\n+    } catch (error) {\n+      // Silent error handling\n+    }\n+  }\n+\n+  private async findTestFiles(): Promise<vscode.Uri[]> {\n+    return await this.findTestFilesWithGitignore();\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFilesWithGitignore(): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs();\n+    const tests = await vscode.workspace.findFiles(this.customFilePattern(), \"node_modules\");\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\"**/.gitignore\", \"**/node_modules/**\");\n+    const ignoreGlobs = [\"**/node_modules/**\"];\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, \"utf8\");\n+        const lines = content\n+          .split(\"\\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.push(line.trim());\n+          } else {\n+            ignoreGlobs.push(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch (err) {\n+        // Silent error handling",
        "comment_created_at": "2025-07-10T19:13:50+00:00",
        "comment_author": "RiskyMH",
        "comment_body": "Hmm I could make a output channel console like you did for the diagnostics. I just felt like these initial test discovery are pretty not important to care about, but in sense of debugging it can get harder I suppose.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198512012",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20645,
        "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
        "discussion_id": "2198474457",
        "commented_code": "@@ -0,0 +1,1424 @@\n+import { spawn, type ChildProcess } from \"node:child_process\";\n+import { randomUUID } from \"node:crypto\";\n+import * as fsSync from \"node:fs\";\n+import * as fs from \"node:fs/promises\";\n+import { tmpdir } from \"node:os\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import { parseString as xmlParseString } from \"xml2js\";\n+import type { BunFileResult, BunTestResult, TestNode } from \"./types\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      await this.staticDiscoverTests(testItem);\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    const openEditors = vscode.window.visibleTextEditors;\n+    for (const editor of openEditors) {\n+      this.handleOpenDocument(editor.document);\n+    }\n+\n+    vscode.workspace.onDidOpenTextDocument(\n+      document => {\n+        this.handleOpenDocument(document);\n+      },\n+      null,\n+      this.disposables,\n+    );\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.staticDiscoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(): Promise<void> {\n+    try {\n+      const tests = await this.findTestFiles();\n+      this.createFileTestItems(tests);\n+    } catch (error) {\n+      // Silent error handling\n+    }\n+  }\n+\n+  private async findTestFiles(): Promise<vscode.Uri[]> {\n+    return await this.findTestFilesWithGitignore();\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFilesWithGitignore(): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs();\n+    const tests = await vscode.workspace.findFiles(this.customFilePattern(), \"node_modules\");\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\"**/.gitignore\", \"**/node_modules/**\");\n+    const ignoreGlobs = [\"**/node_modules/**\"];\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, \"utf8\");\n+        const lines = content\n+          .split(\"\\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.push(line.trim());\n+          } else {\n+            ignoreGlobs.push(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch (err) {\n+        // Silent error handling",
        "comment_created_at": "2025-07-10T19:15:20+00:00",
        "comment_author": "alii",
        "comment_body": "Yeah that sounds good, basically surfacing the error is better than zero knowledge of a failure at all. At least we can tell a user to look in the logs to see if something went wrong...",
        "pr_file_module": null
      },
      {
        "comment_id": "2198605450",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20645,
        "pr_file": "packages/bun-vscode/src/features/tests/bun-test-controller.ts",
        "discussion_id": "2198474457",
        "commented_code": "@@ -0,0 +1,1424 @@\n+import { spawn, type ChildProcess } from \"node:child_process\";\n+import { randomUUID } from \"node:crypto\";\n+import * as fsSync from \"node:fs\";\n+import * as fs from \"node:fs/promises\";\n+import { tmpdir } from \"node:os\";\n+import * as path from \"node:path\";\n+import * as vscode from \"vscode\";\n+import { parseString as xmlParseString } from \"xml2js\";\n+import type { BunFileResult, BunTestResult, TestNode } from \"./types\";\n+\n+const DEFAULT_TEST_PATTERN = \"**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}\";\n+\n+export class BunTestController implements vscode.Disposable {\n+  private disposables: vscode.Disposable[] = [];\n+  private activeProcesses: Set<ChildProcess> = new Set();\n+\n+  constructor(\n+    private readonly testController: vscode.TestController,\n+    private readonly workspaceFolder: vscode.WorkspaceFolder,\n+  ) {\n+    this.setupTestController();\n+    this.setupWatchers();\n+    this.setupOpenDocumentListener();\n+    this.discoverInitialTests();\n+  }\n+\n+  private setupTestController(): void {\n+    this.testController.resolveHandler = async testItem => {\n+      await this.staticDiscoverTests(testItem);\n+    };\n+\n+    this.testController.createRunProfile(\n+      \"Run Test\",\n+      vscode.TestRunProfileKind.Run,\n+      (request, token) => this.runHandler(request, token, false),\n+      true,\n+    );\n+\n+    this.testController.createRunProfile(\n+      \"Debug\",\n+      vscode.TestRunProfileKind.Debug,\n+      (request, token) => this.runHandler(request, token, true),\n+      true,\n+    );\n+  }\n+\n+  private setupOpenDocumentListener(): void {\n+    const openEditors = vscode.window.visibleTextEditors;\n+    for (const editor of openEditors) {\n+      this.handleOpenDocument(editor.document);\n+    }\n+\n+    vscode.workspace.onDidOpenTextDocument(\n+      document => {\n+        this.handleOpenDocument(document);\n+      },\n+      null,\n+      this.disposables,\n+    );\n+  }\n+\n+  private handleOpenDocument(document: vscode.TextDocument): void {\n+    if (this.isTestFile(document) && !this.testController.items.get(windowsVscodeUri(document.uri.fsPath))) {\n+      this.staticDiscoverTests(false, windowsVscodeUri(document.uri.fsPath));\n+    }\n+  }\n+\n+  private isTestFile(document: vscode.TextDocument): boolean {\n+    return document?.uri?.scheme === \"file\" && /\\.(test|spec)\\.(js|jsx|ts|tsx|cjs|mts)$/.test(document.uri.fsPath);\n+  }\n+\n+  private async discoverInitialTests(): Promise<void> {\n+    try {\n+      const tests = await this.findTestFiles();\n+      this.createFileTestItems(tests);\n+    } catch (error) {\n+      // Silent error handling\n+    }\n+  }\n+\n+  private async findTestFiles(): Promise<vscode.Uri[]> {\n+    return await this.findTestFilesWithGitignore();\n+  }\n+\n+  private customFilePattern(): string {\n+    return vscode.workspace.getConfiguration(\"bun.test\").get(\"filePattern\", DEFAULT_TEST_PATTERN);\n+  }\n+\n+  private async findTestFilesWithGitignore(): Promise<vscode.Uri[]> {\n+    const ignoreGlobs = await this.buildIgnoreGlobs();\n+    const tests = await vscode.workspace.findFiles(this.customFilePattern(), \"node_modules\");\n+\n+    return tests.filter(test => {\n+      const normalizedTestPath = test.fsPath.replace(/\\\\/g, \"/\");\n+      return !ignoreGlobs.some(glob => {\n+        const normalizedGlob = glob.replace(/\\\\/g, \"/\").replace(/^\\.\\//, \"\");\n+        return normalizedTestPath.includes(normalizedGlob);\n+      });\n+    });\n+  }\n+\n+  private async buildIgnoreGlobs(): Promise<string[]> {\n+    const ignores = await vscode.workspace.findFiles(\"**/.gitignore\", \"**/node_modules/**\");\n+    const ignoreGlobs = [\"**/node_modules/**\"];\n+\n+    for (const ignore of ignores) {\n+      try {\n+        const content = await fs.readFile(ignore.fsPath, \"utf8\");\n+        const lines = content\n+          .split(\"\\n\")\n+          .map(line => line.trim())\n+          .filter(line => line && !line.startsWith(\"#\"));\n+\n+        const cwd = path.relative(this.workspaceFolder.uri.fsPath, path.dirname(ignore.fsPath));\n+\n+        for (const line of lines) {\n+          if (!cwd || cwd === \"\" || cwd === \".\") {\n+            ignoreGlobs.push(line.trim());\n+          } else {\n+            ignoreGlobs.push(path.join(cwd.trim(), line.trim()));\n+          }\n+        }\n+      } catch (err) {\n+        // Silent error handling",
        "comment_created_at": "2025-07-10T19:59:24+00:00",
        "comment_author": "RiskyMH",
        "comment_body": "done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1828728295",
    "pr_number": 14831,
    "pr_file": "src/js/builtins/ReadableStreamInternals.ts",
    "created_at": "2024-11-05T05:02:51+00:00",
    "commented_code": "$alwaysInline = true;\n export function isReadableStreamLocked(stream) {\n-  $assert($isReadableStream(stream));\n+  // $assert($isReadableStream(stream));",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "1828728295",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 14831,
        "pr_file": "src/js/builtins/ReadableStreamInternals.ts",
        "discussion_id": "1828728295",
        "commented_code": "@@ -1440,7 +1443,7 @@ export function readableStreamDefaultControllerCallPullIfNeeded(controller) {\n \n $alwaysInline = true;\n export function isReadableStreamLocked(stream) {\n-  $assert($isReadableStream(stream));\n+  // $assert($isReadableStream(stream));",
        "comment_created_at": "2024-11-05T05:02:51+00:00",
        "comment_author": "Jarred-Sumner",
        "comment_body": "This assertion shouldn't be removed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2141247245",
    "pr_number": 20313,
    "pr_file": "src/js/node/zlib.ts",
    "created_at": "2025-06-11T23:09:51+00:00",
    "commented_code": "}\n $toClass(Brotli, \"Brotli\", Zlib);\n \n-function BrotliCompress(opts) {\n+function BrotliCompress(opts): void {\n   if (!(this instanceof BrotliCompress)) return new BrotliCompress(opts);\n   Brotli.$apply(this, [opts, BROTLI_ENCODE]);\n }\n $toClass(BrotliCompress, \"BrotliCompress\", Brotli);\n \n-function BrotliDecompress(opts) {\n+function BrotliDecompress(opts): void {\n   if (!(this instanceof BrotliDecompress)) return new BrotliDecompress(opts);\n   Brotli.$apply(this, [opts, BROTLI_DECODE]);\n }\n $toClass(BrotliDecompress, \"BrotliDecompress\", Brotli);\n \n+const zstdDefaultOpts = {\n+  flush: ZSTD_e_continue,\n+  finishFlush: ZSTD_e_end,\n+  fullFlush: ZSTD_e_flush,\n+};\n+\n+class Zstd extends ZlibBase {\n+  constructor(opts, mode, initParamsArray, maxParam) {\n+    assert(mode === ZSTD_COMPRESS || mode === ZSTD_DECOMPRESS);\n+\n+    initParamsArray.fill(-1);\n+    if (opts?.params) {\n+      ObjectKeys(opts.params).forEach(origKey => {\n+        const key = +origKey;\n+        if (NumberIsNaN(key) || key < 0 || key > maxParam || (initParamsArray[key] | 0) !== -1) {\n+          throw $ERR_ZSTD_INVALID_PARAM(origKey);\n+        }\n+\n+        const value = opts.params[origKey];\n+        if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n+          throw $ERR_INVALID_ARG_TYPE(\"options.params[key]\", \"number\", opts.params[origKey]);\n+        }\n+        initParamsArray[key] = value;\n+      });\n+    }\n+\n+    const handle = new NativeZstd(mode);\n+\n+    const pledgedSrcSize = opts?.pledgedSrcSize ?? undefined;\n+\n+    const writeState = new Uint32Array(2);\n+    handle.init(initParamsArray, pledgedSrcSize, writeState, processCallback);",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2141247245",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20313,
        "pr_file": "src/js/node/zlib.ts",
        "discussion_id": "2141247245",
        "commented_code": "@@ -694,18 +702,75 @@ function Brotli(opts, mode) {\n }\n $toClass(Brotli, \"Brotli\", Zlib);\n \n-function BrotliCompress(opts) {\n+function BrotliCompress(opts): void {\n   if (!(this instanceof BrotliCompress)) return new BrotliCompress(opts);\n   Brotli.$apply(this, [opts, BROTLI_ENCODE]);\n }\n $toClass(BrotliCompress, \"BrotliCompress\", Brotli);\n \n-function BrotliDecompress(opts) {\n+function BrotliDecompress(opts): void {\n   if (!(this instanceof BrotliDecompress)) return new BrotliDecompress(opts);\n   Brotli.$apply(this, [opts, BROTLI_DECODE]);\n }\n $toClass(BrotliDecompress, \"BrotliDecompress\", Brotli);\n \n+const zstdDefaultOpts = {\n+  flush: ZSTD_e_continue,\n+  finishFlush: ZSTD_e_end,\n+  fullFlush: ZSTD_e_flush,\n+};\n+\n+class Zstd extends ZlibBase {\n+  constructor(opts, mode, initParamsArray, maxParam) {\n+    assert(mode === ZSTD_COMPRESS || mode === ZSTD_DECOMPRESS);\n+\n+    initParamsArray.fill(-1);\n+    if (opts?.params) {\n+      ObjectKeys(opts.params).forEach(origKey => {\n+        const key = +origKey;\n+        if (NumberIsNaN(key) || key < 0 || key > maxParam || (initParamsArray[key] | 0) !== -1) {\n+          throw $ERR_ZSTD_INVALID_PARAM(origKey);\n+        }\n+\n+        const value = opts.params[origKey];\n+        if (typeof value !== \"number\" && typeof value !== \"boolean\") {\n+          throw $ERR_INVALID_ARG_TYPE(\"options.params[key]\", \"number\", opts.params[origKey]);\n+        }\n+        initParamsArray[key] = value;\n+      });\n+    }\n+\n+    const handle = new NativeZstd(mode);\n+\n+    const pledgedSrcSize = opts?.pledgedSrcSize ?? undefined;\n+\n+    const writeState = new Uint32Array(2);\n+    handle.init(initParamsArray, pledgedSrcSize, writeState, processCallback);",
        "comment_created_at": "2025-06-11T23:09:51+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "The `handle.init()` call should check its return value to handle initialization failures. Currently, if initialization fails, the constructor will continue and create an invalid instance. Consider adding error handling to throw an appropriate error if the initialization fails, preventing the creation of unusable objects.\n```suggestion\n    const initResult = handle.init(initParamsArray, pledgedSrcSize, writeState, processCallback);\n    if (initResult !== 0) {\n      throw new Error(`Zlib initialization failed with code ${initResult}`);\n    }\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  }
]