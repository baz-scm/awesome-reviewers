[
  {
    "discussion_id": "2132974221",
    "pr_number": 20232,
    "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
    "created_at": "2025-06-06T22:28:42+00:00",
    "commented_code": "RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);\n+    \n+    // We need to reset and step the statement to get fresh types,\n+    // but only do this for read-only statements to avoid side effects\n+    bool isReadOnly = sqlite3_stmt_readonly(castedThis->stmt) != 0;\n+\n+    if (! isReadOnly) {\n+      // For non-read-only statements, throw an error since column types don't make sense\n+      throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"columnTypes is not available for non-read-only statements (INSERT, UPDATE, DELETE, etc.)\"_s));\n+      return { };\n+    }\n+\n+    // Reset the statement (safe for read-only statements)\n+    int resetStatus = sqlite3_reset(castedThis->stmt);\n+    if (resetStatus != SQLITE_OK) {\n+        throwException(lexicalGlobalObject, scope, createSQLiteError(lexicalGlobalObject, castedThis->version_db->db));\n+        return { };\n+    }\n+\n+    // Step once to get to the first row (safe for read-only statements)\n+    int stepStatus = sqlite3_step(castedThis->stmt);\n+\n+    // If we got a row, get types from it\n+    if (stepStatus == SQLITE_ROW) {",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2132974221",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20232,
        "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
        "discussion_id": "2132974221",
        "commented_code": "@@ -2362,6 +2366,129 @@ JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetParamCount, (JSGlobalObject * lexicalG\n     RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);\n+    \n+    // We need to reset and step the statement to get fresh types,\n+    // but only do this for read-only statements to avoid side effects\n+    bool isReadOnly = sqlite3_stmt_readonly(castedThis->stmt) != 0;\n+\n+    if (! isReadOnly) {\n+      // For non-read-only statements, throw an error since column types don't make sense\n+      throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"columnTypes is not available for non-read-only statements (INSERT, UPDATE, DELETE, etc.)\"_s));\n+      return { };\n+    }\n+\n+    // Reset the statement (safe for read-only statements)\n+    int resetStatus = sqlite3_reset(castedThis->stmt);\n+    if (resetStatus != SQLITE_OK) {\n+        throwException(lexicalGlobalObject, scope, createSQLiteError(lexicalGlobalObject, castedThis->version_db->db));\n+        return { };\n+    }\n+\n+    // Step once to get to the first row (safe for read-only statements)\n+    int stepStatus = sqlite3_step(castedThis->stmt);\n+\n+    // If we got a row, get types from it\n+    if (stepStatus == SQLITE_ROW) {",
        "comment_created_at": "2025-06-06T22:28:42+00:00",
        "comment_author": "Jarred-Sumner",
        "comment_body": "One thing I'm not sure about: do we need to call sqlite3_step repeatedly or can we get away iwth only stepping once?",
        "pr_file_module": null
      },
      {
        "comment_id": "2133072187",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20232,
        "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
        "discussion_id": "2132974221",
        "commented_code": "@@ -2362,6 +2366,129 @@ JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetParamCount, (JSGlobalObject * lexicalG\n     RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);\n+    \n+    // We need to reset and step the statement to get fresh types,\n+    // but only do this for read-only statements to avoid side effects\n+    bool isReadOnly = sqlite3_stmt_readonly(castedThis->stmt) != 0;\n+\n+    if (! isReadOnly) {\n+      // For non-read-only statements, throw an error since column types don't make sense\n+      throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"columnTypes is not available for non-read-only statements (INSERT, UPDATE, DELETE, etc.)\"_s));\n+      return { };\n+    }\n+\n+    // Reset the statement (safe for read-only statements)\n+    int resetStatus = sqlite3_reset(castedThis->stmt);\n+    if (resetStatus != SQLITE_OK) {\n+        throwException(lexicalGlobalObject, scope, createSQLiteError(lexicalGlobalObject, castedThis->version_db->db));\n+        return { };\n+    }\n+\n+    // Step once to get to the first row (safe for read-only statements)\n+    int stepStatus = sqlite3_step(castedThis->stmt);\n+\n+    // If we got a row, get types from it\n+    if (stepStatus == SQLITE_ROW) {",
        "comment_created_at": "2025-06-06T23:29:06+00:00",
        "comment_author": "crishoj",
        "comment_body": "`sqlite3_step` evaluates the prepared bytecode up to the point where a row is returned or there are no more rows, so the only expected non-error return codes are `SQLITE_ROW` and `SQLITE_DONE`.\r\n\r\nThat being said, calling `sqlite3_reset` and `sqlite3_step` again just go get the column types just seems silly, now that I think about it. The statement could be a costly one, and Prisma would end up running it _twice_.\r\n\r\nHow about instead capturing the column types after the first call to `sqlite3_step` in `jsSQLStatementExecuteStatementFunctionGet`, `...All` and `...Iterate`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2133013736",
    "pr_number": 20232,
    "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
    "created_at": "2025-06-06T22:49:41+00:00",
    "commented_code": "RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);\n+    \n+    // We need to reset and step the statement to get fresh types,\n+    // but only do this for read-only statements to avoid side effects\n+    bool isReadOnly = sqlite3_stmt_readonly(castedThis->stmt) != 0;\n+\n+    if (! isReadOnly) {\n+      // For non-read-only statements, throw an error since column types don't make sense\n+      throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"columnTypes is not available for non-read-only statements (INSERT, UPDATE, DELETE, etc.)\"_s));\n+      return { };\n+    }\n+\n+    // Reset the statement (safe for read-only statements)\n+    int resetStatus = sqlite3_reset(castedThis->stmt);\n+    if (resetStatus != SQLITE_OK) {\n+        throwException(lexicalGlobalObject, scope, createSQLiteError(lexicalGlobalObject, castedThis->version_db->db));\n+        return { };\n+    }\n+\n+    // Step once to get to the first row (safe for read-only statements)\n+    int stepStatus = sqlite3_step(castedThis->stmt);\n+\n+    // If we got a row, get types from it\n+    if (stepStatus == SQLITE_ROW) {\n+        for (int i = 0; i < count; i++) {\n+            JSC::JSValue typeValue;\n+\n+            // Get the actual column type from the current row\n+            int columnType = sqlite3_column_type(castedThis->stmt, i);\n+\n+            switch (columnType) {\n+            case SQLITE_INTEGER:\n+                typeValue = JSC::jsAtomString(vm, makeAtomString(\"INTEGER\"_s));\n+                break;\n+            case SQLITE_FLOAT:\n+                typeValue = JSC::jsAtomString(vm, makeAtomString(\"FLOAT\"_s));\n+                break;\n+            case SQLITE3_TEXT:",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2133013736",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20232,
        "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
        "discussion_id": "2133013736",
        "commented_code": "@@ -2362,6 +2366,129 @@ JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetParamCount, (JSGlobalObject * lexicalG\n     RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);\n+    \n+    // We need to reset and step the statement to get fresh types,\n+    // but only do this for read-only statements to avoid side effects\n+    bool isReadOnly = sqlite3_stmt_readonly(castedThis->stmt) != 0;\n+\n+    if (! isReadOnly) {\n+      // For non-read-only statements, throw an error since column types don't make sense\n+      throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"columnTypes is not available for non-read-only statements (INSERT, UPDATE, DELETE, etc.)\"_s));\n+      return { };\n+    }\n+\n+    // Reset the statement (safe for read-only statements)\n+    int resetStatus = sqlite3_reset(castedThis->stmt);\n+    if (resetStatus != SQLITE_OK) {\n+        throwException(lexicalGlobalObject, scope, createSQLiteError(lexicalGlobalObject, castedThis->version_db->db));\n+        return { };\n+    }\n+\n+    // Step once to get to the first row (safe for read-only statements)\n+    int stepStatus = sqlite3_step(castedThis->stmt);\n+\n+    // If we got a row, get types from it\n+    if (stepStatus == SQLITE_ROW) {\n+        for (int i = 0; i < count; i++) {\n+            JSC::JSValue typeValue;\n+\n+            // Get the actual column type from the current row\n+            int columnType = sqlite3_column_type(castedThis->stmt, i);\n+\n+            switch (columnType) {\n+            case SQLITE_INTEGER:\n+                typeValue = JSC::jsAtomString(vm, makeAtomString(\"INTEGER\"_s));\n+                break;\n+            case SQLITE_FLOAT:\n+                typeValue = JSC::jsAtomString(vm, makeAtomString(\"FLOAT\"_s));\n+                break;\n+            case SQLITE3_TEXT:",
        "comment_created_at": "2025-06-06T22:49:41+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "There appears to be a typo in the constant name - this should be `SQLITE_TEXT` rather than `SQLITE3_TEXT`. All SQLite type constants follow the `SQLITE_` prefix pattern, as seen with the other constants used in this switch statement (`SQLITE_INTEGER`, `SQLITE_FLOAT`, etc.).\n```suggestion\n            case SQLITE_TEXT:\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      },
      {
        "comment_id": "2133073037",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20232,
        "pr_file": "src/bun.js/bindings/sqlite/JSSQLStatement.cpp",
        "discussion_id": "2133013736",
        "commented_code": "@@ -2362,6 +2366,129 @@ JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetParamCount, (JSGlobalObject * lexicalG\n     RELEASE_AND_RETURN(scope, JSC::JSValue::encode(JSC::jsNumber(sqlite3_bind_parameter_count(castedThis->stmt))));\n }\n \n+JSC_DEFINE_CUSTOM_GETTER(jsSqlStatementGetColumnTypes, (JSGlobalObject * lexicalGlobalObject, JSC::EncodedJSValue thisValue, PropertyName attributeName))\n+{\n+    auto& vm = JSC::getVM(lexicalGlobalObject);\n+    JSSQLStatement* castedThis = jsDynamicCast<JSSQLStatement*>(JSValue::decode(thisValue));\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+    CHECK_THIS\n+    CHECK_PREPARED\n+\n+    // Ensure the statement has been executed at least once\n+    if (!castedThis->hasExecuted) {\n+        throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"Statement must be executed before accessing columnTypes\"_s));\n+        return { };\n+    }\n+\n+    int count = sqlite3_column_count(castedThis->stmt);\n+    JSC::JSArray* array = JSC::constructEmptyArray(lexicalGlobalObject, nullptr, count);\n+    \n+    // We need to reset and step the statement to get fresh types,\n+    // but only do this for read-only statements to avoid side effects\n+    bool isReadOnly = sqlite3_stmt_readonly(castedThis->stmt) != 0;\n+\n+    if (! isReadOnly) {\n+      // For non-read-only statements, throw an error since column types don't make sense\n+      throwException(lexicalGlobalObject, scope, createError(lexicalGlobalObject, \"columnTypes is not available for non-read-only statements (INSERT, UPDATE, DELETE, etc.)\"_s));\n+      return { };\n+    }\n+\n+    // Reset the statement (safe for read-only statements)\n+    int resetStatus = sqlite3_reset(castedThis->stmt);\n+    if (resetStatus != SQLITE_OK) {\n+        throwException(lexicalGlobalObject, scope, createSQLiteError(lexicalGlobalObject, castedThis->version_db->db));\n+        return { };\n+    }\n+\n+    // Step once to get to the first row (safe for read-only statements)\n+    int stepStatus = sqlite3_step(castedThis->stmt);\n+\n+    // If we got a row, get types from it\n+    if (stepStatus == SQLITE_ROW) {\n+        for (int i = 0; i < count; i++) {\n+            JSC::JSValue typeValue;\n+\n+            // Get the actual column type from the current row\n+            int columnType = sqlite3_column_type(castedThis->stmt, i);\n+\n+            switch (columnType) {\n+            case SQLITE_INTEGER:\n+                typeValue = JSC::jsAtomString(vm, makeAtomString(\"INTEGER\"_s));\n+                break;\n+            case SQLITE_FLOAT:\n+                typeValue = JSC::jsAtomString(vm, makeAtomString(\"FLOAT\"_s));\n+                break;\n+            case SQLITE3_TEXT:",
        "comment_created_at": "2025-06-06T23:30:58+00:00",
        "comment_author": "crishoj",
        "comment_body": "\ud83d\udc4e\r\n\r\nAs per comment above:\r\n\r\n> Note that the SQLITE_TEXT constant was also used in SQLite version\r\n> 2 for a completely different meaning. Software that links against\r\n> both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT,\r\n> not SQLITE_TEXT.\r\n",
        "pr_file_module": null
      }
    ]
  }
]