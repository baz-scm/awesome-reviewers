[
  {
    "discussion_id": "2191647855",
    "pr_number": 20883,
    "pr_file": "src/js/internal/fs/glob.ts",
    "created_at": "2025-07-08T06:58:12+00:00",
    "commented_code": "import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\" && exclude(ent)) continue;\n+      if (excludeGlobs?.some(([glob, p]) => glob.match(ent) || ent.startsWith(p))) continue;",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2191647855",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2191647855",
        "commented_code": "@@ -1,58 +1,72 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\" && exclude(ent)) continue;\n+      if (excludeGlobs?.some(([glob, p]) => glob.match(ent) || ent.startsWith(p))) continue;",
        "comment_created_at": "2025-07-08T06:58:12+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "The `ent.startsWith(p)` check may be overly inclusive and could exclude unintended files. For example, with an exclude pattern of `'foo'`, this would exclude both `'foo/bar'` (intended) and `'foobar'` (likely unintended). \n\nConsider either:\n1. Using only `glob.match(ent)` if it provides sufficient matching capability\n2. Implementing a more precise path-based check that respects directory boundaries, such as:\n   ```js\n   // Check if it's the exact path or a subdirectory (with path separator)\n   p === ent || ent.startsWith(p + path.sep)\n   ```\n\nThis would ensure exclusions only apply to the specified directory and its contents, not to files that merely share a prefix.\n```suggestion\nif (excludeGlobs?.some(([glob, p]) => glob.match(ent) || p === ent || ent.startsWith(p + path.sep))) continue;\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198609902",
    "pr_number": 20883,
    "pr_file": "src/js/internal/fs/glob.ts",
    "created_at": "2025-07-10T20:02:14+00:00",
    "commented_code": "import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2198609902",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2198609902",
        "commented_code": "@@ -1,58 +1,88 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
        "comment_created_at": "2025-07-10T20:02:14+00:00",
        "comment_author": "taylordotfish",
        "comment_body": "Is there a case where `glob.match(ent)` is false but `_ent === p` is true? `new Bun.Glob(\"foo/bar\").match(\"foo\\\\bar\")` returns true on Windows, so it seems to convert separators already.\r\n\r\nAlso, I think the current approach of using `_ent.startsWith(p + \"/\")` to handle directories won't work if `p` contains wildcards. For example:\r\n\r\n```typescript\r\nfs.mkdirSync(\"a/b/c/d\", {recursive: true})\r\nfs.globSync(\"a/**\", {exclude: [\"*/b\"])\r\n// should return ['a'], but instead returns ['a', 'a/b/c', 'a/b/c/d']\r\n```\r\n\r\nMaybe instead we need to match against two globs: `Bun.Glob(p)` and `Bun.Glob(p + \"/*\")` for each exclude pattern `p`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198660598",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2198609902",
        "commented_code": "@@ -1,58 +1,88 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
        "comment_created_at": "2025-07-10T20:29:48+00:00",
        "comment_author": "RiskyMH",
        "comment_body": "Yeah good question. Basically the way node does it and bun do things are subtly different. It would need to be `/**/*` I believe, but adding that itself caused edge cases of issues too, so I felt like a literal startsWith was safer to try and preserve what the user had specified, and for basic things it should still work (i.e only really saw literal `node_modules` or actual globs in use).\r\n\r\nIn an earlier iteration I did make the excludeGlobs a flatMap instead of map so it would have the 2. I can do that again and then not do the `/**` if it already ends in /* or similar I suppose.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198705555",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2198609902",
        "commented_code": "@@ -1,58 +1,88 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
        "comment_created_at": "2025-07-10T20:48:30+00:00",
        "comment_author": "taylordotfish",
        "comment_body": "Good point, `/*` isn't sufficient. I think matching against these two globs should work in all cases:\r\n\r\n* `new Bun.Glob(p)`\r\n* `new Bun.Glob(p.replace(/\\/+$/, \"\") + \"/**\")`\r\n\r\nThere's probably a faster way to strip trailing slashes, but logically I think that's right. I'm curious if there are still edge case failures with this approach.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198756104",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2198609902",
        "commented_code": "@@ -1,58 +1,88 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
        "comment_created_at": "2025-07-10T21:12:14+00:00",
        "comment_author": "RiskyMH",
        "comment_body": "The main issue I'm referring to is like `src/*` where we don't want to make it expand infinitly and instead still respect the 1lv deep (I think node does respect too, will need to check again). The other one could be `src/*.js` and adding `/**/*` to end may make the `.js` be treated as folder & not actually a file (may need to check how harsh bun does it though).\r\n\r\nAlso I think you need `/**/*` as just `/**` only matches folders and not files",
        "pr_file_module": null
      },
      {
        "comment_id": "2198869088",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2198609902",
        "commented_code": "@@ -1,58 +1,88 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
        "comment_created_at": "2025-07-10T22:16:49+00:00",
        "comment_author": "taylordotfish",
        "comment_body": "`/**` matches both directories and files for me with both Node and Bun.\r\n\r\n```console\r\n$ mkdir -p a/b/c\r\n$ touch a/b/c/file\r\n```\r\n\r\nIn `test.mjs`:\r\n\r\n```javascript\r\nimport fs from \"node:fs\";\r\nconsole.log(fs.globSync(\"a/**\"));\r\n```\r\n\r\n```console\r\n$ node test.mjs \r\n[ 'a', 'a/b', 'a/b/c', 'a/b/c/file' ]\r\n$ bun run test.mjs \r\n[ \"a/b\", \"a/b/c\", \"a/b/c/file\" ]\r\n```\r\n\r\nBun and Node differ in whether they include `a` itself, but they both match the file.\r\n\r\n(Fixing this unrelated compatibility issue would actually make this PR simpler, because then we would only have to match against one pattern, `Glob(p.replace(/\\/+$/, \"\") + \"/**\")`)",
        "pr_file_module": null
      },
      {
        "comment_id": "2198911707",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2198609902",
        "commented_code": "@@ -1,58 +1,88 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
        "comment_created_at": "2025-07-10T22:40:52+00:00",
        "comment_author": "RiskyMH",
        "comment_body": "Ah yeah I tested wrongly to get that conclusion. In anycase, I'll see what I can do about appending `/**` in a way that doesn't match too differently to node. I do wish it was a literal negation instead of excludes behaving differently.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198941443",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20883,
        "pr_file": "src/js/internal/fs/glob.ts",
        "discussion_id": "2198609902",
        "commented_code": "@@ -1,58 +1,88 @@\n import type { GlobScanOptions } from \"bun\";\n-const { validateObject, validateString, validateFunction } = require(\"internal/validators\");\n+const { validateObject, validateString, validateFunction, validateArray } = require(\"internal/validators\");\n+const { sep } = require(\"node:path\");\n \n const isWindows = process.platform === \"win32\";\n \n interface GlobOptions {\n   /** @default process.cwd() */\n   cwd?: string;\n-  exclude?: (ent: string) => boolean;\n+  exclude?: ((ent: string) => boolean) | string[];\n   /**\n    * Should glob return paths as {@link Dirent} objects. `false` for strings.\n    * @default false */\n   withFileTypes?: boolean;\n }\n \n-interface ExtendedGlobOptions extends GlobScanOptions {\n-  exclude(ent: string): boolean;\n-}\n-\n async function* glob(pattern: string | string[], options?: GlobOptions): AsyncGenerator<string> {\n-  pattern = validatePattern(pattern);\n+  const patterns = validatePattern(pattern);\n   const globOptions = mapOptions(options || {});\n-  let it = new Bun.Glob(pattern).scan(globOptions);\n   const exclude = globOptions.exclude;\n+  const excludeGlobs = Array.isArray(exclude) ? exclude.map(p => [new Bun.Glob(p), p] as const) : null;\n \n-  for await (const ent of it) {\n-    if (exclude(ent)) continue;\n-    yield ent;\n+  for (const pat of patterns) {\n+    for await (const ent of new Bun.Glob(pat).scan(globOptions)) {\n+      if (typeof exclude === \"function\") {\n+        if (exclude(ent)) continue;\n+      } else if (excludeGlobs) {\n+        const _ent = ent.replaceAll(sep, \"/\");\n+        if (excludeGlobs.some(([glob, p]) => glob.match(ent) || _ent === p || _ent.startsWith(p + \"/\"))) {",
        "comment_created_at": "2025-07-10T22:57:22+00:00",
        "comment_author": "RiskyMH",
        "comment_body": "Your replace was spot on, thanks that seems to have been the part that messed with me before. I think its now pretty accurate to node!",
        "pr_file_module": null
      }
    ]
  }
]