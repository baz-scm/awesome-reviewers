[
  {
    "discussion_id": "2115092230",
    "pr_number": 20049,
    "pr_file": "src/bun.js/bindings/node/http/JSHTTPParserPrototype.cpp",
    "created_at": "2025-05-30T03:51:07+00:00",
    "commented_code": "+#include \"JSHTTPParserPrototype.h\"\n+#include \"JSHTTPParser.h\"\n+#include \"JSConnectionsList.h\"\n+#include \"ZigGlobalObject.h\"\n+#include \"JSDOMExceptionHandling.h\"\n+\n+namespace Bun {\n+\n+using namespace JSC;\n+\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_close);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_free);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_remove);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_execute);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_finish);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_initialize);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_pause);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_resume);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_consume);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_unconsume);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_getCurrentBuffer);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_duration);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_headersCompleted);\n+\n+const ClassInfo JSHTTPParserPrototype::s_info = { \"HTTPParser\"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSHTTPParserPrototype) };\n+\n+static const HashTableValue JSHTTPParserPrototypeTableValues[] = {\n+    { \"close\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_close, 0 } },\n+    { \"free\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_free, 0 } },\n+    { \"remove\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_remove, 0 } },\n+    { \"execute\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_execute, 0 } },\n+    { \"finish\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_finish, 0 } },\n+    { \"initialize\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_initialize, 0 } },\n+    { \"pause\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_pause, 0 } },\n+    { \"resume\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_resume, 0 } },\n+    { \"consume\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_consume, 0 } },\n+    { \"unconsume\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_unconsume, 0 } },\n+    { \"getCurrentBuffer\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_getCurrentBuffer, 0 } },\n+    { \"duration\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_duration, 0 } },\n+    { \"headersCompleted\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_headersCompleted, 0 } },\n+};\n+\n+void JSHTTPParserPrototype::finishCreation(VM& vm)\n+{\n+    Base::finishCreation(vm);\n+    reifyStaticProperties(vm, info(), JSHTTPParserPrototypeTableValues, *this);\n+    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_close, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"close\"_s);\n+        return {};\n+    }\n+\n+    delete parser;\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_free, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"free\"_s);\n+        return {};\n+    }\n+\n+    // TODO: TODO!\n+    // parser->emitTraceEventDestroy();\n+    // parser->emitDestroy();\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_remove, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    JSValue thisValue = callFrame->thisValue();\n+\n+    JSHTTPParser* thisParser = jsDynamicCast<JSHTTPParser*>(thisValue);\n+    if (!thisParser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"remove\"_s);\n+        return {};\n+    }\n+\n+    HTTPParser* parser = thisParser->impl();\n+    if (!parser) {\n+        return JSValue::encode(jsUndefined());\n+    }\n+\n+    return JSValue::encode(parser->remove(globalObject, thisParser));\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_execute, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"execute\"_s);\n+        return {};\n+    }\n+\n+    JSValue bufferValue = callFrame->argument(0);\n+\n+    if (auto* buffer = jsDynamicCast<JSArrayBufferView*>(bufferValue)) {\n+        if (buffer->isDetached()) {\n+            throwTypeError(globalObject, scope, \"Buffer is detached\"_s);\n+            return JSValue::encode(jsUndefined());\n+        }\n+\n+        JSValue result = parser->execute(globalObject, reinterpret_cast<const char*>(buffer->vector()), buffer->byteLength());\n+        RETURN_IF_EXCEPTION(scope, {});\n+\n+        if (!result.isEmpty()) {\n+            return JSValue::encode(result);\n+        }\n+    }\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_finish, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"finish\"_s);\n+        return {};\n+    }\n+\n+    JSValue result = parser->execute(globalObject, nullptr, 0);\n+    RETURN_IF_EXCEPTION(scope, {});\n+\n+    if (!result.isEmpty()) {\n+        return JSValue::encode(result);\n+    }\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+extern \"C\" size_t BUN_DEFAULT_MAX_HTTP_HEADER_SIZE;\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_initialize, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    uint64_t maxHttpHeaderSize = 0;\n+    uint32_t lenientFlags = kLenientNone;\n+    JSConnectionsList* connections = nullptr;\n+\n+    if (callFrame->argumentCount() > 2) {\n+        JSValue maxHttpHeaderSizeValue = callFrame->argument(2);\n+        if (maxHttpHeaderSizeValue.isNumber()) {\n+            maxHttpHeaderSize = static_cast<uint64_t>(maxHttpHeaderSizeValue.asNumber());\n+        }\n+    }\n+\n+    if (maxHttpHeaderSize == 0) {\n+        maxHttpHeaderSize = BUN_DEFAULT_MAX_HTTP_HEADER_SIZE;\n+    }\n+\n+    if (callFrame->argumentCount() > 3) {\n+        JSValue lenientFlagsValue = callFrame->argument(3);\n+        if (lenientFlagsValue.isInt32()) {\n+            lenientFlags = lenientFlagsValue.asInt32();\n+        }\n+    }\n+\n+    if (callFrame->argumentCount() > 4) {\n+        JSValue connectionsListValue = callFrame->argument(4);\n+        if (!connectionsListValue.isUndefinedOrNull()) {\n+            connections = jsDynamicCast<JSConnectionsList*>(connectionsListValue);\n+            if (!connections) {\n+                return JSValue::encode(jsUndefined());\n+            }\n+        }\n+    }\n+\n+    JSValue typeValue = callFrame->argument(0);\n+\n+    llhttp_type_t type = static_cast<llhttp_type_t>(typeValue.asNumber());",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2115092230",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20049,
        "pr_file": "src/bun.js/bindings/node/http/JSHTTPParserPrototype.cpp",
        "discussion_id": "2115092230",
        "commented_code": "@@ -0,0 +1,318 @@\n+#include \"JSHTTPParserPrototype.h\"\n+#include \"JSHTTPParser.h\"\n+#include \"JSConnectionsList.h\"\n+#include \"ZigGlobalObject.h\"\n+#include \"JSDOMExceptionHandling.h\"\n+\n+namespace Bun {\n+\n+using namespace JSC;\n+\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_close);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_free);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_remove);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_execute);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_finish);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_initialize);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_pause);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_resume);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_consume);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_unconsume);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_getCurrentBuffer);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_duration);\n+JSC_DECLARE_HOST_FUNCTION(jsHTTPParser_headersCompleted);\n+\n+const ClassInfo JSHTTPParserPrototype::s_info = { \"HTTPParser\"_s, &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSHTTPParserPrototype) };\n+\n+static const HashTableValue JSHTTPParserPrototypeTableValues[] = {\n+    { \"close\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_close, 0 } },\n+    { \"free\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_free, 0 } },\n+    { \"remove\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_remove, 0 } },\n+    { \"execute\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_execute, 0 } },\n+    { \"finish\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_finish, 0 } },\n+    { \"initialize\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_initialize, 0 } },\n+    { \"pause\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_pause, 0 } },\n+    { \"resume\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_resume, 0 } },\n+    { \"consume\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_consume, 0 } },\n+    { \"unconsume\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_unconsume, 0 } },\n+    { \"getCurrentBuffer\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_getCurrentBuffer, 0 } },\n+    { \"duration\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_duration, 0 } },\n+    { \"headersCompleted\"_s, static_cast<unsigned>(PropertyAttribute::Function), NoIntrinsic, { HashTableValue::NativeFunctionType, jsHTTPParser_headersCompleted, 0 } },\n+};\n+\n+void JSHTTPParserPrototype::finishCreation(VM& vm)\n+{\n+    Base::finishCreation(vm);\n+    reifyStaticProperties(vm, info(), JSHTTPParserPrototypeTableValues, *this);\n+    JSC_TO_STRING_TAG_WITHOUT_TRANSITION();\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_close, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"close\"_s);\n+        return {};\n+    }\n+\n+    delete parser;\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_free, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"free\"_s);\n+        return {};\n+    }\n+\n+    // TODO: TODO!\n+    // parser->emitTraceEventDestroy();\n+    // parser->emitDestroy();\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_remove, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    JSValue thisValue = callFrame->thisValue();\n+\n+    JSHTTPParser* thisParser = jsDynamicCast<JSHTTPParser*>(thisValue);\n+    if (!thisParser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"remove\"_s);\n+        return {};\n+    }\n+\n+    HTTPParser* parser = thisParser->impl();\n+    if (!parser) {\n+        return JSValue::encode(jsUndefined());\n+    }\n+\n+    return JSValue::encode(parser->remove(globalObject, thisParser));\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_execute, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"execute\"_s);\n+        return {};\n+    }\n+\n+    JSValue bufferValue = callFrame->argument(0);\n+\n+    if (auto* buffer = jsDynamicCast<JSArrayBufferView*>(bufferValue)) {\n+        if (buffer->isDetached()) {\n+            throwTypeError(globalObject, scope, \"Buffer is detached\"_s);\n+            return JSValue::encode(jsUndefined());\n+        }\n+\n+        JSValue result = parser->execute(globalObject, reinterpret_cast<const char*>(buffer->vector()), buffer->byteLength());\n+        RETURN_IF_EXCEPTION(scope, {});\n+\n+        if (!result.isEmpty()) {\n+            return JSValue::encode(result);\n+        }\n+    }\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_finish, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    HTTPParser* parser = JSHTTPParser::toImpl(callFrame->thisValue());\n+    if (!parser) {\n+        throwThisTypeError(*globalObject, scope, \"HTTPParser\"_s, \"finish\"_s);\n+        return {};\n+    }\n+\n+    JSValue result = parser->execute(globalObject, nullptr, 0);\n+    RETURN_IF_EXCEPTION(scope, {});\n+\n+    if (!result.isEmpty()) {\n+        return JSValue::encode(result);\n+    }\n+\n+    return JSValue::encode(jsUndefined());\n+}\n+\n+extern \"C\" size_t BUN_DEFAULT_MAX_HTTP_HEADER_SIZE;\n+\n+JSC_DEFINE_HOST_FUNCTION(jsHTTPParser_initialize, (JSGlobalObject * globalObject, CallFrame* callFrame))\n+{\n+    VM& vm = globalObject->vm();\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    uint64_t maxHttpHeaderSize = 0;\n+    uint32_t lenientFlags = kLenientNone;\n+    JSConnectionsList* connections = nullptr;\n+\n+    if (callFrame->argumentCount() > 2) {\n+        JSValue maxHttpHeaderSizeValue = callFrame->argument(2);\n+        if (maxHttpHeaderSizeValue.isNumber()) {\n+            maxHttpHeaderSize = static_cast<uint64_t>(maxHttpHeaderSizeValue.asNumber());\n+        }\n+    }\n+\n+    if (maxHttpHeaderSize == 0) {\n+        maxHttpHeaderSize = BUN_DEFAULT_MAX_HTTP_HEADER_SIZE;\n+    }\n+\n+    if (callFrame->argumentCount() > 3) {\n+        JSValue lenientFlagsValue = callFrame->argument(3);\n+        if (lenientFlagsValue.isInt32()) {\n+            lenientFlags = lenientFlagsValue.asInt32();\n+        }\n+    }\n+\n+    if (callFrame->argumentCount() > 4) {\n+        JSValue connectionsListValue = callFrame->argument(4);\n+        if (!connectionsListValue.isUndefinedOrNull()) {\n+            connections = jsDynamicCast<JSConnectionsList*>(connectionsListValue);\n+            if (!connections) {\n+                return JSValue::encode(jsUndefined());\n+            }\n+        }\n+    }\n+\n+    JSValue typeValue = callFrame->argument(0);\n+\n+    llhttp_type_t type = static_cast<llhttp_type_t>(typeValue.asNumber());",
        "comment_created_at": "2025-05-30T03:51:07+00:00",
        "comment_author": "Jarred-Sumner",
        "comment_body": "```suggestion\r\n    llhttp_type_t type = static_cast<llhttp_type_t>(typeValue.toNumber(globalObject));\r\n    RETURN_IF_EXCEPTION(scope, {});\r\n```",
        "pr_file_module": null
      }
    ]
  }
]