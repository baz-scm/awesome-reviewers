[
  {
    "discussion_id": "2196383463",
    "pr_number": 20927,
    "pr_file": "test/regression/issue/20927.test.js",
    "created_at": "2025-07-10T02:40:22+00:00",
    "commented_code": "+import { expect, test } from \"bun:test\";\n+\n+// This used to break in ASAN builds of Bun in CI due to LTO flags being passed\n+// to CMake. Specifically, the callback passed to `vm.deferredWorkTimer->scheduleWorkSoon(ticket, ...)`\n+// never gets called (see JSFinalizationRegistry.cpp in WebKit).\n+test(\"FinalizationRegistry callback should be called\", async () => {\n+  const registry = new FinalizationRegistry(value => value(123));\n+  const promise = new Promise(resolve => registry.register({}, resolve));\n+\n+  Bun.gc(true);\n+  expect(promise).resolves.toBe(123);",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2198309203",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20927,
        "pr_file": "test/regression/issue/20927.test.js",
        "discussion_id": "2196383463",
        "commented_code": "@@ -0,0 +1,12 @@\n+import { expect, test } from \"bun:test\";\n+\n+// This used to break in ASAN builds of Bun in CI due to LTO flags being passed\n+// to CMake. Specifically, the callback passed to `vm.deferredWorkTimer->scheduleWorkSoon(ticket, ...)`\n+// never gets called (see JSFinalizationRegistry.cpp in WebKit).\n+test(\"FinalizationRegistry callback should be called\", async () => {\n+  const registry = new FinalizationRegistry(value => value(123));\n+  const promise = new Promise(resolve => registry.register({}, resolve));\n+\n+  Bun.gc(true);\n+  expect(promise).resolves.toBe(123);",
        "comment_created_at": "2025-07-10T17:34:37+00:00",
        "comment_author": "190n",
        "comment_body": "this is wrong, in bun `expect(...).resolves` functions as a synchronous await (though it probably shouldn't)",
        "pr_file_module": null
      },
      {
        "comment_id": "2198400266",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20927,
        "pr_file": "test/regression/issue/20927.test.js",
        "discussion_id": "2196383463",
        "commented_code": "@@ -0,0 +1,12 @@\n+import { expect, test } from \"bun:test\";\n+\n+// This used to break in ASAN builds of Bun in CI due to LTO flags being passed\n+// to CMake. Specifically, the callback passed to `vm.deferredWorkTimer->scheduleWorkSoon(ticket, ...)`\n+// never gets called (see JSFinalizationRegistry.cpp in WebKit).\n+test(\"FinalizationRegistry callback should be called\", async () => {\n+  const registry = new FinalizationRegistry(value => value(123));\n+  const promise = new Promise(resolve => registry.register({}, resolve));\n+\n+  Bun.gc(true);\n+  expect(promise).resolves.toBe(123);",
        "comment_created_at": "2025-07-10T18:20:59+00:00",
        "comment_author": "CountBleck",
        "comment_body": "@190n I wish that was documented, because I just went off Jest's docs and assumed the \"await has no effect on this type of expression\" TS diagnostic was a fluke.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2139376291",
    "pr_number": 20313,
    "pr_file": "test/js/node/zlib/zlib.test.js",
    "created_at": "2025-06-11T07:08:19+00:00",
    "commented_code": "});\n   }\n }\n+\n+describe(\"zlib.zstd\", () => {\n+  const inputString =\n+    \"立立Lorem ipsum dolor sit amet, consectetur adipiscing eli\" +\n+    \"t. Morbi faucibus, purus at gravida dictum, libero arcu \" +\n+    \"convallis lacus, in commodo libero metus eu nisi. Nullam\" +\n+    \" commodo, neque nec porta placerat, nisi est fermentum a\" +\n+    \"ugue, vitae gravida tellus sapien sit amet tellus. Aenea\" +\n+    \"n non diam orci. Proin quis elit turpis. Suspendisse non\" +\n+    \" diam ipsum. Suspendisse nec ullamcorper odio. Vestibulu\" +\n+    \"m arcu mi, sodales non suscipit id, ultrices ut massa. S\" +\n+    \"ed ac sem sit amet arcu malesuada fermentum. Nunc sed. \";\n+  const compressedString =\n+    \"KLUv/WD5AF0JAGbXPCCgJUkH/8+rqgA3KaVsW+6LfK3JLcnP+I/\" +\n+    \"Gy1/3Qv9XDTQAMwA0AK+Ch9LCub6tnT62C7QuwrHQHDhhNPcCQl\" +\n+    \"tMWOrafGy3KO2D79QZ95omy09vwp/TFEAkEIlHOO99cOlZmfRiz\" +\n+    \"XQ79GvDoY9TxrTgBBfR+77Nd7LkOWlHaGW+aEwd2rSeegWaj9Ns\" +\n+    \"WAJJ0253u1jQpe3ByWLS5i+24QhTAZygaf4UlqNER3XoAk7QYar\" +\n+    \"9tjHHV4yHj+tC108zuqMBJ+X2hlpwUqX6vE3r3N7q5QYntVvn3N\" +\n+    \"8zVDb9UfCMCW1790yV3A88pgvkvQAniSWvFxMAELvECFu0tC1R9\" +\n+    \"Ijsri5bt2kE/2mLoi2wCpkElnidDMS//DemxlNdHClyl6KeNTCugmAG\";\n+  const compressedBuffer = Buffer.from(compressedString, \"base64\");\n+\n+  it(\"zstdDecompress\", async () => {\n+    const roundtrip = await util.promisify(zlib.zstdDecompress)(compressedBuffer);\n+    expect(roundtrip.toString()).toEqual(inputString);\n+  });\n+\n+  it(\"zstdCompressSync\", () => {\n+    const compressed = zlib.zstdCompressSync(inputString);\n+    expect(compressed.toString(\"base64\")).toEqual(compressedString);\n+  });\n+\n+  it(\"zstdDecompressSync\", () => {\n+    const roundtrip = zlib.zstdDecompressSync(compressedBuffer);\n+    expect(roundtrip.toString()).toEqual(inputString);\n+  });\n+\n+  it(\"can compress streaming\", async () => {\n+    const encoder = zlib.createZstdCompress();\n+    for (const chunk of window(inputString, 55)) {\n+      encoder.push(chunk);\n+    }\n+    encoder.push(null);\n+    const buf = await new Response(encoder).text();\n+    expect(buf).toEqual(inputString);\n+  });\n+\n+  it(\"can decompress streaming\", async () => {\n+    const decoder = zlib.createZstdDecompress();\n+    for (const chunk of window(compressedBuffer, 10)) {\n+      decoder.push(chunk);\n+    }\n+    decoder.push(null);\n+    const buf = await new Response(decoder).bytes();\n+    expect(buf).toEqual(compressedBuffer);",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2141154879",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 20313,
        "pr_file": "test/js/node/zlib/zlib.test.js",
        "discussion_id": "2139376291",
        "commented_code": "@@ -469,3 +500,137 @@ for (const C of [zlib.BrotliCompress, zlib.BrotliDecompress]) {\n     });\n   }\n }\n+\n+describe(\"zlib.zstd\", () => {\n+  const inputString =\n+    \"立立Lorem ipsum dolor sit amet, consectetur adipiscing eli\" +\n+    \"t. Morbi faucibus, purus at gravida dictum, libero arcu \" +\n+    \"convallis lacus, in commodo libero metus eu nisi. Nullam\" +\n+    \" commodo, neque nec porta placerat, nisi est fermentum a\" +\n+    \"ugue, vitae gravida tellus sapien sit amet tellus. Aenea\" +\n+    \"n non diam orci. Proin quis elit turpis. Suspendisse non\" +\n+    \" diam ipsum. Suspendisse nec ullamcorper odio. Vestibulu\" +\n+    \"m arcu mi, sodales non suscipit id, ultrices ut massa. S\" +\n+    \"ed ac sem sit amet arcu malesuada fermentum. Nunc sed. \";\n+  const compressedString =\n+    \"KLUv/WD5AF0JAGbXPCCgJUkH/8+rqgA3KaVsW+6LfK3JLcnP+I/\" +\n+    \"Gy1/3Qv9XDTQAMwA0AK+Ch9LCub6tnT62C7QuwrHQHDhhNPcCQl\" +\n+    \"tMWOrafGy3KO2D79QZ95omy09vwp/TFEAkEIlHOO99cOlZmfRiz\" +\n+    \"XQ79GvDoY9TxrTgBBfR+77Nd7LkOWlHaGW+aEwd2rSeegWaj9Ns\" +\n+    \"WAJJ0253u1jQpe3ByWLS5i+24QhTAZygaf4UlqNER3XoAk7QYar\" +\n+    \"9tjHHV4yHj+tC108zuqMBJ+X2hlpwUqX6vE3r3N7q5QYntVvn3N\" +\n+    \"8zVDb9UfCMCW1790yV3A88pgvkvQAniSWvFxMAELvECFu0tC1R9\" +\n+    \"Ijsri5bt2kE/2mLoi2wCpkElnidDMS//DemxlNdHClyl6KeNTCugmAG\";\n+  const compressedBuffer = Buffer.from(compressedString, \"base64\");\n+\n+  it(\"zstdDecompress\", async () => {\n+    const roundtrip = await util.promisify(zlib.zstdDecompress)(compressedBuffer);\n+    expect(roundtrip.toString()).toEqual(inputString);\n+  });\n+\n+  it(\"zstdCompressSync\", () => {\n+    const compressed = zlib.zstdCompressSync(inputString);\n+    expect(compressed.toString(\"base64\")).toEqual(compressedString);\n+  });\n+\n+  it(\"zstdDecompressSync\", () => {\n+    const roundtrip = zlib.zstdDecompressSync(compressedBuffer);\n+    expect(roundtrip.toString()).toEqual(inputString);\n+  });\n+\n+  it(\"can compress streaming\", async () => {\n+    const encoder = zlib.createZstdCompress();\n+    for (const chunk of window(inputString, 55)) {\n+      encoder.push(chunk);\n+    }\n+    encoder.push(null);\n+    const buf = await new Response(encoder).text();\n+    expect(buf).toEqual(inputString);\n+  });\n+\n+  it(\"can decompress streaming\", async () => {\n+    const decoder = zlib.createZstdDecompress();\n+    for (const chunk of window(compressedBuffer, 10)) {\n+      decoder.push(chunk);\n+    }\n+    decoder.push(null);\n+    const buf = await new Response(decoder).bytes();\n+    expect(buf).toEqual(compressedBuffer);",
        "comment_created_at": "2025-06-11T21:34:45+00:00",
        "comment_author": "190n",
        "comment_body": "so the AI is wrong (we're actually testing the correct behavior here; this is how Node.js behaves too) but why is it that `new Response` on these compression or decompression streams returns the input instead of the output?",
        "pr_file_module": null
      }
    ]
  }
]