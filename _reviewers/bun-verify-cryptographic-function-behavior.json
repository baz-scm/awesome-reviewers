[
  {
    "discussion_id": "2092250197",
    "pr_number": 19674,
    "pr_file": "src/bun.js/bindings/webcrypto/CryptoAlgorithmX25519.cpp",
    "created_at": "2025-05-16T03:15:37+00:00",
    "commented_code": "+/*\n+ * Copyright (C) 2023 Igalia S.L.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2,1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public License\n+ * along with this library; see the file COPYING.LIB.  If not, write to\n+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ */\n+\n+#include \"config.h\"\n+#include \"CryptoAlgorithmX25519.h\"\n+\n+#if ENABLE(WEB_CRYPTO)\n+\n+#include \"CryptoAlgorithmX25519Params.h\"\n+#include \"CryptoKeyOKP.h\"\n+#include \"ScriptExecutionContext.h\"\n+#include \"CryptoDigest.h\"\n+#include <wtf/CryptographicUtilities.h>\n+\n+namespace WebCore {\n+\n+Ref<CryptoAlgorithm> CryptoAlgorithmX25519::create()\n+{\n+    return adoptRef(*new CryptoAlgorithmX25519);\n+}\n+\n+CryptoAlgorithmIdentifier CryptoAlgorithmX25519::identifier() const\n+{\n+    return s_identifier;\n+}\n+\n+void CryptoAlgorithmX25519::generateKey(const CryptoAlgorithmParameters&, bool extractable, CryptoKeyUsageBitmap usages, KeyOrKeyPairCallback&& callback, ExceptionCallback&& exceptionCallback, ScriptExecutionContext&)\n+{\n+    if (usages & (CryptoKeyUsageEncrypt | CryptoKeyUsageDecrypt | CryptoKeyUsageSign | CryptoKeyUsageVerify | CryptoKeyUsageWrapKey | CryptoKeyUsageUnwrapKey)) {\n+        exceptionCallback(ExceptionCode::SyntaxError, \"\"_s);\n+        return;\n+    }\n+\n+    auto result = CryptoKeyOKP::generatePair(CryptoAlgorithmIdentifier::X25519, CryptoKeyOKP::NamedCurve::X25519, extractable, usages);\n+    if (result.hasException()) {\n+        exceptionCallback(result.releaseException().code(), \"\"_s);\n+        return;\n+    }\n+\n+    auto pair = result.releaseReturnValue();\n+    pair.publicKey->setUsagesBitmap(0);\n+    pair.privateKey->setUsagesBitmap(pair.privateKey->usagesBitmap() & (CryptoKeyUsageDeriveKey | CryptoKeyUsageDeriveBits));\n+    callback(WTFMove(pair));\n+}\n+\n+#if !PLATFORM(COCOA) && !USE(GCRYPT)\n+std::optional<Vector<uint8_t>> CryptoAlgorithmX25519::platformDeriveBits(const CryptoKeyOKP&, const CryptoKeyOKP&)\n+{\n+    return std::nullopt;\n+}\n+#endif\n+\n+void CryptoAlgorithmX25519::deriveBits(const CryptoAlgorithmParameters& parameters, Ref<CryptoKey>&& baseKey, std::optional<size_t> length, VectorCallback&& callback, ExceptionCallback&& exceptionCallback, ScriptExecutionContext& context, WorkQueue& workQueue)\n+{\n+    if (baseKey->type() != CryptoKey::Type::Private) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    auto& ecParameters = downcast<CryptoAlgorithmX25519Params>(parameters);\n+    ASSERT(ecParameters.publicKey);\n+    if (ecParameters.publicKey->type() != CryptoKey::Type::Public) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    if (baseKey->algorithmIdentifier() != ecParameters.publicKey->algorithmIdentifier()) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    auto& ecBaseKey = downcast<CryptoKeyOKP>(baseKey.get());\n+    auto& ecPublicKey = downcast<CryptoKeyOKP>(*(ecParameters.publicKey.get()));\n+    if (ecBaseKey.namedCurve() != ecPublicKey.namedCurve()) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+\n+    // Return an empty string doesn't make much sense, but truncating either at all.\n+    // https://github.com/WICG/webcrypto-secure-curves/pull/29\n+    if (length && !(*length)) {\n+        // Avoid executing the key-derivation, since we are going to return an empty string.\n+        callback({ });\n+        return;\n+    }\n+\n+    auto unifiedCallback = [callback = WTFMove(callback), exceptionCallback = WTFMove(exceptionCallback)](std::optional<Vector<uint8_t>>&& derivedKey, std::optional<size_t> length) mutable {\n+        if (!derivedKey) {\n+            exceptionCallback(ExceptionCode::OperationError, \"\"_s);\n+            return;\n+        }\n+        if (!length) {\n+            callback(WTFMove(*derivedKey));\n+            return;\n+        }\n+#if !HAVE(X25519_ZERO_CHECKS)\n+        // https://datatracker.ietf.org/doc/html/rfc7748#section-6.1\n+        constexpr auto expectedOutputSize = 32;\n+        constexpr std::array<uint8_t, expectedOutputSize> zeros { };\n+        if (derivedKey->size() != expectedOutputSize || !constantTimeMemcmp(derivedKey->span(), zeros)) {",
    "repo_full_name": "oven-sh/bun",
    "discussion_comments": [
      {
        "comment_id": "2092250197",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19674,
        "pr_file": "src/bun.js/bindings/webcrypto/CryptoAlgorithmX25519.cpp",
        "discussion_id": "2092250197",
        "commented_code": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright (C) 2023 Igalia S.L.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2,1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public License\n+ * along with this library; see the file COPYING.LIB.  If not, write to\n+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ */\n+\n+#include \"config.h\"\n+#include \"CryptoAlgorithmX25519.h\"\n+\n+#if ENABLE(WEB_CRYPTO)\n+\n+#include \"CryptoAlgorithmX25519Params.h\"\n+#include \"CryptoKeyOKP.h\"\n+#include \"ScriptExecutionContext.h\"\n+#include \"CryptoDigest.h\"\n+#include <wtf/CryptographicUtilities.h>\n+\n+namespace WebCore {\n+\n+Ref<CryptoAlgorithm> CryptoAlgorithmX25519::create()\n+{\n+    return adoptRef(*new CryptoAlgorithmX25519);\n+}\n+\n+CryptoAlgorithmIdentifier CryptoAlgorithmX25519::identifier() const\n+{\n+    return s_identifier;\n+}\n+\n+void CryptoAlgorithmX25519::generateKey(const CryptoAlgorithmParameters&, bool extractable, CryptoKeyUsageBitmap usages, KeyOrKeyPairCallback&& callback, ExceptionCallback&& exceptionCallback, ScriptExecutionContext&)\n+{\n+    if (usages & (CryptoKeyUsageEncrypt | CryptoKeyUsageDecrypt | CryptoKeyUsageSign | CryptoKeyUsageVerify | CryptoKeyUsageWrapKey | CryptoKeyUsageUnwrapKey)) {\n+        exceptionCallback(ExceptionCode::SyntaxError, \"\"_s);\n+        return;\n+    }\n+\n+    auto result = CryptoKeyOKP::generatePair(CryptoAlgorithmIdentifier::X25519, CryptoKeyOKP::NamedCurve::X25519, extractable, usages);\n+    if (result.hasException()) {\n+        exceptionCallback(result.releaseException().code(), \"\"_s);\n+        return;\n+    }\n+\n+    auto pair = result.releaseReturnValue();\n+    pair.publicKey->setUsagesBitmap(0);\n+    pair.privateKey->setUsagesBitmap(pair.privateKey->usagesBitmap() & (CryptoKeyUsageDeriveKey | CryptoKeyUsageDeriveBits));\n+    callback(WTFMove(pair));\n+}\n+\n+#if !PLATFORM(COCOA) && !USE(GCRYPT)\n+std::optional<Vector<uint8_t>> CryptoAlgorithmX25519::platformDeriveBits(const CryptoKeyOKP&, const CryptoKeyOKP&)\n+{\n+    return std::nullopt;\n+}\n+#endif\n+\n+void CryptoAlgorithmX25519::deriveBits(const CryptoAlgorithmParameters& parameters, Ref<CryptoKey>&& baseKey, std::optional<size_t> length, VectorCallback&& callback, ExceptionCallback&& exceptionCallback, ScriptExecutionContext& context, WorkQueue& workQueue)\n+{\n+    if (baseKey->type() != CryptoKey::Type::Private) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    auto& ecParameters = downcast<CryptoAlgorithmX25519Params>(parameters);\n+    ASSERT(ecParameters.publicKey);\n+    if (ecParameters.publicKey->type() != CryptoKey::Type::Public) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    if (baseKey->algorithmIdentifier() != ecParameters.publicKey->algorithmIdentifier()) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    auto& ecBaseKey = downcast<CryptoKeyOKP>(baseKey.get());\n+    auto& ecPublicKey = downcast<CryptoKeyOKP>(*(ecParameters.publicKey.get()));\n+    if (ecBaseKey.namedCurve() != ecPublicKey.namedCurve()) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+\n+    // Return an empty string doesn't make much sense, but truncating either at all.\n+    // https://github.com/WICG/webcrypto-secure-curves/pull/29\n+    if (length && !(*length)) {\n+        // Avoid executing the key-derivation, since we are going to return an empty string.\n+        callback({ });\n+        return;\n+    }\n+\n+    auto unifiedCallback = [callback = WTFMove(callback), exceptionCallback = WTFMove(exceptionCallback)](std::optional<Vector<uint8_t>>&& derivedKey, std::optional<size_t> length) mutable {\n+        if (!derivedKey) {\n+            exceptionCallback(ExceptionCode::OperationError, \"\"_s);\n+            return;\n+        }\n+        if (!length) {\n+            callback(WTFMove(*derivedKey));\n+            return;\n+        }\n+#if !HAVE(X25519_ZERO_CHECKS)\n+        // https://datatracker.ietf.org/doc/html/rfc7748#section-6.1\n+        constexpr auto expectedOutputSize = 32;\n+        constexpr std::array<uint8_t, expectedOutputSize> zeros { };\n+        if (derivedKey->size() != expectedOutputSize || !constantTimeMemcmp(derivedKey->span(), zeros)) {",
        "comment_created_at": "2025-05-16T03:15:37+00:00",
        "comment_author": "graphite-app[bot]",
        "comment_body": "The zero check logic appears to be inverted. The function `constantTimeMemcmp` returns true when the memory regions are equal, so to check if the derived key is all zeros, the condition should be `constantTimeMemcmp(derivedKey->span(), zeros)` without the negation (`!`). The current implementation with `!constantTimeMemcmp(derivedKey->span(), zeros)` would actually check if the derived key is *not* all zeros, which is the opposite of the intended check described in the RFC comment above.\n```suggestion\n        if (derivedKey->size() != expectedOutputSize || constantTimeMemcmp(derivedKey->span(), zeros)) {\n```\n  \n\n*Spotted by [Diamond](https://app.graphite.dev/diamond/?org=oven-sh&ref=ai-review-comment)*<i class='graphite__hidden'><br /><br />Is this helpful? React \ud83d\udc4d or \ud83d\udc4e to let us know.</i>",
        "pr_file_module": null
      },
      {
        "comment_id": "2092257764",
        "repo_full_name": "oven-sh/bun",
        "pr_number": 19674,
        "pr_file": "src/bun.js/bindings/webcrypto/CryptoAlgorithmX25519.cpp",
        "discussion_id": "2092250197",
        "commented_code": "@@ -0,0 +1,250 @@\n+/*\n+ * Copyright (C) 2023 Igalia S.L.\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2,1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Library General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Library General Public License\n+ * along with this library; see the file COPYING.LIB.  If not, write to\n+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+ * Boston, MA 02110-1301, USA.\n+ */\n+\n+#include \"config.h\"\n+#include \"CryptoAlgorithmX25519.h\"\n+\n+#if ENABLE(WEB_CRYPTO)\n+\n+#include \"CryptoAlgorithmX25519Params.h\"\n+#include \"CryptoKeyOKP.h\"\n+#include \"ScriptExecutionContext.h\"\n+#include \"CryptoDigest.h\"\n+#include <wtf/CryptographicUtilities.h>\n+\n+namespace WebCore {\n+\n+Ref<CryptoAlgorithm> CryptoAlgorithmX25519::create()\n+{\n+    return adoptRef(*new CryptoAlgorithmX25519);\n+}\n+\n+CryptoAlgorithmIdentifier CryptoAlgorithmX25519::identifier() const\n+{\n+    return s_identifier;\n+}\n+\n+void CryptoAlgorithmX25519::generateKey(const CryptoAlgorithmParameters&, bool extractable, CryptoKeyUsageBitmap usages, KeyOrKeyPairCallback&& callback, ExceptionCallback&& exceptionCallback, ScriptExecutionContext&)\n+{\n+    if (usages & (CryptoKeyUsageEncrypt | CryptoKeyUsageDecrypt | CryptoKeyUsageSign | CryptoKeyUsageVerify | CryptoKeyUsageWrapKey | CryptoKeyUsageUnwrapKey)) {\n+        exceptionCallback(ExceptionCode::SyntaxError, \"\"_s);\n+        return;\n+    }\n+\n+    auto result = CryptoKeyOKP::generatePair(CryptoAlgorithmIdentifier::X25519, CryptoKeyOKP::NamedCurve::X25519, extractable, usages);\n+    if (result.hasException()) {\n+        exceptionCallback(result.releaseException().code(), \"\"_s);\n+        return;\n+    }\n+\n+    auto pair = result.releaseReturnValue();\n+    pair.publicKey->setUsagesBitmap(0);\n+    pair.privateKey->setUsagesBitmap(pair.privateKey->usagesBitmap() & (CryptoKeyUsageDeriveKey | CryptoKeyUsageDeriveBits));\n+    callback(WTFMove(pair));\n+}\n+\n+#if !PLATFORM(COCOA) && !USE(GCRYPT)\n+std::optional<Vector<uint8_t>> CryptoAlgorithmX25519::platformDeriveBits(const CryptoKeyOKP&, const CryptoKeyOKP&)\n+{\n+    return std::nullopt;\n+}\n+#endif\n+\n+void CryptoAlgorithmX25519::deriveBits(const CryptoAlgorithmParameters& parameters, Ref<CryptoKey>&& baseKey, std::optional<size_t> length, VectorCallback&& callback, ExceptionCallback&& exceptionCallback, ScriptExecutionContext& context, WorkQueue& workQueue)\n+{\n+    if (baseKey->type() != CryptoKey::Type::Private) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    auto& ecParameters = downcast<CryptoAlgorithmX25519Params>(parameters);\n+    ASSERT(ecParameters.publicKey);\n+    if (ecParameters.publicKey->type() != CryptoKey::Type::Public) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    if (baseKey->algorithmIdentifier() != ecParameters.publicKey->algorithmIdentifier()) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+    auto& ecBaseKey = downcast<CryptoKeyOKP>(baseKey.get());\n+    auto& ecPublicKey = downcast<CryptoKeyOKP>(*(ecParameters.publicKey.get()));\n+    if (ecBaseKey.namedCurve() != ecPublicKey.namedCurve()) {\n+        exceptionCallback(ExceptionCode::InvalidAccessError, \"\"_s);\n+        return;\n+    }\n+\n+    // Return an empty string doesn't make much sense, but truncating either at all.\n+    // https://github.com/WICG/webcrypto-secure-curves/pull/29\n+    if (length && !(*length)) {\n+        // Avoid executing the key-derivation, since we are going to return an empty string.\n+        callback({ });\n+        return;\n+    }\n+\n+    auto unifiedCallback = [callback = WTFMove(callback), exceptionCallback = WTFMove(exceptionCallback)](std::optional<Vector<uint8_t>>&& derivedKey, std::optional<size_t> length) mutable {\n+        if (!derivedKey) {\n+            exceptionCallback(ExceptionCode::OperationError, \"\"_s);\n+            return;\n+        }\n+        if (!length) {\n+            callback(WTFMove(*derivedKey));\n+            return;\n+        }\n+#if !HAVE(X25519_ZERO_CHECKS)\n+        // https://datatracker.ietf.org/doc/html/rfc7748#section-6.1\n+        constexpr auto expectedOutputSize = 32;\n+        constexpr std::array<uint8_t, expectedOutputSize> zeros { };\n+        if (derivedKey->size() != expectedOutputSize || !constantTimeMemcmp(derivedKey->span(), zeros)) {",
        "comment_created_at": "2025-05-16T03:27:32+00:00",
        "comment_author": "DevSDK",
        "comment_body": "Since [constantTimeMemcmp returns 0 if they are equal](https://github.com/WebKit/WebKit/blob/798647db3b710d3f5282bbc367a44bcc44200173/Source/WTF/wtf/CryptographicUtilities.h#L33), it is intended for   \r\n> Both MAY check, without leaking extra\r\n   information about the value of K, whether K is the all-zero value and\r\n   abort if so (see below).  Alice and Bob can then use a key-derivation\r\n   function that includes K, K_A, and K_B to derive a symmetric key.\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7748#section-6.1\r\n\r\nAnd also it is part of the upstream's.\r\n",
        "pr_file_module": null
      }
    ]
  }
]