[
  {
    "discussion_id": "2047444953",
    "pr_number": 19997,
    "pr_file": "packages/lib/payment/handlePayment.ts",
    "created_at": "2025-04-16T17:54:44+00:00",
    "commented_code": "const apps = eventTypeAppMetadataOptionalSchema.parse(selectedEventType?.metadata?.apps);\n   const paymentOption = apps?.[paymentAppCredentials.appId].paymentOption || \"ON_BOOKING\";\n+  const paymentCurrency = apps?.[paymentAppCredentials.appId].currency;\n+\n+  let totalAmount = apps?.[paymentAppCredentials.appId].price || 0;\n+\n+  if ((bookingFields || [])?.length > 0) {\n+    let addonsPrice = 0;\n+    (bookingFields || []).forEach((field) => {\n+      if (\n+        fieldTypesConfigMap[field.type]?.supportsPricing ||\n+        fieldTypesConfigMap[field.type]?.optionsSupportPricing\n+      ) {\n+        const typedInput = field as { price?: number; options?: { value: string; price?: number }[] };\n+        if (evt.responses?.[field.name]) {\n+          switch (field.type) {\n+            case \"number\":\n+              addonsPrice += Number(evt.responses[field.name]?.value || 0) * (typedInput.price || 0);\n+              break;\n+            case \"boolean\":\n+              if (evt.responses[field.name]?.value) {\n+                addonsPrice += typedInput.price || 0;\n+              }\n+              break;\n+            case \"select\":\n+            case \"radio\":\n+              // For select and radio, find the selected option and add its price\n+              const selectedValue = evt.responses[field.name]?.value;\n+              let selectedOption = typedInput.options?.find((opt) => opt.value === selectedValue);\n+              // For radio, the value coming is the label itself\n+              if (field.type === \"radio\") {\n+                selectedOption = typedInput.options?.find((opt) => {\n+                  const formattedValue = `${opt.value} (${Intl.NumberFormat(\"en\", {\n+                    style: \"currency\",\n+                    currency: paymentCurrency,\n+                  }).format(opt.price || 0)})`;\n+                  return formattedValue === selectedValue;\n+                });\n+              }\n+              addonsPrice += selectedOption?.price || 0;\n+              break;\n+            case \"checkbox\":\n+            case \"multiselect\":\n+              // For checkbox and multiselect, add prices of all selected options\n+              const response = evt.responses[field.name]?.value;\n+              const selectedValues = Array.isArray(response) ? response : response ? [response] : [];\n+              selectedValues.forEach((value) => {\n+                const option = typedInput.options?.find((opt) => opt.value === value);\n+                addonsPrice += option?.price || 0;\n+              });\n+              break;\n+          }\n+        }\n+      }\n+    });\n+\n+    totalAmount += convertToSmallestCurrencyUnit(addonsPrice, paymentCurrency);\n+  }",
    "repo_full_name": "calcom/cal.com",
    "discussion_comments": [
      {
        "comment_id": "2047444953",
        "repo_full_name": "calcom/cal.com",
        "pr_number": 19997,
        "pr_file": "packages/lib/payment/handlePayment.ts",
        "discussion_id": "2047444953",
        "commented_code": "@@ -66,25 +71,80 @@ const handlePayment = async ({\n \n   const apps = eventTypeAppMetadataOptionalSchema.parse(selectedEventType?.metadata?.apps);\n   const paymentOption = apps?.[paymentAppCredentials.appId].paymentOption || \"ON_BOOKING\";\n+  const paymentCurrency = apps?.[paymentAppCredentials.appId].currency;\n+\n+  let totalAmount = apps?.[paymentAppCredentials.appId].price || 0;\n+\n+  if ((bookingFields || [])?.length > 0) {\n+    let addonsPrice = 0;\n+    (bookingFields || []).forEach((field) => {\n+      if (\n+        fieldTypesConfigMap[field.type]?.supportsPricing ||\n+        fieldTypesConfigMap[field.type]?.optionsSupportPricing\n+      ) {\n+        const typedInput = field as { price?: number; options?: { value: string; price?: number }[] };\n+        if (evt.responses?.[field.name]) {\n+          switch (field.type) {\n+            case \"number\":\n+              addonsPrice += Number(evt.responses[field.name]?.value || 0) * (typedInput.price || 0);\n+              break;\n+            case \"boolean\":\n+              if (evt.responses[field.name]?.value) {\n+                addonsPrice += typedInput.price || 0;\n+              }\n+              break;\n+            case \"select\":\n+            case \"radio\":\n+              // For select and radio, find the selected option and add its price\n+              const selectedValue = evt.responses[field.name]?.value;\n+              let selectedOption = typedInput.options?.find((opt) => opt.value === selectedValue);\n+              // For radio, the value coming is the label itself\n+              if (field.type === \"radio\") {\n+                selectedOption = typedInput.options?.find((opt) => {\n+                  const formattedValue = `${opt.value} (${Intl.NumberFormat(\"en\", {\n+                    style: \"currency\",\n+                    currency: paymentCurrency,\n+                  }).format(opt.price || 0)})`;\n+                  return formattedValue === selectedValue;\n+                });\n+              }\n+              addonsPrice += selectedOption?.price || 0;\n+              break;\n+            case \"checkbox\":\n+            case \"multiselect\":\n+              // For checkbox and multiselect, add prices of all selected options\n+              const response = evt.responses[field.name]?.value;\n+              const selectedValues = Array.isArray(response) ? response : response ? [response] : [];\n+              selectedValues.forEach((value) => {\n+                const option = typedInput.options?.find((opt) => opt.value === value);\n+                addonsPrice += option?.price || 0;\n+              });\n+              break;\n+          }\n+        }\n+      }\n+    });\n+\n+    totalAmount += convertToSmallestCurrencyUnit(addonsPrice, paymentCurrency);\n+  }",
        "comment_created_at": "2025-04-16T17:54:44+00:00",
        "comment_author": "hbjORbj",
        "comment_body": "Not very readable. I asked AI to refactor this, and here's what I got. Can you use this code and test? If not working, feel free to tweak it\r\n```tsx\r\nif ((bookingFields || [])?.length > 0) {\r\n  let addonsPrice = 0;\r\n  \r\n  // Process each booking field\r\n  (bookingFields || []).forEach((field) => {\r\n    // Skip fields that don't support pricing\r\n    if (!fieldTypesConfigMap[field.type]?.supportsPricing && \r\n        !fieldTypesConfigMap[field.type]?.optionsSupportPricing) {\r\n      return;\r\n    }\r\n    \r\n    // Type assertion for price-related fields\r\n    const typedInput = field as { price?: number; options?: { value: string; price?: number }[] };\r\n    const response = evt.responses?.[field.name];\r\n    \r\n    // Skip if no response for this field\r\n    if (!response) return;\r\n    \r\n    switch (field.type) {\r\n      case \"number\":\r\n        // Multiply the numeric value by the field's price\r\n        addonsPrice += Number(response.value || 0) * (typedInput.price || 0);\r\n        break;\r\n        \r\n      case \"boolean\":\r\n        // Add price if boolean field is true\r\n        if (response.value) {\r\n          addonsPrice += typedInput.price || 0;\r\n        }\r\n        break;\r\n        \r\n      case \"select\":\r\n      case \"radio\":\r\n        // For select and radio, find the selected option and add its price\r\n        const selectedValue = response.value;\r\n        let selectedOption;\r\n        \r\n        if (field.type === \"radio\") {\r\n          // For radio, the value coming is the label itself\r\n          selectedOption = typedInput.options?.find((opt) => {\r\n            const formattedValue = `${opt.value} (${Intl.NumberFormat(\"en\", {\r\n              style: \"currency\",\r\n              currency: paymentCurrency,\r\n            }).format(opt.price || 0)})`;\r\n            return formattedValue === selectedValue;\r\n          });\r\n        } else {\r\n          // For select, match by direct value\r\n          selectedOption = typedInput.options?.find((opt) => opt.value === selectedValue);\r\n        }\r\n        \r\n        addonsPrice += selectedOption?.price || 0;\r\n        break;\r\n        \r\n      case \"checkbox\":\r\n      case \"multiselect\":\r\n        // For checkbox and multiselect, add prices of all selected options\r\n        const responseValue = response.value;\r\n        const selectedValues = Array.isArray(responseValue) \r\n          ? responseValue \r\n          : responseValue \r\n            ? [responseValue] \r\n            : [];\r\n            \r\n        selectedValues.forEach((value) => {\r\n          const option = typedInput.options?.find((opt) => opt.value === value);\r\n          addonsPrice += option?.price || 0;\r\n        });\r\n        break;\r\n    }\r\n  });\r\n\r\n  totalAmount += convertToSmallestCurrencyUnit(addonsPrice, paymentCurrency);\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2049269702",
        "repo_full_name": "calcom/cal.com",
        "pr_number": 19997,
        "pr_file": "packages/lib/payment/handlePayment.ts",
        "discussion_id": "2047444953",
        "commented_code": "@@ -66,25 +71,80 @@ const handlePayment = async ({\n \n   const apps = eventTypeAppMetadataOptionalSchema.parse(selectedEventType?.metadata?.apps);\n   const paymentOption = apps?.[paymentAppCredentials.appId].paymentOption || \"ON_BOOKING\";\n+  const paymentCurrency = apps?.[paymentAppCredentials.appId].currency;\n+\n+  let totalAmount = apps?.[paymentAppCredentials.appId].price || 0;\n+\n+  if ((bookingFields || [])?.length > 0) {\n+    let addonsPrice = 0;\n+    (bookingFields || []).forEach((field) => {\n+      if (\n+        fieldTypesConfigMap[field.type]?.supportsPricing ||\n+        fieldTypesConfigMap[field.type]?.optionsSupportPricing\n+      ) {\n+        const typedInput = field as { price?: number; options?: { value: string; price?: number }[] };\n+        if (evt.responses?.[field.name]) {\n+          switch (field.type) {\n+            case \"number\":\n+              addonsPrice += Number(evt.responses[field.name]?.value || 0) * (typedInput.price || 0);\n+              break;\n+            case \"boolean\":\n+              if (evt.responses[field.name]?.value) {\n+                addonsPrice += typedInput.price || 0;\n+              }\n+              break;\n+            case \"select\":\n+            case \"radio\":\n+              // For select and radio, find the selected option and add its price\n+              const selectedValue = evt.responses[field.name]?.value;\n+              let selectedOption = typedInput.options?.find((opt) => opt.value === selectedValue);\n+              // For radio, the value coming is the label itself\n+              if (field.type === \"radio\") {\n+                selectedOption = typedInput.options?.find((opt) => {\n+                  const formattedValue = `${opt.value} (${Intl.NumberFormat(\"en\", {\n+                    style: \"currency\",\n+                    currency: paymentCurrency,\n+                  }).format(opt.price || 0)})`;\n+                  return formattedValue === selectedValue;\n+                });\n+              }\n+              addonsPrice += selectedOption?.price || 0;\n+              break;\n+            case \"checkbox\":\n+            case \"multiselect\":\n+              // For checkbox and multiselect, add prices of all selected options\n+              const response = evt.responses[field.name]?.value;\n+              const selectedValues = Array.isArray(response) ? response : response ? [response] : [];\n+              selectedValues.forEach((value) => {\n+                const option = typedInput.options?.find((opt) => opt.value === value);\n+                addonsPrice += option?.price || 0;\n+              });\n+              break;\n+          }\n+        }\n+      }\n+    });\n+\n+    totalAmount += convertToSmallestCurrencyUnit(addonsPrice, paymentCurrency);\n+  }",
        "comment_created_at": "2025-04-17T16:11:23+00:00",
        "comment_author": "asadath1395",
        "comment_body": "I used the above code and its look and works good",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1757225812",
    "pr_number": 16579,
    "pr_file": "packages/lib/slots.ts",
    "created_at": "2024-09-12T16:39:44+00:00",
    "commented_code": "? range.start\n       : startTimeWithMinNotice;\n \n-    slotStartTime =\n-      slotStartTime.minute() % interval !== 0\n-        ? slotStartTime.startOf(\"hour\").add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n-        : slotStartTime;\n-\n     // Adding 1 minute to date ranges that end at midnight to ensure that the last slot is included\n     const rangeEnd = range.end\n       .add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\")\n       .isSame(range.end.endOf(\"day\").add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\"), \"minute\")\n       ? range.end.add(1, \"minute\")\n       : range.end;\n \n+    slotStartTime =\n+      slotStartTime.minute() % interval !== 0\n+        ? showOptimizedSlots\n+          ? rangeEnd.diff(slotStartTime, \"minutes\") % interval > interval - slotStartTime.minute()\n+            ? slotStartTime.add(interval - slotStartTime.minute(), \"minute\")\n+            : slotStartTime.add(rangeEnd.diff(slotStartTime, \"minutes\") % interval, \"minute\")\n+          : slotStartTime\n+              .startOf(\"hour\")\n+              .add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n+        : slotStartTime;\n+",
    "repo_full_name": "calcom/cal.com",
    "discussion_comments": [
      {
        "comment_id": "1757225812",
        "repo_full_name": "calcom/cal.com",
        "pr_number": 16579,
        "pr_file": "packages/lib/slots.ts",
        "discussion_id": "1757225812",
        "commented_code": "@@ -192,18 +195,24 @@ function buildSlotsWithDateRanges({\n       ? range.start\n       : startTimeWithMinNotice;\n \n-    slotStartTime =\n-      slotStartTime.minute() % interval !== 0\n-        ? slotStartTime.startOf(\"hour\").add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n-        : slotStartTime;\n-\n     // Adding 1 minute to date ranges that end at midnight to ensure that the last slot is included\n     const rangeEnd = range.end\n       .add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\")\n       .isSame(range.end.endOf(\"day\").add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\"), \"minute\")\n       ? range.end.add(1, \"minute\")\n       : range.end;\n \n+    slotStartTime =\n+      slotStartTime.minute() % interval !== 0\n+        ? showOptimizedSlots\n+          ? rangeEnd.diff(slotStartTime, \"minutes\") % interval > interval - slotStartTime.minute()\n+            ? slotStartTime.add(interval - slotStartTime.minute(), \"minute\")\n+            : slotStartTime.add(rangeEnd.diff(slotStartTime, \"minutes\") % interval, \"minute\")\n+          : slotStartTime\n+              .startOf(\"hour\")\n+              .add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n+        : slotStartTime;\n+",
        "comment_created_at": "2024-09-12T16:39:44+00:00",
        "comment_author": "Amit91848",
        "comment_body": "Avoid ternaries within ternaries, it not very readable and can quickly become a nightmare to debug. Can you please refactor this bit?",
        "pr_file_module": null
      },
      {
        "comment_id": "1757321984",
        "repo_full_name": "calcom/cal.com",
        "pr_number": 16579,
        "pr_file": "packages/lib/slots.ts",
        "discussion_id": "1757225812",
        "commented_code": "@@ -192,18 +195,24 @@ function buildSlotsWithDateRanges({\n       ? range.start\n       : startTimeWithMinNotice;\n \n-    slotStartTime =\n-      slotStartTime.minute() % interval !== 0\n-        ? slotStartTime.startOf(\"hour\").add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n-        : slotStartTime;\n-\n     // Adding 1 minute to date ranges that end at midnight to ensure that the last slot is included\n     const rangeEnd = range.end\n       .add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\")\n       .isSame(range.end.endOf(\"day\").add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\"), \"minute\")\n       ? range.end.add(1, \"minute\")\n       : range.end;\n \n+    slotStartTime =\n+      slotStartTime.minute() % interval !== 0\n+        ? showOptimizedSlots\n+          ? rangeEnd.diff(slotStartTime, \"minutes\") % interval > interval - slotStartTime.minute()\n+            ? slotStartTime.add(interval - slotStartTime.minute(), \"minute\")\n+            : slotStartTime.add(rangeEnd.diff(slotStartTime, \"minutes\") % interval, \"minute\")\n+          : slotStartTime\n+              .startOf(\"hour\")\n+              .add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n+        : slotStartTime;\n+",
        "comment_created_at": "2024-09-12T17:49:59+00:00",
        "comment_author": "vijayraghav-io",
        "comment_body": "sure will do",
        "pr_file_module": null
      },
      {
        "comment_id": "1758347064",
        "repo_full_name": "calcom/cal.com",
        "pr_number": 16579,
        "pr_file": "packages/lib/slots.ts",
        "discussion_id": "1757225812",
        "commented_code": "@@ -192,18 +195,24 @@ function buildSlotsWithDateRanges({\n       ? range.start\n       : startTimeWithMinNotice;\n \n-    slotStartTime =\n-      slotStartTime.minute() % interval !== 0\n-        ? slotStartTime.startOf(\"hour\").add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n-        : slotStartTime;\n-\n     // Adding 1 minute to date ranges that end at midnight to ensure that the last slot is included\n     const rangeEnd = range.end\n       .add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\")\n       .isSame(range.end.endOf(\"day\").add(dayjs().tz(organizerTimeZone).utcOffset(), \"minutes\"), \"minute\")\n       ? range.end.add(1, \"minute\")\n       : range.end;\n \n+    slotStartTime =\n+      slotStartTime.minute() % interval !== 0\n+        ? showOptimizedSlots\n+          ? rangeEnd.diff(slotStartTime, \"minutes\") % interval > interval - slotStartTime.minute()\n+            ? slotStartTime.add(interval - slotStartTime.minute(), \"minute\")\n+            : slotStartTime.add(rangeEnd.diff(slotStartTime, \"minutes\") % interval, \"minute\")\n+          : slotStartTime\n+              .startOf(\"hour\")\n+              .add(Math.ceil(slotStartTime.minute() / interval) * interval, \"minute\")\n+        : slotStartTime;\n+",
        "comment_created_at": "2024-09-13T07:39:19+00:00",
        "comment_author": "vijayraghav-io",
        "comment_body": "@Amit91848 , have refactored and added comments, can you please see if it's ok now. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1950602137",
    "pr_number": 19231,
    "pr_file": "packages/lib/slots.ts",
    "created_at": "2025-02-11T10:34:33+00:00",
    "commented_code": "* @calcom/web:dev: 2022-11-06T03:00:00-04:00\n      * ...\n      */\n-    slots.push({\n-      userIds: item.userIds,\n-      time: getTime(item.startTime),\n-    });\n+    const timeNum = parseInt(time);\n+    const slotTime = getTime(timeNum);\n+    // Skip slots that are before the day's start or after its end\n+    if (timeNum < dayStart) continue;\n+\n+    let slotData: {\n+      time: Dayjs;\n+      userIds?: number[];\n+      away?: boolean;\n+      fromUser?: IFromUser;\n+      toUser?: IToUser;\n+      reason?: string;\n+      emoji?: string;\n+      busy?: boolean;\n+    } = {\n+      userIds: isAvailable ? isAvailable.userIds : undefined,\n+      time: slotTime,\n+      busy: !isAvailable, // Mark non-available slots as busy\n+    };\n+\n+    // Always add OOO data if it exists, regardless of availabilityy\n+    if (dateOutOfOfficeExists) {\n+      const { toUser, fromUser, reason, emoji } = dateOutOfOfficeExists;\n+      slotData = {\n+        ...slotData,\n+        away: true,\n+        ...(fromUser && { fromUser }),\n+        ...(toUser && { toUser }),\n+        ...(reason && { reason }),\n+        ...(emoji && { emoji }),\n+      };\n+    }\n+\n+    slots.push(slotData);",
    "repo_full_name": "calcom/cal.com",
    "discussion_comments": [
      {
        "comment_id": "1950602137",
        "repo_full_name": "calcom/cal.com",
        "pr_number": 19231,
        "pr_file": "packages/lib/slots.ts",
        "discussion_id": "1950602137",
        "commented_code": "@@ -132,10 +191,40 @@ function buildSlots({\n      * @calcom/web:dev: 2022-11-06T03:00:00-04:00\n      * ...\n      */\n-    slots.push({\n-      userIds: item.userIds,\n-      time: getTime(item.startTime),\n-    });\n+    const timeNum = parseInt(time);\n+    const slotTime = getTime(timeNum);\n+    // Skip slots that are before the day's start or after its end\n+    if (timeNum < dayStart) continue;\n+\n+    let slotData: {\n+      time: Dayjs;\n+      userIds?: number[];\n+      away?: boolean;\n+      fromUser?: IFromUser;\n+      toUser?: IToUser;\n+      reason?: string;\n+      emoji?: string;\n+      busy?: boolean;\n+    } = {\n+      userIds: isAvailable ? isAvailable.userIds : undefined,\n+      time: slotTime,\n+      busy: !isAvailable, // Mark non-available slots as busy\n+    };\n+\n+    // Always add OOO data if it exists, regardless of availabilityy\n+    if (dateOutOfOfficeExists) {\n+      const { toUser, fromUser, reason, emoji } = dateOutOfOfficeExists;\n+      slotData = {\n+        ...slotData,\n+        away: true,\n+        ...(fromUser && { fromUser }),\n+        ...(toUser && { toUser }),\n+        ...(reason && { reason }),\n+        ...(emoji && { emoji }),\n+      };\n+    }\n+\n+    slots.push(slotData);",
        "comment_created_at": "2025-02-11T10:34:33+00:00",
        "comment_author": "hbjORbj",
        "comment_body": "- this can be refactored into much fewer lines of code\r\n- `const { toUser, fromUser, reason, emoji } = dateOutOfOfficeExists;` I see this in multiple places. you can either destructure `dateOutOfOfficeExists` at the top once or do `dateOutOfOfficeExists?.fromUser`, etc.\r\n",
        "pr_file_module": null
      }
    ]
  }
]