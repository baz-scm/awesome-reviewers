[
  {
    "discussion_id": "1694205056",
    "pr_number": 6502,
    "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
    "created_at": "2024-07-28T09:23:55+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if \"siteConfig\" in conf[\"properties\"] and conf[\"properties\"][\"siteConfig\"] is not None:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1694205056",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6502,
        "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
        "discussion_id": "1694205056",
        "commented_code": "@@ -0,0 +1,34 @@\n+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if \"siteConfig\" in conf[\"properties\"] and conf[\"properties\"][\"siteConfig\"] is not None:",
        "comment_created_at": "2024-07-28T09:23:55+00:00",
        "comment_author": "SteveVaknin",
        "comment_body": "consider working with `get` instead, it is less complex and more readable. If the key doesn't exists it will return `None`. \r\n\r\n```suggestion\r\n            if conf.get(\"properties\").get(\"siteConfig\") is not None:\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1694617802",
    "pr_number": 6502,
    "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
    "created_at": "2024-07-29T06:04:47+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if conf.get(\"properties\").get(\"siteConfig\") is not None:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1694617802",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6502,
        "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
        "discussion_id": "1694617802",
        "commented_code": "@@ -0,0 +1,34 @@\n+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if conf.get(\"properties\").get(\"siteConfig\") is not None:",
        "comment_created_at": "2024-07-29T06:04:47+00:00",
        "comment_author": "ChanochShayner",
        "comment_body": "```suggestion\r\n            if conf.get(\"properties\", {}).get(\"siteConfig\") is not None:\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1438871227",
    "pr_number": 5861,
    "pr_file": "checkov/terraform/checks/resource/ibm/IBMVirtualServersForVPCInstanceIPSpoofingDisabled.py",
    "created_at": "2023-12-31T11:53:12+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+from typing import Any\n+\n+from checkov.common.util.type_forcers import force_list\n+\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class IBMVirtualServersForVPCInstanceIPSpoofingDisabled(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that Virtual Servers for VPC instance has interface with IP-spoofing disabled\"\n+        id = \"CKV2_IBM_8\"\n+        supported_resources = [\"ibm_is_instance\"]\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: dict[str, list[Any]]) -> CheckResult:\n+\n+        primary_network_interfaces = force_list(conf.get('primary_network_interface', []))\n+        network_interfaces = force_list(conf.get('network_interfaces', []))\n+\n+        allow_ip_spoofing_found = False\n+\n+        # Check 'allow_ip_spoofing' in primary_network_interface\n+        for prim_nic_bloc in primary_network_interfaces:\n+            if prim_nic_bloc.get('allow_ip_spoofing', [False])[0]:\n+                allow_ip_spoofing_found = True\n+\n+        # If 'allow_ip_spoofing' not found in primary_network_interface, check in network_interfaces\n+        if not allow_ip_spoofing_found:\n+            for nic_bloc in network_interfaces:\n+                if nic_bloc.get('allow_ip_spoofing', [False])[0]:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1438871227",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5861,
        "pr_file": "checkov/terraform/checks/resource/ibm/IBMVirtualServersForVPCInstanceIPSpoofingDisabled.py",
        "discussion_id": "1438871227",
        "commented_code": "@@ -0,0 +1,42 @@\n+from __future__ import annotations\n+\n+from typing import Any\n+\n+from checkov.common.util.type_forcers import force_list\n+\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class IBMVirtualServersForVPCInstanceIPSpoofingDisabled(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that Virtual Servers for VPC instance has interface with IP-spoofing disabled\"\n+        id = \"CKV2_IBM_8\"\n+        supported_resources = [\"ibm_is_instance\"]\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: dict[str, list[Any]]) -> CheckResult:\n+\n+        primary_network_interfaces = force_list(conf.get('primary_network_interface', []))\n+        network_interfaces = force_list(conf.get('network_interfaces', []))\n+\n+        allow_ip_spoofing_found = False\n+\n+        # Check 'allow_ip_spoofing' in primary_network_interface\n+        for prim_nic_bloc in primary_network_interfaces:\n+            if prim_nic_bloc.get('allow_ip_spoofing', [False])[0]:\n+                allow_ip_spoofing_found = True\n+\n+        # If 'allow_ip_spoofing' not found in primary_network_interface, check in network_interfaces\n+        if not allow_ip_spoofing_found:\n+            for nic_bloc in network_interfaces:\n+                if nic_bloc.get('allow_ip_spoofing', [False])[0]:",
        "comment_created_at": "2023-12-31T11:53:12+00:00",
        "comment_author": "marynaKK",
        "comment_body": "```suggestion\r\n                if isinstance(nic_bloc, dict) and nic_bloc.get('allow_ip_spoofing', [False])[0]:\r\n```\r\n\r\nalso notice that nic_block can be a `None`, or not a list with at least 1 element. would do it in 2 parts, validating each time we have the right type and enough elements.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1438869386",
    "pr_number": 5905,
    "pr_file": "checkov/terraform/checks/resource/aws/DLMEventsCrossRegionEncryption.py",
    "created_at": "2023-12-31T11:38:23+00:00",
    "commented_code": "if policy.get(\"action\") and isinstance(policy.get(\"action\"), list):\n                 actions = policy.get(\"action\")\n                 for idx, action in enumerate(actions):\n-                    if action.get(\"cross_region_copy\") and isinstance(action.get(\"cross_region_copy\"), list):\n+                    if action != [] and action.get(\"cross_region_copy\") and isinstance(action.get(\"cross_region_copy\"), list):",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1438869386",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5905,
        "pr_file": "checkov/terraform/checks/resource/aws/DLMEventsCrossRegionEncryption.py",
        "discussion_id": "1438869386",
        "commented_code": "@@ -16,7 +16,7 @@ def scan_resource_conf(self, conf):\n             if policy.get(\"action\") and isinstance(policy.get(\"action\"), list):\n                 actions = policy.get(\"action\")\n                 for idx, action in enumerate(actions):\n-                    if action.get(\"cross_region_copy\") and isinstance(action.get(\"cross_region_copy\"), list):\n+                    if action != [] and action.get(\"cross_region_copy\") and isinstance(action.get(\"cross_region_copy\"), list):",
        "comment_created_at": "2023-12-31T11:38:23+00:00",
        "comment_author": "marynaKK",
        "comment_body": "better to check precisely it is a dictionary first?\r\n```py\r\n if policy.get(\"action\") and isinstance(policy.get(\"action\"), list):\r\n    actions = policy.get(\"action\")    \r\n    for idx, action in enumerate(actions):\r\n        if not isinstance(action, dict) or not action:\r\n            continue\r\n    ....\r\n      \r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1440314102",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5905,
        "pr_file": "checkov/terraform/checks/resource/aws/DLMEventsCrossRegionEncryption.py",
        "discussion_id": "1438869386",
        "commented_code": "@@ -16,7 +16,7 @@ def scan_resource_conf(self, conf):\n             if policy.get(\"action\") and isinstance(policy.get(\"action\"), list):\n                 actions = policy.get(\"action\")\n                 for idx, action in enumerate(actions):\n-                    if action.get(\"cross_region_copy\") and isinstance(action.get(\"cross_region_copy\"), list):\n+                    if action != [] and action.get(\"cross_region_copy\") and isinstance(action.get(\"cross_region_copy\"), list):",
        "comment_created_at": "2024-01-03T10:49:53+00:00",
        "comment_author": "tsmithv11",
        "comment_body": "Updated. Please take a look",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1114993880",
    "pr_number": 4375,
    "pr_file": "checkov/cloudformation/checks/resource/aws/LambdaServicePermission.py",
    "created_at": "2023-02-22T21:40:51+00:00",
    "commented_code": "+from typing import List\n+\n+from checkov.cloudformation.checks.resource.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that AWS Lambda function permissions delegated to AWS services are limited by SourceArn or SourceAccount\"\n+        id = \"CKV_AWS_293\"\n+        supported_resources = [\"AWS::Lambda::Permission\"]\n+        categories = [CheckCategories.GENERAL_SECURITY, ]\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        properties = conf.get('Properties')\n+        if properties is not None:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1114993880",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 4375,
        "pr_file": "checkov/cloudformation/checks/resource/aws/LambdaServicePermission.py",
        "discussion_id": "1114993880",
        "commented_code": "@@ -0,0 +1,35 @@\n+from typing import List\n+\n+from checkov.cloudformation.checks.resource.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that AWS Lambda function permissions delegated to AWS services are limited by SourceArn or SourceAccount\"\n+        id = \"CKV_AWS_293\"\n+        supported_resources = [\"AWS::Lambda::Permission\"]\n+        categories = [CheckCategories.GENERAL_SECURITY, ]\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        properties = conf.get('Properties')\n+        if properties is not None:",
        "comment_created_at": "2023-02-22T21:40:51+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n        if properties and isinstance(properties, dict):\r\n```\r\nlet's make sure, ew deal with a dictionary otherwise we will have a problem.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1115000149",
    "pr_number": 4375,
    "pr_file": "checkov/terraform/checks/resource/aws/LambdaServicePermission.py",
    "created_at": "2023-02-22T21:48:27+00:00",
    "commented_code": "+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self):\n+        # This is the full description of your check\n+        description = \"Ensure that when a Lambda Function Permission is delegated to a service as principal, that the permission is scoped to either a SourceArn or a SourceAccount.\"\n+\n+        # This is the Unique ID for your check\n+        id = \"CKV_AWS_293\"\n+\n+        # These are the terraform objects supported by this check (ex: aws_iam_policy_document)\n+        supported_resources = ['aws_lambda_permission']\n+\n+        # Valid CheckCategories are defined in checkov/common/models/enums.py\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=description, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        # Replace this with the custom logic for your check\n+        principal = conf.get(\"principal\", [])\n+        self.evaluated_keys = [\"principal\"]\n+        principal_parts = principal[0].split('.')",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1115000149",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 4375,
        "pr_file": "checkov/terraform/checks/resource/aws/LambdaServicePermission.py",
        "discussion_id": "1115000149",
        "commented_code": "@@ -0,0 +1,38 @@\n+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self):\n+        # This is the full description of your check\n+        description = \"Ensure that when a Lambda Function Permission is delegated to a service as principal, that the permission is scoped to either a SourceArn or a SourceAccount.\"\n+\n+        # This is the Unique ID for your check\n+        id = \"CKV_AWS_293\"\n+\n+        # These are the terraform objects supported by this check (ex: aws_iam_policy_document)\n+        supported_resources = ['aws_lambda_permission']\n+\n+        # Valid CheckCategories are defined in checkov/common/models/enums.py\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=description, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        # Replace this with the custom logic for your check\n+        principal = conf.get(\"principal\", [])\n+        self.evaluated_keys = [\"principal\"]\n+        principal_parts = principal[0].split('.')",
        "comment_created_at": "2023-02-22T21:48:27+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n        principal = conf.get(\"principal\")\r\n        if principal and isintsance(principal, list) and isinstance(principal[0], str):\r\n            principal_parts = principal[0].split('.')\r\n```\r\nthis is a bit tricky, we need to be a bit more cautious on the types. Quite often Terraform plan files come with unexpected default values and break our checks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1253041087",
    "pr_number": 5285,
    "pr_file": "checkov/common/sca/output.py",
    "created_at": "2023-07-05T12:33:14+00:00",
    "commented_code": "return licenses_per_package_map\n \n \n+def get_inline_suppressions_map(inline_suppressions: _ScaSuppressions | None = None) -> _ScaSuppressionsMaps | None:\n+    if not inline_suppressions:\n+        return None\n+    suppressions_map: _ScaSuppressionsMaps = {}\n+\n+    # fill cves suppressions map\n+    cve_by_cve_map: dict[str, _SuppressedCves] = {}\n+    if inline_suppressions.get(\"cves\"):\n+        if inline_suppressions[\"cves\"].get(\"byCve\"):\n+            for cve_suppression in inline_suppressions[\"cves\"][\"byCve\"]:\n+                if cve_suppression.get(\"cveId\"):\n+                    cve_by_cve_map[cve_suppression[\"cveId\"]] = cve_suppression",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1253041087",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5285,
        "pr_file": "checkov/common/sca/output.py",
        "discussion_id": "1253041087",
        "commented_code": "@@ -266,6 +276,35 @@ def _add_to_report_licenses_statuses(\n     return licenses_per_package_map\n \n \n+def get_inline_suppressions_map(inline_suppressions: _ScaSuppressions | None = None) -> _ScaSuppressionsMaps | None:\n+    if not inline_suppressions:\n+        return None\n+    suppressions_map: _ScaSuppressionsMaps = {}\n+\n+    # fill cves suppressions map\n+    cve_by_cve_map: dict[str, _SuppressedCves] = {}\n+    if inline_suppressions.get(\"cves\"):\n+        if inline_suppressions[\"cves\"].get(\"byCve\"):\n+            for cve_suppression in inline_suppressions[\"cves\"][\"byCve\"]:\n+                if cve_suppression.get(\"cveId\"):\n+                    cve_by_cve_map[cve_suppression[\"cveId\"]] = cve_suppression",
        "comment_created_at": "2023-07-05T12:33:14+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n    inline_suppressions_by_cve = inline_suppressions.get(\"cves\", {}).get(\"byCve\", {})\r\n    for cve_suppression in inline_suppressions_by_cve:\r\n        cve_id = cve_suppression.get(\"cveId\")\r\n        if cve_id:\r\n            cve_by_cve_map[cve_id] = cve_suppression\r\n```\r\n\ud83d\ude42 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1215615816",
    "pr_number": 5112,
    "pr_file": "checkov/terraform/plan_parser.py",
    "created_at": "2023-06-03T15:42:38+00:00",
    "commented_code": "\"\"\"Returns a resource address to resource changes dict\"\"\"\n \n     resource_changes_map = {}\n-\n     resource_changes = template.get(\"resource_changes\")\n-    if resource_changes and isinstance(resource_changes, list):\n-        resource_changes_map = {\n-            change.get(\"address\", \"\"): change\n-            for change in resource_changes\n-        }\n \n+    if resource_changes and isinstance(resource_changes, list):\n+        for each in resource_changes:\n+            resource_changes_map[each[\"address\"]] = each\n+            changes = []\n+\n+            # before + after are None when resources are created/destroyed, so make them safe\n+            if not each[\"change\"][\"before\"]:\n+                each[\"change\"][\"before\"] = {}\n+            if not each[\"change\"][\"after\"]:\n+                each[\"change\"][\"after\"] = {}",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1215615816",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5112,
        "pr_file": "checkov/terraform/plan_parser.py",
        "discussion_id": "1215615816",
        "commented_code": "@@ -238,14 +239,24 @@ def _get_resource_changes(template: dict[str, Any]) -> dict[str, dict[str, Any]]\n     \"\"\"Returns a resource address to resource changes dict\"\"\"\n \n     resource_changes_map = {}\n-\n     resource_changes = template.get(\"resource_changes\")\n-    if resource_changes and isinstance(resource_changes, list):\n-        resource_changes_map = {\n-            change.get(\"address\", \"\"): change\n-            for change in resource_changes\n-        }\n \n+    if resource_changes and isinstance(resource_changes, list):\n+        for each in resource_changes:\n+            resource_changes_map[each[\"address\"]] = each\n+            changes = []\n+\n+            # before + after are None when resources are created/destroyed, so make them safe\n+            if not each[\"change\"][\"before\"]:\n+                each[\"change\"][\"before\"] = {}\n+            if not each[\"change\"][\"after\"]:\n+                each[\"change\"][\"after\"] = {}",
        "comment_created_at": "2023-06-03T15:42:38+00:00",
        "comment_author": "gruebel",
        "comment_body": "`not` also works, but if it is an empty `dict` then there is no need to override it again\r\n```suggestion\r\n            if each[\"change\"][\"before\"] is None:\r\n                each[\"change\"][\"before\"] = {}\r\n            if each[\"change\"][\"after\"] is None:\r\n                each[\"change\"][\"after\"] = {}\r\n```",
        "pr_file_module": null
      }
    ]
  }
]