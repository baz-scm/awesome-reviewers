[
  {
    "discussion_id": "1921863862",
    "pr_number": 6960,
    "pr_file": "checkov/terraform/checks/data/aws/GithubActionsOIDCTrustPolicy.py",
    "created_at": "2025-01-20T06:37:39+00:00",
    "commented_code": "from checkov.common.util.type_forcers import force_list\n from checkov.terraform.checks.data.base_check import BaseDataCheck\n \n-gh_repo_regex = re.compile(r'repo:[^/]+/[^/]+')\n+gh_repo_regex = re.compile(r\"[\\w]+/.+\")\n+gh_abusable_claims = [\"workflow\", \"environment\", \"ref\", \"context\", \"head_ref\", \"base_ref\"]\n \n \n class GithubActionsOIDCTrustPolicy(BaseDataCheck):\n     def __init__(self):\n-        name = 'Ensure GitHub Actions OIDC trust policies only allows actions from a specific known organization'\n+        name = \"Ensure GitHub Actions OIDC authorization policies only allows safe claims and claim order\"\n         id = \"CKV_AWS_358\"\n         supported_data = (\"aws_iam_policy_document\",)\n         categories = [CheckCategories.IAM]\n         super().__init__(name=name, id=id, categories=categories, supported_data=supported_data)\n \n     def scan_data_conf(self, conf: Dict[str, List[Any]]) -> CheckResult:\n-        statements = force_list(conf.get('statement'))\n+        statements = force_list(conf.get(\"statement\"))\n         for statement in statements:\n             found_federated_gh_oidc = False\n             if isinstance(statement, dict):\n-                if statement.get('principals'):\n-                    principals = statement['principals']\n+                if statement.get(\"principals\"):\n+                    principals = statement[\"principals\"]\n                     for principal in force_list(principals):\n-                        if 'type' not in principal and 'identifiers' not in principal:\n+                        if \"type\" not in principal and \"identifiers\" not in principal:\n                             continue\n-                        principal_type = principal['type']\n-                        principal_identifiers = principal['identifiers']\n-                        if isinstance(principal_type, list) and len(\n-                                principal_type) and 'Federated' in principal_type and isinstance(principal_identifiers,\n-                                                                                                 list):\n+                        principal_type = principal[\"type\"]\n+                        principal_identifiers = principal[\"identifiers\"]\n+                        if (\n+                            isinstance(principal_type, list)\n+                            and len(principal_type)\n+                            and \"Federated\" in principal_type\n+                            and isinstance(principal_identifiers, list)\n+                        ):\n                             for identifier in principal_identifiers:\n-                                if isinstance(identifier,\n-                                              list) and identifier[0] is not None and \\\n-                                        'oidc-provider/token.actions.githubusercontent.com' in identifier[0]:\n+                                if (\n+                                    isinstance(identifier, list)\n+                                    and identifier[0] is not None\n+                                    and \"oidc-provider/token.actions.githubusercontent.com\" in identifier[0]\n+                                ):\n                                     found_federated_gh_oidc = True\n                                     break\n                 if not found_federated_gh_oidc:\n                     return CheckResult.PASSED\n-                if found_federated_gh_oidc and not statement.get('condition'):\n+                if found_federated_gh_oidc and not statement.get(\"condition\"):\n                     return CheckResult.FAILED\n                 found_sub_condition_variable = False\n                 found_sub_condition_value = False\n-                for condition in statement.get('condition'):\n-                    condition_variables = condition.get('variable')\n-                    condition_values = condition.get('values')\n+                for condition in statement.get(\"condition\"):\n+                    condition_variables = condition.get(\"variable\")\n+                    condition_values = condition.get(\"values\")\n                     if isinstance(condition_variables, list):\n                         for condition_variable in condition_variables:\n-                            if condition_variable == 'token.actions.githubusercontent.com:sub':\n+                            if condition_variable == \"token.actions.githubusercontent.com:sub\":\n                                 found_sub_condition_variable = True\n                                 break\n                         for condition_value in condition_values:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1921863862",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6960,
        "pr_file": "checkov/terraform/checks/data/aws/GithubActionsOIDCTrustPolicy.py",
        "discussion_id": "1921863862",
        "commented_code": "@@ -4,54 +4,82 @@\n from checkov.common.util.type_forcers import force_list\n from checkov.terraform.checks.data.base_check import BaseDataCheck\n \n-gh_repo_regex = re.compile(r'repo:[^/]+/[^/]+')\n+gh_repo_regex = re.compile(r\"[\\w]+/.+\")\n+gh_abusable_claims = [\"workflow\", \"environment\", \"ref\", \"context\", \"head_ref\", \"base_ref\"]\n \n \n class GithubActionsOIDCTrustPolicy(BaseDataCheck):\n     def __init__(self):\n-        name = 'Ensure GitHub Actions OIDC trust policies only allows actions from a specific known organization'\n+        name = \"Ensure GitHub Actions OIDC authorization policies only allows safe claims and claim order\"\n         id = \"CKV_AWS_358\"\n         supported_data = (\"aws_iam_policy_document\",)\n         categories = [CheckCategories.IAM]\n         super().__init__(name=name, id=id, categories=categories, supported_data=supported_data)\n \n     def scan_data_conf(self, conf: Dict[str, List[Any]]) -> CheckResult:\n-        statements = force_list(conf.get('statement'))\n+        statements = force_list(conf.get(\"statement\"))\n         for statement in statements:\n             found_federated_gh_oidc = False\n             if isinstance(statement, dict):\n-                if statement.get('principals'):\n-                    principals = statement['principals']\n+                if statement.get(\"principals\"):\n+                    principals = statement[\"principals\"]\n                     for principal in force_list(principals):\n-                        if 'type' not in principal and 'identifiers' not in principal:\n+                        if \"type\" not in principal and \"identifiers\" not in principal:\n                             continue\n-                        principal_type = principal['type']\n-                        principal_identifiers = principal['identifiers']\n-                        if isinstance(principal_type, list) and len(\n-                                principal_type) and 'Federated' in principal_type and isinstance(principal_identifiers,\n-                                                                                                 list):\n+                        principal_type = principal[\"type\"]\n+                        principal_identifiers = principal[\"identifiers\"]\n+                        if (\n+                            isinstance(principal_type, list)\n+                            and len(principal_type)\n+                            and \"Federated\" in principal_type\n+                            and isinstance(principal_identifiers, list)\n+                        ):\n                             for identifier in principal_identifiers:\n-                                if isinstance(identifier,\n-                                              list) and identifier[0] is not None and \\\n-                                        'oidc-provider/token.actions.githubusercontent.com' in identifier[0]:\n+                                if (\n+                                    isinstance(identifier, list)\n+                                    and identifier[0] is not None\n+                                    and \"oidc-provider/token.actions.githubusercontent.com\" in identifier[0]\n+                                ):\n                                     found_federated_gh_oidc = True\n                                     break\n                 if not found_federated_gh_oidc:\n                     return CheckResult.PASSED\n-                if found_federated_gh_oidc and not statement.get('condition'):\n+                if found_federated_gh_oidc and not statement.get(\"condition\"):\n                     return CheckResult.FAILED\n                 found_sub_condition_variable = False\n                 found_sub_condition_value = False\n-                for condition in statement.get('condition'):\n-                    condition_variables = condition.get('variable')\n-                    condition_values = condition.get('values')\n+                for condition in statement.get(\"condition\"):\n+                    condition_variables = condition.get(\"variable\")\n+                    condition_values = condition.get(\"values\")\n                     if isinstance(condition_variables, list):\n                         for condition_variable in condition_variables:\n-                            if condition_variable == 'token.actions.githubusercontent.com:sub':\n+                            if condition_variable == \"token.actions.githubusercontent.com:sub\":\n                                 found_sub_condition_variable = True\n                                 break\n                         for condition_value in condition_values:",
        "comment_created_at": "2025-01-20T06:37:39+00:00",
        "comment_author": "tsmithv11",
        "comment_body": "```suggestion\r\n                        if isinstance(condition_values, list):\r\n                            for condition_value in condition_values:\r\n```\r\n\r\nRecommend checking that it is a list",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1694205056",
    "pr_number": 6502,
    "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
    "created_at": "2024-07-28T09:23:55+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if \"siteConfig\" in conf[\"properties\"] and conf[\"properties\"][\"siteConfig\"] is not None:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1694205056",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6502,
        "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
        "discussion_id": "1694205056",
        "commented_code": "@@ -0,0 +1,34 @@\n+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if \"siteConfig\" in conf[\"properties\"] and conf[\"properties\"][\"siteConfig\"] is not None:",
        "comment_created_at": "2024-07-28T09:23:55+00:00",
        "comment_author": "SteveVaknin",
        "comment_body": "consider working with `get` instead, it is less complex and more readable. If the key doesn't exists it will return `None`. \r\n\r\n```suggestion\r\n            if conf.get(\"properties\").get(\"siteConfig\") is not None:\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1694617802",
    "pr_number": 6502,
    "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
    "created_at": "2024-07-29T06:04:47+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if conf.get(\"properties\").get(\"siteConfig\") is not None:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1694617802",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6502,
        "pr_file": "checkov/arm/checks/resource/AppServiceInstanceMinimum.py",
        "discussion_id": "1694617802",
        "commented_code": "@@ -0,0 +1,34 @@\n+from __future__ import annotations\n+\n+from typing import Dict\n+\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class AppServiceInstanceMinimum(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        # \"App Services Plans provides a configurable number of instances that will run apps.\n+        # When a single instance is configured your app may be temporarily unavailable during unplanned interruptions.\n+        # In most circumstances, Azure will self-heal faulty app service instances automatically.\n+        # How-ever during this time there may interruptions to your workload.\"\n+        name = \"Ensure App Service has a minimum number of instances for failover\"\n+        id = \"CKV_AZURE_212\"\n+        supported_resources = (\"Microsoft.Web/sites\", \"Microsoft.Web/sites/slots\")\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Dict[str, Dict[str, int]]]) -> CheckResult:\n+        if \"properties\" in conf:\n+            if conf.get(\"properties\").get(\"siteConfig\") is not None:",
        "comment_created_at": "2024-07-29T06:04:47+00:00",
        "comment_author": "ChanochShayner",
        "comment_body": "```suggestion\r\n            if conf.get(\"properties\", {}).get(\"siteConfig\") is not None:\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1632233889",
    "pr_number": 6418,
    "pr_file": "checkov/arm/checks/resource/AzureDefenderOnKeyVaults.py",
    "created_at": "2024-06-09T10:51:23+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+from typing import Any\n+\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+\n+\n+class AzureDefenderOnKeyVaults(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that Azure Defender is set to On for Key Vault\"\n+        id = \"CKV_AZURE_87\"\n+        supported_resources = (\"Microsoft.Security/pricings\",)\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: dict[str, list[Any]]) -> CheckResult:\n+        if conf[\"properties\"][\"pricingTier\"] == \"Standard\":",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1632233889",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6418,
        "pr_file": "checkov/arm/checks/resource/AzureDefenderOnKeyVaults.py",
        "discussion_id": "1632233889",
        "commented_code": "@@ -0,0 +1,27 @@\n+from __future__ import annotations\n+\n+from typing import Any\n+\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+from checkov.arm.base_resource_check import BaseResourceCheck\n+\n+\n+class AzureDefenderOnKeyVaults(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that Azure Defender is set to On for Key Vault\"\n+        id = \"CKV_AZURE_87\"\n+        supported_resources = (\"Microsoft.Security/pricings\",)\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: dict[str, list[Any]]) -> CheckResult:\n+        if conf[\"properties\"][\"pricingTier\"] == \"Standard\":",
        "comment_created_at": "2024-06-09T10:51:23+00:00",
        "comment_author": "ChanochShayner",
        "comment_body": "we need to check if the fields are in the dict before accessing them.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1663549254",
    "pr_number": 6455,
    "pr_file": "checkov/arm/checks/resource/VMStorageOsDisk.py",
    "created_at": "2024-07-03T06:07:03+00:00",
    "commented_code": "+from typing import Any, Dict\n+\n+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.arm.base_resource_value_check import BaseResourceCheck\n+\n+\n+class VMStorageOsDisk(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that Virtual Machines use managed disks\"\n+        id = \"CKV_AZURE_92\"\n+        supported_resources = (\"Microsoft.Compute/virtualMachines\",)\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Any]) -> CheckResult:\n+        properties = conf.get('properties')\n+        if not properties:\n+            return CheckResult.PASSED\n+        storage_profile = properties.get('storageProfile')\n+        if not storage_profile:\n+            return CheckResult.PASSED\n+        os_disk = storage_profile.get('osDisk')",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1663549254",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6455,
        "pr_file": "checkov/arm/checks/resource/VMStorageOsDisk.py",
        "discussion_id": "1663549254",
        "commented_code": "@@ -0,0 +1,36 @@\n+from typing import Any, Dict\n+\n+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.arm.base_resource_value_check import BaseResourceCheck\n+\n+\n+class VMStorageOsDisk(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that Virtual Machines use managed disks\"\n+        id = \"CKV_AZURE_92\"\n+        supported_resources = (\"Microsoft.Compute/virtualMachines\",)\n+        categories = (CheckCategories.GENERAL_SECURITY,)\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf: Dict[str, Any]) -> CheckResult:\n+        properties = conf.get('properties')\n+        if not properties:\n+            return CheckResult.PASSED\n+        storage_profile = properties.get('storageProfile')\n+        if not storage_profile:\n+            return CheckResult.PASSED\n+        os_disk = storage_profile.get('osDisk')",
        "comment_created_at": "2024-07-03T06:07:03+00:00",
        "comment_author": "ChanochShayner",
        "comment_body": "lets check if `storage_profile` field is a dict before accessing it.  ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1114993880",
    "pr_number": 4375,
    "pr_file": "checkov/cloudformation/checks/resource/aws/LambdaServicePermission.py",
    "created_at": "2023-02-22T21:40:51+00:00",
    "commented_code": "+from typing import List\n+\n+from checkov.cloudformation.checks.resource.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that AWS Lambda function permissions delegated to AWS services are limited by SourceArn or SourceAccount\"\n+        id = \"CKV_AWS_293\"\n+        supported_resources = [\"AWS::Lambda::Permission\"]\n+        categories = [CheckCategories.GENERAL_SECURITY, ]\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        properties = conf.get('Properties')\n+        if properties is not None:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1114993880",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 4375,
        "pr_file": "checkov/cloudformation/checks/resource/aws/LambdaServicePermission.py",
        "discussion_id": "1114993880",
        "commented_code": "@@ -0,0 +1,35 @@\n+from typing import List\n+\n+from checkov.cloudformation.checks.resource.base_resource_check import BaseResourceCheck\n+from checkov.common.models.enums import CheckCategories, CheckResult\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self) -> None:\n+        name = \"Ensure that AWS Lambda function permissions delegated to AWS services are limited by SourceArn or SourceAccount\"\n+        id = \"CKV_AWS_293\"\n+        supported_resources = [\"AWS::Lambda::Permission\"]\n+        categories = [CheckCategories.GENERAL_SECURITY, ]\n+        super().__init__(name=name, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        properties = conf.get('Properties')\n+        if properties is not None:",
        "comment_created_at": "2023-02-22T21:40:51+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n        if properties and isinstance(properties, dict):\r\n```\r\nlet's make sure, ew deal with a dictionary otherwise we will have a problem.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1115000149",
    "pr_number": 4375,
    "pr_file": "checkov/terraform/checks/resource/aws/LambdaServicePermission.py",
    "created_at": "2023-02-22T21:48:27+00:00",
    "commented_code": "+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self):\n+        # This is the full description of your check\n+        description = \"Ensure that when a Lambda Function Permission is delegated to a service as principal, that the permission is scoped to either a SourceArn or a SourceAccount.\"\n+\n+        # This is the Unique ID for your check\n+        id = \"CKV_AWS_293\"\n+\n+        # These are the terraform objects supported by this check (ex: aws_iam_policy_document)\n+        supported_resources = ['aws_lambda_permission']\n+\n+        # Valid CheckCategories are defined in checkov/common/models/enums.py\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=description, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        # Replace this with the custom logic for your check\n+        principal = conf.get(\"principal\", [])\n+        self.evaluated_keys = [\"principal\"]\n+        principal_parts = principal[0].split('.')",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1115000149",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 4375,
        "pr_file": "checkov/terraform/checks/resource/aws/LambdaServicePermission.py",
        "discussion_id": "1115000149",
        "commented_code": "@@ -0,0 +1,38 @@\n+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self):\n+        # This is the full description of your check\n+        description = \"Ensure that when a Lambda Function Permission is delegated to a service as principal, that the permission is scoped to either a SourceArn or a SourceAccount.\"\n+\n+        # This is the Unique ID for your check\n+        id = \"CKV_AWS_293\"\n+\n+        # These are the terraform objects supported by this check (ex: aws_iam_policy_document)\n+        supported_resources = ['aws_lambda_permission']\n+\n+        # Valid CheckCategories are defined in checkov/common/models/enums.py\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=description, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        # Replace this with the custom logic for your check\n+        principal = conf.get(\"principal\", [])\n+        self.evaluated_keys = [\"principal\"]\n+        principal_parts = principal[0].split('.')",
        "comment_created_at": "2023-02-22T21:48:27+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n        principal = conf.get(\"principal\")\r\n        if principal and isintsance(principal, list) and isinstance(principal[0], str):\r\n            principal_parts = principal[0].split('.')\r\n```\r\nthis is a bit tricky, we need to be a bit more cautious on the types. Quite often Terraform plan files come with unexpected default values and break our checks.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1253041087",
    "pr_number": 5285,
    "pr_file": "checkov/common/sca/output.py",
    "created_at": "2023-07-05T12:33:14+00:00",
    "commented_code": "return licenses_per_package_map\n \n \n+def get_inline_suppressions_map(inline_suppressions: _ScaSuppressions | None = None) -> _ScaSuppressionsMaps | None:\n+    if not inline_suppressions:\n+        return None\n+    suppressions_map: _ScaSuppressionsMaps = {}\n+\n+    # fill cves suppressions map\n+    cve_by_cve_map: dict[str, _SuppressedCves] = {}\n+    if inline_suppressions.get(\"cves\"):\n+        if inline_suppressions[\"cves\"].get(\"byCve\"):\n+            for cve_suppression in inline_suppressions[\"cves\"][\"byCve\"]:\n+                if cve_suppression.get(\"cveId\"):\n+                    cve_by_cve_map[cve_suppression[\"cveId\"]] = cve_suppression",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1253041087",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5285,
        "pr_file": "checkov/common/sca/output.py",
        "discussion_id": "1253041087",
        "commented_code": "@@ -266,6 +276,35 @@ def _add_to_report_licenses_statuses(\n     return licenses_per_package_map\n \n \n+def get_inline_suppressions_map(inline_suppressions: _ScaSuppressions | None = None) -> _ScaSuppressionsMaps | None:\n+    if not inline_suppressions:\n+        return None\n+    suppressions_map: _ScaSuppressionsMaps = {}\n+\n+    # fill cves suppressions map\n+    cve_by_cve_map: dict[str, _SuppressedCves] = {}\n+    if inline_suppressions.get(\"cves\"):\n+        if inline_suppressions[\"cves\"].get(\"byCve\"):\n+            for cve_suppression in inline_suppressions[\"cves\"][\"byCve\"]:\n+                if cve_suppression.get(\"cveId\"):\n+                    cve_by_cve_map[cve_suppression[\"cveId\"]] = cve_suppression",
        "comment_created_at": "2023-07-05T12:33:14+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n    inline_suppressions_by_cve = inline_suppressions.get(\"cves\", {}).get(\"byCve\", {})\r\n    for cve_suppression in inline_suppressions_by_cve:\r\n        cve_id = cve_suppression.get(\"cveId\")\r\n        if cve_id:\r\n            cve_by_cve_map[cve_id] = cve_suppression\r\n```\r\n\ud83d\ude42 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1215615816",
    "pr_number": 5112,
    "pr_file": "checkov/terraform/plan_parser.py",
    "created_at": "2023-06-03T15:42:38+00:00",
    "commented_code": "\"\"\"Returns a resource address to resource changes dict\"\"\"\n \n     resource_changes_map = {}\n-\n     resource_changes = template.get(\"resource_changes\")\n-    if resource_changes and isinstance(resource_changes, list):\n-        resource_changes_map = {\n-            change.get(\"address\", \"\"): change\n-            for change in resource_changes\n-        }\n \n+    if resource_changes and isinstance(resource_changes, list):\n+        for each in resource_changes:\n+            resource_changes_map[each[\"address\"]] = each\n+            changes = []\n+\n+            # before + after are None when resources are created/destroyed, so make them safe\n+            if not each[\"change\"][\"before\"]:\n+                each[\"change\"][\"before\"] = {}\n+            if not each[\"change\"][\"after\"]:\n+                each[\"change\"][\"after\"] = {}",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1215615816",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5112,
        "pr_file": "checkov/terraform/plan_parser.py",
        "discussion_id": "1215615816",
        "commented_code": "@@ -238,14 +239,24 @@ def _get_resource_changes(template: dict[str, Any]) -> dict[str, dict[str, Any]]\n     \"\"\"Returns a resource address to resource changes dict\"\"\"\n \n     resource_changes_map = {}\n-\n     resource_changes = template.get(\"resource_changes\")\n-    if resource_changes and isinstance(resource_changes, list):\n-        resource_changes_map = {\n-            change.get(\"address\", \"\"): change\n-            for change in resource_changes\n-        }\n \n+    if resource_changes and isinstance(resource_changes, list):\n+        for each in resource_changes:\n+            resource_changes_map[each[\"address\"]] = each\n+            changes = []\n+\n+            # before + after are None when resources are created/destroyed, so make them safe\n+            if not each[\"change\"][\"before\"]:\n+                each[\"change\"][\"before\"] = {}\n+            if not each[\"change\"][\"after\"]:\n+                each[\"change\"][\"after\"] = {}",
        "comment_created_at": "2023-06-03T15:42:38+00:00",
        "comment_author": "gruebel",
        "comment_body": "`not` also works, but if it is an empty `dict` then there is no need to override it again\r\n```suggestion\r\n            if each[\"change\"][\"before\"] is None:\r\n                each[\"change\"][\"before\"] = {}\r\n            if each[\"change\"][\"after\"] is None:\r\n                each[\"change\"][\"after\"] = {}\r\n```",
        "pr_file_module": null
      }
    ]
  }
]