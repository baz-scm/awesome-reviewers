[
  {
    "discussion_id": "1481122587",
    "pr_number": 6013,
    "pr_file": "checkov/common/bridgecrew/platform_integration.py",
    "created_at": "2024-02-07T08:58:48+00:00",
    "commented_code": "return re.match(UUID_V4_PATTERN, token) is not None\n \n+    @staticmethod\n+    def raise_bridgecrew_auth_error(request_status: int, request_data: bytes) -> NoReturn:\n+        logging.error(f'Received {request_status} response from Prisma /login endpoint: {request_data.decode(\"utf8\")}')  # danger:ignore\n+        raise BridgecrewAuthError()\n+\n+    def fetch_auth_token(self, username: str, password: str) -> str:\n+        retries = int(os.getenv('REQUEST_MAX_TRIES', 3))\n+        request: Any = None\n+        for i in range(retries):\n+            request = self.http.request(\"POST\", f\"{self.prisma_api_url}/login\",  # type:ignore[union-attr]\n+                                        body=json.dumps({\"username\": username, \"password\": password}),\n+                                        headers=merge_dicts({\"Content-Type\": \"application/json\"},\n+                                                            get_user_agent_header()))\n+\n+            if request.status == 200:\n+                token: str = json.loads(request.data.decode(\"utf8\"))['token']\n+                return token\n+            elif request.status in [401, 403]:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1481122587",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6013,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1481122587",
        "commented_code": "@@ -249,6 +249,30 @@ def is_bc_token(token: str | None) -> TypeGuard[str]:\n \n         return re.match(UUID_V4_PATTERN, token) is not None\n \n+    @staticmethod\n+    def raise_bridgecrew_auth_error(request_status: int, request_data: bytes) -> NoReturn:\n+        logging.error(f'Received {request_status} response from Prisma /login endpoint: {request_data.decode(\"utf8\")}')  # danger:ignore\n+        raise BridgecrewAuthError()\n+\n+    def fetch_auth_token(self, username: str, password: str) -> str:\n+        retries = int(os.getenv('REQUEST_MAX_TRIES', 3))\n+        request: Any = None\n+        for i in range(retries):\n+            request = self.http.request(\"POST\", f\"{self.prisma_api_url}/login\",  # type:ignore[union-attr]\n+                                        body=json.dumps({\"username\": username, \"password\": password}),\n+                                        headers=merge_dicts({\"Content-Type\": \"application/json\"},\n+                                                            get_user_agent_header()))\n+\n+            if request.status == 200:\n+                token: str = json.loads(request.data.decode(\"utf8\"))['token']\n+                return token\n+            elif request.status in [401, 403]:",
        "comment_created_at": "2024-02-07T08:58:48+00:00",
        "comment_author": "Eliran-Turgeman",
        "comment_body": "I think 500 fits here too",
        "pr_file_module": null
      },
      {
        "comment_id": "1481750127",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6013,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1481122587",
        "commented_code": "@@ -249,6 +249,30 @@ def is_bc_token(token: str | None) -> TypeGuard[str]:\n \n         return re.match(UUID_V4_PATTERN, token) is not None\n \n+    @staticmethod\n+    def raise_bridgecrew_auth_error(request_status: int, request_data: bytes) -> NoReturn:\n+        logging.error(f'Received {request_status} response from Prisma /login endpoint: {request_data.decode(\"utf8\")}')  # danger:ignore\n+        raise BridgecrewAuthError()\n+\n+    def fetch_auth_token(self, username: str, password: str) -> str:\n+        retries = int(os.getenv('REQUEST_MAX_TRIES', 3))\n+        request: Any = None\n+        for i in range(retries):\n+            request = self.http.request(\"POST\", f\"{self.prisma_api_url}/login\",  # type:ignore[union-attr]\n+                                        body=json.dumps({\"username\": username, \"password\": password}),\n+                                        headers=merge_dicts({\"Content-Type\": \"application/json\"},\n+                                                            get_user_agent_header()))\n+\n+            if request.status == 200:\n+                token: str = json.loads(request.data.decode(\"utf8\"))['token']\n+                return token\n+            elif request.status in [401, 403]:",
        "comment_created_at": "2024-02-07T16:22:44+00:00",
        "comment_author": "OfekShimko",
        "comment_body": "@mikeurbanski1 WDYT? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1481835443",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6013,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1481122587",
        "commented_code": "@@ -249,6 +249,30 @@ def is_bc_token(token: str | None) -> TypeGuard[str]:\n \n         return re.match(UUID_V4_PATTERN, token) is not None\n \n+    @staticmethod\n+    def raise_bridgecrew_auth_error(request_status: int, request_data: bytes) -> NoReturn:\n+        logging.error(f'Received {request_status} response from Prisma /login endpoint: {request_data.decode(\"utf8\")}')  # danger:ignore\n+        raise BridgecrewAuthError()\n+\n+    def fetch_auth_token(self, username: str, password: str) -> str:\n+        retries = int(os.getenv('REQUEST_MAX_TRIES', 3))\n+        request: Any = None\n+        for i in range(retries):\n+            request = self.http.request(\"POST\", f\"{self.prisma_api_url}/login\",  # type:ignore[union-attr]\n+                                        body=json.dumps({\"username\": username, \"password\": password}),\n+                                        headers=merge_dicts({\"Content-Type\": \"application/json\"},\n+                                                            get_user_agent_header()))\n+\n+            if request.status == 200:\n+                token: str = json.loads(request.data.decode(\"utf8\"))['token']\n+                return token\n+            elif request.status in [401, 403]:",
        "comment_created_at": "2024-02-07T17:23:37+00:00",
        "comment_author": "mikeurbanski1",
        "comment_body": "Yeah, we should retry any 5xx error",
        "pr_file_module": null
      },
      {
        "comment_id": "1481840310",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6013,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1481122587",
        "commented_code": "@@ -249,6 +249,30 @@ def is_bc_token(token: str | None) -> TypeGuard[str]:\n \n         return re.match(UUID_V4_PATTERN, token) is not None\n \n+    @staticmethod\n+    def raise_bridgecrew_auth_error(request_status: int, request_data: bytes) -> NoReturn:\n+        logging.error(f'Received {request_status} response from Prisma /login endpoint: {request_data.decode(\"utf8\")}')  # danger:ignore\n+        raise BridgecrewAuthError()\n+\n+    def fetch_auth_token(self, username: str, password: str) -> str:\n+        retries = int(os.getenv('REQUEST_MAX_TRIES', 3))\n+        request: Any = None\n+        for i in range(retries):\n+            request = self.http.request(\"POST\", f\"{self.prisma_api_url}/login\",  # type:ignore[union-attr]\n+                                        body=json.dumps({\"username\": username, \"password\": password}),\n+                                        headers=merge_dicts({\"Content-Type\": \"application/json\"},\n+                                                            get_user_agent_header()))\n+\n+            if request.status == 200:\n+                token: str = json.loads(request.data.decode(\"utf8\"))['token']\n+                return token\n+            elif request.status in [401, 403]:",
        "comment_created_at": "2024-02-07T17:27:34+00:00",
        "comment_author": "OfekShimko",
        "comment_body": "In this if, we raise an exception :) so need to add it here ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1235101440",
    "pr_number": 5217,
    "pr_file": "checkov/common/bridgecrew/platform_integration.py",
    "created_at": "2023-06-20T11:02:21+00:00",
    "commented_code": "logging.info(f\"Unsupported request {request_type}\")\n         return {}\n \n+    # Define the function that will get the relay state from the Prisma Cloud Platform.\n+    def get_sso_prismacloud_url(self, report_url: str) -> str:\n+        if not bc_integration.prisma_api_url:\n+            return report_url\n+        url_saml_config = f\"{bc_integration.prisma_api_url}/saml/config\"\n+        token = self.get_auth_token()\n+        headers = merge_dicts(get_auth_header(token),\n+                              get_default_get_headers(self.bc_source, self.bc_source_version))\n+\n+        request = self.http.request(\"GET\", url_saml_config, headers=headers, timeout=10)\n+        if request.status == 401:\n+            logging.error(f'Received 401 response from Prisma /login endpoint: {request.data.decode(\"utf8\")}')\n+            raise BridgecrewAuthError()\n+        elif request.status == 403:\n+            logging.error('Received 403 (Forbidden) response from Prisma /login endpoint')\n+            raise BridgecrewAuthError()",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1235101440",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5217,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1235101440",
        "commented_code": "@@ -1041,5 +1042,41 @@ def get_default_headers(self, request_type: str) -> dict[str, Any]:\n         logging.info(f\"Unsupported request {request_type}\")\n         return {}\n \n+    # Define the function that will get the relay state from the Prisma Cloud Platform.\n+    def get_sso_prismacloud_url(self, report_url: str) -> str:\n+        if not bc_integration.prisma_api_url:\n+            return report_url\n+        url_saml_config = f\"{bc_integration.prisma_api_url}/saml/config\"\n+        token = self.get_auth_token()\n+        headers = merge_dicts(get_auth_header(token),\n+                              get_default_get_headers(self.bc_source, self.bc_source_version))\n+\n+        request = self.http.request(\"GET\", url_saml_config, headers=headers, timeout=10)\n+        if request.status == 401:\n+            logging.error(f'Received 401 response from Prisma /login endpoint: {request.data.decode(\"utf8\")}')\n+            raise BridgecrewAuthError()\n+        elif request.status == 403:\n+            logging.error('Received 403 (Forbidden) response from Prisma /login endpoint')\n+            raise BridgecrewAuthError()",
        "comment_created_at": "2023-06-20T11:02:21+00:00",
        "comment_author": "gruebel",
        "comment_body": "@mikeurbanski1 any thoughts about raising an exception here or should we just log it and return the normal URL?",
        "pr_file_module": null
      },
      {
        "comment_id": "1243965443",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5217,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1235101440",
        "commented_code": "@@ -1041,5 +1042,41 @@ def get_default_headers(self, request_type: str) -> dict[str, Any]:\n         logging.info(f\"Unsupported request {request_type}\")\n         return {}\n \n+    # Define the function that will get the relay state from the Prisma Cloud Platform.\n+    def get_sso_prismacloud_url(self, report_url: str) -> str:\n+        if not bc_integration.prisma_api_url:\n+            return report_url\n+        url_saml_config = f\"{bc_integration.prisma_api_url}/saml/config\"\n+        token = self.get_auth_token()\n+        headers = merge_dicts(get_auth_header(token),\n+                              get_default_get_headers(self.bc_source, self.bc_source_version))\n+\n+        request = self.http.request(\"GET\", url_saml_config, headers=headers, timeout=10)\n+        if request.status == 401:\n+            logging.error(f'Received 401 response from Prisma /login endpoint: {request.data.decode(\"utf8\")}')\n+            raise BridgecrewAuthError()\n+        elif request.status == 403:\n+            logging.error('Received 403 (Forbidden) response from Prisma /login endpoint')\n+            raise BridgecrewAuthError()",
        "comment_created_at": "2023-06-27T15:40:59+00:00",
        "comment_author": "mikeurbanski1",
        "comment_body": "I like returning the normal URL. Then at least they can go to it after signing in separately.",
        "pr_file_module": null
      },
      {
        "comment_id": "1246526249",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5217,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1235101440",
        "commented_code": "@@ -1041,5 +1042,41 @@ def get_default_headers(self, request_type: str) -> dict[str, Any]:\n         logging.info(f\"Unsupported request {request_type}\")\n         return {}\n \n+    # Define the function that will get the relay state from the Prisma Cloud Platform.\n+    def get_sso_prismacloud_url(self, report_url: str) -> str:\n+        if not bc_integration.prisma_api_url:\n+            return report_url\n+        url_saml_config = f\"{bc_integration.prisma_api_url}/saml/config\"\n+        token = self.get_auth_token()\n+        headers = merge_dicts(get_auth_header(token),\n+                              get_default_get_headers(self.bc_source, self.bc_source_version))\n+\n+        request = self.http.request(\"GET\", url_saml_config, headers=headers, timeout=10)\n+        if request.status == 401:\n+            logging.error(f'Received 401 response from Prisma /login endpoint: {request.data.decode(\"utf8\")}')\n+            raise BridgecrewAuthError()\n+        elif request.status == 403:\n+            logging.error('Received 403 (Forbidden) response from Prisma /login endpoint')\n+            raise BridgecrewAuthError()",
        "comment_created_at": "2023-06-29T12:01:40+00:00",
        "comment_author": "SimOnPanw",
        "comment_body": "@mikeurbanski1 @gruebel instead of raising an exception, I could return the normal URL as follow:\r\n```        \r\nrequest = self.http.request(\"GET\", url_saml_config, headers=headers, timeout=10)  # type:ignore[no-untyped-call]\r\nif request.status >= 300:\r\n  return report_url\r\n```\r\n\r\nWith the problem that we don't trigger an exception if the BC_API_KEY is not provided. I am not sure this is better. What do you think ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1272250056",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5217,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1235101440",
        "commented_code": "@@ -1041,5 +1042,41 @@ def get_default_headers(self, request_type: str) -> dict[str, Any]:\n         logging.info(f\"Unsupported request {request_type}\")\n         return {}\n \n+    # Define the function that will get the relay state from the Prisma Cloud Platform.\n+    def get_sso_prismacloud_url(self, report_url: str) -> str:\n+        if not bc_integration.prisma_api_url:\n+            return report_url\n+        url_saml_config = f\"{bc_integration.prisma_api_url}/saml/config\"\n+        token = self.get_auth_token()\n+        headers = merge_dicts(get_auth_header(token),\n+                              get_default_get_headers(self.bc_source, self.bc_source_version))\n+\n+        request = self.http.request(\"GET\", url_saml_config, headers=headers, timeout=10)\n+        if request.status == 401:\n+            logging.error(f'Received 401 response from Prisma /login endpoint: {request.data.decode(\"utf8\")}')\n+            raise BridgecrewAuthError()\n+        elif request.status == 403:\n+            logging.error('Received 403 (Forbidden) response from Prisma /login endpoint')\n+            raise BridgecrewAuthError()",
        "comment_created_at": "2023-07-24T13:16:26+00:00",
        "comment_author": "mikeurbanski1",
        "comment_body": "We won't get to this code if there is no BC_API_KEY though",
        "pr_file_module": null
      },
      {
        "comment_id": "1272361540",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5217,
        "pr_file": "checkov/common/bridgecrew/platform_integration.py",
        "discussion_id": "1235101440",
        "commented_code": "@@ -1041,5 +1042,41 @@ def get_default_headers(self, request_type: str) -> dict[str, Any]:\n         logging.info(f\"Unsupported request {request_type}\")\n         return {}\n \n+    # Define the function that will get the relay state from the Prisma Cloud Platform.\n+    def get_sso_prismacloud_url(self, report_url: str) -> str:\n+        if not bc_integration.prisma_api_url:\n+            return report_url\n+        url_saml_config = f\"{bc_integration.prisma_api_url}/saml/config\"\n+        token = self.get_auth_token()\n+        headers = merge_dicts(get_auth_header(token),\n+                              get_default_get_headers(self.bc_source, self.bc_source_version))\n+\n+        request = self.http.request(\"GET\", url_saml_config, headers=headers, timeout=10)\n+        if request.status == 401:\n+            logging.error(f'Received 401 response from Prisma /login endpoint: {request.data.decode(\"utf8\")}')\n+            raise BridgecrewAuthError()\n+        elif request.status == 403:\n+            logging.error('Received 403 (Forbidden) response from Prisma /login endpoint')\n+            raise BridgecrewAuthError()",
        "comment_created_at": "2023-07-24T14:40:22+00:00",
        "comment_author": "SimOnPanw",
        "comment_body": "@mikeurbanski1, of course, you are correct. I committed the change.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1203833353",
    "pr_number": 5132,
    "pr_file": "checkov/common/sca/commons.py",
    "created_at": "2023-05-24T10:03:42+00:00",
    "commented_code": "return package.get(\"linesNumbers\", package.get(\"lines\"))\n \n \n+def get_record_file_line_range(package: dict[str, Any], file_line_range: list[int] | None) -> list[int]:\n+    \"\"\"\n+    Currently, there are 2 way for getting file_line_range for the sca-report:\n+    1. by the arg 'file_line_range' which is arrived from the runner - this is specific for entire file (e.g: image referencer)\n+    2. by a dedicated attribute in a package-object - (e.g: DT-cli V2)\n+    The purpose of this function is making sure there are no conflicts between those resources, and return a valid rage\n+    \"\"\"\n+    package_line_range = get_package_lines(package)\n+    if package_line_range and file_line_range:\n+        raise Exception('Both \\'package_line_range\\' and \\'file_line_range\\' are not None. Conflict.')",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1203833353",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5132,
        "pr_file": "checkov/common/sca/commons.py",
        "discussion_id": "1203833353",
        "commented_code": "@@ -50,6 +50,19 @@ def get_package_lines(package: dict[str, Any]) -> list[int] | None:\n     return package.get(\"linesNumbers\", package.get(\"lines\"))\n \n \n+def get_record_file_line_range(package: dict[str, Any], file_line_range: list[int] | None) -> list[int]:\n+    \"\"\"\n+    Currently, there are 2 way for getting file_line_range for the sca-report:\n+    1. by the arg 'file_line_range' which is arrived from the runner - this is specific for entire file (e.g: image referencer)\n+    2. by a dedicated attribute in a package-object - (e.g: DT-cli V2)\n+    The purpose of this function is making sure there are no conflicts between those resources, and return a valid rage\n+    \"\"\"\n+    package_line_range = get_package_lines(package)\n+    if package_line_range and file_line_range:\n+        raise Exception('Both \\'package_line_range\\' and \\'file_line_range\\' are not None. Conflict.')",
        "comment_created_at": "2023-05-24T10:03:42+00:00",
        "comment_author": "gruebel",
        "comment_body": "do we really want to raise an exception or just log a message?",
        "pr_file_module": null
      },
      {
        "comment_id": "1203918591",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5132,
        "pr_file": "checkov/common/sca/commons.py",
        "discussion_id": "1203833353",
        "commented_code": "@@ -50,6 +50,19 @@ def get_package_lines(package: dict[str, Any]) -> list[int] | None:\n     return package.get(\"linesNumbers\", package.get(\"lines\"))\n \n \n+def get_record_file_line_range(package: dict[str, Any], file_line_range: list[int] | None) -> list[int]:\n+    \"\"\"\n+    Currently, there are 2 way for getting file_line_range for the sca-report:\n+    1. by the arg 'file_line_range' which is arrived from the runner - this is specific for entire file (e.g: image referencer)\n+    2. by a dedicated attribute in a package-object - (e.g: DT-cli V2)\n+    The purpose of this function is making sure there are no conflicts between those resources, and return a valid rage\n+    \"\"\"\n+    package_line_range = get_package_lines(package)\n+    if package_line_range and file_line_range:\n+        raise Exception('Both \\'package_line_range\\' and \\'file_line_range\\' are not None. Conflict.')",
        "comment_created_at": "2023-05-24T11:11:23+00:00",
        "comment_author": "itai1357",
        "comment_body": "I prefer raising exepction. it isn't valid behavior. otherwise we can't have bad logic without knowing about it",
        "pr_file_module": null
      },
      {
        "comment_id": "1203951800",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5132,
        "pr_file": "checkov/common/sca/commons.py",
        "discussion_id": "1203833353",
        "commented_code": "@@ -50,6 +50,19 @@ def get_package_lines(package: dict[str, Any]) -> list[int] | None:\n     return package.get(\"linesNumbers\", package.get(\"lines\"))\n \n \n+def get_record_file_line_range(package: dict[str, Any], file_line_range: list[int] | None) -> list[int]:\n+    \"\"\"\n+    Currently, there are 2 way for getting file_line_range for the sca-report:\n+    1. by the arg 'file_line_range' which is arrived from the runner - this is specific for entire file (e.g: image referencer)\n+    2. by a dedicated attribute in a package-object - (e.g: DT-cli V2)\n+    The purpose of this function is making sure there are no conflicts between those resources, and return a valid rage\n+    \"\"\"\n+    package_line_range = get_package_lines(package)\n+    if package_line_range and file_line_range:\n+        raise Exception('Both \\'package_line_range\\' and \\'file_line_range\\' are not None. Conflict.')",
        "comment_created_at": "2023-05-24T11:36:05+00:00",
        "comment_author": "itai1357",
        "comment_body": "fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1193697892",
    "pr_number": 5085,
    "pr_file": "checkov/dockerfile/runner.py",
    "created_at": "2023-05-15T11:23:01+00:00",
    "commented_code": "result_instruction: str,\n     ) -> None:\n         codeblock: list[tuple[int, str]] = []\n-        self.calc_record_codeblock(codeblock, definitions_raw, docker_file_path, endline, startline)\n+\n+        if result_instruction:\n+            entity_context = next(",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1193697892",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5085,
        "pr_file": "checkov/dockerfile/runner.py",
        "discussion_id": "1193697892",
        "commented_code": "@@ -256,7 +263,28 @@ def build_record(\n         result_instruction: str,\n     ) -> None:\n         codeblock: list[tuple[int, str]] = []\n-        self.calc_record_codeblock(codeblock, definitions_raw, docker_file_path, endline, startline)\n+\n+        if result_instruction:\n+            entity_context = next(",
        "comment_created_at": "2023-05-15T11:23:01+00:00",
        "comment_author": "bo156",
        "comment_body": "can this part result in a `StopIteeration` being thrown?",
        "pr_file_module": null
      },
      {
        "comment_id": "1193706583",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5085,
        "pr_file": "checkov/dockerfile/runner.py",
        "discussion_id": "1193697892",
        "commented_code": "@@ -256,7 +263,28 @@ def build_record(\n         result_instruction: str,\n     ) -> None:\n         codeblock: list[tuple[int, str]] = []\n-        self.calc_record_codeblock(codeblock, definitions_raw, docker_file_path, endline, startline)\n+\n+        if result_instruction:\n+            entity_context = next(",
        "comment_created_at": "2023-05-15T11:32:01+00:00",
        "comment_author": "gruebel",
        "comment_body": "in theory it could, but this would mean something went wrong during the context creation. But I will add a check and log a message.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1191037941",
    "pr_number": 5079,
    "pr_file": "checkov/terraform/runner.py",
    "created_at": "2023-05-11T11:38:25+00:00",
    "commented_code": "module, _ = get_module_from_full_path(full_file_path)\n                 if module:\n                     full_definition_path = entity_id.split('.')\n-                    module_name_index = len(full_definition_path) - full_definition_path[::-1][1:].index(BlockType.MODULE) - 1  # the next item after the last 'module' prefix is the module name\n+                    try:\n+                        module_name_index = len(full_definition_path) - full_definition_path[::-1][1:].index(BlockType.MODULE) - 1  # the next item after the last 'module' prefix is the module name\n+                    except Exception as e:",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1191037941",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5079,
        "pr_file": "checkov/terraform/runner.py",
        "discussion_id": "1191037941",
        "commented_code": "@@ -377,7 +377,12 @@ def run_block(self, entities,\n                 module, _ = get_module_from_full_path(full_file_path)\n                 if module:\n                     full_definition_path = entity_id.split('.')\n-                    module_name_index = len(full_definition_path) - full_definition_path[::-1][1:].index(BlockType.MODULE) - 1  # the next item after the last 'module' prefix is the module name\n+                    try:\n+                        module_name_index = len(full_definition_path) - full_definition_path[::-1][1:].index(BlockType.MODULE) - 1  # the next item after the last 'module' prefix is the module name\n+                    except Exception as e:",
        "comment_created_at": "2023-05-11T11:38:25+00:00",
        "comment_author": "ChanochShayner",
        "comment_body": "This is a KeyError?\r\nIf so `except KeyError`",
        "pr_file_module": null
      },
      {
        "comment_id": "1191038432",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5079,
        "pr_file": "checkov/terraform/runner.py",
        "discussion_id": "1191037941",
        "commented_code": "@@ -377,7 +377,12 @@ def run_block(self, entities,\n                 module, _ = get_module_from_full_path(full_file_path)\n                 if module:\n                     full_definition_path = entity_id.split('.')\n-                    module_name_index = len(full_definition_path) - full_definition_path[::-1][1:].index(BlockType.MODULE) - 1  # the next item after the last 'module' prefix is the module name\n+                    try:\n+                        module_name_index = len(full_definition_path) - full_definition_path[::-1][1:].index(BlockType.MODULE) - 1  # the next item after the last 'module' prefix is the module name\n+                    except Exception as e:",
        "comment_created_at": "2023-05-11T11:38:56+00:00",
        "comment_author": "achiar99",
        "comment_body": "ValueError :) ",
        "pr_file_module": null
      }
    ]
  }
]