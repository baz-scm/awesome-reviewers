[
  {
    "discussion_id": "2052950396",
    "pr_number": 7111,
    "pr_file": "checkov/terraform/module_loading/module_finder.py",
    "created_at": "2025-04-21T20:21:17+00:00",
    "commented_code": "def find_modules(path: str) -> List[ModuleDownload]:\n     modules_found: list[ModuleDownload] = []\n \n+    # Leverage modules.json to better inform discovery. If we have this,\n+    # there should be no need to walk and gather modules\n+    if env_vars_config.CHECKOV_EXPERIMENTAL_TERRAFORM_MANAGED_MODULES:\n+        tf_modules_file = Path(path) / '.terraform' / 'modules' / 'modules.json'\n+        if tf_modules_file.exists():\n+            for mod in json.loads(tf_modules_file.read_bytes())['Modules']:\n+                if len(mod['Key']):",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "2052950396",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 7111,
        "pr_file": "checkov/terraform/module_loading/module_finder.py",
        "discussion_id": "2052950396",
        "commented_code": "@@ -36,6 +37,22 @@ def __str__(self) -> str:\n def find_modules(path: str) -> List[ModuleDownload]:\n     modules_found: list[ModuleDownload] = []\n \n+    # Leverage modules.json to better inform discovery. If we have this,\n+    # there should be no need to walk and gather modules\n+    if env_vars_config.CHECKOV_EXPERIMENTAL_TERRAFORM_MANAGED_MODULES:\n+        tf_modules_file = Path(path) / '.terraform' / 'modules' / 'modules.json'\n+        if tf_modules_file.exists():\n+            for mod in json.loads(tf_modules_file.read_bytes())['Modules']:\n+                if len(mod['Key']):",
        "comment_created_at": "2025-04-21T20:21:17+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n                if mod['Key']:\r\n```\r\nit is faster to check for truthiness, which means it is not empty.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1818074197",
    "pr_number": 6769,
    "pr_file": "checkov/arm/graph_builder/local_graph.py",
    "created_at": "2024-10-27T12:05:49+00:00",
    "commented_code": "var_name = match[1]\n                         self._create_edge(var_name, origin_vertex_index, attr_key)\n \n+    def _create_edge(self, element_name: str, origin_vertex_index: int, label: str) -> None:\n+        dest_vertex_index = self.vertices_by_name.get(element_name)\n+        if origin_vertex_index == dest_vertex_index or dest_vertex_index is None:\n+            return\n+        edge = Edge(origin_vertex_index, dest_vertex_index, label)\n+        self.edges.append(edge)\n+        self.out_edges[origin_vertex_index].append(edge)\n+        self.in_edges[dest_vertex_index].append(edge)\n+\n+    def _create_implicit_edges(self, origin_vertex_index: int, resource_name: str, d: dict[str, Any]) -> None:\n+        for _, value in d.items():",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1818074197",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6769,
        "pr_file": "checkov/arm/graph_builder/local_graph.py",
        "discussion_id": "1818074197",
        "commented_code": "@@ -156,6 +160,25 @@ def _create_vars_and_parameters_edges(self) -> None:\n                         var_name = match[1]\n                         self._create_edge(var_name, origin_vertex_index, attr_key)\n \n+    def _create_edge(self, element_name: str, origin_vertex_index: int, label: str) -> None:\n+        dest_vertex_index = self.vertices_by_name.get(element_name)\n+        if origin_vertex_index == dest_vertex_index or dest_vertex_index is None:\n+            return\n+        edge = Edge(origin_vertex_index, dest_vertex_index, label)\n+        self.edges.append(edge)\n+        self.out_edges[origin_vertex_index].append(edge)\n+        self.in_edges[dest_vertex_index].append(edge)\n+\n+    def _create_implicit_edges(self, origin_vertex_index: int, resource_name: str, d: dict[str, Any]) -> None:\n+        for _, value in d.items():",
        "comment_created_at": "2024-10-27T12:05:49+00:00",
        "comment_author": "bo156",
        "comment_body": "why not just go over `d.values()` if you don't use the key",
        "pr_file_module": null
      },
      {
        "comment_id": "1818083748",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6769,
        "pr_file": "checkov/arm/graph_builder/local_graph.py",
        "discussion_id": "1818074197",
        "commented_code": "@@ -156,6 +160,25 @@ def _create_vars_and_parameters_edges(self) -> None:\n                         var_name = match[1]\n                         self._create_edge(var_name, origin_vertex_index, attr_key)\n \n+    def _create_edge(self, element_name: str, origin_vertex_index: int, label: str) -> None:\n+        dest_vertex_index = self.vertices_by_name.get(element_name)\n+        if origin_vertex_index == dest_vertex_index or dest_vertex_index is None:\n+            return\n+        edge = Edge(origin_vertex_index, dest_vertex_index, label)\n+        self.edges.append(edge)\n+        self.out_edges[origin_vertex_index].append(edge)\n+        self.in_edges[dest_vertex_index].append(edge)\n+\n+    def _create_implicit_edges(self, origin_vertex_index: int, resource_name: str, d: dict[str, Any]) -> None:\n+        for _, value in d.items():",
        "comment_created_at": "2024-10-27T12:53:22+00:00",
        "comment_author": "omriyoffe-panw",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1048281467",
    "pr_number": 4066,
    "pr_file": "checkov/terraform/deep_analysis_plan_graph_manager.py",
    "created_at": "2022-12-14T10:26:30+00:00",
    "commented_code": "+import logging\n+\n+from checkov.terraform.graph_builder.graph_components.blocks import TerraformBlock\n+from checkov.terraform.graph_builder.local_graph import TerraformLocalGraph\n+from checkov.terraform.graph_builder.graph_components.block_types import BlockType\n+from checkov.common.output.report import Report\n+from .plan_parser import TF_PLAN_RESOURCE_ADDRESS\n+from typing import Dict\n+\n+\n+class DeepAnalysisGraphManager:\n+    def __init__(self, tf_graph: TerraformLocalGraph, tf_plan_graph: TerraformLocalGraph) -> None:\n+        self.tf_graph: TerraformLocalGraph = tf_graph\n+        self.tf_plan_graph: TerraformLocalGraph = tf_plan_graph\n+        self._address_to_tf_vertex_map: Dict[str, TerraformBlock] = {}\n+        self._address_to_tf_plan_vertex_map: Dict[str, TerraformBlock] = {}\n+        self._apply_address_mapping()\n+\n+    def _apply_address_mapping(self) -> None:\n+        for vertex in self.tf_graph.vertices:\n+            if vertex.block_type == BlockType.RESOURCE:\n+                self._address_to_tf_vertex_map[vertex.attributes[TF_PLAN_RESOURCE_ADDRESS]] = vertex",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1048281467",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 4066,
        "pr_file": "checkov/terraform/deep_analysis_plan_graph_manager.py",
        "discussion_id": "1048281467",
        "commented_code": "@@ -0,0 +1,43 @@\n+import logging\n+\n+from checkov.terraform.graph_builder.graph_components.blocks import TerraformBlock\n+from checkov.terraform.graph_builder.local_graph import TerraformLocalGraph\n+from checkov.terraform.graph_builder.graph_components.block_types import BlockType\n+from checkov.common.output.report import Report\n+from .plan_parser import TF_PLAN_RESOURCE_ADDRESS\n+from typing import Dict\n+\n+\n+class DeepAnalysisGraphManager:\n+    def __init__(self, tf_graph: TerraformLocalGraph, tf_plan_graph: TerraformLocalGraph) -> None:\n+        self.tf_graph: TerraformLocalGraph = tf_graph\n+        self.tf_plan_graph: TerraformLocalGraph = tf_plan_graph\n+        self._address_to_tf_vertex_map: Dict[str, TerraformBlock] = {}\n+        self._address_to_tf_plan_vertex_map: Dict[str, TerraformBlock] = {}\n+        self._apply_address_mapping()\n+\n+    def _apply_address_mapping(self) -> None:\n+        for vertex in self.tf_graph.vertices:\n+            if vertex.block_type == BlockType.RESOURCE:\n+                self._address_to_tf_vertex_map[vertex.attributes[TF_PLAN_RESOURCE_ADDRESS]] = vertex",
        "comment_created_at": "2022-12-14T10:26:30+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n        self._address_to_tf_vertex_map = {\r\n            vertex.attributes[TF_PLAN_RESOURCE_ADDRESS]: vertex\r\n            for vertex in self.tf_graph.vertices\r\n            if vertex.block_type == BlockType.RESOURCE:\r\n        }\r\n```\r\nI think you can do it via a dict comprehension",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1497490251",
    "pr_number": 6040,
    "pr_file": "checkov/common/bridgecrew/integration_features/features/custom_policies_integration.py",
    "created_at": "2024-02-21T12:53:02+00:00",
    "commented_code": "return\n \n             policies = self.bc_integration.customer_run_config_response.get('customPolicies')\n+            sast_policies_dir = tempfile.mkdtemp()\n+            self.bc_integration.sast_custom_policies = sast_policies_dir\n             for policy in policies:\n                 try:\n                     logging.debug(f\"Loading policy id: {policy.get('id')}\")\n+                    if policy.get('category') == SAST_CATEGORY:\n+                        f = open(f\"{sast_policies_dir}/{policy.get('id')}.yaml\", \"a\")",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1497490251",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 6040,
        "pr_file": "checkov/common/bridgecrew/integration_features/features/custom_policies_integration.py",
        "discussion_id": "1497490251",
        "commented_code": "@@ -49,9 +51,17 @@ def pre_scan(self) -> None:\n                 return\n \n             policies = self.bc_integration.customer_run_config_response.get('customPolicies')\n+            sast_policies_dir = tempfile.mkdtemp()\n+            self.bc_integration.sast_custom_policies = sast_policies_dir\n             for policy in policies:\n                 try:\n                     logging.debug(f\"Loading policy id: {policy.get('id')}\")\n+                    if policy.get('category') == SAST_CATEGORY:\n+                        f = open(f\"{sast_policies_dir}/{policy.get('id')}.yaml\", \"a\")",
        "comment_created_at": "2024-02-21T12:53:02+00:00",
        "comment_author": "tronxd",
        "comment_body": "you can use the `with open(...) as f` instead of open/close ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1398402397",
    "pr_number": 5762,
    "pr_file": "checkov/terraform/checks/resource/azure/AzureContainerInstanceEnvVarSecureValueType.py",
    "created_at": "2023-11-19T13:37:36+00:00",
    "commented_code": "+from __future__ import annotations\n+\n+from typing import Any, Dict, List",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1398402397",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5762,
        "pr_file": "checkov/terraform/checks/resource/azure/AzureContainerInstanceEnvVarSecureValueType.py",
        "discussion_id": "1398402397",
        "commented_code": "@@ -0,0 +1,35 @@\n+from __future__ import annotations\n+\n+from typing import Any, Dict, List",
        "comment_created_at": "2023-11-19T13:37:36+00:00",
        "comment_author": "Saarett",
        "comment_body": "@praveen-panw Let's use Python's built in types wherever possible, i.e `dict` instead of `Dict`, `list` instead of `List` \ud83d\ude42 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1398881743",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5762,
        "pr_file": "checkov/terraform/checks/resource/azure/AzureContainerInstanceEnvVarSecureValueType.py",
        "discussion_id": "1398402397",
        "commented_code": "@@ -0,0 +1,35 @@\n+from __future__ import annotations\n+\n+from typing import Any, Dict, List",
        "comment_created_at": "2023-11-20T09:34:09+00:00",
        "comment_author": "praveen-panw",
        "comment_body": "Okay \ud83d\udc4d\ud83c\udffb",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1115001152",
    "pr_number": 4375,
    "pr_file": "checkov/terraform/checks/resource/aws/LambdaServicePermission.py",
    "created_at": "2023-02-22T21:49:41+00:00",
    "commented_code": "+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self):\n+        # This is the full description of your check\n+        description = \"Ensure that when a Lambda Function Permission is delegated to a service as principal, that the permission is scoped to either a SourceArn or a SourceAccount.\"\n+\n+        # This is the Unique ID for your check\n+        id = \"CKV_AWS_293\"\n+\n+        # These are the terraform objects supported by this check (ex: aws_iam_policy_document)\n+        supported_resources = ['aws_lambda_permission']\n+\n+        # Valid CheckCategories are defined in checkov/common/models/enums.py\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=description, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        # Replace this with the custom logic for your check\n+        principal = conf.get(\"principal\", [])\n+        self.evaluated_keys = [\"principal\"]\n+        principal_parts = principal[0].split('.')\n+        try:\n+            if principal_parts[1] == 'amazonaws' and principal_parts[2] == 'com':  # This confirms that the principal is set as a service principal.\n+                if 'source_arn' in conf.keys() or 'source_account' in conf.keys():  # If either of these are set, we're good and the check should pass.",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1115001152",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 4375,
        "pr_file": "checkov/terraform/checks/resource/aws/LambdaServicePermission.py",
        "discussion_id": "1115001152",
        "commented_code": "@@ -0,0 +1,38 @@\n+from checkov.common.models.enums import CheckResult, CheckCategories\n+from checkov.terraform.checks.resource.base_resource_check import BaseResourceCheck\n+\n+\n+class LambdaServicePermission(BaseResourceCheck):\n+    def __init__(self):\n+        # This is the full description of your check\n+        description = \"Ensure that when a Lambda Function Permission is delegated to a service as principal, that the permission is scoped to either a SourceArn or a SourceAccount.\"\n+\n+        # This is the Unique ID for your check\n+        id = \"CKV_AWS_293\"\n+\n+        # These are the terraform objects supported by this check (ex: aws_iam_policy_document)\n+        supported_resources = ['aws_lambda_permission']\n+\n+        # Valid CheckCategories are defined in checkov/common/models/enums.py\n+        categories = [CheckCategories.GENERAL_SECURITY]\n+        super().__init__(name=description, id=id, categories=categories, supported_resources=supported_resources)\n+\n+    def scan_resource_conf(self, conf):\n+        # Replace this with the custom logic for your check\n+        principal = conf.get(\"principal\", [])\n+        self.evaluated_keys = [\"principal\"]\n+        principal_parts = principal[0].split('.')\n+        try:\n+            if principal_parts[1] == 'amazonaws' and principal_parts[2] == 'com':  # This confirms that the principal is set as a service principal.\n+                if 'source_arn' in conf.keys() or 'source_account' in conf.keys():  # If either of these are set, we're good and the check should pass.",
        "comment_created_at": "2023-02-22T21:49:41+00:00",
        "comment_author": "gruebel",
        "comment_body": "```suggestion\r\n                if 'source_arn' in conf or 'source_account' in conf:  # If either of these are set, we're good and the check should pass.\r\n```\r\nno need to explicitly add `.keys()` because it is the default when doing a lookup in a dict.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1222509333",
    "pr_number": 5188,
    "pr_file": "checkov/common/bridgecrew/integration_features/features/policy_metadata_integration.py",
    "created_at": "2023-06-08T06:21:30+00:00",
    "commented_code": "ckv_id = self.get_ckv_id_from_pc_id(pc_id)\n                     if ckv_id:\n                         self.filtered_policy_ids.append(ckv_id)\n+            self._add_ckv_id_for_filtered_cloned_checks()\n+\n+    def _add_ckv_id_for_filtered_cloned_checks(self) -> None:\n+        \"\"\"\n+        Filtered checks are the policies that are returned by --policy-metadata-filter.\n+        Cloned checks are policies that have modified metadata in Prisma (severity, title etc).\n+        Filtered checks do not have a definition if they are cloned, instead they have a sourceIncidentId\n+        which corresponds to the BC ID of the original source check.\n+        This method adds the CKV ID for that source check to the list of filtered policies to ensure it is run.\n+        Example:\n+            Input:\n+                filtered_policy_ids = [ \"org_AWS_1609123441\" ]\n+                ckv_id_to_source_incident_id_mapping =  { \"org_AWS_1609123441\": \"BC__AWS_GENERAL_123\" }\n+                bc_id_to_ckv_id_mapping = { \"BC__AWS_GENERAL_123\": \"CKV_AWS_123\" }\n+            Output:\n+                filtered_policy_ids = [ \"org_AWS_1609123441\", \"CKV_AWS_123\" ]\n+        \"\"\"\n+        ckv_ids = []\n+        for policy_id in self.filtered_policy_ids:\n+            source_bc_id = self.get_source_incident_id_from_ckv_id(policy_id)\n+            if source_bc_id:\n+                ckv_id = self.get_ckv_id_from_bc_id(source_bc_id)\n+                if ckv_id:\n+                    ckv_ids.append(ckv_id)",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1222509333",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5188,
        "pr_file": "checkov/common/bridgecrew/integration_features/features/policy_metadata_integration.py",
        "discussion_id": "1222509333",
        "commented_code": "@@ -157,6 +164,31 @@ def _handle_customer_prisma_policy_metadata(self, prisma_policy_metadata: list[d\n                     ckv_id = self.get_ckv_id_from_pc_id(pc_id)\n                     if ckv_id:\n                         self.filtered_policy_ids.append(ckv_id)\n+            self._add_ckv_id_for_filtered_cloned_checks()\n+\n+    def _add_ckv_id_for_filtered_cloned_checks(self) -> None:\n+        \"\"\"\n+        Filtered checks are the policies that are returned by --policy-metadata-filter.\n+        Cloned checks are policies that have modified metadata in Prisma (severity, title etc).\n+        Filtered checks do not have a definition if they are cloned, instead they have a sourceIncidentId\n+        which corresponds to the BC ID of the original source check.\n+        This method adds the CKV ID for that source check to the list of filtered policies to ensure it is run.\n+        Example:\n+            Input:\n+                filtered_policy_ids = [ \"org_AWS_1609123441\" ]\n+                ckv_id_to_source_incident_id_mapping =  { \"org_AWS_1609123441\": \"BC__AWS_GENERAL_123\" }\n+                bc_id_to_ckv_id_mapping = { \"BC__AWS_GENERAL_123\": \"CKV_AWS_123\" }\n+            Output:\n+                filtered_policy_ids = [ \"org_AWS_1609123441\", \"CKV_AWS_123\" ]\n+        \"\"\"\n+        ckv_ids = []\n+        for policy_id in self.filtered_policy_ids:\n+            source_bc_id = self.get_source_incident_id_from_ckv_id(policy_id)\n+            if source_bc_id:\n+                ckv_id = self.get_ckv_id_from_bc_id(source_bc_id)\n+                if ckv_id:\n+                    ckv_ids.append(ckv_id)",
        "comment_created_at": "2023-06-08T06:21:30+00:00",
        "comment_author": "nimrodkor",
        "comment_body": "@kartikp10 Just a general engineering tip - try to avoid this nested if pattern by using the `fail-fast` pattern. Might be a little longer but needs less context to understand:\r\n```suggestion\r\n            if not source_bc_id:\r\n                continue\r\n            ckv_id = self.get_ckv_id_from_bc_id(source_bc_id)\r\n            if not ckv_id:\r\n                continue\r\n            ckv_ids.append(ckv_id)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1193666402",
    "pr_number": 5088,
    "pr_file": "checkov/kubernetes/parser/parser.py",
    "created_at": "2023-05-15T10:50:52+00:00",
    "commented_code": "if filename.endswith(\".json\"):\n             (template, template_lines) = k8_json.load(Path(filename))\n         if template:\n+            k8s_validator = K8sValidator()\n             if isinstance(template, list):\n                 for t in template:\n-                    if t and isinstance(t, dict) and 'apiVersion' in t.keys() and 'kind' in t.keys():\n+                    if k8s_validator.is_valid_template(t):",
    "repo_full_name": "bridgecrewio/checkov",
    "discussion_comments": [
      {
        "comment_id": "1193666402",
        "repo_full_name": "bridgecrewio/checkov",
        "pr_number": 5088,
        "pr_file": "checkov/kubernetes/parser/parser.py",
        "discussion_id": "1193666402",
        "commented_code": "@@ -21,9 +22,10 @@ def parse(filename: str) -> tuple[list[dict[str, Any]], list[tuple[int, str]]] |\n         if filename.endswith(\".json\"):\n             (template, template_lines) = k8_json.load(Path(filename))\n         if template:\n+            k8s_validator = K8sValidator()\n             if isinstance(template, list):\n                 for t in template:\n-                    if t and isinstance(t, dict) and 'apiVersion' in t.keys() and 'kind' in t.keys():\n+                    if k8s_validator.is_valid_template(t):",
        "comment_created_at": "2023-05-15T10:50:52+00:00",
        "comment_author": "YaaraVerner",
        "comment_body": "```suggestion\r\n                    if K8sValidator.is_valid_template(t):\r\n```\r\nif you are using a static method you don't need to create an instance of the class for it",
        "pr_file_module": null
      }
    ]
  }
]