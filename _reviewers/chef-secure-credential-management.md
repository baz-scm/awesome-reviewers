---
title: Secure credential management
description: 'When handling passwords, certificates, or keys in your code, implement
  secure encryption and storage mechanisms to prevent exposure of sensitive data. '
repository: chef/chef
label: Security
language: Ruby
comments_count: 5
repository_stars: 7860
---

When handling passwords, certificates, or keys in your code, implement secure encryption and storage mechanisms to prevent exposure of sensitive data. 

Key practices:

1. Use strong encryption with unique salts when hashing sensitive data to prevent rainbow table attacks:

```ruby
# Poor implementation - vulnerable to rainbow tables
def obscure(cleartext)
  return nil if cleartext.nil? || cleartext.empty?
  Digest::SHA2.new(256).hexdigest(cleartext)
end

# Better implementation - with salt
def obscure(cleartext)
  return nil if cleartext.nil? || cleartext.empty?
  salt = SecureRandom.hex(16)  # Generate a random 16-byte salt
  hash = Digest::SHA2.new(256).hexdigest(salt + cleartext)
  { hash: hash, salt: salt }  # Store both hash and salt
end
```

2. Use platform-appropriate secure storage mechanisms (registry on Windows, keychain on macOS) rather than storing credentials in plaintext files.

3. When migrating between encryption methods, ensure backward compatibility while maintaining or improving security. Plan for safe key rotation without disrupting existing implementations.

4. Use dedicated encryption libraries when available rather than implementing your own cryptography:

```ruby
# Prefer built-in encryption libraries over custom implementations
Chef::ReservedNames::Win32::Crypto.encrypt(password)
```

5. Validate that credential operations succeed and provide meaningful error handling when they fail, without exposing sensitive details in logs or error messages.


[
  {
    "discussion_id": "1792491323",
    "pr_number": 14511,
    "pr_file": "lib/chef/telemetry/base.rb",
    "created_at": "2024-10-08T20:48:36+00:00",
    "commented_code": "# frozen_string_literal: true\nrequire \"chef-licensing\"\nrequire \"securerandom\" unless defined?(SecureRandom)\nrequire \"digest\" unless defined?(Digest)\nrequire \"chef-utils/dist\" unless defined?(ChefUtils::Dist)\nrequire_relative \"../telemetry/run_context_probe\" unless defined?(Chef::Telemetry::RunContextProbe)\n\nclass Chef\n  class Telemetry\n    class Base\n      VERSION = 2.0\n      TYPE = \"job\"\n      JOB_TYPE = \"Infra\"\n\n      attr_accessor :scratch, :ohai\n\n      def fetch_license_ids\n        Chef::Log.debug \"Fetching license IDs for telemetry\"\n        @license_keys ||= ChefLicensing.license_keys\n      end\n\n      def create_wrapper\n        Chef::Log.debug \"Initializing wrapper for telemetry\"\n        {\n          version: VERSION,\n          createdTimeUTC: Time.now.getutc.iso8601,\n          environment: Chef::Telemetry::RunContextProbe.guess_run_context,\n          licenseIds: fetch_license_ids,\n          source: \"#{ChefUtils::Dist::Infra::EXEC}:#{Chef::VERSION}\",\n          type: TYPE,\n        }\n      end\n\n      def run_starting(_opts = {})\n        Chef::Log.debug \"Initiating telemetry for Chef\"\n      end\n\n      def run_ending(opts)\n        payload = create_wrapper\n\n        # To not load ohai information once loaded\n        unless ohai\n          @ohai = Ohai::System.new\n          # Load plugins to gather system data\n          @ohai.all_plugins(%w{ os hostname platform dmi kernel})\n        end\n\n        payload[:platform] = ohai[:platform]\n\n        payload[:jobs] = [{\n                            type: JOB_TYPE,\n                            # Target platform info\n                            environment: {\n                              host: ohai[:hostname],\n                              os: ohai[:os],\n                              version: ohai[:platform_version],\n                              architecture: ohai[:kernel][:machine],\n                              id: (ohai[:dmi][:system] && ohai[:dmi][:system][:uuid]) || \"\",\n                            },\n                            runtime: Chef::VERSION,\n                            content: [],\n                            steps: [],\n                          }]\n\n        if opts[:run_context]\n          opts[:run_context].cookbook_collection.each do |_, value|\n            metadata = value.metadata\n            payload[:jobs][0][:content] << {\n              name: obscure(metadata&.name) || \"\",\n              version: metadata&.version || \"\",\n              maintainer: metadata&.maintainer || \"\",\n              type: \"cookbook\",\n            }\n          end\n          all_resources = opts[:run_context].resource_collection&.all_resources\n          if all_resources\n            all_resources.each do |resource|\n              payload[:jobs][0][:steps] << {\n                name: resource.recipe_name,\n                resources: [],\n              }\n\n              payload[:jobs][0][:steps].last[:resources] << {\n                type: \"chef-resource\",\n                name: resource.resource_name.to_s,\n              }\n            end\n          end\n        end\n        Chef::Log.debug \"Final data for telemetry upload -> #{payload}\"\n        Chef::Log.debug \"Finishing telemetry for Chef\"\n        # Return payload object for testing\n        payload\n      end\n\n      # TBD Should we implement distribution name based on below usage?\n      def determine_distribution_name\n        run_context = Chef::Telemetry::RunContextProbe.guess_run_context\n        case run_context\n        when \"chef-zero\"\n          ChefUtils::Dist::Zero::EXEC\n        when \"chef-apply\"\n          ChefUtils::Dist::Apply::EXEC\n        when \"chef-solo\"\n          ChefUtils::Dist::Solo::EXEC\n        else\n          ChefUtils::Dist::Infra::EXEC\n        end\n      end\n\n      # Hash text if non-nil\n      def obscure(cleartext)\n        return nil if cleartext.nil?\n        return nil if cleartext.empty?\n\n        Digest::SHA2.new(256).hexdigest(cleartext)",
    "repo_full_name": "chef/chef",
    "discussion_comments": [
      {
        "comment_id": "1792491323",
        "repo_full_name": "chef/chef",
        "pr_number": 14511,
        "pr_file": "lib/chef/telemetry/base.rb",
        "discussion_id": "1792491323",
        "commented_code": "@@ -0,0 +1,120 @@\n+# frozen_string_literal: true\n+require \"chef-licensing\"\n+require \"securerandom\" unless defined?(SecureRandom)\n+require \"digest\" unless defined?(Digest)\n+require \"chef-utils/dist\" unless defined?(ChefUtils::Dist)\n+require_relative \"../telemetry/run_context_probe\" unless defined?(Chef::Telemetry::RunContextProbe)\n+\n+class Chef\n+  class Telemetry\n+    class Base\n+      VERSION = 2.0\n+      TYPE = \"job\"\n+      JOB_TYPE = \"Infra\"\n+\n+      attr_accessor :scratch, :ohai\n+\n+      def fetch_license_ids\n+        Chef::Log.debug \"Fetching license IDs for telemetry\"\n+        @license_keys ||= ChefLicensing.license_keys\n+      end\n+\n+      def create_wrapper\n+        Chef::Log.debug \"Initializing wrapper for telemetry\"\n+        {\n+          version: VERSION,\n+          createdTimeUTC: Time.now.getutc.iso8601,\n+          environment: Chef::Telemetry::RunContextProbe.guess_run_context,\n+          licenseIds: fetch_license_ids,\n+          source: \"#{ChefUtils::Dist::Infra::EXEC}:#{Chef::VERSION}\",\n+          type: TYPE,\n+        }\n+      end\n+\n+      def run_starting(_opts = {})\n+        Chef::Log.debug \"Initiating telemetry for Chef\"\n+      end\n+\n+      def run_ending(opts)\n+        payload = create_wrapper\n+\n+        # To not load ohai information once loaded\n+        unless ohai\n+          @ohai = Ohai::System.new\n+          # Load plugins to gather system data\n+          @ohai.all_plugins(%w{ os hostname platform dmi kernel})\n+        end\n+\n+        payload[:platform] = ohai[:platform]\n+\n+        payload[:jobs] = [{\n+                            type: JOB_TYPE,\n+                            # Target platform info\n+                            environment: {\n+                              host: ohai[:hostname],\n+                              os: ohai[:os],\n+                              version: ohai[:platform_version],\n+                              architecture: ohai[:kernel][:machine],\n+                              id: (ohai[:dmi][:system] && ohai[:dmi][:system][:uuid]) || \"\",\n+                            },\n+                            runtime: Chef::VERSION,\n+                            content: [],\n+                            steps: [],\n+                          }]\n+\n+        if opts[:run_context]\n+          opts[:run_context].cookbook_collection.each do |_, value|\n+            metadata = value.metadata\n+            payload[:jobs][0][:content] << {\n+              name: obscure(metadata&.name) || \"\",\n+              version: metadata&.version || \"\",\n+              maintainer: metadata&.maintainer || \"\",\n+              type: \"cookbook\",\n+            }\n+          end\n+          all_resources = opts[:run_context].resource_collection&.all_resources\n+          if all_resources\n+            all_resources.each do |resource|\n+              payload[:jobs][0][:steps] << {\n+                name: resource.recipe_name,\n+                resources: [],\n+              }\n+\n+              payload[:jobs][0][:steps].last[:resources] << {\n+                type: \"chef-resource\",\n+                name: resource.resource_name.to_s,\n+              }\n+            end\n+          end\n+        end\n+        Chef::Log.debug \"Final data for telemetry upload -> #{payload}\"\n+        Chef::Log.debug \"Finishing telemetry for Chef\"\n+        # Return payload object for testing\n+        payload\n+      end\n+\n+      # TBD Should we implement distribution name based on below usage?\n+      def determine_distribution_name\n+        run_context = Chef::Telemetry::RunContextProbe.guess_run_context\n+        case run_context\n+        when \"chef-zero\"\n+          ChefUtils::Dist::Zero::EXEC\n+        when \"chef-apply\"\n+          ChefUtils::Dist::Apply::EXEC\n+        when \"chef-solo\"\n+          ChefUtils::Dist::Solo::EXEC\n+        else\n+          ChefUtils::Dist::Infra::EXEC\n+        end\n+      end\n+\n+      # Hash text if non-nil\n+      def obscure(cleartext)\n+        return nil if cleartext.nil?\n+        return nil if cleartext.empty?\n+\n+        Digest::SHA2.new(256).hexdigest(cleartext)",
        "comment_created_at": "2024-10-08T20:48:36+00:00",
        "comment_author": "dafyddcrosby",
        "comment_body": "This is insufficient for obfuscation. Supermarket has ~4000 cookbooks, so building a rainbow table is trivial.",
        "pr_file_module": null
      },
      {
        "comment_id": "1794919348",
        "repo_full_name": "chef/chef",
        "pr_number": 14511,
        "pr_file": "lib/chef/telemetry/base.rb",
        "discussion_id": "1792491323",
        "commented_code": "@@ -0,0 +1,120 @@\n+# frozen_string_literal: true\n+require \"chef-licensing\"\n+require \"securerandom\" unless defined?(SecureRandom)\n+require \"digest\" unless defined?(Digest)\n+require \"chef-utils/dist\" unless defined?(ChefUtils::Dist)\n+require_relative \"../telemetry/run_context_probe\" unless defined?(Chef::Telemetry::RunContextProbe)\n+\n+class Chef\n+  class Telemetry\n+    class Base\n+      VERSION = 2.0\n+      TYPE = \"job\"\n+      JOB_TYPE = \"Infra\"\n+\n+      attr_accessor :scratch, :ohai\n+\n+      def fetch_license_ids\n+        Chef::Log.debug \"Fetching license IDs for telemetry\"\n+        @license_keys ||= ChefLicensing.license_keys\n+      end\n+\n+      def create_wrapper\n+        Chef::Log.debug \"Initializing wrapper for telemetry\"\n+        {\n+          version: VERSION,\n+          createdTimeUTC: Time.now.getutc.iso8601,\n+          environment: Chef::Telemetry::RunContextProbe.guess_run_context,\n+          licenseIds: fetch_license_ids,\n+          source: \"#{ChefUtils::Dist::Infra::EXEC}:#{Chef::VERSION}\",\n+          type: TYPE,\n+        }\n+      end\n+\n+      def run_starting(_opts = {})\n+        Chef::Log.debug \"Initiating telemetry for Chef\"\n+      end\n+\n+      def run_ending(opts)\n+        payload = create_wrapper\n+\n+        # To not load ohai information once loaded\n+        unless ohai\n+          @ohai = Ohai::System.new\n+          # Load plugins to gather system data\n+          @ohai.all_plugins(%w{ os hostname platform dmi kernel})\n+        end\n+\n+        payload[:platform] = ohai[:platform]\n+\n+        payload[:jobs] = [{\n+                            type: JOB_TYPE,\n+                            # Target platform info\n+                            environment: {\n+                              host: ohai[:hostname],\n+                              os: ohai[:os],\n+                              version: ohai[:platform_version],\n+                              architecture: ohai[:kernel][:machine],\n+                              id: (ohai[:dmi][:system] && ohai[:dmi][:system][:uuid]) || \"\",\n+                            },\n+                            runtime: Chef::VERSION,\n+                            content: [],\n+                            steps: [],\n+                          }]\n+\n+        if opts[:run_context]\n+          opts[:run_context].cookbook_collection.each do |_, value|\n+            metadata = value.metadata\n+            payload[:jobs][0][:content] << {\n+              name: obscure(metadata&.name) || \"\",\n+              version: metadata&.version || \"\",\n+              maintainer: metadata&.maintainer || \"\",\n+              type: \"cookbook\",\n+            }\n+          end\n+          all_resources = opts[:run_context].resource_collection&.all_resources\n+          if all_resources\n+            all_resources.each do |resource|\n+              payload[:jobs][0][:steps] << {\n+                name: resource.recipe_name,\n+                resources: [],\n+              }\n+\n+              payload[:jobs][0][:steps].last[:resources] << {\n+                type: \"chef-resource\",\n+                name: resource.resource_name.to_s,\n+              }\n+            end\n+          end\n+        end\n+        Chef::Log.debug \"Final data for telemetry upload -> #{payload}\"\n+        Chef::Log.debug \"Finishing telemetry for Chef\"\n+        # Return payload object for testing\n+        payload\n+      end\n+\n+      # TBD Should we implement distribution name based on below usage?\n+      def determine_distribution_name\n+        run_context = Chef::Telemetry::RunContextProbe.guess_run_context\n+        case run_context\n+        when \"chef-zero\"\n+          ChefUtils::Dist::Zero::EXEC\n+        when \"chef-apply\"\n+          ChefUtils::Dist::Apply::EXEC\n+        when \"chef-solo\"\n+          ChefUtils::Dist::Solo::EXEC\n+        else\n+          ChefUtils::Dist::Infra::EXEC\n+        end\n+      end\n+\n+      # Hash text if non-nil\n+      def obscure(cleartext)\n+        return nil if cleartext.nil?\n+        return nil if cleartext.empty?\n+\n+        Digest::SHA2.new(256).hexdigest(cleartext)",
        "comment_created_at": "2024-10-10T08:01:12+00:00",
        "comment_author": "Nik08",
        "comment_body": "Do you think implementing salting with this might be helpful?\r\n\r\n```\r\nsalt = SecureRandom.hex(16)  # Generate a random 16-byte salt\r\nhash = Digest::SHA2.new(256).hexdigest(salt + cleartext)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1808562848",
        "repo_full_name": "chef/chef",
        "pr_number": 14511,
        "pr_file": "lib/chef/telemetry/base.rb",
        "discussion_id": "1792491323",
        "commented_code": "@@ -0,0 +1,120 @@\n+# frozen_string_literal: true\n+require \"chef-licensing\"\n+require \"securerandom\" unless defined?(SecureRandom)\n+require \"digest\" unless defined?(Digest)\n+require \"chef-utils/dist\" unless defined?(ChefUtils::Dist)\n+require_relative \"../telemetry/run_context_probe\" unless defined?(Chef::Telemetry::RunContextProbe)\n+\n+class Chef\n+  class Telemetry\n+    class Base\n+      VERSION = 2.0\n+      TYPE = \"job\"\n+      JOB_TYPE = \"Infra\"\n+\n+      attr_accessor :scratch, :ohai\n+\n+      def fetch_license_ids\n+        Chef::Log.debug \"Fetching license IDs for telemetry\"\n+        @license_keys ||= ChefLicensing.license_keys\n+      end\n+\n+      def create_wrapper\n+        Chef::Log.debug \"Initializing wrapper for telemetry\"\n+        {\n+          version: VERSION,\n+          createdTimeUTC: Time.now.getutc.iso8601,\n+          environment: Chef::Telemetry::RunContextProbe.guess_run_context,\n+          licenseIds: fetch_license_ids,\n+          source: \"#{ChefUtils::Dist::Infra::EXEC}:#{Chef::VERSION}\",\n+          type: TYPE,\n+        }\n+      end\n+\n+      def run_starting(_opts = {})\n+        Chef::Log.debug \"Initiating telemetry for Chef\"\n+      end\n+\n+      def run_ending(opts)\n+        payload = create_wrapper\n+\n+        # To not load ohai information once loaded\n+        unless ohai\n+          @ohai = Ohai::System.new\n+          # Load plugins to gather system data\n+          @ohai.all_plugins(%w{ os hostname platform dmi kernel})\n+        end\n+\n+        payload[:platform] = ohai[:platform]\n+\n+        payload[:jobs] = [{\n+                            type: JOB_TYPE,\n+                            # Target platform info\n+                            environment: {\n+                              host: ohai[:hostname],\n+                              os: ohai[:os],\n+                              version: ohai[:platform_version],\n+                              architecture: ohai[:kernel][:machine],\n+                              id: (ohai[:dmi][:system] && ohai[:dmi][:system][:uuid]) || \"\",\n+                            },\n+                            runtime: Chef::VERSION,\n+                            content: [],\n+                            steps: [],\n+                          }]\n+\n+        if opts[:run_context]\n+          opts[:run_context].cookbook_collection.each do |_, value|\n+            metadata = value.metadata\n+            payload[:jobs][0][:content] << {\n+              name: obscure(metadata&.name) || \"\",\n+              version: metadata&.version || \"\",\n+              maintainer: metadata&.maintainer || \"\",\n+              type: \"cookbook\",\n+            }\n+          end\n+          all_resources = opts[:run_context].resource_collection&.all_resources\n+          if all_resources\n+            all_resources.each do |resource|\n+              payload[:jobs][0][:steps] << {\n+                name: resource.recipe_name,\n+                resources: [],\n+              }\n+\n+              payload[:jobs][0][:steps].last[:resources] << {\n+                type: \"chef-resource\",\n+                name: resource.resource_name.to_s,\n+              }\n+            end\n+          end\n+        end\n+        Chef::Log.debug \"Final data for telemetry upload -> #{payload}\"\n+        Chef::Log.debug \"Finishing telemetry for Chef\"\n+        # Return payload object for testing\n+        payload\n+      end\n+\n+      # TBD Should we implement distribution name based on below usage?\n+      def determine_distribution_name\n+        run_context = Chef::Telemetry::RunContextProbe.guess_run_context\n+        case run_context\n+        when \"chef-zero\"\n+          ChefUtils::Dist::Zero::EXEC\n+        when \"chef-apply\"\n+          ChefUtils::Dist::Apply::EXEC\n+        when \"chef-solo\"\n+          ChefUtils::Dist::Solo::EXEC\n+        else\n+          ChefUtils::Dist::Infra::EXEC\n+        end\n+      end\n+\n+      # Hash text if non-nil\n+      def obscure(cleartext)\n+        return nil if cleartext.nil?\n+        return nil if cleartext.empty?\n+\n+        Digest::SHA2.new(256).hexdigest(cleartext)",
        "comment_created_at": "2024-10-21T11:06:28+00:00",
        "comment_author": "GeorgeWestwater",
        "comment_body": "@dafyddcrosby - the entire intent on capturing the SHA of the without salt was to actually have that rainbow table.\r\n\r\nWe are looking to understand, what cookbooks are being used from public supermarket. Ideally with this information we can track which cookbook (and version). That are used. That will help us understand what are the most popular cookbooks (download data is not enough for that), which cookbooks being used but are no longer maintained, and as the usage data is tried to a license we could explore the possibility of notify people of cookbook updates/vulnerabilities (inspired from depend-a-bot). \r\n\r\nThe thought process here was cookbook names could contain sensitive information, so transmitting it without a hash was not acceptable, however adding in the salt would make this data meaningless, unless the salt was part of your license (which would also downgrade the usefulness of the salt). \r\n\r\nWe are not interested in collecting information on private cookbooks or user-specific content. I am open to any suggestions on alternative ways to collect this information?",
        "pr_file_module": null
      },
      {
        "comment_id": "1817165143",
        "repo_full_name": "chef/chef",
        "pr_number": 14511,
        "pr_file": "lib/chef/telemetry/base.rb",
        "discussion_id": "1792491323",
        "commented_code": "@@ -0,0 +1,120 @@\n+# frozen_string_literal: true\n+require \"chef-licensing\"\n+require \"securerandom\" unless defined?(SecureRandom)\n+require \"digest\" unless defined?(Digest)\n+require \"chef-utils/dist\" unless defined?(ChefUtils::Dist)\n+require_relative \"../telemetry/run_context_probe\" unless defined?(Chef::Telemetry::RunContextProbe)\n+\n+class Chef\n+  class Telemetry\n+    class Base\n+      VERSION = 2.0\n+      TYPE = \"job\"\n+      JOB_TYPE = \"Infra\"\n+\n+      attr_accessor :scratch, :ohai\n+\n+      def fetch_license_ids\n+        Chef::Log.debug \"Fetching license IDs for telemetry\"\n+        @license_keys ||= ChefLicensing.license_keys\n+      end\n+\n+      def create_wrapper\n+        Chef::Log.debug \"Initializing wrapper for telemetry\"\n+        {\n+          version: VERSION,\n+          createdTimeUTC: Time.now.getutc.iso8601,\n+          environment: Chef::Telemetry::RunContextProbe.guess_run_context,\n+          licenseIds: fetch_license_ids,\n+          source: \"#{ChefUtils::Dist::Infra::EXEC}:#{Chef::VERSION}\",\n+          type: TYPE,\n+        }\n+      end\n+\n+      def run_starting(_opts = {})\n+        Chef::Log.debug \"Initiating telemetry for Chef\"\n+      end\n+\n+      def run_ending(opts)\n+        payload = create_wrapper\n+\n+        # To not load ohai information once loaded\n+        unless ohai\n+          @ohai = Ohai::System.new\n+          # Load plugins to gather system data\n+          @ohai.all_plugins(%w{ os hostname platform dmi kernel})\n+        end\n+\n+        payload[:platform] = ohai[:platform]\n+\n+        payload[:jobs] = [{\n+                            type: JOB_TYPE,\n+                            # Target platform info\n+                            environment: {\n+                              host: ohai[:hostname],\n+                              os: ohai[:os],\n+                              version: ohai[:platform_version],\n+                              architecture: ohai[:kernel][:machine],\n+                              id: (ohai[:dmi][:system] && ohai[:dmi][:system][:uuid]) || \"\",\n+                            },\n+                            runtime: Chef::VERSION,\n+                            content: [],\n+                            steps: [],\n+                          }]\n+\n+        if opts[:run_context]\n+          opts[:run_context].cookbook_collection.each do |_, value|\n+            metadata = value.metadata\n+            payload[:jobs][0][:content] << {\n+              name: obscure(metadata&.name) || \"\",\n+              version: metadata&.version || \"\",\n+              maintainer: metadata&.maintainer || \"\",\n+              type: \"cookbook\",\n+            }\n+          end\n+          all_resources = opts[:run_context].resource_collection&.all_resources\n+          if all_resources\n+            all_resources.each do |resource|\n+              payload[:jobs][0][:steps] << {\n+                name: resource.recipe_name,\n+                resources: [],\n+              }\n+\n+              payload[:jobs][0][:steps].last[:resources] << {\n+                type: \"chef-resource\",\n+                name: resource.resource_name.to_s,\n+              }\n+            end\n+          end\n+        end\n+        Chef::Log.debug \"Final data for telemetry upload -> #{payload}\"\n+        Chef::Log.debug \"Finishing telemetry for Chef\"\n+        # Return payload object for testing\n+        payload\n+      end\n+\n+      # TBD Should we implement distribution name based on below usage?\n+      def determine_distribution_name\n+        run_context = Chef::Telemetry::RunContextProbe.guess_run_context\n+        case run_context\n+        when \"chef-zero\"\n+          ChefUtils::Dist::Zero::EXEC\n+        when \"chef-apply\"\n+          ChefUtils::Dist::Apply::EXEC\n+        when \"chef-solo\"\n+          ChefUtils::Dist::Solo::EXEC\n+        else\n+          ChefUtils::Dist::Infra::EXEC\n+        end\n+      end\n+\n+      # Hash text if non-nil\n+      def obscure(cleartext)\n+        return nil if cleartext.nil?\n+        return nil if cleartext.empty?\n+\n+        Digest::SHA2.new(256).hexdigest(cleartext)",
        "comment_created_at": "2024-10-25T18:12:18+00:00",
        "comment_author": "dafyddcrosby",
        "comment_body": "> however adding in the salt would make this data meaningless, unless the salt was part of your license (which would also downgrade the usefulness of the salt).\r\n\r\nWith no salt, one could just grab a rainbow table off https://crackstation.net/ and call it a day. Whereas if you used eg the serial off the trial key as a salt, while you could still quickly generate one-off rainbow tables of cookbooks out of the known cookbook names in supermarket, it increases the cost of finding *unknown* cookbook names.\r\n\r\nConceptually, the client sends a set of hashes along with the serial. Server-side, you have something like this pseudocode:\r\n```\r\ndef find_supermarket_cookbooks(serial, set)\r\n  table = SUPERMARKET_COOKBOOK_NAMES.to_h {|cb| [Digest::SHA2.new(256).hexdigest(serial + cb), cb] }\r\n  set.map! {|cb_hash| table[cb_hash]}\r\n  set.compact!\r\n  set\r\nend\r\n```\r\n\r\nIt's not a perfect solution, but gets you the information you want re: supermarket cookbooks, and is still largely cacheable so that you don't need to recompute hashes on the backend after the first upload from a license. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1820583786",
        "repo_full_name": "chef/chef",
        "pr_number": 14511,
        "pr_file": "lib/chef/telemetry/base.rb",
        "discussion_id": "1792491323",
        "commented_code": "@@ -0,0 +1,120 @@\n+# frozen_string_literal: true\n+require \"chef-licensing\"\n+require \"securerandom\" unless defined?(SecureRandom)\n+require \"digest\" unless defined?(Digest)\n+require \"chef-utils/dist\" unless defined?(ChefUtils::Dist)\n+require_relative \"../telemetry/run_context_probe\" unless defined?(Chef::Telemetry::RunContextProbe)\n+\n+class Chef\n+  class Telemetry\n+    class Base\n+      VERSION = 2.0\n+      TYPE = \"job\"\n+      JOB_TYPE = \"Infra\"\n+\n+      attr_accessor :scratch, :ohai\n+\n+      def fetch_license_ids\n+        Chef::Log.debug \"Fetching license IDs for telemetry\"\n+        @license_keys ||= ChefLicensing.license_keys\n+      end\n+\n+      def create_wrapper\n+        Chef::Log.debug \"Initializing wrapper for telemetry\"\n+        {\n+          version: VERSION,\n+          createdTimeUTC: Time.now.getutc.iso8601,\n+          environment: Chef::Telemetry::RunContextProbe.guess_run_context,\n+          licenseIds: fetch_license_ids,\n+          source: \"#{ChefUtils::Dist::Infra::EXEC}:#{Chef::VERSION}\",\n+          type: TYPE,\n+        }\n+      end\n+\n+      def run_starting(_opts = {})\n+        Chef::Log.debug \"Initiating telemetry for Chef\"\n+      end\n+\n+      def run_ending(opts)\n+        payload = create_wrapper\n+\n+        # To not load ohai information once loaded\n+        unless ohai\n+          @ohai = Ohai::System.new\n+          # Load plugins to gather system data\n+          @ohai.all_plugins(%w{ os hostname platform dmi kernel})\n+        end\n+\n+        payload[:platform] = ohai[:platform]\n+\n+        payload[:jobs] = [{\n+                            type: JOB_TYPE,\n+                            # Target platform info\n+                            environment: {\n+                              host: ohai[:hostname],\n+                              os: ohai[:os],\n+                              version: ohai[:platform_version],\n+                              architecture: ohai[:kernel][:machine],\n+                              id: (ohai[:dmi][:system] && ohai[:dmi][:system][:uuid]) || \"\",\n+                            },\n+                            runtime: Chef::VERSION,\n+                            content: [],\n+                            steps: [],\n+                          }]\n+\n+        if opts[:run_context]\n+          opts[:run_context].cookbook_collection.each do |_, value|\n+            metadata = value.metadata\n+            payload[:jobs][0][:content] << {\n+              name: obscure(metadata&.name) || \"\",\n+              version: metadata&.version || \"\",\n+              maintainer: metadata&.maintainer || \"\",\n+              type: \"cookbook\",\n+            }\n+          end\n+          all_resources = opts[:run_context].resource_collection&.all_resources\n+          if all_resources\n+            all_resources.each do |resource|\n+              payload[:jobs][0][:steps] << {\n+                name: resource.recipe_name,\n+                resources: [],\n+              }\n+\n+              payload[:jobs][0][:steps].last[:resources] << {\n+                type: \"chef-resource\",\n+                name: resource.resource_name.to_s,\n+              }\n+            end\n+          end\n+        end\n+        Chef::Log.debug \"Final data for telemetry upload -> #{payload}\"\n+        Chef::Log.debug \"Finishing telemetry for Chef\"\n+        # Return payload object for testing\n+        payload\n+      end\n+\n+      # TBD Should we implement distribution name based on below usage?\n+      def determine_distribution_name\n+        run_context = Chef::Telemetry::RunContextProbe.guess_run_context\n+        case run_context\n+        when \"chef-zero\"\n+          ChefUtils::Dist::Zero::EXEC\n+        when \"chef-apply\"\n+          ChefUtils::Dist::Apply::EXEC\n+        when \"chef-solo\"\n+          ChefUtils::Dist::Solo::EXEC\n+        else\n+          ChefUtils::Dist::Infra::EXEC\n+        end\n+      end\n+\n+      # Hash text if non-nil\n+      def obscure(cleartext)\n+        return nil if cleartext.nil?\n+        return nil if cleartext.empty?\n+\n+        Digest::SHA2.new(256).hexdigest(cleartext)",
        "comment_created_at": "2024-10-29T11:02:11+00:00",
        "comment_author": "GeorgeWestwater",
        "comment_body": "@dafyddcrosby  - one question and one comment\r\n\r\nQuestion: what is the concern about someone being able to reverse some of the cookbook names?\r\n\r\nComment: If I am understanding your suggestion correctly (salt by license) that would have to result in us having one rainbow table per license issued. Am I understanding this correctly?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1099196196",
    "pr_number": 13552,
    "pr_file": "lib/chef/http/authenticator.rb",
    "created_at": "2023-02-07T20:36:50+00:00",
    "commented_code": "@win32registry = Chef::Win32::Registry.new\n        path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n        # does the registry key even exist?\n        present = @win32registry.get_values(path)\n        if present.nil? || present.empty?\n        # password_blob should be an array of hashes\n        password_blob = @win32registry.get_values(path)\n        if password_blob.nil? || password_blob.empty?\n          raise Chef::Exceptions::Win32RegKeyMissing\n        end\n\n        present.each do |secret|\n          if secret[:name] == \"PfxPass\"\n            password = decrypt_pfx_pass(secret[:data])\n            return password\n        # Did someone have just the password stored in the registry?\n        raw_data = password_blob.map { |x| x[:data] }\n        vector = raw_data[2]\n        if !!vector\n          decrypted_password = decrypt_pfx_pass_with_vector(password_blob)\n        else\n          decrypted_password = decrypt_pfx_pass_with_password(password_blob)\n          if !!decrypted_password\n            migrate_pass_to_use_vector\n          else\n            Chef::Log.error(\"Failed to retrieve certificate password\")\n          end\n        end\n\n        raise Chef::Exceptions::Win32RegKeyMissing\n\n        decrypted_password\n      rescue Chef::Exceptions::Win32RegKeyMissing\n        # if we don't have a password, log that and generate one\n        Chef::Log.warn \"Authentication Hive and values not present in registry, creating them now\"\n        new_path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n        unless @win32registry.key_exists?(new_path)\n          @win32registry.create_key(new_path, true)\n        end\n        require \"securerandom\" unless defined?(SecureRandom)\n        size = 14\n        password = SecureRandom.alphanumeric(size)\n        encrypted_pass = encrypt_pfx_pass(password)\n        values = { name: \"PfxPass\", type: :string, data: encrypted_pass }\n        @win32registry.set_value(new_path, values)\n        password = create_and_store_new_password\n        password\n      end\n\n      def self.encrypt_pfx_pass(password)\n        powershell_code = <<~CODE\n          $encrypted_string = ConvertTo-SecureString \"#{password}\" -AsPlainText -Force\n          $secure_string = ConvertFrom-SecureString $encrypted_string\n          return $secure_string\n          $AES = [System.Security.Cryptography.Aes]::Create()\n          $key_temp = [System.Convert]::ToBase64String($AES.Key)\n          $iv_temp = [System.Convert]::ToBase64String($AES.IV)\n          $encryptor = $AES.CreateEncryptor()\n          [System.Byte[]]$Bytes =  [System.Text.Encoding]::Unicode.GetBytes(\"#{password}\")\n          $EncryptedBytes = $encryptor.TransformFinalBlock($Bytes,0,$Bytes.Length)\n          $EncryptedBase64String = [System.Convert]::ToBase64String($EncryptedBytes)\n          # create array of encrypted pass, key, iv\n          $password_blob = @($EncryptedBase64String, $key_temp, $iv_temp)\n          return $password_blob\n        CODE\n        powershell_exec!(powershell_code).result\n      end\n\n      def self.decrypt_pfx_pass(password)\n      def self.decrypt_pfx_pass_with_vector(password_blob)\n        raw_data = password_blob.map { |x| x[:data] }\n        password = raw_data[0]\n        key = raw_data[1]\n        vector = raw_data[2]\n\n        powershell_code = <<~CODE\n          $KeyBytes = [System.Convert]::FromBase64String(\"#{key}\")\n          $IVBytes = [System.Convert]::FromBase64String(\"#{vector}\")\n          $aes = [System.Security.Cryptography.Aes]::Create()\n          $aes.Key = $KeyBytes\n          $aes.IV = $IVBytes\n          $EncryptedBytes = [System.Convert]::FromBase64String(\"#{password}\")\n          $Decryptor = $aes.CreateDecryptor()\n          $DecryptedBytes = $Decryptor.TransformFinalBlock($EncryptedBytes,0,$EncryptedBytes.Length)\n          $DecryptedString = [System.Text.Encoding]::Unicode.GetString($DecryptedBytes)\n          return $DecryptedString\n        CODE\n        results = powershell_exec!(powershell_code).result\n      end\n\n      def self.decrypt_pfx_pass_with_password(password_blob)\n        password = \"\"\n        password_blob.each do |secret|\n          password = secret[:data]\n        end",
    "repo_full_name": "chef/chef",
    "discussion_comments": [
      {
        "comment_id": "1099196196",
        "repo_full_name": "chef/chef",
        "pr_number": 13552,
        "pr_file": "lib/chef/http/authenticator.rb",
        "discussion_id": "1099196196",
        "commented_code": "@@ -167,46 +168,79 @@ def self.get_cert_password\n         @win32registry = Chef::Win32::Registry.new\n         path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n         # does the registry key even exist?\n-        present = @win32registry.get_values(path)\n-        if present.nil? || present.empty?\n+        # password_blob should be an array of hashes\n+        password_blob = @win32registry.get_values(path)\n+        if password_blob.nil? || password_blob.empty?\n           raise Chef::Exceptions::Win32RegKeyMissing\n         end\n \n-        present.each do |secret|\n-          if secret[:name] == \"PfxPass\"\n-            password = decrypt_pfx_pass(secret[:data])\n-            return password\n+        # Did someone have just the password stored in the registry?\n+        raw_data = password_blob.map { |x| x[:data] }\n+        vector = raw_data[2]\n+        if !!vector\n+          decrypted_password = decrypt_pfx_pass_with_vector(password_blob)\n+        else\n+          decrypted_password = decrypt_pfx_pass_with_password(password_blob)\n+          if !!decrypted_password\n+            migrate_pass_to_use_vector\n+          else\n+            Chef::Log.error(\"Failed to retrieve certificate password\")\n           end\n         end\n-\n-        raise Chef::Exceptions::Win32RegKeyMissing\n-\n+        decrypted_password\n       rescue Chef::Exceptions::Win32RegKeyMissing\n         # if we don't have a password, log that and generate one\n         Chef::Log.warn \"Authentication Hive and values not present in registry, creating them now\"\n         new_path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n         unless @win32registry.key_exists?(new_path)\n           @win32registry.create_key(new_path, true)\n         end\n-        require \"securerandom\" unless defined?(SecureRandom)\n-        size = 14\n-        password = SecureRandom.alphanumeric(size)\n-        encrypted_pass = encrypt_pfx_pass(password)\n-        values = { name: \"PfxPass\", type: :string, data: encrypted_pass }\n-        @win32registry.set_value(new_path, values)\n+        password = create_and_store_new_password\n         password\n       end\n \n       def self.encrypt_pfx_pass(password)\n         powershell_code = <<~CODE\n-          $encrypted_string = ConvertTo-SecureString \"#{password}\" -AsPlainText -Force\n-          $secure_string = ConvertFrom-SecureString $encrypted_string\n-          return $secure_string\n+          $AES = [System.Security.Cryptography.Aes]::Create()\n+          $key_temp = [System.Convert]::ToBase64String($AES.Key)\n+          $iv_temp = [System.Convert]::ToBase64String($AES.IV)\n+          $encryptor = $AES.CreateEncryptor()\n+          [System.Byte[]]$Bytes =  [System.Text.Encoding]::Unicode.GetBytes(\"#{password}\")\n+          $EncryptedBytes = $encryptor.TransformFinalBlock($Bytes,0,$Bytes.Length)\n+          $EncryptedBase64String = [System.Convert]::ToBase64String($EncryptedBytes)\n+          # create array of encrypted pass, key, iv\n+          $password_blob = @($EncryptedBase64String, $key_temp, $iv_temp)\n+          return $password_blob\n         CODE\n         powershell_exec!(powershell_code).result\n       end\n \n-      def self.decrypt_pfx_pass(password)\n+      def self.decrypt_pfx_pass_with_vector(password_blob)\n+        raw_data = password_blob.map { |x| x[:data] }\n+        password = raw_data[0]\n+        key = raw_data[1]\n+        vector = raw_data[2]\n+\n+        powershell_code = <<~CODE\n+          $KeyBytes = [System.Convert]::FromBase64String(\"#{key}\")\n+          $IVBytes = [System.Convert]::FromBase64String(\"#{vector}\")\n+          $aes = [System.Security.Cryptography.Aes]::Create()\n+          $aes.Key = $KeyBytes\n+          $aes.IV = $IVBytes\n+          $EncryptedBytes = [System.Convert]::FromBase64String(\"#{password}\")\n+          $Decryptor = $aes.CreateDecryptor()\n+          $DecryptedBytes = $Decryptor.TransformFinalBlock($EncryptedBytes,0,$EncryptedBytes.Length)\n+          $DecryptedString = [System.Text.Encoding]::Unicode.GetString($DecryptedBytes)\n+          return $DecryptedString\n+        CODE\n+        results = powershell_exec!(powershell_code).result\n+      end\n+\n+      def self.decrypt_pfx_pass_with_password(password_blob)\n+        password = \"\"\n+        password_blob.each do |secret|\n+          password = secret[:data]\n+        end",
        "comment_created_at": "2023-02-07T20:36:50+00:00",
        "comment_author": "jaymzh",
        "comment_body": "This used  to be (the equivalent of):\r\n```ruby\r\npassword_blob.each do |secret|\r\n  if secret[:name] == \"PfxPass\"\r\n    password = secret[:data]\r\n    break\r\n  end\r\nend\r\n```\r\n\r\nYour code here will, I think, overwrite `password` with non-PfxPass",
        "pr_file_module": null
      },
      {
        "comment_id": "1099616027",
        "repo_full_name": "chef/chef",
        "pr_number": 13552,
        "pr_file": "lib/chef/http/authenticator.rb",
        "discussion_id": "1099196196",
        "commented_code": "@@ -167,46 +168,79 @@ def self.get_cert_password\n         @win32registry = Chef::Win32::Registry.new\n         path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n         # does the registry key even exist?\n-        present = @win32registry.get_values(path)\n-        if present.nil? || present.empty?\n+        # password_blob should be an array of hashes\n+        password_blob = @win32registry.get_values(path)\n+        if password_blob.nil? || password_blob.empty?\n           raise Chef::Exceptions::Win32RegKeyMissing\n         end\n \n-        present.each do |secret|\n-          if secret[:name] == \"PfxPass\"\n-            password = decrypt_pfx_pass(secret[:data])\n-            return password\n+        # Did someone have just the password stored in the registry?\n+        raw_data = password_blob.map { |x| x[:data] }\n+        vector = raw_data[2]\n+        if !!vector\n+          decrypted_password = decrypt_pfx_pass_with_vector(password_blob)\n+        else\n+          decrypted_password = decrypt_pfx_pass_with_password(password_blob)\n+          if !!decrypted_password\n+            migrate_pass_to_use_vector\n+          else\n+            Chef::Log.error(\"Failed to retrieve certificate password\")\n           end\n         end\n-\n-        raise Chef::Exceptions::Win32RegKeyMissing\n-\n+        decrypted_password\n       rescue Chef::Exceptions::Win32RegKeyMissing\n         # if we don't have a password, log that and generate one\n         Chef::Log.warn \"Authentication Hive and values not present in registry, creating them now\"\n         new_path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n         unless @win32registry.key_exists?(new_path)\n           @win32registry.create_key(new_path, true)\n         end\n-        require \"securerandom\" unless defined?(SecureRandom)\n-        size = 14\n-        password = SecureRandom.alphanumeric(size)\n-        encrypted_pass = encrypt_pfx_pass(password)\n-        values = { name: \"PfxPass\", type: :string, data: encrypted_pass }\n-        @win32registry.set_value(new_path, values)\n+        password = create_and_store_new_password\n         password\n       end\n \n       def self.encrypt_pfx_pass(password)\n         powershell_code = <<~CODE\n-          $encrypted_string = ConvertTo-SecureString \"#{password}\" -AsPlainText -Force\n-          $secure_string = ConvertFrom-SecureString $encrypted_string\n-          return $secure_string\n+          $AES = [System.Security.Cryptography.Aes]::Create()\n+          $key_temp = [System.Convert]::ToBase64String($AES.Key)\n+          $iv_temp = [System.Convert]::ToBase64String($AES.IV)\n+          $encryptor = $AES.CreateEncryptor()\n+          [System.Byte[]]$Bytes =  [System.Text.Encoding]::Unicode.GetBytes(\"#{password}\")\n+          $EncryptedBytes = $encryptor.TransformFinalBlock($Bytes,0,$Bytes.Length)\n+          $EncryptedBase64String = [System.Convert]::ToBase64String($EncryptedBytes)\n+          # create array of encrypted pass, key, iv\n+          $password_blob = @($EncryptedBase64String, $key_temp, $iv_temp)\n+          return $password_blob\n         CODE\n         powershell_exec!(powershell_code).result\n       end\n \n-      def self.decrypt_pfx_pass(password)\n+      def self.decrypt_pfx_pass_with_vector(password_blob)\n+        raw_data = password_blob.map { |x| x[:data] }\n+        password = raw_data[0]\n+        key = raw_data[1]\n+        vector = raw_data[2]\n+\n+        powershell_code = <<~CODE\n+          $KeyBytes = [System.Convert]::FromBase64String(\"#{key}\")\n+          $IVBytes = [System.Convert]::FromBase64String(\"#{vector}\")\n+          $aes = [System.Security.Cryptography.Aes]::Create()\n+          $aes.Key = $KeyBytes\n+          $aes.IV = $IVBytes\n+          $EncryptedBytes = [System.Convert]::FromBase64String(\"#{password}\")\n+          $Decryptor = $aes.CreateDecryptor()\n+          $DecryptedBytes = $Decryptor.TransformFinalBlock($EncryptedBytes,0,$EncryptedBytes.Length)\n+          $DecryptedString = [System.Text.Encoding]::Unicode.GetString($DecryptedBytes)\n+          return $DecryptedString\n+        CODE\n+        results = powershell_exec!(powershell_code).result\n+      end\n+\n+      def self.decrypt_pfx_pass_with_password(password_blob)\n+        password = \"\"\n+        password_blob.each do |secret|\n+          password = secret[:data]\n+        end",
        "comment_created_at": "2023-02-08T03:31:37+00:00",
        "comment_author": "johnmccrae",
        "comment_body": "For extra protection, I am using the old technique to ensure I am actually grabbing only the PfxPass detail",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1099199876",
    "pr_number": 13552,
    "pr_file": "lib/chef/http/authenticator.rb",
    "created_at": "2023-02-07T20:38:46+00:00",
    "commented_code": "powershell_exec!(powershell_code).result\n      end\n\n      def self.retrieve_certificate_key(client_name)\n        require \"openssl\" unless defined?(OpenSSL)\n      def self.migrate_pass_to_use_vector\n        powershell_code = <<~CODE\n          Remove-ItemProperty -Path \"HKLM:\\\\Software\\\\Progress\\\\Authentication\" -Name \"PfXPass\"\n        CODE\n        powershell_exec!(powershell_code)\n        create_and_store_new_password\n      end\n\n      def self.create_and_store_new_password\n        @win32registry = Chef::Win32::Registry.new\n        path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n        require \"securerandom\" unless defined?(SecureRandom)\n        size = 14\n        password = SecureRandom.alphanumeric(size)\n        encrypted_blob = encrypt_pfx_pass(password)",
    "repo_full_name": "chef/chef",
    "discussion_comments": [
      {
        "comment_id": "1099199876",
        "repo_full_name": "chef/chef",
        "pr_number": 13552,
        "pr_file": "lib/chef/http/authenticator.rb",
        "discussion_id": "1099199876",
        "commented_code": "@@ -215,10 +249,38 @@ def self.decrypt_pfx_pass(password)\n         powershell_exec!(powershell_code).result\n       end\n \n-      def self.retrieve_certificate_key(client_name)\n-        require \"openssl\" unless defined?(OpenSSL)\n+      def self.migrate_pass_to_use_vector\n+        powershell_code = <<~CODE\n+          Remove-ItemProperty -Path \"HKLM:\\\\Software\\\\Progress\\\\Authentication\" -Name \"PfXPass\"\n+        CODE\n+        powershell_exec!(powershell_code)\n+        create_and_store_new_password\n+      end\n \n+      def self.create_and_store_new_password\n+        @win32registry = Chef::Win32::Registry.new\n+        path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n+        require \"securerandom\" unless defined?(SecureRandom)\n+        size = 14\n+        password = SecureRandom.alphanumeric(size)\n+        encrypted_blob = encrypt_pfx_pass(password)",
        "comment_created_at": "2023-02-07T20:38:46+00:00",
        "comment_author": "jaymzh",
        "comment_body": "Shouldn't we want to use the same password here from when it was an encrypted string? Isn't that what the key is encrypted with? If we make a new one, we just break the users' ability to use their key? Perhaps I'm mis-reading something, but it feels like we should just properly encrypted the existing password.",
        "pr_file_module": null
      },
      {
        "comment_id": "1099679312",
        "repo_full_name": "chef/chef",
        "pr_number": 13552,
        "pr_file": "lib/chef/http/authenticator.rb",
        "discussion_id": "1099199876",
        "commented_code": "@@ -215,10 +249,38 @@ def self.decrypt_pfx_pass(password)\n         powershell_exec!(powershell_code).result\n       end\n \n-      def self.retrieve_certificate_key(client_name)\n-        require \"openssl\" unless defined?(OpenSSL)\n+      def self.migrate_pass_to_use_vector\n+        powershell_code = <<~CODE\n+          Remove-ItemProperty -Path \"HKLM:\\\\Software\\\\Progress\\\\Authentication\" -Name \"PfXPass\"\n+        CODE\n+        powershell_exec!(powershell_code)\n+        create_and_store_new_password\n+      end\n \n+      def self.create_and_store_new_password\n+        @win32registry = Chef::Win32::Registry.new\n+        path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n+        require \"securerandom\" unless defined?(SecureRandom)\n+        size = 14\n+        password = SecureRandom.alphanumeric(size)\n+        encrypted_blob = encrypt_pfx_pass(password)",
        "comment_created_at": "2023-02-08T05:41:15+00:00",
        "comment_author": "johnmccrae",
        "comment_body": "The problem I am having here is that the old password was created using ConvertTo-SecureString which is user dependent (since no AES Key is used, it uses DPAPI which is user specific). I'll ensure that there are no paths that can lead to a busted password.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "823233225",
    "pr_number": 12640,
    "pr_file": "lib/chef/client.rb",
    "created_at": "2022-03-10T00:44:59+00:00",
    "commented_code": "raise\n    end\n\n    #\n    # In the brave new world of No Certs On Disk, we want to put the pem file into Keychain or the Certstore\n    # But is it already there?\n    def check_certstore_for_key(cert_name)\n      require \"win32-certstore\"\n      win32certstore = ::Win32::Certstore.open(\"MY\")\n      win32certstore.search(\"#{cert_name}\")\n    end\n\n    def generate_pfx_package(cert_name, date = nil)\n      require_relative \"mixin/powershell_exec\"\n      extend Chef::Mixin::PowershellExec\n      ::Chef::HTTP::Authenticator.get_cert_password\n      powershell_code = <<~EOH\n\n        $date = \"#{date}\"\n\n        $certSplat = @{\n            Subject = \"#{cert_name}\"\n            KeyExportPolicy = 'Exportable'\n            KeyUsage = @('KeyEncipherment','DigitalSignature')\n            CertStoreLocation = 'Cert:\\\\LocalMachine\\\\My'\n            TextExtension = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\")\n        };\n        if ([string]$date -as [DateTime]){\n          $certSplat.add('NotAfter', $date)\n        }\n\n        New-SelfSignedCertificate @certSplat;\n      EOH\n      powershell_exec!(powershell_code)\n    end\n\n    def move_key_and_register(cert_name)\n      require \"time\" unless defined?(Time)\n      autoload :URI, \"uri\"\n\n      KeyMigration.instance.key_migrated = true\n\n      node = Chef::Config[:node_name]\n      d = Time.now\n      end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601\n\n      payload = {\n        name: node,\n        clientname: node,\n        public_key: \"\",\n        expiration_date: end_date,\n      }\n\n      generate_pfx_package(cert_name, end_date)\n      payload[:public_key] = get_public_key(cert_name)\n      base_url = \"#{Chef::Config[:chef_server_url]}\"\n      client = Chef::ServerAPI.new(base_url, client_name: Chef::Config[:validation_client_name], signing_key_filename: Chef::Config[:validation_key])\n      client.post(base_url + \"/clients\", payload)\n      KeyMigration.instance.key_migrated = false",
    "repo_full_name": "chef/chef",
    "discussion_comments": [
      {
        "comment_id": "823233225",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/client.rb",
        "discussion_id": "823233225",
        "commented_code": "@@ -665,6 +683,83 @@ def register(client_name = node_name, config = Chef::Config)\n       raise\n     end\n \n+    #\n+    # In the brave new world of No Certs On Disk, we want to put the pem file into Keychain or the Certstore\n+    # But is it already there?\n+    def check_certstore_for_key(cert_name)\n+      require \"win32-certstore\"\n+      win32certstore = ::Win32::Certstore.open(\"MY\")\n+      win32certstore.search(\"#{cert_name}\")\n+    end\n+\n+    def generate_pfx_package(cert_name, date = nil)\n+      require_relative \"mixin/powershell_exec\"\n+      extend Chef::Mixin::PowershellExec\n+      ::Chef::HTTP::Authenticator.get_cert_password\n+      powershell_code = <<~EOH\n+\n+        $date = \"#{date}\"\n+\n+        $certSplat = @{\n+            Subject = \"#{cert_name}\"\n+            KeyExportPolicy = 'Exportable'\n+            KeyUsage = @('KeyEncipherment','DigitalSignature')\n+            CertStoreLocation = 'Cert:\\\\LocalMachine\\\\My'\n+            TextExtension = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\")\n+        };\n+        if ([string]$date -as [DateTime]){\n+          $certSplat.add('NotAfter', $date)\n+        }\n+\n+        New-SelfSignedCertificate @certSplat;\n+      EOH\n+      powershell_exec!(powershell_code)\n+    end\n+\n+    def move_key_and_register(cert_name)\n+      require \"time\" unless defined?(Time)\n+      autoload :URI, \"uri\"\n+\n+      KeyMigration.instance.key_migrated = true\n+\n+      node = Chef::Config[:node_name]\n+      d = Time.now\n+      end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601\n+\n+      payload = {\n+        name: node,\n+        clientname: node,\n+        public_key: \"\",\n+        expiration_date: end_date,\n+      }\n+\n+      generate_pfx_package(cert_name, end_date)\n+      payload[:public_key] = get_public_key(cert_name)\n+      base_url = \"#{Chef::Config[:chef_server_url]}\"\n+      client = Chef::ServerAPI.new(base_url, client_name: Chef::Config[:validation_client_name], signing_key_filename: Chef::Config[:validation_key])\n+      client.post(base_url + \"/clients\", payload)\n+      KeyMigration.instance.key_migrated = false",
        "comment_created_at": "2022-03-10T00:44:59+00:00",
        "comment_author": "mwrock",
        "comment_body": "Not clear why you are setting to `false`. Didn't the key just get migrated?",
        "pr_file_module": null
      },
      {
        "comment_id": "826446240",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/client.rb",
        "discussion_id": "823233225",
        "commented_code": "@@ -665,6 +683,83 @@ def register(client_name = node_name, config = Chef::Config)\n       raise\n     end\n \n+    #\n+    # In the brave new world of No Certs On Disk, we want to put the pem file into Keychain or the Certstore\n+    # But is it already there?\n+    def check_certstore_for_key(cert_name)\n+      require \"win32-certstore\"\n+      win32certstore = ::Win32::Certstore.open(\"MY\")\n+      win32certstore.search(\"#{cert_name}\")\n+    end\n+\n+    def generate_pfx_package(cert_name, date = nil)\n+      require_relative \"mixin/powershell_exec\"\n+      extend Chef::Mixin::PowershellExec\n+      ::Chef::HTTP::Authenticator.get_cert_password\n+      powershell_code = <<~EOH\n+\n+        $date = \"#{date}\"\n+\n+        $certSplat = @{\n+            Subject = \"#{cert_name}\"\n+            KeyExportPolicy = 'Exportable'\n+            KeyUsage = @('KeyEncipherment','DigitalSignature')\n+            CertStoreLocation = 'Cert:\\\\LocalMachine\\\\My'\n+            TextExtension = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\")\n+        };\n+        if ([string]$date -as [DateTime]){\n+          $certSplat.add('NotAfter', $date)\n+        }\n+\n+        New-SelfSignedCertificate @certSplat;\n+      EOH\n+      powershell_exec!(powershell_code)\n+    end\n+\n+    def move_key_and_register(cert_name)\n+      require \"time\" unless defined?(Time)\n+      autoload :URI, \"uri\"\n+\n+      KeyMigration.instance.key_migrated = true\n+\n+      node = Chef::Config[:node_name]\n+      d = Time.now\n+      end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601\n+\n+      payload = {\n+        name: node,\n+        clientname: node,\n+        public_key: \"\",\n+        expiration_date: end_date,\n+      }\n+\n+      generate_pfx_package(cert_name, end_date)\n+      payload[:public_key] = get_public_key(cert_name)\n+      base_url = \"#{Chef::Config[:chef_server_url]}\"\n+      client = Chef::ServerAPI.new(base_url, client_name: Chef::Config[:validation_client_name], signing_key_filename: Chef::Config[:validation_key])\n+      client.post(base_url + \"/clients\", payload)\n+      KeyMigration.instance.key_migrated = false",
        "comment_created_at": "2022-03-14T22:59:06+00:00",
        "comment_author": "johnmccrae",
        "comment_body": "So what happens at the top of that method is that I set the flag Keymigration to True - Line 739 executes and calls code in Authenticator.rb to load the pem file needed to build the headers for the client object. In this case, I need to validator so code in authenticator sees the Keymigraiton flag and hands me back the validator pem. On line 740 I update the chef server with the new key for the client. I now need the chef client to connect with the new cert I stuffed into the Certstore (line 738 generate_pfx_package) so I set the Keymigraiton flag back to false to prevent the Load_Signing_key code in authenticator from handing me back the validator pem when the client goes on to run a CCR",
        "pr_file_module": null
      },
      {
        "comment_id": "827295020",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/client.rb",
        "discussion_id": "823233225",
        "commented_code": "@@ -665,6 +683,83 @@ def register(client_name = node_name, config = Chef::Config)\n       raise\n     end\n \n+    #\n+    # In the brave new world of No Certs On Disk, we want to put the pem file into Keychain or the Certstore\n+    # But is it already there?\n+    def check_certstore_for_key(cert_name)\n+      require \"win32-certstore\"\n+      win32certstore = ::Win32::Certstore.open(\"MY\")\n+      win32certstore.search(\"#{cert_name}\")\n+    end\n+\n+    def generate_pfx_package(cert_name, date = nil)\n+      require_relative \"mixin/powershell_exec\"\n+      extend Chef::Mixin::PowershellExec\n+      ::Chef::HTTP::Authenticator.get_cert_password\n+      powershell_code = <<~EOH\n+\n+        $date = \"#{date}\"\n+\n+        $certSplat = @{\n+            Subject = \"#{cert_name}\"\n+            KeyExportPolicy = 'Exportable'\n+            KeyUsage = @('KeyEncipherment','DigitalSignature')\n+            CertStoreLocation = 'Cert:\\\\LocalMachine\\\\My'\n+            TextExtension = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\")\n+        };\n+        if ([string]$date -as [DateTime]){\n+          $certSplat.add('NotAfter', $date)\n+        }\n+\n+        New-SelfSignedCertificate @certSplat;\n+      EOH\n+      powershell_exec!(powershell_code)\n+    end\n+\n+    def move_key_and_register(cert_name)\n+      require \"time\" unless defined?(Time)\n+      autoload :URI, \"uri\"\n+\n+      KeyMigration.instance.key_migrated = true\n+\n+      node = Chef::Config[:node_name]\n+      d = Time.now\n+      end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601\n+\n+      payload = {\n+        name: node,\n+        clientname: node,\n+        public_key: \"\",\n+        expiration_date: end_date,\n+      }\n+\n+      generate_pfx_package(cert_name, end_date)\n+      payload[:public_key] = get_public_key(cert_name)\n+      base_url = \"#{Chef::Config[:chef_server_url]}\"\n+      client = Chef::ServerAPI.new(base_url, client_name: Chef::Config[:validation_client_name], signing_key_filename: Chef::Config[:validation_key])\n+      client.post(base_url + \"/clients\", payload)\n+      KeyMigration.instance.key_migrated = false",
        "comment_created_at": "2022-03-15T18:31:18+00:00",
        "comment_author": "mwrock",
        "comment_body": "I'd suggest not storing the new key in `Cert:\\\\LocalMachine\\\\My` when you first create it. I'd either create one with openssl to avoid the certstore or store in current user. Then after the client post, migrate the key to `Cert:\\\\LocalMachine\\\\My`",
        "pr_file_module": null
      },
      {
        "comment_id": "827296110",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/client.rb",
        "discussion_id": "823233225",
        "commented_code": "@@ -665,6 +683,83 @@ def register(client_name = node_name, config = Chef::Config)\n       raise\n     end\n \n+    #\n+    # In the brave new world of No Certs On Disk, we want to put the pem file into Keychain or the Certstore\n+    # But is it already there?\n+    def check_certstore_for_key(cert_name)\n+      require \"win32-certstore\"\n+      win32certstore = ::Win32::Certstore.open(\"MY\")\n+      win32certstore.search(\"#{cert_name}\")\n+    end\n+\n+    def generate_pfx_package(cert_name, date = nil)\n+      require_relative \"mixin/powershell_exec\"\n+      extend Chef::Mixin::PowershellExec\n+      ::Chef::HTTP::Authenticator.get_cert_password\n+      powershell_code = <<~EOH\n+\n+        $date = \"#{date}\"\n+\n+        $certSplat = @{\n+            Subject = \"#{cert_name}\"\n+            KeyExportPolicy = 'Exportable'\n+            KeyUsage = @('KeyEncipherment','DigitalSignature')\n+            CertStoreLocation = 'Cert:\\\\LocalMachine\\\\My'\n+            TextExtension = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\")\n+        };\n+        if ([string]$date -as [DateTime]){\n+          $certSplat.add('NotAfter', $date)\n+        }\n+\n+        New-SelfSignedCertificate @certSplat;\n+      EOH\n+      powershell_exec!(powershell_code)\n+    end\n+\n+    def move_key_and_register(cert_name)\n+      require \"time\" unless defined?(Time)\n+      autoload :URI, \"uri\"\n+\n+      KeyMigration.instance.key_migrated = true\n+\n+      node = Chef::Config[:node_name]\n+      d = Time.now\n+      end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601\n+\n+      payload = {\n+        name: node,\n+        clientname: node,\n+        public_key: \"\",\n+        expiration_date: end_date,\n+      }\n+\n+      generate_pfx_package(cert_name, end_date)\n+      payload[:public_key] = get_public_key(cert_name)\n+      base_url = \"#{Chef::Config[:chef_server_url]}\"\n+      client = Chef::ServerAPI.new(base_url, client_name: Chef::Config[:validation_client_name], signing_key_filename: Chef::Config[:validation_key])\n+      client.post(base_url + \"/clients\", payload)\n+      KeyMigration.instance.key_migrated = false",
        "comment_created_at": "2022-03-15T18:32:38+00:00",
        "comment_author": "mwrock",
        "comment_body": "This would eliminate the need for a static `key_migrated` flag which feels fragile and confusing.",
        "pr_file_module": null
      },
      {
        "comment_id": "831624108",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/client.rb",
        "discussion_id": "823233225",
        "commented_code": "@@ -665,6 +683,83 @@ def register(client_name = node_name, config = Chef::Config)\n       raise\n     end\n \n+    #\n+    # In the brave new world of No Certs On Disk, we want to put the pem file into Keychain or the Certstore\n+    # But is it already there?\n+    def check_certstore_for_key(cert_name)\n+      require \"win32-certstore\"\n+      win32certstore = ::Win32::Certstore.open(\"MY\")\n+      win32certstore.search(\"#{cert_name}\")\n+    end\n+\n+    def generate_pfx_package(cert_name, date = nil)\n+      require_relative \"mixin/powershell_exec\"\n+      extend Chef::Mixin::PowershellExec\n+      ::Chef::HTTP::Authenticator.get_cert_password\n+      powershell_code = <<~EOH\n+\n+        $date = \"#{date}\"\n+\n+        $certSplat = @{\n+            Subject = \"#{cert_name}\"\n+            KeyExportPolicy = 'Exportable'\n+            KeyUsage = @('KeyEncipherment','DigitalSignature')\n+            CertStoreLocation = 'Cert:\\\\LocalMachine\\\\My'\n+            TextExtension = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\")\n+        };\n+        if ([string]$date -as [DateTime]){\n+          $certSplat.add('NotAfter', $date)\n+        }\n+\n+        New-SelfSignedCertificate @certSplat;\n+      EOH\n+      powershell_exec!(powershell_code)\n+    end\n+\n+    def move_key_and_register(cert_name)\n+      require \"time\" unless defined?(Time)\n+      autoload :URI, \"uri\"\n+\n+      KeyMigration.instance.key_migrated = true\n+\n+      node = Chef::Config[:node_name]\n+      d = Time.now\n+      end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601\n+\n+      payload = {\n+        name: node,\n+        clientname: node,\n+        public_key: \"\",\n+        expiration_date: end_date,\n+      }\n+\n+      generate_pfx_package(cert_name, end_date)\n+      payload[:public_key] = get_public_key(cert_name)\n+      base_url = \"#{Chef::Config[:chef_server_url]}\"\n+      client = Chef::ServerAPI.new(base_url, client_name: Chef::Config[:validation_client_name], signing_key_filename: Chef::Config[:validation_key])\n+      client.post(base_url + \"/clients\", payload)\n+      KeyMigration.instance.key_migrated = false",
        "comment_created_at": "2022-03-21T23:34:03+00:00",
        "comment_author": "johnmccrae",
        "comment_body": "This makes a lot more sense. ",
        "pr_file_module": null
      },
      {
        "comment_id": "833469005",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/client.rb",
        "discussion_id": "823233225",
        "commented_code": "@@ -665,6 +683,83 @@ def register(client_name = node_name, config = Chef::Config)\n       raise\n     end\n \n+    #\n+    # In the brave new world of No Certs On Disk, we want to put the pem file into Keychain or the Certstore\n+    # But is it already there?\n+    def check_certstore_for_key(cert_name)\n+      require \"win32-certstore\"\n+      win32certstore = ::Win32::Certstore.open(\"MY\")\n+      win32certstore.search(\"#{cert_name}\")\n+    end\n+\n+    def generate_pfx_package(cert_name, date = nil)\n+      require_relative \"mixin/powershell_exec\"\n+      extend Chef::Mixin::PowershellExec\n+      ::Chef::HTTP::Authenticator.get_cert_password\n+      powershell_code = <<~EOH\n+\n+        $date = \"#{date}\"\n+\n+        $certSplat = @{\n+            Subject = \"#{cert_name}\"\n+            KeyExportPolicy = 'Exportable'\n+            KeyUsage = @('KeyEncipherment','DigitalSignature')\n+            CertStoreLocation = 'Cert:\\\\LocalMachine\\\\My'\n+            TextExtension = @(\"2.5.29.37={text}1.3.6.1.5.5.7.3.2,1.3.6.1.5.5.7.3.1\")\n+        };\n+        if ([string]$date -as [DateTime]){\n+          $certSplat.add('NotAfter', $date)\n+        }\n+\n+        New-SelfSignedCertificate @certSplat;\n+      EOH\n+      powershell_exec!(powershell_code)\n+    end\n+\n+    def move_key_and_register(cert_name)\n+      require \"time\" unless defined?(Time)\n+      autoload :URI, \"uri\"\n+\n+      KeyMigration.instance.key_migrated = true\n+\n+      node = Chef::Config[:node_name]\n+      d = Time.now\n+      end_date = Time.new(d.year, d.month + 3, d.day, d.hour, d.min, d.sec).utc.iso8601\n+\n+      payload = {\n+        name: node,\n+        clientname: node,\n+        public_key: \"\",\n+        expiration_date: end_date,\n+      }\n+\n+      generate_pfx_package(cert_name, end_date)\n+      payload[:public_key] = get_public_key(cert_name)\n+      base_url = \"#{Chef::Config[:chef_server_url]}\"\n+      client = Chef::ServerAPI.new(base_url, client_name: Chef::Config[:validation_client_name], signing_key_filename: Chef::Config[:validation_key])\n+      client.post(base_url + \"/clients\", payload)\n+      KeyMigration.instance.key_migrated = false",
        "comment_created_at": "2022-03-23T16:22:04+00:00",
        "comment_author": "johnmccrae",
        "comment_body": "Done and working and it makes we more sense now and I got rid of the Singleton class at the top too ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "827353584",
    "pr_number": 12640,
    "pr_file": "lib/chef/http/authenticator.rb",
    "created_at": "2022-03-15T19:48:11+00:00",
    "commented_code": "present.each do |secret|\n          if secret[:name] == \"PfxPass\"\n            return secret[:data]\n            password = decrypt_pfx_pass(secret[:data])\n            return password\n          end\n        end\n\n        # if we make it this far, that means there is no valid password in the Registry. Fail out to correct that.\n        raise Chef::Exceptions::Win32RegKeyMissing\n\n      rescue Chef::Exceptions::Win32RegKeyMissing\n        # if we don't have a password, log that and generate one\n        Chef::Log.warn \"Authentication Hive and value not present in registry, creating it now\"\n        Chef::Log.warn \"Authentication Hive and values not present in registry, creating them now\"\n        new_path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n        unless @win32registry.key_exists?(new_path)\n          @win32registry.create_key(new_path, true)\n        end\n        password = SOME_CHARS.sample(1 + rand(SOME_CHARS.count)).join[0...14]\n        values = { name: \"PfxPass\", type: :string, data: password }\n        encrypted_pass = encrypt_pfx_pass(password)\n        values = { name: \"PfxPass\", type: :string, data: encrypted_pass }\n        @win32registry.set_value(new_path, values)\n        password\n      end\n\n      def self.encrypt_pfx_pass(password)\n        powershell_code = <<~CODE",
    "repo_full_name": "chef/chef",
    "discussion_comments": [
      {
        "comment_id": "827353584",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/http/authenticator.rb",
        "discussion_id": "827353584",
        "commented_code": "@@ -166,60 +178,85 @@ def self.get_cert_password\n \n         present.each do |secret|\n           if secret[:name] == \"PfxPass\"\n-            return secret[:data]\n+            password = decrypt_pfx_pass(secret[:data])\n+            return password\n           end\n         end\n \n-        # if we make it this far, that means there is no valid password in the Registry. Fail out to correct that.\n         raise Chef::Exceptions::Win32RegKeyMissing\n \n       rescue Chef::Exceptions::Win32RegKeyMissing\n         # if we don't have a password, log that and generate one\n-        Chef::Log.warn \"Authentication Hive and value not present in registry, creating it now\"\n+        Chef::Log.warn \"Authentication Hive and values not present in registry, creating them now\"\n         new_path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n         unless @win32registry.key_exists?(new_path)\n           @win32registry.create_key(new_path, true)\n         end\n         password = SOME_CHARS.sample(1 + rand(SOME_CHARS.count)).join[0...14]\n-        values = { name: \"PfxPass\", type: :string, data: password }\n+        encrypted_pass = encrypt_pfx_pass(password)\n+        values = { name: \"PfxPass\", type: :string, data: encrypted_pass }\n         @win32registry.set_value(new_path, values)\n         password\n       end\n \n+      def self.encrypt_pfx_pass(password)\n+        powershell_code = <<~CODE",
        "comment_created_at": "2022-03-15T19:48:11+00:00",
        "comment_author": "mwrock",
        "comment_body": "I'd use `Chef::ReservedNames::Win32::Crypto.encrypt(str)` for this. You would want to add a `decrypt` method.",
        "pr_file_module": null
      },
      {
        "comment_id": "833549896",
        "repo_full_name": "chef/chef",
        "pr_number": 12640,
        "pr_file": "lib/chef/http/authenticator.rb",
        "discussion_id": "827353584",
        "commented_code": "@@ -166,60 +178,85 @@ def self.get_cert_password\n \n         present.each do |secret|\n           if secret[:name] == \"PfxPass\"\n-            return secret[:data]\n+            password = decrypt_pfx_pass(secret[:data])\n+            return password\n           end\n         end\n \n-        # if we make it this far, that means there is no valid password in the Registry. Fail out to correct that.\n         raise Chef::Exceptions::Win32RegKeyMissing\n \n       rescue Chef::Exceptions::Win32RegKeyMissing\n         # if we don't have a password, log that and generate one\n-        Chef::Log.warn \"Authentication Hive and value not present in registry, creating it now\"\n+        Chef::Log.warn \"Authentication Hive and values not present in registry, creating them now\"\n         new_path = \"HKEY_LOCAL_MACHINE\\\\Software\\\\Progress\\\\Authentication\"\n         unless @win32registry.key_exists?(new_path)\n           @win32registry.create_key(new_path, true)\n         end\n         password = SOME_CHARS.sample(1 + rand(SOME_CHARS.count)).join[0...14]\n-        values = { name: \"PfxPass\", type: :string, data: password }\n+        encrypted_pass = encrypt_pfx_pass(password)\n+        values = { name: \"PfxPass\", type: :string, data: encrypted_pass }\n         @win32registry.set_value(new_path, values)\n         password\n       end\n \n+      def self.encrypt_pfx_pass(password)\n+        powershell_code = <<~CODE",
        "comment_created_at": "2022-03-23T17:37:35+00:00",
        "comment_author": "johnmccrae",
        "comment_body": "As discussed, I am punting for now since the ReservedNames code is interchangeable with the PowerShell approach. Taking a backlog item to do that work",
        "pr_file_module": null
      }
    ]
  }
]
