[
  {
    "discussion_id": "1153145331",
    "pr_number": 4496,
    "pr_file": "cliv2/cmd/cliv2/main.go",
    "created_at": "2023-03-30T11:52:25+00:00",
    "commented_code": "commandError := strings.Contains(errString, unknownCommandMessage)\n \n \t\t// filter for known cobra errors, since cobra errors shall trigger a fallback, but not others.\n-\t\tif commandError || flagError {\n-\t\t\tfallback = true\n+\t\tif commandError {\n+\t\t\tresultError = handleErrorFallbackToLegacyCLI\n+\t\t} else if flagError {\n+\t\t\tresultError = handleErrorShowHelp",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1153145331",
        "repo_full_name": "snyk/cli",
        "pr_number": 4496,
        "pr_file": "cliv2/cmd/cliv2/main.go",
        "discussion_id": "1153145331",
        "commented_code": "@@ -219,12 +238,14 @@ func doFallback(err error) (fallback bool) {\n \t\tcommandError := strings.Contains(errString, unknownCommandMessage)\n \n \t\t// filter for known cobra errors, since cobra errors shall trigger a fallback, but not others.\n-\t\tif commandError || flagError {\n-\t\t\tfallback = true\n+\t\tif commandError {\n+\t\t\tresultError = handleErrorFallbackToLegacyCLI\n+\t\t} else if flagError {\n+\t\t\tresultError = handleErrorShowHelp",
        "comment_created_at": "2023-03-30T11:52:25+00:00",
        "comment_author": "michelkaporin",
        "comment_body": "It'd be great to comment why flag error is always a case to show help. \r\n\r\nSomething along the lines: \"Cobra has it's own help mechanism, however since we have help documentation only in legacy cli, we should fallback to calling it.\"",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "926810828",
    "pr_number": 3430,
    "pr_file": "cliv2/internal/httpauth/proxy_authenticator.go",
    "created_at": "2022-07-21T15:17:28+00:00",
    "commented_code": "+package httpauth\n+\n+import (\n+\t\"bufio\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/url\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"golang.org/x/net/idna\"\n+)\n+\n+type ProxyAuthenticator struct {\n+\tacceptedProxyAuthMechanism AuthenticationMechanism\n+\tdebugLogger                *log.Logger\n+\tupstreamProxy              func(*http.Request) (*url.URL, error)\n+}\n+\n+func NewProxyAuthenticator(mechanism AuthenticationMechanism, upstreamProxy func(*http.Request) (*url.URL, error), logger *log.Logger) *ProxyAuthenticator {\n+\tauthenticator := &ProxyAuthenticator{\n+\t\tacceptedProxyAuthMechanism: mechanism,\n+\t\tdebugLogger:                logger,\n+\t\tupstreamProxy:              upstreamProxy,\n+\t}\n+\treturn authenticator\n+}\n+\n+// This is the main entry point function for the ProxyAuthenticator when being used with http.Transport.\n+// It should be used like this: transport.DialContext = GetDialContext\n+// It'll be invoked by http.Transport when it requires a new TCP connection.\n+func (p *ProxyAuthenticator) GetDialContext(ctx context.Context, network, addr string) (net.Conn, error) {\n+\tvar connection net.Conn\n+\tvar err error\n+\tvar proxyUrl *url.URL\n+\n+\tfakeRequest := &http.Request{URL: &url.URL{}}\n+\tfakeRequest.URL.Scheme = LookupSchemeFromCannonicalAddress(addr, \"https\")\n+\tproxyUrl, err = p.upstreamProxy(fakeRequest)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif proxyUrl != nil {\n+\t\tproxyAddr := CanonicalAddr(proxyUrl)\n+\t\tconnection, err = net.Dial(network, proxyAddr)\n+\t\tif err == nil {\n+\t\t\terr = p.ConnectToProxy(ctx, proxyUrl, addr, connection)\n+\t\t}\n+\n+\t\tif err != nil {\n+\t\t\tfmt.Println(\"Failed to connect to Proxy! \", proxyUrl)\n+\t\t\tif connection != nil {\n+\t\t\t\tconnection.Close()\n+\t\t\t\tconnection = nil\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tp.debugLogger.Println(\"No Proxy defined for \", addr, \"!\")\n+\t\tconnection, err = net.Dial(network, addr)\n+\t}\n+\n+\treturn connection, err\n+}\n+\n+func (p *ProxyAuthenticator) ConnectToProxy(ctx context.Context, proxyURL *url.URL, target string, connection net.Conn) error {",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "926810828",
        "repo_full_name": "snyk/cli",
        "pr_number": 3430,
        "pr_file": "cliv2/internal/httpauth/proxy_authenticator.go",
        "discussion_id": "926810828",
        "commented_code": "@@ -0,0 +1,271 @@\n+package httpauth\n+\n+import (\n+\t\"bufio\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"net\"\n+\t\"net/http\"\n+\t\"net/url\"\n+\t\"strings\"\n+\t\"time\"\n+\n+\t\"golang.org/x/net/idna\"\n+)\n+\n+type ProxyAuthenticator struct {\n+\tacceptedProxyAuthMechanism AuthenticationMechanism\n+\tdebugLogger                *log.Logger\n+\tupstreamProxy              func(*http.Request) (*url.URL, error)\n+}\n+\n+func NewProxyAuthenticator(mechanism AuthenticationMechanism, upstreamProxy func(*http.Request) (*url.URL, error), logger *log.Logger) *ProxyAuthenticator {\n+\tauthenticator := &ProxyAuthenticator{\n+\t\tacceptedProxyAuthMechanism: mechanism,\n+\t\tdebugLogger:                logger,\n+\t\tupstreamProxy:              upstreamProxy,\n+\t}\n+\treturn authenticator\n+}\n+\n+// This is the main entry point function for the ProxyAuthenticator when being used with http.Transport.\n+// It should be used like this: transport.DialContext = GetDialContext\n+// It'll be invoked by http.Transport when it requires a new TCP connection.\n+func (p *ProxyAuthenticator) GetDialContext(ctx context.Context, network, addr string) (net.Conn, error) {\n+\tvar connection net.Conn\n+\tvar err error\n+\tvar proxyUrl *url.URL\n+\n+\tfakeRequest := &http.Request{URL: &url.URL{}}\n+\tfakeRequest.URL.Scheme = LookupSchemeFromCannonicalAddress(addr, \"https\")\n+\tproxyUrl, err = p.upstreamProxy(fakeRequest)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tif proxyUrl != nil {\n+\t\tproxyAddr := CanonicalAddr(proxyUrl)\n+\t\tconnection, err = net.Dial(network, proxyAddr)\n+\t\tif err == nil {\n+\t\t\terr = p.ConnectToProxy(ctx, proxyUrl, addr, connection)\n+\t\t}\n+\n+\t\tif err != nil {\n+\t\t\tfmt.Println(\"Failed to connect to Proxy! \", proxyUrl)\n+\t\t\tif connection != nil {\n+\t\t\t\tconnection.Close()\n+\t\t\t\tconnection = nil\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tp.debugLogger.Println(\"No Proxy defined for \", addr, \"!\")\n+\t\tconnection, err = net.Dial(network, addr)\n+\t}\n+\n+\treturn connection, err\n+}\n+\n+func (p *ProxyAuthenticator) ConnectToProxy(ctx context.Context, proxyURL *url.URL, target string, connection net.Conn) error {",
        "comment_created_at": "2022-07-21T15:17:28+00:00",
        "comment_author": "maxjeffos",
        "comment_body": "polish: I would appreciate a method comment here explaining what this does at a high level",
        "pr_file_module": null
      }
    ]
  }
]