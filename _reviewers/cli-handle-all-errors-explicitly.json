[
  {
    "discussion_id": "1876061732",
    "pr_number": 5605,
    "pr_file": "cliv2/internal/proxy/proxy.go",
    "created_at": "2024-12-09T14:21:41+00:00",
    "commented_code": "if authFailed := resp.Request.Header.Get(headerSnykAuthFailed); authFailed != \"\" {\n \t\t\tresp.Header.Set(headerSnykAuthFailed, authFailed)\n \t\t}\n+\n+\t\terr := middleware.HandleResponse(resp, p.config)\n+\t\tif err != nil && p.errHandlerFunc != nil {\n+\t\t\tresp.Header.Set(headerSnykTerminate, \"true\")\n+\t\t\tp.errHandlerFunc(err, resp.Request.Context())",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1876061732",
        "repo_full_name": "snyk/cli",
        "pr_number": 5605,
        "pr_file": "cliv2/internal/proxy/proxy.go",
        "discussion_id": "1876061732",
        "commented_code": "@@ -221,6 +228,13 @@ func (p *WrapperProxy) Start() error {\n \t\tif authFailed := resp.Request.Header.Get(headerSnykAuthFailed); authFailed != \"\" {\n \t\t\tresp.Header.Set(headerSnykAuthFailed, authFailed)\n \t\t}\n+\n+\t\terr := middleware.HandleResponse(resp, p.config)\n+\t\tif err != nil && p.errHandlerFunc != nil {\n+\t\t\tresp.Header.Set(headerSnykTerminate, \"true\")\n+\t\t\tp.errHandlerFunc(err, resp.Request.Context())",
        "comment_created_at": "2024-12-09T14:21:41+00:00",
        "comment_author": "PeterSchafer",
        "comment_body": "Issue: Mimicking the gaf network stack behaviour, we need to use the error returned from the errorhandler and only if this error is not nil set the terminate header.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1861980779",
    "pr_number": 5604,
    "pr_file": "cliv2/cmd/cliv2/logheader.go",
    "created_at": "2024-11-28T11:02:45+00:00",
    "commented_code": "tablePrint(\"Version\", cliv2.GetFullVersion()+\" \"+buildType)\n \ttablePrint(\"Platform\", userAgent)\n \ttablePrint(\"API\", config.GetString(configuration.API_URL))\n+\n+\tregion, err := localworkflows.DetermineRegionFromUrl(config.GetString(configuration.API_URL))",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1861980779",
        "repo_full_name": "snyk/cli",
        "pr_number": 5604,
        "pr_file": "cliv2/cmd/cliv2/logheader.go",
        "discussion_id": "1861980779",
        "commented_code": "@@ -109,6 +110,12 @@ func writeLogHeader(config configuration.Configuration, networkAccess networking\n \ttablePrint(\"Version\", cliv2.GetFullVersion()+\" \"+buildType)\n \ttablePrint(\"Platform\", userAgent)\n \ttablePrint(\"API\", config.GetString(configuration.API_URL))\n+\n+\tregion, err := localworkflows.DetermineRegionFromUrl(config.GetString(configuration.API_URL))",
        "comment_created_at": "2024-11-28T11:02:45+00:00",
        "comment_author": "j-luong",
        "comment_body": "nitpick: I know we handle the error in GAF, but in general I'm not sure I'm convinced of this pattern of assuming errors are handled in the dependencies.\r\n\r\nI would suggest:\r\n```\r\nif err != nil {\r\n...\r\n} else {\r\n...\r\n}\r\n```\r\n\r\nbut it's a minor point",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1569017664",
    "pr_number": 5173,
    "pr_file": "scripts/upgrade-snyk-go-dependencies.go",
    "created_at": "2024-04-17T15:13:34+00:00",
    "commented_code": "+package main\n+\n+/**\n+ * This script is used to upgrade the go dependencies in the cliv2 project.\n+ *\n+ * It uses the GitHub API to fetch the latest commit SHA for the specified repository\n+ * and then uses the `go get` command to upgrade the dependency.\n+ *\n+ * Usage:\n+ * go run scripts/upgrade-snyk-go-dependencies.go --name=go-application-framework\n+ */\n+import (\n+\t\"encoding/json\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"os/exec\"\n+\t\"regexp\"\n+)\n+\n+type Commit struct {\n+\tSHA    string `json:\"sha\"`\n+\tCommit struct {\n+\t\tMessage string `json:\"message\"`\n+\t} `json:\"commit\"`\n+\tUrl string `json:\"html_url\"`\n+}\n+\n+func isValidRepository(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9-]+$\", name)",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1569017664",
        "repo_full_name": "snyk/cli",
        "pr_number": 5173,
        "pr_file": "scripts/upgrade-snyk-go-dependencies.go",
        "discussion_id": "1569017664",
        "commented_code": "@@ -0,0 +1,134 @@\n+package main\n+\n+/**\n+ * This script is used to upgrade the go dependencies in the cliv2 project.\n+ *\n+ * It uses the GitHub API to fetch the latest commit SHA for the specified repository\n+ * and then uses the `go get` command to upgrade the dependency.\n+ *\n+ * Usage:\n+ * go run scripts/upgrade-snyk-go-dependencies.go --name=go-application-framework\n+ */\n+import (\n+\t\"encoding/json\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"os/exec\"\n+\t\"regexp\"\n+)\n+\n+type Commit struct {\n+\tSHA    string `json:\"sha\"`\n+\tCommit struct {\n+\t\tMessage string `json:\"message\"`\n+\t} `json:\"commit\"`\n+\tUrl string `json:\"html_url\"`\n+}\n+\n+func isValidRepository(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9-]+$\", name)",
        "comment_created_at": "2024-04-17T15:13:34+00:00",
        "comment_author": "cmars",
        "comment_body": "I'd `log.Fatal` on the error. Handing all errors (even by panicking) is a good habit.",
        "pr_file_module": null
      },
      {
        "comment_id": "1570548345",
        "repo_full_name": "snyk/cli",
        "pr_number": 5173,
        "pr_file": "scripts/upgrade-snyk-go-dependencies.go",
        "discussion_id": "1569017664",
        "commented_code": "@@ -0,0 +1,134 @@\n+package main\n+\n+/**\n+ * This script is used to upgrade the go dependencies in the cliv2 project.\n+ *\n+ * It uses the GitHub API to fetch the latest commit SHA for the specified repository\n+ * and then uses the `go get` command to upgrade the dependency.\n+ *\n+ * Usage:\n+ * go run scripts/upgrade-snyk-go-dependencies.go --name=go-application-framework\n+ */\n+import (\n+\t\"encoding/json\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"os/exec\"\n+\t\"regexp\"\n+)\n+\n+type Commit struct {\n+\tSHA    string `json:\"sha\"`\n+\tCommit struct {\n+\t\tMessage string `json:\"message\"`\n+\t} `json:\"commit\"`\n+\tUrl string `json:\"html_url\"`\n+}\n+\n+func isValidRepository(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9-]+$\", name)",
        "comment_created_at": "2024-04-18T11:36:26+00:00",
        "comment_author": "thisislawatts",
        "comment_body": "Good catch, updated in https://github.com/snyk/cli/pull/5173/commits/8d4b87e6cd8fdf68c5dca1f4e03910bac7dd6cf9",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1569018544",
    "pr_number": 5173,
    "pr_file": "scripts/upgrade-snyk-go-dependencies.go",
    "created_at": "2024-04-17T15:14:10+00:00",
    "commented_code": "+package main\n+\n+/**\n+ * This script is used to upgrade the go dependencies in the cliv2 project.\n+ *\n+ * It uses the GitHub API to fetch the latest commit SHA for the specified repository\n+ * and then uses the `go get` command to upgrade the dependency.\n+ *\n+ * Usage:\n+ * go run scripts/upgrade-snyk-go-dependencies.go --name=go-application-framework\n+ */\n+import (\n+\t\"encoding/json\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"os/exec\"\n+\t\"regexp\"\n+)\n+\n+type Commit struct {\n+\tSHA    string `json:\"sha\"`\n+\tCommit struct {\n+\t\tMessage string `json:\"message\"`\n+\t} `json:\"commit\"`\n+\tUrl string `json:\"html_url\"`\n+}\n+\n+func isValidRepository(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9-]+$\", name)\n+\treturn match\n+}\n+\n+func getLatestCommitSHA(name string) (string, error) {\n+\tif !isValidRepository(name) {\n+\t\treturn \"\", fmt.Errorf(\"Invalid repository name: %s\", name)\n+\t}\n+\turl := fmt.Sprintf(\"https://api.github.com/repos/snyk/%s/commits\", name)\n+\treq, err := http.NewRequest(\"GET\", url, nil)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treq.Header.Set(\"Accept\", \"application/vnd.github.v3+json\")\n+\n+\tclient := http.Client{}\n+\tresp, err := client.Do(req)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer func(Body io.ReadCloser) {\n+\t\terr := Body.Close()\n+\t\tif err != nil {\n+\n+\t\t}\n+\t}(resp.Body)",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1569018544",
        "repo_full_name": "snyk/cli",
        "pr_number": 5173,
        "pr_file": "scripts/upgrade-snyk-go-dependencies.go",
        "discussion_id": "1569018544",
        "commented_code": "@@ -0,0 +1,134 @@\n+package main\n+\n+/**\n+ * This script is used to upgrade the go dependencies in the cliv2 project.\n+ *\n+ * It uses the GitHub API to fetch the latest commit SHA for the specified repository\n+ * and then uses the `go get` command to upgrade the dependency.\n+ *\n+ * Usage:\n+ * go run scripts/upgrade-snyk-go-dependencies.go --name=go-application-framework\n+ */\n+import (\n+\t\"encoding/json\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"os/exec\"\n+\t\"regexp\"\n+)\n+\n+type Commit struct {\n+\tSHA    string `json:\"sha\"`\n+\tCommit struct {\n+\t\tMessage string `json:\"message\"`\n+\t} `json:\"commit\"`\n+\tUrl string `json:\"html_url\"`\n+}\n+\n+func isValidRepository(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9-]+$\", name)\n+\treturn match\n+}\n+\n+func getLatestCommitSHA(name string) (string, error) {\n+\tif !isValidRepository(name) {\n+\t\treturn \"\", fmt.Errorf(\"Invalid repository name: %s\", name)\n+\t}\n+\turl := fmt.Sprintf(\"https://api.github.com/repos/snyk/%s/commits\", name)\n+\treq, err := http.NewRequest(\"GET\", url, nil)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treq.Header.Set(\"Accept\", \"application/vnd.github.v3+json\")\n+\n+\tclient := http.Client{}\n+\tresp, err := client.Do(req)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer func(Body io.ReadCloser) {\n+\t\terr := Body.Close()\n+\t\tif err != nil {\n+\n+\t\t}\n+\t}(resp.Body)",
        "comment_created_at": "2024-04-17T15:14:10+00:00",
        "comment_author": "cmars",
        "comment_body": "```suggestion\r\n\tdefer resp.Body.Close()\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1570548051",
        "repo_full_name": "snyk/cli",
        "pr_number": 5173,
        "pr_file": "scripts/upgrade-snyk-go-dependencies.go",
        "discussion_id": "1569018544",
        "commented_code": "@@ -0,0 +1,134 @@\n+package main\n+\n+/**\n+ * This script is used to upgrade the go dependencies in the cliv2 project.\n+ *\n+ * It uses the GitHub API to fetch the latest commit SHA for the specified repository\n+ * and then uses the `go get` command to upgrade the dependency.\n+ *\n+ * Usage:\n+ * go run scripts/upgrade-snyk-go-dependencies.go --name=go-application-framework\n+ */\n+import (\n+\t\"encoding/json\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"net/http\"\n+\t\"os/exec\"\n+\t\"regexp\"\n+)\n+\n+type Commit struct {\n+\tSHA    string `json:\"sha\"`\n+\tCommit struct {\n+\t\tMessage string `json:\"message\"`\n+\t} `json:\"commit\"`\n+\tUrl string `json:\"html_url\"`\n+}\n+\n+func isValidRepository(name string) bool {\n+\tif name == \"\" {\n+\t\treturn false\n+\t}\n+\n+\tmatch, _ := regexp.MatchString(\"^[a-zA-Z0-9-]+$\", name)\n+\treturn match\n+}\n+\n+func getLatestCommitSHA(name string) (string, error) {\n+\tif !isValidRepository(name) {\n+\t\treturn \"\", fmt.Errorf(\"Invalid repository name: %s\", name)\n+\t}\n+\turl := fmt.Sprintf(\"https://api.github.com/repos/snyk/%s/commits\", name)\n+\treq, err := http.NewRequest(\"GET\", url, nil)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treq.Header.Set(\"Accept\", \"application/vnd.github.v3+json\")\n+\n+\tclient := http.Client{}\n+\tresp, err := client.Do(req)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer func(Body io.ReadCloser) {\n+\t\terr := Body.Close()\n+\t\tif err != nil {\n+\n+\t\t}\n+\t}(resp.Body)",
        "comment_created_at": "2024-04-18T11:36:14+00:00",
        "comment_author": "thisislawatts",
        "comment_body": "Resolved in https://github.com/snyk/cli/pull/5173/commits/8d4b87e6cd8fdf68c5dca1f4e03910bac7dd6cf9",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1088124939",
    "pr_number": 4373,
    "pr_file": "cliv2/internal/cliv2/cliv2.go",
    "created_at": "2023-01-26T17:12:43+00:00",
    "commented_code": "if _, err = os.Stat(c.CacheDirectory); os.IsNotExist(err) {\n \t\t\terr = os.Mkdir(c.CacheDirectory, local_utils.CACHEDIR_PERMISSION)\n \t\t\tif err != nil {\n-\t\t\t\treturn err\n+\t\t\t\treturn fmt.Errorf(\"Cache directory path is invalid:\n\" + err.Error())",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1088124939",
        "repo_full_name": "snyk/cli",
        "pr_number": 4373,
        "pr_file": "cliv2/internal/cliv2/cliv2.go",
        "discussion_id": "1088124939",
        "commented_code": "@@ -75,7 +75,7 @@ func (c *CLI) Init() (err error) {\n \t\tif _, err = os.Stat(c.CacheDirectory); os.IsNotExist(err) {\n \t\t\terr = os.Mkdir(c.CacheDirectory, local_utils.CACHEDIR_PERMISSION)\n \t\t\tif err != nil {\n-\t\t\t\treturn err\n+\t\t\t\treturn fmt.Errorf(\"Cache directory path is invalid:\\n\" + err.Error())",
        "comment_created_at": "2023-01-26T17:12:43+00:00",
        "comment_author": "PeterSchafer",
        "comment_body": "Please use fmt.Errorf() the following way, see [the documentation](https://pkg.go.dev/fmt@go1.19.5#Errorf) for the reasoning\r\n`fmt.Errorf(\"Cache directory path is invalid: %w\", err)`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1084275770",
    "pr_number": 4365,
    "pr_file": "cliv2/internal/cliv2/cliv2_test.go",
    "created_at": "2023-01-23T16:28:13+00:00",
    "commented_code": "os.RemoveAll(cacheDir)",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1084275770",
        "repo_full_name": "snyk/cli",
        "pr_number": 4365,
        "pr_file": "cliv2/internal/cliv2/cliv2_test.go",
        "discussion_id": "1084275770",
        "commented_code": "@@ -176,16 +192,61 @@ func Test_executeRunV1(t *testing.T) {\n \tos.RemoveAll(cacheDir)",
        "comment_created_at": "2023-01-23T16:28:13+00:00",
        "comment_author": "bastiandoetsch",
        "comment_body": "this could be a `deferred` call so that it is executed even if a panic/error occurs",
        "pr_file_module": null
      },
      {
        "comment_id": "1084332621",
        "repo_full_name": "snyk/cli",
        "pr_number": 4365,
        "pr_file": "cliv2/internal/cliv2/cliv2_test.go",
        "discussion_id": "1084275770",
        "commented_code": "@@ -176,16 +192,61 @@ func Test_executeRunV1(t *testing.T) {\n \tos.RemoveAll(cacheDir)",
        "comment_created_at": "2023-01-23T17:17:14+00:00",
        "comment_author": "PeterSchafer",
        "comment_body": "done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1084276192",
    "pr_number": 4365,
    "pr_file": "cliv2/internal/cliv2/cliv2_test.go",
    "created_at": "2023-01-23T16:28:37+00:00",
    "commented_code": "os.RemoveAll(cacheDir)\n }\n \n+func Test_init_extractDueToInvalidBinary(t *testing.T) {\n+\n+\tcacheDir := getCacheDir()\n+\ttmpDir := utils.GetTemporaryDirectory(cacheDir, cliv2.GetFullVersion())\n+\tlogger := log.New(ioutil.Discard, \"\", 0)\n+\n+\tassert.NoDirExists(t, tmpDir)\n+\n+\t// create instance under test\n+\tcli, _ := cliv2.NewCLIv2(cacheDir, logger)\n+\n+\t// fill binary with invalid data\n+\tos.MkdirAll(tmpDir, 0755)\n+\tos.WriteFile(cli.GetBinaryLocation(), []byte(\"Writing some strings\"), 0755)\n+\tfileInfo1, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\t// prove that we can't execute the invalid binary\n+\t_, binError := exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.NotNil(t, binError)\n+\n+\t// sleep shortly to ensure that everything is applied\n+\ttime.Sleep(500 * time.Millisecond)\n+\n+\t// run init to ensure that the file system is being setup correctly\n+\tinitError := cli.Init()\n+\tassert.Nil(t, initError)\n+\n+\t// execute to test that the cli can run successfully\n+\tassert.FileExists(t, cli.GetBinaryLocation())\n+\n+\t// prove that we now can execute the invalid binary\n+\t_, binError = exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.Nil(t, binError)\n+\n+\tfileInfo2, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\tassert.NotEqual(t, fileInfo1.ModTime(), fileInfo2.ModTime())\n+\n+\t// cleanup\n+\tos.RemoveAll(cacheDir)",
    "repo_full_name": "snyk/cli",
    "discussion_comments": [
      {
        "comment_id": "1084276192",
        "repo_full_name": "snyk/cli",
        "pr_number": 4365,
        "pr_file": "cliv2/internal/cliv2/cliv2_test.go",
        "discussion_id": "1084276192",
        "commented_code": "@@ -176,16 +192,61 @@ func Test_executeRunV1(t *testing.T) {\n \tos.RemoveAll(cacheDir)\n }\n \n+func Test_init_extractDueToInvalidBinary(t *testing.T) {\n+\n+\tcacheDir := getCacheDir()\n+\ttmpDir := utils.GetTemporaryDirectory(cacheDir, cliv2.GetFullVersion())\n+\tlogger := log.New(ioutil.Discard, \"\", 0)\n+\n+\tassert.NoDirExists(t, tmpDir)\n+\n+\t// create instance under test\n+\tcli, _ := cliv2.NewCLIv2(cacheDir, logger)\n+\n+\t// fill binary with invalid data\n+\tos.MkdirAll(tmpDir, 0755)\n+\tos.WriteFile(cli.GetBinaryLocation(), []byte(\"Writing some strings\"), 0755)\n+\tfileInfo1, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\t// prove that we can't execute the invalid binary\n+\t_, binError := exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.NotNil(t, binError)\n+\n+\t// sleep shortly to ensure that everything is applied\n+\ttime.Sleep(500 * time.Millisecond)\n+\n+\t// run init to ensure that the file system is being setup correctly\n+\tinitError := cli.Init()\n+\tassert.Nil(t, initError)\n+\n+\t// execute to test that the cli can run successfully\n+\tassert.FileExists(t, cli.GetBinaryLocation())\n+\n+\t// prove that we now can execute the invalid binary\n+\t_, binError = exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.Nil(t, binError)\n+\n+\tfileInfo2, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\tassert.NotEqual(t, fileInfo1.ModTime(), fileInfo2.ModTime())\n+\n+\t// cleanup\n+\tos.RemoveAll(cacheDir)",
        "comment_created_at": "2023-01-23T16:28:37+00:00",
        "comment_author": "bastiandoetsch",
        "comment_body": "see above - why not cleaning up with defer?",
        "pr_file_module": null
      },
      {
        "comment_id": "1084278216",
        "repo_full_name": "snyk/cli",
        "pr_number": 4365,
        "pr_file": "cliv2/internal/cliv2/cliv2_test.go",
        "discussion_id": "1084276192",
        "commented_code": "@@ -176,16 +192,61 @@ func Test_executeRunV1(t *testing.T) {\n \tos.RemoveAll(cacheDir)\n }\n \n+func Test_init_extractDueToInvalidBinary(t *testing.T) {\n+\n+\tcacheDir := getCacheDir()\n+\ttmpDir := utils.GetTemporaryDirectory(cacheDir, cliv2.GetFullVersion())\n+\tlogger := log.New(ioutil.Discard, \"\", 0)\n+\n+\tassert.NoDirExists(t, tmpDir)\n+\n+\t// create instance under test\n+\tcli, _ := cliv2.NewCLIv2(cacheDir, logger)\n+\n+\t// fill binary with invalid data\n+\tos.MkdirAll(tmpDir, 0755)\n+\tos.WriteFile(cli.GetBinaryLocation(), []byte(\"Writing some strings\"), 0755)\n+\tfileInfo1, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\t// prove that we can't execute the invalid binary\n+\t_, binError := exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.NotNil(t, binError)\n+\n+\t// sleep shortly to ensure that everything is applied\n+\ttime.Sleep(500 * time.Millisecond)\n+\n+\t// run init to ensure that the file system is being setup correctly\n+\tinitError := cli.Init()\n+\tassert.Nil(t, initError)\n+\n+\t// execute to test that the cli can run successfully\n+\tassert.FileExists(t, cli.GetBinaryLocation())\n+\n+\t// prove that we now can execute the invalid binary\n+\t_, binError = exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.Nil(t, binError)\n+\n+\tfileInfo2, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\tassert.NotEqual(t, fileInfo1.ModTime(), fileInfo2.ModTime())\n+\n+\t// cleanup\n+\tos.RemoveAll(cacheDir)",
        "comment_created_at": "2023-01-23T16:30:09+00:00",
        "comment_author": "bastiandoetsch",
        "comment_body": "The cachedir could even clean itself up, if you pass T into the function and then register the cleanup as cleanup function.",
        "pr_file_module": null
      },
      {
        "comment_id": "1084332963",
        "repo_full_name": "snyk/cli",
        "pr_number": 4365,
        "pr_file": "cliv2/internal/cliv2/cliv2_test.go",
        "discussion_id": "1084276192",
        "commented_code": "@@ -176,16 +192,61 @@ func Test_executeRunV1(t *testing.T) {\n \tos.RemoveAll(cacheDir)\n }\n \n+func Test_init_extractDueToInvalidBinary(t *testing.T) {\n+\n+\tcacheDir := getCacheDir()\n+\ttmpDir := utils.GetTemporaryDirectory(cacheDir, cliv2.GetFullVersion())\n+\tlogger := log.New(ioutil.Discard, \"\", 0)\n+\n+\tassert.NoDirExists(t, tmpDir)\n+\n+\t// create instance under test\n+\tcli, _ := cliv2.NewCLIv2(cacheDir, logger)\n+\n+\t// fill binary with invalid data\n+\tos.MkdirAll(tmpDir, 0755)\n+\tos.WriteFile(cli.GetBinaryLocation(), []byte(\"Writing some strings\"), 0755)\n+\tfileInfo1, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\t// prove that we can't execute the invalid binary\n+\t_, binError := exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.NotNil(t, binError)\n+\n+\t// sleep shortly to ensure that everything is applied\n+\ttime.Sleep(500 * time.Millisecond)\n+\n+\t// run init to ensure that the file system is being setup correctly\n+\tinitError := cli.Init()\n+\tassert.Nil(t, initError)\n+\n+\t// execute to test that the cli can run successfully\n+\tassert.FileExists(t, cli.GetBinaryLocation())\n+\n+\t// prove that we now can execute the invalid binary\n+\t_, binError = exec.Command(cli.GetBinaryLocation(), \"--help\").Output()\n+\tassert.Nil(t, binError)\n+\n+\tfileInfo2, _ := os.Stat(cli.GetBinaryLocation())\n+\n+\tassert.NotEqual(t, fileInfo1.ModTime(), fileInfo2.ModTime())\n+\n+\t// cleanup\n+\tos.RemoveAll(cacheDir)",
        "comment_created_at": "2023-01-23T17:17:35+00:00",
        "comment_author": "PeterSchafer",
        "comment_body": "done! used defer",
        "pr_file_module": null
      }
    ]
  }
]