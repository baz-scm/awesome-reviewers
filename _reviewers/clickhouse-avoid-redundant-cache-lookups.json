[
  {
    "discussion_id": "2003088815",
    "pr_number": 77884,
    "pr_file": "src/IO/CachedInMemoryReadBufferFromFile.cpp",
    "created_at": "2025-03-19T11:13:32+00:00",
    "commented_code": "return available() == 0 || last_read_hit_cache;\n }\n \n+bool CachedInMemoryReadBufferFromFile::isContentCached(size_t offset, size_t /*size*/)\n+{\n+    /// There's a tradeoff here: we waste time doing the cache lookup twice (here, then in nextImpl),\n+    /// but save ThreadPoolRemoteFSReader the overhead of passing the task to another thread and back.",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2003088815",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 77884,
        "pr_file": "src/IO/CachedInMemoryReadBufferFromFile.cpp",
        "discussion_id": "2003088815",
        "commented_code": "@@ -41,6 +41,19 @@ bool CachedInMemoryReadBufferFromFile::isSeekCheap()\n     return available() == 0 || last_read_hit_cache;\n }\n \n+bool CachedInMemoryReadBufferFromFile::isContentCached(size_t offset, size_t /*size*/)\n+{\n+    /// There's a tradeoff here: we waste time doing the cache lookup twice (here, then in nextImpl),\n+    /// but save ThreadPoolRemoteFSReader the overhead of passing the task to another thread and back.",
        "comment_created_at": "2025-03-19T11:13:32+00:00",
        "comment_author": "kssenii",
        "comment_body": "About double lookup, in fs cache there is similar code and there in `isContentCached` we do `cache->getOrSet` (not just `cache->contains`) and save the result inside the class and then use it on next `nextImpl`. Probably easy to do the same here? Anyway, just `contains()` would suffice for now probably.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2003144625",
    "pr_number": 77884,
    "pr_file": "src/Disks/IO/AsynchronousBoundedReadBuffer.cpp",
    "created_at": "2025-03-19T11:49:18+00:00",
    "commented_code": "size_t bytes_read = result.size - result.offset;\n     if (bytes_read)\n     {\n+        if (use_page_cache)\n+        {\n+            page_cache_cell = result.page_cache_cell;\n+            internal_buffer = Buffer(page_cache_cell->data(), page_cache_cell->data() + page_cache_cell->size());",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2003144625",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 77884,
        "pr_file": "src/Disks/IO/AsynchronousBoundedReadBuffer.cpp",
        "discussion_id": "2003144625",
        "commented_code": "@@ -250,9 +264,18 @@ bool AsynchronousBoundedReadBuffer::nextImpl()\n     size_t bytes_read = result.size - result.offset;\n     if (bytes_read)\n     {\n+        if (use_page_cache)\n+        {\n+            page_cache_cell = result.page_cache_cell;\n+            internal_buffer = Buffer(page_cache_cell->data(), page_cache_cell->data() + page_cache_cell->size());",
        "comment_created_at": "2025-03-19T11:49:18+00:00",
        "comment_author": "kssenii",
        "comment_body": "I see this code https://github.com/ClickHouse/ClickHouse/blob/dc7b7b49ed14ac28ce0ea84a6e3405cac6f2c96e/src/IO/CachedInMemoryReadBufferFromFile.cpp#L186-L195\r\nShould we now delete it? And make `chassert(internal_buffer.empty())` (or better throw explicit logical error just in case)?",
        "pr_file_module": null
      }
    ]
  }
]