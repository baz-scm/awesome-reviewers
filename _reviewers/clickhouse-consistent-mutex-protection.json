[
  {
    "discussion_id": "2107632641",
    "pr_number": 77153,
    "pr_file": "src/Interpreters/XRayInstrumentationManager.cpp",
    "created_at": "2025-05-26T16:29:38+00:00",
    "commented_code": "+#include \"XRayInstrumentationManager.h\"\n+#include <cstdint>\n+#include <shared_mutex>\n+#include <string>\n+\n+#if USE_XRAY\n+\n+#include <filesystem>\n+#include <print>\n+#include <stdexcept>\n+#include <thread>\n+#include <string_view>\n+#include <unistd.h>\n+\n+#include <llvm/Object/Binary.h>\n+#include <llvm/Object/ObjectFile.h>\n+#include <llvm/Support/Error.h>\n+#include <llvm/Support/MemoryBuffer.h>\n+#include <llvm/Support/raw_ostream.h>\n+#include <llvm/XRay/InstrumentationMap.h>\n+#include <llvm/DebugInfo/Symbolize/Symbolize.h>\n+#include <llvm/Support/Path.h>\n+#include <llvm/Support/TargetSelect.h>\n+#include <llvm/IR/Function.h>\n+#include <Common/Exception.h>\n+#include <Common/ErrorCodes.h>\n+#include <Common/logger_useful.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/InstrumentationProfilingLog.h>\n+#include <Common/CurrentThread.h>\n+#include <Common/ThreadStatus.h>\n+\n+\n+using namespace llvm;\n+using namespace llvm::object;\n+using namespace llvm::xray;\n+using namespace llvm::symbolize;\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int BAD_ARGUMENTS;\n+}\n+std::unordered_map<int64_t, std::string> XRayInstrumentationManager::xrayIdToFunctionName;\n+std::unordered_map<std::string, XRayHandlerFunction> XRayInstrumentationManager::xrayHandlerNameToFunction;\n+std::unordered_map<int32_t, XRayInstrumentationManager::HandlerTypeToIP> XRayInstrumentationManager::functionIdToHandlers;\n+\n+void XRayInstrumentationManager::registerHandler(const std::string & name, XRayHandlerFunction handler)\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    xrayHandlerNameToFunction[name] = handler;\n+}\n+\n+\n+XRayInstrumentationManager::XRayInstrumentationManager()\n+{\n+    registerHandler(\"SLEEP\", &sleep);\n+    registerHandler(\"LOG\", &log);\n+    registerHandler(\"PROFILE\", &profile);\n+    parseXRayInstrumentationMap();\n+}\n+\n+XRayInstrumentationManager & XRayInstrumentationManager::instance()\n+{\n+    static XRayInstrumentationManager instance;\n+    return instance;\n+}\n+\n+HandlerType XRayInstrumentationManager::getHandlerType(const std::string & handler_name)\n+{\n+    if (handler_name == \"SLEEP\")\n+        return HandlerType::Sleep;\n+\n+    if (handler_name == \"LOG\")\n+        return HandlerType::Log;\n+\n+    if (handler_name == \"PROFILE\")\n+        return HandlerType::Profile;\n+\n+    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown handler type: ({})\", handler_name);\n+}\n+\n+void XRayInstrumentationManager::setHandlerAndPatch(const std::string & function_name, const std::string & handler_name, std::optional<std::vector<InstrumentParameter>> &parameters, ContextPtr context)\n+{\n+    std::lock_guard lock(mutex);\n+    auto handler_it = xrayHandlerNameToFunction.find(handler_name);\n+    if (handler_it == xrayHandlerNameToFunction.end())\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown XRAY handler: ({})\", handler_name);\n+\n+    int64_t function_id;\n+    auto fn_it = functionNameToXRayID.find(function_name);\n+    if (fn_it != functionNameToXRayID.end())\n+        function_id = fn_it->second;\n+    else\n+    {\n+        auto stripped_it = strippedFunctionNameToXRayID.find(function_name);\n+        if (stripped_it != strippedFunctionNameToXRayID.end())\n+            function_id = stripped_it->second.back();\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown function to instrument: ({})\", function_name);\n+    }\n+\n+    HandlerType type;\n+    try\n+    {\n+        type = getHandlerType(handler_name);\n+    }\n+    catch (const std::exception & e)\n+    {\n+        throw e;\n+    }\n+\n+\n+    auto handlers_set_it = functionIdToHandlers.find(function_id);\n+    if (handlers_set_it !=  functionIdToHandlers.end() && handlers_set_it->second.contains(type))\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Handler of this type is already installed for function ({})\", function_name);\n+    }\n+    instrumented_functions.emplace_front(instrumentation_point_id, function_id, function_name, handler_name, parameters, context);\n+    functionIdToHandlers[function_id][type] = instrumented_functions.begin();\n+    instrumentation_point_id++;\n+\n+    static std::once_flag once;\n+    std::call_once(once, [&] {\n+        __xray_set_handler(&XRayInstrumentationManager::dispatchHandler);\n+        __xray_patch_function(function_id);\n+    });\n+}\n+\n+\n+void XRayInstrumentationManager::unpatchFunction(const std::string & function_name, const std::string & handler_name)\n+{\n+    std::lock_guard lock(mutex);\n+    int64_t function_id;\n+    auto fn_it = functionNameToXRayID.find(function_name);\n+    if (fn_it != functionNameToXRayID.end())\n+        function_id = fn_it->second;\n+    else\n+    {\n+        auto stripped_it = strippedFunctionNameToXRayID.find(function_name);\n+        if (stripped_it != strippedFunctionNameToXRayID.end())\n+            function_id = stripped_it->second.back();\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown function to instrument: ({})\", function_name);\n+    }\n+    HandlerType type = getHandlerType(handler_name);\n+    if (!functionIdToHandlers.contains(function_id))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"This function wasn't previously instrumented, nothing to unpatch: ({})\", function_name);\n+    if (!functionIdToHandlers[function_id].contains(type))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"This function was not instrumenented with this handler type, nothing to unpatch: ({}), ({})\", function_name, handler_name);\n+    instrumented_functions.erase(functionIdToHandlers[function_id][type]);\n+    functionIdToHandlers[function_id].erase(type);\n+    __xray_unpatch_function(function_id);\n+}\n+\n+\n+XRayHandlerFunction XRayInstrumentationManager::getHandler(const std::string & name) const\n+{\n+    std::lock_guard lock(mutex);\n+    auto it = xrayHandlerNameToFunction.find(name);\n+    if (it == xrayHandlerNameToFunction.end())\n+        throw std::runtime_error(\"Handler not found: \" + name);\n+    return it->second;\n+}\n+\n+[[clang::xray_never_instrument]] void XRayInstrumentationManager::dispatchHandler(int32_t FuncId, XRayEntryType Type)\n+{\n+    static thread_local bool in_hook = false;\n+    if (in_hook) return;\n+    in_hook = true;\n+    std::shared_lock lock(shared_mutex);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2107632641",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 77153,
        "pr_file": "src/Interpreters/XRayInstrumentationManager.cpp",
        "discussion_id": "2107632641",
        "commented_code": "@@ -0,0 +1,516 @@\n+#include \"XRayInstrumentationManager.h\"\n+#include <cstdint>\n+#include <shared_mutex>\n+#include <string>\n+\n+#if USE_XRAY\n+\n+#include <filesystem>\n+#include <print>\n+#include <stdexcept>\n+#include <thread>\n+#include <string_view>\n+#include <unistd.h>\n+\n+#include <llvm/Object/Binary.h>\n+#include <llvm/Object/ObjectFile.h>\n+#include <llvm/Support/Error.h>\n+#include <llvm/Support/MemoryBuffer.h>\n+#include <llvm/Support/raw_ostream.h>\n+#include <llvm/XRay/InstrumentationMap.h>\n+#include <llvm/DebugInfo/Symbolize/Symbolize.h>\n+#include <llvm/Support/Path.h>\n+#include <llvm/Support/TargetSelect.h>\n+#include <llvm/IR/Function.h>\n+#include <Common/Exception.h>\n+#include <Common/ErrorCodes.h>\n+#include <Common/logger_useful.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/InstrumentationProfilingLog.h>\n+#include <Common/CurrentThread.h>\n+#include <Common/ThreadStatus.h>\n+\n+\n+using namespace llvm;\n+using namespace llvm::object;\n+using namespace llvm::xray;\n+using namespace llvm::symbolize;\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int BAD_ARGUMENTS;\n+}\n+std::unordered_map<int64_t, std::string> XRayInstrumentationManager::xrayIdToFunctionName;\n+std::unordered_map<std::string, XRayHandlerFunction> XRayInstrumentationManager::xrayHandlerNameToFunction;\n+std::unordered_map<int32_t, XRayInstrumentationManager::HandlerTypeToIP> XRayInstrumentationManager::functionIdToHandlers;\n+\n+void XRayInstrumentationManager::registerHandler(const std::string & name, XRayHandlerFunction handler)\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    xrayHandlerNameToFunction[name] = handler;\n+}\n+\n+\n+XRayInstrumentationManager::XRayInstrumentationManager()\n+{\n+    registerHandler(\"SLEEP\", &sleep);\n+    registerHandler(\"LOG\", &log);\n+    registerHandler(\"PROFILE\", &profile);\n+    parseXRayInstrumentationMap();\n+}\n+\n+XRayInstrumentationManager & XRayInstrumentationManager::instance()\n+{\n+    static XRayInstrumentationManager instance;\n+    return instance;\n+}\n+\n+HandlerType XRayInstrumentationManager::getHandlerType(const std::string & handler_name)\n+{\n+    if (handler_name == \"SLEEP\")\n+        return HandlerType::Sleep;\n+\n+    if (handler_name == \"LOG\")\n+        return HandlerType::Log;\n+\n+    if (handler_name == \"PROFILE\")\n+        return HandlerType::Profile;\n+\n+    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown handler type: ({})\", handler_name);\n+}\n+\n+void XRayInstrumentationManager::setHandlerAndPatch(const std::string & function_name, const std::string & handler_name, std::optional<std::vector<InstrumentParameter>> &parameters, ContextPtr context)\n+{\n+    std::lock_guard lock(mutex);\n+    auto handler_it = xrayHandlerNameToFunction.find(handler_name);\n+    if (handler_it == xrayHandlerNameToFunction.end())\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown XRAY handler: ({})\", handler_name);\n+\n+    int64_t function_id;\n+    auto fn_it = functionNameToXRayID.find(function_name);\n+    if (fn_it != functionNameToXRayID.end())\n+        function_id = fn_it->second;\n+    else\n+    {\n+        auto stripped_it = strippedFunctionNameToXRayID.find(function_name);\n+        if (stripped_it != strippedFunctionNameToXRayID.end())\n+            function_id = stripped_it->second.back();\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown function to instrument: ({})\", function_name);\n+    }\n+\n+    HandlerType type;\n+    try\n+    {\n+        type = getHandlerType(handler_name);\n+    }\n+    catch (const std::exception & e)\n+    {\n+        throw e;\n+    }\n+\n+\n+    auto handlers_set_it = functionIdToHandlers.find(function_id);\n+    if (handlers_set_it !=  functionIdToHandlers.end() && handlers_set_it->second.contains(type))\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Handler of this type is already installed for function ({})\", function_name);\n+    }\n+    instrumented_functions.emplace_front(instrumentation_point_id, function_id, function_name, handler_name, parameters, context);\n+    functionIdToHandlers[function_id][type] = instrumented_functions.begin();\n+    instrumentation_point_id++;\n+\n+    static std::once_flag once;\n+    std::call_once(once, [&] {\n+        __xray_set_handler(&XRayInstrumentationManager::dispatchHandler);\n+        __xray_patch_function(function_id);\n+    });\n+}\n+\n+\n+void XRayInstrumentationManager::unpatchFunction(const std::string & function_name, const std::string & handler_name)\n+{\n+    std::lock_guard lock(mutex);\n+    int64_t function_id;\n+    auto fn_it = functionNameToXRayID.find(function_name);\n+    if (fn_it != functionNameToXRayID.end())\n+        function_id = fn_it->second;\n+    else\n+    {\n+        auto stripped_it = strippedFunctionNameToXRayID.find(function_name);\n+        if (stripped_it != strippedFunctionNameToXRayID.end())\n+            function_id = stripped_it->second.back();\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown function to instrument: ({})\", function_name);\n+    }\n+    HandlerType type = getHandlerType(handler_name);\n+    if (!functionIdToHandlers.contains(function_id))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"This function wasn't previously instrumented, nothing to unpatch: ({})\", function_name);\n+    if (!functionIdToHandlers[function_id].contains(type))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"This function was not instrumenented with this handler type, nothing to unpatch: ({}), ({})\", function_name, handler_name);\n+    instrumented_functions.erase(functionIdToHandlers[function_id][type]);\n+    functionIdToHandlers[function_id].erase(type);\n+    __xray_unpatch_function(function_id);\n+}\n+\n+\n+XRayHandlerFunction XRayInstrumentationManager::getHandler(const std::string & name) const\n+{\n+    std::lock_guard lock(mutex);\n+    auto it = xrayHandlerNameToFunction.find(name);\n+    if (it == xrayHandlerNameToFunction.end())\n+        throw std::runtime_error(\"Handler not found: \" + name);\n+    return it->second;\n+}\n+\n+[[clang::xray_never_instrument]] void XRayInstrumentationManager::dispatchHandler(int32_t FuncId, XRayEntryType Type)\n+{\n+    static thread_local bool in_hook = false;\n+    if (in_hook) return;\n+    in_hook = true;\n+    std::shared_lock lock(shared_mutex);",
        "comment_created_at": "2025-05-26T16:29:38+00:00",
        "comment_author": "pamarcos",
        "comment_body": "What is this mutex supposed to protect? This comment goes in line with the one where I recommended to add TSA annotations to variables and which mutexes protect them.\r\n\r\nThis is the topic where I expected most of the issues to come up because it's quite difficult to get it right.\r\nFor instance, I thought that `mutex` was the one protecting `functionIdToHandlers`. But here it's `shared_mutex`, which is obviously a different mutex. But then, in `log/sleep/profile` there is no mutex locked at all for `functionIdToHandlers`. Kind reminder that there's no thread-safe guarantees in an `std::unordered_map` and they could be resized with new insertions/deletionsk, all iterators can be invalidated, etc.\r\n\r\nThe na\u00efve approach would be to add a lock to the same mutex everywhere and off we go. It won't be very good for performance, but at least it'll be correct.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2266492461",
    "pr_number": 85356,
    "pr_file": "src/Storages/MergeTree/GinIndexStore.cpp",
    "created_at": "2025-08-11T12:01:07+00:00",
    "commented_code": "void GinIndexStoreDeserializer::initFileStreams()\n {\n     String metadata_file_name = store->getName() + GinIndexStore::GIN_SEGMENT_METADATA_FILE_TYPE;\n+    String bloom_filter_file_name = store->getName() + GinIndexStore::GIN_BLOOM_FILTER_FILE_TYPE;\n     String dict_file_name = store->getName() + GinIndexStore::GIN_DICTIONARY_FILE_TYPE;\n     String postings_file_name = store->getName() + GinIndexStore::GIN_POSTINGS_FILE_TYPE;\n \n     metadata_file_stream = store->storage->readFile(metadata_file_name, {}, std::nullopt, std::nullopt);\n+    bloom_filter_file_stream = store->storage->readFile(bloom_filter_file_name, {}, std::nullopt, std::nullopt);\n     dict_file_stream = store->storage->readFile(dict_file_name, {}, std::nullopt, std::nullopt);\n     postings_file_stream = store->storage->readFile(postings_file_name, {}, std::nullopt, std::nullopt);\n }\n+\n void GinIndexStoreDeserializer::readSegments()\n {\n     UInt32 num_segments = store->getNumOfSegments();\n     if (num_segments == 0)\n         return;\n \n-    using GinIndexSegments = std::vector<GinIndexSegment>;\n-    GinIndexSegments segments (num_segments);\n-\n     assert(metadata_file_stream != nullptr);\n \n-    metadata_file_stream->readStrict(reinterpret_cast<char *>(segments.data()), num_segments * sizeof(GinIndexSegment));\n-    for (UInt32 i = 0; i < num_segments; ++i)\n+    if (store->getVersion() == GinIndexStore::Format::v1)\n     {\n-        auto seg_id = segments[i].segment_id;\n-        auto seg_dict = std::make_shared<GinSegmentDictionary>();\n-        seg_dict->postings_start_offset = segments[i].postings_start_offset;\n-        seg_dict->dict_start_offset = segments[i].dict_start_offset;\n-        store->segment_dictionaries[seg_id] = seg_dict;\n+        std::vector<GinIndexSegment> segments(num_segments);\n+        metadata_file_stream->readStrict(reinterpret_cast<char *>(segments.data()), num_segments * sizeof(GinIndexSegment));\n+        for (UInt32 i = 0; i < num_segments; ++i)\n+        {\n+            auto seg_dict = std::make_shared<GinSegmentDictionary>();\n+            seg_dict->postings_start_offset = segments[i].postings_start_offset;\n+            seg_dict->dict_start_offset = segments[i].dict_start_offset;\n+            seg_dict->bloom_filter_start_offset = segments[i].bloom_filter_start_offset;\n+            store->segment_dictionaries[segments[i].segment_id] = seg_dict;\n+        }\n     }\n }\n \n-void GinIndexStoreDeserializer::readSegmentDictionaries()\n+void GinIndexStoreDeserializer::prepareSegmentsForReading()\n {\n     for (UInt32 seg_index = 0; seg_index < store->getNumOfSegments(); ++seg_index)\n-        readSegmentDictionary(seg_index);\n+        prepareSegmentForReading(seg_index);\n }\n \n-void GinIndexStoreDeserializer::readSegmentDictionary(UInt32 segment_id)\n+void GinIndexStoreDeserializer::prepareSegmentForReading(UInt32 segment_id)\n {\n     /// Check validity of segment_id\n     auto it = store->segment_dictionaries.find(segment_id);\n     if (it == store->segment_dictionaries.end())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid segment id {}\", segment_id);\n \n+    const GinSegmentDictionaryPtr & seg_dict = it->second;\n+    switch (auto version = store->getVersion(); version)\n+    {\n+        case GinIndexStore::Format::v1: {\n+            /// V1 supports bloom filter, so we can delay reading a segment until it's needed.\n+\n+            /// Set file pointer of filter file\n+            assert(bloom_filter_file_stream != nullptr);\n+            bloom_filter_file_stream->seek(it->second->bloom_filter_start_offset, SEEK_SET);\n+            seg_dict->bloom_filter = GinSegmentDictionaryBloomFilter::deserialize(*bloom_filter_file_stream);\n+            break;\n+        }\n+    }\n+}\n+\n+void GinIndexStoreDeserializer::readSegmentFST(GinSegmentDictionaryPtr segment_dictionary)\n+{\n+    std::scoped_lock lock(segment_dictionary->mutex_fst);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2266492461",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85356,
        "pr_file": "src/Storages/MergeTree/GinIndexStore.cpp",
        "discussion_id": "2266492461",
        "commented_code": "@@ -436,52 +533,76 @@ GinIndexStoreDeserializer::GinIndexStoreDeserializer(const GinIndexStorePtr & st\n void GinIndexStoreDeserializer::initFileStreams()\n {\n     String metadata_file_name = store->getName() + GinIndexStore::GIN_SEGMENT_METADATA_FILE_TYPE;\n+    String bloom_filter_file_name = store->getName() + GinIndexStore::GIN_BLOOM_FILTER_FILE_TYPE;\n     String dict_file_name = store->getName() + GinIndexStore::GIN_DICTIONARY_FILE_TYPE;\n     String postings_file_name = store->getName() + GinIndexStore::GIN_POSTINGS_FILE_TYPE;\n \n     metadata_file_stream = store->storage->readFile(metadata_file_name, {}, std::nullopt, std::nullopt);\n+    bloom_filter_file_stream = store->storage->readFile(bloom_filter_file_name, {}, std::nullopt, std::nullopt);\n     dict_file_stream = store->storage->readFile(dict_file_name, {}, std::nullopt, std::nullopt);\n     postings_file_stream = store->storage->readFile(postings_file_name, {}, std::nullopt, std::nullopt);\n }\n+\n void GinIndexStoreDeserializer::readSegments()\n {\n     UInt32 num_segments = store->getNumOfSegments();\n     if (num_segments == 0)\n         return;\n \n-    using GinIndexSegments = std::vector<GinIndexSegment>;\n-    GinIndexSegments segments (num_segments);\n-\n     assert(metadata_file_stream != nullptr);\n \n-    metadata_file_stream->readStrict(reinterpret_cast<char *>(segments.data()), num_segments * sizeof(GinIndexSegment));\n-    for (UInt32 i = 0; i < num_segments; ++i)\n+    if (store->getVersion() == GinIndexStore::Format::v1)\n     {\n-        auto seg_id = segments[i].segment_id;\n-        auto seg_dict = std::make_shared<GinSegmentDictionary>();\n-        seg_dict->postings_start_offset = segments[i].postings_start_offset;\n-        seg_dict->dict_start_offset = segments[i].dict_start_offset;\n-        store->segment_dictionaries[seg_id] = seg_dict;\n+        std::vector<GinIndexSegment> segments(num_segments);\n+        metadata_file_stream->readStrict(reinterpret_cast<char *>(segments.data()), num_segments * sizeof(GinIndexSegment));\n+        for (UInt32 i = 0; i < num_segments; ++i)\n+        {\n+            auto seg_dict = std::make_shared<GinSegmentDictionary>();\n+            seg_dict->postings_start_offset = segments[i].postings_start_offset;\n+            seg_dict->dict_start_offset = segments[i].dict_start_offset;\n+            seg_dict->bloom_filter_start_offset = segments[i].bloom_filter_start_offset;\n+            store->segment_dictionaries[segments[i].segment_id] = seg_dict;\n+        }\n     }\n }\n \n-void GinIndexStoreDeserializer::readSegmentDictionaries()\n+void GinIndexStoreDeserializer::prepareSegmentsForReading()\n {\n     for (UInt32 seg_index = 0; seg_index < store->getNumOfSegments(); ++seg_index)\n-        readSegmentDictionary(seg_index);\n+        prepareSegmentForReading(seg_index);\n }\n \n-void GinIndexStoreDeserializer::readSegmentDictionary(UInt32 segment_id)\n+void GinIndexStoreDeserializer::prepareSegmentForReading(UInt32 segment_id)\n {\n     /// Check validity of segment_id\n     auto it = store->segment_dictionaries.find(segment_id);\n     if (it == store->segment_dictionaries.end())\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid segment id {}\", segment_id);\n \n+    const GinSegmentDictionaryPtr & seg_dict = it->second;\n+    switch (auto version = store->getVersion(); version)\n+    {\n+        case GinIndexStore::Format::v1: {\n+            /// V1 supports bloom filter, so we can delay reading a segment until it's needed.\n+\n+            /// Set file pointer of filter file\n+            assert(bloom_filter_file_stream != nullptr);\n+            bloom_filter_file_stream->seek(it->second->bloom_filter_start_offset, SEEK_SET);\n+            seg_dict->bloom_filter = GinSegmentDictionaryBloomFilter::deserialize(*bloom_filter_file_stream);\n+            break;\n+        }\n+    }\n+}\n+\n+void GinIndexStoreDeserializer::readSegmentFST(GinSegmentDictionaryPtr segment_dictionary)\n+{\n+    std::scoped_lock lock(segment_dictionary->mutex_fst);",
        "comment_created_at": "2025-08-11T12:01:07+00:00",
        "comment_author": "rschu1ze",
        "comment_body": "We should use `std::lock_guard` here ([SO](https://stackoverflow.com/questions/43019598/stdlock-guard-or-stdscoped-lock)).\n\nMore importantly, the caller `readSegmentedPostingsLists` accesses `fst` as well:\n\n```cpp\nif (seg_dict.second->fst == nullptr)\n```\n\nTSAN will sooner or later complain. It technically comes down to the question if the pointer itself needs synchronization or only the pointed-to object. I would argue for the former - the pointer gets set once the FST is loaded.\n\nTherefore, can we omit locking here and rewrite `readSegmentedPostingsLists` to something like this:\n\n```cpp\nFST::FiniteStateTransducer::Output fst_output;\n\n{\n    std::lock_guard lock(segment_dictionary.second->fst_mutex);\n\n    if (segment_dictionary.second->fst == nullptr)\n    {\n        /// Segment dictionary is not loaded. First check the bloom filter if we can avoid the load.\n        if (segment_dictionary.second->bloom_filter && !segment_dictionary.second->bloom_filter->contains(term))\n            continue;\n\n        /// Term might be in segment dictionary\n        readSegmentFST(segment_dictionary.second);\n    }\n\n    fst_output = segment_dictionary.second->fst->getOutput(term);\n    if (!fst_output.found)\n        continue;\n}\n```\n\n(I also changed the return type of `FiniteStateTransducer::getOutput` a little bit:\n\n```cpp\nstruct Output {\n    UInt64 offset;\n    bool found;\n};\nOutput getOutput(std::string_view term);\n```\n\n)",
        "pr_file_module": null
      }
    ]
  }
]