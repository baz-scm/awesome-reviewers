[
  {
    "discussion_id": "2271246122",
    "pr_number": 85010,
    "pr_file": "src/Common/CPUID.h",
    "created_at": "2025-08-12T21:08:51+00:00",
    "commented_code": "&& ((CPUInfo(0x7, 0).registers.edx >> 25) & 1u);  // AMX-INT8 bit\n }\n \n+inline bool haveSVE() noexcept\n+{\n+#if defined(__aarch64__)\n+    /// https://www.kernel.org/doc/Documentation/arm64/sve.txt",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2271246122",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85010,
        "pr_file": "src/Common/CPUID.h",
        "discussion_id": "2271246122",
        "commented_code": "@@ -305,6 +309,17 @@ inline bool haveAMXINT8() noexcept\n             && ((CPUInfo(0x7, 0).registers.edx >> 25) & 1u);  // AMX-INT8 bit\n }\n \n+inline bool haveSVE() noexcept\n+{\n+#if defined(__aarch64__)\n+    /// https://www.kernel.org/doc/Documentation/arm64/sve.txt",
        "comment_created_at": "2025-08-12T21:08:51+00:00",
        "comment_author": "rschu1ze",
        "comment_body": "The same docs say\n\n```\n* Support for the execution of SVE instructions in userspace can also be\n  detected by reading the CPU ID register ID_AA64PFR0_EL1 using an MRS\n  instruction, and checking that the value of the SVE field is nonzero. [3]\n```\n\nWondering why we don't do that? It seems more \"direct\" than checking hwcap \\+ it would be more consistent with how other SIMD capabilities are checked above (l. 309).",
        "pr_file_module": null
      },
      {
        "comment_id": "2281345121",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85010,
        "pr_file": "src/Common/CPUID.h",
        "discussion_id": "2271246122",
        "commented_code": "@@ -305,6 +309,17 @@ inline bool haveAMXINT8() noexcept\n             && ((CPUInfo(0x7, 0).registers.edx >> 25) & 1u);  // AMX-INT8 bit\n }\n \n+inline bool haveSVE() noexcept\n+{\n+#if defined(__aarch64__)\n+    /// https://www.kernel.org/doc/Documentation/arm64/sve.txt",
        "comment_created_at": "2025-08-18T05:42:57+00:00",
        "comment_author": "rajatma1993",
        "comment_body": "Initially, we implemented SVE detection using the \"mrs\" method ([reference](https://github.com/ClickHouse/ClickHouse/pull/85010#discussion_r2251740453)) as per comments. Following review comments, this was later updated to use the HWCAP-based approach. We also believe the \"HWCAP\" method is generally more appropriate for detection.\r\n\r\nNow, we\u2019ve received a suggestion to revert back to the mrs method. Are we correct in understanding that this is being proposed mainly for the reasons you outlined earlier (More Direct , Consistency) rather than for functional or correctness concerns?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2281403605",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85010,
        "pr_file": "src/Common/CPUID.h",
        "discussion_id": "2271246122",
        "commented_code": "@@ -305,6 +309,17 @@ inline bool haveAMXINT8() noexcept\n             && ((CPUInfo(0x7, 0).registers.edx >> 25) & 1u);  // AMX-INT8 bit\n }\n \n+inline bool haveSVE() noexcept\n+{\n+#if defined(__aarch64__)\n+    /// https://www.kernel.org/doc/Documentation/arm64/sve.txt",
        "comment_created_at": "2025-08-18T06:22:50+00:00",
        "comment_author": "rschu1ze",
        "comment_body": "Please use the more reliable and more portable method ... which seems to be HWCAP as far as I read the [Linux docs](https://www.kernel.org/doc/Documentation/arm64/sve.txt).\r\n\r\nHowever, to minimize surprise for the next person who reads the code, it is not enough to just include an URL as a comment. We should also include the relevant paragraph:\r\n\r\n```\r\n\r\n* Support for the execution of SVE instructions in userspace can also be\r\n  detected by reading the CPU ID register ID_AA64PFR0_EL1 using an MRS\r\n  instruction, and checking that the value of the SVE field is nonzero. [3]\r\n\r\n  It does not guarantee the presence of the system interfaces described in the\r\n  following sections: software that needs to verify that those interfaces are\r\n  present must check for HWCAP_SVE instead.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2281436868",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85010,
        "pr_file": "src/Common/CPUID.h",
        "discussion_id": "2271246122",
        "commented_code": "@@ -305,6 +309,17 @@ inline bool haveAMXINT8() noexcept\n             && ((CPUInfo(0x7, 0).registers.edx >> 25) & 1u);  // AMX-INT8 bit\n }\n \n+inline bool haveSVE() noexcept\n+{\n+#if defined(__aarch64__)\n+    /// https://www.kernel.org/doc/Documentation/arm64/sve.txt",
        "comment_created_at": "2025-08-18T06:43:04+00:00",
        "comment_author": "rajatma1993",
        "comment_body": "@rschu1ze, Thanks for confirmation. will fallow suggestion going forward.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218976086",
    "pr_number": 76802,
    "pr_file": "src/Storages/ObjectStorage/HDFS/Configuration.h",
    "created_at": "2025-07-21T11:54:26+00:00",
    "commented_code": "std::string getSignatures(bool with_structure = true) const { return with_structure ? signatures_with_structure : signatures_without_structure; }\n     size_t getMaxNumberOfArguments(bool with_structure = true) const { return with_structure ? max_number_of_arguments_with_structure : max_number_of_arguments_without_structure; }\n \n-    Path getPath() const override { return path; }\n-    void setPath(const Path & path_) override { path = path_; }\n+    /// Unlike s3 and azure, which are object storages,\n+    /// hdfs is a filesystem, so it cannot list files by partial prefix,\n+    /// only by directory.",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2218976086",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/ObjectStorage/HDFS/Configuration.h",
        "discussion_id": "2218976086",
        "commented_code": "@@ -39,12 +39,22 @@ class StorageHDFSConfiguration : public StorageObjectStorageConfiguration\n     std::string getSignatures(bool with_structure = true) const { return with_structure ? signatures_with_structure : signatures_without_structure; }\n     size_t getMaxNumberOfArguments(bool with_structure = true) const { return with_structure ? max_number_of_arguments_with_structure : max_number_of_arguments_without_structure; }\n \n-    Path getPath() const override { return path; }\n-    void setPath(const Path & path_) override { path = path_; }\n+    /// Unlike s3 and azure, which are object storages,\n+    /// hdfs is a filesystem, so it cannot list files by partial prefix,\n+    /// only by directory.",
        "comment_created_at": "2025-07-21T11:54:26+00:00",
        "comment_author": "kssenii",
        "comment_body": "```suggestion\r\n    /// Unlike s3 and azure, which are object storages,\r\n    /// hdfs is a filesystem, so it cannot list files by partial prefix,\r\n    /// only by directory. \r\n    /// Therefore in the below methods we use allow_partial_prefix=false.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]