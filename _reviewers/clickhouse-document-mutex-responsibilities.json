[
  {
    "discussion_id": "2107022951",
    "pr_number": 77153,
    "pr_file": "src/Interpreters/XRayInstrumentationManager.h",
    "created_at": "2025-05-26T10:22:26+00:00",
    "commented_code": "+#pragma once\n+\n+#include \"Interpreters/Context_fwd.h\"\n+#include \"base/types.h\"\n+#include \"config.h\"\n+\n+#if USE_XRAY\n+\n+#include <string>\n+#include <unordered_map>\n+#include <list>\n+#include <vector>\n+#include <mutex>\n+#include <shared_mutex>\n+#include <variant>\n+#include <xray/xray_interface.h>\n+\n+namespace DB\n+{\n+\n+enum class HandlerType\n+{\n+    Sleep,\n+    Log,\n+    Profile,\n+};\n+\n+using XRayHandlerFunction = void(*)(int32_t, XRayEntryType);\n+using InstrumentParameter = std::variant<String, Int64, Float64>;\n+\n+class XRayInstrumentationManager\n+{\n+public:\n+\n+    struct InstrumentedFunctionInfo\n+    {\n+        uint64_t instrumentation_point_id;\n+        uint32_t function_id;\n+        std::string function_name;\n+        std::string handler_name;\n+        std::optional<std::vector<InstrumentParameter>> parameters;\n+        ContextPtr context;\n+    };\n+    static XRayInstrumentationManager & instance();\n+\n+    void setHandlerAndPatch(const std::string & function_name, const std::string & handler_name, std::optional<std::vector<InstrumentParameter>> &parameters, ContextPtr context);\n+    void unpatchFunction(const std::string & function_name, const std::string & handler_name);\n+\n+    using InstrumentedFunctions = std::list<InstrumentedFunctionInfo>;\n+    using HandlerTypeToIP = std::unordered_map<HandlerType, std::list<InstrumentedFunctionInfo>::iterator>;\n+    InstrumentedFunctions getInstrumentedFunctions()\n+    {\n+        std::lock_guard lock(functions_to_instrument_mutex);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2107022951",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 77153,
        "pr_file": "src/Interpreters/XRayInstrumentationManager.h",
        "discussion_id": "2107022951",
        "commented_code": "@@ -0,0 +1,90 @@\n+#pragma once\n+\n+#include \"Interpreters/Context_fwd.h\"\n+#include \"base/types.h\"\n+#include \"config.h\"\n+\n+#if USE_XRAY\n+\n+#include <string>\n+#include <unordered_map>\n+#include <list>\n+#include <vector>\n+#include <mutex>\n+#include <shared_mutex>\n+#include <variant>\n+#include <xray/xray_interface.h>\n+\n+namespace DB\n+{\n+\n+enum class HandlerType\n+{\n+    Sleep,\n+    Log,\n+    Profile,\n+};\n+\n+using XRayHandlerFunction = void(*)(int32_t, XRayEntryType);\n+using InstrumentParameter = std::variant<String, Int64, Float64>;\n+\n+class XRayInstrumentationManager\n+{\n+public:\n+\n+    struct InstrumentedFunctionInfo\n+    {\n+        uint64_t instrumentation_point_id;\n+        uint32_t function_id;\n+        std::string function_name;\n+        std::string handler_name;\n+        std::optional<std::vector<InstrumentParameter>> parameters;\n+        ContextPtr context;\n+    };\n+    static XRayInstrumentationManager & instance();\n+\n+    void setHandlerAndPatch(const std::string & function_name, const std::string & handler_name, std::optional<std::vector<InstrumentParameter>> &parameters, ContextPtr context);\n+    void unpatchFunction(const std::string & function_name, const std::string & handler_name);\n+\n+    using InstrumentedFunctions = std::list<InstrumentedFunctionInfo>;\n+    using HandlerTypeToIP = std::unordered_map<HandlerType, std::list<InstrumentedFunctionInfo>::iterator>;\n+    InstrumentedFunctions getInstrumentedFunctions()\n+    {\n+        std::lock_guard lock(functions_to_instrument_mutex);",
        "comment_created_at": "2025-05-26T10:22:26+00:00",
        "comment_author": "pamarcos",
        "comment_body": "What's this mutex `functions_to_instrument_mutex` supposed to protect against?\r\nIt's only locked here and nowhere else. Maybe you mean to use the `mutex` from this class instead?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2107034581",
    "pr_number": 77153,
    "pr_file": "src/Interpreters/XRayInstrumentationManager.h",
    "created_at": "2025-05-26T10:29:16+00:00",
    "commented_code": "+#pragma once\n+\n+#include \"Interpreters/Context_fwd.h\"\n+#include \"base/types.h\"\n+#include \"config.h\"\n+\n+#if USE_XRAY\n+\n+#include <string>\n+#include <unordered_map>\n+#include <list>\n+#include <vector>\n+#include <mutex>\n+#include <shared_mutex>\n+#include <variant>\n+#include <xray/xray_interface.h>\n+\n+namespace DB\n+{\n+\n+enum class HandlerType\n+{\n+    Sleep,\n+    Log,\n+    Profile,\n+};\n+\n+using XRayHandlerFunction = void(*)(int32_t, XRayEntryType);\n+using InstrumentParameter = std::variant<String, Int64, Float64>;\n+\n+class XRayInstrumentationManager\n+{\n+public:\n+\n+    struct InstrumentedFunctionInfo\n+    {\n+        uint64_t instrumentation_point_id;\n+        uint32_t function_id;\n+        std::string function_name;\n+        std::string handler_name;\n+        std::optional<std::vector<InstrumentParameter>> parameters;\n+        ContextPtr context;\n+    };\n+    static XRayInstrumentationManager & instance();\n+\n+    void setHandlerAndPatch(const std::string & function_name, const std::string & handler_name, std::optional<std::vector<InstrumentParameter>> &parameters, ContextPtr context);\n+    void unpatchFunction(const std::string & function_name, const std::string & handler_name);\n+\n+    using InstrumentedFunctions = std::list<InstrumentedFunctionInfo>;\n+    using HandlerTypeToIP = std::unordered_map<HandlerType, std::list<InstrumentedFunctionInfo>::iterator>;\n+    InstrumentedFunctions getInstrumentedFunctions()\n+    {\n+        std::lock_guard lock(functions_to_instrument_mutex);\n+        return instrumented_functions;\n+    }\n+\n+private:\n+\n+    XRayInstrumentationManager();\n+    void registerHandler(const std::string & name, XRayHandlerFunction handler);\n+    XRayHandlerFunction getHandler(const std::string & name) const;\n+    void parseXRayInstrumentationMap();\n+    static std::string_view removeTemplateArgs(std::string_view input);\n+    std::string extractNearestNamespaceAndFunction(std::string_view signature);\n+    HandlerType getHandlerType(const std::string & handler_name);\n+\n+    [[clang::xray_never_instrument]] static void dispatchHandler(int32_t FuncId, XRayEntryType Type);\n+    [[clang::xray_never_instrument]] static void sleep(int32_t FuncId, XRayEntryType Type);\n+    [[clang::xray_never_instrument]] static void log(int32_t FuncId, XRayEntryType Type);\n+    [[clang::xray_never_instrument]] static void profile(int32_t FuncId, XRayEntryType Type);\n+\n+    // TODO: more handlers\n+\n+    mutable std::mutex mutex;\n+    uint64_t instrumentation_point_id;\n+    std::mutex functions_to_instrument_mutex;\n+    static std::unordered_map<std::string, XRayHandlerFunction> xrayHandlerNameToFunction;\n+    std::unordered_map<std::string, int64_t> functionNameToXRayID;\n+    std::unordered_map<std::string, std::vector<int64_t>> strippedFunctionNameToXRayID;\n+    static std::unordered_map<int64_t, std::string> xrayIdToFunctionName;\n+    std::list<InstrumentedFunctionInfo> instrumented_functions;\n+    static std::unordered_map<int32_t, HandlerTypeToIP> functionIdToHandlers;\n+\n+    static inline std::mutex log_mutex;\n+    static inline std::shared_mutex shared_mutex;",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2107034581",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 77153,
        "pr_file": "src/Interpreters/XRayInstrumentationManager.h",
        "discussion_id": "2107034581",
        "commented_code": "@@ -0,0 +1,90 @@\n+#pragma once\n+\n+#include \"Interpreters/Context_fwd.h\"\n+#include \"base/types.h\"\n+#include \"config.h\"\n+\n+#if USE_XRAY\n+\n+#include <string>\n+#include <unordered_map>\n+#include <list>\n+#include <vector>\n+#include <mutex>\n+#include <shared_mutex>\n+#include <variant>\n+#include <xray/xray_interface.h>\n+\n+namespace DB\n+{\n+\n+enum class HandlerType\n+{\n+    Sleep,\n+    Log,\n+    Profile,\n+};\n+\n+using XRayHandlerFunction = void(*)(int32_t, XRayEntryType);\n+using InstrumentParameter = std::variant<String, Int64, Float64>;\n+\n+class XRayInstrumentationManager\n+{\n+public:\n+\n+    struct InstrumentedFunctionInfo\n+    {\n+        uint64_t instrumentation_point_id;\n+        uint32_t function_id;\n+        std::string function_name;\n+        std::string handler_name;\n+        std::optional<std::vector<InstrumentParameter>> parameters;\n+        ContextPtr context;\n+    };\n+    static XRayInstrumentationManager & instance();\n+\n+    void setHandlerAndPatch(const std::string & function_name, const std::string & handler_name, std::optional<std::vector<InstrumentParameter>> &parameters, ContextPtr context);\n+    void unpatchFunction(const std::string & function_name, const std::string & handler_name);\n+\n+    using InstrumentedFunctions = std::list<InstrumentedFunctionInfo>;\n+    using HandlerTypeToIP = std::unordered_map<HandlerType, std::list<InstrumentedFunctionInfo>::iterator>;\n+    InstrumentedFunctions getInstrumentedFunctions()\n+    {\n+        std::lock_guard lock(functions_to_instrument_mutex);\n+        return instrumented_functions;\n+    }\n+\n+private:\n+\n+    XRayInstrumentationManager();\n+    void registerHandler(const std::string & name, XRayHandlerFunction handler);\n+    XRayHandlerFunction getHandler(const std::string & name) const;\n+    void parseXRayInstrumentationMap();\n+    static std::string_view removeTemplateArgs(std::string_view input);\n+    std::string extractNearestNamespaceAndFunction(std::string_view signature);\n+    HandlerType getHandlerType(const std::string & handler_name);\n+\n+    [[clang::xray_never_instrument]] static void dispatchHandler(int32_t FuncId, XRayEntryType Type);\n+    [[clang::xray_never_instrument]] static void sleep(int32_t FuncId, XRayEntryType Type);\n+    [[clang::xray_never_instrument]] static void log(int32_t FuncId, XRayEntryType Type);\n+    [[clang::xray_never_instrument]] static void profile(int32_t FuncId, XRayEntryType Type);\n+\n+    // TODO: more handlers\n+\n+    mutable std::mutex mutex;\n+    uint64_t instrumentation_point_id;\n+    std::mutex functions_to_instrument_mutex;\n+    static std::unordered_map<std::string, XRayHandlerFunction> xrayHandlerNameToFunction;\n+    std::unordered_map<std::string, int64_t> functionNameToXRayID;\n+    std::unordered_map<std::string, std::vector<int64_t>> strippedFunctionNameToXRayID;\n+    static std::unordered_map<int64_t, std::string> xrayIdToFunctionName;\n+    std::list<InstrumentedFunctionInfo> instrumented_functions;\n+    static std::unordered_map<int32_t, HandlerTypeToIP> functionIdToHandlers;\n+\n+    static inline std::mutex log_mutex;\n+    static inline std::shared_mutex shared_mutex;",
        "comment_created_at": "2025-05-26T10:29:16+00:00",
        "comment_author": "pamarcos",
        "comment_body": "There's something very useful we use in ClickHouse which are macros to decorate functions/variables/mutexes for Clang's Thread Safety Analysis (TSA). That's yet another static analyzer that complains whenever some code touches some variables without prior lock of the mutex.\r\n\r\nThose macros help not only the analyzer but the reader to understand what mutexes are protecting what variables. It also helps catch issues early. Sometimes it can be a pain to get the analyzer to understand what you mean, but there are workarounds we can apply.\r\n\r\nIn this sense, please take a look at examples that use TSA such as https://github.com/ClickHouse/ClickHouse/blob/5e7cc223122cb9c57381f716968c99c4edfdf842/src/Interpreters/QueryMetricLog.h#L92-L93 and try to apply them as much as possible.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2279436563",
    "pr_number": 83837,
    "pr_file": "src/Interpreters/Context.h",
    "created_at": "2025-08-15T16:28:07+00:00",
    "commented_code": "std::pair<Context::StorageMetadataCache *, std::unique_lock<std::mutex>> getStorageMetadataCache() const;\n     std::pair<Context::StorageSnapshotCache *, std::unique_lock<std::mutex>> getStorageSnapshotCache() const;\n \n+     /// Information needed in pure index functions (without real column access).\n+    std::pair<IndexContextInfoPtr, std::shared_lock<std::shared_mutex>> getIndexInfo() const",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2279436563",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 83837,
        "pr_file": "src/Interpreters/Context.h",
        "discussion_id": "2279436563",
        "commented_code": "@@ -1456,6 +1468,24 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     std::pair<Context::StorageMetadataCache *, std::unique_lock<std::mutex>> getStorageMetadataCache() const;\n     std::pair<Context::StorageSnapshotCache *, std::unique_lock<std::mutex>> getStorageSnapshotCache() const;\n \n+     /// Information needed in pure index functions (without real column access).\n+    std::pair<IndexContextInfoPtr, std::shared_lock<std::shared_mutex>> getIndexInfo() const",
        "comment_created_at": "2025-08-15T16:28:07+00:00",
        "comment_author": "ahmadov",
        "comment_body": "Maybe add a simple comment that functions can access this info in parallel but only for reading purpose. Also, maybe return `std::pair<const IndexContextInfoPtr, ...` as another hint that it's not modifiable ",
        "pr_file_module": null
      }
    ]
  }
]