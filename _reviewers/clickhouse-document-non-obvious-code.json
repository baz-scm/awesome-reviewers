[
  {
    "discussion_id": "2278697643",
    "pr_number": 85538,
    "pr_file": "src/Storages/HivePartitioningUtils.h",
    "created_at": "2025-08-15T09:39:30+00:00",
    "commented_code": "const NamesAndTypesList & hive_partition_columns_to_read_from_file_path,\n     const std::string & path);\n \n-void extractPartitionColumnsFromPathAndEnrichStorageColumns(\n-    ColumnsDescription & storage_columns,\n-    NamesAndTypesList & hive_partition_columns_to_read_from_file_path,\n-    const std::string & path,\n+std::pair<NamesAndTypesList, NamesAndTypesList> setupHivePartitioningForObjectStorage(\n+    ColumnsDescription & columns,\n+    const StorageObjectStorageConfigurationPtr & configuration,\n+    const std::string & sample_path,\n+    bool inferred_schema,\n+    std::optional<FormatSettings> format_settings,\n+    ContextPtr context);\n+\n+std::pair<NamesAndTypesList, NamesAndTypesList> setupHivePartitioningForFileURLLikeStorage(",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2278697643",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85538,
        "pr_file": "src/Storages/HivePartitioningUtils.h",
        "discussion_id": "2278697643",
        "commented_code": "@@ -19,14 +20,22 @@ void addPartitionColumnsToChunk(\n     const NamesAndTypesList & hive_partition_columns_to_read_from_file_path,\n     const std::string & path);\n \n-void extractPartitionColumnsFromPathAndEnrichStorageColumns(\n-    ColumnsDescription & storage_columns,\n-    NamesAndTypesList & hive_partition_columns_to_read_from_file_path,\n-    const std::string & path,\n+std::pair<NamesAndTypesList, NamesAndTypesList> setupHivePartitioningForObjectStorage(\n+    ColumnsDescription & columns,\n+    const StorageObjectStorageConfigurationPtr & configuration,\n+    const std::string & sample_path,\n+    bool inferred_schema,\n+    std::optional<FormatSettings> format_settings,\n+    ContextPtr context);\n+\n+std::pair<NamesAndTypesList, NamesAndTypesList> setupHivePartitioningForFileURLLikeStorage(",
        "comment_created_at": "2025-08-15T09:39:30+00:00",
        "comment_author": "kssenii",
        "comment_body": "Please add a comment about return values, as `std::pair<NamesAndTypesList, NamesAndTypesList>` is not self-explanatory.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167491219",
    "pr_number": 81040,
    "pr_file": "src/Storages/ObjectStorageQueue/ObjectStorageQueueIFileMetadata.h",
    "created_at": "2025-06-25T19:48:12+00:00",
    "commented_code": "void resetProcessing();\n \n     /// Prepare keeper requests, required to set file as Processed.\n-    void prepareProcessedRequests(Coordination::Requests & requests);\n+    void prepareProcessedRequests(Coordination::Requests & requests,\n+        LastProcessedFileInfoMapPtr created_nodes = nullptr);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2167491219",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 81040,
        "pr_file": "src/Storages/ObjectStorageQueue/ObjectStorageQueueIFileMetadata.h",
        "discussion_id": "2167491219",
        "commented_code": "@@ -81,13 +98,17 @@ class ObjectStorageQueueIFileMetadata\n     void resetProcessing();\n \n     /// Prepare keeper requests, required to set file as Processed.\n-    void prepareProcessedRequests(Coordination::Requests & requests);\n+    void prepareProcessedRequests(Coordination::Requests & requests,\n+        LastProcessedFileInfoMapPtr created_nodes = nullptr);",
        "comment_created_at": "2025-06-25T19:48:12+00:00",
        "comment_author": "kssenii",
        "comment_body": "Please add a short comment above the method about what `created_nodes` is used for / when is it passed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2258025710",
    "pr_number": 84435,
    "pr_file": "src/Storages/MergeTree/GinIndexStore.h",
    "created_at": "2025-08-06T19:01:55+00:00",
    "commented_code": "static const CompressionCodecPtr & zstdCodec();\n };\n \n+#if USE_FASTPFOR\n+class GinIndexPostingListDeltaPforCompression",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2258025710",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84435,
        "pr_file": "src/Storages/MergeTree/GinIndexStore.h",
        "discussion_id": "2258025710",
        "commented_code": "@@ -49,6 +50,45 @@ class GinIndexCompressionFactory\n     static const CompressionCodecPtr & zstdCodec();\n };\n \n+#if USE_FASTPFOR\n+class GinIndexPostingListDeltaPforCompression",
        "comment_created_at": "2025-08-06T19:01:55+00:00",
        "comment_author": "rschu1ze",
        "comment_body": "This class and the one in l. 76 need a brief class-level code comment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2145160386",
    "pr_number": 76802,
    "pr_file": "src/Core/NamesAndTypes.h",
    "created_at": "2025-06-13T13:56:16+00:00",
    "commented_code": "NameSet getNameSet() const;\n     DataTypes getTypes() const;\n \n+    std::unordered_map<std::string, NameAndTypePair> getNameToPairMap() const;",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2145160386",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Core/NamesAndTypes.h",
        "discussion_id": "2145160386",
        "commented_code": "@@ -101,6 +101,8 @@ class NamesAndTypesList : public std::list<NameAndTypePair>\n     NameSet getNameSet() const;\n     DataTypes getTypes() const;\n \n+    std::unordered_map<std::string, NameAndTypePair> getNameToPairMap() const;",
        "comment_created_at": "2025-06-13T13:56:16+00:00",
        "comment_author": "kssenii",
        "comment_body": "Please add a comment in code to explain what this method does, as its name is not quite self-explanatory.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2146821531",
    "pr_number": 76802,
    "pr_file": "src/Storages/ObjectStorage/StorageObjectStorage.h",
    "created_at": "2025-06-14T11:12:11+00:00",
    "commented_code": "Configuration() = default;\n     virtual ~Configuration() = default;\n \n-    using Path = std::string;\n+    struct Path\n+    {\n+        Path() = default;\n+        Path(const std::string & path_) : path(path_) {} /// NOLINT(google-explicit-constructor)\n+        Path(const std::string & path_, bool allow_partial_prefix_) : path(path_), allow_partial_prefix(allow_partial_prefix_) {}",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2146821531",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/ObjectStorage/StorageObjectStorage.h",
        "discussion_id": "2146821531",
        "commented_code": "@@ -175,7 +177,23 @@ class StorageObjectStorage::Configuration\n     Configuration() = default;\n     virtual ~Configuration() = default;\n \n-    using Path = std::string;\n+    struct Path\n+    {\n+        Path() = default;\n+        Path(const std::string & path_) : path(path_) {} /// NOLINT(google-explicit-constructor)\n+        Path(const std::string & path_, bool allow_partial_prefix_) : path(path_), allow_partial_prefix(allow_partial_prefix_) {}",
        "comment_created_at": "2025-06-14T11:12:11+00:00",
        "comment_author": "kssenii",
        "comment_body": "```suggestion\r\n        Path(const std::string & path_, bool allow_partial_prefix_ = true) : path(path_), allow_partial_prefix(allow_partial_prefix_) {}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2146822310",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/ObjectStorage/StorageObjectStorage.h",
        "discussion_id": "2146821531",
        "commented_code": "@@ -175,7 +177,23 @@ class StorageObjectStorage::Configuration\n     Configuration() = default;\n     virtual ~Configuration() = default;\n \n-    using Path = std::string;\n+    struct Path\n+    {\n+        Path() = default;\n+        Path(const std::string & path_) : path(path_) {} /// NOLINT(google-explicit-constructor)\n+        Path(const std::string & path_, bool allow_partial_prefix_) : path(path_), allow_partial_prefix(allow_partial_prefix_) {}",
        "comment_created_at": "2025-06-14T11:17:08+00:00",
        "comment_author": "kssenii",
        "comment_body": "Also please add a comment about what partial prefix is and hence what allow_partial_prefix means.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2146828510",
    "pr_number": 76802,
    "pr_file": "src/Storages/PartitionStrategy.h",
    "created_at": "2025-06-14T11:33:07+00:00",
    "commented_code": "+#pragma once\n+\n+#include <Interpreters/ExpressionActions.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+#include <Processors/Chunk.h>\n+\n+namespace DB\n+{\n+\n+struct PartitionStrategy",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2146828510",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/PartitionStrategy.h",
        "discussion_id": "2146828510",
        "commented_code": "@@ -0,0 +1,100 @@\n+#pragma once\n+\n+#include <Interpreters/ExpressionActions.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+#include <Processors/Chunk.h>\n+\n+namespace DB\n+{\n+\n+struct PartitionStrategy",
        "comment_created_at": "2025-06-14T11:33:07+00:00",
        "comment_author": "kssenii",
        "comment_body": "Let's add a general comment above this struct about what is this class. Same for `PartitionStrategyFactory`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2150044549",
    "pr_number": 76802,
    "pr_file": "src/Storages/PartitionStrategy.h",
    "created_at": "2025-06-16T13:41:32+00:00",
    "commented_code": "+#pragma once\n+\n+#include <Interpreters/ExpressionActions.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+#include <Processors/Chunk.h>\n+\n+namespace DB\n+{\n+\n+/*\n+ * Class responsible for computing and generating a partition key for object storage.\n+ * As of now, there are two possible implementations: hive and stringfied.\n+ *\n+ * It also offers some helper APIs like `getFormatChunk` and `getFormatHeader`. Required mostly because of `hive` strategy\n+ * since the default behavior is not to write partition columns in the files and rely only on the filepath.\n+ */\n+struct PartitionStrategy\n+{\n+    struct PartitionExpressionActionsAndColumnName\n+    {\n+        ExpressionActionsPtr actions;\n+        std::string column_name;\n+    };\n+\n+    PartitionStrategy(ASTPtr partition_by_, const Block & sample_block_, ContextPtr context_);\n+\n+    virtual ~PartitionStrategy() = default;\n+\n+    virtual ColumnPtr computePartitionKey(const Chunk & chunk) = 0;\n+\n+    virtual std::string getPathForRead(const std::string & prefix) = 0;\n+    virtual std::string getPathForWrite(const std::string & prefix, const std::string & partition_key) = 0;\n+\n+    virtual Chunk getFormatChunk(const Chunk & chunk) { return chunk.clone(); }\n+\n+    virtual Block getFormatHeader() { return sample_block; }\n+\n+    const NamesAndTypesList & getPartitionColumns() const;\n+\n+protected:\n+    ASTPtr partition_by;\n+    Block sample_block;\n+    ContextPtr context;\n+    NamesAndTypesList partition_columns;\n+};\n+\n+/*\n+ * Tries to create a partition strategy given a strategy name.\n+ * Performs validation on required arguments by each strategy. Example: Partition strategy hive can not be used without a PARTITION BY expression\n+ */\n+struct PartitionStrategyFactory\n+{\n+    enum class StrategyType\n+    {\n+        WILDCARD,\n+        HIVE\n+    };\n+\n+    static std::shared_ptr<PartitionStrategy> get(\n+        StrategyType strategy,\n+        ASTPtr partition_by,\n+        const Block & sample_block,\n+        ContextPtr context,\n+        const std::string & file_format,\n+        bool globbed_path,\n+        bool partition_columns_in_data_file);\n+\n+    static std::shared_ptr<PartitionStrategy> get(\n+        StrategyType strategy,\n+        ASTPtr partition_by,\n+        const NamesAndTypesList & partition_columns,\n+        ContextPtr context,\n+        const std::string & file_format,\n+        bool globbed_path,\n+        bool partition_columns_in_data_file);\n+};\n+\n+/*\n+ * It is the previous & existing implementation for object storage partitioned writes.\n+ * It simply wraps the partition expression with a `toString` function call\n+ */\n+struct StringifiedPartitionStrategy : PartitionStrategy\n+{\n+    StringifiedPartitionStrategy(ASTPtr partition_by_, const Block & sample_block_, ContextPtr context_);\n+\n+    ColumnPtr computePartitionKey(const Chunk & chunk) override;\n+    std::string getPathForRead(const std::string & prefix) override;\n+    std::string getPathForWrite(const std::string & prefix, const std::string & partition_key) override;\n+\n+private:\n+    PartitionExpressionActionsAndColumnName actions_with_column_name;\n+};\n+\n+struct HiveStylePartitionStrategy : PartitionStrategy",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2150044549",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/PartitionStrategy.h",
        "discussion_id": "2150044549",
        "commented_code": "@@ -0,0 +1,119 @@\n+#pragma once\n+\n+#include <Interpreters/ExpressionActions.h>\n+#include <Parsers/IAST_fwd.h>\n+\n+#include <Processors/Chunk.h>\n+\n+namespace DB\n+{\n+\n+/*\n+ * Class responsible for computing and generating a partition key for object storage.\n+ * As of now, there are two possible implementations: hive and stringfied.\n+ *\n+ * It also offers some helper APIs like `getFormatChunk` and `getFormatHeader`. Required mostly because of `hive` strategy\n+ * since the default behavior is not to write partition columns in the files and rely only on the filepath.\n+ */\n+struct PartitionStrategy\n+{\n+    struct PartitionExpressionActionsAndColumnName\n+    {\n+        ExpressionActionsPtr actions;\n+        std::string column_name;\n+    };\n+\n+    PartitionStrategy(ASTPtr partition_by_, const Block & sample_block_, ContextPtr context_);\n+\n+    virtual ~PartitionStrategy() = default;\n+\n+    virtual ColumnPtr computePartitionKey(const Chunk & chunk) = 0;\n+\n+    virtual std::string getPathForRead(const std::string & prefix) = 0;\n+    virtual std::string getPathForWrite(const std::string & prefix, const std::string & partition_key) = 0;\n+\n+    virtual Chunk getFormatChunk(const Chunk & chunk) { return chunk.clone(); }\n+\n+    virtual Block getFormatHeader() { return sample_block; }\n+\n+    const NamesAndTypesList & getPartitionColumns() const;\n+\n+protected:\n+    ASTPtr partition_by;\n+    Block sample_block;\n+    ContextPtr context;\n+    NamesAndTypesList partition_columns;\n+};\n+\n+/*\n+ * Tries to create a partition strategy given a strategy name.\n+ * Performs validation on required arguments by each strategy. Example: Partition strategy hive can not be used without a PARTITION BY expression\n+ */\n+struct PartitionStrategyFactory\n+{\n+    enum class StrategyType\n+    {\n+        WILDCARD,\n+        HIVE\n+    };\n+\n+    static std::shared_ptr<PartitionStrategy> get(\n+        StrategyType strategy,\n+        ASTPtr partition_by,\n+        const Block & sample_block,\n+        ContextPtr context,\n+        const std::string & file_format,\n+        bool globbed_path,\n+        bool partition_columns_in_data_file);\n+\n+    static std::shared_ptr<PartitionStrategy> get(\n+        StrategyType strategy,\n+        ASTPtr partition_by,\n+        const NamesAndTypesList & partition_columns,\n+        ContextPtr context,\n+        const std::string & file_format,\n+        bool globbed_path,\n+        bool partition_columns_in_data_file);\n+};\n+\n+/*\n+ * It is the previous & existing implementation for object storage partitioned writes.\n+ * It simply wraps the partition expression with a `toString` function call\n+ */\n+struct StringifiedPartitionStrategy : PartitionStrategy\n+{\n+    StringifiedPartitionStrategy(ASTPtr partition_by_, const Block & sample_block_, ContextPtr context_);\n+\n+    ColumnPtr computePartitionKey(const Chunk & chunk) override;\n+    std::string getPathForRead(const std::string & prefix) override;\n+    std::string getPathForWrite(const std::string & prefix, const std::string & partition_key) override;\n+\n+private:\n+    PartitionExpressionActionsAndColumnName actions_with_column_name;\n+};\n+\n+struct HiveStylePartitionStrategy : PartitionStrategy",
        "comment_created_at": "2025-06-16T13:41:32+00:00",
        "comment_author": "kssenii",
        "comment_body": "A comment here like above would be nice as well, just briefly, as not everyone is familiar with what hive style partitioning is, so it will save time for a reader.",
        "pr_file_module": null
      }
    ]
  }
]