[
  {
    "discussion_id": "2277425312",
    "pr_number": 85656,
    "pr_file": "src/Functions/arrayStringConcat.cpp",
    "created_at": "2025-08-14T18:27:42+00:00",
    "commented_code": "REGISTER_FUNCTION(ArrayStringConcat)\n {\n-    FunctionDocumentation::Description description = \"Concatenates the elements of an array of strings into a single string, using the specified delimiter between elements.\";\n-    FunctionDocumentation::Syntax syntax = \"arrayStringConcat(arr[, delimiter])\";\n+    FunctionDocumentation::Description description = R\"(\n+Concatenates string representations of values listed in the array with the provided separator,\n+an optional parameter set to an empty string by default.\n+)\";\n+    FunctionDocumentation::Syntax syntax = \"arrayStringConcat(arr[, separator])\";\n     FunctionDocumentation::Arguments arguments = {\n-        {\"arr\", \"The source array of strings.\", {\"Array(String)\"}},\n-        {\"delimiter\", \"Optional.The delimiter to insert between elements. Defaults to empty string if not specified.\", {\"String\"}}\n+        {\"arr\", \"The array to concatenate.\", {\"Array\"}},",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2277425312",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85656,
        "pr_file": "src/Functions/arrayStringConcat.cpp",
        "discussion_id": "2277425312",
        "commented_code": "@@ -199,19 +199,29 @@ class FunctionArrayStringConcat : public IFunction\n \n REGISTER_FUNCTION(ArrayStringConcat)\n {\n-    FunctionDocumentation::Description description = \"Concatenates the elements of an array of strings into a single string, using the specified delimiter between elements.\";\n-    FunctionDocumentation::Syntax syntax = \"arrayStringConcat(arr[, delimiter])\";\n+    FunctionDocumentation::Description description = R\"(\n+Concatenates string representations of values listed in the array with the provided separator,\n+an optional parameter set to an empty string by default.\n+)\";\n+    FunctionDocumentation::Syntax syntax = \"arrayStringConcat(arr[, separator])\";\n     FunctionDocumentation::Arguments arguments = {\n-        {\"arr\", \"The source array of strings.\", {\"Array(String)\"}},\n-        {\"delimiter\", \"Optional.The delimiter to insert between elements. Defaults to empty string if not specified.\", {\"String\"}}\n+        {\"arr\", \"The array to concatenate.\", {\"Array\"}},",
        "comment_created_at": "2025-08-14T18:27:42+00:00",
        "comment_author": "Blargian",
        "comment_body": "```suggestion\r\n        {\"arr\", \"The array to concatenate.\", {\"Array(T)\"}},\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2277436704",
    "pr_number": 85656,
    "pr_file": "src/Functions/extractGroups.cpp",
    "created_at": "2025-08-14T18:33:07+00:00",
    "commented_code": "REGISTER_FUNCTION(ExtractGroups)\n {\n-    factory.registerFunction<FunctionExtractGroups>();\n+    FunctionDocumentation::Description description = R\"(\n+Extracts all groups from non-overlapping substrings matched by a regular expression.\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"extractAllGroups(text, regexp)\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"s\", \"Input string to extract from.\", {\"String\", \"FixedString\"}},\n+        {\"regexp\", \"Regular expression. Constant.\", {\"const String\", \"const FixedString\"}}\n+    };\n+    FunctionDocumentation::ReturnedValue returned_value = {\"If the function finds at least one matching group, it returns Array(Array(String)) column, clustered by group_id (1 to N, where N is number of capturing groups in regexp). If there is no matching group, it returns an empty array.\", {\"Array(Array(String))\"}};",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2277436704",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85656,
        "pr_file": "src/Functions/extractGroups.cpp",
        "discussion_id": "2277436704",
        "commented_code": "@@ -111,7 +111,35 @@ class FunctionExtractGroups : public IFunction\n \n REGISTER_FUNCTION(ExtractGroups)\n {\n-    factory.registerFunction<FunctionExtractGroups>();\n+    FunctionDocumentation::Description description = R\"(\n+Extracts all groups from non-overlapping substrings matched by a regular expression.\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"extractAllGroups(text, regexp)\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"s\", \"Input string to extract from.\", {\"String\", \"FixedString\"}},\n+        {\"regexp\", \"Regular expression. Constant.\", {\"const String\", \"const FixedString\"}}\n+    };\n+    FunctionDocumentation::ReturnedValue returned_value = {\"If the function finds at least one matching group, it returns Array(Array(String)) column, clustered by group_id (1 to N, where N is number of capturing groups in regexp). If there is no matching group, it returns an empty array.\", {\"Array(Array(String))\"}};",
        "comment_created_at": "2025-08-14T18:33:07+00:00",
        "comment_author": "Blargian",
        "comment_body": "```suggestion\r\n    FunctionDocumentation::ReturnedValue returned_value = {\"If the function finds at least one matching group, it returns Array(Array(String)) column, clustered by group_id (`1` to `N`, where `N` is number of capturing groups in regexp). If there is no matching group, it returns an empty array.\", {\"Array(Array(String))\"}};\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2279674680",
    "pr_number": 85656,
    "pr_file": "src/Functions/alphaTokens.cpp",
    "created_at": "2025-08-15T18:48:51+00:00",
    "commented_code": "REGISTER_FUNCTION(SplitByAlpha)\n {\n-    factory.registerFunction<FunctionSplitByAlpha>();\n+    FunctionDocumentation::Description description = R\"(\n+Selects substrings of consecutive bytes from the ranges `a-z` and `A-Z` and returns an array of the selected substrings.\n+)\";\n+    FunctionDocumentation::Syntax syntax = \"alphaTokens(s[, max_substrings])\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"s\", \"The string to split.\", {\"String\"}},\n+        {\"[max_substrings]\", \"Optional. When `max_substrings > 0`, the number of returned substrings will be no more than `max_substrings`, otherwise the function will return as many substrings as possible.\", {\"Int64\"}}",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2279674680",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85656,
        "pr_file": "src/Functions/alphaTokens.cpp",
        "discussion_id": "2279674680",
        "commented_code": "@@ -99,7 +99,31 @@ using FunctionSplitByAlpha = FunctionTokens<SplitByAlphaImpl>;\n \n REGISTER_FUNCTION(SplitByAlpha)\n {\n-    factory.registerFunction<FunctionSplitByAlpha>();\n+    FunctionDocumentation::Description description = R\"(\n+Selects substrings of consecutive bytes from the ranges `a-z` and `A-Z` and returns an array of the selected substrings.\n+)\";\n+    FunctionDocumentation::Syntax syntax = \"alphaTokens(s[, max_substrings])\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"s\", \"The string to split.\", {\"String\"}},\n+        {\"[max_substrings]\", \"Optional. When `max_substrings > 0`, the number of returned substrings will be no more than `max_substrings`, otherwise the function will return as many substrings as possible.\", {\"Int64\"}}",
        "comment_created_at": "2025-08-15T18:48:51+00:00",
        "comment_author": "Blargian",
        "comment_body": "```suggestion\r\n        {\"max_substrings\", \"Optional. When `max_substrings > 0`, the number of returned substrings will be no more than `max_substrings`, otherwise the function will return as many substrings as possible.\", {\"Int64\"}}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2273746154",
    "pr_number": 85548,
    "pr_file": "src/Functions/randConstant.cpp",
    "created_at": "2025-08-13T15:00:09+00:00",
    "commented_code": "REGISTER_FUNCTION(RandConstant)\n {\n-    factory.registerFunction<FunctionBuilderRandConstant>();\n+    FunctionDocumentation::Description description = R\"(\n+Generates a single random value that remains constant across all rows in the current query execution.\n+\n+This function:\n+- Returns the same random value for every row within a single query\n+- Produces different values across separate query executions\n+\n+It is useful for applying consistent random seeds or identifiers across all rows in a dataset\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"randConstant([x])\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"[x]\", \"Optional. An expression that influences the generated random value.\", {\"U)Int*\", \"Float*\", \"Decimal\", \"String\"}}",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2273746154",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85548,
        "pr_file": "src/Functions/randConstant.cpp",
        "discussion_id": "2273746154",
        "commented_code": "@@ -121,7 +121,37 @@ using FunctionBuilderRandConstant = RandomConstantOverloadResolver<UInt32, NameR\n \n REGISTER_FUNCTION(RandConstant)\n {\n-    factory.registerFunction<FunctionBuilderRandConstant>();\n+    FunctionDocumentation::Description description = R\"(\n+Generates a single random value that remains constant across all rows in the current query execution.\n+\n+This function:\n+- Returns the same random value for every row within a single query\n+- Produces different values across separate query executions\n+\n+It is useful for applying consistent random seeds or identifiers across all rows in a dataset\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"randConstant([x])\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"[x]\", \"Optional. An expression that influences the generated random value.\", {\"U)Int*\", \"Float*\", \"Decimal\", \"String\"}}",
        "comment_created_at": "2025-08-13T15:00:09+00:00",
        "comment_author": "Blargian",
        "comment_body": "@rschu1ze, for this one the current description from the markdown of \"An expression that influences the generated random value.\" is greek to me. Is this just a fancy way of saying `x` is a seed for the function? Accepts other types as well like `DateTime`, should we simplify and just go for `(U)Int*, Float* and Decimal`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2274219096",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85548,
        "pr_file": "src/Functions/randConstant.cpp",
        "discussion_id": "2273746154",
        "commented_code": "@@ -121,7 +121,37 @@ using FunctionBuilderRandConstant = RandomConstantOverloadResolver<UInt32, NameR\n \n REGISTER_FUNCTION(RandConstant)\n {\n-    factory.registerFunction<FunctionBuilderRandConstant>();\n+    FunctionDocumentation::Description description = R\"(\n+Generates a single random value that remains constant across all rows in the current query execution.\n+\n+This function:\n+- Returns the same random value for every row within a single query\n+- Produces different values across separate query executions\n+\n+It is useful for applying consistent random seeds or identifiers across all rows in a dataset\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"randConstant([x])\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"[x]\", \"Optional. An expression that influences the generated random value.\", {\"U)Int*\", \"Float*\", \"Decimal\", \"String\"}}",
        "comment_created_at": "2025-08-13T17:54:18+00:00",
        "comment_author": "rschu1ze",
        "comment_body": "The sentence says in a very awkward way that the optional argument provides a way to prevent common subexpression elimination. I posted a longer comment what that is and why it is important below (other functions you documented in this PR use a similar trick).\n\nSee here for the difference: https://fiddle.clickhouse.com/04e6d420-17eb-41ba-98a3-888429345fc9 with and without common subexpression elimination.\n\nWe can write something like this: `The optional argument is ignored, its only purpose is to prevent common subexpression elimination when the same function call is used multiple times in a query.`.",
        "pr_file_module": null
      }
    ]
  }
]