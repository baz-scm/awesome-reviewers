[
  {
    "discussion_id": "2255317281",
    "pr_number": 80414,
    "pr_file": "src/Interpreters/HashJoin/KnownRowsHolder.h",
    "created_at": "2025-08-05T20:53:45+00:00",
    "commented_code": "class KnownRowsHolder<true>\n {\n public:\n-    using Type = PairNoInit<const Columns *, DB::RowRef::SizeT>;\n+    using Type = PairNoInit<const Columns *, RowRef::SizeT>;\n \n private:\n+    struct PairHash\n+    {\n+        std::size_t operator()(const Type & p) const\n+        {\n+            auto h1 = std::hash<const Columns *>{}(p.first);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2255317281",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 80414,
        "pr_file": "src/Interpreters/HashJoin/KnownRowsHolder.h",
        "discussion_id": "2255317281",
        "commented_code": "@@ -19,12 +20,22 @@ template<>\n class KnownRowsHolder<true>\n {\n public:\n-    using Type = PairNoInit<const Columns *, DB::RowRef::SizeT>;\n+    using Type = PairNoInit<const Columns *, RowRef::SizeT>;\n \n private:\n+    struct PairHash\n+    {\n+        std::size_t operator()(const Type & p) const\n+        {\n+            auto h1 = std::hash<const Columns *>{}(p.first);",
        "comment_created_at": "2025-08-05T20:53:45+00:00",
        "comment_author": "nickitat",
        "comment_body": "STL authors decided to use relatively heavy hash functions internally. I think we can use `UInt128HashCRC32`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2267244682",
    "pr_number": 85375,
    "pr_file": "src/IO/readIntText.h",
    "created_at": "2025-08-11T15:59:52+00:00",
    "commented_code": "+#pragma once\n+\n+#include <IO/ReadBuffer.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <base/Decimal_fwd.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_PARSE_NUMBER;\n+}\n+\n+enum class ReadIntTextCheckOverflow : uint8_t\n+{\n+    DO_NOT_CHECK_OVERFLOW,\n+    CHECK_OVERFLOW,\n+};\n+\n+void assertEOF(ReadBuffer & buf);\n+[[noreturn]] void throwReadAfterEOF();\n+\n+template <int base, typename T, typename ReturnType, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW>\n+ReturnType readIntTextInBaseImpl(T & x, ReadBuffer & buf)\n+{\n+    using UnsignedT = make_unsigned_t<T>;\n+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n+    static_assert(2 <= base && base <= 16);\n+\n+    bool negative = false;\n+    UnsignedT res{};\n+    if (buf.eof()) [[unlikely]]\n+    {\n+        if constexpr (throw_exception)\n+            throwReadAfterEOF();\n+        else\n+            return ReturnType(false);\n+    }\n+\n+    const size_t initial_pos = buf.count();\n+    bool has_sign = false;\n+    bool has_number = false;\n+    for (; !buf.eof(); ++buf.position())\n+    {\n+        char c = *buf.position();\n+        char digit;\n+        switch (c)\n+        {\n+            case '+':\n+            {\n+                /// 123+ or +123+, just stop after 123 or +123.\n+                if (has_number)\n+                    goto end;\n+\n+                /// No digits read yet, but we already read sign, like ++, -+.\n+                if (has_sign)\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Cannot parse number with multiple sign (+/-) characters\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+\n+                has_sign = true;\n+                continue;\n+            }\n+            case '-':\n+            {\n+                if (has_number)\n+                    goto end;\n+\n+                if (has_sign)\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Cannot parse number with multiple sign (+/-) characters\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+\n+                if constexpr (is_signed_v<T>)\n+                    negative = true;\n+                else\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Unsigned type must not contain '-' symbol\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+                has_sign = true;\n+                continue;\n+            }\n+            case '0': [[fallthrough]];\n+            case '1': [[fallthrough]];\n+            case '2': [[fallthrough]];\n+            case '3': [[fallthrough]];\n+            case '4': [[fallthrough]];\n+            case '5': [[fallthrough]];\n+            case '6': [[fallthrough]];\n+            case '7': [[fallthrough]];\n+            case '8': [[fallthrough]];\n+            case '9':\n+            {\n+                digit = c - '0';\n+                goto handle_digit;\n+            }\n+            case 'A': [[fallthrough]];\n+            case 'B': [[fallthrough]];\n+            case 'C': [[fallthrough]];\n+            case 'D': [[fallthrough]];\n+            case 'E': [[fallthrough]];\n+            case 'F':\n+            {\n+                if constexpr (base > 10)\n+                {\n+                    digit = c - ('A' - 10);\n+                    goto handle_digit;\n+                }\n+                else\n+                    goto end;\n+            }\n+            case 'a': [[fallthrough]];\n+            case 'b': [[fallthrough]];\n+            case 'c': [[fallthrough]];\n+            case 'd': [[fallthrough]];\n+            case 'e': [[fallthrough]];\n+            case 'f':\n+            {\n+                if constexpr (base > 10)\n+                {\n+                    digit = c - ('a' - 10);\n+                    goto handle_digit;\n+                }\n+                else\n+                    goto end;\n+            }\n+            default:\n+            {\n+                goto end;\n+            }\n+\n+handle_digit:\n+            if constexpr (base != 10)\n+            {\n+                if (digit >= base)\n+                    goto end;\n+            }\n+            has_number = true;\n+            if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW && !is_big_int_v<T>)\n+            {\n+                /// Perform relativelly slow overflow check only when\n+                /// number of decimal digits so far is close to the max for given type.\n+                /// Example: 20 * 10 will overflow Int8.\n+                constexpr size_t max_digits = (base == 10) ? std::numeric_limits<T>::max_digits10 : (\n+                                              (base == 2) ? std::numeric_limits<T>::digits : (\n+                                              (base == 8) ? ((std::numeric_limits<T>::digits + 2) / 3) : (\n+                                              (base == 16) ? ((std::numeric_limits<T>::digits + 3) / 4) : 0)));\n+\n+                if (buf.count() - initial_pos + 1 >= max_digits)\n+                {\n+                    if (negative)\n+                    {\n+                        T signed_res = -res;\n+                        if (common::mulOverflow<T>(signed_res, base, signed_res) ||\n+                            common::subOverflow<T>(signed_res, digit, signed_res))\n+                        {\n+                            if constexpr (throw_exception)\n+                                throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Overflow while parsing a number\");\n+                            else\n+                                return ReturnType(false);\n+                        }\n+\n+                        res = -static_cast<UnsignedT>(signed_res);\n+                    }\n+                    else\n+                    {\n+                        T signed_res = res;\n+                        if (common::mulOverflow<T>(signed_res, base, signed_res) ||\n+                            common::addOverflow<T>(signed_res, digit, signed_res))\n+                        {\n+                            if constexpr (throw_exception)\n+                                throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Overflow while parsing a number\");\n+                            else\n+                                return ReturnType(false);\n+                        }\n+\n+                        res = signed_res;\n+                    }\n+                    break;\n+                }\n+            }\n+            res *= base;\n+            res += digit;\n+        }\n+    }\n+\n+end:\n+    if (!has_number)\n+    {\n+        if constexpr (throw_exception)\n+            throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Cannot parse number without any digits\");\n+        else\n+            return ReturnType(false);\n+    }\n+    x = res;\n+    if constexpr (is_signed_v<T>)\n+    {\n+        if (negative)\n+        {\n+            if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW)\n+            {\n+                if (common::mulOverflow<UnsignedT, Int8, T>(res, -1, x))\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Overflow while parsing a number\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+            }\n+            else\n+                x = -res;\n+        }\n+    }\n+\n+    return ReturnType(true);\n+}\n+\n+template <typename T, typename ReturnType, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW>\n+ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n+{\n+    return readIntTextInBaseImpl<10, T, ReturnType, check_overflow>(x, buf);\n+}\n+\n+\n+/// Parses an integer in a specific base (2 or 8 or 10 or 16).\n+template <int base, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW, typename T>\n+void readIntTextInBase(T & x, ReadBuffer & buf)",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2267244682",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85375,
        "pr_file": "src/IO/readIntText.h",
        "discussion_id": "2267244682",
        "commented_code": "@@ -0,0 +1,378 @@\n+#pragma once\n+\n+#include <IO/ReadBuffer.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <base/Decimal_fwd.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_PARSE_NUMBER;\n+}\n+\n+enum class ReadIntTextCheckOverflow : uint8_t\n+{\n+    DO_NOT_CHECK_OVERFLOW,\n+    CHECK_OVERFLOW,\n+};\n+\n+void assertEOF(ReadBuffer & buf);\n+[[noreturn]] void throwReadAfterEOF();\n+\n+template <int base, typename T, typename ReturnType, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW>\n+ReturnType readIntTextInBaseImpl(T & x, ReadBuffer & buf)\n+{\n+    using UnsignedT = make_unsigned_t<T>;\n+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n+    static_assert(2 <= base && base <= 16);\n+\n+    bool negative = false;\n+    UnsignedT res{};\n+    if (buf.eof()) [[unlikely]]\n+    {\n+        if constexpr (throw_exception)\n+            throwReadAfterEOF();\n+        else\n+            return ReturnType(false);\n+    }\n+\n+    const size_t initial_pos = buf.count();\n+    bool has_sign = false;\n+    bool has_number = false;\n+    for (; !buf.eof(); ++buf.position())\n+    {\n+        char c = *buf.position();\n+        char digit;\n+        switch (c)\n+        {\n+            case '+':\n+            {\n+                /// 123+ or +123+, just stop after 123 or +123.\n+                if (has_number)\n+                    goto end;\n+\n+                /// No digits read yet, but we already read sign, like ++, -+.\n+                if (has_sign)\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Cannot parse number with multiple sign (+/-) characters\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+\n+                has_sign = true;\n+                continue;\n+            }\n+            case '-':\n+            {\n+                if (has_number)\n+                    goto end;\n+\n+                if (has_sign)\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Cannot parse number with multiple sign (+/-) characters\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+\n+                if constexpr (is_signed_v<T>)\n+                    negative = true;\n+                else\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Unsigned type must not contain '-' symbol\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+                has_sign = true;\n+                continue;\n+            }\n+            case '0': [[fallthrough]];\n+            case '1': [[fallthrough]];\n+            case '2': [[fallthrough]];\n+            case '3': [[fallthrough]];\n+            case '4': [[fallthrough]];\n+            case '5': [[fallthrough]];\n+            case '6': [[fallthrough]];\n+            case '7': [[fallthrough]];\n+            case '8': [[fallthrough]];\n+            case '9':\n+            {\n+                digit = c - '0';\n+                goto handle_digit;\n+            }\n+            case 'A': [[fallthrough]];\n+            case 'B': [[fallthrough]];\n+            case 'C': [[fallthrough]];\n+            case 'D': [[fallthrough]];\n+            case 'E': [[fallthrough]];\n+            case 'F':\n+            {\n+                if constexpr (base > 10)\n+                {\n+                    digit = c - ('A' - 10);\n+                    goto handle_digit;\n+                }\n+                else\n+                    goto end;\n+            }\n+            case 'a': [[fallthrough]];\n+            case 'b': [[fallthrough]];\n+            case 'c': [[fallthrough]];\n+            case 'd': [[fallthrough]];\n+            case 'e': [[fallthrough]];\n+            case 'f':\n+            {\n+                if constexpr (base > 10)\n+                {\n+                    digit = c - ('a' - 10);\n+                    goto handle_digit;\n+                }\n+                else\n+                    goto end;\n+            }\n+            default:\n+            {\n+                goto end;\n+            }\n+\n+handle_digit:\n+            if constexpr (base != 10)\n+            {\n+                if (digit >= base)\n+                    goto end;\n+            }\n+            has_number = true;\n+            if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW && !is_big_int_v<T>)\n+            {\n+                /// Perform relativelly slow overflow check only when\n+                /// number of decimal digits so far is close to the max for given type.\n+                /// Example: 20 * 10 will overflow Int8.\n+                constexpr size_t max_digits = (base == 10) ? std::numeric_limits<T>::max_digits10 : (\n+                                              (base == 2) ? std::numeric_limits<T>::digits : (\n+                                              (base == 8) ? ((std::numeric_limits<T>::digits + 2) / 3) : (\n+                                              (base == 16) ? ((std::numeric_limits<T>::digits + 3) / 4) : 0)));\n+\n+                if (buf.count() - initial_pos + 1 >= max_digits)\n+                {\n+                    if (negative)\n+                    {\n+                        T signed_res = -res;\n+                        if (common::mulOverflow<T>(signed_res, base, signed_res) ||\n+                            common::subOverflow<T>(signed_res, digit, signed_res))\n+                        {\n+                            if constexpr (throw_exception)\n+                                throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Overflow while parsing a number\");\n+                            else\n+                                return ReturnType(false);\n+                        }\n+\n+                        res = -static_cast<UnsignedT>(signed_res);\n+                    }\n+                    else\n+                    {\n+                        T signed_res = res;\n+                        if (common::mulOverflow<T>(signed_res, base, signed_res) ||\n+                            common::addOverflow<T>(signed_res, digit, signed_res))\n+                        {\n+                            if constexpr (throw_exception)\n+                                throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Overflow while parsing a number\");\n+                            else\n+                                return ReturnType(false);\n+                        }\n+\n+                        res = signed_res;\n+                    }\n+                    break;\n+                }\n+            }\n+            res *= base;\n+            res += digit;\n+        }\n+    }\n+\n+end:\n+    if (!has_number)\n+    {\n+        if constexpr (throw_exception)\n+            throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Cannot parse number without any digits\");\n+        else\n+            return ReturnType(false);\n+    }\n+    x = res;\n+    if constexpr (is_signed_v<T>)\n+    {\n+        if (negative)\n+        {\n+            if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW)\n+            {\n+                if (common::mulOverflow<UnsignedT, Int8, T>(res, -1, x))\n+                {\n+                    if constexpr (throw_exception)\n+                        throw Exception(ErrorCodes::CANNOT_PARSE_NUMBER, \"Overflow while parsing a number\");\n+                    else\n+                        return ReturnType(false);\n+                }\n+            }\n+            else\n+                x = -res;\n+        }\n+    }\n+\n+    return ReturnType(true);\n+}\n+\n+template <typename T, typename ReturnType, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW>\n+ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n+{\n+    return readIntTextInBaseImpl<10, T, ReturnType, check_overflow>(x, buf);\n+}\n+\n+\n+/// Parses an integer in a specific base (2 or 8 or 10 or 16).\n+template <int base, ReadIntTextCheckOverflow check_overflow = ReadIntTextCheckOverflow::DO_NOT_CHECK_OVERFLOW, typename T>\n+void readIntTextInBase(T & x, ReadBuffer & buf)",
        "comment_created_at": "2025-08-11T15:59:52+00:00",
        "comment_author": "vitlibar",
        "comment_body": "For some tasks like parsing promQL expressions we need a method to parse integer numbers in a non-decimal base. So I decided to modify our function `readIntText()` to allow that because this way looks better than using functions from the standard library like `strtol()` or `sscanf()`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1300315515",
    "pr_number": 48941,
    "pr_file": "src/Storages/MergeTree/MergeTreePartInfo.h",
    "created_at": "2023-08-21T15:54:15+00:00",
    "commented_code": "using DetachedPartsInfo = std::vector<DetachedPartInfo>;\n \n+using PartitionIds = std::vector<String>;\n+\n+void compactPartitionIds(PartitionIds &);\n+\n+inline bool containsInPartitionIdsOrEmpty(const PartitionIds & haystack, const String & needle)\n+{\n+    switch (haystack.size())",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "1300315515",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 48941,
        "pr_file": "src/Storages/MergeTree/MergeTreePartInfo.h",
        "discussion_id": "1300315515",
        "commented_code": "@@ -191,4 +191,21 @@ struct DetachedPartInfo : public MergeTreePartInfo\n \n using DetachedPartsInfo = std::vector<DetachedPartInfo>;\n \n+using PartitionIds = std::vector<String>;\n+\n+void compactPartitionIds(PartitionIds &);\n+\n+inline bool containsInPartitionIdsOrEmpty(const PartitionIds & haystack, const String & needle)\n+{\n+    switch (haystack.size())",
        "comment_created_at": "2023-08-21T15:54:15+00:00",
        "comment_author": "Enmk",
        "comment_body": "```suggestion\r\n  if (haystack.empty())\r\n      // empty haystack means mutation is global and applied to all partitions\r\n      return true;\r\n  return std::binary_search(haystack.cbegin(), haystack.cend(), needle);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1301528539",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 48941,
        "pr_file": "src/Storages/MergeTree/MergeTreePartInfo.h",
        "discussion_id": "1300315515",
        "commented_code": "@@ -191,4 +191,21 @@ struct DetachedPartInfo : public MergeTreePartInfo\n \n using DetachedPartsInfo = std::vector<DetachedPartInfo>;\n \n+using PartitionIds = std::vector<String>;\n+\n+void compactPartitionIds(PartitionIds &);\n+\n+inline bool containsInPartitionIdsOrEmpty(const PartitionIds & haystack, const String & needle)\n+{\n+    switch (haystack.size())",
        "comment_created_at": "2023-08-22T11:53:26+00:00",
        "comment_author": "ilejn",
        "comment_body": "A comment about mutation would be a kind of dependency inversion, semantic of containsInPartitionIdsOrEmpty defined by its name.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077652251",
    "pr_number": 78553,
    "pr_file": "src/Common/ColumnsHashingImpl.h",
    "created_at": "2025-05-07T13:33:58+00:00",
    "commented_code": "}\n     }\n \n+    template <typename Data>\n+    ALWAYS_INLINE void reduceHashTable(\n+        Data & data,\n+        size_t limit_plus_offset_length,\n+        const std::vector<OptimizationDataOneExpression> & optimization_indexes)\n+    {\n+        if constexpr (HasBegin<Data>::value)\n+        {\n+            if constexpr (!std::is_same_v<decltype(data.begin()->getKey()), const VoidKey>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), Int128>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), UInt128>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), Int256>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), UInt256>) { // TODO support all types\n+                if constexpr (!std::is_same_v<decltype(data.begin()->getKey()), const VoidKey> && HasErase<Data, decltype(data.begin()->getKey())>::value)\n+                {\n+                    // TODO Remove after support more types\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), StringRef>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), Int128>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), UInt128>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), Int256>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), UInt256>));\n+\n+                    // apply n-th element to data\n+                    std::vector<typename Data::iterator> data_iterators;\n+                    data_iterators.reserve(data.size());\n+                    for (auto iter = data.begin(); iter != data.end(); ++iter)\n+                        data_iterators.push_back(iter);\n+                    std::nth_element(data_iterators.begin(), data_iterators.begin() + (limit_plus_offset_length - 1), data_iterators.end(), [this, &optimization_indexes](const typename Data::iterator& lhs, const typename Data::iterator& rhs)",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2077652251",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 78553,
        "pr_file": "src/Common/ColumnsHashingImpl.h",
        "discussion_id": "2077652251",
        "commented_code": "@@ -286,6 +304,60 @@ class HashMethodBase\n         }\n     }\n \n+    template <typename Data>\n+    ALWAYS_INLINE void reduceHashTable(\n+        Data & data,\n+        size_t limit_plus_offset_length,\n+        const std::vector<OptimizationDataOneExpression> & optimization_indexes)\n+    {\n+        if constexpr (HasBegin<Data>::value)\n+        {\n+            if constexpr (!std::is_same_v<decltype(data.begin()->getKey()), const VoidKey>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), Int128>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), UInt128>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), Int256>\n+            && !std::is_same_v<decltype(data.begin()->getKey()), UInt256>) { // TODO support all types\n+                if constexpr (!std::is_same_v<decltype(data.begin()->getKey()), const VoidKey> && HasErase<Data, decltype(data.begin()->getKey())>::value)\n+                {\n+                    // TODO Remove after support more types\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), StringRef>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), Int128>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), UInt128>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), Int256>));\n+                    assert(static_cast<bool>(!std::is_same_v<decltype(data.begin()->getKey()), UInt256>));\n+\n+                    // apply n-th element to data\n+                    std::vector<typename Data::iterator> data_iterators;\n+                    data_iterators.reserve(data.size());\n+                    for (auto iter = data.begin(); iter != data.end(); ++iter)\n+                        data_iterators.push_back(iter);\n+                    std::nth_element(data_iterators.begin(), data_iterators.begin() + (limit_plus_offset_length - 1), data_iterators.end(), [this, &optimization_indexes](const typename Data::iterator& lhs, const typename Data::iterator& rhs)",
        "comment_created_at": "2025-05-07T13:33:58+00:00",
        "comment_author": "Dmitry909",
        "comment_body": "I use std::nth_element to filter top of them to save, and erase another elements",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1987137492",
    "pr_number": 77029,
    "pr_file": "src/Core/SortCursor.h",
    "created_at": "2025-03-10T11:53:15+00:00",
    "commented_code": "else\n             return;\n \n-        if (unlikely(begin_cursor.totallyLessOrEquals(next_child_cursor)))\n+        /// Linear detection at most 8 elements to quickly find a small batch size.\n+        /// This heuristic helps to avoid the overhead of binary search for small batches.\n+        constexpr size_t max_linear_detection = 16;",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "1987137492",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 77029,
        "pr_file": "src/Core/SortCursor.h",
        "discussion_id": "1987137492",
        "commented_code": "@@ -557,14 +601,32 @@ class SortingQueueImpl\n         else\n             return;\n \n-        if (unlikely(begin_cursor.totallyLessOrEquals(next_child_cursor)))\n+        /// Linear detection at most 8 elements to quickly find a small batch size.\n+        /// This heuristic helps to avoid the overhead of binary search for small batches.\n+        constexpr size_t max_linear_detection = 16;",
        "comment_created_at": "2025-03-10T11:53:15+00:00",
        "comment_author": "Algunenano",
        "comment_body": "Some suggestions in case you haven't tried them:\r\n* If there are less than `max_linear_detection` elements available always use linear search.\r\n* If there are more than `max_linear_detection` elements available in the current cursor, check the `begin_cursor + max_linear_detection`. If `next_child_cursor` is smaller do a linear search over begin_cursor[0..15], if it's greater do a binary search over the rest of the elements[16..size].",
        "pr_file_module": null
      },
      {
        "comment_id": "1990380201",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 77029,
        "pr_file": "src/Core/SortCursor.h",
        "discussion_id": "1987137492",
        "commented_code": "@@ -557,14 +601,32 @@ class SortingQueueImpl\n         else\n             return;\n \n-        if (unlikely(begin_cursor.totallyLessOrEquals(next_child_cursor)))\n+        /// Linear detection at most 8 elements to quickly find a small batch size.\n+        /// This heuristic helps to avoid the overhead of binary search for small batches.\n+        constexpr size_t max_linear_detection = 16;",
        "comment_created_at": "2025-03-12T01:15:53+00:00",
        "comment_author": "taiyang-li",
        "comment_body": "@Algunenano I had calculated the histograms of `batch_size`. If order by columns don't have low cardinality, `batch_size = 1` or `batch_size = 2` occurs much more frequently than any other values of `batch_size`. Adding an extra comparison between `begin_cursor + max_linear_detection` and `next_child_cursor` will slow down the most typical case.",
        "pr_file_module": null
      }
    ]
  }
]