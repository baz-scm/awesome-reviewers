[
  {
    "discussion_id": "2263924630",
    "pr_number": 84708,
    "pr_file": "src/Common/HashTable/HashTable.h",
    "created_at": "2025-08-08T20:22:24+00:00",
    "commented_code": "}\n     }\n \n+    // Prefetching keys will reduce cache misses and improve performance.\n+    template <typename Derived, bool is_const>\n+    class prefetching_iterator_base\n+    {\n+\n+        using Container = std::conditional_t<is_const, const Self, Self>;\n+        using cell_type = std::conditional_t<is_const, const Cell, Cell>;\n+\n+        struct RingBuffer",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2263924630",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84708,
        "pr_file": "src/Common/HashTable/HashTable.h",
        "discussion_id": "2263924630",
        "commented_code": "@@ -617,6 +617,163 @@ class HashTable : private boost::noncopyable,\n         }\n     }\n \n+    // Prefetching keys will reduce cache misses and improve performance.\n+    template <typename Derived, bool is_const>\n+    class prefetching_iterator_base\n+    {\n+\n+        using Container = std::conditional_t<is_const, const Self, Self>;\n+        using cell_type = std::conditional_t<is_const, const Cell, Cell>;\n+\n+        struct RingBuffer",
        "comment_created_at": "2025-08-08T20:22:24+00:00",
        "comment_author": "nickitat",
        "comment_body": "This looks too complex for the task. Why won't we just prefetch `current + prefetch_ahead` if it is not zero?",
        "pr_file_module": null
      },
      {
        "comment_id": "2265538314",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84708,
        "pr_file": "src/Common/HashTable/HashTable.h",
        "discussion_id": "2263924630",
        "commented_code": "@@ -617,6 +617,163 @@ class HashTable : private boost::noncopyable,\n         }\n     }\n \n+    // Prefetching keys will reduce cache misses and improve performance.\n+    template <typename Derived, bool is_const>\n+    class prefetching_iterator_base\n+    {\n+\n+        using Container = std::conditional_t<is_const, const Self, Self>;\n+        using cell_type = std::conditional_t<is_const, const Cell, Cell>;\n+\n+        struct RingBuffer",
        "comment_created_at": "2025-08-11T01:37:07+00:00",
        "comment_author": "lgbo-ustc",
        "comment_body": "I want to optimize cell checking to avoid duplicates",
        "pr_file_module": null
      },
      {
        "comment_id": "2268519028",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84708,
        "pr_file": "src/Common/HashTable/HashTable.h",
        "discussion_id": "2263924630",
        "commented_code": "@@ -617,6 +617,163 @@ class HashTable : private boost::noncopyable,\n         }\n     }\n \n+    // Prefetching keys will reduce cache misses and improve performance.\n+    template <typename Derived, bool is_const>\n+    class prefetching_iterator_base\n+    {\n+\n+        using Container = std::conditional_t<is_const, const Self, Self>;\n+        using cell_type = std::conditional_t<is_const, const Cell, Cell>;\n+\n+        struct RingBuffer",
        "comment_created_at": "2025-08-12T04:00:08+00:00",
        "comment_author": "lgbo-ustc",
        "comment_body": "I run another test which just  prefetches current + prefetch_ahead.\r\n```\r\n1 row in set. Elapsed: 2.537 sec. Processed 10.00 million rows, 267.89 MB (3.94 million rows/s., 105.61 MB/s.)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2258039805",
    "pr_number": 84435,
    "pr_file": "src/Storages/MergeTree/GinIndexStore.h",
    "created_at": "2025-08-06T19:08:31+00:00",
    "commented_code": "static const CompressionCodecPtr & zstdCodec();\n };\n \n+#if USE_FASTPFOR\n+class GinIndexPostingListDeltaPforCompression\n+{\n+public:\n+    static UInt64 serialize(WriteBuffer & buffer, const roaring::Roaring & rowids, UInt64 header_mask);\n+\n+    static GinIndexPostingsListPtr deserialize(ReadBuffer & buffer, UInt64 header);\n+\n+private:\n+#    if defined(__AVX512F__) && defined(__AVX512BW__)",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2258039805",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84435,
        "pr_file": "src/Storages/MergeTree/GinIndexStore.h",
        "discussion_id": "2258039805",
        "commented_code": "@@ -49,6 +50,45 @@ class GinIndexCompressionFactory\n     static const CompressionCodecPtr & zstdCodec();\n };\n \n+#if USE_FASTPFOR\n+class GinIndexPostingListDeltaPforCompression\n+{\n+public:\n+    static UInt64 serialize(WriteBuffer & buffer, const roaring::Roaring & rowids, UInt64 header_mask);\n+\n+    static GinIndexPostingsListPtr deserialize(ReadBuffer & buffer, UInt64 header);\n+\n+private:\n+#    if defined(__AVX512F__) && defined(__AVX512BW__)",
        "comment_created_at": "2025-08-06T19:08:31+00:00",
        "comment_author": "rschu1ze",
        "comment_body": "I know there was some discussion in an earlier version of the PR but can we keep the codec selection as dumb (simple) as possible? Just use `simdfastpfor128` / threshold = 4 ... this seems the more portable alternative ... I doubt that there would be significant space / performance advantage for the 256/8 variant.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2195452741",
    "pr_number": 83094,
    "pr_file": "src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h",
    "created_at": "2025-07-09T16:24:05+00:00",
    "commented_code": "Int64 relevant_snapshot_id TSA_GUARDED_BY(mutex) {-1};\n     const String table_location;\n \n-    mutable std::optional<Strings> cached_unprunned_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);\n+    mutable std::optional<std::vector<ParsedDataFileInfo>>\n+        cached_unprunned_data_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2195452741",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 83094,
        "pr_file": "src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h",
        "discussion_id": "2195452741",
        "commented_code": "@@ -107,11 +141,17 @@ class IcebergMetadata : public IDataLakeMetadata\n     Int64 relevant_snapshot_id TSA_GUARDED_BY(mutex) {-1};\n     const String table_location;\n \n-    mutable std::optional<Strings> cached_unprunned_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);\n+    mutable std::optional<std::vector<ParsedDataFileInfo>>\n+        cached_unprunned_data_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);",
        "comment_created_at": "2025-07-09T16:24:05+00:00",
        "comment_author": "hanfei1991",
        "comment_body": "it looks very complex here. I suspect why this cache is needed:\r\nnow that we cache `ManifestFileContent` in `IcebergMetadataFilesCache`, it has cached:\r\n- `std::vector<ManifestFileEntry> data_files;`\r\n- `std::vector<ManifestFileEntry> position_deletes_files;`\r\n\r\nThat means if we hit this cache, we have almost no cost to get data/deletes files entry.",
        "pr_file_module": null
      },
      {
        "comment_id": "2197837533",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 83094,
        "pr_file": "src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h",
        "discussion_id": "2195452741",
        "commented_code": "@@ -107,11 +141,17 @@ class IcebergMetadata : public IDataLakeMetadata\n     Int64 relevant_snapshot_id TSA_GUARDED_BY(mutex) {-1};\n     const String table_location;\n \n-    mutable std::optional<Strings> cached_unprunned_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);\n+    mutable std::optional<std::vector<ParsedDataFileInfo>>\n+        cached_unprunned_data_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);",
        "comment_created_at": "2025-07-10T14:03:05+00:00",
        "comment_author": "hanfei1991",
        "comment_body": "so can we just remove these cache?",
        "pr_file_module": null
      },
      {
        "comment_id": "2200755568",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 83094,
        "pr_file": "src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h",
        "discussion_id": "2195452741",
        "commented_code": "@@ -107,11 +141,17 @@ class IcebergMetadata : public IDataLakeMetadata\n     Int64 relevant_snapshot_id TSA_GUARDED_BY(mutex) {-1};\n     const String table_location;\n \n-    mutable std::optional<Strings> cached_unprunned_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);\n+    mutable std::optional<std::vector<ParsedDataFileInfo>>\n+        cached_unprunned_data_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);",
        "comment_created_at": "2025-07-11T13:29:25+00:00",
        "comment_author": "divanik",
        "comment_body": "It theoretically can lead to unpredicted perfomance consequences, though I really also want to do it, so let's try and maybe return it if it is needed ",
        "pr_file_module": null
      },
      {
        "comment_id": "2248427278",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 83094,
        "pr_file": "src/Storages/ObjectStorage/DataLakes/Iceberg/IcebergMetadata.h",
        "discussion_id": "2195452741",
        "commented_code": "@@ -107,11 +141,17 @@ class IcebergMetadata : public IDataLakeMetadata\n     Int64 relevant_snapshot_id TSA_GUARDED_BY(mutex) {-1};\n     const String table_location;\n \n-    mutable std::optional<Strings> cached_unprunned_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);\n+    mutable std::optional<std::vector<ParsedDataFileInfo>>\n+        cached_unprunned_data_files_for_last_processed_snapshot TSA_GUARDED_BY(cached_unprunned_files_for_last_processed_snapshot_mutex);",
        "comment_created_at": "2025-08-01T16:49:02+00:00",
        "comment_author": "divanik",
        "comment_body": "We can remove cache but we can't remove ParsedDataFileInfo, unfortunately (it is used not only in cache)",
        "pr_file_module": null
      }
    ]
  }
]