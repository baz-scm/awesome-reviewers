[
  {
    "discussion_id": "2221420249",
    "pr_number": 84183,
    "pr_file": "src/Databases/DatabaseReplicated.cpp",
    "created_at": "2025-07-22T06:57:26+00:00",
    "commented_code": "ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path + \"/counter/cnt-\", -1));\n     ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/metadata\", \"\", zkutil::CreateMode::Persistent));\n     ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/max_log_ptr\", \"1\", zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/logs_to_keep\", \"1000\", zkutil::CreateMode::Persistent));\n+    auto logs_to_keep = getContext()->getServerSettings().database_replicated_logs_to_keep;",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2221420249",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84183,
        "pr_file": "src/Databases/DatabaseReplicated.cpp",
        "discussion_id": "2221420249",
        "commented_code": "@@ -591,7 +591,8 @@ bool DatabaseReplicated::createDatabaseNodesInZooKeeper(const zkutil::ZooKeeperP\n     ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path + \"/counter/cnt-\", -1));\n     ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/metadata\", \"\", zkutil::CreateMode::Persistent));\n     ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/max_log_ptr\", \"1\", zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/logs_to_keep\", \"1000\", zkutil::CreateMode::Persistent));\n+    auto logs_to_keep = getContext()->getServerSettings().database_replicated_logs_to_keep;",
        "comment_created_at": "2025-07-22T06:57:26+00:00",
        "comment_author": "tuanpach",
        "comment_body": "We must declare the setting before using it:\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/cbab61ccd691535ce5049bc986e51fcad11c58c7/src/Databases/DatabaseReplicated.cpp#L75-L79\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/cbab61ccd691535ce5049bc986e51fcad11c58c7/src/Databases/DatabaseReplicated.cpp#L1556\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2226851207",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84183,
        "pr_file": "src/Databases/DatabaseReplicated.cpp",
        "discussion_id": "2221420249",
        "commented_code": "@@ -591,7 +591,8 @@ bool DatabaseReplicated::createDatabaseNodesInZooKeeper(const zkutil::ZooKeeperP\n     ops.emplace_back(zkutil::makeRemoveRequest(zookeeper_path + \"/counter/cnt-\", -1));\n     ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/metadata\", \"\", zkutil::CreateMode::Persistent));\n     ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/max_log_ptr\", \"1\", zkutil::CreateMode::Persistent));\n-    ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + \"/logs_to_keep\", \"1000\", zkutil::CreateMode::Persistent));\n+    auto logs_to_keep = getContext()->getServerSettings().database_replicated_logs_to_keep;",
        "comment_created_at": "2025-07-23T22:26:43+00:00",
        "comment_author": "Khatskevich",
        "comment_body": "Thanks. Declared.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2146845361",
    "pr_number": 76802,
    "pr_file": "src/Storages/ObjectStorage/StorageObjectStorage.cpp",
    "created_at": "2025-06-14T11:44:51+00:00",
    "commented_code": "FormatFactory::instance().checkFormatName(format);\n }\n \n-bool StorageObjectStorage::Configuration::withPartitionWildcard() const\n+StorageObjectStorage::Configuration::Path StorageObjectStorage::Configuration::getReadingPath() const\n+{\n+    auto raw_path = getRawPath();\n+\n+    if (!partition_strategy)\n+    {\n+        return raw_path;\n+    }\n+\n+    return Path {partition_strategy->getReadingPath(raw_path.path)};",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2146845361",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/ObjectStorage/StorageObjectStorage.cpp",
        "discussion_id": "2146845361",
        "commented_code": "@@ -650,33 +749,65 @@ void StorageObjectStorage::Configuration::check(ContextPtr) const\n     FormatFactory::instance().checkFormatName(format);\n }\n \n-bool StorageObjectStorage::Configuration::withPartitionWildcard() const\n+StorageObjectStorage::Configuration::Path StorageObjectStorage::Configuration::getReadingPath() const\n+{\n+    auto raw_path = getRawPath();\n+\n+    if (!partition_strategy)\n+    {\n+        return raw_path;\n+    }\n+\n+    return Path {partition_strategy->getReadingPath(raw_path.path)};",
        "comment_created_at": "2025-06-14T11:44:51+00:00",
        "comment_author": "kssenii",
        "comment_body": "Why not initialize reading path once - when raw path is set? to avoid recalculating reading path each time we need it. Same about writing path",
        "pr_file_module": null
      },
      {
        "comment_id": "2146936997",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/ObjectStorage/StorageObjectStorage.cpp",
        "discussion_id": "2146845361",
        "commented_code": "@@ -650,33 +749,65 @@ void StorageObjectStorage::Configuration::check(ContextPtr) const\n     FormatFactory::instance().checkFormatName(format);\n }\n \n-bool StorageObjectStorage::Configuration::withPartitionWildcard() const\n+StorageObjectStorage::Configuration::Path StorageObjectStorage::Configuration::getReadingPath() const\n+{\n+    auto raw_path = getRawPath();\n+\n+    if (!partition_strategy)\n+    {\n+        return raw_path;\n+    }\n+\n+    return Path {partition_strategy->getReadingPath(raw_path.path)};",
        "comment_created_at": "2025-06-14T13:02:02+00:00",
        "comment_author": "arthurpassos",
        "comment_body": "Reading path is doable indeed, but writing is not as it depends on the `partition_id`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2166753920",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 76802,
        "pr_file": "src/Storages/ObjectStorage/StorageObjectStorage.cpp",
        "discussion_id": "2146845361",
        "commented_code": "@@ -650,33 +749,65 @@ void StorageObjectStorage::Configuration::check(ContextPtr) const\n     FormatFactory::instance().checkFormatName(format);\n }\n \n-bool StorageObjectStorage::Configuration::withPartitionWildcard() const\n+StorageObjectStorage::Configuration::Path StorageObjectStorage::Configuration::getReadingPath() const\n+{\n+    auto raw_path = getRawPath();\n+\n+    if (!partition_strategy)\n+    {\n+        return raw_path;\n+    }\n+\n+    return Path {partition_strategy->getReadingPath(raw_path.path)};",
        "comment_created_at": "2025-06-25T13:41:57+00:00",
        "comment_author": "arthurpassos",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2262381115",
    "pr_number": 85134,
    "pr_file": "src/Storages/ObjectStorage/S3/Configuration.cpp",
    "created_at": "2025-08-08T09:06:40+00:00",
    "commented_code": "return true;\n }\n \n+template <typename T>\n+static std::optional<T> getFromPositionOrKeyValue(\n+    const std::string & key,\n+    const ASTs & args,\n+    const std::unordered_map<std::string_view, size_t> & engine_args_to_idx,\n+    const std::unordered_map<std::string, Field> & key_value_args)\n+{\n+    if (auto arg_it = engine_args_to_idx.find(key); arg_it != engine_args_to_idx.end())\n+        return checkAndGetLiteralArgument<T>(args[arg_it->second], key);\n+\n+    if (auto arg_it = key_value_args.find(key); arg_it != key_value_args.end())\n+        return arg_it->second.safeGet<T>();\n+\n+    return std::nullopt;\n+};\n+\n+static std::unordered_map<std::string, Field> parseKeyValueArguments(const ASTs & function_args, ContextPtr context)\n+{\n+    std::unordered_map<std::string, Field> key_value_args;\n+    for (const auto & arg : function_args)\n+    {\n+        const auto * function_ast = arg->as<ASTFunction>();\n+        if (!function_ast || function_ast->name != \"equals\")\n+            continue;\n+\n+        auto * args_expr = assert_cast<ASTExpressionList *>(function_ast->arguments.get());\n+        auto & children = args_expr->children;\n+        if (children.size() != 2)\n+        {\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Key value argument is incorrect: expected 2 arguments, got {}\",\n+                children.size());\n+        }\n+\n+        children[0] = evaluateConstantExpressionOrIdentifierAsLiteral(children[0], context);\n+        children[1] = evaluateConstantExpressionOrIdentifierAsLiteral(children[1], context);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2262381115",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 85134,
        "pr_file": "src/Storages/ObjectStorage/S3/Configuration.cpp",
        "discussion_id": "2262381115",
        "commented_code": "@@ -293,18 +293,103 @@ bool StorageS3Configuration::collectCredentials(ASTPtr maybe_credentials, S3::S3\n     return true;\n }\n \n+template <typename T>\n+static std::optional<T> getFromPositionOrKeyValue(\n+    const std::string & key,\n+    const ASTs & args,\n+    const std::unordered_map<std::string_view, size_t> & engine_args_to_idx,\n+    const std::unordered_map<std::string, Field> & key_value_args)\n+{\n+    if (auto arg_it = engine_args_to_idx.find(key); arg_it != engine_args_to_idx.end())\n+        return checkAndGetLiteralArgument<T>(args[arg_it->second], key);\n+\n+    if (auto arg_it = key_value_args.find(key); arg_it != key_value_args.end())\n+        return arg_it->second.safeGet<T>();\n+\n+    return std::nullopt;\n+};\n+\n+static std::unordered_map<std::string, Field> parseKeyValueArguments(const ASTs & function_args, ContextPtr context)\n+{\n+    std::unordered_map<std::string, Field> key_value_args;\n+    for (const auto & arg : function_args)\n+    {\n+        const auto * function_ast = arg->as<ASTFunction>();\n+        if (!function_ast || function_ast->name != \"equals\")\n+            continue;\n+\n+        auto * args_expr = assert_cast<ASTExpressionList *>(function_ast->arguments.get());\n+        auto & children = args_expr->children;\n+        if (children.size() != 2)\n+        {\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Key value argument is incorrect: expected 2 arguments, got {}\",\n+                children.size());\n+        }\n+\n+        children[0] = evaluateConstantExpressionOrIdentifierAsLiteral(children[0], context);\n+        children[1] = evaluateConstantExpressionOrIdentifierAsLiteral(children[1], context);",
        "comment_created_at": "2025-08-08T09:06:40+00:00",
        "comment_author": "novikd",
        "comment_body": "Maybe better to avoid updating AST at all? Let's save these values in local variables",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2204968628",
    "pr_number": 81908,
    "pr_file": "src/Storages/buildQueryTreeForShard.cpp",
    "created_at": "2025-07-14T13:36:57+00:00",
    "commented_code": "subquery_to_execute,\n                         planner_context->getQueryContext());\n \n+                // If DISTINCT optimization is enabled, add DISTINCT before executing the subquery\n+                if (planner_context->getQueryContext()->getSettingsRef()[Setting::enable_add_distinct_to_in_subqueries])",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2204968628",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 81908,
        "pr_file": "src/Storages/buildQueryTreeForShard.cpp",
        "discussion_id": "2204968628",
        "commented_code": "@@ -424,11 +440,15 @@ QueryTreeNodePtr buildQueryTreeForShard(const PlannerContextPtr & planner_contex\n                         subquery_to_execute,\n                         planner_context->getQueryContext());\n \n+                // If DISTINCT optimization is enabled, add DISTINCT before executing the subquery\n+                if (planner_context->getQueryContext()->getSettingsRef()[Setting::enable_add_distinct_to_in_subqueries])",
        "comment_created_at": "2025-07-14T13:36:57+00:00",
        "comment_author": "novikd",
        "comment_body": "Let's save the setting value to a local variable before the for cycle.",
        "pr_file_module": null
      }
    ]
  }
]