[
  {
    "discussion_id": "2177791604",
    "pr_number": 82753,
    "pr_file": "src/Client/CloudJWTProvider.cpp",
    "created_at": "2025-07-01T14:40:26+00:00",
    "commented_code": "+#include <config.h>\n+\n+#if USE_JWT_CPP && USE_SSL\n+#include <Client/CloudJWTProvider.h>\n+#include <Common/Exception.h>\n+#include <Common/StringUtils.h>\n+\n+#include <Poco/Net/HTTPClientSession.h>\n+#include <Poco/Net/HTTPRequest.h>\n+#include <Poco/Net/HTTPResponse.h>\n+#include <Poco/Net/HTTPSClientSession.h>\n+#include <Poco/Net/SSLManager.h>\n+#include <Poco/StreamCopier.h>\n+#include <Poco/URI.h>\n+#include <Poco/JSON/Parser.h>\n+#include <Poco/JSON/Object.h>\n+#include <Poco/Dynamic/Var.h>\n+\n+#include <IO/WriteBufferFromString.h>\n+\n+#include <thread>\n+#include <chrono>\n+#include <cstdlib>\n+#include <iostream>\n+#include <jwt-cpp/jwt.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+struct AuthEndpoints\n+{\n+    std::string auth_url;\n+    std::string client_id;\n+    std::string api_host;\n+};\n+\n+static const std::map<std::string, AuthEndpoints> managed_service_endpoints = {\n+    {\n+        \".clickhouse-dev.com\",\n+        {\n+            \"https://auth.control-plane.clickhouse-dev.com\",\n+            \"dKv0XkTAw7rghGiAa5sjPFYGQUVtjzuz\",\n+            \"https://control-plane-internal.clickhouse-dev.com\"\n+        }\n+    },\n+    {\n+        \".clickhouse-staging.com\",\n+        {\n+            \"https://auth.control-plane.clickhouse-staging.com\",\n+            \"rpEkizLMmAU95MP4JL8ERefbVXtUQSFs\",\n+            \"https://control-plane-internal.clickhouse-staging.com\"\n+        }\n+    },\n+    {\n+        \".clickhouse.cloud\",\n+        {\n+            \"https://auth.control-plane.clickhouse.cloud\",\n+            \"TODO: CREATE THIS\",\n+            \"https://control-plane-internal.clickhouse.cloud\"\n+        }\n+    }\n+};\n+\n+inline const AuthEndpoints * getAuthEndpoints(const std::string & host)\n+{\n+    for (const auto & [suffix, endpoints] : managed_service_endpoints)\n+    {\n+        if (endsWith(host, suffix))\n+            return &endpoints;\n+    }\n+    return nullptr;\n+}\n+\n+}\n+\n+CloudJWTProvider::CloudJWTProvider(\n+    std::string auth_url, std::string client_id, std::string host,\n+    std::ostream & out, std::ostream & err)\n+    : JWTProvider(std::move(auth_url), std::move(client_id), out, err),\n+      host_str(std::move(host))\n+{\n+    if (auth_url_str.empty() || client_id_str.empty())\n+    {\n+        if (const auto * endpoints = getAuthEndpoints(host_str))\n+        {\n+            if (auth_url_str.empty())\n+                auth_url_str = endpoints->auth_url;\n+            if (client_id_str.empty())\n+                client_id_str = endpoints->client_id;\n+        }\n+    }\n+}\n+\n+std::string CloudJWTProvider::getJWT()\n+{\n+    Poco::Timestamp now;\n+    Poco::Timestamp expiration_buffer = 30 * Poco::Timespan::SECONDS;\n+\n+    // If we have a valid ClickHouse JWT, return it.\n+    if (!clickhouse_jwt.empty() && now < clickhouse_jwt_expires_at - expiration_buffer)\n+        return clickhouse_jwt;\n+\n+    // If we have a valid IDP refresh token, attempt to refresh the IDP access token if expired.\n+    if (!idp_refresh_token.empty() && now >= idp_access_token_expires_at - expiration_buffer)\n+    {\n+        refreshIdPAccessToken();\n+    }\n+\n+    // If we have a valid IDP access token, attempt to swap it for a ClickHouse JWT.\n+    if (!idp_access_token.empty() && now < idp_access_token_expires_at - expiration_buffer)\n+    {\n+        if (swapIdPTokenForClickHouseJWT(false))\n+            return clickhouse_jwt;\n+    }\n+\n+    // If we don't have a valid ClickHouse JWT, attempt to login and swap the IDP token for a ClickHouse JWT.\n+    if (initialLogin() && swapIdPTokenForClickHouseJWT(true))\n+        return clickhouse_jwt;\n+\n+    return \"\";\n+}\n+\n+bool CloudJWTProvider::swapIdPTokenForClickHouseJWT(bool show_messages)\n+{\n+    const auto * endpoints = getAuthEndpoints(host_str);\n+\n+    if (!endpoints)\n+    {\n+        error_stream << \"Error: cannot determine token swap endpoint from hostname \" << host_str\n+                     << \". Please use a managed ClickHouse hostname.\" << std::endl;\n+        return false;\n+    }\n+\n+    std::string swap_url = endpoints->api_host + \"/api/tokenSwap\";\n+\n+    if (show_messages)\n+        output_stream << \"Authenticating access to \" << host_str << \".\" << std::endl;\n+    try\n+    {\n+        Poco::URI swap_uri(swap_url);\n+        auto session = createHTTPSession(swap_uri);\n+        Poco::Net::HTTPRequest request(Poco::Net::HTTPRequest::HTTP_POST, swap_uri.getPathAndQuery(), Poco::Net::HTTPMessage::HTTP_1_1);\n+        request.set(\"Authorization\", \"Bearer \" + idp_access_token);\n+        request.setContentType(\"application/json; charset=utf-8\");\n+        std::string request_body = \"{\\\"hostname\\\": \\\"\" + host_str + \"\\\"}\";",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2177791604",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 82753,
        "pr_file": "src/Client/CloudJWTProvider.cpp",
        "discussion_id": "2177791604",
        "commented_code": "@@ -0,0 +1,182 @@\n+#include <config.h>\n+\n+#if USE_JWT_CPP && USE_SSL\n+#include <Client/CloudJWTProvider.h>\n+#include <Common/Exception.h>\n+#include <Common/StringUtils.h>\n+\n+#include <Poco/Net/HTTPClientSession.h>\n+#include <Poco/Net/HTTPRequest.h>\n+#include <Poco/Net/HTTPResponse.h>\n+#include <Poco/Net/HTTPSClientSession.h>\n+#include <Poco/Net/SSLManager.h>\n+#include <Poco/StreamCopier.h>\n+#include <Poco/URI.h>\n+#include <Poco/JSON/Parser.h>\n+#include <Poco/JSON/Object.h>\n+#include <Poco/Dynamic/Var.h>\n+\n+#include <IO/WriteBufferFromString.h>\n+\n+#include <thread>\n+#include <chrono>\n+#include <cstdlib>\n+#include <iostream>\n+#include <jwt-cpp/jwt.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+struct AuthEndpoints\n+{\n+    std::string auth_url;\n+    std::string client_id;\n+    std::string api_host;\n+};\n+\n+static const std::map<std::string, AuthEndpoints> managed_service_endpoints = {\n+    {\n+        \".clickhouse-dev.com\",\n+        {\n+            \"https://auth.control-plane.clickhouse-dev.com\",\n+            \"dKv0XkTAw7rghGiAa5sjPFYGQUVtjzuz\",\n+            \"https://control-plane-internal.clickhouse-dev.com\"\n+        }\n+    },\n+    {\n+        \".clickhouse-staging.com\",\n+        {\n+            \"https://auth.control-plane.clickhouse-staging.com\",\n+            \"rpEkizLMmAU95MP4JL8ERefbVXtUQSFs\",\n+            \"https://control-plane-internal.clickhouse-staging.com\"\n+        }\n+    },\n+    {\n+        \".clickhouse.cloud\",\n+        {\n+            \"https://auth.control-plane.clickhouse.cloud\",\n+            \"TODO: CREATE THIS\",\n+            \"https://control-plane-internal.clickhouse.cloud\"\n+        }\n+    }\n+};\n+\n+inline const AuthEndpoints * getAuthEndpoints(const std::string & host)\n+{\n+    for (const auto & [suffix, endpoints] : managed_service_endpoints)\n+    {\n+        if (endsWith(host, suffix))\n+            return &endpoints;\n+    }\n+    return nullptr;\n+}\n+\n+}\n+\n+CloudJWTProvider::CloudJWTProvider(\n+    std::string auth_url, std::string client_id, std::string host,\n+    std::ostream & out, std::ostream & err)\n+    : JWTProvider(std::move(auth_url), std::move(client_id), out, err),\n+      host_str(std::move(host))\n+{\n+    if (auth_url_str.empty() || client_id_str.empty())\n+    {\n+        if (const auto * endpoints = getAuthEndpoints(host_str))\n+        {\n+            if (auth_url_str.empty())\n+                auth_url_str = endpoints->auth_url;\n+            if (client_id_str.empty())\n+                client_id_str = endpoints->client_id;\n+        }\n+    }\n+}\n+\n+std::string CloudJWTProvider::getJWT()\n+{\n+    Poco::Timestamp now;\n+    Poco::Timestamp expiration_buffer = 30 * Poco::Timespan::SECONDS;\n+\n+    // If we have a valid ClickHouse JWT, return it.\n+    if (!clickhouse_jwt.empty() && now < clickhouse_jwt_expires_at - expiration_buffer)\n+        return clickhouse_jwt;\n+\n+    // If we have a valid IDP refresh token, attempt to refresh the IDP access token if expired.\n+    if (!idp_refresh_token.empty() && now >= idp_access_token_expires_at - expiration_buffer)\n+    {\n+        refreshIdPAccessToken();\n+    }\n+\n+    // If we have a valid IDP access token, attempt to swap it for a ClickHouse JWT.\n+    if (!idp_access_token.empty() && now < idp_access_token_expires_at - expiration_buffer)\n+    {\n+        if (swapIdPTokenForClickHouseJWT(false))\n+            return clickhouse_jwt;\n+    }\n+\n+    // If we don't have a valid ClickHouse JWT, attempt to login and swap the IDP token for a ClickHouse JWT.\n+    if (initialLogin() && swapIdPTokenForClickHouseJWT(true))\n+        return clickhouse_jwt;\n+\n+    return \"\";\n+}\n+\n+bool CloudJWTProvider::swapIdPTokenForClickHouseJWT(bool show_messages)\n+{\n+    const auto * endpoints = getAuthEndpoints(host_str);\n+\n+    if (!endpoints)\n+    {\n+        error_stream << \"Error: cannot determine token swap endpoint from hostname \" << host_str\n+                     << \". Please use a managed ClickHouse hostname.\" << std::endl;\n+        return false;\n+    }\n+\n+    std::string swap_url = endpoints->api_host + \"/api/tokenSwap\";\n+\n+    if (show_messages)\n+        output_stream << \"Authenticating access to \" << host_str << \".\" << std::endl;\n+    try\n+    {\n+        Poco::URI swap_uri(swap_url);\n+        auto session = createHTTPSession(swap_uri);\n+        Poco::Net::HTTPRequest request(Poco::Net::HTTPRequest::HTTP_POST, swap_uri.getPathAndQuery(), Poco::Net::HTTPMessage::HTTP_1_1);\n+        request.set(\"Authorization\", \"Bearer \" + idp_access_token);\n+        request.setContentType(\"application/json; charset=utf-8\");\n+        std::string request_body = \"{\\\"hostname\\\": \\\"\" + host_str + \"\\\"}\";",
        "comment_created_at": "2025-07-01T14:40:26+00:00",
        "comment_author": "alexey-milovidov",
        "comment_body": "The `host_str` is unescaped (this is a security issue like SQL injection or XSS).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2230637638",
    "pr_number": 84235,
    "pr_file": "src/Storages/ObjectStorage/Azure/Configuration.cpp",
    "created_at": "2025-07-25T09:33:08+00:00",
    "commented_code": "const String & container_name,\n     const std::optional<String> & account_name,\n     const std::optional<String> & account_key,\n+    const std::optional<String> & client_id,\n+    const std::optional<String> & tenant_id,\n     const ContextPtr & local_context)\n {\n     AzureBlobStorage::ConnectionParams connection_params;\n     auto request_settings = AzureBlobStorage::getRequestSettings(local_context->getSettingsRef());\n \n-    if (account_name && account_key)\n+    if (client_id && tenant_id)\n+    {\n+        connection_params.endpoint.storage_account_url = connection_url;\n+        connection_params.endpoint.container_name = container_name;\n+        Azure::Identity::WorkloadIdentityCredentialOptions options;\n+        options.ClientId = *client_id;\n+        options.TenantId = *tenant_id;\n+        connection_params.auth_method = std::make_shared<Azure::Identity::WorkloadIdentityCredential>(options);",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2230637638",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84235,
        "pr_file": "src/Storages/ObjectStorage/Azure/Configuration.cpp",
        "discussion_id": "2230637638",
        "commented_code": "@@ -101,23 +104,33 @@ static AzureBlobStorage::ConnectionParams getConnectionParams(\n     const String & container_name,\n     const std::optional<String> & account_name,\n     const std::optional<String> & account_key,\n+    const std::optional<String> & client_id,\n+    const std::optional<String> & tenant_id,\n     const ContextPtr & local_context)\n {\n     AzureBlobStorage::ConnectionParams connection_params;\n     auto request_settings = AzureBlobStorage::getRequestSettings(local_context->getSettingsRef());\n \n-    if (account_name && account_key)\n+    if (client_id && tenant_id)\n+    {\n+        connection_params.endpoint.storage_account_url = connection_url;\n+        connection_params.endpoint.container_name = container_name;\n+        Azure::Identity::WorkloadIdentityCredentialOptions options;\n+        options.ClientId = *client_id;\n+        options.TenantId = *tenant_id;\n+        connection_params.auth_method = std::make_shared<Azure::Identity::WorkloadIdentityCredential>(options);",
        "comment_created_at": "2025-07-25T09:33:08+00:00",
        "comment_author": "SmitaRKulkarni",
        "comment_body": "Only when both client_id and tenant_id are specified we go for WorkloadIdentity, maybe in case only either one of them is specified we should throw an error indicating to the user that they have insufficient data for authentication, what do you think? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2230648114",
    "pr_number": 84235,
    "pr_file": "src/Storages/tests/gtest_azure_configuration.cpp",
    "created_at": "2025-07-25T09:38:00+00:00",
    "commented_code": "+#include <gtest/gtest.h>\n+#include <config.h>\n+\n+#if USE_AZURE_BLOB_STORAGE\n+\n+#include <Storages/ObjectStorage/Azure/Configuration.h>\n+#include <Interpreters/Context.h>\n+#include <Parsers/parseQuery.h>\n+#include <Parsers/ParserQuery.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/TablePropertiesQueriesASTs.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+\n+#include <Common/NamedCollections/NamedCollectionsFactory.h>\n+#include <Poco/Util/XMLConfiguration.h>\n+#include <Poco/DOM/DOMParser.h>\n+\n+using namespace DB;\n+\n+namespace\n+{\n+\n+/// A class which allows to test private methods of NamedCollectionFactory.\n+class NamedCollectionFactoryFriend : public NamedCollectionFactory\n+{\n+public:\n+    static NamedCollectionFactoryFriend & instance()\n+    {\n+        static NamedCollectionFactoryFriend instance;\n+        return instance;\n+    }\n+\n+    void loadFromConfig(const Poco::Util::AbstractConfiguration & config)\n+    {\n+        std::lock_guard lock(mutex);\n+        NamedCollectionFactory::loadFromConfig(config, lock);\n+    }\n+};\n+\n+class StorageAzureConfigurationFriend : public StorageAzureConfiguration\n+{\n+public:\n+    void fromNamedCollection(const NamedCollection & collection, ContextPtr context) override\n+    {\n+        StorageAzureConfiguration::fromNamedCollection(collection, context);\n+    }\n+\n+    void fromAST(ASTs & args, ContextPtr context, bool with_structure) override\n+    {\n+        StorageAzureConfiguration::fromAST(args, context, with_structure);\n+    }\n+\n+    const AzureBlobStorage::ConnectionParams & getConnectionParams()\n+    {\n+        return connection_params;\n+    }\n+};\n+\n+void loadNamedCollectionConfig(const String & xml)\n+{\n+    Poco::XML::DOMParser dom_parser;\n+    Poco::AutoPtr<Poco::XML::Document> document = dom_parser.parseString(xml);\n+    Poco::AutoPtr<Poco::Util::XMLConfiguration> config = new Poco::Util::XMLConfiguration(document);\n+\n+    NamedCollectionFactoryFriend::instance().loadFromConfig(*config);\n+}\n+\n+TEST(StorageAzureConfiguration, FromNamedCollectionWithExtraCredentials)\n+{\n+    std::string xml(R\"CONFIG(<clickhouse>\n+    <named_collections>\n+        <FromNamedCollectionWithExtraCredentials>\n+            <container>test_container</container>\n+            <blob_path>test_blob.csv</blob_path>\n+            <client_id>test_client_id</client_id>\n+            <tenant_id>test_tenant_id</tenant_id>\n+        </FromNamedCollectionWithExtraCredentials>\n+    </named_collections>\n+    </clickhouse>)CONFIG\");\n+\n+    loadNamedCollectionConfig(xml);\n+\n+    StorageAzureConfigurationFriend conf;\n+    auto collection = NamedCollectionFactoryFriend::instance().get(\"FromNamedCollectionWithExtraCredentials\");\n+    conf.fromNamedCollection(*collection, Context::getGlobalContextInstance());\n+\n+    ASSERT_TRUE(std::holds_alternative<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(conf.getConnectionParams().auth_method));\n+}\n+\n+TEST(StorageAzureConfiguration, FromNamedCollectionWithExtraCredentialsAndAccount)\n+{\n+    std::string xml(R\"CONFIG(<clickhouse>\n+    <named_collections>\n+        <FromNamedCollectionWithExtraCredentialsAndAccount>\n+            <container>test_container</container>\n+            <blob_path>test_blob.csv</blob_path>\n+            <account_name>test_account</account_name>\n+            <account_key>test_key</account_key>\n+            <client_id>test_client_id</client_id>\n+            <tenant_id>test_tenant_id</tenant_id>\n+        </FromNamedCollectionWithExtraCredentialsAndAccount>\n+    </named_collections>\n+    </clickhouse>)CONFIG\");\n+\n+    loadNamedCollectionConfig(xml);\n+\n+    StorageAzureConfigurationFriend conf;\n+    auto collection = NamedCollectionFactoryFriend::instance().get(\"FromNamedCollectionWithExtraCredentialsAndAccount\");\n+    conf.fromNamedCollection(*collection, Context::getGlobalContextInstance());\n+\n+    ASSERT_TRUE(std::holds_alternative<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(conf.getConnectionParams().auth_method));\n+}\n+\n+TEST(StorageAzureConfiguration, FromNamedCollectionWithPartialExtraCredentialsAndFallback)\n+{\n+    std::string xml(R\"CONFIG(<clickhouse>\n+    <named_collections>\n+        <FromNamedCollectionWithPartialExtraCredentialsAndFallback>\n+            <container>test_container</container>\n+            <blob_path>test_blob.csv</blob_path>\n+            <account_name>test_account</account_name>\n+            <account_key>test_key</account_key>\n+            <client_id>test_client_id</client_id>",
    "repo_full_name": "ClickHouse/ClickHouse",
    "discussion_comments": [
      {
        "comment_id": "2230648114",
        "repo_full_name": "ClickHouse/ClickHouse",
        "pr_number": 84235,
        "pr_file": "src/Storages/tests/gtest_azure_configuration.cpp",
        "discussion_id": "2230648114",
        "commented_code": "@@ -0,0 +1,183 @@\n+#include <gtest/gtest.h>\n+#include <config.h>\n+\n+#if USE_AZURE_BLOB_STORAGE\n+\n+#include <Storages/ObjectStorage/Azure/Configuration.h>\n+#include <Interpreters/Context.h>\n+#include <Parsers/parseQuery.h>\n+#include <Parsers/ParserQuery.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/TablePropertiesQueriesASTs.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+\n+#include <Common/NamedCollections/NamedCollectionsFactory.h>\n+#include <Poco/Util/XMLConfiguration.h>\n+#include <Poco/DOM/DOMParser.h>\n+\n+using namespace DB;\n+\n+namespace\n+{\n+\n+/// A class which allows to test private methods of NamedCollectionFactory.\n+class NamedCollectionFactoryFriend : public NamedCollectionFactory\n+{\n+public:\n+    static NamedCollectionFactoryFriend & instance()\n+    {\n+        static NamedCollectionFactoryFriend instance;\n+        return instance;\n+    }\n+\n+    void loadFromConfig(const Poco::Util::AbstractConfiguration & config)\n+    {\n+        std::lock_guard lock(mutex);\n+        NamedCollectionFactory::loadFromConfig(config, lock);\n+    }\n+};\n+\n+class StorageAzureConfigurationFriend : public StorageAzureConfiguration\n+{\n+public:\n+    void fromNamedCollection(const NamedCollection & collection, ContextPtr context) override\n+    {\n+        StorageAzureConfiguration::fromNamedCollection(collection, context);\n+    }\n+\n+    void fromAST(ASTs & args, ContextPtr context, bool with_structure) override\n+    {\n+        StorageAzureConfiguration::fromAST(args, context, with_structure);\n+    }\n+\n+    const AzureBlobStorage::ConnectionParams & getConnectionParams()\n+    {\n+        return connection_params;\n+    }\n+};\n+\n+void loadNamedCollectionConfig(const String & xml)\n+{\n+    Poco::XML::DOMParser dom_parser;\n+    Poco::AutoPtr<Poco::XML::Document> document = dom_parser.parseString(xml);\n+    Poco::AutoPtr<Poco::Util::XMLConfiguration> config = new Poco::Util::XMLConfiguration(document);\n+\n+    NamedCollectionFactoryFriend::instance().loadFromConfig(*config);\n+}\n+\n+TEST(StorageAzureConfiguration, FromNamedCollectionWithExtraCredentials)\n+{\n+    std::string xml(R\"CONFIG(<clickhouse>\n+    <named_collections>\n+        <FromNamedCollectionWithExtraCredentials>\n+            <container>test_container</container>\n+            <blob_path>test_blob.csv</blob_path>\n+            <client_id>test_client_id</client_id>\n+            <tenant_id>test_tenant_id</tenant_id>\n+        </FromNamedCollectionWithExtraCredentials>\n+    </named_collections>\n+    </clickhouse>)CONFIG\");\n+\n+    loadNamedCollectionConfig(xml);\n+\n+    StorageAzureConfigurationFriend conf;\n+    auto collection = NamedCollectionFactoryFriend::instance().get(\"FromNamedCollectionWithExtraCredentials\");\n+    conf.fromNamedCollection(*collection, Context::getGlobalContextInstance());\n+\n+    ASSERT_TRUE(std::holds_alternative<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(conf.getConnectionParams().auth_method));\n+}\n+\n+TEST(StorageAzureConfiguration, FromNamedCollectionWithExtraCredentialsAndAccount)\n+{\n+    std::string xml(R\"CONFIG(<clickhouse>\n+    <named_collections>\n+        <FromNamedCollectionWithExtraCredentialsAndAccount>\n+            <container>test_container</container>\n+            <blob_path>test_blob.csv</blob_path>\n+            <account_name>test_account</account_name>\n+            <account_key>test_key</account_key>\n+            <client_id>test_client_id</client_id>\n+            <tenant_id>test_tenant_id</tenant_id>\n+        </FromNamedCollectionWithExtraCredentialsAndAccount>\n+    </named_collections>\n+    </clickhouse>)CONFIG\");\n+\n+    loadNamedCollectionConfig(xml);\n+\n+    StorageAzureConfigurationFriend conf;\n+    auto collection = NamedCollectionFactoryFriend::instance().get(\"FromNamedCollectionWithExtraCredentialsAndAccount\");\n+    conf.fromNamedCollection(*collection, Context::getGlobalContextInstance());\n+\n+    ASSERT_TRUE(std::holds_alternative<std::shared_ptr<Azure::Identity::WorkloadIdentityCredential>>(conf.getConnectionParams().auth_method));\n+}\n+\n+TEST(StorageAzureConfiguration, FromNamedCollectionWithPartialExtraCredentialsAndFallback)\n+{\n+    std::string xml(R\"CONFIG(<clickhouse>\n+    <named_collections>\n+        <FromNamedCollectionWithPartialExtraCredentialsAndFallback>\n+            <container>test_container</container>\n+            <blob_path>test_blob.csv</blob_path>\n+            <account_name>test_account</account_name>\n+            <account_key>test_key</account_key>\n+            <client_id>test_client_id</client_id>",
        "comment_created_at": "2025-07-25T09:38:00+00:00",
        "comment_author": "SmitaRKulkarni",
        "comment_body": "In this case too, I think we should throw an error that both authentication methods are trying to be used and also that one of them is incomplete, instead of choosing one and ignoring the other.",
        "pr_file_module": null
      }
    ]
  }
]