[
  {
    "discussion_id": "2223445251",
    "pr_number": 5075,
    "pr_file": "src/api/providers/oca.ts",
    "created_at": "2025-07-22T18:18:10+00:00",
    "commented_code": "+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2223445251",
        "repo_full_name": "cline/cline",
        "pr_number": 5075,
        "pr_file": "src/api/providers/oca.ts",
        "discussion_id": "2223445251",
        "commented_code": "@@ -0,0 +1,63 @@\n+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {",
        "comment_created_at": "2025-07-22T18:18:10+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "If this is somehow built on top of LiteLLM, I would still recommend writing it separately and not tying it to the LiteLLM handler code. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2223770260",
        "repo_full_name": "cline/cline",
        "pr_number": 5075,
        "pr_file": "src/api/providers/oca.ts",
        "discussion_id": "2223445251",
        "commented_code": "@@ -0,0 +1,63 @@\n+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {",
        "comment_created_at": "2025-07-22T20:33:35+00:00",
        "comment_author": "nihar-oracle",
        "comment_body": "So, it is OCA's litellm compatible endpoint. The only real difference between this and a proper litellm implementation is that oca uses sso oauth backed access keys instead of api keys.\r\n\r\nI am happy to move this into a separate non derived class",
        "pr_file_module": null
      },
      {
        "comment_id": "2232590051",
        "repo_full_name": "cline/cline",
        "pr_number": 5075,
        "pr_file": "src/api/providers/oca.ts",
        "discussion_id": "2223445251",
        "commented_code": "@@ -0,0 +1,63 @@\n+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {",
        "comment_created_at": "2025-07-26T05:57:14+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "Yeah, let's move it into it's own class so they don't get mixed up.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223447332",
    "pr_number": 5075,
    "pr_file": "src/api/providers/oca.ts",
    "created_at": "2025-07-22T18:19:15+00:00",
    "commented_code": "+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {\n+\tconstructor(options: LiteLlmHandlerOptions) {\n+\t\tsuper(options)\n+\t}\n+\tprotected override initializeClient(options: LiteLlmHandlerOptions) {\n+\t\treturn new OpenAI({\n+\t\t\tbaseURL: options.liteLlmBaseUrl || DEFAULT_OCA_BASE_URL,\n+\t\t\tapiKey: \"noop\",\n+\t\t\tfetch: async (url, init) => {\n+\t\t\t\ttry {\n+\t\t\t\t\t// Authorization Header\n+\t\t\t\t\tconst token = (await OcaTokenManager.getToken()).access_token\n+\t\t\t\t\tif (!token) {\n+\t\t\t\t\t\tthrow new Error(\"Oracle Code Assist (OCA) access token is not available\")\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst globalFetch = (typeof fetch === \"function\" ? fetch : globalThis.fetch).bind(undefined)",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2223447332",
        "repo_full_name": "cline/cline",
        "pr_number": 5075,
        "pr_file": "src/api/providers/oca.ts",
        "discussion_id": "2223447332",
        "commented_code": "@@ -0,0 +1,63 @@\n+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {\n+\tconstructor(options: LiteLlmHandlerOptions) {\n+\t\tsuper(options)\n+\t}\n+\tprotected override initializeClient(options: LiteLlmHandlerOptions) {\n+\t\treturn new OpenAI({\n+\t\t\tbaseURL: options.liteLlmBaseUrl || DEFAULT_OCA_BASE_URL,\n+\t\t\tapiKey: \"noop\",\n+\t\t\tfetch: async (url, init) => {\n+\t\t\t\ttry {\n+\t\t\t\t\t// Authorization Header\n+\t\t\t\t\tconst token = (await OcaTokenManager.getToken()).access_token\n+\t\t\t\t\tif (!token) {\n+\t\t\t\t\t\tthrow new Error(\"Oracle Code Assist (OCA) access token is not available\")\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst globalFetch = (typeof fetch === \"function\" ? fetch : globalThis.fetch).bind(undefined)",
        "comment_created_at": "2025-07-22T18:19:15+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "If you were to do that, you would also avoid complexity here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2223771585",
        "repo_full_name": "cline/cline",
        "pr_number": 5075,
        "pr_file": "src/api/providers/oca.ts",
        "discussion_id": "2223447332",
        "commented_code": "@@ -0,0 +1,63 @@\n+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {\n+\tconstructor(options: LiteLlmHandlerOptions) {\n+\t\tsuper(options)\n+\t}\n+\tprotected override initializeClient(options: LiteLlmHandlerOptions) {\n+\t\treturn new OpenAI({\n+\t\t\tbaseURL: options.liteLlmBaseUrl || DEFAULT_OCA_BASE_URL,\n+\t\t\tapiKey: \"noop\",\n+\t\t\tfetch: async (url, init) => {\n+\t\t\t\ttry {\n+\t\t\t\t\t// Authorization Header\n+\t\t\t\t\tconst token = (await OcaTokenManager.getToken()).access_token\n+\t\t\t\t\tif (!token) {\n+\t\t\t\t\t\tthrow new Error(\"Oracle Code Assist (OCA) access token is not available\")\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst globalFetch = (typeof fetch === \"function\" ? fetch : globalThis.fetch).bind(undefined)",
        "comment_created_at": "2025-07-22T20:34:20+00:00",
        "comment_author": "nihar-oracle",
        "comment_body": "Happy to move this to it's own class, just that the only difference between the two classes is the auth implementation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2232596443",
        "repo_full_name": "cline/cline",
        "pr_number": 5075,
        "pr_file": "src/api/providers/oca.ts",
        "discussion_id": "2223447332",
        "commented_code": "@@ -0,0 +1,63 @@\n+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {\n+\tconstructor(options: LiteLlmHandlerOptions) {\n+\t\tsuper(options)\n+\t}\n+\tprotected override initializeClient(options: LiteLlmHandlerOptions) {\n+\t\treturn new OpenAI({\n+\t\t\tbaseURL: options.liteLlmBaseUrl || DEFAULT_OCA_BASE_URL,\n+\t\t\tapiKey: \"noop\",\n+\t\t\tfetch: async (url, init) => {\n+\t\t\t\ttry {\n+\t\t\t\t\t// Authorization Header\n+\t\t\t\t\tconst token = (await OcaTokenManager.getToken()).access_token\n+\t\t\t\t\tif (!token) {\n+\t\t\t\t\t\tthrow new Error(\"Oracle Code Assist (OCA) access token is not available\")\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst globalFetch = (typeof fetch === \"function\" ? fetch : globalThis.fetch).bind(undefined)",
        "comment_created_at": "2025-07-26T06:04:57+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "Yeah let's do so",
        "pr_file_module": null
      },
      {
        "comment_id": "2237464012",
        "repo_full_name": "cline/cline",
        "pr_number": 5075,
        "pr_file": "src/api/providers/oca.ts",
        "discussion_id": "2223447332",
        "commented_code": "@@ -0,0 +1,63 @@\n+import OpenAI from \"openai\"\n+import { ApiHandlerOptions, liteLlmModelInfoSaneDefaults, type LiteLLMModelInfo } from \"@shared/api\"\n+import { LiteLlmHandler, type LiteLlmHandlerOptions } from \"./litellm\"\n+import { OcaTokenManager } from \"@/core/controller/oca/util/ocaTokenManager\"\n+import { Logger } from \"@/services/logging/Logger\"\n+import { DEFAULT_OCA_BASE_URL } from \"@/core/controller/oca/util/constants\"\n+import { createOcaHeaders } from \"@/core/controller/oca/util/utils\"\n+\n+export class OcaHandler extends LiteLlmHandler {\n+\tconstructor(options: LiteLlmHandlerOptions) {\n+\t\tsuper(options)\n+\t}\n+\tprotected override initializeClient(options: LiteLlmHandlerOptions) {\n+\t\treturn new OpenAI({\n+\t\t\tbaseURL: options.liteLlmBaseUrl || DEFAULT_OCA_BASE_URL,\n+\t\t\tapiKey: \"noop\",\n+\t\t\tfetch: async (url, init) => {\n+\t\t\t\ttry {\n+\t\t\t\t\t// Authorization Header\n+\t\t\t\t\tconst token = (await OcaTokenManager.getToken()).access_token\n+\t\t\t\t\tif (!token) {\n+\t\t\t\t\t\tthrow new Error(\"Oracle Code Assist (OCA) access token is not available\")\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tconst globalFetch = (typeof fetch === \"function\" ? fetch : globalThis.fetch).bind(undefined)",
        "comment_created_at": "2025-07-28T17:57:10+00:00",
        "comment_author": "nihar-oracle",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2229651477",
    "pr_number": 5152,
    "pr_file": "src/hosts/vscode/hostbridge/window/openFile.ts",
    "created_at": "2025-07-24T21:48:50+00:00",
    "commented_code": "+import * as vscode from \"vscode\"\n+import * as path from \"path\"\n+import { OpenFileRequest, OpenFileResponse } from \"@/shared/proto/host/window\"\n+\n+export async function openFile(request: OpenFileRequest): Promise<OpenFileResponse> {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2229651477",
        "repo_full_name": "cline/cline",
        "pr_number": 5152,
        "pr_file": "src/hosts/vscode/hostbridge/window/openFile.ts",
        "discussion_id": "2229651477",
        "commented_code": "@@ -0,0 +1,46 @@\n+import * as vscode from \"vscode\"\n+import * as path from \"path\"\n+import { OpenFileRequest, OpenFileResponse } from \"@/shared/proto/host/window\"\n+\n+export async function openFile(request: OpenFileRequest): Promise<OpenFileResponse> {",
        "comment_created_at": "2025-07-24T21:48:50+00:00",
        "comment_author": "sjf",
        "comment_body": "The switch to the host bridge for vscode should really just be moving the existing code into a new file. We don't want to change how it works at the same time.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205884078",
    "pr_number": 4897,
    "pr_file": "src/services/ripgrep/index.ts",
    "created_at": "2025-07-14T21:47:32+00:00",
    "commented_code": "const MAX_RESULTS = 300\n \n-export async function getBinPath(vscodeAppRoot: string): Promise<string | undefined> {\n-\tconst checkPath = async (pkgFolder: string) => {\n-\t\tconst fullPath = path.join(vscodeAppRoot, pkgFolder, binName)\n-\t\treturn (await fileExistsAtPath(fullPath)) ? fullPath : undefined\n+export async function getBinPath(vscodeAppRoot?: string): Promise<string | undefined> {\n+\t// If running in non VS Code environment, use bundled binary\n+\tif (isSetup) {\n+\t\ttry {\n+\t\t\tconst binaryPath = getBinaryInstallPath()\n+\t\t\tif (binaryPath) {\n+\t\t\t\tconst bundledPath = getRipgrepBinaryPath(binaryPath)",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2205884078",
        "repo_full_name": "cline/cline",
        "pr_number": 4897,
        "pr_file": "src/services/ripgrep/index.ts",
        "discussion_id": "2205884078",
        "commented_code": "@@ -61,18 +63,38 @@ interface SearchResult {\n \n const MAX_RESULTS = 300\n \n-export async function getBinPath(vscodeAppRoot: string): Promise<string | undefined> {\n-\tconst checkPath = async (pkgFolder: string) => {\n-\t\tconst fullPath = path.join(vscodeAppRoot, pkgFolder, binName)\n-\t\treturn (await fileExistsAtPath(fullPath)) ? fullPath : undefined\n+export async function getBinPath(vscodeAppRoot?: string): Promise<string | undefined> {\n+\t// If running in non VS Code environment, use bundled binary\n+\tif (isSetup) {\n+\t\ttry {\n+\t\t\tconst binaryPath = getBinaryInstallPath()\n+\t\t\tif (binaryPath) {\n+\t\t\t\tconst bundledPath = getRipgrepBinaryPath(binaryPath)",
        "comment_created_at": "2025-07-14T21:47:32+00:00",
        "comment_author": "sjf",
        "comment_body": "We should be able to run the ripgrep binary using `getRipgrepBinaryPath(binaryPath)` on all platforms, so we don't need different cases for vscode, intellij, etc.\r\n\r\nThe separate code paths for different platforms need to all be contained within the `host-providers`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2056978389",
    "pr_number": 3085,
    "pr_file": "src/services/mcp/McpHub.ts",
    "created_at": "2025-04-23T22:54:30+00:00",
    "commented_code": "}\n \t}\n \n+\tasync updateServerConnectionsRPC(newServers: Record<string, McpServerConfig>): Promise<void> {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2056982377",
        "repo_full_name": "cline/cline",
        "pr_number": 3085,
        "pr_file": "src/services/mcp/McpHub.ts",
        "discussion_id": "2056978389",
        "commented_code": "@@ -377,6 +376,53 @@ export class McpHub {\n \t\t}\n \t}\n \n+\tasync updateServerConnectionsRPC(newServers: Record<string, McpServerConfig>): Promise<void> {",
        "comment_created_at": "2025-04-23T22:54:30+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "This function is called in several other places in McpHub, so it's cleanest to make a new function for now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2031521774",
    "pr_number": 2423,
    "pr_file": "src/services/browser/BrowserSession.ts",
    "created_at": "2025-04-07T15:38:16+00:00",
    "commented_code": "import * as vscode from \"vscode\"\n import * as fs from \"fs/promises\"\n import * as path from \"path\"\n-import { Browser, Page, ScreenshotOptions, TimeoutError, launch } from \"puppeteer-core\"\n+import { exec, spawn } from \"child_process\"\n+import { Browser, Page, ScreenshotOptions, TimeoutError, launch, connect } from \"puppeteer-core\"\n // @ts-ignore\n import PCR from \"puppeteer-chromium-resolver\"\n import pWaitFor from \"p-wait-for\"\n import { setTimeout as setTimeoutPromise } from \"node:timers/promises\"\n+import axios from \"axios\"\n import { fileExistsAtPath } from \"../../utils/fs\"\n import { BrowserActionResult } from \"../../shared/ExtensionMessage\"\n import { BrowserSettings } from \"../../shared/BrowserSettings\"\n-// import * as chromeLauncher from \"chrome-launcher\"\n+import { discoverChromeInstances, testBrowserConnection, isPortOpen } from \"./BrowserDiscovery\"\n+import * as chromeLauncher from \"chrome-launcher\"\n+import { Controller } from \"../../core/controller\"\n+import { telemetryService } from \"../../services/telemetry/TelemetryService\"\n \n interface PCRStats {\n \tpuppeteer: { launch: typeof launch }\n \texecutablePath: string\n }\n \n-// const DEBUG_PORT = 9222 // Chrome's default debugging port\n+// Define browser connection info interface\n+export interface BrowserConnectionInfo {\n+\tisConnected: boolean\n+\tisRemote: boolean\n+\thost?: string\n+}\n+\n+const DEBUG_PORT = 9222 // Chrome's default debugging port\n \n export class BrowserSession {\n \tprivate context: vscode.ExtensionContext\n \tprivate browser?: Browser\n \tprivate page?: Page\n \tprivate currentMousePosition?: string\n+\tprivate cachedWebSocketEndpoint?: string\n+\tprivate lastConnectionAttempt: number = 0\n \tbrowserSettings: BrowserSettings\n+\tprivate isConnectedToRemote: boolean = false\n+\n+\t// Telemetry tracking properties\n+\tprivate sessionStartTime: number = 0\n+\tprivate browserActions: string[] = []\n+\tprivate taskId?: string\n \n \tconstructor(context: vscode.ExtensionContext, browserSettings: BrowserSettings) {\n \t\tthis.context = context\n \t\tthis.browserSettings = browserSettings\n \t}\n \n-\tprivate async ensureChromiumExists(): Promise<PCRStats> {\n+\t// Tests remote browser connection\n+\tasync testConnection(host: string): Promise<{ success: boolean; message: string; endpoint?: string }> {\n+\t\treturn testBrowserConnection(host)\n+\t}\n+\n+\t/**\n+\t * Get current browser connection information\n+\t */\n+\tgetConnectionInfo(): BrowserConnectionInfo {\n+\t\treturn {\n+\t\t\tisConnected: !!this.browser,\n+\t\t\tisRemote: this.isConnectedToRemote,\n+\t\t\thost: this.isConnectedToRemote ? this.browserSettings.remoteBrowserHost : undefined,\n+\t\t}\n+\t}\n+\n+\tasync getDetectedChromePath(): Promise<{ path: string; isBundled: boolean }> {\n+\t\t// First check VSCode config\n+\t\tconst configPath = vscode.workspace.getConfiguration(\"cline\").get<string>(\"chromeExecutablePath\")\n+\t\tif (configPath && (await fileExistsAtPath(configPath))) {\n+\t\t\treturn { path: configPath, isBundled: false }\n+\t\t}\n+\n+\t\t// Then try to find system Chrome\n+\t\ttry {\n+\t\t\tconst systemPath = chromeLauncher.Launcher.getFirstInstallation()\n+\t\t\t// Add validation to ensure path is not in Trash - This can happen on Mac OS due to the way the chrome-launcher library works\n+\t\t\tif (systemPath && !systemPath.includes(\".Trash\") && (await fileExistsAtPath(systemPath))) {\n+\t\t\t\treturn { path: systemPath, isBundled: false }\n+\t\t\t}\n+\t\t} catch (error) {\n+\t\t\tconsole.info(\"Could not find system Chrome:\", error)\n+\t\t}\n+\n+\t\t// Finally fall back to PCR's bundled version\n+\t\tconst stats = await this.ensureChromiumExists()\n+\t\treturn { path: stats.executablePath, isBundled: true }\n+\t}\n+\n+\tasync ensureChromiumExists(): Promise<PCRStats> {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2031521774",
        "repo_full_name": "cline/cline",
        "pr_number": 2423,
        "pr_file": "src/services/browser/BrowserSession.ts",
        "discussion_id": "2031521774",
        "commented_code": "@@ -1,36 +1,95 @@\n import * as vscode from \"vscode\"\n import * as fs from \"fs/promises\"\n import * as path from \"path\"\n-import { Browser, Page, ScreenshotOptions, TimeoutError, launch } from \"puppeteer-core\"\n+import { exec, spawn } from \"child_process\"\n+import { Browser, Page, ScreenshotOptions, TimeoutError, launch, connect } from \"puppeteer-core\"\n // @ts-ignore\n import PCR from \"puppeteer-chromium-resolver\"\n import pWaitFor from \"p-wait-for\"\n import { setTimeout as setTimeoutPromise } from \"node:timers/promises\"\n+import axios from \"axios\"\n import { fileExistsAtPath } from \"../../utils/fs\"\n import { BrowserActionResult } from \"../../shared/ExtensionMessage\"\n import { BrowserSettings } from \"../../shared/BrowserSettings\"\n-// import * as chromeLauncher from \"chrome-launcher\"\n+import { discoverChromeInstances, testBrowserConnection, isPortOpen } from \"./BrowserDiscovery\"\n+import * as chromeLauncher from \"chrome-launcher\"\n+import { Controller } from \"../../core/controller\"\n+import { telemetryService } from \"../../services/telemetry/TelemetryService\"\n \n interface PCRStats {\n \tpuppeteer: { launch: typeof launch }\n \texecutablePath: string\n }\n \n-// const DEBUG_PORT = 9222 // Chrome's default debugging port\n+// Define browser connection info interface\n+export interface BrowserConnectionInfo {\n+\tisConnected: boolean\n+\tisRemote: boolean\n+\thost?: string\n+}\n+\n+const DEBUG_PORT = 9222 // Chrome's default debugging port\n \n export class BrowserSession {\n \tprivate context: vscode.ExtensionContext\n \tprivate browser?: Browser\n \tprivate page?: Page\n \tprivate currentMousePosition?: string\n+\tprivate cachedWebSocketEndpoint?: string\n+\tprivate lastConnectionAttempt: number = 0\n \tbrowserSettings: BrowserSettings\n+\tprivate isConnectedToRemote: boolean = false\n+\n+\t// Telemetry tracking properties\n+\tprivate sessionStartTime: number = 0\n+\tprivate browserActions: string[] = []\n+\tprivate taskId?: string\n \n \tconstructor(context: vscode.ExtensionContext, browserSettings: BrowserSettings) {\n \t\tthis.context = context\n \t\tthis.browserSettings = browserSettings\n \t}\n \n-\tprivate async ensureChromiumExists(): Promise<PCRStats> {\n+\t// Tests remote browser connection\n+\tasync testConnection(host: string): Promise<{ success: boolean; message: string; endpoint?: string }> {\n+\t\treturn testBrowserConnection(host)\n+\t}\n+\n+\t/**\n+\t * Get current browser connection information\n+\t */\n+\tgetConnectionInfo(): BrowserConnectionInfo {\n+\t\treturn {\n+\t\t\tisConnected: !!this.browser,\n+\t\t\tisRemote: this.isConnectedToRemote,\n+\t\t\thost: this.isConnectedToRemote ? this.browserSettings.remoteBrowserHost : undefined,\n+\t\t}\n+\t}\n+\n+\tasync getDetectedChromePath(): Promise<{ path: string; isBundled: boolean }> {\n+\t\t// First check VSCode config\n+\t\tconst configPath = vscode.workspace.getConfiguration(\"cline\").get<string>(\"chromeExecutablePath\")\n+\t\tif (configPath && (await fileExistsAtPath(configPath))) {\n+\t\t\treturn { path: configPath, isBundled: false }\n+\t\t}\n+\n+\t\t// Then try to find system Chrome\n+\t\ttry {\n+\t\t\tconst systemPath = chromeLauncher.Launcher.getFirstInstallation()\n+\t\t\t// Add validation to ensure path is not in Trash - This can happen on Mac OS due to the way the chrome-launcher library works\n+\t\t\tif (systemPath && !systemPath.includes(\".Trash\") && (await fileExistsAtPath(systemPath))) {\n+\t\t\t\treturn { path: systemPath, isBundled: false }\n+\t\t\t}\n+\t\t} catch (error) {\n+\t\t\tconsole.info(\"Could not find system Chrome:\", error)\n+\t\t}\n+\n+\t\t// Finally fall back to PCR's bundled version\n+\t\tconst stats = await this.ensureChromiumExists()\n+\t\treturn { path: stats.executablePath, isBundled: true }\n+\t}\n+\n+\tasync ensureChromiumExists(): Promise<PCRStats> {",
        "comment_created_at": "2025-04-07T15:38:16+00:00",
        "comment_author": "arafatkatze",
        "comment_body": "This file is very large would it be possible to rip out some code from here to make separate functions \r\n\r\n`ensureChromiumExists` and `getDetectedChromePath` can be ripped out into a separate file like something like `ChromeExecutableManager`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2028052235",
    "pr_number": 2661,
    "pr_file": "src/core/task/index.ts",
    "created_at": "2025-04-04T04:04:08+00:00",
    "commented_code": "isInitialized = false\n \tisAwaitingPlanResponse = false\n \tdidRespondToPlanAskBySwitchingMode = false\n+\tlastOptionsCount: number = 0",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2028052235",
        "repo_full_name": "cline/cline",
        "pr_number": 2661,
        "pr_file": "src/core/task/index.ts",
        "discussion_id": "2028052235",
        "commented_code": "@@ -116,6 +116,7 @@ export class Task {\n \tisInitialized = false\n \tisAwaitingPlanResponse = false\n \tdidRespondToPlanAskBySwitchingMode = false\n+\tlastOptionsCount: number = 0",
        "comment_created_at": "2025-04-04T04:04:08+00:00",
        "comment_author": "saoudrizwan",
        "comment_body": "we dont need this property, instead we can retrieve this from the message data itself (we should avoid adding anymore class properties here than we have to)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1992083710",
    "pr_number": 2198,
    "pr_file": "src/core/Cline.ts",
    "created_at": "2025-03-12T18:31:47+00:00",
    "commented_code": "telemetryService.captureConversationTurnEvent(this.taskId, this.apiProvider, this.api.getModel().id, \"user\")\n \n+\t\t// Capture message data for telemetry,",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "1992083710",
        "repo_full_name": "cline/cline",
        "pr_number": 2198,
        "pr_file": "src/core/Cline.ts",
        "discussion_id": "1992083710",
        "commented_code": "@@ -3120,6 +3141,42 @@ export class Cline {\n \n \t\ttelemetryService.captureConversationTurnEvent(this.taskId, this.apiProvider, this.api.getModel().id, \"user\")\n \n+\t\t// Capture message data for telemetry,",
        "comment_created_at": "2025-03-12T18:31:47+00:00",
        "comment_author": "ocasta181",
        "comment_body": "Is there a way we can move the bulk of this logic out into a function held in a separate file? I'm concerned about further bloating cline.ts",
        "pr_file_module": null
      },
      {
        "comment_id": "1992115473",
        "repo_full_name": "cline/cline",
        "pr_number": 2198,
        "pr_file": "src/core/Cline.ts",
        "discussion_id": "1992083710",
        "commented_code": "@@ -3120,6 +3141,42 @@ export class Cline {\n \n \t\ttelemetryService.captureConversationTurnEvent(this.taskId, this.apiProvider, this.api.getModel().id, \"user\")\n \n+\t\t// Capture message data for telemetry,",
        "comment_created_at": "2025-03-12T18:53:01+00:00",
        "comment_author": "pashpashpash",
        "comment_body": "I understand the concern about file size, but moving these functions out in isolation would actually introduce more complexity without addressing the core architectural needs.\r\n\r\nthe message handling logic is tightly coupled with several provider-specific dependencies (apiProvider, taskId, model settings) and requires specific timing/cleanup handling. Creating separate utility functions would mean either:\r\n\r\n1. Passing all these dependencies as parameters, leading to unwieldy function signatures and potential maintainability issues\r\n2. Creating new interfaces/abstractions just for this specific use case, which adds more indirection without clear benefits\r\n\r\nif we want to properly modularize this code, it would make more sense to do it as part of a larger architectural refactor that thoughtfully separates the message handling responsibilities. \r\n\r\nFor now, keeping this logic colocated provides better clarity around the dependencies and control flow.",
        "pr_file_module": null
      }
    ]
  }
]