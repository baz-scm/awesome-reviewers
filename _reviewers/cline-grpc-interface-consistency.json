[
  {
    "discussion_id": "2229647422",
    "pr_number": 5152,
    "pr_file": "src/hosts/vscode/hostbridge/file/selectFiles.ts",
    "created_at": "2025-07-24T21:45:31+00:00",
    "commented_code": "+import * as vscode from \"vscode\"\n+import * as fs from \"fs/promises\"\n+import * as path from \"path\"\n+import sizeOf from \"image-size\"\n+import { BooleanRequest, StringArrays } from \"@/shared/proto/common\"\n+\n+export async function selectFiles(request: BooleanRequest): Promise<StringArrays> {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2229647422",
        "repo_full_name": "cline/cline",
        "pr_number": 5152,
        "pr_file": "src/hosts/vscode/hostbridge/file/selectFiles.ts",
        "discussion_id": "2229647422",
        "commented_code": "@@ -0,0 +1,93 @@\n+import * as vscode from \"vscode\"\n+import * as fs from \"fs/promises\"\n+import * as path from \"path\"\n+import sizeOf from \"image-size\"\n+import { BooleanRequest, StringArrays } from \"@/shared/proto/common\"\n+\n+export async function selectFiles(request: BooleanRequest): Promise<StringArrays> {",
        "comment_created_at": "2025-07-24T21:45:31+00:00",
        "comment_author": "sjf",
        "comment_body": "Unfortunately we don't need this RPC `selectFiles`. There is is already a way to open the file picker in the host bridge: `window.showOpenDialogue`. The rest of this function where it encodes the files is not dependent on the IDE, so it shouldn't be in the host bridge because it means each platform will need to re-implement it (unnecessarily). \r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193724194",
    "pr_number": 4745,
    "pr_file": "src/core/controller/file/deleteRuleFile.ts",
    "created_at": "2025-07-09T01:38:54+00:00",
    "commented_code": "const fileTypeName = request.type === \"workflow\" ? \"workflow\" : \"rule\"\n \n-\tvscode.window.showInformationMessage(`${fileTypeName} file \"${fileName}\" deleted successfully`)\n+\tshowInformationMessage(`${fileTypeName} file \"${fileName}\" deleted successfully`)",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2193724194",
        "repo_full_name": "cline/cline",
        "pr_number": 4745,
        "pr_file": "src/core/controller/file/deleteRuleFile.ts",
        "discussion_id": "2193724194",
        "commented_code": "@@ -44,7 +44,7 @@ export const deleteRuleFile: FileMethodHandler = async (controller: Controller,\n \n \tconst fileTypeName = request.type === \"workflow\" ? \"workflow\" : \"rule\"\n \n-\tvscode.window.showInformationMessage(`${fileTypeName} file \"${fileName}\" deleted successfully`)\n+\tshowInformationMessage(`${fileTypeName} file \"${fileName}\" deleted successfully`)",
        "comment_created_at": "2025-07-09T01:38:54+00:00",
        "comment_author": "Garoth",
        "comment_body": "This isn't the correct way, if I understand correctly. You appear to be directly important and using the VSCode implementation, but you actually need to use the gRPC client to make the call. Otherwise, the VSCode implementation gets bundled into standalone, rather than calling the remote service ",
        "pr_file_module": null
      },
      {
        "comment_id": "2196272528",
        "repo_full_name": "cline/cline",
        "pr_number": 4745,
        "pr_file": "src/core/controller/file/deleteRuleFile.ts",
        "discussion_id": "2193724194",
        "commented_code": "@@ -44,7 +44,7 @@ export const deleteRuleFile: FileMethodHandler = async (controller: Controller,\n \n \tconst fileTypeName = request.type === \"workflow\" ? \"workflow\" : \"rule\"\n \n-\tvscode.window.showInformationMessage(`${fileTypeName} file \"${fileName}\" deleted successfully`)\n+\tshowInformationMessage(`${fileTypeName} file \"${fileName}\" deleted successfully`)",
        "comment_created_at": "2025-07-10T00:54:57+00:00",
        "comment_author": "abeatrix",
        "comment_body": "Updated all the call sites to use the host bridge provider instead. Thanks for walking through the code with me :) ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2119493703",
    "pr_number": 3977,
    "pr_file": "src/core/controller/ui/subscribeToHistoryButtonClicked.ts",
    "created_at": "2025-06-01T19:40:05+00:00",
    "commented_code": "+import { Controller } from \"../index\"\n+import { EmptyRequest, Empty } from \"@shared/proto/common\"\n+import { StreamingResponseHandler, getRequestRegistry } from \"../grpc-handler\"\n+\n+// Keep track of active subscriptions\n+const activeHistoryButtonClickedSubscriptions = new Set<StreamingResponseHandler>()\n+\n+/**\n+ * Subscribe to history button clicked events\n+ * @param controller The controller instance\n+ * @param request The empty request\n+ * @param responseStream The streaming response handler\n+ * @param requestId The ID of the request (passed by the gRPC handler)\n+ */\n+export async function subscribeToHistoryButtonClicked(\n+\tcontroller: Controller,\n+\trequest: EmptyRequest,\n+\tresponseStream: StreamingResponseHandler,\n+\trequestId?: string,\n+): Promise<void> {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2119493703",
        "repo_full_name": "cline/cline",
        "pr_number": 3977,
        "pr_file": "src/core/controller/ui/subscribeToHistoryButtonClicked.ts",
        "discussion_id": "2119493703",
        "commented_code": "@@ -0,0 +1,55 @@\n+import { Controller } from \"../index\"\n+import { EmptyRequest, Empty } from \"@shared/proto/common\"\n+import { StreamingResponseHandler, getRequestRegistry } from \"../grpc-handler\"\n+\n+// Keep track of active subscriptions\n+const activeHistoryButtonClickedSubscriptions = new Set<StreamingResponseHandler>()\n+\n+/**\n+ * Subscribe to history button clicked events\n+ * @param controller The controller instance\n+ * @param request The empty request\n+ * @param responseStream The streaming response handler\n+ * @param requestId The ID of the request (passed by the gRPC handler)\n+ */\n+export async function subscribeToHistoryButtonClicked(\n+\tcontroller: Controller,\n+\trequest: EmptyRequest,\n+\tresponseStream: StreamingResponseHandler,\n+\trequestId?: string,\n+): Promise<void> {",
        "comment_created_at": "2025-06-01T19:40:05+00:00",
        "comment_author": "sjf",
        "comment_body": "This should be `Promise<Empty>`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2119567202",
        "repo_full_name": "cline/cline",
        "pr_number": 3977,
        "pr_file": "src/core/controller/ui/subscribeToHistoryButtonClicked.ts",
        "discussion_id": "2119493703",
        "commented_code": "@@ -0,0 +1,55 @@\n+import { Controller } from \"../index\"\n+import { EmptyRequest, Empty } from \"@shared/proto/common\"\n+import { StreamingResponseHandler, getRequestRegistry } from \"../grpc-handler\"\n+\n+// Keep track of active subscriptions\n+const activeHistoryButtonClickedSubscriptions = new Set<StreamingResponseHandler>()\n+\n+/**\n+ * Subscribe to history button clicked events\n+ * @param controller The controller instance\n+ * @param request The empty request\n+ * @param responseStream The streaming response handler\n+ * @param requestId The ID of the request (passed by the gRPC handler)\n+ */\n+export async function subscribeToHistoryButtonClicked(\n+\tcontroller: Controller,\n+\trequest: EmptyRequest,\n+\tresponseStream: StreamingResponseHandler,\n+\trequestId?: string,\n+): Promise<void> {",
        "comment_created_at": "2025-06-01T20:29:26+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "@sjf Are we sure about this? Citing @Garoth 's inaugural PR, a Promise<void> is used.\r\n\r\nhttps://github.com/cline/cline/pull/3781/files#diff-66f49a5549f7ac3e91f56d3bbe46445a57bf27a19e60ecd962fd4030d4bd027d",
        "pr_file_module": null
      },
      {
        "comment_id": "2119676137",
        "repo_full_name": "cline/cline",
        "pr_number": 3977,
        "pr_file": "src/core/controller/ui/subscribeToHistoryButtonClicked.ts",
        "discussion_id": "2119493703",
        "commented_code": "@@ -0,0 +1,55 @@\n+import { Controller } from \"../index\"\n+import { EmptyRequest, Empty } from \"@shared/proto/common\"\n+import { StreamingResponseHandler, getRequestRegistry } from \"../grpc-handler\"\n+\n+// Keep track of active subscriptions\n+const activeHistoryButtonClickedSubscriptions = new Set<StreamingResponseHandler>()\n+\n+/**\n+ * Subscribe to history button clicked events\n+ * @param controller The controller instance\n+ * @param request The empty request\n+ * @param responseStream The streaming response handler\n+ * @param requestId The ID of the request (passed by the gRPC handler)\n+ */\n+export async function subscribeToHistoryButtonClicked(\n+\tcontroller: Controller,\n+\trequest: EmptyRequest,\n+\tresponseStream: StreamingResponseHandler,\n+\trequestId?: string,\n+): Promise<void> {",
        "comment_created_at": "2025-06-01T22:38:55+00:00",
        "comment_author": "sjf",
        "comment_body": "It only works because of lax typechecking in the extension. When we start integrating with Intellij, not returning the correct type will cause the rpc to fail, because it deserializes the JSON object into the return type. So, all the occurrences of void instead of Empty will need to be updated. \r\n\r\nI'm working on a eslint rule to check that the handlers match the types from the proto.",
        "pr_file_module": null
      },
      {
        "comment_id": "2119903690",
        "repo_full_name": "cline/cline",
        "pr_number": 3977,
        "pr_file": "src/core/controller/ui/subscribeToHistoryButtonClicked.ts",
        "discussion_id": "2119493703",
        "commented_code": "@@ -0,0 +1,55 @@\n+import { Controller } from \"../index\"\n+import { EmptyRequest, Empty } from \"@shared/proto/common\"\n+import { StreamingResponseHandler, getRequestRegistry } from \"../grpc-handler\"\n+\n+// Keep track of active subscriptions\n+const activeHistoryButtonClickedSubscriptions = new Set<StreamingResponseHandler>()\n+\n+/**\n+ * Subscribe to history button clicked events\n+ * @param controller The controller instance\n+ * @param request The empty request\n+ * @param responseStream The streaming response handler\n+ * @param requestId The ID of the request (passed by the gRPC handler)\n+ */\n+export async function subscribeToHistoryButtonClicked(\n+\tcontroller: Controller,\n+\trequest: EmptyRequest,\n+\tresponseStream: StreamingResponseHandler,\n+\trequestId?: string,\n+): Promise<void> {",
        "comment_created_at": "2025-06-02T02:48:25+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "Okay sounds good",
        "pr_file_module": null
      },
      {
        "comment_id": "2119903904",
        "repo_full_name": "cline/cline",
        "pr_number": 3977,
        "pr_file": "src/core/controller/ui/subscribeToHistoryButtonClicked.ts",
        "discussion_id": "2119493703",
        "commented_code": "@@ -0,0 +1,55 @@\n+import { Controller } from \"../index\"\n+import { EmptyRequest, Empty } from \"@shared/proto/common\"\n+import { StreamingResponseHandler, getRequestRegistry } from \"../grpc-handler\"\n+\n+// Keep track of active subscriptions\n+const activeHistoryButtonClickedSubscriptions = new Set<StreamingResponseHandler>()\n+\n+/**\n+ * Subscribe to history button clicked events\n+ * @param controller The controller instance\n+ * @param request The empty request\n+ * @param responseStream The streaming response handler\n+ * @param requestId The ID of the request (passed by the gRPC handler)\n+ */\n+export async function subscribeToHistoryButtonClicked(\n+\tcontroller: Controller,\n+\trequest: EmptyRequest,\n+\tresponseStream: StreamingResponseHandler,\n+\trequestId?: string,\n+): Promise<void> {",
        "comment_created_at": "2025-06-02T02:48:48+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "@sjf So in the error case we need to also return Empty?",
        "pr_file_module": null
      },
      {
        "comment_id": "2121925177",
        "repo_full_name": "cline/cline",
        "pr_number": 3977,
        "pr_file": "src/core/controller/ui/subscribeToHistoryButtonClicked.ts",
        "discussion_id": "2119493703",
        "commented_code": "@@ -0,0 +1,55 @@\n+import { Controller } from \"../index\"\n+import { EmptyRequest, Empty } from \"@shared/proto/common\"\n+import { StreamingResponseHandler, getRequestRegistry } from \"../grpc-handler\"\n+\n+// Keep track of active subscriptions\n+const activeHistoryButtonClickedSubscriptions = new Set<StreamingResponseHandler>()\n+\n+/**\n+ * Subscribe to history button clicked events\n+ * @param controller The controller instance\n+ * @param request The empty request\n+ * @param responseStream The streaming response handler\n+ * @param requestId The ID of the request (passed by the gRPC handler)\n+ */\n+export async function subscribeToHistoryButtonClicked(\n+\tcontroller: Controller,\n+\trequest: EmptyRequest,\n+\tresponseStream: StreamingResponseHandler,\n+\trequestId?: string,\n+): Promise<void> {",
        "comment_created_at": "2025-06-02T18:51:40+00:00",
        "comment_author": "sjf",
        "comment_body": "Discussed this offline with Evan, apparently returning Promise<Empty> causes an error.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2062697131",
    "pr_number": 3147,
    "pr_file": "src/core/controller/mcp/addRemoteMcpServer.ts",
    "created_at": "2025-04-27T18:46:18+00:00",
    "commented_code": "+import { convertMcpServersToProtoMcpServers } from \"@/shared/proto-conversions/mcp/mcp-server-conversion\"\n+import type { AddRemoteMcpServerRequest, McpServers } from \"../../../shared/proto/mcp\"\n+import { McpServerStatus } from \"../../../shared/proto/mcp\"\n+import type { Controller } from \"../index\"\n+\n+/**\n+ * Adds a new remote MCP server via gRPC\n+ * @param controller The controller instance\n+ * @param request The request containing server name and URL\n+ * @returns An array of McpServer objects\n+ */\n+export async function addRemoteMcpServer(controller: Controller, request: AddRemoteMcpServerRequest): Promise<McpServers> {\n+\ttry {\n+\t\t// Validate required fields\n+\t\tif (!request.serverName) {\n+\t\t\tthrow new Error(\"Server name is required\")\n+\t\t}\n+\t\tif (!request.serverUrl) {\n+\t\t\tthrow new Error(\"Server URL is required\")\n+\t\t}\n+\n+\t\t// Call the McpHub method to add the remote server\n+\t\tconst servers = await controller.mcpHub?.addRemoteServer(request.serverName, request.serverUrl)\n+\n+\t\tconst protoServers = convertMcpServersToProtoMcpServers(servers)\n+\n+\t\treturn { mcpServers: protoServers }",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2062697131",
        "repo_full_name": "cline/cline",
        "pr_number": 3147,
        "pr_file": "src/core/controller/mcp/addRemoteMcpServer.ts",
        "discussion_id": "2062697131",
        "commented_code": "@@ -0,0 +1,33 @@\n+import { convertMcpServersToProtoMcpServers } from \"@/shared/proto-conversions/mcp/mcp-server-conversion\"\n+import type { AddRemoteMcpServerRequest, McpServers } from \"../../../shared/proto/mcp\"\n+import { McpServerStatus } from \"../../../shared/proto/mcp\"\n+import type { Controller } from \"../index\"\n+\n+/**\n+ * Adds a new remote MCP server via gRPC\n+ * @param controller The controller instance\n+ * @param request The request containing server name and URL\n+ * @returns An array of McpServer objects\n+ */\n+export async function addRemoteMcpServer(controller: Controller, request: AddRemoteMcpServerRequest): Promise<McpServers> {\n+\ttry {\n+\t\t// Validate required fields\n+\t\tif (!request.serverName) {\n+\t\t\tthrow new Error(\"Server name is required\")\n+\t\t}\n+\t\tif (!request.serverUrl) {\n+\t\t\tthrow new Error(\"Server URL is required\")\n+\t\t}\n+\n+\t\t// Call the McpHub method to add the remote server\n+\t\tconst servers = await controller.mcpHub?.addRemoteServer(request.serverName, request.serverUrl)\n+\n+\t\tconst protoServers = convertMcpServersToProtoMcpServers(servers)\n+\n+\t\treturn { mcpServers: protoServers }",
        "comment_created_at": "2025-04-27T18:46:18+00:00",
        "comment_author": "DaveFres",
        "comment_body": "Adjusted return value here, to also be `McpServers` type.\r\n@Garoth  I noticed in previous PR's that you're aiming to avoid introducing new response types when possible.\r\nI hope I'm on right track here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2062711579",
        "repo_full_name": "cline/cline",
        "pr_number": 3147,
        "pr_file": "src/core/controller/mcp/addRemoteMcpServer.ts",
        "discussion_id": "2062697131",
        "commented_code": "@@ -0,0 +1,33 @@\n+import { convertMcpServersToProtoMcpServers } from \"@/shared/proto-conversions/mcp/mcp-server-conversion\"\n+import type { AddRemoteMcpServerRequest, McpServers } from \"../../../shared/proto/mcp\"\n+import { McpServerStatus } from \"../../../shared/proto/mcp\"\n+import type { Controller } from \"../index\"\n+\n+/**\n+ * Adds a new remote MCP server via gRPC\n+ * @param controller The controller instance\n+ * @param request The request containing server name and URL\n+ * @returns An array of McpServer objects\n+ */\n+export async function addRemoteMcpServer(controller: Controller, request: AddRemoteMcpServerRequest): Promise<McpServers> {\n+\ttry {\n+\t\t// Validate required fields\n+\t\tif (!request.serverName) {\n+\t\t\tthrow new Error(\"Server name is required\")\n+\t\t}\n+\t\tif (!request.serverUrl) {\n+\t\t\tthrow new Error(\"Server URL is required\")\n+\t\t}\n+\n+\t\t// Call the McpHub method to add the remote server\n+\t\tconst servers = await controller.mcpHub?.addRemoteServer(request.serverName, request.serverUrl)\n+\n+\t\tconst protoServers = convertMcpServersToProtoMcpServers(servers)\n+\n+\t\treturn { mcpServers: protoServers }",
        "comment_created_at": "2025-04-27T20:06:34+00:00",
        "comment_author": "Garoth",
        "comment_body": "Hey bro!! Awesome to see you in the codebase. This PR reads very good, and I think you took on one of the more challenging ones with mcp :pray: \r\n\r\nRelated to this comment, I think you made the correct choices, eliminating the old type & replacing it with a more consistent API. Do I have this correct:\r\n\r\n- The previous response type was basically `success` bool & with `serverName` added, and an `error` string\r\n- You replaced the error string with the native gRPC error mechanism, which is great\r\n- Success can be deduced by whether an error was thrown\r\n- `serverName` is kind of interesting, since it was passed through the response before, and checked. But the need for that arises from the old message bus not linking call and response automatically, so we were verifying that the message we're receiving is actually for our request. Does that track @DaveFres ?\r\n- So now you pass back McpServers array, which isn't used by the code, but I think is totally fine. You could arguably just pass back `Empty` but I think this is nicer\r\n\r\nAll that is a very interesting case study in protobus. Thanks for doing it !",
        "pr_file_module": null
      },
      {
        "comment_id": "2062721833",
        "repo_full_name": "cline/cline",
        "pr_number": 3147,
        "pr_file": "src/core/controller/mcp/addRemoteMcpServer.ts",
        "discussion_id": "2062697131",
        "commented_code": "@@ -0,0 +1,33 @@\n+import { convertMcpServersToProtoMcpServers } from \"@/shared/proto-conversions/mcp/mcp-server-conversion\"\n+import type { AddRemoteMcpServerRequest, McpServers } from \"../../../shared/proto/mcp\"\n+import { McpServerStatus } from \"../../../shared/proto/mcp\"\n+import type { Controller } from \"../index\"\n+\n+/**\n+ * Adds a new remote MCP server via gRPC\n+ * @param controller The controller instance\n+ * @param request The request containing server name and URL\n+ * @returns An array of McpServer objects\n+ */\n+export async function addRemoteMcpServer(controller: Controller, request: AddRemoteMcpServerRequest): Promise<McpServers> {\n+\ttry {\n+\t\t// Validate required fields\n+\t\tif (!request.serverName) {\n+\t\t\tthrow new Error(\"Server name is required\")\n+\t\t}\n+\t\tif (!request.serverUrl) {\n+\t\t\tthrow new Error(\"Server URL is required\")\n+\t\t}\n+\n+\t\t// Call the McpHub method to add the remote server\n+\t\tconst servers = await controller.mcpHub?.addRemoteServer(request.serverName, request.serverUrl)\n+\n+\t\tconst protoServers = convertMcpServersToProtoMcpServers(servers)\n+\n+\t\treturn { mcpServers: protoServers }",
        "comment_created_at": "2025-04-27T21:04:57+00:00",
        "comment_author": "DaveFres",
        "comment_body": "Thanks for the quick reply!\r\n\r\n> The previous response type was basically success bool & with serverName added, and an error string\r\nYou replaced the error string with the native gRPC error mechanism, which is great\r\nSuccess can be deduced by whether an error was thrown\r\n\r\nyep, exactly!\r\n\r\n> serverName is kind of interesting, since it was passed through the response before, and checked. But the need for that arises from the old message bus not linking call and response automatically, so we were verifying that the message we're receiving is actually for our request.\r\n\r\nYes, that's right! gRPC handles request-response correlation automatically in this setup.\r\n\r\n> So now you pass back McpServers array, which isn't used by the code, but I think is totally fine. You could arguably just pass back Empty but I think this is nicer\r\n\r\nYep, also correct.\r\nThe response is not used yet and we could remove it, but for now tried to keep consistency between mcp methods.\r\n\r\nBased my PR on this one: https://github.com/cline/cline/pull/3115.\r\n\r\nIf you plan to migrate `addRemoteServer` to protobus, feel free to use this PR as a boilerplate or simply merge it if you like the changes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2029676014",
    "pr_number": 2423,
    "pr_file": "src/shared/ExtensionMessage.ts",
    "created_at": "2025-04-05T03:26:43+00:00",
    "commented_code": "userCreditsUsage?: UsageTransaction[]\n \tuserCreditsPayments?: PaymentTransaction[]\n \ttotalTasksSize?: number | null\n+\tsuccess?: boolean\n+\tvalues?: Record<string, any>",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2029676014",
        "repo_full_name": "cline/cline",
        "pr_number": 2423,
        "pr_file": "src/shared/ExtensionMessage.ts",
        "discussion_id": "2029676014",
        "commented_code": "@@ -81,6 +86,13 @@ export interface ExtensionMessage {\n \tuserCreditsUsage?: UsageTransaction[]\n \tuserCreditsPayments?: PaymentTransaction[]\n \ttotalTasksSize?: number | null\n+\tsuccess?: boolean\n+\tvalues?: Record<string, any>",
        "comment_created_at": "2025-04-05T03:26:43+00:00",
        "comment_author": "saoudrizwan",
        "comment_body": "it looks like we're only ever using this to pass `values: { endpoint: result.endpoint }`, can we instead just create an `endpoint` string? that way it's typed and less prone to issues when we refactor message passing",
        "pr_file_module": null
      },
      {
        "comment_id": "2029692815",
        "repo_full_name": "cline/cline",
        "pr_number": 2423,
        "pr_file": "src/shared/ExtensionMessage.ts",
        "discussion_id": "2029676014",
        "commented_code": "@@ -81,6 +86,13 @@ export interface ExtensionMessage {\n \tuserCreditsUsage?: UsageTransaction[]\n \tuserCreditsPayments?: PaymentTransaction[]\n \ttotalTasksSize?: number | null\n+\tsuccess?: boolean\n+\tvalues?: Record<string, any>",
        "comment_created_at": "2025-04-05T04:26:40+00:00",
        "comment_author": "Garoth",
        "comment_body": "Done: https://github.com/cline/cline/pull/2423/commits/26e2969e0a58d074bbf8b24e167a4c94495e3e29",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2041425295",
    "pr_number": 2830,
    "pr_file": "webview-ui/src/services/grpc-client.ts",
    "created_at": "2025-04-14T05:10:51+00:00",
    "commented_code": "+import { vscode } from \"../utils/vscode\"\n+import { v4 as uuidv4 } from \"uuid\"\n+import { BrowserServiceDefinition } from \"@shared/proto/browser\"\n+import { EmptyRequest } from \"@shared/proto/common\"\n+\n+// Generic type for any protobuf service definition\n+type ProtoService = {\n+\tname: string\n+\tfullName: string\n+\tmethods: {\n+\t\t[key: string]: {\n+\t\t\tname: string\n+\t\t\trequestType: any\n+\t\t\tresponseType: any\n+\t\t\trequestStream: boolean\n+\t\t\tresponseStream: boolean\n+\t\t\toptions: any\n+\t\t}\n+\t}\n+}\n+\n+// Define a generic type that extracts method signatures from a service definition\n+type GrpcClientType<T extends ProtoService> = {\n+\t[K in keyof T[\"methods\"]]: (\n+\t\trequest: InstanceType<T[\"methods\"][K][\"requestType\"]>,\n+\t) => Promise<InstanceType<T[\"methods\"][K][\"responseType\"]>>\n+}\n+\n+// Create a client for any protobuf service with inferred types\n+function createGrpcClient<T extends ProtoService>(service: T): GrpcClientType<T> {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2041425295",
        "repo_full_name": "cline/cline",
        "pr_number": 2830,
        "pr_file": "webview-ui/src/services/grpc-client.ts",
        "discussion_id": "2041425295",
        "commented_code": "@@ -0,0 +1,89 @@\n+import { vscode } from \"../utils/vscode\"\n+import { v4 as uuidv4 } from \"uuid\"\n+import { BrowserServiceDefinition } from \"@shared/proto/browser\"\n+import { EmptyRequest } from \"@shared/proto/common\"\n+\n+// Generic type for any protobuf service definition\n+type ProtoService = {\n+\tname: string\n+\tfullName: string\n+\tmethods: {\n+\t\t[key: string]: {\n+\t\t\tname: string\n+\t\t\trequestType: any\n+\t\t\tresponseType: any\n+\t\t\trequestStream: boolean\n+\t\t\tresponseStream: boolean\n+\t\t\toptions: any\n+\t\t}\n+\t}\n+}\n+\n+// Define a generic type that extracts method signatures from a service definition\n+type GrpcClientType<T extends ProtoService> = {\n+\t[K in keyof T[\"methods\"]]: (\n+\t\trequest: InstanceType<T[\"methods\"][K][\"requestType\"]>,\n+\t) => Promise<InstanceType<T[\"methods\"][K][\"responseType\"]>>\n+}\n+\n+// Create a client for any protobuf service with inferred types\n+function createGrpcClient<T extends ProtoService>(service: T): GrpcClientType<T> {",
        "comment_created_at": "2025-04-14T05:10:51+00:00",
        "comment_author": "arafatkatze",
        "comment_body": "The current `createGrpcClient` implementation is specifically tailored for the unary request/response pattern (it sends one message and sets up a listener for one corresponding response message identified by a unique ID). If we later introduce, say, server-streaming (where the backend sends multiple messages back in response to one request), or just Protobuf-defined notifications that don't use the request/response pattern, they wouldn't fit the current client's internal mechanism.\r\n\r\nMy concern is that calling this specific implementation simply grpc-client might imply it handles all potential gRPC communication patterns. When we standardize on Protobuf more broadly in the future, we might end up needing different client implementations or handlers for different patterns (e.g., one for unary, one for streaming, etc.).\r\n\r\nPerhaps we could consider:\r\n\r\n- More Specific Naming: Rename the current client/creator function to something that reflects its specific pattern, like createUnaryGrpcClient?\r\n- Architectural Plan: If a broader migration to Protobuf is planned, maybe think about how different communication patterns (unary, streaming, notifications) would be handled? Would we have multiple specialized clients, or a different approach?\r\n\r\nThis isn't necessarily a blocker for this PR, as the current implementation is a clear improvement for the unary calls it replaces. However, thinking about the naming now might make future extensions or refactoring clearer.\r\n\r\nWhat are your thoughts on this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2041433550",
        "repo_full_name": "cline/cline",
        "pr_number": 2830,
        "pr_file": "webview-ui/src/services/grpc-client.ts",
        "discussion_id": "2041425295",
        "commented_code": "@@ -0,0 +1,89 @@\n+import { vscode } from \"../utils/vscode\"\n+import { v4 as uuidv4 } from \"uuid\"\n+import { BrowserServiceDefinition } from \"@shared/proto/browser\"\n+import { EmptyRequest } from \"@shared/proto/common\"\n+\n+// Generic type for any protobuf service definition\n+type ProtoService = {\n+\tname: string\n+\tfullName: string\n+\tmethods: {\n+\t\t[key: string]: {\n+\t\t\tname: string\n+\t\t\trequestType: any\n+\t\t\tresponseType: any\n+\t\t\trequestStream: boolean\n+\t\t\tresponseStream: boolean\n+\t\t\toptions: any\n+\t\t}\n+\t}\n+}\n+\n+// Define a generic type that extracts method signatures from a service definition\n+type GrpcClientType<T extends ProtoService> = {\n+\t[K in keyof T[\"methods\"]]: (\n+\t\trequest: InstanceType<T[\"methods\"][K][\"requestType\"]>,\n+\t) => Promise<InstanceType<T[\"methods\"][K][\"responseType\"]>>\n+}\n+\n+// Create a client for any protobuf service with inferred types\n+function createGrpcClient<T extends ProtoService>(service: T): GrpcClientType<T> {",
        "comment_created_at": "2025-04-14T05:22:27+00:00",
        "comment_author": "arafatkatze",
        "comment_body": "NOTE: You mentioned this before too but I asking you that here. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2043577191",
        "repo_full_name": "cline/cline",
        "pr_number": 2830,
        "pr_file": "webview-ui/src/services/grpc-client.ts",
        "discussion_id": "2041425295",
        "commented_code": "@@ -0,0 +1,89 @@\n+import { vscode } from \"../utils/vscode\"\n+import { v4 as uuidv4 } from \"uuid\"\n+import { BrowserServiceDefinition } from \"@shared/proto/browser\"\n+import { EmptyRequest } from \"@shared/proto/common\"\n+\n+// Generic type for any protobuf service definition\n+type ProtoService = {\n+\tname: string\n+\tfullName: string\n+\tmethods: {\n+\t\t[key: string]: {\n+\t\t\tname: string\n+\t\t\trequestType: any\n+\t\t\tresponseType: any\n+\t\t\trequestStream: boolean\n+\t\t\tresponseStream: boolean\n+\t\t\toptions: any\n+\t\t}\n+\t}\n+}\n+\n+// Define a generic type that extracts method signatures from a service definition\n+type GrpcClientType<T extends ProtoService> = {\n+\t[K in keyof T[\"methods\"]]: (\n+\t\trequest: InstanceType<T[\"methods\"][K][\"requestType\"]>,\n+\t) => Promise<InstanceType<T[\"methods\"][K][\"responseType\"]>>\n+}\n+\n+// Create a client for any protobuf service with inferred types\n+function createGrpcClient<T extends ProtoService>(service: T): GrpcClientType<T> {",
        "comment_created_at": "2025-04-15T04:45:01+00:00",
        "comment_author": "Garoth",
        "comment_body": "Thanks! My rough plan was to keep the function signatures the same, but add streaming functionality to it a little later under the hood. My idea is to handle that with reflection & modifying the request_id to support expecting multiple returns to be streamed back over time. I haven't totally thought it through, but I think it'll work out",
        "pr_file_module": null
      }
    ]
  }
]