[
  {
    "discussion_id": "2202862974",
    "pr_number": 4852,
    "pr_file": "webview-ui/src/components/mcp/chat-display/McpResponseDisplay.tsx",
    "created_at": "2025-07-12T18:28:54+00:00",
    "commented_code": "return\n \t\t}\n \n-\t\t// Use a direct boolean for cancellation that's scoped to this effect run\n-\t\tlet processingCanceled = false\n-\t\tconst processResponse = async () => {\n-\t\t\tconsole.log(\"Processing MCP response for URL extraction\")\n-\t\t\tsetIsLoading(true)\n-\t\t\tsetError(null)\n-\t\t\ttry {\n-\t\t\t\tconst text = responseText || \"\"\n-\t\t\t\tconst matches: UrlMatch[] = []\n-\t\t\t\tconst urlRegex = /(?:https?:\\/\\/|data:image)[^\\s<>\"']+/g\n-\t\t\t\tlet urlMatch: RegExpExecArray | null\n-\t\t\t\tlet urlCount = 0\n-\n-\t\t\t\t// First pass: Extract all URLs and immediately make them available for rendering\n-\t\t\t\twhile ((urlMatch = urlRegex.exec(text)) !== null && urlCount < MAX_URLS) {\n-\t\t\t\t\t// Get the original URL from the match - never modify the original URL text\n-\t\t\t\t\tconst url = urlMatch[0]\n-\n-\t\t\t\t\t// Skip invalid URLs\n-\t\t\t\t\tif (!isUrl(url)) {\n-\t\t\t\t\t\tconsole.log(\"Skipping invalid URL:\", url)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Skip localhost URLs to prevent security issues\n-\t\t\t\t\tif (isLocalhostUrl(url)) {\n-\t\t\t\t\t\tconsole.log(\"Skipping localhost URL:\", url)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tmatches.push({\n-\t\t\t\t\t\turl,\n-\t\t\t\t\t\tfullMatch: url,\n-\t\t\t\t\t\tindex: urlMatch.index,\n-\t\t\t\t\t\tisImage: false, // Will check later\n-\t\t\t\t\t\tisProcessed: false,\n-\t\t\t\t\t})\n-\n-\t\t\t\t\turlCount++\n-\t\t\t\t}\n-\n-\t\t\t\tconsole.log(`Found ${matches.length} URLs in text, will check if they are images`)\n-\n-\t\t\t\t// Set matches immediately so UI can start rendering with loading states\n-\t\t\t\tsetUrlMatches(matches.sort((a, b) => a.index - b.index))\n-\n-\t\t\t\t// Mark loading as complete to show content immediately\n-\t\t\t\tsetIsLoading(false)\n+\t\tconsole.log(\"Processing MCP response for URL extraction\")\n+\t\tsetIsLoading(true)\n+\t\tsetError(null)\n \n-\t\t\t\t// Process image checks in the background - one at a time to avoid network flooding\n-\t\t\t\tconst processImageChecks = async () => {\n-\t\t\t\t\tconsole.log(`Starting sequential URL processing for ${matches.length} URLs`)\n-\n-\t\t\t\t\tfor (let i = 0; i < matches.length; i++) {\n-\t\t\t\t\t\t// Skip already processed URLs (from extension check)\n-\t\t\t\t\t\tif (matches[i].isProcessed) continue\n-\n-\t\t\t\t\t\t// Check if processing has been canceled (switched to plain mode)\n-\t\t\t\t\t\tif (processingCanceled) {\n-\t\t\t\t\t\t\tconsole.log(\"URL processing canceled - display mode changed to plain\")\n-\t\t\t\t\t\t\treturn\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tconst match = matches[i]\n-\t\t\t\t\t\tconsole.log(`Processing URL ${i + 1} of ${matches.length}: ${match.url}`)\n-\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// Process each URL individually\n-\t\t\t\t\t\t\tconst isImage = await checkIfImageUrl(match.url)\n-\n-\t\t\t\t\t\t\t// Skip if processing has been canceled\n-\t\t\t\t\t\t\tif (processingCanceled) return\n-\n-\t\t\t\t\t\t\t// Update the match in place\n-\t\t\t\t\t\t\tmatch.isImage = isImage\n-\t\t\t\t\t\t\tmatch.isProcessed = true\n-\n-\t\t\t\t\t\t\t// Update state after each URL to show progress\n-\t\t\t\t\t\t\t// Create a new array to ensure React detects the state change\n-\t\t\t\t\t\t\tsetUrlMatches([...matches])\n-\t\t\t\t\t\t} catch (err) {\n-\t\t\t\t\t\t\tconsole.log(`URL check error: ${match.url}`, err)\n-\t\t\t\t\t\t\tmatch.isProcessed = true\n-\n-\t\t\t\t\t\t\t// Update state even on error\n-\t\t\t\t\t\t\tif (!processingCanceled) {\n-\t\t\t\t\t\t\t\tsetUrlMatches([...matches])\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t// Delay between URL processing to avoid overwhelming the network\n-\t\t\t\t\t\tif (!processingCanceled && i < matches.length - 1) {\n-\t\t\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100))\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tconsole.log(`URL processing complete. Found ${matches.filter((m) => m.isImage).length} image URLs`)\n-\t\t\t\t}\n-\n-\t\t\t\t// Start the background processing\n-\t\t\t\tprocessImageChecks()\n-\t\t\t} catch (error) {\n-\t\t\t\tsetError(\"Failed to process response content. Switch to plain text mode to view safely.\")\n+\t\t// Use the orchestrator function from mcpRichUtil\n+\t\tconst cleanup = processResponseUrls(\n+\t\t\tresponseText || \"\",\n+\t\t\tMAX_URLS,\n+\t\t\t(matches) => {\n+\t\t\t\tsetUrlMatches(matches)\n \t\t\t\tsetIsLoading(false)\n-\t\t\t}\n-\t\t}\n+\t\t\t},\n+\t\t\t(updatedMatches) => {\n+\t\t\t\tsetUrlMatches(updatedMatches)\n+\t\t\t},\n+\t\t\t(errorMessage) => {\n+\t\t\t\tsetError(errorMessage)\n+\t\t\t\tsetIsLoading(false)\n+\t\t\t},\n+\t\t)\n+\n+\t\treturn cleanup\n+\t}, [responseText, displayMode, isExpanded])\n+\n+\t// Helper function to render a display segment\n+\tconst renderSegment = (segment: DisplaySegment): JSX.Element => {",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2202862974",
        "repo_full_name": "cline/cline",
        "pr_number": 4852,
        "pr_file": "webview-ui/src/components/mcp/chat-display/McpResponseDisplay.tsx",
        "discussion_id": "2202862974",
        "commented_code": "@@ -151,126 +140,77 @@ const McpResponseDisplay: React.FC<McpResponseDisplayProps> = ({ responseText })\n \t\t\treturn\n \t\t}\n \n-\t\t// Use a direct boolean for cancellation that's scoped to this effect run\n-\t\tlet processingCanceled = false\n-\t\tconst processResponse = async () => {\n-\t\t\tconsole.log(\"Processing MCP response for URL extraction\")\n-\t\t\tsetIsLoading(true)\n-\t\t\tsetError(null)\n-\t\t\ttry {\n-\t\t\t\tconst text = responseText || \"\"\n-\t\t\t\tconst matches: UrlMatch[] = []\n-\t\t\t\tconst urlRegex = /(?:https?:\\/\\/|data:image)[^\\s<>\"']+/g\n-\t\t\t\tlet urlMatch: RegExpExecArray | null\n-\t\t\t\tlet urlCount = 0\n-\n-\t\t\t\t// First pass: Extract all URLs and immediately make them available for rendering\n-\t\t\t\twhile ((urlMatch = urlRegex.exec(text)) !== null && urlCount < MAX_URLS) {\n-\t\t\t\t\t// Get the original URL from the match - never modify the original URL text\n-\t\t\t\t\tconst url = urlMatch[0]\n-\n-\t\t\t\t\t// Skip invalid URLs\n-\t\t\t\t\tif (!isUrl(url)) {\n-\t\t\t\t\t\tconsole.log(\"Skipping invalid URL:\", url)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Skip localhost URLs to prevent security issues\n-\t\t\t\t\tif (isLocalhostUrl(url)) {\n-\t\t\t\t\t\tconsole.log(\"Skipping localhost URL:\", url)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tmatches.push({\n-\t\t\t\t\t\turl,\n-\t\t\t\t\t\tfullMatch: url,\n-\t\t\t\t\t\tindex: urlMatch.index,\n-\t\t\t\t\t\tisImage: false, // Will check later\n-\t\t\t\t\t\tisProcessed: false,\n-\t\t\t\t\t})\n-\n-\t\t\t\t\turlCount++\n-\t\t\t\t}\n-\n-\t\t\t\tconsole.log(`Found ${matches.length} URLs in text, will check if they are images`)\n-\n-\t\t\t\t// Set matches immediately so UI can start rendering with loading states\n-\t\t\t\tsetUrlMatches(matches.sort((a, b) => a.index - b.index))\n-\n-\t\t\t\t// Mark loading as complete to show content immediately\n-\t\t\t\tsetIsLoading(false)\n+\t\tconsole.log(\"Processing MCP response for URL extraction\")\n+\t\tsetIsLoading(true)\n+\t\tsetError(null)\n \n-\t\t\t\t// Process image checks in the background - one at a time to avoid network flooding\n-\t\t\t\tconst processImageChecks = async () => {\n-\t\t\t\t\tconsole.log(`Starting sequential URL processing for ${matches.length} URLs`)\n-\n-\t\t\t\t\tfor (let i = 0; i < matches.length; i++) {\n-\t\t\t\t\t\t// Skip already processed URLs (from extension check)\n-\t\t\t\t\t\tif (matches[i].isProcessed) continue\n-\n-\t\t\t\t\t\t// Check if processing has been canceled (switched to plain mode)\n-\t\t\t\t\t\tif (processingCanceled) {\n-\t\t\t\t\t\t\tconsole.log(\"URL processing canceled - display mode changed to plain\")\n-\t\t\t\t\t\t\treturn\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tconst match = matches[i]\n-\t\t\t\t\t\tconsole.log(`Processing URL ${i + 1} of ${matches.length}: ${match.url}`)\n-\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t// Process each URL individually\n-\t\t\t\t\t\t\tconst isImage = await checkIfImageUrl(match.url)\n-\n-\t\t\t\t\t\t\t// Skip if processing has been canceled\n-\t\t\t\t\t\t\tif (processingCanceled) return\n-\n-\t\t\t\t\t\t\t// Update the match in place\n-\t\t\t\t\t\t\tmatch.isImage = isImage\n-\t\t\t\t\t\t\tmatch.isProcessed = true\n-\n-\t\t\t\t\t\t\t// Update state after each URL to show progress\n-\t\t\t\t\t\t\t// Create a new array to ensure React detects the state change\n-\t\t\t\t\t\t\tsetUrlMatches([...matches])\n-\t\t\t\t\t\t} catch (err) {\n-\t\t\t\t\t\t\tconsole.log(`URL check error: ${match.url}`, err)\n-\t\t\t\t\t\t\tmatch.isProcessed = true\n-\n-\t\t\t\t\t\t\t// Update state even on error\n-\t\t\t\t\t\t\tif (!processingCanceled) {\n-\t\t\t\t\t\t\t\tsetUrlMatches([...matches])\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t// Delay between URL processing to avoid overwhelming the network\n-\t\t\t\t\t\tif (!processingCanceled && i < matches.length - 1) {\n-\t\t\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 100))\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tconsole.log(`URL processing complete. Found ${matches.filter((m) => m.isImage).length} image URLs`)\n-\t\t\t\t}\n-\n-\t\t\t\t// Start the background processing\n-\t\t\t\tprocessImageChecks()\n-\t\t\t} catch (error) {\n-\t\t\t\tsetError(\"Failed to process response content. Switch to plain text mode to view safely.\")\n+\t\t// Use the orchestrator function from mcpRichUtil\n+\t\tconst cleanup = processResponseUrls(\n+\t\t\tresponseText || \"\",\n+\t\t\tMAX_URLS,\n+\t\t\t(matches) => {\n+\t\t\t\tsetUrlMatches(matches)\n \t\t\t\tsetIsLoading(false)\n-\t\t\t}\n-\t\t}\n+\t\t\t},\n+\t\t\t(updatedMatches) => {\n+\t\t\t\tsetUrlMatches(updatedMatches)\n+\t\t\t},\n+\t\t\t(errorMessage) => {\n+\t\t\t\tsetError(errorMessage)\n+\t\t\t\tsetIsLoading(false)\n+\t\t\t},\n+\t\t)\n+\n+\t\treturn cleanup\n+\t}, [responseText, displayMode, isExpanded])\n+\n+\t// Helper function to render a display segment\n+\tconst renderSegment = (segment: DisplaySegment): JSX.Element => {",
        "comment_created_at": "2025-07-12T18:28:54+00:00",
        "comment_author": "abeatrix",
        "comment_body": "Should we memorize this & renderContent as they get recreation on every render? Something like\r\n\r\n```suggestion\r\n\tconst renderSegment = useCallback((segment: DisplaySegment): JSX.Element => {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175602851",
    "pr_number": 4554,
    "pr_file": "webview-ui/src/components/settings/common/ApiKeyField.tsx",
    "created_at": "2025-06-30T17:51:10+00:00",
    "commented_code": "* A reusable component for API key input fields with standard styling and help text for signing up for key\n  */\n export const ApiKeyField = ({\n-\tvalue,\n+\tinitialValue,\n \tonChange,\n \tproviderName,\n \tsignupUrl,\n \tplaceholder = \"Enter API Key...\",\n \thelpText,\n-}: ApiKeyFieldProps) => (\n-\t<div>\n-\t\t<VSCodeTextField value={value} style={{ width: \"100%\" }} type=\"password\" onInput={onChange} placeholder={placeholder}>\n-\t\t\t<span style={{ fontWeight: 500 }}>{providerName} API Key</span>\n-\t\t</VSCodeTextField>\n-\t\t<p\n-\t\t\tstyle={{\n-\t\t\t\tfontSize: \"12px\",\n-\t\t\t\tmarginTop: 3,\n-\t\t\t\tcolor: \"var(--vscode-descriptionForeground)\",\n-\t\t\t}}>\n-\t\t\t{helpText || \"This key is stored locally and only used to make API requests from this extension.\"}\n-\t\t\t{!value && signupUrl && (\n-\t\t\t\t<VSCodeLink\n-\t\t\t\t\thref={signupUrl}\n-\t\t\t\t\tstyle={{\n-\t\t\t\t\t\tdisplay: \"inline\",\n-\t\t\t\t\t\tfontSize: \"inherit\",\n-\t\t\t\t\t}}>\n-\t\t\t\t\tYou can get a{/^[aeiou]/i.test(providerName) ? \"n\" : \"\"} {providerName} API key by signing up here.\n-\t\t\t\t</VSCodeLink>\n-\t\t\t)}\n-\t\t</p>\n-\t</div>\n-)\n+}: ApiKeyFieldProps) => {\n+\tconst [localValue, setLocalValue] = useDebouncedInput(initialValue, onChange)\n+",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2175602851",
        "repo_full_name": "cline/cline",
        "pr_number": 4554,
        "pr_file": "webview-ui/src/components/settings/common/ApiKeyField.tsx",
        "discussion_id": "2175602851",
        "commented_code": "@@ -16,34 +17,43 @@ interface ApiKeyFieldProps {\n  * A reusable component for API key input fields with standard styling and help text for signing up for key\n  */\n export const ApiKeyField = ({\n-\tvalue,\n+\tinitialValue,\n \tonChange,\n \tproviderName,\n \tsignupUrl,\n \tplaceholder = \"Enter API Key...\",\n \thelpText,\n-}: ApiKeyFieldProps) => (\n-\t<div>\n-\t\t<VSCodeTextField value={value} style={{ width: \"100%\" }} type=\"password\" onInput={onChange} placeholder={placeholder}>\n-\t\t\t<span style={{ fontWeight: 500 }}>{providerName} API Key</span>\n-\t\t</VSCodeTextField>\n-\t\t<p\n-\t\t\tstyle={{\n-\t\t\t\tfontSize: \"12px\",\n-\t\t\t\tmarginTop: 3,\n-\t\t\t\tcolor: \"var(--vscode-descriptionForeground)\",\n-\t\t\t}}>\n-\t\t\t{helpText || \"This key is stored locally and only used to make API requests from this extension.\"}\n-\t\t\t{!value && signupUrl && (\n-\t\t\t\t<VSCodeLink\n-\t\t\t\t\thref={signupUrl}\n-\t\t\t\t\tstyle={{\n-\t\t\t\t\t\tdisplay: \"inline\",\n-\t\t\t\t\t\tfontSize: \"inherit\",\n-\t\t\t\t\t}}>\n-\t\t\t\t\tYou can get a{/^[aeiou]/i.test(providerName) ? \"n\" : \"\"} {providerName} API key by signing up here.\n-\t\t\t\t</VSCodeLink>\n-\t\t\t)}\n-\t\t</p>\n-\t</div>\n-)\n+}: ApiKeyFieldProps) => {\n+\tconst [localValue, setLocalValue] = useDebouncedInput(initialValue, onChange)\n+",
        "comment_created_at": "2025-06-30T17:51:10+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "Debouncing input with a controlled value (useState). Adding to ApiKeyField and BaseUrl field. Also seen in the new DebouncedTextField component.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2032037761",
    "pr_number": 2723,
    "pr_file": "webview-ui/src/components/chat/ServersToggleModal.tsx",
    "created_at": "2025-04-07T21:32:59+00:00",
    "commented_code": "+import React, { useRef, useState, useEffect } from \"react\"\n+import { useClickAway, useWindowSize } from \"react-use\"\n+import { useExtensionState } from \"@/context/ExtensionStateContext\"\n+import { CODE_BLOCK_BG_COLOR } from \"@/components/common/CodeBlock\"\n+import ServersToggleList from \"@/components/mcp/configuration/tabs/installed/ServersToggleList\"\n+import { vscode } from \"@/utils/vscode\"\n+import { VSCodeButton } from \"@vscode/webview-ui-toolkit/react\"\n+\n+const ServersToggleModal: React.FC = () => {\n+\tconst { mcpServers } = useExtensionState()\n+\tconst [isVisible, setIsVisible] = useState(false)\n+\tconst buttonRef = useRef<HTMLDivElement>(null)\n+\tconst modalRef = useRef<HTMLDivElement>(null)\n+\tconst { width: viewportWidth, height: viewportHeight } = useWindowSize()\n+\tconst [arrowPosition, setArrowPosition] = useState(0)\n+\tconst [menuPosition, setMenuPosition] = useState(0)\n+\n+\t// Close modal when clicking outside\n+\tuseClickAway(modalRef, () => {\n+\t\tsetIsVisible(false)\n+\t})\n+\n+\t// Calculate positions for modal and arrow\n+\tuseEffect(() => {\n+\t\tif (isVisible && buttonRef.current) {\n+\t\t\tconst buttonRect = buttonRef.current.getBoundingClientRect()\n+\t\t\tconst buttonCenter = buttonRect.left + buttonRect.width / 2\n+\t\t\tconst rightPosition = document.documentElement.clientWidth - buttonCenter - 5\n+\n+\t\t\tsetArrowPosition(rightPosition)\n+\t\t\tsetMenuPosition(buttonRect.top + 1)\n+\n+\t\t\tvscode.postMessage({ type: \"fetchLatestMcpServersFromHub\" })",
    "repo_full_name": "cline/cline",
    "discussion_comments": [
      {
        "comment_id": "2032037761",
        "repo_full_name": "cline/cline",
        "pr_number": 2723,
        "pr_file": "webview-ui/src/components/chat/ServersToggleModal.tsx",
        "discussion_id": "2032037761",
        "commented_code": "@@ -0,0 +1,77 @@\n+import React, { useRef, useState, useEffect } from \"react\"\n+import { useClickAway, useWindowSize } from \"react-use\"\n+import { useExtensionState } from \"@/context/ExtensionStateContext\"\n+import { CODE_BLOCK_BG_COLOR } from \"@/components/common/CodeBlock\"\n+import ServersToggleList from \"@/components/mcp/configuration/tabs/installed/ServersToggleList\"\n+import { vscode } from \"@/utils/vscode\"\n+import { VSCodeButton } from \"@vscode/webview-ui-toolkit/react\"\n+\n+const ServersToggleModal: React.FC = () => {\n+\tconst { mcpServers } = useExtensionState()\n+\tconst [isVisible, setIsVisible] = useState(false)\n+\tconst buttonRef = useRef<HTMLDivElement>(null)\n+\tconst modalRef = useRef<HTMLDivElement>(null)\n+\tconst { width: viewportWidth, height: viewportHeight } = useWindowSize()\n+\tconst [arrowPosition, setArrowPosition] = useState(0)\n+\tconst [menuPosition, setMenuPosition] = useState(0)\n+\n+\t// Close modal when clicking outside\n+\tuseClickAway(modalRef, () => {\n+\t\tsetIsVisible(false)\n+\t})\n+\n+\t// Calculate positions for modal and arrow\n+\tuseEffect(() => {\n+\t\tif (isVisible && buttonRef.current) {\n+\t\t\tconst buttonRect = buttonRef.current.getBoundingClientRect()\n+\t\t\tconst buttonCenter = buttonRect.left + buttonRect.width / 2\n+\t\t\tconst rightPosition = document.documentElement.clientWidth - buttonCenter - 5\n+\n+\t\t\tsetArrowPosition(rightPosition)\n+\t\t\tsetMenuPosition(buttonRect.top + 1)\n+\n+\t\t\tvscode.postMessage({ type: \"fetchLatestMcpServersFromHub\" })",
        "comment_created_at": "2025-04-07T21:32:59+00:00",
        "comment_author": "saito-sv",
        "comment_body": "Do we always want to post this message to fetch the latestMCPServer? \r\nIt seems to me that we are posting a message each time the dimension changes, which could result in an unnecessary overhead. Consider separating the post of the message only when we really need it.\r\n\r\n```typescript\r\n// Separate effect for data fetching\r\nuseEffect(() => {\r\n  if (isVisible) {\r\n    vscode.postMessage({ type: \"fetchLatestMcpServersFromHub\" })\r\n  }\r\n}, [isVisible])\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2032140210",
        "repo_full_name": "cline/cline",
        "pr_number": 2723,
        "pr_file": "webview-ui/src/components/chat/ServersToggleModal.tsx",
        "discussion_id": "2032037761",
        "commented_code": "@@ -0,0 +1,77 @@\n+import React, { useRef, useState, useEffect } from \"react\"\n+import { useClickAway, useWindowSize } from \"react-use\"\n+import { useExtensionState } from \"@/context/ExtensionStateContext\"\n+import { CODE_BLOCK_BG_COLOR } from \"@/components/common/CodeBlock\"\n+import ServersToggleList from \"@/components/mcp/configuration/tabs/installed/ServersToggleList\"\n+import { vscode } from \"@/utils/vscode\"\n+import { VSCodeButton } from \"@vscode/webview-ui-toolkit/react\"\n+\n+const ServersToggleModal: React.FC = () => {\n+\tconst { mcpServers } = useExtensionState()\n+\tconst [isVisible, setIsVisible] = useState(false)\n+\tconst buttonRef = useRef<HTMLDivElement>(null)\n+\tconst modalRef = useRef<HTMLDivElement>(null)\n+\tconst { width: viewportWidth, height: viewportHeight } = useWindowSize()\n+\tconst [arrowPosition, setArrowPosition] = useState(0)\n+\tconst [menuPosition, setMenuPosition] = useState(0)\n+\n+\t// Close modal when clicking outside\n+\tuseClickAway(modalRef, () => {\n+\t\tsetIsVisible(false)\n+\t})\n+\n+\t// Calculate positions for modal and arrow\n+\tuseEffect(() => {\n+\t\tif (isVisible && buttonRef.current) {\n+\t\t\tconst buttonRect = buttonRef.current.getBoundingClientRect()\n+\t\t\tconst buttonCenter = buttonRect.left + buttonRect.width / 2\n+\t\t\tconst rightPosition = document.documentElement.clientWidth - buttonCenter - 5\n+\n+\t\t\tsetArrowPosition(rightPosition)\n+\t\t\tsetMenuPosition(buttonRect.top + 1)\n+\n+\t\t\tvscode.postMessage({ type: \"fetchLatestMcpServersFromHub\" })",
        "comment_created_at": "2025-04-07T23:23:51+00:00",
        "comment_author": "celestial-vault",
        "comment_body": "Fair point",
        "pr_file_module": null
      }
    ]
  }
]