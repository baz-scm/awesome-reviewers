[
  {
    "discussion_id": "2051351566",
    "pr_number": 383,
    "pr_file": "codex-cli/scripts/run_in_container.sh",
    "created_at": "2025-04-19T02:23:10+00:00",
    "commented_code": "set -e\n \n # Usage:\n-#   ./run_in_container.sh [--work_dir directory] \"COMMAND\"\n+#   ./run_in_container.sh [--allow-outbound] [--work_dir directory] \"COMMAND\"\n #\n #   Examples:\n #     ./run_in_container.sh --work_dir project/code \"ls -la\"\n #     ./run_in_container.sh \"echo Hello, world!\"\n \n # Default the work directory to WORKSPACE_ROOT_DIR if not provided.\n WORK_DIR=\"${WORKSPACE_ROOT_DIR:-$(pwd)}\"\n+# By default, do not disable outbound firewall\n+ALLOW_OUTBOUND=false\n \n-# Parse optional flag.\n-if [ \"$1\" = \"--work_dir\" ]; then\n-  if [ -z \"$2\" ]; then\n-    echo \"Error: --work_dir flag provided but no directory specified.\"\n-    exit 1\n-  fi\n-  WORK_DIR=\"$2\"\n-  shift 2\n-fi\n+# Parse optional flags: --allow-outbound and --work_dir\n+while [ \"$#\" -gt 0 ]; do\n+  case \"$1\" in\n+    --allow-outbound)",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2051351566",
        "repo_full_name": "openai/codex",
        "pr_number": 383,
        "pr_file": "codex-cli/scripts/run_in_container.sh",
        "discussion_id": "2051351566",
        "commented_code": "@@ -2,24 +2,37 @@\n set -e\n \n # Usage:\n-#   ./run_in_container.sh [--work_dir directory] \"COMMAND\"\n+#   ./run_in_container.sh [--allow-outbound] [--work_dir directory] \"COMMAND\"\n #\n #   Examples:\n #     ./run_in_container.sh --work_dir project/code \"ls -la\"\n #     ./run_in_container.sh \"echo Hello, world!\"\n \n # Default the work directory to WORKSPACE_ROOT_DIR if not provided.\n WORK_DIR=\"${WORKSPACE_ROOT_DIR:-$(pwd)}\"\n+# By default, do not disable outbound firewall\n+ALLOW_OUTBOUND=false\n \n-# Parse optional flag.\n-if [ \"$1\" = \"--work_dir\" ]; then\n-  if [ -z \"$2\" ]; then\n-    echo \"Error: --work_dir flag provided but no directory specified.\"\n-    exit 1\n-  fi\n-  WORK_DIR=\"$2\"\n-  shift 2\n-fi\n+# Parse optional flags: --allow-outbound and --work_dir\n+while [ \"$#\" -gt 0 ]; do\n+  case \"$1\" in\n+    --allow-outbound)",
        "comment_created_at": "2025-04-19T02:23:10+00:00",
        "comment_author": "fouad-openai",
        "comment_body": "```suggestion\r\n# Parse optional flags: --dangerously-allow-network-outbound and --work_dir\r\nwhile [ \"$#\" -gt 0 ]; do\r\n  case \"$1\" in\r\n    --dangerously-allow-network-outbound)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2087644630",
    "pr_number": 783,
    "pr_file": "codex-cli/scripts/run_in_container.sh",
    "created_at": "2025-05-13T21:14:46+00:00",
    "commented_code": "for arg in \"$@\"; do\n   quoted_args+=\" $(printf '%q' \"$arg\")\"\n done\n-docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex --full-auto ${quoted_args}\"\n+docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex ${quoted_args}\"",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2087644630",
        "repo_full_name": "openai/codex",
        "pr_number": 783,
        "pr_file": "codex-cli/scripts/run_in_container.sh",
        "discussion_id": "2087644630",
        "commented_code": "@@ -92,4 +92,4 @@ quoted_args=\"\"\n for arg in \"$@\"; do\n   quoted_args+=\" $(printf '%q' \"$arg\")\"\n done\n-docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex --full-auto ${quoted_args}\"\n+docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex ${quoted_args}\"",
        "comment_created_at": "2025-05-13T21:14:46+00:00",
        "comment_author": "bolinfest",
        "comment_body": "I was thinking of going in the other direction where we would replace `--full-auto` with `--dangerously-auto-approve-everything` since the Docker container *is* the sandbox. Is your motivation to add a weaker approval mode or a stronger one?\r\n\r\nI guess from your screenshot you want to run it with `--suggest`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2087766959",
        "repo_full_name": "openai/codex",
        "pr_number": 783,
        "pr_file": "codex-cli/scripts/run_in_container.sh",
        "discussion_id": "2087644630",
        "commented_code": "@@ -92,4 +92,4 @@ quoted_args=\"\"\n for arg in \"$@\"; do\n   quoted_args+=\" $(printf '%q' \"$arg\")\"\n done\n-docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex --full-auto ${quoted_args}\"\n+docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex ${quoted_args}\"",
        "comment_created_at": "2025-05-13T23:27:58+00:00",
        "comment_author": "braun-viathan",
        "comment_body": "My goal wasn’t to weaken or strengthen the default-approval policy, but to make `run_in_container.sh` **flag-agnostic** so Linux users can supply *any* `--approval-mode` (e.g., `suggest` or even your proposed `--dangerously-auto-approve-everything`).\r\nThe hard-coded `--full-auto` prevented that. \r\nThis PR therefore just removes the fixed flag (no other behaviour change).\r\n\r\nAlso commands with the *linux sandbox* got really long in daily use. \r\nMy follow-up PR (#876) mounts `~/.codex`, letting users persist their own config/instruction presets—together these two patches give people more parity with the macOS workflow while still defaulting to Codex’s existing approval mode.\r\n\r\nMaking the Linux sandbox more user friendly was my initial goal. \r\nThis PR is the first step. trying to keep changes small and easy to review. \r\n\r\nHappy to adjust if you’d prefer a different default. Let me know what you think!",
        "pr_file_module": null
      },
      {
        "comment_id": "2093354416",
        "repo_full_name": "openai/codex",
        "pr_number": 783,
        "pr_file": "codex-cli/scripts/run_in_container.sh",
        "discussion_id": "2087644630",
        "commented_code": "@@ -92,4 +92,4 @@ quoted_args=\"\"\n for arg in \"$@\"; do\n   quoted_args+=\" $(printf '%q' \"$arg\")\"\n done\n-docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex --full-auto ${quoted_args}\"\n+docker exec -it \"$CONTAINER_NAME\" bash -c \"cd \\\"/app$WORK_DIR\\\" && codex ${quoted_args}\"",
        "comment_created_at": "2025-05-16T16:30:08+00:00",
        "comment_author": "braun-viathan",
        "comment_body": "updated and tested both PR's. \r\n \r\nAny thoughts ? - #876 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2076643894",
    "pr_number": 844,
    "pr_file": "codex-cli/scripts/stage_release.sh",
    "created_at": "2025-05-07T02:02:07+00:00",
    "commented_code": "-#!/bin/bash\n+#!/usr/bin/env bash\n+# -----------------------------------------------------------------------------\n+# stage_release.sh\n+# -----------------------------------------------------------------------------\n+# Stages an npm release for @openai/codex.\n+#\n+# The script used to accept a single optional positional argument that indicated\n+# the temporary directory in which to stage the package.  We now support a\n+# flag-based interface so that we can extend the command with further options\n+# without breaking the call-site contract.\n+#\n+#   --tmp <dir>  : Use <dir> instead of a freshly created temp directory.\n+#   --native     : Bundle the pre-built Rust CLI binaries for Linux alongside\n+#                  the JavaScript implementation (a so-called \"fat\" package).\n+#   -h|--help    : Print usage.\n+#\n+# When --native is supplied we copy the linux-sandbox binaries (as before) and\n+# additionally fetch / unpack the two Rust targets that we currently support:\n+#   - x86_64-unknown-linux-musl\n+#   - aarch64-unknown-linux-gnu\n+#\n+# NOTE: This script is intended to be run from the repository root via\n+#       `pnpm --filter codex-cli stage-release ...` or inside codex-cli with the\n+#       helper script entry in package.json (`pnpm stage-release ...`).\n+# -----------------------------------------------------------------------------\n \n set -euo pipefail\n \n-# Change to the codex-cli directory.\n-cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\"\n+# Helper - usage / flag parsing\n \n-# First argument is where to stage the release. Creates a temporary directory\n-# if not provided.\n-RELEASE_DIR=\"${1:-$(mktemp -d)}\"\n-[ -n \"${1-}\" ] && shift\n+usage() {\n+  cat <<EOF\n+Usage: $(basename \"$0\") [--tmp DIR] [--native]\n+\n+Options\n+  --tmp DIR   Use DIR to stage the release (defaults to a fresh mktemp dir)\n+  --native    Bundle Rust binaries for Linux (fat package)\n+  -h, --help  Show this help\n+\n+Legacy positional argument: the first non-flag argument is still interpreted\n+as the temporary directory (for backwards compatibility) but is deprecated.\n+EOF\n+  exit \"${1:-0}\"\n+}\n+\n+TMPDIR=\"\"\n+INCLUDE_NATIVE=0\n+\n+# Manual flag parser - Bash getopts does not handle GNU long options well.\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --tmp)\n+      shift || { echo \"--tmp requires an argument\"; usage 1; }\n+      TMPDIR=\"$1\"\n+      ;;\n+    --tmp=*)\n+      TMPDIR=\"${1#*=}\"\n+      ;;\n+    --native)\n+      INCLUDE_NATIVE=1\n+      ;;\n+    -h|--help)\n+      usage 0\n+      ;;\n+    --*)\n+      echo \"Unknown option: $1\" >&2\n+      usage 1\n+      ;;\n+    *)\n+      echo \"Unexpected extra argument: $1\" >&2\n+      usage 1\n+      ;;\n+  esac\n+  shift\n+done\n+\n+# Fallback when the caller did not specify a directory.\n+# If no directory was specified create a fresh temporary one.\n+if [[ -z \"$TMPDIR\" ]]; then\n+  TMPDIR=\"$(mktemp -d)\"\n+fi\n+\n+# Ensure the directory exists, then resolve to an absolute path.\n+mkdir -p \"$TMPDIR\"\n+TMPDIR=\"$(cd \"$TMPDIR\" && pwd)\"\n+\n+# Main build logic\n+\n+echo \"Staging release in $TMPDIR\"\n+\n+# The script lives in codex-cli/scripts/ - change into codex-cli root so that\n+# relative paths keep working.\n+SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n+CODEX_CLI_ROOT=\"$(cd \"$SCRIPT_DIR/..\" && pwd)\"\n+\n+pushd \"$CODEX_CLI_ROOT\" >/dev/null\n+\n+# 1. Build the JS artifacts ---------------------------------------------------\n \n-# Compile the JavaScript.\n pnpm install\n pnpm build\n-mkdir \"$RELEASE_DIR/bin\"\n-cp -r bin/codex.js \"$RELEASE_DIR/bin/codex.js\"\n-cp -r dist \"$RELEASE_DIR/dist\"\n-cp -r src \"$RELEASE_DIR/src\" # important if we want sourcemaps to continue to work\n-cp ../README.md \"$RELEASE_DIR\"\n-# TODO: Derive version from Git tag.\n-VERSION=$(printf '0.1.%d' \"$(date +%y%m%d%H%M)\")\n-jq --arg version \"$VERSION\" '.version = $version' package.json > \"$RELEASE_DIR/package.json\"\n-\n-# Copy the native dependencies.\n-./scripts/install_native_deps.sh \"$RELEASE_DIR\"\n-\n-echo \"Staged version $VERSION for release in $RELEASE_DIR\"\n+\n+# Paths inside the staged package\n+mkdir -p \"$TMPDIR/bin\"\n+\n+cp -r bin/codex.js \"$TMPDIR/bin/codex.js\"\n+cp -r dist \"$TMPDIR/dist\"\n+cp -r src \"$TMPDIR/src\" # keep source for TS sourcemaps\n+cp ../README.md \"$TMPDIR\" || true # README is one level up - ignore if missing\n+\n+# Derive a timestamp-based version (keep same scheme as before)\n+VERSION=\"$(printf '0.1.%d' \"$(date +%y%m%d%H%M)\")\"\n+\n+# Modify package.json - bump version and optionally add the native directory to\n+# the files array so that the binaries are published to npm.\n+\n+jq --arg version \"$VERSION\" \\\n+    '.version = $version' \\\n+    package.json > \"$TMPDIR/package.json\"\n+\n+# 2. Native runtime deps (sandbox plus optional Rust binaries)\n+\n+if [[ \"$INCLUDE_NATIVE\" -eq 1 ]]; then\n+  ./scripts/install_native_deps.sh \"$TMPDIR\" --full-native\n+else\n+  ./scripts/install_native_deps.sh \"$TMPDIR\"\n+fi\n+\n+popd >/dev/null\n+\n+echo \"Staged version $VERSION for release in $TMPDIR\"\n+\n+echo \"Test Node:\"\n+echo \"    node ${TMPDIR}/bin/codex.js --help\"\n+if [[ \"$INCLUDE_NATIVE\" -eq 1 ]]; then\n+  echo \"Test Rust:\"\n+  echo \"    CODEX_RUST=1 node ${TMPDIR}/bin/codex.js --help\"\n+fi\n+\n+# Print final hint for convenience\n+echo \"Next:  cd \\\"$TMPDIR\\\" && npm publish\"",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2076643894",
        "repo_full_name": "openai/codex",
        "pr_number": 844,
        "pr_file": "codex-cli/scripts/stage_release.sh",
        "discussion_id": "2076643894",
        "commented_code": "@@ -1,28 +1,141 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n+# -----------------------------------------------------------------------------\n+# stage_release.sh\n+# -----------------------------------------------------------------------------\n+# Stages an npm release for @openai/codex.\n+#\n+# The script used to accept a single optional positional argument that indicated\n+# the temporary directory in which to stage the package.  We now support a\n+# flag-based interface so that we can extend the command with further options\n+# without breaking the call-site contract.\n+#\n+#   --tmp <dir>  : Use <dir> instead of a freshly created temp directory.\n+#   --native     : Bundle the pre-built Rust CLI binaries for Linux alongside\n+#                  the JavaScript implementation (a so-called \"fat\" package).\n+#   -h|--help    : Print usage.\n+#\n+# When --native is supplied we copy the linux-sandbox binaries (as before) and\n+# additionally fetch / unpack the two Rust targets that we currently support:\n+#   - x86_64-unknown-linux-musl\n+#   - aarch64-unknown-linux-gnu\n+#\n+# NOTE: This script is intended to be run from the repository root via\n+#       `pnpm --filter codex-cli stage-release ...` or inside codex-cli with the\n+#       helper script entry in package.json (`pnpm stage-release ...`).\n+# -----------------------------------------------------------------------------\n \n set -euo pipefail\n \n-# Change to the codex-cli directory.\n-cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\"\n+# Helper - usage / flag parsing\n \n-# First argument is where to stage the release. Creates a temporary directory\n-# if not provided.\n-RELEASE_DIR=\"${1:-$(mktemp -d)}\"\n-[ -n \"${1-}\" ] && shift\n+usage() {\n+  cat <<EOF\n+Usage: $(basename \"$0\") [--tmp DIR] [--native]\n+\n+Options\n+  --tmp DIR   Use DIR to stage the release (defaults to a fresh mktemp dir)\n+  --native    Bundle Rust binaries for Linux (fat package)\n+  -h, --help  Show this help\n+\n+Legacy positional argument: the first non-flag argument is still interpreted\n+as the temporary directory (for backwards compatibility) but is deprecated.\n+EOF\n+  exit \"${1:-0}\"\n+}\n+\n+TMPDIR=\"\"\n+INCLUDE_NATIVE=0\n+\n+# Manual flag parser - Bash getopts does not handle GNU long options well.\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --tmp)\n+      shift || { echo \"--tmp requires an argument\"; usage 1; }\n+      TMPDIR=\"$1\"\n+      ;;\n+    --tmp=*)\n+      TMPDIR=\"${1#*=}\"\n+      ;;\n+    --native)\n+      INCLUDE_NATIVE=1\n+      ;;\n+    -h|--help)\n+      usage 0\n+      ;;\n+    --*)\n+      echo \"Unknown option: $1\" >&2\n+      usage 1\n+      ;;\n+    *)\n+      echo \"Unexpected extra argument: $1\" >&2\n+      usage 1\n+      ;;\n+  esac\n+  shift\n+done\n+\n+# Fallback when the caller did not specify a directory.\n+# If no directory was specified create a fresh temporary one.\n+if [[ -z \"$TMPDIR\" ]]; then\n+  TMPDIR=\"$(mktemp -d)\"\n+fi\n+\n+# Ensure the directory exists, then resolve to an absolute path.\n+mkdir -p \"$TMPDIR\"\n+TMPDIR=\"$(cd \"$TMPDIR\" && pwd)\"\n+\n+# Main build logic\n+\n+echo \"Staging release in $TMPDIR\"\n+\n+# The script lives in codex-cli/scripts/ - change into codex-cli root so that\n+# relative paths keep working.\n+SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n+CODEX_CLI_ROOT=\"$(cd \"$SCRIPT_DIR/..\" && pwd)\"\n+\n+pushd \"$CODEX_CLI_ROOT\" >/dev/null\n+\n+# 1. Build the JS artifacts ---------------------------------------------------\n \n-# Compile the JavaScript.\n pnpm install\n pnpm build\n-mkdir \"$RELEASE_DIR/bin\"\n-cp -r bin/codex.js \"$RELEASE_DIR/bin/codex.js\"\n-cp -r dist \"$RELEASE_DIR/dist\"\n-cp -r src \"$RELEASE_DIR/src\" # important if we want sourcemaps to continue to work\n-cp ../README.md \"$RELEASE_DIR\"\n-# TODO: Derive version from Git tag.\n-VERSION=$(printf '0.1.%d' \"$(date +%y%m%d%H%M)\")\n-jq --arg version \"$VERSION\" '.version = $version' package.json > \"$RELEASE_DIR/package.json\"\n-\n-# Copy the native dependencies.\n-./scripts/install_native_deps.sh \"$RELEASE_DIR\"\n-\n-echo \"Staged version $VERSION for release in $RELEASE_DIR\"\n+\n+# Paths inside the staged package\n+mkdir -p \"$TMPDIR/bin\"\n+\n+cp -r bin/codex.js \"$TMPDIR/bin/codex.js\"\n+cp -r dist \"$TMPDIR/dist\"\n+cp -r src \"$TMPDIR/src\" # keep source for TS sourcemaps\n+cp ../README.md \"$TMPDIR\" || true # README is one level up - ignore if missing\n+\n+# Derive a timestamp-based version (keep same scheme as before)\n+VERSION=\"$(printf '0.1.%d' \"$(date +%y%m%d%H%M)\")\"\n+\n+# Modify package.json - bump version and optionally add the native directory to\n+# the files array so that the binaries are published to npm.\n+\n+jq --arg version \"$VERSION\" \\\n+    '.version = $version' \\\n+    package.json > \"$TMPDIR/package.json\"\n+\n+# 2. Native runtime deps (sandbox plus optional Rust binaries)\n+\n+if [[ \"$INCLUDE_NATIVE\" -eq 1 ]]; then\n+  ./scripts/install_native_deps.sh \"$TMPDIR\" --full-native\n+else\n+  ./scripts/install_native_deps.sh \"$TMPDIR\"\n+fi\n+\n+popd >/dev/null\n+\n+echo \"Staged version $VERSION for release in $TMPDIR\"\n+\n+echo \"Test Node:\"\n+echo \"    node ${TMPDIR}/bin/codex.js --help\"\n+if [[ \"$INCLUDE_NATIVE\" -eq 1 ]]; then\n+  echo \"Test Rust:\"\n+  echo \"    CODEX_RUST=1 node ${TMPDIR}/bin/codex.js --help\"\n+fi\n+\n+# Print final hint for convenience\n+echo \"Next:  cd \\\"$TMPDIR\\\" && npm publish\"",
        "comment_created_at": "2025-05-07T02:02:07+00:00",
        "comment_author": "bolinfest",
        "comment_body": "@fouad-openai do you want this to print something else if `--native` was passed to indicate publishing to a different tag?",
        "pr_file_module": null
      },
      {
        "comment_id": "2083280917",
        "repo_full_name": "openai/codex",
        "pr_number": 844,
        "pr_file": "codex-cli/scripts/stage_release.sh",
        "discussion_id": "2076643894",
        "commented_code": "@@ -1,28 +1,141 @@\n-#!/bin/bash\n+#!/usr/bin/env bash\n+# -----------------------------------------------------------------------------\n+# stage_release.sh\n+# -----------------------------------------------------------------------------\n+# Stages an npm release for @openai/codex.\n+#\n+# The script used to accept a single optional positional argument that indicated\n+# the temporary directory in which to stage the package.  We now support a\n+# flag-based interface so that we can extend the command with further options\n+# without breaking the call-site contract.\n+#\n+#   --tmp <dir>  : Use <dir> instead of a freshly created temp directory.\n+#   --native     : Bundle the pre-built Rust CLI binaries for Linux alongside\n+#                  the JavaScript implementation (a so-called \"fat\" package).\n+#   -h|--help    : Print usage.\n+#\n+# When --native is supplied we copy the linux-sandbox binaries (as before) and\n+# additionally fetch / unpack the two Rust targets that we currently support:\n+#   - x86_64-unknown-linux-musl\n+#   - aarch64-unknown-linux-gnu\n+#\n+# NOTE: This script is intended to be run from the repository root via\n+#       `pnpm --filter codex-cli stage-release ...` or inside codex-cli with the\n+#       helper script entry in package.json (`pnpm stage-release ...`).\n+# -----------------------------------------------------------------------------\n \n set -euo pipefail\n \n-# Change to the codex-cli directory.\n-cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\"\n+# Helper - usage / flag parsing\n \n-# First argument is where to stage the release. Creates a temporary directory\n-# if not provided.\n-RELEASE_DIR=\"${1:-$(mktemp -d)}\"\n-[ -n \"${1-}\" ] && shift\n+usage() {\n+  cat <<EOF\n+Usage: $(basename \"$0\") [--tmp DIR] [--native]\n+\n+Options\n+  --tmp DIR   Use DIR to stage the release (defaults to a fresh mktemp dir)\n+  --native    Bundle Rust binaries for Linux (fat package)\n+  -h, --help  Show this help\n+\n+Legacy positional argument: the first non-flag argument is still interpreted\n+as the temporary directory (for backwards compatibility) but is deprecated.\n+EOF\n+  exit \"${1:-0}\"\n+}\n+\n+TMPDIR=\"\"\n+INCLUDE_NATIVE=0\n+\n+# Manual flag parser - Bash getopts does not handle GNU long options well.\n+while [[ $# -gt 0 ]]; do\n+  case \"$1\" in\n+    --tmp)\n+      shift || { echo \"--tmp requires an argument\"; usage 1; }\n+      TMPDIR=\"$1\"\n+      ;;\n+    --tmp=*)\n+      TMPDIR=\"${1#*=}\"\n+      ;;\n+    --native)\n+      INCLUDE_NATIVE=1\n+      ;;\n+    -h|--help)\n+      usage 0\n+      ;;\n+    --*)\n+      echo \"Unknown option: $1\" >&2\n+      usage 1\n+      ;;\n+    *)\n+      echo \"Unexpected extra argument: $1\" >&2\n+      usage 1\n+      ;;\n+  esac\n+  shift\n+done\n+\n+# Fallback when the caller did not specify a directory.\n+# If no directory was specified create a fresh temporary one.\n+if [[ -z \"$TMPDIR\" ]]; then\n+  TMPDIR=\"$(mktemp -d)\"\n+fi\n+\n+# Ensure the directory exists, then resolve to an absolute path.\n+mkdir -p \"$TMPDIR\"\n+TMPDIR=\"$(cd \"$TMPDIR\" && pwd)\"\n+\n+# Main build logic\n+\n+echo \"Staging release in $TMPDIR\"\n+\n+# The script lives in codex-cli/scripts/ - change into codex-cli root so that\n+# relative paths keep working.\n+SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\n+CODEX_CLI_ROOT=\"$(cd \"$SCRIPT_DIR/..\" && pwd)\"\n+\n+pushd \"$CODEX_CLI_ROOT\" >/dev/null\n+\n+# 1. Build the JS artifacts ---------------------------------------------------\n \n-# Compile the JavaScript.\n pnpm install\n pnpm build\n-mkdir \"$RELEASE_DIR/bin\"\n-cp -r bin/codex.js \"$RELEASE_DIR/bin/codex.js\"\n-cp -r dist \"$RELEASE_DIR/dist\"\n-cp -r src \"$RELEASE_DIR/src\" # important if we want sourcemaps to continue to work\n-cp ../README.md \"$RELEASE_DIR\"\n-# TODO: Derive version from Git tag.\n-VERSION=$(printf '0.1.%d' \"$(date +%y%m%d%H%M)\")\n-jq --arg version \"$VERSION\" '.version = $version' package.json > \"$RELEASE_DIR/package.json\"\n-\n-# Copy the native dependencies.\n-./scripts/install_native_deps.sh \"$RELEASE_DIR\"\n-\n-echo \"Staged version $VERSION for release in $RELEASE_DIR\"\n+\n+# Paths inside the staged package\n+mkdir -p \"$TMPDIR/bin\"\n+\n+cp -r bin/codex.js \"$TMPDIR/bin/codex.js\"\n+cp -r dist \"$TMPDIR/dist\"\n+cp -r src \"$TMPDIR/src\" # keep source for TS sourcemaps\n+cp ../README.md \"$TMPDIR\" || true # README is one level up - ignore if missing\n+\n+# Derive a timestamp-based version (keep same scheme as before)\n+VERSION=\"$(printf '0.1.%d' \"$(date +%y%m%d%H%M)\")\"\n+\n+# Modify package.json - bump version and optionally add the native directory to\n+# the files array so that the binaries are published to npm.\n+\n+jq --arg version \"$VERSION\" \\\n+    '.version = $version' \\\n+    package.json > \"$TMPDIR/package.json\"\n+\n+# 2. Native runtime deps (sandbox plus optional Rust binaries)\n+\n+if [[ \"$INCLUDE_NATIVE\" -eq 1 ]]; then\n+  ./scripts/install_native_deps.sh \"$TMPDIR\" --full-native\n+else\n+  ./scripts/install_native_deps.sh \"$TMPDIR\"\n+fi\n+\n+popd >/dev/null\n+\n+echo \"Staged version $VERSION for release in $TMPDIR\"\n+\n+echo \"Test Node:\"\n+echo \"    node ${TMPDIR}/bin/codex.js --help\"\n+if [[ \"$INCLUDE_NATIVE\" -eq 1 ]]; then\n+  echo \"Test Rust:\"\n+  echo \"    CODEX_RUST=1 node ${TMPDIR}/bin/codex.js --help\"\n+fi\n+\n+# Print final hint for convenience\n+echo \"Next:  cd \\\"$TMPDIR\\\" && npm publish\"",
        "comment_created_at": "2025-05-10T20:07:48+00:00",
        "comment_author": "fouad-openai",
        "comment_body": "yeah maybe we should include a `--tag` for npm publish like `--tag native` or thinking something else?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2059033292",
    "pr_number": 414,
    "pr_file": "codex-cli/scripts/run_in_container.sh",
    "created_at": "2025-04-24T18:39:26+00:00",
    "commented_code": "# Run the container with the specified directory mounted at the same path inside the container.\n docker run --name \"$CONTAINER_NAME\" -d \\\n   -e OPENAI_API_KEY \\\n+  -e ALLOWED_DOMAINS=\"$ALLOWED_DOMAINS\" \\",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2059033292",
        "repo_full_name": "openai/codex",
        "pr_number": 414,
        "pr_file": "codex-cli/scripts/run_in_container.sh",
        "discussion_id": "2059033292",
        "commented_code": "@@ -51,14 +68,21 @@ cleanup\n # Run the container with the specified directory mounted at the same path inside the container.\n docker run --name \"$CONTAINER_NAME\" -d \\\n   -e OPENAI_API_KEY \\\n+  -e ALLOWED_DOMAINS=\"$ALLOWED_DOMAINS\" \\",
        "comment_created_at": "2025-04-24T18:39:26+00:00",
        "comment_author": "bolinfest",
        "comment_body": "I believe it is possible for `ALLOWED_DOMAINS` to be the empty string if this script were run with `ALLOWED_DOMAINS=` (explicitly defining the `ALLOWED_DOMAINS` env var as the empty string), so out of an abundance of caution, maybe we should do this before `docker run`:\r\n\r\n```\r\nif [ -z \"$ALLOWED_DOMAINS\" ]; then\r\n  echo \"Error: ALLOWED_DOMAINS is empty.\"\r\n  exit 1\r\nfi\r\n```\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]