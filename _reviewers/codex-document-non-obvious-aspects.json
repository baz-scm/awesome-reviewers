[
  {
    "discussion_id": "2217587164",
    "pr_number": 1629,
    "pr_file": "codex-rs/mcp-server/src/codex_tool_runner.rs",
    "created_at": "2025-07-20T06:01:40+00:00",
    "commented_code": "});\n                         }\n \n-                        break;\n+                        // Continue, don't break so the session continues.",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2217587164",
        "repo_full_name": "openai/codex",
        "pr_number": 1629,
        "pr_file": "codex-rs/mcp-server/src/codex_tool_runner.rs",
        "discussion_id": "2217587164",
        "commented_code": "@@ -131,7 +131,8 @@ pub async fn run_codex_tool_session(\n                             });\n                         }\n \n-                        break;\n+                        // Continue, don't break so the session continues.",
        "comment_created_at": "2025-07-20T06:01:40+00:00",
        "comment_author": "bolinfest",
        "comment_body": "Should we keep this comment?",
        "pr_file_module": null
      },
      {
        "comment_id": "2217896246",
        "repo_full_name": "openai/codex",
        "pr_number": 1629,
        "pr_file": "codex-rs/mcp-server/src/codex_tool_runner.rs",
        "discussion_id": "2217587164",
        "commented_code": "@@ -131,7 +131,8 @@ pub async fn run_codex_tool_session(\n                             });\n                         }\n \n-                        break;\n+                        // Continue, don't break so the session continues.",
        "comment_created_at": "2025-07-20T17:30:43+00:00",
        "comment_author": "gpeal",
        "comment_body": "I think the comments are somewhat useful because some branches continue and some break and when the next person implements a branch, they could make the same mistake as you did the first time since it's not totally obvious",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2202868898",
    "pr_number": 1547,
    "pr_file": "codex-rs/core/src/chat_completions.rs",
    "created_at": "2025-07-12T18:49:48+00:00",
    "commented_code": "}\n \n impl<T> AggregateStreamExt for T where T: Stream<Item = Result<ResponseEvent>> + Sized {}\n+#[cfg(test)]\n+mod tests {\n+    #![allow(clippy::unwrap_used)]\n+    use super::*;\n+    use crate::WireApi;\n+    use crate::client_common::Prompt;\n+    use crate::config::{Config, ConfigOverrides, ConfigToml};\n+    use crate::models::{ContentItem, FunctionCallOutputPayload, ResponseItem};\n+    use pretty_assertions::assert_eq;\n+    use std::sync::{Arc, Mutex};\n+    use tempfile::TempDir;\n+    use wiremock::matchers::{method, path};\n+    use wiremock::{Mock, MockServer, Request, Respond, ResponseTemplate};\n+\n+    struct CaptureResponder {\n+        body: Arc<Mutex<Option<serde_json::Value>>>,\n+    }\n+\n+    impl Respond for CaptureResponder {\n+        fn respond(&self, req: &Request) -> ResponseTemplate {\n+            let v: serde_json::Value = serde_json::from_slice(&req.body).unwrap();\n+            *self.body.lock().unwrap() = Some(v);\n+            ResponseTemplate::new(200).insert_header(\"content-type\", \"text/event-stream\")\n+        }\n+    }\n+\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2202868898",
        "repo_full_name": "openai/codex",
        "pr_number": 1547,
        "pr_file": "codex-rs/core/src/chat_completions.rs",
        "discussion_id": "2202868898",
        "commented_code": "@@ -462,3 +462,106 @@ pub(crate) trait AggregateStreamExt: Stream<Item = Result<ResponseEvent>> + Size\n }\n \n impl<T> AggregateStreamExt for T where T: Stream<Item = Result<ResponseEvent>> + Sized {}\n+#[cfg(test)]\n+mod tests {\n+    #![allow(clippy::unwrap_used)]\n+    use super::*;\n+    use crate::WireApi;\n+    use crate::client_common::Prompt;\n+    use crate::config::{Config, ConfigOverrides, ConfigToml};\n+    use crate::models::{ContentItem, FunctionCallOutputPayload, ResponseItem};\n+    use pretty_assertions::assert_eq;\n+    use std::sync::{Arc, Mutex};\n+    use tempfile::TempDir;\n+    use wiremock::matchers::{method, path};\n+    use wiremock::{Mock, MockServer, Request, Respond, ResponseTemplate};\n+\n+    struct CaptureResponder {\n+        body: Arc<Mutex<Option<serde_json::Value>>>,\n+    }\n+\n+    impl Respond for CaptureResponder {\n+        fn respond(&self, req: &Request) -> ResponseTemplate {\n+            let v: serde_json::Value = serde_json::from_slice(&req.body).unwrap();\n+            *self.body.lock().unwrap() = Some(v);\n+            ResponseTemplate::new(200).insert_header(\"content-type\", \"text/event-stream\")\n+        }\n+    }\n+\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]",
        "comment_created_at": "2025-07-12T18:49:48+00:00",
        "comment_author": "bolinfest",
        "comment_body": "Please add a docstring explaining what is being tested.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2202854547",
    "pr_number": 1545,
    "pr_file": "codex-rs/cli/tests/integration.rs",
    "created_at": "2025-07-12T18:06:39+00:00",
    "commented_code": "+#![allow(clippy::unwrap_used)]\n+\n+use codex_core::exec::CODEX_SANDBOX_NETWORK_DISABLED_ENV_VAR;\n+use predicates::prelude::*;\n+use std::fs;\n+use std::path::Path;\n+use tempfile::TempDir;\n+use wiremock::Mock;\n+use wiremock::MockServer;\n+use wiremock::ResponseTemplate;\n+use wiremock::matchers::method;\n+use wiremock::matchers::path;\n+\n+fn write_config(dir: &Path, server: &MockServer) {\n+    fs::write(\n+        dir.join(\"config.toml\"),\n+        format!(\n+            r#\"model_provider = \"mock\"\n+model = \"test-model\"\n+[model_providers.mock]\n+name = \"mock\"\n+base_url = \"{}/v1\"\n+env_key = \"PATH\"\n+wire_api = \"responses\"\n+\"#,\n+            server.uri()\n+        ),\n+    )\n+    .unwrap();\n+}\n+\n+fn sse_message(text: &str) -> String {\n+    format!(\n+        \"event: response.output_item.done\n\\\n+data: {{\\\"type\\\":\\\"response.output_item.done\\\",\\\"item\\\":{{\\\"type\\\":\\\"message\\\",\\\"role\\\":\\\"assistant\\\",\\\"content\\\":[{{\\\"type\\\":\\\"output_text\\\",\\\"text\\\":\\\"{text}\\\"}}]}}}}\n\n\\\n+event: response.completed\n\\\n+data: {{\\\"type\\\":\\\"response.completed\\\",\\\"response\\\":{{\\\"id\\\":\\\"resp1\\\",\\\"output\\\":[]}}}}\n\n\n\"\n+    )\n+}\n+\n+fn sse_function_call() -> String {\n+    let call = serde_json::json!({\n+        \"type\": \"response.output_item.done\",\n+        \"item\": {\n+            \"type\": \"function_call\",\n+            \"name\": \"shell\",\n+            \"arguments\": \"{\\\"command\\\":[\\\"echo\\\",\\\"hi\\\"]}\",\n+            \"call_id\": \"call1\"\n+        }\n+    });\n+    let completed = serde_json::json!({\n+        \"type\": \"response.completed\",\n+        \"response\": {\"id\": \"resp1\", \"output\": []}\n+    });\n+    format!(\n+        \"event: response.output_item.done\ndata: {call}\n\n\\\n+event: response.completed\ndata: {completed}\n\n\n\"\n+    )\n+}\n+\n+fn sse_final_after_call() -> String {\n+    let msg = serde_json::json!({\n+        \"type\": \"response.output_item.done\",\n+        \"item\": {\"type\": \"message\", \"role\": \"assistant\", \"content\": [{\"type\": \"output_text\", \"text\": \"done\"}]}\n+    });\n+    let completed = serde_json::json!({\n+        \"type\": \"response.completed\",\n+        \"response\": {\"id\": \"resp2\", \"output\": []}\n+    });\n+    format!(\n+        \"event: response.output_item.done\ndata: {msg}\n\n\\\n+event: response.completed\ndata: {completed}\n\n\n\"\n+    )\n+}\n+\n+#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2202854547",
        "repo_full_name": "openai/codex",
        "pr_number": 1545,
        "pr_file": "codex-rs/cli/tests/integration.rs",
        "discussion_id": "2202854547",
        "commented_code": "@@ -0,0 +1,171 @@\n+#![allow(clippy::unwrap_used)]\n+\n+use codex_core::exec::CODEX_SANDBOX_NETWORK_DISABLED_ENV_VAR;\n+use predicates::prelude::*;\n+use std::fs;\n+use std::path::Path;\n+use tempfile::TempDir;\n+use wiremock::Mock;\n+use wiremock::MockServer;\n+use wiremock::ResponseTemplate;\n+use wiremock::matchers::method;\n+use wiremock::matchers::path;\n+\n+fn write_config(dir: &Path, server: &MockServer) {\n+    fs::write(\n+        dir.join(\"config.toml\"),\n+        format!(\n+            r#\"model_provider = \"mock\"\n+model = \"test-model\"\n+[model_providers.mock]\n+name = \"mock\"\n+base_url = \"{}/v1\"\n+env_key = \"PATH\"\n+wire_api = \"responses\"\n+\"#,\n+            server.uri()\n+        ),\n+    )\n+    .unwrap();\n+}\n+\n+fn sse_message(text: &str) -> String {\n+    format!(\n+        \"event: response.output_item.done\\n\\\n+data: {{\\\"type\\\":\\\"response.output_item.done\\\",\\\"item\\\":{{\\\"type\\\":\\\"message\\\",\\\"role\\\":\\\"assistant\\\",\\\"content\\\":[{{\\\"type\\\":\\\"output_text\\\",\\\"text\\\":\\\"{text}\\\"}}]}}}}\\n\\n\\\n+event: response.completed\\n\\\n+data: {{\\\"type\\\":\\\"response.completed\\\",\\\"response\\\":{{\\\"id\\\":\\\"resp1\\\",\\\"output\\\":[]}}}}\\n\\n\\n\"\n+    )\n+}\n+\n+fn sse_function_call() -> String {\n+    let call = serde_json::json!({\n+        \"type\": \"response.output_item.done\",\n+        \"item\": {\n+            \"type\": \"function_call\",\n+            \"name\": \"shell\",\n+            \"arguments\": \"{\\\"command\\\":[\\\"echo\\\",\\\"hi\\\"]}\",\n+            \"call_id\": \"call1\"\n+        }\n+    });\n+    let completed = serde_json::json!({\n+        \"type\": \"response.completed\",\n+        \"response\": {\"id\": \"resp1\", \"output\": []}\n+    });\n+    format!(\n+        \"event: response.output_item.done\\ndata: {call}\\n\\n\\\n+event: response.completed\\ndata: {completed}\\n\\n\\n\"\n+    )\n+}\n+\n+fn sse_final_after_call() -> String {\n+    let msg = serde_json::json!({\n+        \"type\": \"response.output_item.done\",\n+        \"item\": {\"type\": \"message\", \"role\": \"assistant\", \"content\": [{\"type\": \"output_text\", \"text\": \"done\"}]}\n+    });\n+    let completed = serde_json::json!({\n+        \"type\": \"response.completed\",\n+        \"response\": {\"id\": \"resp2\", \"output\": []}\n+    });\n+    format!(\n+        \"event: response.output_item.done\\ndata: {msg}\\n\\n\\\n+event: response.completed\\ndata: {completed}\\n\\n\\n\"\n+    )\n+}\n+\n+#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]",
        "comment_created_at": "2025-07-12T18:06:39+00:00",
        "comment_author": "bolinfest",
        "comment_body": "Could you add docstrings for this test and the other test? Admittedly, there is a lot of code required just to setup these tests, so it's not 100% obvious what is being tested. That is, this line seems to be the key bit that is producing the behavior that we are verifying at the end of the test:\r\n\r\n```rust\r\n.set_body_raw(sse_message(\"Hello, world.\"), \"text/event-stream\")\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172460843",
    "pr_number": 1402,
    "pr_file": "codex-rs/tui/src/chatwidget.rs",
    "created_at": "2025-06-27T16:56:12+00:00",
    "commented_code": "self.request_redraw();\n     }\n \n+    pub(crate) fn on_ctrl_c(&mut self) -> bool {",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2172460843",
        "repo_full_name": "openai/codex",
        "pr_number": 1402,
        "pr_file": "codex-rs/tui/src/chatwidget.rs",
        "discussion_id": "2172460843",
        "commented_code": "@@ -402,6 +404,19 @@ impl ChatWidget<'_> {\n         self.request_redraw();\n     }\n \n+    pub(crate) fn on_ctrl_c(&mut self) -> bool {",
        "comment_created_at": "2025-06-27T16:56:12+00:00",
        "comment_author": "bolinfest",
        "comment_body": "Maybe a docstring to explain what the return value represents?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072441002",
    "pr_number": 733,
    "pr_file": "codex-rs/tui/src/status_indicator_widget.rs",
    "created_at": "2025-05-03T18:10:40+00:00",
    "commented_code": "let paragraph = Paragraph::new(Line::from(spans))\n             .block(block)\n             .alignment(Alignment::Left);\n+        \n+        // Render the main paragraph\n         paragraph.render_ref(area, buf);\n+        \n+        // Add the \"press Esc twice to interrupt\" text at the right side\n+        if area.height > 0 {\n+            let interrupt_text = \"press Esc twice to interrupt\";\n+            let text_style = Style::default().fg(Color::DarkGray);\n+            \n+            // Calculate position for right-aligned text\n+            let text_width = interrupt_text.len() as u16;\n+            let x_pos = area.x + area.width.saturating_sub(text_width + 2); // +2 for padding",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2072441002",
        "repo_full_name": "openai/codex",
        "pr_number": 733,
        "pr_file": "codex-rs/tui/src/status_indicator_widget.rs",
        "discussion_id": "2072441002",
        "commented_code": "@@ -209,6 +209,24 @@ impl WidgetRef for StatusIndicatorWidget {\n         let paragraph = Paragraph::new(Line::from(spans))\n             .block(block)\n             .alignment(Alignment::Left);\n+        \n+        // Render the main paragraph\n         paragraph.render_ref(area, buf);\n+        \n+        // Add the \"press Esc twice to interrupt\" text at the right side\n+        if area.height > 0 {\n+            let interrupt_text = \"press Esc twice to interrupt\";\n+            let text_style = Style::default().fg(Color::DarkGray);\n+            \n+            // Calculate position for right-aligned text\n+            let text_width = interrupt_text.len() as u16;\n+            let x_pos = area.x + area.width.saturating_sub(text_width + 2); // +2 for padding",
        "comment_created_at": "2025-05-03T18:10:40+00:00",
        "comment_author": "bolinfest",
        "comment_body": "I have tried to avoid these sorts of comments. For example, in `bottom_pane.rs`, we have:\r\n\r\n```rust\r\n/// Number of terminal rows consumed by the textarea border (top + bottom).\r\nconst TEXTAREA_BORDER_LINES: u16 = 2;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]