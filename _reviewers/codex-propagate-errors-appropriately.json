[
  {
    "discussion_id": "2055000086",
    "pr_number": 563,
    "pr_file": "codex-cli/tests/responses-chat-completions.test.ts",
    "created_at": "2025-04-22T23:00:16+00:00",
    "commented_code": "}\n     });\n \n-    it(\"should handle errors gracefully\", async () => {",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2055000086",
        "repo_full_name": "openai/codex",
        "pr_number": 563,
        "pr_file": "codex-cli/tests/responses-chat-completions.test.ts",
        "discussion_id": "2055000086",
        "commented_code": "@@ -736,33 +736,6 @@ describe(\"responsesCreateViaChatCompletions\", () => {\n       }\n     });\n \n-    it(\"should handle errors gracefully\", async () => {",
        "comment_created_at": "2025-04-22T23:00:16+00:00",
        "comment_author": "tibo-openai",
        "comment_body": "Could you document why we want to remove this one?",
        "pr_file_module": null
      },
      {
        "comment_id": "2055065140",
        "repo_full_name": "openai/codex",
        "pr_number": 563,
        "pr_file": "codex-cli/tests/responses-chat-completions.test.ts",
        "discussion_id": "2055000086",
        "commented_code": "@@ -736,33 +736,6 @@ describe(\"responsesCreateViaChatCompletions\", () => {\n       }\n     });\n \n-    it(\"should handle errors gracefully\", async () => {",
        "comment_created_at": "2025-04-23T00:09:09+00:00",
        "comment_author": "dnakov",
        "comment_body": "the try/catch wasn't allowing errors to propagate to the agent-loop, which has the rate limit and other handling. I took the error test out because it shouldn't gracefully handle the errors.\nI'll write some more tests, I want to record snapshots from the different providers and test against those. Up to you if you want to wait a but for those, but this PR fixes gemini right now that people have been complaining about :)",
        "pr_file_module": null
      },
      {
        "comment_id": "2055082322",
        "repo_full_name": "openai/codex",
        "pr_number": 563,
        "pr_file": "codex-cli/tests/responses-chat-completions.test.ts",
        "discussion_id": "2055000086",
        "commented_code": "@@ -736,33 +736,6 @@ describe(\"responsesCreateViaChatCompletions\", () => {\n       }\n     });\n \n-    it(\"should handle errors gracefully\", async () => {",
        "comment_created_at": "2025-04-23T00:37:41+00:00",
        "comment_author": "tibo-openai",
        "comment_body": "This makes sense to me, will merge.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2057307834",
    "pr_number": 602,
    "pr_file": "codex-cli/src/utils/transcriber.ts",
    "created_at": "2025-04-24T02:55:42+00:00",
    "commented_code": "+import { OpenAIRealtimeWS } from 'openai/beta/realtime/ws';\n+import { EventEmitter } from 'events';\n+import OpenAI from 'openai';\n+// workaround since pvrecorder-node is a commonjs module\n+import { createRequire } from 'node:module';\n+const require = createRequire(import.meta.url);\n+const { PvRecorder } = require('@picovoice/pvrecorder-node'); \n+\n+// API configuration\n+const API_KEY = process.env['OPENAI_API_KEY'];\n+\n+export interface TranscriptionEvent {\n+  type: string;\n+  delta?: string;\n+  transcript?: string;\n+}\n+\n+export interface TranscriberOptions {\n+  model?: string;\n+  language?: string;\n+}\n+\n+export class RealtimeTranscriber extends EventEmitter {\n+  private rt: OpenAIRealtimeWS | null = null;\n+  private recorder: typeof PvRecorder | null = null;\n+  private isConnected = false;\n+  private isRecording = false;\n+  private model: string;\n+  private language: string;\n+\n+  constructor(options: TranscriberOptions = {}) {\n+    super();\n+    this.model = options.model || 'gpt-4o-mini-transcribe';\n+    this.language = options.language || 'en';\n+    this.setupSignalHandlers();\n+  }\n+\n+  private setupSignalHandlers() {\n+    process.on('SIGINT', () => this.cleanup());\n+    process.on('SIGTERM', () => this.cleanup());\n+  }\n+\n+  public async start() {\n+    try {\n+      // Check API key\n+      if (!API_KEY) {\n+        throw new Error('OPENAI_API_KEY not found in environment variables');\n+      }\n+      \n+      // Initialize OpenAI client\n+      const client = new OpenAI({ apiKey: API_KEY });\n+\n+      // Initialize the realtime client\n+      this.rt = new OpenAIRealtimeWS(\n+        { model: this.model },\n+        client\n+      );\n+\n+      // Set up event handlers\n+      this.rt.on('error', (error) => {\n+        console.error('OpenAI WebSocket error:', error);\n+        this.emit('error', error);\n+      });\n+\n+      this.rt.on('conversation.item.input_audio_transcription.delta', (event) => {\n+        this.emit('transcription', {\n+          type: 'transcription.delta',\n+          delta: event.delta\n+        });\n+      });\n+\n+      this.rt.on('conversation.item.input_audio_transcription.completed', (event) => {\n+        this.emit('transcription', {\n+          type: 'transcription.done',\n+          transcript: event.transcript\n+        });\n+      });\n+\n+      // Set up WebSocket connection\n+      this.rt.socket.on('open', () => {\n+        this.isConnected = true;\n+        this.emit('connected');\n+\n+        // Configure the session\n+        this.rt?.send({\n+          type: 'session.update',\n+          session: {\n+            input_audio_format: 'pcm16',\n+            input_audio_transcription: {\n+              model: this.model,\n+              prompt: '',\n+              language: this.language\n+            },\n+            turn_detection: {\n+              type: 'server_vad',\n+              threshold: 0.5,\n+              prefix_padding_ms: 300,\n+              silence_duration_ms: 500\n+            },\n+            input_audio_noise_reduction: {\n+              type: 'near_field'\n+            }\n+          }\n+        });\n+\n+        // Start audio capture once WebSocket is connected\n+        this.startAudioCapture();\n+      });\n+\n+      this.rt.socket.on('close', (code: number, reason: string) => {\n+        if (code !== 1000) { // 1000 is a normal close\n+          console.error(`WebSocket closed: code=${code}, reason=${reason}`);\n+        }\n+        this.isConnected = false;\n+        this.emit('disconnected');\n+      });\n+\n+      this.rt.socket.on('error', (error: Error) => {\n+        console.error('WebSocket error:', error);\n+      });\n+\n+    } catch (error) {\n+      console.error('Failed to start transcription:', error);\n+      this.cleanup();\n+      throw error;\n+    }\n+  }\n+\n+  private startAudioCapture() {\n+    try {\n+      // Get available audio devices\n+      const devices = PvRecorder.getAvailableDevices();\n+      if (devices.length === 0) {\n+        throw new Error('No audio input device found');\n+      }\n+\n+      // Create recorder with first available device\n+      const frameLength = 512;\n+      this.recorder = new PvRecorder(frameLength, 0);\n+      \n+      // Start recording\n+      this.recorder.start();\n+      this.isRecording = true;\n+      \n+      // Process audio frames\n+      this.processAudioFrames();\n+    } catch (error) {\n+      console.error('Failed to start audio capture:', error);\n+      this.stopAudioCapture();\n+      throw error;\n+    }\n+  }\n+\n+  private async processAudioFrames() {\n+    if (!this.recorder || !this.isRecording) return;\n+    \n+    try {\n+      while (this.isRecording && this.isConnected) {\n+        try {\n+          const frame = await this.recorder.read();\n+          \n+          // Convert Int16Array to Buffer and send to OpenAI\n+          if (this.rt && this.isConnected) {\n+            const buffer = Buffer.from(frame.buffer);\n+            this.rt.send({\n+              type: 'input_audio_buffer.append',\n+              audio: buffer.toString('base64')\n+            });\n+          }\n+        } catch (error: any) {\n+          // Silently break out if it's an InvalidState error (happens when stopping)\n+          if (error.constructor.name === 'PvRecorderStatusInvalidStateError' ||",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2057307834",
        "repo_full_name": "openai/codex",
        "pr_number": 602,
        "pr_file": "codex-cli/src/utils/transcriber.ts",
        "discussion_id": "2057307834",
        "commented_code": "@@ -0,0 +1,214 @@\n+import { OpenAIRealtimeWS } from 'openai/beta/realtime/ws';\n+import { EventEmitter } from 'events';\n+import OpenAI from 'openai';\n+// workaround since pvrecorder-node is a commonjs module\n+import { createRequire } from 'node:module';\n+const require = createRequire(import.meta.url);\n+const { PvRecorder } = require('@picovoice/pvrecorder-node'); \n+\n+// API configuration\n+const API_KEY = process.env['OPENAI_API_KEY'];\n+\n+export interface TranscriptionEvent {\n+  type: string;\n+  delta?: string;\n+  transcript?: string;\n+}\n+\n+export interface TranscriberOptions {\n+  model?: string;\n+  language?: string;\n+}\n+\n+export class RealtimeTranscriber extends EventEmitter {\n+  private rt: OpenAIRealtimeWS | null = null;\n+  private recorder: typeof PvRecorder | null = null;\n+  private isConnected = false;\n+  private isRecording = false;\n+  private model: string;\n+  private language: string;\n+\n+  constructor(options: TranscriberOptions = {}) {\n+    super();\n+    this.model = options.model || 'gpt-4o-mini-transcribe';\n+    this.language = options.language || 'en';\n+    this.setupSignalHandlers();\n+  }\n+\n+  private setupSignalHandlers() {\n+    process.on('SIGINT', () => this.cleanup());\n+    process.on('SIGTERM', () => this.cleanup());\n+  }\n+\n+  public async start() {\n+    try {\n+      // Check API key\n+      if (!API_KEY) {\n+        throw new Error('OPENAI_API_KEY not found in environment variables');\n+      }\n+      \n+      // Initialize OpenAI client\n+      const client = new OpenAI({ apiKey: API_KEY });\n+\n+      // Initialize the realtime client\n+      this.rt = new OpenAIRealtimeWS(\n+        { model: this.model },\n+        client\n+      );\n+\n+      // Set up event handlers\n+      this.rt.on('error', (error) => {\n+        console.error('OpenAI WebSocket error:', error);\n+        this.emit('error', error);\n+      });\n+\n+      this.rt.on('conversation.item.input_audio_transcription.delta', (event) => {\n+        this.emit('transcription', {\n+          type: 'transcription.delta',\n+          delta: event.delta\n+        });\n+      });\n+\n+      this.rt.on('conversation.item.input_audio_transcription.completed', (event) => {\n+        this.emit('transcription', {\n+          type: 'transcription.done',\n+          transcript: event.transcript\n+        });\n+      });\n+\n+      // Set up WebSocket connection\n+      this.rt.socket.on('open', () => {\n+        this.isConnected = true;\n+        this.emit('connected');\n+\n+        // Configure the session\n+        this.rt?.send({\n+          type: 'session.update',\n+          session: {\n+            input_audio_format: 'pcm16',\n+            input_audio_transcription: {\n+              model: this.model,\n+              prompt: '',\n+              language: this.language\n+            },\n+            turn_detection: {\n+              type: 'server_vad',\n+              threshold: 0.5,\n+              prefix_padding_ms: 300,\n+              silence_duration_ms: 500\n+            },\n+            input_audio_noise_reduction: {\n+              type: 'near_field'\n+            }\n+          }\n+        });\n+\n+        // Start audio capture once WebSocket is connected\n+        this.startAudioCapture();\n+      });\n+\n+      this.rt.socket.on('close', (code: number, reason: string) => {\n+        if (code !== 1000) { // 1000 is a normal close\n+          console.error(`WebSocket closed: code=${code}, reason=${reason}`);\n+        }\n+        this.isConnected = false;\n+        this.emit('disconnected');\n+      });\n+\n+      this.rt.socket.on('error', (error: Error) => {\n+        console.error('WebSocket error:', error);\n+      });\n+\n+    } catch (error) {\n+      console.error('Failed to start transcription:', error);\n+      this.cleanup();\n+      throw error;\n+    }\n+  }\n+\n+  private startAudioCapture() {\n+    try {\n+      // Get available audio devices\n+      const devices = PvRecorder.getAvailableDevices();\n+      if (devices.length === 0) {\n+        throw new Error('No audio input device found');\n+      }\n+\n+      // Create recorder with first available device\n+      const frameLength = 512;\n+      this.recorder = new PvRecorder(frameLength, 0);\n+      \n+      // Start recording\n+      this.recorder.start();\n+      this.isRecording = true;\n+      \n+      // Process audio frames\n+      this.processAudioFrames();\n+    } catch (error) {\n+      console.error('Failed to start audio capture:', error);\n+      this.stopAudioCapture();\n+      throw error;\n+    }\n+  }\n+\n+  private async processAudioFrames() {\n+    if (!this.recorder || !this.isRecording) return;\n+    \n+    try {\n+      while (this.isRecording && this.isConnected) {\n+        try {\n+          const frame = await this.recorder.read();\n+          \n+          // Convert Int16Array to Buffer and send to OpenAI\n+          if (this.rt && this.isConnected) {\n+            const buffer = Buffer.from(frame.buffer);\n+            this.rt.send({\n+              type: 'input_audio_buffer.append',\n+              audio: buffer.toString('base64')\n+            });\n+          }\n+        } catch (error: any) {\n+          // Silently break out if it's an InvalidState error (happens when stopping)\n+          if (error.constructor.name === 'PvRecorderStatusInvalidStateError' || ",
        "comment_created_at": "2025-04-24T02:55:42+00:00",
        "comment_author": "benny123tw",
        "comment_body": "You can use `instanceof` to check the Error type.\r\n\r\n```js\r\n  if (\r\n    error instanceof Error && \r\n    (error instanceof PvRecorderStatusInvalidStateError || \r\n     error.message.includes('failed to read audio data frame'))\r\n  ) {\r\n    break;\r\n  }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2059352054",
        "repo_full_name": "openai/codex",
        "pr_number": 602,
        "pr_file": "codex-cli/src/utils/transcriber.ts",
        "discussion_id": "2057307834",
        "commented_code": "@@ -0,0 +1,214 @@\n+import { OpenAIRealtimeWS } from 'openai/beta/realtime/ws';\n+import { EventEmitter } from 'events';\n+import OpenAI from 'openai';\n+// workaround since pvrecorder-node is a commonjs module\n+import { createRequire } from 'node:module';\n+const require = createRequire(import.meta.url);\n+const { PvRecorder } = require('@picovoice/pvrecorder-node'); \n+\n+// API configuration\n+const API_KEY = process.env['OPENAI_API_KEY'];\n+\n+export interface TranscriptionEvent {\n+  type: string;\n+  delta?: string;\n+  transcript?: string;\n+}\n+\n+export interface TranscriberOptions {\n+  model?: string;\n+  language?: string;\n+}\n+\n+export class RealtimeTranscriber extends EventEmitter {\n+  private rt: OpenAIRealtimeWS | null = null;\n+  private recorder: typeof PvRecorder | null = null;\n+  private isConnected = false;\n+  private isRecording = false;\n+  private model: string;\n+  private language: string;\n+\n+  constructor(options: TranscriberOptions = {}) {\n+    super();\n+    this.model = options.model || 'gpt-4o-mini-transcribe';\n+    this.language = options.language || 'en';\n+    this.setupSignalHandlers();\n+  }\n+\n+  private setupSignalHandlers() {\n+    process.on('SIGINT', () => this.cleanup());\n+    process.on('SIGTERM', () => this.cleanup());\n+  }\n+\n+  public async start() {\n+    try {\n+      // Check API key\n+      if (!API_KEY) {\n+        throw new Error('OPENAI_API_KEY not found in environment variables');\n+      }\n+      \n+      // Initialize OpenAI client\n+      const client = new OpenAI({ apiKey: API_KEY });\n+\n+      // Initialize the realtime client\n+      this.rt = new OpenAIRealtimeWS(\n+        { model: this.model },\n+        client\n+      );\n+\n+      // Set up event handlers\n+      this.rt.on('error', (error) => {\n+        console.error('OpenAI WebSocket error:', error);\n+        this.emit('error', error);\n+      });\n+\n+      this.rt.on('conversation.item.input_audio_transcription.delta', (event) => {\n+        this.emit('transcription', {\n+          type: 'transcription.delta',\n+          delta: event.delta\n+        });\n+      });\n+\n+      this.rt.on('conversation.item.input_audio_transcription.completed', (event) => {\n+        this.emit('transcription', {\n+          type: 'transcription.done',\n+          transcript: event.transcript\n+        });\n+      });\n+\n+      // Set up WebSocket connection\n+      this.rt.socket.on('open', () => {\n+        this.isConnected = true;\n+        this.emit('connected');\n+\n+        // Configure the session\n+        this.rt?.send({\n+          type: 'session.update',\n+          session: {\n+            input_audio_format: 'pcm16',\n+            input_audio_transcription: {\n+              model: this.model,\n+              prompt: '',\n+              language: this.language\n+            },\n+            turn_detection: {\n+              type: 'server_vad',\n+              threshold: 0.5,\n+              prefix_padding_ms: 300,\n+              silence_duration_ms: 500\n+            },\n+            input_audio_noise_reduction: {\n+              type: 'near_field'\n+            }\n+          }\n+        });\n+\n+        // Start audio capture once WebSocket is connected\n+        this.startAudioCapture();\n+      });\n+\n+      this.rt.socket.on('close', (code: number, reason: string) => {\n+        if (code !== 1000) { // 1000 is a normal close\n+          console.error(`WebSocket closed: code=${code}, reason=${reason}`);\n+        }\n+        this.isConnected = false;\n+        this.emit('disconnected');\n+      });\n+\n+      this.rt.socket.on('error', (error: Error) => {\n+        console.error('WebSocket error:', error);\n+      });\n+\n+    } catch (error) {\n+      console.error('Failed to start transcription:', error);\n+      this.cleanup();\n+      throw error;\n+    }\n+  }\n+\n+  private startAudioCapture() {\n+    try {\n+      // Get available audio devices\n+      const devices = PvRecorder.getAvailableDevices();\n+      if (devices.length === 0) {\n+        throw new Error('No audio input device found');\n+      }\n+\n+      // Create recorder with first available device\n+      const frameLength = 512;\n+      this.recorder = new PvRecorder(frameLength, 0);\n+      \n+      // Start recording\n+      this.recorder.start();\n+      this.isRecording = true;\n+      \n+      // Process audio frames\n+      this.processAudioFrames();\n+    } catch (error) {\n+      console.error('Failed to start audio capture:', error);\n+      this.stopAudioCapture();\n+      throw error;\n+    }\n+  }\n+\n+  private async processAudioFrames() {\n+    if (!this.recorder || !this.isRecording) return;\n+    \n+    try {\n+      while (this.isRecording && this.isConnected) {\n+        try {\n+          const frame = await this.recorder.read();\n+          \n+          // Convert Int16Array to Buffer and send to OpenAI\n+          if (this.rt && this.isConnected) {\n+            const buffer = Buffer.from(frame.buffer);\n+            this.rt.send({\n+              type: 'input_audio_buffer.append',\n+              audio: buffer.toString('base64')\n+            });\n+          }\n+        } catch (error: any) {\n+          // Silently break out if it's an InvalidState error (happens when stopping)\n+          if (error.constructor.name === 'PvRecorderStatusInvalidStateError' || ",
        "comment_created_at": "2025-04-24T22:56:20+00:00",
        "comment_author": "ercbot",
        "comment_body": "added instanceof Error\r\n\r\nunfortunately we can't do instance of PvRecorderStatusInvalidStateError, since the require input here doesn't preserve the class type",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2049386666",
    "pr_number": 176,
    "pr_file": "codex-cli/src/utils/config.ts",
    "created_at": "2025-04-17T17:27:25+00:00",
    "commented_code": "export const DEFAULT_APPROVAL_MODE = AutoApprovalMode.SUGGEST;\n export const DEFAULT_INSTRUCTIONS = \"\";\n \n+// Default rate limit retry settings\n+export const DEFAULT_RATE_LIMIT_MAX_RETRIES = 5;\n+export const DEFAULT_RATE_LIMIT_INITIAL_RETRY_DELAY_MS = 2500;",
    "repo_full_name": "openai/codex",
    "discussion_comments": [
      {
        "comment_id": "2049386666",
        "repo_full_name": "openai/codex",
        "pr_number": 176,
        "pr_file": "codex-cli/src/utils/config.ts",
        "discussion_id": "2049386666",
        "commented_code": "@@ -20,6 +20,12 @@ export const DEFAULT_FULL_CONTEXT_MODEL = \"gpt-4.1\";\n export const DEFAULT_APPROVAL_MODE = AutoApprovalMode.SUGGEST;\n export const DEFAULT_INSTRUCTIONS = \"\";\n \n+// Default rate limit retry settings\n+export const DEFAULT_RATE_LIMIT_MAX_RETRIES = 5;\n+export const DEFAULT_RATE_LIMIT_INITIAL_RETRY_DELAY_MS = 2500;",
        "comment_created_at": "2025-04-17T17:27:25+00:00",
        "comment_author": "jonchurch",
        "comment_body": "How was this tested? 2.5 sec is a very large initial backoff",
        "pr_file_module": null
      },
      {
        "comment_id": "2049483237",
        "repo_full_name": "openai/codex",
        "pr_number": 176,
        "pr_file": "codex-cli/src/utils/config.ts",
        "discussion_id": "2049386666",
        "commented_code": "@@ -20,6 +20,12 @@ export const DEFAULT_FULL_CONTEXT_MODEL = \"gpt-4.1\";\n export const DEFAULT_APPROVAL_MODE = AutoApprovalMode.SUGGEST;\n export const DEFAULT_INSTRUCTIONS = \"\";\n \n+// Default rate limit retry settings\n+export const DEFAULT_RATE_LIMIT_MAX_RETRIES = 5;\n+export const DEFAULT_RATE_LIMIT_INITIAL_RETRY_DELAY_MS = 2500;",
        "comment_created_at": "2025-04-17T18:48:53+00:00",
        "comment_author": "jonchurch",
        "comment_body": "I see this was already in the codebase \ud83d\udc4d \r\nhttps://github.com/openai/codex/blob/3a71175236cae47a2950266a0d7888e4f76227c4/codex-cli/src/utils/agent/agent-loop.ts#L27\r\n\r\nToo big for my taste, we end up with something like\r\n```\r\n  attempt 1: 2500ms   (2500 \u00d7 2\u2070 = 2500)\r\n  attempt 2: 5000ms   (2500 \u00d7 2\u00b9 = 5000)\r\n  attempt 3: 10000ms  (2500 \u00d7 2\u00b2 = 10000)\r\n  attempt 4: 20000ms  (2500 \u00d7 2\u00b3 = 20000)\r\n  attempt 5: 40000ms  (2500 \u00d7 2\u2074 = 40000)\r\n```\r\nWhich is really sluggish",
        "pr_file_module": null
      },
      {
        "comment_id": "2049538183",
        "repo_full_name": "openai/codex",
        "pr_number": 176,
        "pr_file": "codex-cli/src/utils/config.ts",
        "discussion_id": "2049386666",
        "commented_code": "@@ -20,6 +20,12 @@ export const DEFAULT_FULL_CONTEXT_MODEL = \"gpt-4.1\";\n export const DEFAULT_APPROVAL_MODE = AutoApprovalMode.SUGGEST;\n export const DEFAULT_INSTRUCTIONS = \"\";\n \n+// Default rate limit retry settings\n+export const DEFAULT_RATE_LIMIT_MAX_RETRIES = 5;\n+export const DEFAULT_RATE_LIMIT_INITIAL_RETRY_DELAY_MS = 2500;",
        "comment_created_at": "2025-04-17T19:37:45+00:00",
        "comment_author": "tibo-openai",
        "comment_body": "This feels like a good start and guarantees that the total > 60s, which should guarantee that this should never fail just for rate limiting reasons. If it fails, then the correct behavior would be to block I think.",
        "pr_file_module": null
      }
    ]
  }
]