[
  {
    "discussion_id": "2147374271",
    "pr_number": 8351,
    "pr_file": "sandbox/windows_sandbox.py",
    "created_at": "2025-06-14T23:20:54+00:00",
    "commented_code": "+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"\n+\n+\n+def set_process_integrity_level_to_low():\n+    current_process = win32process.GetCurrentProcess()\n+    token = win32security.OpenProcessToken(\n+        current_process,\n+        win32con.TOKEN_ALL_ACCESS,\n+    )\n+\n+    low_integrity_sid = win32security.ConvertStringSidToSid(LOW_INTEGRITY_SID_STRING)\n+    win32security.SetTokenInformation(\n+        token, win32security.TokenIntegrityLevel, (low_integrity_sid, 0)\n+    )\n+\n+    logging.info(\"Sandbox enabled: Process now running with low integrity token\")\n+\n+    win32api.CloseHandle(token)\n+\n+\n+def does_permit_low_integrity_write(icacls_output):\n+    \"\"\"\n+    Checks if an icacls output indicates that the path is writable by low\n+    integrity processes.\n+\n+    Note that currently it is a bit of a crude check - it is possible for\n+    a low integrity process to have write access to a directory without\n+    having these exact ACLs reported by icacls. Implement a more robust\n+    check if this situation ever occurs.\n+    \"\"\"\n+    permissions = [l.strip() for l in icacls_output.split(\"\n\")]\n+    LOW_INTEGRITY_LABEL = r\"Mandatory Label\\Low Mandatory Level\"\n+\n+    for p in permissions:\n+        if LOW_INTEGRITY_LABEL not in p:\n+            continue\n+\n+        # Check the Low integrity label line - it should be something like\n+        # Mandatory Label\\Low Mandatory Level:(OI)(CI)(NW) or\n+        # Mandatory Label\\Low Mandatory Level:(I)(OI)(CI)(NW)\n+        return all(\n+            [\n+                # OI: Object Inheritance - all files in the directory with have low\n+                # integrity\n+                \"(OI)\" in p,\n+                # CI: Container Inheritance - all subdirectories will have low\n+                # integrity\n+                \"(CI)\" in p,\n+                # NW: No Writeup - processes with lower integrity cannot write to\n+                # this directory\n+                \"(NW)\" in p,\n+            ]\n+        )\n+\n+\n+def path_is_low_integrity_writable(path):\n+    \"\"\"Check if the path has a writable ACL by low integrity process\"\"\"\n+    result = subprocess.run([ICACLS_PATH, path], capture_output=True, text=True)\n+\n+    if result.returncode != 0:\n+        # icacls command failed. Can happen because path doesn't exist\n+        # or we're not allowed to access acl information of the path.\n+        return False",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2147374271",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8351,
        "pr_file": "sandbox/windows_sandbox.py",
        "discussion_id": "2147374271",
        "commented_code": "@@ -0,0 +1,172 @@\n+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"\n+\n+\n+def set_process_integrity_level_to_low():\n+    current_process = win32process.GetCurrentProcess()\n+    token = win32security.OpenProcessToken(\n+        current_process,\n+        win32con.TOKEN_ALL_ACCESS,\n+    )\n+\n+    low_integrity_sid = win32security.ConvertStringSidToSid(LOW_INTEGRITY_SID_STRING)\n+    win32security.SetTokenInformation(\n+        token, win32security.TokenIntegrityLevel, (low_integrity_sid, 0)\n+    )\n+\n+    logging.info(\"Sandbox enabled: Process now running with low integrity token\")\n+\n+    win32api.CloseHandle(token)\n+\n+\n+def does_permit_low_integrity_write(icacls_output):\n+    \"\"\"\n+    Checks if an icacls output indicates that the path is writable by low\n+    integrity processes.\n+\n+    Note that currently it is a bit of a crude check - it is possible for\n+    a low integrity process to have write access to a directory without\n+    having these exact ACLs reported by icacls. Implement a more robust\n+    check if this situation ever occurs.\n+    \"\"\"\n+    permissions = [l.strip() for l in icacls_output.split(\"\\n\")]\n+    LOW_INTEGRITY_LABEL = r\"Mandatory Label\\Low Mandatory Level\"\n+\n+    for p in permissions:\n+        if LOW_INTEGRITY_LABEL not in p:\n+            continue\n+\n+        # Check the Low integrity label line - it should be something like\n+        # Mandatory Label\\Low Mandatory Level:(OI)(CI)(NW) or\n+        # Mandatory Label\\Low Mandatory Level:(I)(OI)(CI)(NW)\n+        return all(\n+            [\n+                # OI: Object Inheritance - all files in the directory with have low\n+                # integrity\n+                \"(OI)\" in p,\n+                # CI: Container Inheritance - all subdirectories will have low\n+                # integrity\n+                \"(CI)\" in p,\n+                # NW: No Writeup - processes with lower integrity cannot write to\n+                # this directory\n+                \"(NW)\" in p,\n+            ]\n+        )\n+\n+\n+def path_is_low_integrity_writable(path):\n+    \"\"\"Check if the path has a writable ACL by low integrity process\"\"\"\n+    result = subprocess.run([ICACLS_PATH, path], capture_output=True, text=True)\n+\n+    if result.returncode != 0:\n+        # icacls command failed. Can happen because path doesn't exist\n+        # or we're not allowed to access acl information of the path.\n+        return False",
        "comment_created_at": "2025-06-14T23:20:54+00:00",
        "comment_author": "maludwig",
        "comment_body": "I would consider raising an error here. Calling code should know something went wrong. It probably should also know what went wrong. I think if you have a file in a directory, and your low integrity process wants to create that file, that's a case to consider. For example:\r\n\r\n```\r\nif path_is_low_integrity_writable(r'C:\\writable_dir\\'):\r\n    if not os.path.exists(r'C:\\writable_dir\\newfile.txt'):\r\n        assert path_is_low_integrity_writable(r'C:\\writable_dir\\newfile.txt')\r\n```\r\n\r\nIf this is intended to only check directories, then rename the function accordingly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2147377206",
    "pr_number": 8351,
    "pr_file": "sandbox/windows_sandbox.py",
    "created_at": "2025-06-14T23:41:07+00:00",
    "commented_code": "+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"\n+\n+\n+def set_process_integrity_level_to_low():\n+    current_process = win32process.GetCurrentProcess()\n+    token = win32security.OpenProcessToken(\n+        current_process,\n+        win32con.TOKEN_ALL_ACCESS,\n+    )\n+\n+    low_integrity_sid = win32security.ConvertStringSidToSid(LOW_INTEGRITY_SID_STRING)\n+    win32security.SetTokenInformation(\n+        token, win32security.TokenIntegrityLevel, (low_integrity_sid, 0)\n+    )\n+\n+    logging.info(\"Sandbox enabled: Process now running with low integrity token\")\n+\n+    win32api.CloseHandle(token)\n+\n+\n+def does_permit_low_integrity_write(icacls_output):\n+    \"\"\"\n+    Checks if an icacls output indicates that the path is writable by low\n+    integrity processes.\n+\n+    Note that currently it is a bit of a crude check - it is possible for\n+    a low integrity process to have write access to a directory without\n+    having these exact ACLs reported by icacls. Implement a more robust\n+    check if this situation ever occurs.\n+    \"\"\"\n+    permissions = [l.strip() for l in icacls_output.split(\"\n\")]\n+    LOW_INTEGRITY_LABEL = r\"Mandatory Label\\Low Mandatory Level\"\n+\n+    for p in permissions:\n+        if LOW_INTEGRITY_LABEL not in p:\n+            continue\n+\n+        # Check the Low integrity label line - it should be something like\n+        # Mandatory Label\\Low Mandatory Level:(OI)(CI)(NW) or\n+        # Mandatory Label\\Low Mandatory Level:(I)(OI)(CI)(NW)\n+        return all(\n+            [\n+                # OI: Object Inheritance - all files in the directory with have low\n+                # integrity\n+                \"(OI)\" in p,\n+                # CI: Container Inheritance - all subdirectories will have low\n+                # integrity\n+                \"(CI)\" in p,\n+                # NW: No Writeup - processes with lower integrity cannot write to\n+                # this directory\n+                \"(NW)\" in p,\n+            ]\n+        )\n+\n+\n+def path_is_low_integrity_writable(path):\n+    \"\"\"Check if the path has a writable ACL by low integrity process\"\"\"\n+    result = subprocess.run([ICACLS_PATH, path], capture_output=True, text=True)\n+\n+    if result.returncode != 0:\n+        # icacls command failed. Can happen because path doesn't exist\n+        # or we're not allowed to access acl information of the path.\n+        return False\n+\n+    return does_permit_low_integrity_write(result.stdout)\n+\n+\n+def ensure_directories_exist(dirs):\n+    for dir in dirs:\n+        os.makedirs(dir, exist_ok=True)\n+\n+\n+def check_directory_acls(dirs):\n+    acls_correct = True\n+    for dir in dirs:\n+        if not path_is_low_integrity_writable(dir):\n+            logging.info(\n+                f'Directory \"{dir}\" must be writable by low integrity '\n+                \"processes for sandbox mode.\"\n+            )\n+            acls_correct = False\n+\n+    return acls_correct\n+\n+\n+def setup_permissions(dirs):\n+    \"\"\"\n+    Sets the correct low integrity write permissions for the given directories\n+    using an UAC elevation prompt. We need admin elevation because if the Comfy\n+    directory is not under the user's profile directory (e.g. any location in a\n+    non-C: drive), the regular user does not have permission to set the\n+    integrity level ACLs.\n+    \"\"\"\n+    script_dir = os.path.dirname(os.path.abspath(__file__))\n+    bat_path = os.path.join(script_dir, \"setup_sandbox_permissions.bat\")\n+\n+    execute_info = {\n+        \"lpVerb\": \"runas\",  # Run as administrator\n+        \"lpFile\": bat_path,\n+        \"lpParameters\": \" \".join(dirs),\n+        \"nShow\": win32con.SW_SHOWNORMAL,\n+        # This flag is necessary to wait for the process to finish.\n+        \"fMask\": shellcon.SEE_MASK_NOCLOSEPROCESS,\n+    }\n+\n+    # This is equivalent to right-clicking the bat file and selecting \"Run as\n+    # administrator\"\n+    proc_info = shell.ShellExecuteEx(**execute_info)\n+    hProcess = proc_info[\"hProcess\"]\n+\n+    # Setup script should less than a second. Time out at 10 seconds.\n+    win32event.WaitForSingleObject(hProcess, 10 * 1000)\n+    exit_code = win32process.GetExitCodeProcess(hProcess)\n+\n+    try:\n+        if exit_code == win32con.STATUS_PENDING:\n+            raise Exception(\"Sandbox permission script timed out\")\n+        if exit_code != 0:\n+            raise Exception(\n+                \"Sandbox permission setup script failed. \" f\"Exit code: {exit_code}\"\n+            )\n+    finally:\n+        win32api.CloseHandle(hProcess)\n+\n+\n+def try_enable_sandbox():\n+    write_permitted_dirs = [\n+        folder_paths.get_write_permitted_base_directory(),\n+        folder_paths.get_output_directory(),\n+        folder_paths.get_user_directory(),\n+    ]\n+    write_permitted_dirs.extend(folder_paths.get_folder_paths(\"custom_nodes\"))\n+\n+    ensure_directories_exist(write_permitted_dirs)\n+\n+    if check_directory_acls(write_permitted_dirs):\n+        set_process_integrity_level_to_low()\n+        return True\n+\n+    # Directory permissions are not set up correctly. Try to fix.\n+    logging.critical(\n+        \"Some directories do not have the correct permissions for sandbox mode \"\n+        \"to work. Would you like ComfyUI to fix these permissions? You will \"\n+        \"receive a UAC elevation prompt. [y/n]\"\n+    )\n+    if input() != \"y\":\n+        return False\n+\n+    setup_permissions(write_permitted_dirs)\n+\n+    # Check directory permissions again before enabling sandbox.\n+    if check_directory_acls(write_permitted_dirs):\n+        set_process_integrity_level_to_low()\n+        return True\n+\n+    # Directory permissions are still not set up correctly. Give up.",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2147377206",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8351,
        "pr_file": "sandbox/windows_sandbox.py",
        "discussion_id": "2147377206",
        "commented_code": "@@ -0,0 +1,172 @@\n+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"\n+\n+\n+def set_process_integrity_level_to_low():\n+    current_process = win32process.GetCurrentProcess()\n+    token = win32security.OpenProcessToken(\n+        current_process,\n+        win32con.TOKEN_ALL_ACCESS,\n+    )\n+\n+    low_integrity_sid = win32security.ConvertStringSidToSid(LOW_INTEGRITY_SID_STRING)\n+    win32security.SetTokenInformation(\n+        token, win32security.TokenIntegrityLevel, (low_integrity_sid, 0)\n+    )\n+\n+    logging.info(\"Sandbox enabled: Process now running with low integrity token\")\n+\n+    win32api.CloseHandle(token)\n+\n+\n+def does_permit_low_integrity_write(icacls_output):\n+    \"\"\"\n+    Checks if an icacls output indicates that the path is writable by low\n+    integrity processes.\n+\n+    Note that currently it is a bit of a crude check - it is possible for\n+    a low integrity process to have write access to a directory without\n+    having these exact ACLs reported by icacls. Implement a more robust\n+    check if this situation ever occurs.\n+    \"\"\"\n+    permissions = [l.strip() for l in icacls_output.split(\"\\n\")]\n+    LOW_INTEGRITY_LABEL = r\"Mandatory Label\\Low Mandatory Level\"\n+\n+    for p in permissions:\n+        if LOW_INTEGRITY_LABEL not in p:\n+            continue\n+\n+        # Check the Low integrity label line - it should be something like\n+        # Mandatory Label\\Low Mandatory Level:(OI)(CI)(NW) or\n+        # Mandatory Label\\Low Mandatory Level:(I)(OI)(CI)(NW)\n+        return all(\n+            [\n+                # OI: Object Inheritance - all files in the directory with have low\n+                # integrity\n+                \"(OI)\" in p,\n+                # CI: Container Inheritance - all subdirectories will have low\n+                # integrity\n+                \"(CI)\" in p,\n+                # NW: No Writeup - processes with lower integrity cannot write to\n+                # this directory\n+                \"(NW)\" in p,\n+            ]\n+        )\n+\n+\n+def path_is_low_integrity_writable(path):\n+    \"\"\"Check if the path has a writable ACL by low integrity process\"\"\"\n+    result = subprocess.run([ICACLS_PATH, path], capture_output=True, text=True)\n+\n+    if result.returncode != 0:\n+        # icacls command failed. Can happen because path doesn't exist\n+        # or we're not allowed to access acl information of the path.\n+        return False\n+\n+    return does_permit_low_integrity_write(result.stdout)\n+\n+\n+def ensure_directories_exist(dirs):\n+    for dir in dirs:\n+        os.makedirs(dir, exist_ok=True)\n+\n+\n+def check_directory_acls(dirs):\n+    acls_correct = True\n+    for dir in dirs:\n+        if not path_is_low_integrity_writable(dir):\n+            logging.info(\n+                f'Directory \"{dir}\" must be writable by low integrity '\n+                \"processes for sandbox mode.\"\n+            )\n+            acls_correct = False\n+\n+    return acls_correct\n+\n+\n+def setup_permissions(dirs):\n+    \"\"\"\n+    Sets the correct low integrity write permissions for the given directories\n+    using an UAC elevation prompt. We need admin elevation because if the Comfy\n+    directory is not under the user's profile directory (e.g. any location in a\n+    non-C: drive), the regular user does not have permission to set the\n+    integrity level ACLs.\n+    \"\"\"\n+    script_dir = os.path.dirname(os.path.abspath(__file__))\n+    bat_path = os.path.join(script_dir, \"setup_sandbox_permissions.bat\")\n+\n+    execute_info = {\n+        \"lpVerb\": \"runas\",  # Run as administrator\n+        \"lpFile\": bat_path,\n+        \"lpParameters\": \" \".join(dirs),\n+        \"nShow\": win32con.SW_SHOWNORMAL,\n+        # This flag is necessary to wait for the process to finish.\n+        \"fMask\": shellcon.SEE_MASK_NOCLOSEPROCESS,\n+    }\n+\n+    # This is equivalent to right-clicking the bat file and selecting \"Run as\n+    # administrator\"\n+    proc_info = shell.ShellExecuteEx(**execute_info)\n+    hProcess = proc_info[\"hProcess\"]\n+\n+    # Setup script should less than a second. Time out at 10 seconds.\n+    win32event.WaitForSingleObject(hProcess, 10 * 1000)\n+    exit_code = win32process.GetExitCodeProcess(hProcess)\n+\n+    try:\n+        if exit_code == win32con.STATUS_PENDING:\n+            raise Exception(\"Sandbox permission script timed out\")\n+        if exit_code != 0:\n+            raise Exception(\n+                \"Sandbox permission setup script failed. \" f\"Exit code: {exit_code}\"\n+            )\n+    finally:\n+        win32api.CloseHandle(hProcess)\n+\n+\n+def try_enable_sandbox():\n+    write_permitted_dirs = [\n+        folder_paths.get_write_permitted_base_directory(),\n+        folder_paths.get_output_directory(),\n+        folder_paths.get_user_directory(),\n+    ]\n+    write_permitted_dirs.extend(folder_paths.get_folder_paths(\"custom_nodes\"))\n+\n+    ensure_directories_exist(write_permitted_dirs)\n+\n+    if check_directory_acls(write_permitted_dirs):\n+        set_process_integrity_level_to_low()\n+        return True\n+\n+    # Directory permissions are not set up correctly. Try to fix.\n+    logging.critical(\n+        \"Some directories do not have the correct permissions for sandbox mode \"\n+        \"to work. Would you like ComfyUI to fix these permissions? You will \"\n+        \"receive a UAC elevation prompt. [y/n]\"\n+    )\n+    if input() != \"y\":\n+        return False\n+\n+    setup_permissions(write_permitted_dirs)\n+\n+    # Check directory permissions again before enabling sandbox.\n+    if check_directory_acls(write_permitted_dirs):\n+        set_process_integrity_level_to_low()\n+        return True\n+\n+    # Directory permissions are still not set up correctly. Give up.",
        "comment_created_at": "2025-06-14T23:41:07+00:00",
        "comment_author": "maludwig",
        "comment_body": "Presumably add a log here explaining that the permissions are still not set up correctly even though you tried. Consider raising an exception so that calling code knows what happened.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1566987923",
    "pr_number": 2666,
    "pr_file": "comfy/graph.py",
    "created_at": "2024-04-16T08:48:46+00:00",
    "commented_code": "+import nodes\n+\n+from comfy.graph_utils import is_link\n+\n+class DynamicPrompt:\n+    def __init__(self, original_prompt):\n+        # The original prompt provided by the user\n+        self.original_prompt = original_prompt\n+        # Any extra pieces of the graph created during execution\n+        self.ephemeral_prompt = {}\n+        self.ephemeral_parents = {}\n+        self.ephemeral_display = {}\n+\n+    def get_node(self, node_id):\n+        if node_id in self.ephemeral_prompt:\n+            return self.ephemeral_prompt[node_id]\n+        if node_id in self.original_prompt:\n+            return self.original_prompt[node_id]\n+        return None\n+\n+    def add_ephemeral_node(self, node_id, node_info, parent_id, display_id):\n+        self.ephemeral_prompt[node_id] = node_info\n+        self.ephemeral_parents[node_id] = parent_id\n+        self.ephemeral_display[node_id] = display_id\n+\n+    def get_real_node_id(self, node_id):\n+        while node_id in self.ephemeral_parents:\n+            node_id = self.ephemeral_parents[node_id]\n+        return node_id\n+\n+    def get_parent_node_id(self, node_id):\n+        return self.ephemeral_parents.get(node_id, None)\n+\n+    def get_display_node_id(self, node_id):\n+        while node_id in self.ephemeral_display:\n+            node_id = self.ephemeral_display[node_id]\n+        return node_id\n+\n+    def all_node_ids(self):\n+        return set(self.original_prompt.keys()).union(set(self.ephemeral_prompt.keys()))\n+\n+def get_input_info(class_def, input_name):\n+    valid_inputs = class_def.INPUT_TYPES()\n+    input_info = None\n+    input_category = None\n+    if \"required\" in valid_inputs and input_name in valid_inputs[\"required\"]:\n+        input_category = \"required\"\n+        input_info = valid_inputs[\"required\"][input_name]\n+    elif \"optional\" in valid_inputs and input_name in valid_inputs[\"optional\"]:\n+        input_category = \"optional\"\n+        input_info = valid_inputs[\"optional\"][input_name]\n+    elif \"hidden\" in valid_inputs and input_name in valid_inputs[\"hidden\"]:\n+        input_category = \"hidden\"\n+        input_info = valid_inputs[\"hidden\"][input_name]\n+    if input_info is None:\n+        return None, None, None\n+    input_type = input_info[0]\n+    if len(input_info) > 1:\n+        extra_info = input_info[1]\n+    else:\n+        extra_info = {}\n+    return input_type, input_category, extra_info\n+\n+class TopologicalSort:\n+    def __init__(self, dynprompt):\n+        self.dynprompt = dynprompt\n+        self.pendingNodes = {}\n+        self.blockCount = {} # Number of nodes this node is directly blocked by\n+        self.blocking = {} # Which nodes are blocked by this node\n+\n+    def get_input_info(self, unique_id, input_name):\n+        class_type = self.dynprompt.get_node(unique_id)[\"class_type\"]\n+        class_def = nodes.NODE_CLASS_MAPPINGS[class_type]\n+        return get_input_info(class_def, input_name)\n+\n+    def make_input_strong_link(self, to_node_id, to_input):\n+        inputs = self.dynprompt.get_node(to_node_id)[\"inputs\"]\n+        if to_input not in inputs:\n+            raise Exception(\"Node %s says it needs input %s, but there is no input to that node at all\" % (to_node_id, to_input))\n+        value = inputs[to_input]\n+        if not is_link(value):\n+            raise Exception(\"Node %s says it needs input %s, but that value is a constant\" % (to_node_id, to_input))\n+        from_node_id, from_socket = value\n+        self.add_strong_link(from_node_id, from_socket, to_node_id)\n+\n+    def add_strong_link(self, from_node_id, from_socket, to_node_id):\n+        self.add_node(from_node_id)\n+        if to_node_id not in self.blocking[from_node_id]:\n+            self.blocking[from_node_id][to_node_id] = {}\n+            self.blockCount[to_node_id] += 1\n+        self.blocking[from_node_id][to_node_id][from_socket] = True\n+\n+    def add_node(self, unique_id, include_lazy=False, subgraph_nodes=None):\n+        if unique_id in self.pendingNodes:\n+            return\n+        self.pendingNodes[unique_id] = True\n+        self.blockCount[unique_id] = 0\n+        self.blocking[unique_id] = {}\n+\n+        inputs = self.dynprompt.get_node(unique_id)[\"inputs\"]\n+        for input_name in inputs:\n+            value = inputs[input_name]\n+            if is_link(value):\n+                from_node_id, from_socket = value\n+                if subgraph_nodes is not None and from_node_id not in subgraph_nodes:\n+                    continue\n+                input_type, input_category, input_info = self.get_input_info(unique_id, input_name)\n+                is_lazy = input_info is not None and \"lazy\" in input_info and input_info[\"lazy\"]\n+                if include_lazy or not is_lazy:\n+                    self.add_strong_link(from_node_id, from_socket, unique_id)\n+\n+    def get_ready_nodes(self):\n+        return [node_id for node_id in self.pendingNodes if self.blockCount[node_id] == 0]\n+\n+    def pop_node(self, unique_id):\n+        del self.pendingNodes[unique_id]\n+        for blocked_node_id in self.blocking[unique_id]:\n+            self.blockCount[blocked_node_id] -= 1\n+        del self.blocking[unique_id]\n+\n+    def is_empty(self):\n+        return len(self.pendingNodes) == 0\n+\n+# ExecutionList implements a topological dissolve of the graph. After a node is staged for execution,\n+# it can still be returned to the graph after having further dependencies added.\n+class ExecutionList(TopologicalSort):\n+    def __init__(self, dynprompt, output_cache):\n+        super().__init__(dynprompt)\n+        self.output_cache = output_cache\n+        self.staged_node_id = None\n+\n+    def add_strong_link(self, from_node_id, from_socket, to_node_id):\n+        if self.output_cache.get(from_node_id) is not None:\n+            # Nothing to do\n+            return\n+        super().add_strong_link(from_node_id, from_socket, to_node_id)\n+\n+    def stage_node_execution(self):\n+        assert self.staged_node_id is None\n+        if self.is_empty():\n+            return None\n+        available = self.get_ready_nodes()\n+        if len(available) == 0:\n+            raise Exception(\"Dependency cycle detected\")",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1566987923",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 2666,
        "pr_file": "comfy/graph.py",
        "discussion_id": "1566987923",
        "commented_code": "@@ -0,0 +1,172 @@\n+import nodes\n+\n+from comfy.graph_utils import is_link\n+\n+class DynamicPrompt:\n+    def __init__(self, original_prompt):\n+        # The original prompt provided by the user\n+        self.original_prompt = original_prompt\n+        # Any extra pieces of the graph created during execution\n+        self.ephemeral_prompt = {}\n+        self.ephemeral_parents = {}\n+        self.ephemeral_display = {}\n+\n+    def get_node(self, node_id):\n+        if node_id in self.ephemeral_prompt:\n+            return self.ephemeral_prompt[node_id]\n+        if node_id in self.original_prompt:\n+            return self.original_prompt[node_id]\n+        return None\n+\n+    def add_ephemeral_node(self, node_id, node_info, parent_id, display_id):\n+        self.ephemeral_prompt[node_id] = node_info\n+        self.ephemeral_parents[node_id] = parent_id\n+        self.ephemeral_display[node_id] = display_id\n+\n+    def get_real_node_id(self, node_id):\n+        while node_id in self.ephemeral_parents:\n+            node_id = self.ephemeral_parents[node_id]\n+        return node_id\n+\n+    def get_parent_node_id(self, node_id):\n+        return self.ephemeral_parents.get(node_id, None)\n+\n+    def get_display_node_id(self, node_id):\n+        while node_id in self.ephemeral_display:\n+            node_id = self.ephemeral_display[node_id]\n+        return node_id\n+\n+    def all_node_ids(self):\n+        return set(self.original_prompt.keys()).union(set(self.ephemeral_prompt.keys()))\n+\n+def get_input_info(class_def, input_name):\n+    valid_inputs = class_def.INPUT_TYPES()\n+    input_info = None\n+    input_category = None\n+    if \"required\" in valid_inputs and input_name in valid_inputs[\"required\"]:\n+        input_category = \"required\"\n+        input_info = valid_inputs[\"required\"][input_name]\n+    elif \"optional\" in valid_inputs and input_name in valid_inputs[\"optional\"]:\n+        input_category = \"optional\"\n+        input_info = valid_inputs[\"optional\"][input_name]\n+    elif \"hidden\" in valid_inputs and input_name in valid_inputs[\"hidden\"]:\n+        input_category = \"hidden\"\n+        input_info = valid_inputs[\"hidden\"][input_name]\n+    if input_info is None:\n+        return None, None, None\n+    input_type = input_info[0]\n+    if len(input_info) > 1:\n+        extra_info = input_info[1]\n+    else:\n+        extra_info = {}\n+    return input_type, input_category, extra_info\n+\n+class TopologicalSort:\n+    def __init__(self, dynprompt):\n+        self.dynprompt = dynprompt\n+        self.pendingNodes = {}\n+        self.blockCount = {} # Number of nodes this node is directly blocked by\n+        self.blocking = {} # Which nodes are blocked by this node\n+\n+    def get_input_info(self, unique_id, input_name):\n+        class_type = self.dynprompt.get_node(unique_id)[\"class_type\"]\n+        class_def = nodes.NODE_CLASS_MAPPINGS[class_type]\n+        return get_input_info(class_def, input_name)\n+\n+    def make_input_strong_link(self, to_node_id, to_input):\n+        inputs = self.dynprompt.get_node(to_node_id)[\"inputs\"]\n+        if to_input not in inputs:\n+            raise Exception(\"Node %s says it needs input %s, but there is no input to that node at all\" % (to_node_id, to_input))\n+        value = inputs[to_input]\n+        if not is_link(value):\n+            raise Exception(\"Node %s says it needs input %s, but that value is a constant\" % (to_node_id, to_input))\n+        from_node_id, from_socket = value\n+        self.add_strong_link(from_node_id, from_socket, to_node_id)\n+\n+    def add_strong_link(self, from_node_id, from_socket, to_node_id):\n+        self.add_node(from_node_id)\n+        if to_node_id not in self.blocking[from_node_id]:\n+            self.blocking[from_node_id][to_node_id] = {}\n+            self.blockCount[to_node_id] += 1\n+        self.blocking[from_node_id][to_node_id][from_socket] = True\n+\n+    def add_node(self, unique_id, include_lazy=False, subgraph_nodes=None):\n+        if unique_id in self.pendingNodes:\n+            return\n+        self.pendingNodes[unique_id] = True\n+        self.blockCount[unique_id] = 0\n+        self.blocking[unique_id] = {}\n+\n+        inputs = self.dynprompt.get_node(unique_id)[\"inputs\"]\n+        for input_name in inputs:\n+            value = inputs[input_name]\n+            if is_link(value):\n+                from_node_id, from_socket = value\n+                if subgraph_nodes is not None and from_node_id not in subgraph_nodes:\n+                    continue\n+                input_type, input_category, input_info = self.get_input_info(unique_id, input_name)\n+                is_lazy = input_info is not None and \"lazy\" in input_info and input_info[\"lazy\"]\n+                if include_lazy or not is_lazy:\n+                    self.add_strong_link(from_node_id, from_socket, unique_id)\n+\n+    def get_ready_nodes(self):\n+        return [node_id for node_id in self.pendingNodes if self.blockCount[node_id] == 0]\n+\n+    def pop_node(self, unique_id):\n+        del self.pendingNodes[unique_id]\n+        for blocked_node_id in self.blocking[unique_id]:\n+            self.blockCount[blocked_node_id] -= 1\n+        del self.blocking[unique_id]\n+\n+    def is_empty(self):\n+        return len(self.pendingNodes) == 0\n+\n+# ExecutionList implements a topological dissolve of the graph. After a node is staged for execution,\n+# it can still be returned to the graph after having further dependencies added.\n+class ExecutionList(TopologicalSort):\n+    def __init__(self, dynprompt, output_cache):\n+        super().__init__(dynprompt)\n+        self.output_cache = output_cache\n+        self.staged_node_id = None\n+\n+    def add_strong_link(self, from_node_id, from_socket, to_node_id):\n+        if self.output_cache.get(from_node_id) is not None:\n+            # Nothing to do\n+            return\n+        super().add_strong_link(from_node_id, from_socket, to_node_id)\n+\n+    def stage_node_execution(self):\n+        assert self.staged_node_id is None\n+        if self.is_empty():\n+            return None\n+        available = self.get_ready_nodes()\n+        if len(available) == 0:\n+            raise Exception(\"Dependency cycle detected\")",
        "comment_created_at": "2024-04-16T08:48:46+00:00",
        "comment_author": "kvochko",
        "comment_body": "Could you please raise a more appropriate exception type? Maybe define a new one? Also, the call to `stage_node_execution` is not wrapped in try-except, so it will probably crash the entire process.",
        "pr_file_module": null
      },
      {
        "comment_id": "1573624819",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 2666,
        "pr_file": "comfy/graph.py",
        "discussion_id": "1566987923",
        "commented_code": "@@ -0,0 +1,172 @@\n+import nodes\n+\n+from comfy.graph_utils import is_link\n+\n+class DynamicPrompt:\n+    def __init__(self, original_prompt):\n+        # The original prompt provided by the user\n+        self.original_prompt = original_prompt\n+        # Any extra pieces of the graph created during execution\n+        self.ephemeral_prompt = {}\n+        self.ephemeral_parents = {}\n+        self.ephemeral_display = {}\n+\n+    def get_node(self, node_id):\n+        if node_id in self.ephemeral_prompt:\n+            return self.ephemeral_prompt[node_id]\n+        if node_id in self.original_prompt:\n+            return self.original_prompt[node_id]\n+        return None\n+\n+    def add_ephemeral_node(self, node_id, node_info, parent_id, display_id):\n+        self.ephemeral_prompt[node_id] = node_info\n+        self.ephemeral_parents[node_id] = parent_id\n+        self.ephemeral_display[node_id] = display_id\n+\n+    def get_real_node_id(self, node_id):\n+        while node_id in self.ephemeral_parents:\n+            node_id = self.ephemeral_parents[node_id]\n+        return node_id\n+\n+    def get_parent_node_id(self, node_id):\n+        return self.ephemeral_parents.get(node_id, None)\n+\n+    def get_display_node_id(self, node_id):\n+        while node_id in self.ephemeral_display:\n+            node_id = self.ephemeral_display[node_id]\n+        return node_id\n+\n+    def all_node_ids(self):\n+        return set(self.original_prompt.keys()).union(set(self.ephemeral_prompt.keys()))\n+\n+def get_input_info(class_def, input_name):\n+    valid_inputs = class_def.INPUT_TYPES()\n+    input_info = None\n+    input_category = None\n+    if \"required\" in valid_inputs and input_name in valid_inputs[\"required\"]:\n+        input_category = \"required\"\n+        input_info = valid_inputs[\"required\"][input_name]\n+    elif \"optional\" in valid_inputs and input_name in valid_inputs[\"optional\"]:\n+        input_category = \"optional\"\n+        input_info = valid_inputs[\"optional\"][input_name]\n+    elif \"hidden\" in valid_inputs and input_name in valid_inputs[\"hidden\"]:\n+        input_category = \"hidden\"\n+        input_info = valid_inputs[\"hidden\"][input_name]\n+    if input_info is None:\n+        return None, None, None\n+    input_type = input_info[0]\n+    if len(input_info) > 1:\n+        extra_info = input_info[1]\n+    else:\n+        extra_info = {}\n+    return input_type, input_category, extra_info\n+\n+class TopologicalSort:\n+    def __init__(self, dynprompt):\n+        self.dynprompt = dynprompt\n+        self.pendingNodes = {}\n+        self.blockCount = {} # Number of nodes this node is directly blocked by\n+        self.blocking = {} # Which nodes are blocked by this node\n+\n+    def get_input_info(self, unique_id, input_name):\n+        class_type = self.dynprompt.get_node(unique_id)[\"class_type\"]\n+        class_def = nodes.NODE_CLASS_MAPPINGS[class_type]\n+        return get_input_info(class_def, input_name)\n+\n+    def make_input_strong_link(self, to_node_id, to_input):\n+        inputs = self.dynprompt.get_node(to_node_id)[\"inputs\"]\n+        if to_input not in inputs:\n+            raise Exception(\"Node %s says it needs input %s, but there is no input to that node at all\" % (to_node_id, to_input))\n+        value = inputs[to_input]\n+        if not is_link(value):\n+            raise Exception(\"Node %s says it needs input %s, but that value is a constant\" % (to_node_id, to_input))\n+        from_node_id, from_socket = value\n+        self.add_strong_link(from_node_id, from_socket, to_node_id)\n+\n+    def add_strong_link(self, from_node_id, from_socket, to_node_id):\n+        self.add_node(from_node_id)\n+        if to_node_id not in self.blocking[from_node_id]:\n+            self.blocking[from_node_id][to_node_id] = {}\n+            self.blockCount[to_node_id] += 1\n+        self.blocking[from_node_id][to_node_id][from_socket] = True\n+\n+    def add_node(self, unique_id, include_lazy=False, subgraph_nodes=None):\n+        if unique_id in self.pendingNodes:\n+            return\n+        self.pendingNodes[unique_id] = True\n+        self.blockCount[unique_id] = 0\n+        self.blocking[unique_id] = {}\n+\n+        inputs = self.dynprompt.get_node(unique_id)[\"inputs\"]\n+        for input_name in inputs:\n+            value = inputs[input_name]\n+            if is_link(value):\n+                from_node_id, from_socket = value\n+                if subgraph_nodes is not None and from_node_id not in subgraph_nodes:\n+                    continue\n+                input_type, input_category, input_info = self.get_input_info(unique_id, input_name)\n+                is_lazy = input_info is not None and \"lazy\" in input_info and input_info[\"lazy\"]\n+                if include_lazy or not is_lazy:\n+                    self.add_strong_link(from_node_id, from_socket, unique_id)\n+\n+    def get_ready_nodes(self):\n+        return [node_id for node_id in self.pendingNodes if self.blockCount[node_id] == 0]\n+\n+    def pop_node(self, unique_id):\n+        del self.pendingNodes[unique_id]\n+        for blocked_node_id in self.blocking[unique_id]:\n+            self.blockCount[blocked_node_id] -= 1\n+        del self.blocking[unique_id]\n+\n+    def is_empty(self):\n+        return len(self.pendingNodes) == 0\n+\n+# ExecutionList implements a topological dissolve of the graph. After a node is staged for execution,\n+# it can still be returned to the graph after having further dependencies added.\n+class ExecutionList(TopologicalSort):\n+    def __init__(self, dynprompt, output_cache):\n+        super().__init__(dynprompt)\n+        self.output_cache = output_cache\n+        self.staged_node_id = None\n+\n+    def add_strong_link(self, from_node_id, from_socket, to_node_id):\n+        if self.output_cache.get(from_node_id) is not None:\n+            # Nothing to do\n+            return\n+        super().add_strong_link(from_node_id, from_socket, to_node_id)\n+\n+    def stage_node_execution(self):\n+        assert self.staged_node_id is None\n+        if self.is_empty():\n+            return None\n+        available = self.get_ready_nodes()\n+        if len(available) == 0:\n+            raise Exception(\"Dependency cycle detected\")",
        "comment_created_at": "2024-04-21T05:44:11+00:00",
        "comment_author": "guill",
        "comment_body": "> Also, the call to stage_node_execution is not wrapped in try-except, so it will probably crash the entire process.\r\n\r\nGreat catch, you're absolutely right. I've fixed this as well as added unit tests that:\r\n\r\n1. A dependency cycle in the submitted graph itself will be caught during the validation phase.\r\n2. A dependency cycle created as part of a node's expansion will return a proper error to the UI.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1568293172",
    "pr_number": 2666,
    "pr_file": "execution.py",
    "created_at": "2024-04-17T06:29:53+00:00",
    "commented_code": "import threading\n import heapq\n import traceback\n+from enum import Enum\n import inspect\n from typing import List, Literal, NamedTuple, Optional\n \n import torch\n import nodes\n \n import comfy.model_management\n+import comfy.graph_utils\n+from comfy.graph import get_input_info, ExecutionList, DynamicPrompt, ExecutionBlocker\n+from comfy.graph_utils import is_link, GraphBuilder\n+from comfy.caching import HierarchicalCache, LRUCache, CacheKeySetInputSignature, CacheKeySetInputSignatureWithID, CacheKeySetID\n+from comfy.cli_args import args\n+\n+class ExecutionResult(Enum):\n+    SUCCESS = 0\n+    FAILURE = 1\n+    SLEEPING = 2\n+\n+class IsChangedCache:\n+    def __init__(self, dynprompt, outputs_cache):\n+        self.dynprompt = dynprompt\n+        self.outputs_cache = outputs_cache\n+        self.is_changed = {}\n+\n+    def get(self, node_id):\n+        if node_id not in self.is_changed:\n+            node = self.dynprompt.get_node(node_id)\n+            class_type = node[\"class_type\"]\n+            class_def = nodes.NODE_CLASS_MAPPINGS[class_type]\n+            if hasattr(class_def, \"IS_CHANGED\"):\n+                if \"is_changed\" in node:\n+                    self.is_changed[node_id] = node[\"is_changed\"]\n+                else:\n+                    input_data_all = get_input_data(node[\"inputs\"], class_def, node_id, self.outputs_cache)\n+                    try:\n+                        is_changed = map_node_over_list(class_def, input_data_all, \"IS_CHANGED\")\n+                        node[\"is_changed\"] = [None if isinstance(x, ExecutionBlocker) else x for x in is_changed]\n+                        self.is_changed[node_id] = node[\"is_changed\"]\n+                    except:\n+                        node[\"is_changed\"] = float(\"NaN\")\n+                        self.is_changed[node_id] = node[\"is_changed\"]",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1568293172",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 2666,
        "pr_file": "execution.py",
        "discussion_id": "1568293172",
        "commented_code": "@@ -4,43 +4,115 @@\n import threading\n import heapq\n import traceback\n+from enum import Enum\n import inspect\n from typing import List, Literal, NamedTuple, Optional\n \n import torch\n import nodes\n \n import comfy.model_management\n+import comfy.graph_utils\n+from comfy.graph import get_input_info, ExecutionList, DynamicPrompt, ExecutionBlocker\n+from comfy.graph_utils import is_link, GraphBuilder\n+from comfy.caching import HierarchicalCache, LRUCache, CacheKeySetInputSignature, CacheKeySetInputSignatureWithID, CacheKeySetID\n+from comfy.cli_args import args\n+\n+class ExecutionResult(Enum):\n+    SUCCESS = 0\n+    FAILURE = 1\n+    SLEEPING = 2\n+\n+class IsChangedCache:\n+    def __init__(self, dynprompt, outputs_cache):\n+        self.dynprompt = dynprompt\n+        self.outputs_cache = outputs_cache\n+        self.is_changed = {}\n+\n+    def get(self, node_id):\n+        if node_id not in self.is_changed:\n+            node = self.dynprompt.get_node(node_id)\n+            class_type = node[\"class_type\"]\n+            class_def = nodes.NODE_CLASS_MAPPINGS[class_type]\n+            if hasattr(class_def, \"IS_CHANGED\"):\n+                if \"is_changed\" in node:\n+                    self.is_changed[node_id] = node[\"is_changed\"]\n+                else:\n+                    input_data_all = get_input_data(node[\"inputs\"], class_def, node_id, self.outputs_cache)\n+                    try:\n+                        is_changed = map_node_over_list(class_def, input_data_all, \"IS_CHANGED\")\n+                        node[\"is_changed\"] = [None if isinstance(x, ExecutionBlocker) else x for x in is_changed]\n+                        self.is_changed[node_id] = node[\"is_changed\"]\n+                    except:\n+                        node[\"is_changed\"] = float(\"NaN\")\n+                        self.is_changed[node_id] = node[\"is_changed\"]",
        "comment_created_at": "2024-04-17T06:29:53+00:00",
        "comment_author": "kvochko",
        "comment_body": "I understand that the silent swallowing of all exceptions in IS_CHANGED is consistent with the current implementation, but maybe we should not?",
        "pr_file_module": null
      },
      {
        "comment_id": "1573169913",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 2666,
        "pr_file": "execution.py",
        "discussion_id": "1568293172",
        "commented_code": "@@ -4,43 +4,115 @@\n import threading\n import heapq\n import traceback\n+from enum import Enum\n import inspect\n from typing import List, Literal, NamedTuple, Optional\n \n import torch\n import nodes\n \n import comfy.model_management\n+import comfy.graph_utils\n+from comfy.graph import get_input_info, ExecutionList, DynamicPrompt, ExecutionBlocker\n+from comfy.graph_utils import is_link, GraphBuilder\n+from comfy.caching import HierarchicalCache, LRUCache, CacheKeySetInputSignature, CacheKeySetInputSignatureWithID, CacheKeySetID\n+from comfy.cli_args import args\n+\n+class ExecutionResult(Enum):\n+    SUCCESS = 0\n+    FAILURE = 1\n+    SLEEPING = 2\n+\n+class IsChangedCache:\n+    def __init__(self, dynprompt, outputs_cache):\n+        self.dynprompt = dynprompt\n+        self.outputs_cache = outputs_cache\n+        self.is_changed = {}\n+\n+    def get(self, node_id):\n+        if node_id not in self.is_changed:\n+            node = self.dynprompt.get_node(node_id)\n+            class_type = node[\"class_type\"]\n+            class_def = nodes.NODE_CLASS_MAPPINGS[class_type]\n+            if hasattr(class_def, \"IS_CHANGED\"):\n+                if \"is_changed\" in node:\n+                    self.is_changed[node_id] = node[\"is_changed\"]\n+                else:\n+                    input_data_all = get_input_data(node[\"inputs\"], class_def, node_id, self.outputs_cache)\n+                    try:\n+                        is_changed = map_node_over_list(class_def, input_data_all, \"IS_CHANGED\")\n+                        node[\"is_changed\"] = [None if isinstance(x, ExecutionBlocker) else x for x in is_changed]\n+                        self.is_changed[node_id] = node[\"is_changed\"]\n+                    except:\n+                        node[\"is_changed\"] = float(\"NaN\")\n+                        self.is_changed[node_id] = node[\"is_changed\"]",
        "comment_created_at": "2024-04-20T05:59:02+00:00",
        "comment_author": "guill",
        "comment_body": "I could definitely see a larger update to the way custom `is_changed` values are handled in the future. I think the reason this decision was originally made was due to the fact that truly 'safe' `IS_CHANGED` functions are difficult to read. This is due to the fact that the `IS_CHANGED` function is evaluated prior to actually beginning evaluation of the graph as a whole. As a result, any non-literal inputs will be `None` during the execution of this function.\r\n\r\nWe could require node authors to check every input for `None`, but this is another place where I worry that everything will seem to work just fine when a node author tests their own code (because they always use a constant filepath), but throw errors when people use the node in unexpected ways.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1727917874",
    "pr_number": 4551,
    "pr_file": "execution.py",
    "created_at": "2024-08-22T21:33:18+00:00",
    "commented_code": "result, error, ex = execute(self.server, dynamic_prompt, self.caches, node_id, extra_data, executed, prompt_id, execution_list, pending_subgraph_results)\n                 if result == ExecutionResult.FAILURE:\n                     self.handle_execution_error(prompt_id, dynamic_prompt.original_prompt, current_outputs, executed, error, ex)\n+                    self.success = False\n                     break\n                 elif result == ExecutionResult.PENDING:\n                     execution_list.unstage_node_execution()",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1727917874",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 4551,
        "pr_file": "execution.py",
        "discussion_id": "1727917874",
        "commented_code": "@@ -494,6 +494,7 @@ def execute(self, prompt, prompt_id, extra_data={}, execute_outputs=[]):\n                 result, error, ex = execute(self.server, dynamic_prompt, self.caches, node_id, extra_data, executed, prompt_id, execution_list, pending_subgraph_results)\n                 if result == ExecutionResult.FAILURE:\n                     self.handle_execution_error(prompt_id, dynamic_prompt.original_prompt, current_outputs, executed, error, ex)\n+                    self.success = False\n                     break\n                 elif result == ExecutionResult.PENDING:\n                     execution_list.unstage_node_execution()",
        "comment_created_at": "2024-08-22T21:33:18+00:00",
        "comment_author": "comfyanonymous",
        "comment_body": "Missing a: self.success = True when it succeeds.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1727926759",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 4551,
        "pr_file": "execution.py",
        "discussion_id": "1727917874",
        "commented_code": "@@ -494,6 +494,7 @@ def execute(self, prompt, prompt_id, extra_data={}, execute_outputs=[]):\n                 result, error, ex = execute(self.server, dynamic_prompt, self.caches, node_id, extra_data, executed, prompt_id, execution_list, pending_subgraph_results)\n                 if result == ExecutionResult.FAILURE:\n                     self.handle_execution_error(prompt_id, dynamic_prompt.original_prompt, current_outputs, executed, error, ex)\n+                    self.success = False\n                     break\n                 elif result == ExecutionResult.PENDING:\n                     execution_list.unstage_node_execution()",
        "comment_created_at": "2024-08-22T21:35:37+00:00",
        "comment_author": "huchenlei",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  }
]