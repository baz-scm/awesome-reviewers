[
  {
    "discussion_id": "2195807495",
    "pr_number": 8844,
    "pr_file": "execution.py",
    "created_at": "2025-07-09T19:20:45+00:00",
    "commented_code": "else:\n                 return {}\n \n+    def get_ordered_history(self, max_items=None, offset=-1):\n+        with self.mutex:\n+            out = []",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2195807495",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8844,
        "pr_file": "execution.py",
        "discussion_id": "2195807495",
        "commented_code": "@@ -1024,6 +1024,23 @@ def get_history(self, prompt_id=None, max_items=None, offset=-1):\n             else:\n                 return {}\n \n+    def get_ordered_history(self, max_items=None, offset=-1):\n+        with self.mutex:\n+            out = []",
        "comment_created_at": "2025-07-09T19:20:45+00:00",
        "comment_author": "bigcat88",
        "comment_body": "just a note: maybe using [islice](https://www.geeksforgeeks.org/python/python-itertools-islice/) will be better here(I wrote it from memory, possibly with mistakes):\r\n\r\n\r\n```python\r\nif offset < 0 and max_items is not None:\r\n    offset = max(len(self.history) - max_items, 0)\r\nend = None if max_items is None else offset + max_items\r\nsliced = islice(self.history.items(), offset, end)\r\nreturn {\"history\": [{k: v} for k, v in sliced]}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2195893879",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8844,
        "pr_file": "execution.py",
        "discussion_id": "2195807495",
        "commented_code": "@@ -1024,6 +1024,23 @@ def get_history(self, prompt_id=None, max_items=None, offset=-1):\n             else:\n                 return {}\n \n+    def get_ordered_history(self, max_items=None, offset=-1):\n+        with self.mutex:\n+            out = []",
        "comment_created_at": "2025-07-09T20:14:46+00:00",
        "comment_author": "ric-yu",
        "comment_body": "These dicts are of fairly manageable size, so I don't think we need the extra dependency from itertools. Willing to update to slice though!",
        "pr_file_module": null
      },
      {
        "comment_id": "2195958075",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8844,
        "pr_file": "execution.py",
        "discussion_id": "2195807495",
        "commented_code": "@@ -1024,6 +1024,23 @@ def get_history(self, prompt_id=None, max_items=None, offset=-1):\n             else:\n                 return {}\n \n+    def get_ordered_history(self, max_items=None, offset=-1):\n+        with self.mutex:\n+            out = []",
        "comment_created_at": "2025-07-09T20:57:11+00:00",
        "comment_author": "ric-yu",
        "comment_body": "Made this function a little more python-y, but get_history is still untouched :P",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1510608667",
    "pr_number": 2964,
    "pr_file": "execution.py",
    "created_at": "2024-03-04T05:34:32+00:00",
    "commented_code": "broadcast=False)\n             executed = set()\n             output_node_id = None\n-            to_execute = []\n \n-            for node_id in list(execute_outputs):\n-                to_execute += [(0, node_id)]\n+            to_execute = set(execute_outputs)\n \n             while len(to_execute) > 0:\n                 #always execute the output that depends on the least amount of unexecuted nodes first\n-                memo = {}\n-                to_execute = sorted(list(map(lambda a: (len(recursive_will_execute(prompt, self.outputs, a[-1], memo)), a[-1]), to_execute)))\n-                output_node_id = to_execute.pop(0)[-1]\n+                output_node_id = min(to_execute, key=lambda a: len(recursive_will_execute(prompt, self.outputs, a, {})))",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1510608667",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 2964,
        "pr_file": "execution.py",
        "discussion_id": "1510608667",
        "commented_code": "@@ -375,16 +374,13 @@ def execute(self, prompt, prompt_id, extra_data={}, execute_outputs=[]):\n                           broadcast=False)\n             executed = set()\n             output_node_id = None\n-            to_execute = []\n \n-            for node_id in list(execute_outputs):\n-                to_execute += [(0, node_id)]\n+            to_execute = set(execute_outputs)\n \n             while len(to_execute) > 0:\n                 #always execute the output that depends on the least amount of unexecuted nodes first\n-                memo = {}\n-                to_execute = sorted(list(map(lambda a: (len(recursive_will_execute(prompt, self.outputs, a[-1], memo)), a[-1]), to_execute)))\n-                output_node_id = to_execute.pop(0)[-1]\n+                output_node_id = min(to_execute, key=lambda a: len(recursive_will_execute(prompt, self.outputs, a, {})))",
        "comment_created_at": "2024-03-04T05:34:32+00:00",
        "comment_author": "comfyanonymous",
        "comment_body": "The point of passing a memo to the recursive_will_execute function is so it only needs to calculate things for each node once.",
        "pr_file_module": null
      },
      {
        "comment_id": "1511262946",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 2964,
        "pr_file": "execution.py",
        "discussion_id": "1510608667",
        "commented_code": "@@ -375,16 +374,13 @@ def execute(self, prompt, prompt_id, extra_data={}, execute_outputs=[]):\n                           broadcast=False)\n             executed = set()\n             output_node_id = None\n-            to_execute = []\n \n-            for node_id in list(execute_outputs):\n-                to_execute += [(0, node_id)]\n+            to_execute = set(execute_outputs)\n \n             while len(to_execute) > 0:\n                 #always execute the output that depends on the least amount of unexecuted nodes first\n-                memo = {}\n-                to_execute = sorted(list(map(lambda a: (len(recursive_will_execute(prompt, self.outputs, a[-1], memo)), a[-1]), to_execute)))\n-                output_node_id = to_execute.pop(0)[-1]\n+                output_node_id = min(to_execute, key=lambda a: len(recursive_will_execute(prompt, self.outputs, a, {})))",
        "comment_created_at": "2024-03-04T14:34:57+00:00",
        "comment_author": "tomKPZ",
        "comment_body": "Fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1678761678",
    "pr_number": 3402,
    "pr_file": "folder_paths.py",
    "created_at": "2024-07-16T05:04:00+00:00",
    "commented_code": "def compute_vars(input, image_width, image_height):\n         input = input.replace(\"%width%\", str(image_width))\n         input = input.replace(\"%height%\", str(image_height))\n+        input = input.replace(\"%year%\", time.strftime(\"%Y\"))\n+        input = input.replace(\"%month%\", time.strftime(\"%m\"))\n+        input = input.replace(\"%day%\", time.strftime(\"%d\"))\n         return input\n \n     filename_prefix = compute_vars(filename_prefix, image_width, image_height)",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1678761678",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 3402,
        "pr_file": "folder_paths.py",
        "discussion_id": "1678761678",
        "commented_code": "@@ -243,6 +243,9 @@ def map_filename(filename):\n     def compute_vars(input, image_width, image_height):\n         input = input.replace(\"%width%\", str(image_width))\n         input = input.replace(\"%height%\", str(image_height))\n+        input = input.replace(\"%year%\", time.strftime(\"%Y\"))\n+        input = input.replace(\"%month%\", time.strftime(\"%m\"))\n+        input = input.replace(\"%day%\", time.strftime(\"%d\"))\n         return input\n \n     filename_prefix = compute_vars(filename_prefix, image_width, image_height)",
        "comment_created_at": "2024-07-16T05:04:00+00:00",
        "comment_author": "mcmonkey4eva",
        "comment_body": "i'd suggest to add a guard here for if prefix contains `%`, so it doesn't do redundant processing if there's no vars anyway",
        "pr_file_module": null
      },
      {
        "comment_id": "1678798826",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 3402,
        "pr_file": "folder_paths.py",
        "discussion_id": "1678761678",
        "commented_code": "@@ -243,6 +243,9 @@ def map_filename(filename):\n     def compute_vars(input, image_width, image_height):\n         input = input.replace(\"%width%\", str(image_width))\n         input = input.replace(\"%height%\", str(image_height))\n+        input = input.replace(\"%year%\", time.strftime(\"%Y\"))\n+        input = input.replace(\"%month%\", time.strftime(\"%m\"))\n+        input = input.replace(\"%day%\", time.strftime(\"%d\"))\n         return input\n \n     filename_prefix = compute_vars(filename_prefix, image_width, image_height)",
        "comment_created_at": "2024-07-16T05:56:35+00:00",
        "comment_author": "andrewtvuong",
        "comment_body": "I didn't really get this part, something like this?\r\n\r\n```\r\ndef compute_vars(input, image_width, image_height, organize_by_date):\r\n    input = input.replace(\"%width%\", str(image_width))\r\n    input = input.replace(\"%height%\", str(image_height))\r\n    if organize_by_date:\r\n        current_time = time.localtime()\r\n        year = time.strftime(\"%Y\", current_time)\r\n        month = time.strftime(\"%m\", current_time)\r\n        day = time.strftime(\"%d\", current_time)\r\n        input = input.replace(\"%year%\", year)\r\n        input = input.replace(\"%month%\", month)\r\n        input = input.replace(\"%day%\", day)\r\n    return input\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1496529857",
    "pr_number": 2852,
    "pr_file": "execution.py",
    "created_at": "2024-02-20T21:22:04+00:00",
    "commented_code": "while len(to_execute) > 0:\n                 #always execute the output that depends on the least amount of unexecuted nodes first\n-                to_execute = sorted(list(map(lambda a: (len(recursive_will_execute(prompt, self.outputs, a[-1])), a[-1]), to_execute)))\n+                memo = {}",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1496529857",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 2852,
        "pr_file": "execution.py",
        "discussion_id": "1496529857",
        "commented_code": "@@ -377,7 +382,8 @@ def execute(self, prompt, prompt_id, extra_data={}, execute_outputs=[]):\n \n             while len(to_execute) > 0:\n                 #always execute the output that depends on the least amount of unexecuted nodes first\n-                to_execute = sorted(list(map(lambda a: (len(recursive_will_execute(prompt, self.outputs, a[-1])), a[-1]), to_execute)))\n+                memo = {}",
        "comment_created_at": "2024-02-20T21:22:04+00:00",
        "comment_author": "ricklove",
        "comment_body": "memo should be created outside the lambda so it is reused for entire sorting algorithm",
        "pr_file_module": null
      }
    ]
  }
]