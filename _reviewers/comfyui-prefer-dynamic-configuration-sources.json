[
  {
    "discussion_id": "2202760817",
    "pr_number": 8875,
    "pr_file": "app/frontend_management.py",
    "created_at": "2025-07-12T15:33:07+00:00",
    "commented_code": "This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2202760817",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8875,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "2202760817",
        "commented_code": "@@ -29,6 +29,26 @@ def frontend_install_warning_message():\n This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
        "comment_created_at": "2025-07-12T15:33:07+00:00",
        "comment_author": "christian-byrne",
        "comment_body": "I think for this, we could just move the previous logic from its current location in `check_frontend_version` to here. In particular, these 2 lines:\r\n\r\n```python\r\n        # After moving `parse_version` to module scope\r\n        frontend_version_str = version(\"comfyui-frontend-package\")\r\n        frontend_version = parse_version(frontend_version_str)\r\n```\r\n\r\nThis will let us use `importlib.metadata.version` function which reads from the installed packages in the python environment, so it should be a bit more robust than reading requirements.txt file, ideally.\r\n\r\nThen, we also don't have to worry about the suffix like `==1.23.4`, as it won't exist in returned value of `version` function. And we won't have to use a `is_valid_version` function since if it is installed already then it is guaranteed to be a valid version.\r\n\r\nWDYT @shivansh-gupta4?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2202858134",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8875,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "2202760817",
        "commented_code": "@@ -29,6 +29,26 @@ def frontend_install_warning_message():\n This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
        "comment_created_at": "2025-07-12T18:17:20+00:00",
        "comment_author": "shivansh-gupta4",
        "comment_body": "Thank you for the feedback and I apologize for initially missing the deployment methods. After checking the update scripts in the `.ci` folder and the CI/CD triggers, it's evident that changes to the version in `requirements.txt` will update the packages as expected.\r\n\r\nI\u2019ve made the suggested improvements in the latest commit https://github.com/comfyanonymous/ComfyUI/pull/8875/commits/b3eed4fa35073c9485a95a2a7945a1b3d32a0066. Please let me know if there\u2019s anything else I should adjust, happy to make further changes if needed. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2202867337",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8875,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "2202760817",
        "commented_code": "@@ -29,6 +29,26 @@ def frontend_install_warning_message():\n This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
        "comment_created_at": "2025-07-12T18:43:16+00:00",
        "comment_author": "christian-byrne",
        "comment_body": "LGTM! Thanks!",
        "pr_file_module": null
      },
      {
        "comment_id": "2202867866",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8875,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "2202760817",
        "commented_code": "@@ -29,6 +29,26 @@ def frontend_install_warning_message():\n This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
        "comment_created_at": "2025-07-12T18:45:50+00:00",
        "comment_author": "christian-byrne",
        "comment_body": "@shivansh-gupta4 Oh, I think I made a mistake in my comment, sorry. Maybe we also need to move the extracting of `required_frontend` to its own function as well and then we need to use that one in `server.py`. On the frontend, we can check the installed frontend version via the runtime, but we will want to know the **required** frontend that the server specifies. Sorry for the confusion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2203057712",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8875,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "2202760817",
        "commented_code": "@@ -29,6 +29,26 @@ def frontend_install_warning_message():\n This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
        "comment_created_at": "2025-07-13T02:30:39+00:00",
        "comment_author": "shivansh-gupta4",
        "comment_body": "@christian-byrne No problem at all, thanks for the clarification! Also, in this scenario, should we also check that the `required_frontend` is a valid semver or we can assume that requirements.txt will always have the version in valid semver format?",
        "pr_file_module": null
      },
      {
        "comment_id": "2203489276",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8875,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "2202760817",
        "commented_code": "@@ -29,6 +29,26 @@ def frontend_install_warning_message():\n This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
        "comment_created_at": "2025-07-13T18:38:38+00:00",
        "comment_author": "shivansh-gupta4",
        "comment_body": "@christian-byrne I have committed the required improvements in the code in https://github.com/comfyanonymous/ComfyUI/pull/8875/commits/8355adc750f5c53d55913db3d25e3e20572b564d. We are using a `is_valid_version` function to check for semver validation. Also, created the `get_required_frontend_version` function to fetch the version from the requirements.txt file in a way that the logic is not affected by disordering of dependencies, following the same logic implemented in `config_parser.py` to fetch dependencies from `pyproject.toml`. Please feel free to suggest any further improvements, I want to leave no stone unturned in getting this PR merged. With every commit, I\u2019m getting more familiar with the codebase and I\u2019m looking forward to contributing more in the future!",
        "pr_file_module": null
      },
      {
        "comment_id": "2203527658",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8875,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "2202760817",
        "commented_code": "@@ -29,6 +29,26 @@ def frontend_install_warning_message():\n This error is happening because the ComfyUI frontend is no longer shipped as part of the main repo but as a pip package instead.\n \"\"\".strip()\n \n+def is_valid_version(version: str) -> bool:\n+    \"\"\"Validate if a string is a valid semantic version (X.Y.Z format).\"\"\"\n+    pattern = r\"^(\\d+)\\.(\\d+)\\.(\\d+)$\"\n+    return bool(re.match(pattern, version))\n+\n+def get_required_frontend_version():\n+    \"\"\"Get the required frontend version from requirements.txt.\"\"\"\n+    try:\n+        with open(requirements_path, \"r\", encoding=\"utf-8\") as f:\n+            version_str = f.readline().split(\"=\")[-1].strip()\n+            if not is_valid_version(version_str):\n+                logging.error(f\"Invalid version format in requirements.txt: {version_str}\")\n+                return None\n+            return version_str\n+    except FileNotFoundError:\n+        logging.error(\"requirements.txt not found. Cannot determine required frontend version.\")\n+        return None\n+    except Exception as e:\n+        logging.error(f\"Error reading requirements.txt: {e}\")\n+        return None",
        "comment_created_at": "2025-07-13T21:23:29+00:00",
        "comment_author": "christian-byrne",
        "comment_body": "Nice, everything looks good!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2147369956",
    "pr_number": 8351,
    "pr_file": "sandbox/windows_sandbox.py",
    "created_at": "2025-06-14T22:52:16+00:00",
    "commented_code": "+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2147369956",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8351,
        "pr_file": "sandbox/windows_sandbox.py",
        "discussion_id": "2147369956",
        "commented_code": "@@ -0,0 +1,172 @@\n+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"",
        "comment_created_at": "2025-06-14T22:52:16+00:00",
        "comment_author": "maludwig",
        "comment_body": "This assumes that Windows is installed there, recommend using:\r\n\r\n```\r\nICACLS_PATH = os.path.join(win32api.GetSystemDirectory(), \"icacls.exe\")\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2144521050",
    "pr_number": 8511,
    "pr_file": "comfy/model_management.py",
    "created_at": "2025-06-13T08:48:41+00:00",
    "commented_code": "dev = get_torch_device()\n \n     if hasattr(dev, 'type') and (dev.type == 'cpu' or dev.type == 'mps'):\n-        mem_total = psutil.virtual_memory().total\n+        mem_total = -1\n+        for file in ['/sys/fs/cgroup/memory.max', '/sys/fs/cgroup/memory/memory.limit_in_bytes']:\n+            if os.path.isfile(file):\n+                with open(file, 'r') as f:\n+                    mem_total = int(f.read())",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2144521050",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8511,
        "pr_file": "comfy/model_management.py",
        "discussion_id": "2144521050",
        "commented_code": "@@ -177,7 +177,14 @@ def get_total_memory(dev=None, torch_total_too=False):\n         dev = get_torch_device()\n \n     if hasattr(dev, 'type') and (dev.type == 'cpu' or dev.type == 'mps'):\n-        mem_total = psutil.virtual_memory().total\n+        mem_total = -1\n+        for file in ['/sys/fs/cgroup/memory.max', '/sys/fs/cgroup/memory/memory.limit_in_bytes']:\n+            if os.path.isfile(file):\n+                with open(file, 'r') as f:\n+                    mem_total = int(f.read())",
        "comment_created_at": "2025-06-13T08:48:41+00:00",
        "comment_author": "bigcat88",
        "comment_body": "note: in my test docker container the `/sys/fs/cgroup/memory.max` file contains `max` and not a number inside.",
        "pr_file_module": null
      },
      {
        "comment_id": "2144681942",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8511,
        "pr_file": "comfy/model_management.py",
        "discussion_id": "2144521050",
        "commented_code": "@@ -177,7 +177,14 @@ def get_total_memory(dev=None, torch_total_too=False):\n         dev = get_torch_device()\n \n     if hasattr(dev, 'type') and (dev.type == 'cpu' or dev.type == 'mps'):\n-        mem_total = psutil.virtual_memory().total\n+        mem_total = -1\n+        for file in ['/sys/fs/cgroup/memory.max', '/sys/fs/cgroup/memory/memory.limit_in_bytes']:\n+            if os.path.isfile(file):\n+                with open(file, 'r') as f:\n+                    mem_total = int(f.read())",
        "comment_created_at": "2025-06-13T10:01:59+00:00",
        "comment_author": "j2gg0s",
        "comment_body": "Thank you very much, you were right.\r\n\r\nI reviewed the relevant code in cAdvisor and have corrected my implementation accordingly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1676767891",
    "pr_number": 3897,
    "pr_file": "app/frontend_management.py",
    "created_at": "2024-07-13T06:06:43+00:00",
    "commented_code": "+import argparse\n+import os\n+import re\n+import tempfile\n+import zipfile\n+import logging\n+from functools import cached_property\n+from typing import TypedDict\n+from dataclasses import dataclass\n+from typing_extensions import NotRequired\n+from pathlib import Path\n+\n+import requests\n+\n+\n+class Asset(TypedDict):\n+    url: str\n+\n+\n+class Release(TypedDict):\n+    id: int\n+    tag_name: str\n+    name: str\n+    prerelease: bool\n+    created_at: str\n+    published_at: str\n+    body: str\n+    assets: NotRequired[list[Asset]]\n+\n+\n+@dataclass\n+class FrontEndProvider:\n+    name: str\n+    owner: str\n+    repo: str\n+\n+    @property\n+    def release_url(self) -> str:\n+        return f\"https://api.github.com/repos/{self.owner}/{self.repo}/releases\"\n+\n+    @cached_property\n+    def all_releases(self) -> list[Release]:\n+        releases = []\n+        api_url = self.release_url\n+        while api_url:\n+            response = requests.get(api_url)\n+            response.raise_for_status()  # Raises an HTTPError if the response was an error\n+            releases.extend(response.json())\n+            # GitHub uses the Link header to provide pagination links. Check if it exists and update api_url accordingly.\n+            if \"next\" in response.links:\n+                api_url = response.links[\"next\"][\"url\"]\n+            else:\n+                api_url = None\n+        return releases\n+\n+    @cached_property\n+    def latest_release(self) -> Release:\n+        latest_release_url = f\"{self.release_url}/latest\"\n+        response = requests.get(latest_release_url)\n+        response.raise_for_status()  # Raises an HTTPError if the response was an error\n+        return response.json()\n+\n+    def get_release(self, version: str) -> Release:\n+        if version == \"latest\":\n+            return self.latest_release\n+        else:\n+            for release in self.all_releases:\n+                if release[\"tag_name\"] in [version, f\"v{version}\"]:\n+                    return release\n+            raise ValueError(f\"Version {version} not found in releases\")\n+\n+\n+def download_release_asset_zip(release: Release, destination_path: str) -> None:\n+    \"\"\"Download dist.zip from github release.\"\"\"\n+    asset_url = None\n+    for asset in release.get(\"assets\", []):\n+        if asset[\"name\"] == \"dist.zip\":\n+            asset_url = asset[\"url\"]\n+            break\n+\n+    if not asset_url:\n+        raise ValueError(\"dist.zip not found in the release assets\")\n+\n+    # Use a temporary file to download the zip content\n+    with tempfile.TemporaryFile() as tmp_file:\n+        headers = {\"Accept\": \"application/octet-stream\"}\n+        response = requests.get(asset_url, headers=headers, allow_redirects=True)\n+        response.raise_for_status()  # Ensure we got a successful response\n+\n+        # Write the content to the temporary file\n+        tmp_file.write(response.content)\n+\n+        # Go back to the beginning of the temporary file\n+        tmp_file.seek(0)\n+\n+        # Extract the zip file content to the destination path\n+        with zipfile.ZipFile(tmp_file, \"r\") as zip_ref:\n+            zip_ref.extractall(destination_path)\n+\n+\n+class FrontendManager:\n+    # The default built-in provider hosted under web/\n+    DEFAULT_VERSION_STRING = \"legacy@latest\"\n+    DEFAULT_FRONTEND_PATH = str(Path(__file__).parents[1] / \"web\")\n+    CUSTOM_FRONTENDS_ROOT = str(Path(__file__).parents[1] / \"web_custom_versions\")\n+\n+    PROVIDERS = [\n+        FrontEndProvider(",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1676767891",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 3897,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "1676767891",
        "commented_code": "@@ -0,0 +1,210 @@\n+import argparse\n+import os\n+import re\n+import tempfile\n+import zipfile\n+import logging\n+from functools import cached_property\n+from typing import TypedDict\n+from dataclasses import dataclass\n+from typing_extensions import NotRequired\n+from pathlib import Path\n+\n+import requests\n+\n+\n+class Asset(TypedDict):\n+    url: str\n+\n+\n+class Release(TypedDict):\n+    id: int\n+    tag_name: str\n+    name: str\n+    prerelease: bool\n+    created_at: str\n+    published_at: str\n+    body: str\n+    assets: NotRequired[list[Asset]]\n+\n+\n+@dataclass\n+class FrontEndProvider:\n+    name: str\n+    owner: str\n+    repo: str\n+\n+    @property\n+    def release_url(self) -> str:\n+        return f\"https://api.github.com/repos/{self.owner}/{self.repo}/releases\"\n+\n+    @cached_property\n+    def all_releases(self) -> list[Release]:\n+        releases = []\n+        api_url = self.release_url\n+        while api_url:\n+            response = requests.get(api_url)\n+            response.raise_for_status()  # Raises an HTTPError if the response was an error\n+            releases.extend(response.json())\n+            # GitHub uses the Link header to provide pagination links. Check if it exists and update api_url accordingly.\n+            if \"next\" in response.links:\n+                api_url = response.links[\"next\"][\"url\"]\n+            else:\n+                api_url = None\n+        return releases\n+\n+    @cached_property\n+    def latest_release(self) -> Release:\n+        latest_release_url = f\"{self.release_url}/latest\"\n+        response = requests.get(latest_release_url)\n+        response.raise_for_status()  # Raises an HTTPError if the response was an error\n+        return response.json()\n+\n+    def get_release(self, version: str) -> Release:\n+        if version == \"latest\":\n+            return self.latest_release\n+        else:\n+            for release in self.all_releases:\n+                if release[\"tag_name\"] in [version, f\"v{version}\"]:\n+                    return release\n+            raise ValueError(f\"Version {version} not found in releases\")\n+\n+\n+def download_release_asset_zip(release: Release, destination_path: str) -> None:\n+    \"\"\"Download dist.zip from github release.\"\"\"\n+    asset_url = None\n+    for asset in release.get(\"assets\", []):\n+        if asset[\"name\"] == \"dist.zip\":\n+            asset_url = asset[\"url\"]\n+            break\n+\n+    if not asset_url:\n+        raise ValueError(\"dist.zip not found in the release assets\")\n+\n+    # Use a temporary file to download the zip content\n+    with tempfile.TemporaryFile() as tmp_file:\n+        headers = {\"Accept\": \"application/octet-stream\"}\n+        response = requests.get(asset_url, headers=headers, allow_redirects=True)\n+        response.raise_for_status()  # Ensure we got a successful response\n+\n+        # Write the content to the temporary file\n+        tmp_file.write(response.content)\n+\n+        # Go back to the beginning of the temporary file\n+        tmp_file.seek(0)\n+\n+        # Extract the zip file content to the destination path\n+        with zipfile.ZipFile(tmp_file, \"r\") as zip_ref:\n+            zip_ref.extractall(destination_path)\n+\n+\n+class FrontendManager:\n+    # The default built-in provider hosted under web/\n+    DEFAULT_VERSION_STRING = \"legacy@latest\"\n+    DEFAULT_FRONTEND_PATH = str(Path(__file__).parents[1] / \"web\")\n+    CUSTOM_FRONTENDS_ROOT = str(Path(__file__).parents[1] / \"web_custom_versions\")\n+\n+    PROVIDERS = [\n+        FrontEndProvider(",
        "comment_created_at": "2024-07-13T06:06:43+00:00",
        "comment_author": "comfyanonymous",
        "comment_body": "Why does there need to be a hardcoded list of providers?",
        "pr_file_module": null
      },
      {
        "comment_id": "1676821278",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 3897,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "1676767891",
        "commented_code": "@@ -0,0 +1,210 @@\n+import argparse\n+import os\n+import re\n+import tempfile\n+import zipfile\n+import logging\n+from functools import cached_property\n+from typing import TypedDict\n+from dataclasses import dataclass\n+from typing_extensions import NotRequired\n+from pathlib import Path\n+\n+import requests\n+\n+\n+class Asset(TypedDict):\n+    url: str\n+\n+\n+class Release(TypedDict):\n+    id: int\n+    tag_name: str\n+    name: str\n+    prerelease: bool\n+    created_at: str\n+    published_at: str\n+    body: str\n+    assets: NotRequired[list[Asset]]\n+\n+\n+@dataclass\n+class FrontEndProvider:\n+    name: str\n+    owner: str\n+    repo: str\n+\n+    @property\n+    def release_url(self) -> str:\n+        return f\"https://api.github.com/repos/{self.owner}/{self.repo}/releases\"\n+\n+    @cached_property\n+    def all_releases(self) -> list[Release]:\n+        releases = []\n+        api_url = self.release_url\n+        while api_url:\n+            response = requests.get(api_url)\n+            response.raise_for_status()  # Raises an HTTPError if the response was an error\n+            releases.extend(response.json())\n+            # GitHub uses the Link header to provide pagination links. Check if it exists and update api_url accordingly.\n+            if \"next\" in response.links:\n+                api_url = response.links[\"next\"][\"url\"]\n+            else:\n+                api_url = None\n+        return releases\n+\n+    @cached_property\n+    def latest_release(self) -> Release:\n+        latest_release_url = f\"{self.release_url}/latest\"\n+        response = requests.get(latest_release_url)\n+        response.raise_for_status()  # Raises an HTTPError if the response was an error\n+        return response.json()\n+\n+    def get_release(self, version: str) -> Release:\n+        if version == \"latest\":\n+            return self.latest_release\n+        else:\n+            for release in self.all_releases:\n+                if release[\"tag_name\"] in [version, f\"v{version}\"]:\n+                    return release\n+            raise ValueError(f\"Version {version} not found in releases\")\n+\n+\n+def download_release_asset_zip(release: Release, destination_path: str) -> None:\n+    \"\"\"Download dist.zip from github release.\"\"\"\n+    asset_url = None\n+    for asset in release.get(\"assets\", []):\n+        if asset[\"name\"] == \"dist.zip\":\n+            asset_url = asset[\"url\"]\n+            break\n+\n+    if not asset_url:\n+        raise ValueError(\"dist.zip not found in the release assets\")\n+\n+    # Use a temporary file to download the zip content\n+    with tempfile.TemporaryFile() as tmp_file:\n+        headers = {\"Accept\": \"application/octet-stream\"}\n+        response = requests.get(asset_url, headers=headers, allow_redirects=True)\n+        response.raise_for_status()  # Ensure we got a successful response\n+\n+        # Write the content to the temporary file\n+        tmp_file.write(response.content)\n+\n+        # Go back to the beginning of the temporary file\n+        tmp_file.seek(0)\n+\n+        # Extract the zip file content to the destination path\n+        with zipfile.ZipFile(tmp_file, \"r\") as zip_ref:\n+            zip_ref.extractall(destination_path)\n+\n+\n+class FrontendManager:\n+    # The default built-in provider hosted under web/\n+    DEFAULT_VERSION_STRING = \"legacy@latest\"\n+    DEFAULT_FRONTEND_PATH = str(Path(__file__).parents[1] / \"web\")\n+    CUSTOM_FRONTENDS_ROOT = str(Path(__file__).parents[1] / \"web_custom_versions\")\n+\n+    PROVIDERS = [\n+        FrontEndProvider(",
        "comment_created_at": "2024-07-13T12:48:01+00:00",
        "comment_author": "huchenlei",
        "comment_body": "What concerns do you have on hardcoded provider list? I don't think it's necessary to make the provider list loaded dynamically. At least for now.",
        "pr_file_module": null
      },
      {
        "comment_id": "1678217663",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 3897,
        "pr_file": "app/frontend_management.py",
        "discussion_id": "1676767891",
        "commented_code": "@@ -0,0 +1,210 @@\n+import argparse\n+import os\n+import re\n+import tempfile\n+import zipfile\n+import logging\n+from functools import cached_property\n+from typing import TypedDict\n+from dataclasses import dataclass\n+from typing_extensions import NotRequired\n+from pathlib import Path\n+\n+import requests\n+\n+\n+class Asset(TypedDict):\n+    url: str\n+\n+\n+class Release(TypedDict):\n+    id: int\n+    tag_name: str\n+    name: str\n+    prerelease: bool\n+    created_at: str\n+    published_at: str\n+    body: str\n+    assets: NotRequired[list[Asset]]\n+\n+\n+@dataclass\n+class FrontEndProvider:\n+    name: str\n+    owner: str\n+    repo: str\n+\n+    @property\n+    def release_url(self) -> str:\n+        return f\"https://api.github.com/repos/{self.owner}/{self.repo}/releases\"\n+\n+    @cached_property\n+    def all_releases(self) -> list[Release]:\n+        releases = []\n+        api_url = self.release_url\n+        while api_url:\n+            response = requests.get(api_url)\n+            response.raise_for_status()  # Raises an HTTPError if the response was an error\n+            releases.extend(response.json())\n+            # GitHub uses the Link header to provide pagination links. Check if it exists and update api_url accordingly.\n+            if \"next\" in response.links:\n+                api_url = response.links[\"next\"][\"url\"]\n+            else:\n+                api_url = None\n+        return releases\n+\n+    @cached_property\n+    def latest_release(self) -> Release:\n+        latest_release_url = f\"{self.release_url}/latest\"\n+        response = requests.get(latest_release_url)\n+        response.raise_for_status()  # Raises an HTTPError if the response was an error\n+        return response.json()\n+\n+    def get_release(self, version: str) -> Release:\n+        if version == \"latest\":\n+            return self.latest_release\n+        else:\n+            for release in self.all_releases:\n+                if release[\"tag_name\"] in [version, f\"v{version}\"]:\n+                    return release\n+            raise ValueError(f\"Version {version} not found in releases\")\n+\n+\n+def download_release_asset_zip(release: Release, destination_path: str) -> None:\n+    \"\"\"Download dist.zip from github release.\"\"\"\n+    asset_url = None\n+    for asset in release.get(\"assets\", []):\n+        if asset[\"name\"] == \"dist.zip\":\n+            asset_url = asset[\"url\"]\n+            break\n+\n+    if not asset_url:\n+        raise ValueError(\"dist.zip not found in the release assets\")\n+\n+    # Use a temporary file to download the zip content\n+    with tempfile.TemporaryFile() as tmp_file:\n+        headers = {\"Accept\": \"application/octet-stream\"}\n+        response = requests.get(asset_url, headers=headers, allow_redirects=True)\n+        response.raise_for_status()  # Ensure we got a successful response\n+\n+        # Write the content to the temporary file\n+        tmp_file.write(response.content)\n+\n+        # Go back to the beginning of the temporary file\n+        tmp_file.seek(0)\n+\n+        # Extract the zip file content to the destination path\n+        with zipfile.ZipFile(tmp_file, \"r\") as zip_ref:\n+            zip_ref.extractall(destination_path)\n+\n+\n+class FrontendManager:\n+    # The default built-in provider hosted under web/\n+    DEFAULT_VERSION_STRING = \"legacy@latest\"\n+    DEFAULT_FRONTEND_PATH = str(Path(__file__).parents[1] / \"web\")\n+    CUSTOM_FRONTENDS_ROOT = str(Path(__file__).parents[1] / \"web_custom_versions\")\n+\n+    PROVIDERS = [\n+        FrontEndProvider(",
        "comment_created_at": "2024-07-15T18:11:59+00:00",
        "comment_author": "huchenlei",
        "comment_body": "Offline discussion: Get rid of provider list and let peope directly use URL to specify frontend provider.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1104800825",
    "pr_number": 10,
    "pr_file": "nodes.py",
    "created_at": "2023-02-13T17:23:15+00:00",
    "commented_code": "\"CLIPLoader\": CLIPLoader,\n }\n \n-\n+def load_custom_nodes():\n+    possible_modules = os.listdir(\"custom_nodes\")",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1104800825",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 10,
        "pr_file": "nodes.py",
        "discussion_id": "1104800825",
        "commented_code": "@@ -597,4 +598,18 @@ def upscale(self, image, upscale_method, width, height, crop):\n     \"CLIPLoader\": CLIPLoader,\n }\n \n-\n+def load_custom_nodes():\n+    possible_modules = os.listdir(\"custom_nodes\")",
        "comment_created_at": "2023-02-13T17:23:15+00:00",
        "comment_author": "comfyanonymous",
        "comment_body": "Use something like this for the path so it works even when the user isn't running it from the comfyui directory.\r\n```os.path.join(os.path.dirname(os.path.realpath(__file__)), \"custom_nodes\")```",
        "pr_file_module": null
      },
      {
        "comment_id": "1105973426",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 10,
        "pr_file": "nodes.py",
        "discussion_id": "1104800825",
        "commented_code": "@@ -597,4 +598,18 @@ def upscale(self, image, upscale_method, width, height, crop):\n     \"CLIPLoader\": CLIPLoader,\n }\n \n-\n+def load_custom_nodes():\n+    possible_modules = os.listdir(\"custom_nodes\")",
        "comment_created_at": "2023-02-14T15:22:14+00:00",
        "comment_author": "Fannovel16",
        "comment_body": "Thanks for your advice \ud83d\udc4d",
        "pr_file_module": null
      }
    ]
  }
]