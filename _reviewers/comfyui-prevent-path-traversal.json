[
  {
    "discussion_id": "2147376029",
    "pr_number": 8351,
    "pr_file": "sandbox/windows_sandbox.py",
    "created_at": "2025-06-14T23:34:12+00:00",
    "commented_code": "+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"\n+\n+\n+def set_process_integrity_level_to_low():\n+    current_process = win32process.GetCurrentProcess()\n+    token = win32security.OpenProcessToken(\n+        current_process,\n+        win32con.TOKEN_ALL_ACCESS,\n+    )\n+\n+    low_integrity_sid = win32security.ConvertStringSidToSid(LOW_INTEGRITY_SID_STRING)\n+    win32security.SetTokenInformation(\n+        token, win32security.TokenIntegrityLevel, (low_integrity_sid, 0)\n+    )\n+\n+    logging.info(\"Sandbox enabled: Process now running with low integrity token\")\n+\n+    win32api.CloseHandle(token)\n+\n+\n+def does_permit_low_integrity_write(icacls_output):\n+    \"\"\"\n+    Checks if an icacls output indicates that the path is writable by low\n+    integrity processes.\n+\n+    Note that currently it is a bit of a crude check - it is possible for\n+    a low integrity process to have write access to a directory without\n+    having these exact ACLs reported by icacls. Implement a more robust\n+    check if this situation ever occurs.\n+    \"\"\"\n+    permissions = [l.strip() for l in icacls_output.split(\"\n\")]\n+    LOW_INTEGRITY_LABEL = r\"Mandatory Label\\Low Mandatory Level\"\n+\n+    for p in permissions:\n+        if LOW_INTEGRITY_LABEL not in p:\n+            continue\n+\n+        # Check the Low integrity label line - it should be something like\n+        # Mandatory Label\\Low Mandatory Level:(OI)(CI)(NW) or\n+        # Mandatory Label\\Low Mandatory Level:(I)(OI)(CI)(NW)\n+        return all(\n+            [\n+                # OI: Object Inheritance - all files in the directory with have low\n+                # integrity\n+                \"(OI)\" in p,\n+                # CI: Container Inheritance - all subdirectories will have low\n+                # integrity\n+                \"(CI)\" in p,\n+                # NW: No Writeup - processes with lower integrity cannot write to\n+                # this directory\n+                \"(NW)\" in p,\n+            ]\n+        )\n+\n+\n+def path_is_low_integrity_writable(path):\n+    \"\"\"Check if the path has a writable ACL by low integrity process\"\"\"\n+    result = subprocess.run([ICACLS_PATH, path], capture_output=True, text=True)\n+\n+    if result.returncode != 0:\n+        # icacls command failed. Can happen because path doesn't exist\n+        # or we're not allowed to access acl information of the path.\n+        return False\n+\n+    return does_permit_low_integrity_write(result.stdout)\n+\n+\n+def ensure_directories_exist(dirs):\n+    for dir in dirs:\n+        os.makedirs(dir, exist_ok=True)\n+\n+\n+def check_directory_acls(dirs):\n+    acls_correct = True\n+    for dir in dirs:\n+        if not path_is_low_integrity_writable(dir):\n+            logging.info(\n+                f'Directory \"{dir}\" must be writable by low integrity '\n+                \"processes for sandbox mode.\"\n+            )\n+            acls_correct = False\n+\n+    return acls_correct\n+\n+\n+def setup_permissions(dirs):\n+    \"\"\"\n+    Sets the correct low integrity write permissions for the given directories\n+    using an UAC elevation prompt. We need admin elevation because if the Comfy\n+    directory is not under the user's profile directory (e.g. any location in a\n+    non-C: drive), the regular user does not have permission to set the\n+    integrity level ACLs.\n+    \"\"\"\n+    script_dir = os.path.dirname(os.path.abspath(__file__))\n+    bat_path = os.path.join(script_dir, \"setup_sandbox_permissions.bat\")\n+\n+    execute_info = {\n+        \"lpVerb\": \"runas\",  # Run as administrator\n+        \"lpFile\": bat_path,\n+        \"lpParameters\": \" \".join(dirs),\n+        \"nShow\": win32con.SW_SHOWNORMAL,\n+        # This flag is necessary to wait for the process to finish.\n+        \"fMask\": shellcon.SEE_MASK_NOCLOSEPROCESS,\n+    }\n+\n+    # This is equivalent to right-clicking the bat file and selecting \"Run as\n+    # administrator\"\n+    proc_info = shell.ShellExecuteEx(**execute_info)\n+    hProcess = proc_info[\"hProcess\"]\n+\n+    # Setup script should less than a second. Time out at 10 seconds.\n+    win32event.WaitForSingleObject(hProcess, 10 * 1000)\n+    exit_code = win32process.GetExitCodeProcess(hProcess)\n+\n+    try:\n+        if exit_code == win32con.STATUS_PENDING:\n+            raise Exception(\"Sandbox permission script timed out\")\n+        if exit_code != 0:\n+            raise Exception(\n+                \"Sandbox permission setup script failed. \" f\"Exit code: {exit_code}\"\n+            )\n+    finally:\n+        win32api.CloseHandle(hProcess)\n+\n+\n+def try_enable_sandbox():\n+    write_permitted_dirs = [\n+        folder_paths.get_write_permitted_base_directory(),\n+        folder_paths.get_output_directory(),\n+        folder_paths.get_user_directory(),\n+    ]\n+    write_permitted_dirs.extend(folder_paths.get_folder_paths(\"custom_nodes\"))",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2147376029",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8351,
        "pr_file": "sandbox/windows_sandbox.py",
        "discussion_id": "2147376029",
        "commented_code": "@@ -0,0 +1,172 @@\n+import logging\n+import win32con\n+import win32process\n+import win32security\n+import subprocess\n+import os\n+from win32com.shell import shellcon, shell\n+import win32api\n+import win32event\n+import folder_paths\n+\n+\n+LOW_INTEGRITY_SID_STRING = \"S-1-16-4096\"\n+\n+# Use absolute path to prevent command injection\n+ICACLS_PATH = r\"C:\\Windows\\System32\\icacls.exe\"\n+\n+\n+def set_process_integrity_level_to_low():\n+    current_process = win32process.GetCurrentProcess()\n+    token = win32security.OpenProcessToken(\n+        current_process,\n+        win32con.TOKEN_ALL_ACCESS,\n+    )\n+\n+    low_integrity_sid = win32security.ConvertStringSidToSid(LOW_INTEGRITY_SID_STRING)\n+    win32security.SetTokenInformation(\n+        token, win32security.TokenIntegrityLevel, (low_integrity_sid, 0)\n+    )\n+\n+    logging.info(\"Sandbox enabled: Process now running with low integrity token\")\n+\n+    win32api.CloseHandle(token)\n+\n+\n+def does_permit_low_integrity_write(icacls_output):\n+    \"\"\"\n+    Checks if an icacls output indicates that the path is writable by low\n+    integrity processes.\n+\n+    Note that currently it is a bit of a crude check - it is possible for\n+    a low integrity process to have write access to a directory without\n+    having these exact ACLs reported by icacls. Implement a more robust\n+    check if this situation ever occurs.\n+    \"\"\"\n+    permissions = [l.strip() for l in icacls_output.split(\"\\n\")]\n+    LOW_INTEGRITY_LABEL = r\"Mandatory Label\\Low Mandatory Level\"\n+\n+    for p in permissions:\n+        if LOW_INTEGRITY_LABEL not in p:\n+            continue\n+\n+        # Check the Low integrity label line - it should be something like\n+        # Mandatory Label\\Low Mandatory Level:(OI)(CI)(NW) or\n+        # Mandatory Label\\Low Mandatory Level:(I)(OI)(CI)(NW)\n+        return all(\n+            [\n+                # OI: Object Inheritance - all files in the directory with have low\n+                # integrity\n+                \"(OI)\" in p,\n+                # CI: Container Inheritance - all subdirectories will have low\n+                # integrity\n+                \"(CI)\" in p,\n+                # NW: No Writeup - processes with lower integrity cannot write to\n+                # this directory\n+                \"(NW)\" in p,\n+            ]\n+        )\n+\n+\n+def path_is_low_integrity_writable(path):\n+    \"\"\"Check if the path has a writable ACL by low integrity process\"\"\"\n+    result = subprocess.run([ICACLS_PATH, path], capture_output=True, text=True)\n+\n+    if result.returncode != 0:\n+        # icacls command failed. Can happen because path doesn't exist\n+        # or we're not allowed to access acl information of the path.\n+        return False\n+\n+    return does_permit_low_integrity_write(result.stdout)\n+\n+\n+def ensure_directories_exist(dirs):\n+    for dir in dirs:\n+        os.makedirs(dir, exist_ok=True)\n+\n+\n+def check_directory_acls(dirs):\n+    acls_correct = True\n+    for dir in dirs:\n+        if not path_is_low_integrity_writable(dir):\n+            logging.info(\n+                f'Directory \"{dir}\" must be writable by low integrity '\n+                \"processes for sandbox mode.\"\n+            )\n+            acls_correct = False\n+\n+    return acls_correct\n+\n+\n+def setup_permissions(dirs):\n+    \"\"\"\n+    Sets the correct low integrity write permissions for the given directories\n+    using an UAC elevation prompt. We need admin elevation because if the Comfy\n+    directory is not under the user's profile directory (e.g. any location in a\n+    non-C: drive), the regular user does not have permission to set the\n+    integrity level ACLs.\n+    \"\"\"\n+    script_dir = os.path.dirname(os.path.abspath(__file__))\n+    bat_path = os.path.join(script_dir, \"setup_sandbox_permissions.bat\")\n+\n+    execute_info = {\n+        \"lpVerb\": \"runas\",  # Run as administrator\n+        \"lpFile\": bat_path,\n+        \"lpParameters\": \" \".join(dirs),\n+        \"nShow\": win32con.SW_SHOWNORMAL,\n+        # This flag is necessary to wait for the process to finish.\n+        \"fMask\": shellcon.SEE_MASK_NOCLOSEPROCESS,\n+    }\n+\n+    # This is equivalent to right-clicking the bat file and selecting \"Run as\n+    # administrator\"\n+    proc_info = shell.ShellExecuteEx(**execute_info)\n+    hProcess = proc_info[\"hProcess\"]\n+\n+    # Setup script should less than a second. Time out at 10 seconds.\n+    win32event.WaitForSingleObject(hProcess, 10 * 1000)\n+    exit_code = win32process.GetExitCodeProcess(hProcess)\n+\n+    try:\n+        if exit_code == win32con.STATUS_PENDING:\n+            raise Exception(\"Sandbox permission script timed out\")\n+        if exit_code != 0:\n+            raise Exception(\n+                \"Sandbox permission setup script failed. \" f\"Exit code: {exit_code}\"\n+            )\n+    finally:\n+        win32api.CloseHandle(hProcess)\n+\n+\n+def try_enable_sandbox():\n+    write_permitted_dirs = [\n+        folder_paths.get_write_permitted_base_directory(),\n+        folder_paths.get_output_directory(),\n+        folder_paths.get_user_directory(),\n+    ]\n+    write_permitted_dirs.extend(folder_paths.get_folder_paths(\"custom_nodes\"))",
        "comment_created_at": "2025-06-14T23:34:12+00:00",
        "comment_author": "maludwig",
        "comment_body": "I think this would allow malicious code to write to other custom nodes. For example, it could overwrite Comfy Manager's files with new python code that does whatever they want it to, so if Comfy was later invoked without the sandbox flag, now the malicious code could execute.\r\n\r\nI would consider being more explicit, and only allowing writes to particular specific directories in sandbox mode. Like perhaps `custom_nodes/*/sandbox` or `custom_nodes/*/unsafe`. You don't want untrusted code to be able to do something like:\r\n\r\n```python\r\nfor custom_node_dir in folder_paths.get_folder_paths(\"custom_nodes\"):\r\n  with open(join(custom_node_dir, '__init__.py') as pyfile:\r\n    pyfile.write(EVIL_BAD_CODE)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2147380480",
    "pr_number": 8351,
    "pr_file": "main.py",
    "created_at": "2025-06-15T00:01:45+00:00",
    "commented_code": "folder_paths.set_user_directory(user_dir)\n \n \n+def try_enable_sandbox():\n+    if any([\n+        args.output_directory,\n+        args.user_directory,\n+        args.base_directory,\n+        args.temp_directory\n+    ]):\n+        # Note: If we ever support custom directories, we should warn users if\n+        # the directories are in a senstive location (e.g. a high level\n+        # directory like C:\\ or the user's home directory).\n+        raise Exception(\"Sandbox mode is not supported when using --output-directory, \"",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "2147380480",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 8351,
        "pr_file": "main.py",
        "discussion_id": "2147380480",
        "commented_code": "@@ -54,6 +54,26 @@ def apply_custom_paths():\n         folder_paths.set_user_directory(user_dir)\n \n \n+def try_enable_sandbox():\n+    if any([\n+        args.output_directory,\n+        args.user_directory,\n+        args.base_directory,\n+        args.temp_directory\n+    ]):\n+        # Note: If we ever support custom directories, we should warn users if\n+        # the directories are in a senstive location (e.g. a high level\n+        # directory like C:\\ or the user's home directory).\n+        raise Exception(\"Sandbox mode is not supported when using --output-directory, \"",
        "comment_created_at": "2025-06-15T00:01:45+00:00",
        "comment_author": "maludwig",
        "comment_body": "This is a really good note. Setting the user's entire home directory to Low would be horrendous.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1710330542",
    "pr_number": 4248,
    "pr_file": "model_filemanager/download_models.py",
    "created_at": "2024-08-08T21:39:53+00:00",
    "commented_code": "+from __future__ import annotations\n+import aiohttp\n+import os\n+import traceback\n+import logging\n+from folder_paths import models_dir\n+import re\n+from typing import Callable, Any, Optional, Awaitable, Dict\n+from enum import Enum\n+import time\n+from dataclasses import dataclass\n+\n+\n+class DownloadStatusType(Enum):\n+    PENDING = \"pending\"\n+    IN_PROGRESS = \"in_progress\"\n+    COMPLETED = \"completed\"\n+    ERROR = \"error\"\n+\n+@dataclass\n+class DownloadModelStatus():\n+    status: str\n+    progress_percentage: float\n+    message: str\n+    already_existed: bool = False\n+\n+    def __init__(self, status: DownloadStatusType, progress_percentage: float, message: str, already_existed: bool):\n+        self.status = status.value  # Store the string value of the Enum\n+        self.progress_percentage = progress_percentage\n+        self.message = message\n+        self.already_existed = already_existed\n+    \n+    def to_dict(self) -> Dict[str, Any]:\n+        return {\n+            \"status\": self.status,\n+            \"progress_percentage\": self.progress_percentage,\n+            \"message\": self.message,\n+            \"already_existed\": self.already_existed\n+        }\n+\n+async def download_model(model_download_request: Callable[[str], Awaitable[aiohttp.ClientResponse]],\n+                         model_name: str,  \n+                         model_url: str, \n+                         model_sub_directory: str,\n+                         progress_callback: Callable[[str, DownloadModelStatus], Awaitable[Any]],\n+                         progress_interval: float = 1.0) -> DownloadModelStatus:\n+    \"\"\"\n+    Download a model file from a given URL into the models directory.\n+\n+    Args:\n+        model_download_request (Callable[[str], Awaitable[aiohttp.ClientResponse]]): \n+            A function that makes an HTTP request. This makes it easier to mock in unit tests.\n+        model_name (str): \n+            The name of the model file to be downloaded. This will be the filename on disk.\n+        model_url (str): \n+            The URL from which to download the model.\n+        model_sub_directory (str): \n+            The subdirectory within the main models directory where the model \n+            should be saved (e.g., 'checkpoints', 'loras', etc.).\n+        progress_callback (Callable[[str, DownloadModelStatus], Awaitable[Any]]): \n+            An asynchronous function to call with progress updates.\n+\n+    Returns:\n+        DownloadModelStatus: The result of the download operation.\n+    \"\"\"\n+    if not validate_model_subdirectory(model_sub_directory):\n+        return DownloadModelStatus(\n+            DownloadStatusType.ERROR, \n+            0,\n+            \"Invalid model subdirectory\", \n+            False\n+        )\n+\n+    file_path, relative_path = create_model_path(model_name, model_sub_directory, models_dir)",
    "repo_full_name": "comfyanonymous/ComfyUI",
    "discussion_comments": [
      {
        "comment_id": "1710330542",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 4248,
        "pr_file": "model_filemanager/download_models.py",
        "discussion_id": "1710330542",
        "commented_code": "@@ -0,0 +1,189 @@\n+from __future__ import annotations\n+import aiohttp\n+import os\n+import traceback\n+import logging\n+from folder_paths import models_dir\n+import re\n+from typing import Callable, Any, Optional, Awaitable, Dict\n+from enum import Enum\n+import time\n+from dataclasses import dataclass\n+\n+\n+class DownloadStatusType(Enum):\n+    PENDING = \"pending\"\n+    IN_PROGRESS = \"in_progress\"\n+    COMPLETED = \"completed\"\n+    ERROR = \"error\"\n+\n+@dataclass\n+class DownloadModelStatus():\n+    status: str\n+    progress_percentage: float\n+    message: str\n+    already_existed: bool = False\n+\n+    def __init__(self, status: DownloadStatusType, progress_percentage: float, message: str, already_existed: bool):\n+        self.status = status.value  # Store the string value of the Enum\n+        self.progress_percentage = progress_percentage\n+        self.message = message\n+        self.already_existed = already_existed\n+    \n+    def to_dict(self) -> Dict[str, Any]:\n+        return {\n+            \"status\": self.status,\n+            \"progress_percentage\": self.progress_percentage,\n+            \"message\": self.message,\n+            \"already_existed\": self.already_existed\n+        }\n+\n+async def download_model(model_download_request: Callable[[str], Awaitable[aiohttp.ClientResponse]],\n+                         model_name: str,  \n+                         model_url: str, \n+                         model_sub_directory: str,\n+                         progress_callback: Callable[[str, DownloadModelStatus], Awaitable[Any]],\n+                         progress_interval: float = 1.0) -> DownloadModelStatus:\n+    \"\"\"\n+    Download a model file from a given URL into the models directory.\n+\n+    Args:\n+        model_download_request (Callable[[str], Awaitable[aiohttp.ClientResponse]]): \n+            A function that makes an HTTP request. This makes it easier to mock in unit tests.\n+        model_name (str): \n+            The name of the model file to be downloaded. This will be the filename on disk.\n+        model_url (str): \n+            The URL from which to download the model.\n+        model_sub_directory (str): \n+            The subdirectory within the main models directory where the model \n+            should be saved (e.g., 'checkpoints', 'loras', etc.).\n+        progress_callback (Callable[[str, DownloadModelStatus], Awaitable[Any]]): \n+            An asynchronous function to call with progress updates.\n+\n+    Returns:\n+        DownloadModelStatus: The result of the download operation.\n+    \"\"\"\n+    if not validate_model_subdirectory(model_sub_directory):\n+        return DownloadModelStatus(\n+            DownloadStatusType.ERROR, \n+            0,\n+            \"Invalid model subdirectory\", \n+            False\n+        )\n+\n+    file_path, relative_path = create_model_path(model_name, model_sub_directory, models_dir)",
        "comment_created_at": "2024-08-08T21:39:53+00:00",
        "comment_author": "mcmonkey4eva",
        "comment_body": "the model sub directory is validated, but the model name never is - so the model name itself could just be `../../../../passwd` or something",
        "pr_file_module": null
      },
      {
        "comment_id": "1710419081",
        "repo_full_name": "comfyanonymous/ComfyUI",
        "pr_number": 4248,
        "pr_file": "model_filemanager/download_models.py",
        "discussion_id": "1710330542",
        "commented_code": "@@ -0,0 +1,189 @@\n+from __future__ import annotations\n+import aiohttp\n+import os\n+import traceback\n+import logging\n+from folder_paths import models_dir\n+import re\n+from typing import Callable, Any, Optional, Awaitable, Dict\n+from enum import Enum\n+import time\n+from dataclasses import dataclass\n+\n+\n+class DownloadStatusType(Enum):\n+    PENDING = \"pending\"\n+    IN_PROGRESS = \"in_progress\"\n+    COMPLETED = \"completed\"\n+    ERROR = \"error\"\n+\n+@dataclass\n+class DownloadModelStatus():\n+    status: str\n+    progress_percentage: float\n+    message: str\n+    already_existed: bool = False\n+\n+    def __init__(self, status: DownloadStatusType, progress_percentage: float, message: str, already_existed: bool):\n+        self.status = status.value  # Store the string value of the Enum\n+        self.progress_percentage = progress_percentage\n+        self.message = message\n+        self.already_existed = already_existed\n+    \n+    def to_dict(self) -> Dict[str, Any]:\n+        return {\n+            \"status\": self.status,\n+            \"progress_percentage\": self.progress_percentage,\n+            \"message\": self.message,\n+            \"already_existed\": self.already_existed\n+        }\n+\n+async def download_model(model_download_request: Callable[[str], Awaitable[aiohttp.ClientResponse]],\n+                         model_name: str,  \n+                         model_url: str, \n+                         model_sub_directory: str,\n+                         progress_callback: Callable[[str, DownloadModelStatus], Awaitable[Any]],\n+                         progress_interval: float = 1.0) -> DownloadModelStatus:\n+    \"\"\"\n+    Download a model file from a given URL into the models directory.\n+\n+    Args:\n+        model_download_request (Callable[[str], Awaitable[aiohttp.ClientResponse]]): \n+            A function that makes an HTTP request. This makes it easier to mock in unit tests.\n+        model_name (str): \n+            The name of the model file to be downloaded. This will be the filename on disk.\n+        model_url (str): \n+            The URL from which to download the model.\n+        model_sub_directory (str): \n+            The subdirectory within the main models directory where the model \n+            should be saved (e.g., 'checkpoints', 'loras', etc.).\n+        progress_callback (Callable[[str, DownloadModelStatus], Awaitable[Any]]): \n+            An asynchronous function to call with progress updates.\n+\n+    Returns:\n+        DownloadModelStatus: The result of the download operation.\n+    \"\"\"\n+    if not validate_model_subdirectory(model_sub_directory):\n+        return DownloadModelStatus(\n+            DownloadStatusType.ERROR, \n+            0,\n+            \"Invalid model subdirectory\", \n+            False\n+        )\n+\n+    file_path, relative_path = create_model_path(model_name, model_sub_directory, models_dir)",
        "comment_created_at": "2024-08-08T23:19:03+00:00",
        "comment_author": "robinjhuang",
        "comment_body": "Good point. Added a step to validate the filename as well. And checking that the final file path is within the base models directory.",
        "pr_file_module": null
      }
    ]
  }
]