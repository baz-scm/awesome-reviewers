[
  {
    "discussion_id": "39676713",
    "pr_number": 2051,
    "pr_file": "compose/config/config.py",
    "created_at": "2015-09-16T19:53:28+00:00",
    "commented_code": "log.warn(\"%s is deprecated and will not be supported in future. \"\n                  \"Please rename your config file to docker-compose.yml\n\" % winner)\n \n-    return os.path.join(path, winner)\n+    return [os.path.join(path, winner)] + get_default_override_file(path)\n+\n+\n+def get_default_override_file(path):\n+    override_filename = os.path.join(path, DEFAULT_OVERRIDE_FILENAME)\n+    return [override_filename] if os.path.exists(override_filename) else []",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "39676713",
        "repo_full_name": "docker/compose",
        "pr_number": 2051,
        "pr_file": "compose/config/config.py",
        "discussion_id": "39676713",
        "commented_code": "@@ -122,7 +129,31 @@ def get_config_path(base_dir):\n         log.warn(\"%s is deprecated and will not be supported in future. \"\n                  \"Please rename your config file to docker-compose.yml\\n\" % winner)\n \n-    return os.path.join(path, winner)\n+    return [os.path.join(path, winner)] + get_default_override_file(path)\n+\n+\n+def get_default_override_file(path):\n+    override_filename = os.path.join(path, DEFAULT_OVERRIDE_FILENAME)\n+    return [override_filename] if os.path.exists(override_filename) else []",
        "comment_created_at": "2015-09-16T19:53:28+00:00",
        "comment_author": "dnephin",
        "comment_body": "We don't currently log anything about which file is picked if we hit the defaults. A `log.debug()` might be good for debugging.\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "420603077",
    "pr_number": 7430,
    "pr_file": "compose/service.py",
    "created_at": "2020-05-06T07:47:25+00:00",
    "commented_code": "return progress_stream.get_digest_from_pull(event_stream)\n \n     def push(self, ignore_push_failures=False):\n-        if 'image' not in self.options or 'build' not in self.options:\n+        if not self.can_be_pushed():",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "420603077",
        "repo_full_name": "docker/compose",
        "pr_number": 7430,
        "pr_file": "compose/service.py",
        "discussion_id": "420603077",
        "commented_code": "@@ -1250,7 +1256,7 @@ def pull(self, ignore_pull_failures=False, silent=False, stream=False):\n         return progress_stream.get_digest_from_pull(event_stream)\n \n     def push(self, ignore_push_failures=False):\n-        if 'image' not in self.options or 'build' not in self.options:\n+        if not self.can_be_pushed():",
        "comment_created_at": "2020-05-06T07:47:25+00:00",
        "comment_author": "thaJeztah",
        "comment_body": "Wondering; should we log something if the service _does_ have an `image:` specified, but either doesn't have `build:` or image has a _digest_ set (to give some clue why the image for a service wasn't pushed)?",
        "pr_file_module": null
      },
      {
        "comment_id": "420660583",
        "repo_full_name": "docker/compose",
        "pr_number": 7430,
        "pr_file": "compose/service.py",
        "discussion_id": "420603077",
        "commented_code": "@@ -1250,7 +1256,7 @@ def pull(self, ignore_pull_failures=False, silent=False, stream=False):\n         return progress_stream.get_digest_from_pull(event_stream)\n \n     def push(self, ignore_push_failures=False):\n-        if 'image' not in self.options or 'build' not in self.options:\n+        if not self.can_be_pushed():",
        "comment_created_at": "2020-05-06T09:33:13+00:00",
        "comment_author": "musikov",
        "comment_body": "It would be great to have logs!\r\nFor services without `build` and|or `image` just info log, that they were skipped.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "43063549",
    "pr_number": 2254,
    "pr_file": "compose/service.py",
    "created_at": "2015-10-26T22:38:35+00:00",
    "commented_code": "def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            log_stream = None\n+            if container.has_api_logs and not detached:\n+                log_stream = container.attach(stdout=True, stderr=True, stream=True)\n+\n             self.start_container(container)\n \n-            return [container]\n+            return zip([container], [log_stream])",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "43063549",
        "repo_full_name": "docker/compose",
        "pr_number": 2254,
        "pr_file": "compose/service.py",
        "discussion_id": "43063549",
        "commented_code": "@@ -395,49 +395,80 @@ def _containers_have_diverged(self, containers):\n     def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            log_stream = None\n+            if container.has_api_logs and not detached:\n+                log_stream = container.attach(stdout=True, stderr=True, stream=True)\n+\n             self.start_container(container)\n \n-            return [container]\n+            return zip([container], [log_stream])",
        "comment_created_at": "2015-10-26T22:38:35+00:00",
        "comment_author": "dnephin",
        "comment_body": "It would be really awesome if we could keep the same return value. I think a lot of the complexity in this change is having to accommodate this difference.\n\nSince our log_stream comes from a container, I think we could make it a method on Container.\n\n``` python\n\nclass Container(object):\n    def __init__(self, ...):\n       ...\n       self._log_stream = None\n\n\n    def init_log_stream(self):\n        if not container.has_api_logs:\n            return\n        self._log_stream = self.attach(stdout=True, stderr=True, stream=True)\n\n    def get_log_stream(self):\n        return self._log_stream\n```\n\nIt's unfortunate that it wouldn't be immutable , but Container isn't immutable as it is, so I guess that's not so bad.\n\nIn this function I think we'll be able to restore the returning of just a list of containers, and it can do:\n\n``` python\n    if not detached:\n        container.init_log_stream()\n```\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "43143524",
    "pr_number": 2254,
    "pr_file": "compose/service.py",
    "created_at": "2015-10-27T16:06:13+00:00",
    "commented_code": "def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            if container.has_api_logs and not detached:\n+                container.attach_log_stream()",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "43143524",
        "repo_full_name": "docker/compose",
        "pr_number": 2254,
        "pr_file": "compose/service.py",
        "discussion_id": "43143524",
        "commented_code": "@@ -395,27 +395,57 @@ def _containers_have_diverged(self, containers):\n     def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            if container.has_api_logs and not detached:\n+                container.attach_log_stream()",
        "comment_created_at": "2015-10-27T16:06:13+00:00",
        "comment_author": "dnephin",
        "comment_body": "`attach_log_stream()` already checks for `has_api_logs()` (which I think is a good place to do it), so I think we can remove it from here and do just `if not detached:`\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "43144800",
    "pr_number": 2254,
    "pr_file": "compose/service.py",
    "created_at": "2015-10-27T16:15:19+00:00",
    "commented_code": "def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            if container.has_api_logs and not detached:\n+                container.attach_log_stream()\n+\n             self.start_container(container)\n \n             return [container]\n \n         elif action == 'recreate':\n-            return [\n-                self.recreate_container(\n-                    c,\n-                    timeout=timeout\n+            # de-couple recreate_container by copying it here for this use\n+            # case to work with ability to attach log_stream *before* we\n+            # create a container\n+            recreated_containers = []\n+            for container in containers:\n+                log.info(\"Recreating %s\" % container.name)\n+                # stop\n+                container.stop(timeout=timeout)\n+                container.rename_to_tmp_name()\n+                # create\n+                new_container = self.create_container(\n+                    do_build=False,\n+                    previous_container=container,\n+                    number=container.labels.get(LABEL_CONTAINER_NUMBER),\n+                    quiet=True,\n                 )\n-                for c in containers\n-            ]\n+\n+                # attach\n+                if new_container.has_api_logs and not detached:\n+                    new_container.attach_log_stream()\n+                recreated_containers.append(new_container)\n+\n+                # restart\n+                self.start_container(new_container)\n+                container.remove()\n+\n+            return recreated_containers\n \n         elif action == 'start':\n-            for c in containers:\n-                self.start_container_if_stopped(c)\n+            for container in containers:\n+                if not container.is_running:\n+                    if container.has_api_logs and not detached:\n+                        container.attach_log_stream()\n+\n+                    log.info(\"Starting %s\" % container.name)\n+                    self.start_container(container)",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "43144800",
        "repo_full_name": "docker/compose",
        "pr_number": 2254,
        "pr_file": "compose/service.py",
        "discussion_id": "43144800",
        "commented_code": "@@ -395,27 +395,57 @@ def _containers_have_diverged(self, containers):\n     def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            if container.has_api_logs and not detached:\n+                container.attach_log_stream()\n+\n             self.start_container(container)\n \n             return [container]\n \n         elif action == 'recreate':\n-            return [\n-                self.recreate_container(\n-                    c,\n-                    timeout=timeout\n+            # de-couple recreate_container by copying it here for this use\n+            # case to work with ability to attach log_stream *before* we\n+            # create a container\n+            recreated_containers = []\n+            for container in containers:\n+                log.info(\"Recreating %s\" % container.name)\n+                # stop\n+                container.stop(timeout=timeout)\n+                container.rename_to_tmp_name()\n+                # create\n+                new_container = self.create_container(\n+                    do_build=False,\n+                    previous_container=container,\n+                    number=container.labels.get(LABEL_CONTAINER_NUMBER),\n+                    quiet=True,\n                 )\n-                for c in containers\n-            ]\n+\n+                # attach\n+                if new_container.has_api_logs and not detached:\n+                    new_container.attach_log_stream()\n+                recreated_containers.append(new_container)\n+\n+                # restart\n+                self.start_container(new_container)\n+                container.remove()\n+\n+            return recreated_containers\n \n         elif action == 'start':\n-            for c in containers:\n-                self.start_container_if_stopped(c)\n+            for container in containers:\n+                if not container.is_running:\n+                    if container.has_api_logs and not detached:\n+                        container.attach_log_stream()\n+\n+                    log.info(\"Starting %s\" % container.name)\n+                    self.start_container(container)",
        "comment_created_at": "2015-10-27T16:15:19+00:00",
        "comment_author": "dnephin",
        "comment_body": "If we add a flag `attach_logs` to `start_container_if_stopped()` which calls this. I think this would be:\n\n``` python\n\nfor container in containers:\n    self.start_container_if_stopped(container, attach_logs=not detached)\n```\n\nwhich removes the need to duplicate anything\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "43146031",
    "pr_number": 2254,
    "pr_file": "compose/service.py",
    "created_at": "2015-10-27T16:23:22+00:00",
    "commented_code": "def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            if container.has_api_logs and not detached:\n+                container.attach_log_stream()\n+\n             self.start_container(container)\n \n             return [container]\n \n         elif action == 'recreate':\n-            return [\n-                self.recreate_container(\n-                    c,\n-                    timeout=timeout\n+            # de-couple recreate_container by copying it here for this use\n+            # case to work with ability to attach log_stream *before* we\n+            # create a container\n+            recreated_containers = []\n+            for container in containers:\n+                log.info(\"Recreating %s\" % container.name)\n+                # stop\n+                container.stop(timeout=timeout)\n+                container.rename_to_tmp_name()\n+                # create\n+                new_container = self.create_container(\n+                    do_build=False,\n+                    previous_container=container,\n+                    number=container.labels.get(LABEL_CONTAINER_NUMBER),\n+                    quiet=True,\n                 )\n-                for c in containers\n-            ]\n+\n+                # attach\n+                if new_container.has_api_logs and not detached:\n+                    new_container.attach_log_stream()\n+                recreated_containers.append(new_container)\n+\n+                # restart\n+                self.start_container(new_container)\n+                container.remove()\n+\n+            return recreated_containers",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "43146031",
        "repo_full_name": "docker/compose",
        "pr_number": 2254,
        "pr_file": "compose/service.py",
        "discussion_id": "43146031",
        "commented_code": "@@ -395,27 +395,57 @@ def _containers_have_diverged(self, containers):\n     def execute_convergence_plan(self,\n                                  plan,\n                                  do_build=True,\n-                                 timeout=DEFAULT_TIMEOUT):\n+                                 timeout=DEFAULT_TIMEOUT,\n+                                 detached=False):\n         (action, containers) = plan\n \n         if action == 'create':\n             container = self.create_container(do_build=do_build)\n+\n+            if container.has_api_logs and not detached:\n+                container.attach_log_stream()\n+\n             self.start_container(container)\n \n             return [container]\n \n         elif action == 'recreate':\n-            return [\n-                self.recreate_container(\n-                    c,\n-                    timeout=timeout\n+            # de-couple recreate_container by copying it here for this use\n+            # case to work with ability to attach log_stream *before* we\n+            # create a container\n+            recreated_containers = []\n+            for container in containers:\n+                log.info(\"Recreating %s\" % container.name)\n+                # stop\n+                container.stop(timeout=timeout)\n+                container.rename_to_tmp_name()\n+                # create\n+                new_container = self.create_container(\n+                    do_build=False,\n+                    previous_container=container,\n+                    number=container.labels.get(LABEL_CONTAINER_NUMBER),\n+                    quiet=True,\n                 )\n-                for c in containers\n-            ]\n+\n+                # attach\n+                if new_container.has_api_logs and not detached:\n+                    new_container.attach_log_stream()\n+                recreated_containers.append(new_container)\n+\n+                # restart\n+                self.start_container(new_container)\n+                container.remove()\n+\n+            return recreated_containers",
        "comment_created_at": "2015-10-27T16:23:22+00:00",
        "comment_author": "dnephin",
        "comment_body": "I think we can do the same thing here.\n\nIf we add a flag `attach_logs` to `recreate_container()` which calls `attach_log_stream()`. I think this would be:\n\n``` python\n\nreturn [\n    self.recreate_container(container, timeout=timeout, attach_logs=not detached)\n    for container in containers\n]\n```\n\nwhich removes the need to duplicate anything\n",
        "pr_file_module": null
      }
    ]
  }
]