[
  {
    "discussion_id": "2034728030",
    "pr_number": 12722,
    "pr_file": "pkg/compose/create.go",
    "created_at": "2025-04-09T07:58:51+00:00",
    "commented_code": "// `Mount` is preferred but does not offer option to created host path if missing\n \t\t\t// so `Bind` API is used here with raw volume string\n \t\t\t// see https://github.com/moby/moby/issues/43483\n-\t\t\tfor _, v := range service.Volumes {\n-\t\t\t\tif v.Target == m.Target {\n-\t\t\t\t\tswitch {\n-\t\t\t\t\tcase string(m.Type) != v.Type:\n-\t\t\t\t\t\tv.Source = m.Source\n-\t\t\t\t\t\tfallthrough\n-\t\t\t\t\tcase !requireMountAPI(v.Bind):\n-\t\t\t\t\t\tbinds = append(binds, v.String())\n-\t\t\t\t\t\tcontinue MOUNTS\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tv := findVolumeByTarget(service.Volumes, m.Target)\n+\t\t\tif v == nil {\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t\tswitch {\n+\t\t\tcase v.Type != types.VolumeTypeBind:\n+\t\t\t\tv.Source = m.Source\n+\t\t\t\tfallthrough\n+\t\t\tcase !requireMountAPI(v.Bind):\n+\t\t\t\tvol := findVolumeByName(p.Volumes, m.Source)\n+\t\t\t\tbinds = append(binds, toBindString(vol.Name, v))\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t}\n+\t\tif m.Type == mount.TypeVolume {\n+\t\t\tv := findVolumeByTarget(service.Volumes, m.Target)\n+\t\t\tif v == nil {\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t\tvol := findVolumeByName(p.Volumes, m.Source)\n+\t\t\tif vol.Driver == \"local\" && vol.DriverOpts[\"o\"] == \"bind\" {",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "2034728030",
        "repo_full_name": "docker/compose",
        "pr_number": 12722,
        "pr_file": "pkg/compose/create.go",
        "discussion_id": "2034728030",
        "commented_code": "@@ -858,24 +858,73 @@ MOUNTS:\n \t\t\t// `Mount` is preferred but does not offer option to created host path if missing\n \t\t\t// so `Bind` API is used here with raw volume string\n \t\t\t// see https://github.com/moby/moby/issues/43483\n-\t\t\tfor _, v := range service.Volumes {\n-\t\t\t\tif v.Target == m.Target {\n-\t\t\t\t\tswitch {\n-\t\t\t\t\tcase string(m.Type) != v.Type:\n-\t\t\t\t\t\tv.Source = m.Source\n-\t\t\t\t\t\tfallthrough\n-\t\t\t\t\tcase !requireMountAPI(v.Bind):\n-\t\t\t\t\t\tbinds = append(binds, v.String())\n-\t\t\t\t\t\tcontinue MOUNTS\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tv := findVolumeByTarget(service.Volumes, m.Target)\n+\t\t\tif v == nil {\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t\tswitch {\n+\t\t\tcase v.Type != types.VolumeTypeBind:\n+\t\t\t\tv.Source = m.Source\n+\t\t\t\tfallthrough\n+\t\t\tcase !requireMountAPI(v.Bind):\n+\t\t\t\tvol := findVolumeByName(p.Volumes, m.Source)\n+\t\t\t\tbinds = append(binds, toBindString(vol.Name, v))\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t}\n+\t\tif m.Type == mount.TypeVolume {\n+\t\t\tv := findVolumeByTarget(service.Volumes, m.Target)\n+\t\t\tif v == nil {\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t\tvol := findVolumeByName(p.Volumes, m.Source)\n+\t\t\tif vol.Driver == \"local\" && vol.DriverOpts[\"o\"] == \"bind\" {",
        "comment_created_at": "2025-04-09T07:58:51+00:00",
        "comment_author": "thaJeztah",
        "comment_body": "I think the trick also requires `--opt type=none` ",
        "pr_file_module": null
      },
      {
        "comment_id": "2034763630",
        "repo_full_name": "docker/compose",
        "pr_number": 12722,
        "pr_file": "pkg/compose/create.go",
        "discussion_id": "2034728030",
        "commented_code": "@@ -858,24 +858,73 @@ MOUNTS:\n \t\t\t// `Mount` is preferred but does not offer option to created host path if missing\n \t\t\t// so `Bind` API is used here with raw volume string\n \t\t\t// see https://github.com/moby/moby/issues/43483\n-\t\t\tfor _, v := range service.Volumes {\n-\t\t\t\tif v.Target == m.Target {\n-\t\t\t\t\tswitch {\n-\t\t\t\t\tcase string(m.Type) != v.Type:\n-\t\t\t\t\t\tv.Source = m.Source\n-\t\t\t\t\t\tfallthrough\n-\t\t\t\t\tcase !requireMountAPI(v.Bind):\n-\t\t\t\t\t\tbinds = append(binds, v.String())\n-\t\t\t\t\t\tcontinue MOUNTS\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tv := findVolumeByTarget(service.Volumes, m.Target)\n+\t\t\tif v == nil {\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t\tswitch {\n+\t\t\tcase v.Type != types.VolumeTypeBind:\n+\t\t\t\tv.Source = m.Source\n+\t\t\t\tfallthrough\n+\t\t\tcase !requireMountAPI(v.Bind):\n+\t\t\t\tvol := findVolumeByName(p.Volumes, m.Source)\n+\t\t\t\tbinds = append(binds, toBindString(vol.Name, v))\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t}\n+\t\tif m.Type == mount.TypeVolume {\n+\t\t\tv := findVolumeByTarget(service.Volumes, m.Target)\n+\t\t\tif v == nil {\n+\t\t\t\tcontinue MOUNTS\n+\t\t\t}\n+\t\t\tvol := findVolumeByName(p.Volumes, m.Source)\n+\t\t\tif vol.Driver == \"local\" && vol.DriverOpts[\"o\"] == \"bind\" {",
        "comment_created_at": "2025-04-09T08:18:49+00:00",
        "comment_author": "ndeloof",
        "comment_body": "This hack is also supported for long by compose (https://github.com/docker/compose/blob/v1/compose/config/config.py#L494-L498) and relies on `o=bind` and `device` option being set\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1204757114",
    "pr_number": 10612,
    "pr_file": "pkg/compose/down.go",
    "created_at": "2023-05-24T21:02:35+00:00",
    "commented_code": "func (s *composeService) ensureNetworksDown(ctx context.Context, project *types.Project, w progress.Writer) []downOp {\n \tvar ops []downOp\n-\tfor _, n := range project.Networks {\n+\tfor key, n := range project.Networks {\n \t\tif n.External.External {\n \t\t\tcontinue\n \t\t}\n \t\t// loop capture variable for op closure\n+\t\tnetworkKey := key\n \t\tnetworkName := n.Name\n \t\tops = append(ops, func() error {\n-\t\t\treturn s.removeNetwork(ctx, networkName, w)\n+\t\t\treturn s.removeNetwork(ctx, networkKey, project.Name, networkName, w)\n \t\t})\n \t}\n \treturn ops\n }\n \n-func (s *composeService) removeNetwork(ctx context.Context, name string, w progress.Writer) error {\n+func (s *composeService) removeNetwork(ctx context.Context, networkName string, projectName string, name string, w progress.Writer) error {\n \t// networks are guaranteed to have unique IDs but NOT names, so it's\n \t// possible to get into a situation where a compose down will fail with\n \t// an error along the lines of:\n \t// \tfailed to remove network test: Error response from daemon: network test is ambiguous (2 matches found based on name)\n \t// as a workaround here, the delete is done by ID after doing a list using\n \t// the name as a filter (99.9% of the time this will return a single result)\n \tnetworks, err := s.apiClient().NetworkList(ctx, moby.NetworkListOptions{\n-\t\tFilters: filters.NewArgs(filters.Arg(\"name\", name)),\n+\t\tFilters: filters.NewArgs(\n+\t\t\tprojectFilter(projectName),\n+\t\t\tnetworkFilter(networkName),\n+\t\t\tfilters.Arg(\"name\", name)),\n \t})\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, fmt.Sprintf(\"failed to inspect network %s\", name))\n+\t\treturn errors.Wrapf(err, \"failed to list networks\")\n \t}\n+\n+\t// NetworkList API doesn't return the exact name match, so we can retrieve more than one network with a request\n+\tnetworks = utils.Filter(networks, func(net moby.NetworkResource) bool {\n+\t\treturn net.Name == name\n+\t})",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1204757114",
        "repo_full_name": "docker/compose",
        "pr_number": 10612,
        "pr_file": "pkg/compose/down.go",
        "discussion_id": "1204757114",
        "commented_code": "@@ -148,32 +148,42 @@ func (s *composeService) ensureImagesDown(ctx context.Context, project *types.Pr\n \n func (s *composeService) ensureNetworksDown(ctx context.Context, project *types.Project, w progress.Writer) []downOp {\n \tvar ops []downOp\n-\tfor _, n := range project.Networks {\n+\tfor key, n := range project.Networks {\n \t\tif n.External.External {\n \t\t\tcontinue\n \t\t}\n \t\t// loop capture variable for op closure\n+\t\tnetworkKey := key\n \t\tnetworkName := n.Name\n \t\tops = append(ops, func() error {\n-\t\t\treturn s.removeNetwork(ctx, networkName, w)\n+\t\t\treturn s.removeNetwork(ctx, networkKey, project.Name, networkName, w)\n \t\t})\n \t}\n \treturn ops\n }\n \n-func (s *composeService) removeNetwork(ctx context.Context, name string, w progress.Writer) error {\n+func (s *composeService) removeNetwork(ctx context.Context, networkName string, projectName string, name string, w progress.Writer) error {\n \t// networks are guaranteed to have unique IDs but NOT names, so it's\n \t// possible to get into a situation where a compose down will fail with\n \t// an error along the lines of:\n \t// \tfailed to remove network test: Error response from daemon: network test is ambiguous (2 matches found based on name)\n \t// as a workaround here, the delete is done by ID after doing a list using\n \t// the name as a filter (99.9% of the time this will return a single result)\n \tnetworks, err := s.apiClient().NetworkList(ctx, moby.NetworkListOptions{\n-\t\tFilters: filters.NewArgs(filters.Arg(\"name\", name)),\n+\t\tFilters: filters.NewArgs(\n+\t\t\tprojectFilter(projectName),\n+\t\t\tnetworkFilter(networkName),\n+\t\t\tfilters.Arg(\"name\", name)),\n \t})\n \tif err != nil {\n-\t\treturn errors.Wrapf(err, fmt.Sprintf(\"failed to inspect network %s\", name))\n+\t\treturn errors.Wrapf(err, \"failed to list networks\")\n \t}\n+\n+\t// NetworkList API doesn't return the exact name match, so we can retrieve more than one network with a request\n+\tnetworks = utils.Filter(networks, func(net moby.NetworkResource) bool {\n+\t\treturn net.Name == name\n+\t})",
        "comment_created_at": "2023-05-24T21:02:35+00:00",
        "comment_author": "milas",
        "comment_body": "This is unnecessary - `NetworkList` with a name filter works reliably, it's `NetworkInspect` that does prefix matching",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1211748286",
    "pr_number": 10612,
    "pr_file": "pkg/compose/create.go",
    "created_at": "2023-05-31T13:47:12+00:00",
    "commented_code": "return aliases\n }\n \n-func (s *composeService) ensureNetwork(ctx context.Context, n types.NetworkConfig) error {\n-\t// NetworkInspect will match on ID prefix, so NetworkList with a name\n-\t// filter is used to look for an exact match to prevent e.g. a network\n-\t// named `db` from getting erroneously matched to a network with an ID\n-\t// like `db9086999caf`\n+func (s *composeService) ensureNetwork(ctx context.Context, n *types.NetworkConfig) error {\n+\tif n.External.External {\n+\t\treturn s.resolveExternalNetwork(ctx, n)\n+\t}\n+\n+\terr := s.resolveOrCreateNetwork(ctx, n)\n+\tif errdefs.IsConflict(err) {\n+\t\t// Maybe another execution of `docker compose up|run` created same network\n+\t\t// let's retry once\n+\t\treturn s.resolveOrCreateNetwork(ctx, n)\n+\t}\n+\treturn err\n+}\n+\n+func (s *composeService) resolveOrCreateNetwork(ctx context.Context, n *types.NetworkConfig) error { //nolint:gocyclo\n+\texpectedNetworkLabel := n.Labels[api.NetworkLabel]\n+\texpectedProjectLabel := n.Labels[api.ProjectLabel]\n+\n+\t// First, try to find a unique network matching by name or ID\n+\tinspect, err := s.apiClient().NetworkInspect(ctx, n.Name, moby.NetworkInspectOptions{})\n+\tif err == nil {\n+\t\t// NetworkInspect will match on ID prefix, so double check we get the expected one\n+\t\t// as looking for network named `db` we could erroneously matched network ID `db9086999caf`\n+\t\tif inspect.Name == n.Name || inspect.ID == n.Name {\n+\t\t\tif inspect.Labels[api.ProjectLabel] != expectedProjectLabel {\n+\t\t\t\tlogrus.Warnf(\"a network with name %s exists but was not created by compose.\n\"+\n+\t\t\t\t\t\"Set `external: true` to use a network you created\", n.Name)\n+\t\t\t}\n+\t\t\tif inspect.Labels[api.NetworkLabel] != expectedNetworkLabel {\n+\t\t\t\treturn fmt.Errorf(\"network %s was found but has incorrect label %s set to %q\", n.Name, api.NetworkLabel, inspect.Labels[api.NetworkLabel])\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\t// ignore other errors. Typically, an ambiguous request by name results in some generic `invalidParameter` error\n+\n+\t// Either not found, or name is ambiguous - use NetworkList to list by name\n \tnetworks, err := s.apiClient().NetworkList(ctx, moby.NetworkListOptions{\n \t\tFilters: filters.NewArgs(filters.Arg(\"name\", n.Name)),\n \t})\n \tif err != nil {\n \t\treturn err\n \t}\n-\tnetworkNotFound := true\n+\n+\t// NetworkList Matches all or part of a network name, so we have to filter for a strict match\n+\tnetworks = utils.Filter(networks, func(net moby.NetworkResource) bool {\n+\t\treturn net.Name == n.Name\n+\t})\n+\n \tfor _, net := range networks {\n-\t\tif net.Name == n.Name {\n-\t\t\tnetworkNotFound = false\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif networkNotFound {\n-\t\tif n.External.External {\n-\t\t\tif n.Driver == \"overlay\" {\n-\t\t\t\t// Swarm nodes do not register overlay networks that were\n-\t\t\t\t// created on a different node unless they're in use.\n-\t\t\t\t// Here we assume `driver` is relevant for a network we don't manage\n-\t\t\t\t// which is a non-sense, but this is our legacy \u00af\\(\u30c4)/\u00af\n-\t\t\t\t// networkAttach will later fail anyway if network actually doesn't exists\n-\t\t\t\tenabled, err := s.isSWarmEnabled(ctx)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tif enabled {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn fmt.Errorf(\"network %s declared as external, but could not be found\", n.Name)\n-\t\t}\n-\t\tvar ipam *network.IPAM\n-\t\tif n.Ipam.Config != nil {\n-\t\t\tvar config []network.IPAMConfig\n-\t\t\tfor _, pool := range n.Ipam.Config {\n-\t\t\t\tconfig = append(config, network.IPAMConfig{\n-\t\t\t\t\tSubnet:     pool.Subnet,\n-\t\t\t\t\tIPRange:    pool.IPRange,\n-\t\t\t\t\tGateway:    pool.Gateway,\n-\t\t\t\t\tAuxAddress: pool.AuxiliaryAddresses,\n-\t\t\t\t})\n-\t\t\t}\n-\t\t\tipam = &network.IPAM{\n-\t\t\t\tDriver: n.Ipam.Driver,\n-\t\t\t\tConfig: config,\n-\t\t\t}\n-\t\t}\n-\t\tcreateOpts := moby.NetworkCreate{\n-\t\t\tCheckDuplicate: true,\n-\t\t\t// TODO NameSpace Labels\n-\t\t\tLabels:     n.Labels,\n-\t\t\tDriver:     n.Driver,\n-\t\t\tOptions:    n.DriverOpts,\n-\t\t\tInternal:   n.Internal,\n-\t\t\tAttachable: n.Attachable,\n-\t\t\tIPAM:       ipam,\n-\t\t\tEnableIPv6: n.EnableIPv6,\n+\t\tif net.Labels[api.ProjectLabel] == expectedProjectLabel &&\n+\t\t\tnet.Labels[api.NetworkLabel] == expectedNetworkLabel {\n+\t\t\treturn nil\n \t\t}\n+\t}\n \n-\t\tif n.Ipam.Driver != \"\" || len(n.Ipam.Config) > 0 {\n-\t\t\tcreateOpts.IPAM = &network.IPAM{}\n+\t// we could have set NetworkList with a projectFilter and networkFilter but not doing so allows to catch this\n+\t// scenario were a network with same name exists but doesn't have label, and use of `CheckDuplicate: true`\n+\t// prevents to create another one.\n+\tif len(networks) > 0 {\n+\t\tlogrus.Warnf(\"a network with name %s exists but was not created by compose.\n\"+\n+\t\t\t\"Set `external: true` to use a network you created\", n.Name)",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1211748286",
        "repo_full_name": "docker/compose",
        "pr_number": 10612,
        "pr_file": "pkg/compose/create.go",
        "discussion_id": "1211748286",
        "commented_code": "@@ -1077,98 +1078,168 @@ func getAliases(s types.ServiceConfig, c *types.ServiceNetworkConfig) []string {\n \treturn aliases\n }\n \n-func (s *composeService) ensureNetwork(ctx context.Context, n types.NetworkConfig) error {\n-\t// NetworkInspect will match on ID prefix, so NetworkList with a name\n-\t// filter is used to look for an exact match to prevent e.g. a network\n-\t// named `db` from getting erroneously matched to a network with an ID\n-\t// like `db9086999caf`\n+func (s *composeService) ensureNetwork(ctx context.Context, n *types.NetworkConfig) error {\n+\tif n.External.External {\n+\t\treturn s.resolveExternalNetwork(ctx, n)\n+\t}\n+\n+\terr := s.resolveOrCreateNetwork(ctx, n)\n+\tif errdefs.IsConflict(err) {\n+\t\t// Maybe another execution of `docker compose up|run` created same network\n+\t\t// let's retry once\n+\t\treturn s.resolveOrCreateNetwork(ctx, n)\n+\t}\n+\treturn err\n+}\n+\n+func (s *composeService) resolveOrCreateNetwork(ctx context.Context, n *types.NetworkConfig) error { //nolint:gocyclo\n+\texpectedNetworkLabel := n.Labels[api.NetworkLabel]\n+\texpectedProjectLabel := n.Labels[api.ProjectLabel]\n+\n+\t// First, try to find a unique network matching by name or ID\n+\tinspect, err := s.apiClient().NetworkInspect(ctx, n.Name, moby.NetworkInspectOptions{})\n+\tif err == nil {\n+\t\t// NetworkInspect will match on ID prefix, so double check we get the expected one\n+\t\t// as looking for network named `db` we could erroneously matched network ID `db9086999caf`\n+\t\tif inspect.Name == n.Name || inspect.ID == n.Name {\n+\t\t\tif inspect.Labels[api.ProjectLabel] != expectedProjectLabel {\n+\t\t\t\tlogrus.Warnf(\"a network with name %s exists but was not created by compose.\\n\"+\n+\t\t\t\t\t\"Set `external: true` to use a network you created\", n.Name)\n+\t\t\t}\n+\t\t\tif inspect.Labels[api.NetworkLabel] != expectedNetworkLabel {\n+\t\t\t\treturn fmt.Errorf(\"network %s was found but has incorrect label %s set to %q\", n.Name, api.NetworkLabel, inspect.Labels[api.NetworkLabel])\n+\t\t\t}\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\t// ignore other errors. Typically, an ambiguous request by name results in some generic `invalidParameter` error\n+\n+\t// Either not found, or name is ambiguous - use NetworkList to list by name\n \tnetworks, err := s.apiClient().NetworkList(ctx, moby.NetworkListOptions{\n \t\tFilters: filters.NewArgs(filters.Arg(\"name\", n.Name)),\n \t})\n \tif err != nil {\n \t\treturn err\n \t}\n-\tnetworkNotFound := true\n+\n+\t// NetworkList Matches all or part of a network name, so we have to filter for a strict match\n+\tnetworks = utils.Filter(networks, func(net moby.NetworkResource) bool {\n+\t\treturn net.Name == n.Name\n+\t})\n+\n \tfor _, net := range networks {\n-\t\tif net.Name == n.Name {\n-\t\t\tnetworkNotFound = false\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif networkNotFound {\n-\t\tif n.External.External {\n-\t\t\tif n.Driver == \"overlay\" {\n-\t\t\t\t// Swarm nodes do not register overlay networks that were\n-\t\t\t\t// created on a different node unless they're in use.\n-\t\t\t\t// Here we assume `driver` is relevant for a network we don't manage\n-\t\t\t\t// which is a non-sense, but this is our legacy \u00af\\(\u30c4)/\u00af\n-\t\t\t\t// networkAttach will later fail anyway if network actually doesn't exists\n-\t\t\t\tenabled, err := s.isSWarmEnabled(ctx)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tif enabled {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn fmt.Errorf(\"network %s declared as external, but could not be found\", n.Name)\n-\t\t}\n-\t\tvar ipam *network.IPAM\n-\t\tif n.Ipam.Config != nil {\n-\t\t\tvar config []network.IPAMConfig\n-\t\t\tfor _, pool := range n.Ipam.Config {\n-\t\t\t\tconfig = append(config, network.IPAMConfig{\n-\t\t\t\t\tSubnet:     pool.Subnet,\n-\t\t\t\t\tIPRange:    pool.IPRange,\n-\t\t\t\t\tGateway:    pool.Gateway,\n-\t\t\t\t\tAuxAddress: pool.AuxiliaryAddresses,\n-\t\t\t\t})\n-\t\t\t}\n-\t\t\tipam = &network.IPAM{\n-\t\t\t\tDriver: n.Ipam.Driver,\n-\t\t\t\tConfig: config,\n-\t\t\t}\n-\t\t}\n-\t\tcreateOpts := moby.NetworkCreate{\n-\t\t\tCheckDuplicate: true,\n-\t\t\t// TODO NameSpace Labels\n-\t\t\tLabels:     n.Labels,\n-\t\t\tDriver:     n.Driver,\n-\t\t\tOptions:    n.DriverOpts,\n-\t\t\tInternal:   n.Internal,\n-\t\t\tAttachable: n.Attachable,\n-\t\t\tIPAM:       ipam,\n-\t\t\tEnableIPv6: n.EnableIPv6,\n+\t\tif net.Labels[api.ProjectLabel] == expectedProjectLabel &&\n+\t\t\tnet.Labels[api.NetworkLabel] == expectedNetworkLabel {\n+\t\t\treturn nil\n \t\t}\n+\t}\n \n-\t\tif n.Ipam.Driver != \"\" || len(n.Ipam.Config) > 0 {\n-\t\t\tcreateOpts.IPAM = &network.IPAM{}\n+\t// we could have set NetworkList with a projectFilter and networkFilter but not doing so allows to catch this\n+\t// scenario were a network with same name exists but doesn't have label, and use of `CheckDuplicate: true`\n+\t// prevents to create another one.\n+\tif len(networks) > 0 {\n+\t\tlogrus.Warnf(\"a network with name %s exists but was not created by compose.\\n\"+\n+\t\t\t\"Set `external: true` to use a network you created\", n.Name)",
        "comment_created_at": "2023-05-31T13:47:12+00:00",
        "comment_author": "glours",
        "comment_body": "```suggestion\r\n\t\tlogrus.Warnf(\"a network with name %s exists but was not created by compose.\\n\"+\r\n\t\t\t\"Set `external: true` to use an already existing network\", n.Name)\r\n```",
        "pr_file_module": null
      }
    ]
  }
]