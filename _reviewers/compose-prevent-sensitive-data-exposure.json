[
  {
    "discussion_id": "1923723036",
    "pr_number": 12482,
    "pr_file": "pkg/compose/publish.go",
    "created_at": "2025-01-21T13:22:55+00:00",
    "commented_code": "}\n \treturn override.MarshalYAML()\n }\n+\n+func preChecks(project *types.Project, options api.PublishOptions) error {\n+\tif !options.WithEnvironment {\n+\t\tfor _, service := range project.Services {\n+\t\t\tif len(service.EnvFiles) > 0 {\n+\t\t\t\treturn fmt.Errorf(\"service %q has env_file declared. To avoid leaking sensitive data, \"+\n+\t\t\t\t\t\"you must either explicitly allow the sending of environment variables by using the --with-env flag,\"+\n+\t\t\t\t\t\" or remove sensitive data from your Compose configuration\", service.Name)\n+\t\t\t}\n+\t\t\tif len(service.Environment) > 0 {\n+\t\t\t\treturn fmt.Errorf(\"service %q has environment variable(s) declared. To avoid leaking sensitive data, \"+",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1923723036",
        "repo_full_name": "docker/compose",
        "pr_number": 12482,
        "pr_file": "pkg/compose/publish.go",
        "discussion_id": "1923723036",
        "commented_code": "@@ -120,3 +125,22 @@ func (s *composeService) generateImageDigestsOverride(ctx context.Context, proje\n \t}\n \treturn override.MarshalYAML()\n }\n+\n+func preChecks(project *types.Project, options api.PublishOptions) error {\n+\tif !options.WithEnvironment {\n+\t\tfor _, service := range project.Services {\n+\t\t\tif len(service.EnvFiles) > 0 {\n+\t\t\t\treturn fmt.Errorf(\"service %q has env_file declared. To avoid leaking sensitive data, \"+\n+\t\t\t\t\t\"you must either explicitly allow the sending of environment variables by using the --with-env flag,\"+\n+\t\t\t\t\t\" or remove sensitive data from your Compose configuration\", service.Name)\n+\t\t\t}\n+\t\t\tif len(service.Environment) > 0 {\n+\t\t\t\treturn fmt.Errorf(\"service %q has environment variable(s) declared. To avoid leaking sensitive data, \"+",
        "comment_created_at": "2025-01-21T13:22:55+00:00",
        "comment_author": "ndeloof",
        "comment_body": "service.environment may be set with a fixed value, not relying on any interpolation. Typically:\r\n```\r\ndb:\r\n    image: mysql\r\n    environment:\r\n      MYSQL_DATABASE: avatar\r\n      MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db-password\r\n```\r\nthose should not prevent compose file to be published, right ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1923728536",
        "repo_full_name": "docker/compose",
        "pr_number": 12482,
        "pr_file": "pkg/compose/publish.go",
        "discussion_id": "1923723036",
        "commented_code": "@@ -120,3 +125,22 @@ func (s *composeService) generateImageDigestsOverride(ctx context.Context, proje\n \t}\n \treturn override.MarshalYAML()\n }\n+\n+func preChecks(project *types.Project, options api.PublishOptions) error {\n+\tif !options.WithEnvironment {\n+\t\tfor _, service := range project.Services {\n+\t\t\tif len(service.EnvFiles) > 0 {\n+\t\t\t\treturn fmt.Errorf(\"service %q has env_file declared. To avoid leaking sensitive data, \"+\n+\t\t\t\t\t\"you must either explicitly allow the sending of environment variables by using the --with-env flag,\"+\n+\t\t\t\t\t\" or remove sensitive data from your Compose configuration\", service.Name)\n+\t\t\t}\n+\t\t\tif len(service.Environment) > 0 {\n+\t\t\t\treturn fmt.Errorf(\"service %q has environment variable(s) declared. To avoid leaking sensitive data, \"+",
        "comment_created_at": "2025-01-21T13:26:29+00:00",
        "comment_author": "glours",
        "comment_body": "In fact yes that should prevent from publishing by default because you can also have `MYSQL_ROOT_PASSWORD: mySuperSecretPassword` defined the same way",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174990785",
    "pr_number": 12997,
    "pr_file": "pkg/compose/publish.go",
    "created_at": "2025-06-30T12:46:02+00:00",
    "commented_code": "if ok, err := s.checkOnlyBuildSection(project); !ok || err != nil {\n \t\treturn false, err\n \t}\n-\tif ok, err := s.checkForBindMount(project); !ok || err != nil {\n-\t\treturn false, err\n+\tbindMounts := s.checkForBindMount(project)\n+\tif len(bindMounts) > 0 {\n+\t\tfmt.Println(\"you are about to publish bind mounts declaration within your OCI artifact.\n\" +\n+\t\t\t\"only the bind mount declarations will be added to the OCI artifact\n\" +\n+\t\t\t\"please double check that you are not mounting potential sensitive directories or data\")",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "2174990785",
        "repo_full_name": "docker/compose",
        "pr_number": 12997,
        "pr_file": "pkg/compose/publish.go",
        "discussion_id": "2174990785",
        "commented_code": "@@ -236,8 +236,20 @@ func (s *composeService) preChecks(project *types.Project, options api.PublishOp\n \tif ok, err := s.checkOnlyBuildSection(project); !ok || err != nil {\n \t\treturn false, err\n \t}\n-\tif ok, err := s.checkForBindMount(project); !ok || err != nil {\n-\t\treturn false, err\n+\tbindMounts := s.checkForBindMount(project)\n+\tif len(bindMounts) > 0 {\n+\t\tfmt.Println(\"you are about to publish bind mounts declaration within your OCI artifact.\\n\" +\n+\t\t\t\"only the bind mount declarations will be added to the OCI artifact\\n\" +\n+\t\t\t\"please double check that you are not mounting potential sensitive directories or data\")",
        "comment_created_at": "2025-06-30T12:46:02+00:00",
        "comment_author": "ndeloof",
        "comment_body": "```suggestion\r\n\t\tfmt.Println(\"you are about to publish bind mounts declaration within your OCI artifact.\\n\" +\r\n\t\t\t\"only the bind mount declarations will be added to the OCI artifact (not content)\\n\" +\r\n\t\t\t\"please double check that you are not mounting potential user's sensitive directories or data\")\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1987683727",
    "pr_number": 12620,
    "pr_file": "pkg/compose/publish.go",
    "created_at": "2025-03-10T16:55:10+00:00",
    "commented_code": "}\n \treturn true, nil\n }\n+\n+func (s *composeService) checkForBindMount(project *types.Project) (bool, error) {\n+\tfor name, config := range project.Services {\n+\t\tfor _, volume := range config.Volumes {\n+\t\t\tif volume.Type == types.VolumeTypeBind {\n+\t\t\t\treturn false, fmt.Errorf(\"cannot publish compose file: service %q relies on bind-mount. You should use volumes\", name)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn true, nil\n+}\n+\n+func (s *composeService) checkForSensitiveData(project *types.Project) ([]secrets.DetectedSecret, error) {\n+\tscan := scanner.NewDefaultScanner()\n+\n+\tinput, err := project.MarshalYAML()",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1987683727",
        "repo_full_name": "docker/compose",
        "pr_number": 12620,
        "pr_file": "pkg/compose/publish.go",
        "discussion_id": "1987683727",
        "commented_code": "@@ -367,3 +392,24 @@ func (s *composeService) checkOnlyBuildSection(project *types.Project) (bool, er\n \t}\n \treturn true, nil\n }\n+\n+func (s *composeService) checkForBindMount(project *types.Project) (bool, error) {\n+\tfor name, config := range project.Services {\n+\t\tfor _, volume := range config.Volumes {\n+\t\t\tif volume.Type == types.VolumeTypeBind {\n+\t\t\t\treturn false, fmt.Errorf(\"cannot publish compose file: service %q relies on bind-mount. You should use volumes\", name)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn true, nil\n+}\n+\n+func (s *composeService) checkForSensitiveData(project *types.Project) ([]secrets.DetectedSecret, error) {\n+\tscan := scanner.NewDefaultScanner()\n+\n+\tinput, err := project.MarshalYAML()",
        "comment_created_at": "2025-03-10T16:55:10+00:00",
        "comment_author": "ndeloof",
        "comment_body": "you MUST check each individual file in the compose project, not just the final model. Otherwise I _may_ publish:\r\ncompose.yaml\r\n```yaml\r\nservices:\r\n test\r\n   some: MY_SECRET_PASSWORD\r\n```\r\n\r\ncompose.yaml\r\n```yaml\r\nservices:\r\n test\r\n   some: !override ${ENTER_YOUR_OWN_SECRET}\r\n```\r\n\r\nPublisher expectation would be that secret is not exposed to consumer, but actually it is",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1623215363",
    "pr_number": 11871,
    "pr_file": "pkg/compose/secrets.go",
    "created_at": "2024-06-01T12:41:48+00:00",
    "commented_code": "return nil\n }\n \n-func createTar(env string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n-\tvalue := []byte(env)\n+func createTarredFileOf(value string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n+\tmode, uid, gid, err := makeTarFileEntryParams(config)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed parsing target file parameters\")\n+\t}\n+\n \tb := bytes.Buffer{}\n \ttarWriter := tar.NewWriter(&b)\n-\tmode := uint32(0o444)\n+\tvalueAsBytes := []byte(value)\n+\theader := &tar.Header{\n+\t\tName:    config.Target,\n+\t\tSize:    int64(len(valueAsBytes)),\n+\t\tMode:    mode,\n+\t\tModTime: time.Now(),\n+\t\tUid:     uid,\n+\t\tGid:     gid,\n+\t}\n+\terr = tarWriter.WriteHeader(header)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\t_, err = tarWriter.Write(valueAsBytes)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\terr = tarWriter.Close()\n+\treturn b, err\n+}\n+\n+func createTarArchiveOf(path string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n+\t// need to treat files and directories differently\n+\tfi, err := os.Stat(path)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\n+\t// if path is not directory, try to treat it as a file by reading its value\n+\tif !fi.IsDir() {\n+\t\tbuf, err := os.ReadFile(path)\n+\t\tif err == nil {\n+\t\t\treturn createTarredFileOf(string(buf), config)\n+\t\t}\n+\t}\n+\n+\tmode, uid, gid, err := makeTarFileEntryParams(config)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed parsing target file parameters\")\n+\t}\n+\n+\tsubdir := os.DirFS(path)\n+\tb := bytes.Buffer{}\n+\ttarWriter := tar.NewWriter(&b)\n+\n+\t// build the tar by walking instead of using archive/tar.Writer.AddFS to be able to adjust mode, gid and uid\n+\terr = fs.WalkDir(subdir, \".\", func(filePath string, d fs.DirEntry, err error) error {\n+\t\theader := &tar.Header{\n+\t\t\tName:    filepath.Join(config.Target, filePath),\n+\t\t\tMode:    mode,\n+\t\t\tModTime: time.Now(),\n+\t\t\tUid:     uid,\n+\t\t\tGid:     gid,\n+\t\t}\n+\n+\t\tif d.IsDir() {\n+\t\t\t// tar requires that directory headers ends with a slash\n+\t\t\theader.Name = header.Name + \"/\"\n+\t\t\terr = tarWriter.WriteHeader(header)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing tar header of directory %v while walking diretory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tf, err := subdir.Open(filePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tdefer f.Close()\n+\n+\t\t\tvalueAsBytes, err := io.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed reading file %v for to send to container, error was: %w\", filePath, err)\n+\t\t\t}\n+\n+\t\t\theader.Size = int64(len(valueAsBytes))\n+\t\t\terr = tarWriter.WriteHeader(header)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing tar header for file %v while walking diretory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\n+\t\t\t_, err = tarWriter.Write(valueAsBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing file content of %v into tar archive while walking directory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn nil\n+\t})\n+\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed building tar archive while walking config directory structure, error was: %w\", err)\n+\t}\n+\n+\terr = tarWriter.Close()\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed closing tar archive after writing, error was: %w\", err)\n+\t}\n+\n+\treturn b, err\n+}\n+\n+func makeTarFileEntryParams(config types.FileReferenceConfig) (mode int64, uid, gid int, err error) {\n+\tmode = 0o444",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1623215363",
        "repo_full_name": "docker/compose",
        "pr_number": 11871,
        "pr_file": "pkg/compose/secrets.go",
        "discussion_id": "1623215363",
        "commented_code": "@@ -94,47 +114,135 @@ func (s *composeService) injectConfigs(ctx context.Context, project *types.Proje\n \treturn nil\n }\n \n-func createTar(env string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n-\tvalue := []byte(env)\n+func createTarredFileOf(value string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n+\tmode, uid, gid, err := makeTarFileEntryParams(config)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed parsing target file parameters\")\n+\t}\n+\n \tb := bytes.Buffer{}\n \ttarWriter := tar.NewWriter(&b)\n-\tmode := uint32(0o444)\n+\tvalueAsBytes := []byte(value)\n+\theader := &tar.Header{\n+\t\tName:    config.Target,\n+\t\tSize:    int64(len(valueAsBytes)),\n+\t\tMode:    mode,\n+\t\tModTime: time.Now(),\n+\t\tUid:     uid,\n+\t\tGid:     gid,\n+\t}\n+\terr = tarWriter.WriteHeader(header)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\t_, err = tarWriter.Write(valueAsBytes)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\terr = tarWriter.Close()\n+\treturn b, err\n+}\n+\n+func createTarArchiveOf(path string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n+\t// need to treat files and directories differently\n+\tfi, err := os.Stat(path)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\n+\t// if path is not directory, try to treat it as a file by reading its value\n+\tif !fi.IsDir() {\n+\t\tbuf, err := os.ReadFile(path)\n+\t\tif err == nil {\n+\t\t\treturn createTarredFileOf(string(buf), config)\n+\t\t}\n+\t}\n+\n+\tmode, uid, gid, err := makeTarFileEntryParams(config)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed parsing target file parameters\")\n+\t}\n+\n+\tsubdir := os.DirFS(path)\n+\tb := bytes.Buffer{}\n+\ttarWriter := tar.NewWriter(&b)\n+\n+\t// build the tar by walking instead of using archive/tar.Writer.AddFS to be able to adjust mode, gid and uid\n+\terr = fs.WalkDir(subdir, \".\", func(filePath string, d fs.DirEntry, err error) error {\n+\t\theader := &tar.Header{\n+\t\t\tName:    filepath.Join(config.Target, filePath),\n+\t\t\tMode:    mode,\n+\t\t\tModTime: time.Now(),\n+\t\t\tUid:     uid,\n+\t\t\tGid:     gid,\n+\t\t}\n+\n+\t\tif d.IsDir() {\n+\t\t\t// tar requires that directory headers ends with a slash\n+\t\t\theader.Name = header.Name + \"/\"\n+\t\t\terr = tarWriter.WriteHeader(header)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing tar header of directory %v while walking diretory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tf, err := subdir.Open(filePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tdefer f.Close()\n+\n+\t\t\tvalueAsBytes, err := io.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed reading file %v for to send to container, error was: %w\", filePath, err)\n+\t\t\t}\n+\n+\t\t\theader.Size = int64(len(valueAsBytes))\n+\t\t\terr = tarWriter.WriteHeader(header)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing tar header for file %v while walking diretory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\n+\t\t\t_, err = tarWriter.Write(valueAsBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing file content of %v into tar archive while walking directory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn nil\n+\t})\n+\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed building tar archive while walking config directory structure, error was: %w\", err)\n+\t}\n+\n+\terr = tarWriter.Close()\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed closing tar archive after writing, error was: %w\", err)\n+\t}\n+\n+\treturn b, err\n+}\n+\n+func makeTarFileEntryParams(config types.FileReferenceConfig) (mode int64, uid, gid int, err error) {\n+\tmode = 0o444",
        "comment_created_at": "2024-06-01T12:41:48+00:00",
        "comment_author": "andoks",
        "comment_body": ":question: should the default mode be different for secrets compared to configs?",
        "pr_file_module": null
      },
      {
        "comment_id": "1680929600",
        "repo_full_name": "docker/compose",
        "pr_number": 11871,
        "pr_file": "pkg/compose/secrets.go",
        "discussion_id": "1623215363",
        "commented_code": "@@ -94,47 +114,135 @@ func (s *composeService) injectConfigs(ctx context.Context, project *types.Proje\n \treturn nil\n }\n \n-func createTar(env string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n-\tvalue := []byte(env)\n+func createTarredFileOf(value string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n+\tmode, uid, gid, err := makeTarFileEntryParams(config)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed parsing target file parameters\")\n+\t}\n+\n \tb := bytes.Buffer{}\n \ttarWriter := tar.NewWriter(&b)\n-\tmode := uint32(0o444)\n+\tvalueAsBytes := []byte(value)\n+\theader := &tar.Header{\n+\t\tName:    config.Target,\n+\t\tSize:    int64(len(valueAsBytes)),\n+\t\tMode:    mode,\n+\t\tModTime: time.Now(),\n+\t\tUid:     uid,\n+\t\tGid:     gid,\n+\t}\n+\terr = tarWriter.WriteHeader(header)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\t_, err = tarWriter.Write(valueAsBytes)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\terr = tarWriter.Close()\n+\treturn b, err\n+}\n+\n+func createTarArchiveOf(path string, config types.FileReferenceConfig) (bytes.Buffer, error) {\n+\t// need to treat files and directories differently\n+\tfi, err := os.Stat(path)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, err\n+\t}\n+\n+\t// if path is not directory, try to treat it as a file by reading its value\n+\tif !fi.IsDir() {\n+\t\tbuf, err := os.ReadFile(path)\n+\t\tif err == nil {\n+\t\t\treturn createTarredFileOf(string(buf), config)\n+\t\t}\n+\t}\n+\n+\tmode, uid, gid, err := makeTarFileEntryParams(config)\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed parsing target file parameters\")\n+\t}\n+\n+\tsubdir := os.DirFS(path)\n+\tb := bytes.Buffer{}\n+\ttarWriter := tar.NewWriter(&b)\n+\n+\t// build the tar by walking instead of using archive/tar.Writer.AddFS to be able to adjust mode, gid and uid\n+\terr = fs.WalkDir(subdir, \".\", func(filePath string, d fs.DirEntry, err error) error {\n+\t\theader := &tar.Header{\n+\t\t\tName:    filepath.Join(config.Target, filePath),\n+\t\t\tMode:    mode,\n+\t\t\tModTime: time.Now(),\n+\t\t\tUid:     uid,\n+\t\t\tGid:     gid,\n+\t\t}\n+\n+\t\tif d.IsDir() {\n+\t\t\t// tar requires that directory headers ends with a slash\n+\t\t\theader.Name = header.Name + \"/\"\n+\t\t\terr = tarWriter.WriteHeader(header)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing tar header of directory %v while walking diretory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tf, err := subdir.Open(filePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tdefer f.Close()\n+\n+\t\t\tvalueAsBytes, err := io.ReadAll(f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed reading file %v for to send to container, error was: %w\", filePath, err)\n+\t\t\t}\n+\n+\t\t\theader.Size = int64(len(valueAsBytes))\n+\t\t\terr = tarWriter.WriteHeader(header)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing tar header for file %v while walking diretory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\n+\t\t\t_, err = tarWriter.Write(valueAsBytes)\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"failed writing file content of %v into tar archive while walking directory structure, error was: %w\", filePath, err)\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn nil\n+\t})\n+\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed building tar archive while walking config directory structure, error was: %w\", err)\n+\t}\n+\n+\terr = tarWriter.Close()\n+\tif err != nil {\n+\t\treturn bytes.Buffer{}, fmt.Errorf(\"failed closing tar archive after writing, error was: %w\", err)\n+\t}\n+\n+\treturn b, err\n+}\n+\n+func makeTarFileEntryParams(config types.FileReferenceConfig) (mode int64, uid, gid int, err error) {\n+\tmode = 0o444",
        "comment_created_at": "2024-07-17T11:59:46+00:00",
        "comment_author": "schaubl",
        "comment_body": "I think it would make sense to remove at least public read (`0o440`) for secrets",
        "pr_file_module": null
      }
    ]
  }
]