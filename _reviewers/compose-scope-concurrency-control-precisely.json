[
  {
    "discussion_id": "2175284316",
    "pr_number": 12999,
    "pr_file": "pkg/compose/plugins.go",
    "created_at": "2025-06-30T14:56:40+00:00",
    "commented_code": "return err\n \t}\n \n+\tmux.Lock()\n+\tdefer mux.Unlock()",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "2175284316",
        "repo_full_name": "docker/compose",
        "pr_number": 12999,
        "pr_file": "pkg/compose/plugins.go",
        "discussion_id": "2175284316",
        "commented_code": "@@ -70,6 +74,8 @@ func (s *composeService) runPlugin(ctx context.Context, project *types.Project,\n \t\treturn err\n \t}\n \n+\tmux.Lock()\n+\tdefer mux.Unlock()",
        "comment_created_at": "2025-06-30T14:56:40+00:00",
        "comment_author": "ndeloof",
        "comment_body": "We don't want providers to run sequentially, only the project mutation must be guarded by a mutex.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1247147136",
    "pr_number": 10742,
    "pr_file": "pkg/compose/wait.go",
    "created_at": "2023-06-29T20:38:29+00:00",
    "commented_code": "+/*\n+   Copyright 2020 Docker Compose CLI authors\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package compose\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\t\"github.com/compose-spec/compose-go/types\"\n+\t\"github.com/docker/compose/v2/pkg/api\"\n+)\n+\n+func (s *composeService) Wait(ctx context.Context, project *types.Project, options api.WaitOptions) (int64, error) {\n+\tcontainers, err := s.getContainers(ctx, project.Name, oneOffInclude, false, options.Services...)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\tvar returnErrorChan = make(chan error)\n+\tvar statusCode int64\n+\tfor _, c := range containers {\n+\t\tc := c\n+\t\tgo func() {",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1247147136",
        "repo_full_name": "docker/compose",
        "pr_number": 10742,
        "pr_file": "pkg/compose/wait.go",
        "discussion_id": "1247147136",
        "commented_code": "@@ -0,0 +1,64 @@\n+/*\n+   Copyright 2020 Docker Compose CLI authors\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package compose\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\n+\t\"github.com/compose-spec/compose-go/types\"\n+\t\"github.com/docker/compose/v2/pkg/api\"\n+)\n+\n+func (s *composeService) Wait(ctx context.Context, project *types.Project, options api.WaitOptions) (int64, error) {\n+\tcontainers, err := s.getContainers(ctx, project.Name, oneOffInclude, false, options.Services...)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\tvar returnErrorChan = make(chan error)\n+\tvar statusCode int64\n+\tfor _, c := range containers {\n+\t\tc := c\n+\t\tgo func() {",
        "comment_created_at": "2023-06-29T20:38:29+00:00",
        "comment_author": "ndeloof",
        "comment_body": "could use an errorGroup (like we do in other places in compose) to capture first error and stop other goroutines by cancelable context.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1064814327",
    "pr_number": 10148,
    "pr_file": "pkg/compose/build.go",
    "created_at": "2023-01-09T16:09:32+00:00",
    "commented_code": "}\n \n func (s *composeService) build(ctx context.Context, project *types.Project, options api.BuildOptions) error {\n-\topts := map[string]build.Options{}",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1064814327",
        "repo_full_name": "docker/compose",
        "pr_number": 10148,
        "pr_file": "pkg/compose/build.go",
        "discussion_id": "1064814327",
        "commented_code": "@@ -48,7 +48,6 @@ func (s *composeService) Build(ctx context.Context, project *types.Project, opti\n }\n \n func (s *composeService) build(ctx context.Context, project *types.Project, options api.BuildOptions) error {\n-\topts := map[string]build.Options{}",
        "comment_created_at": "2023-01-09T16:09:32+00:00",
        "comment_author": "maxcleme",
        "comment_body": "Move it to closure below otherwise it could end up with `concurrent map write` panic. It occurs on my end when building multi service with buildx.",
        "pr_file_module": null
      },
      {
        "comment_id": "1065478529",
        "repo_full_name": "docker/compose",
        "pr_number": 10148,
        "pr_file": "pkg/compose/build.go",
        "discussion_id": "1064814327",
        "commented_code": "@@ -48,7 +48,6 @@ func (s *composeService) Build(ctx context.Context, project *types.Project, opti\n }\n \n func (s *composeService) build(ctx context.Context, project *types.Project, options api.BuildOptions) error {\n-\topts := map[string]build.Options{}",
        "comment_created_at": "2023-01-10T08:39:57+00:00",
        "comment_author": "maxcleme",
        "comment_body": "Was spotted and merged in https://github.com/docker/compose/pull/10151, I have rebased accordingly.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1086811372",
    "pr_number": 10202,
    "pr_file": "cmd/formatter/colors.go",
    "created_at": "2023-01-25T15:46:28+00:00",
    "commented_code": "}\n \n var nextColor = rainbowColor\n+var rainbow []colorFunc\n+var currentIndex = 0\n \n func rainbowColor() colorFunc {\n-\treturn <-loop\n+\tresult := rainbow[currentIndex]",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1086811372",
        "repo_full_name": "docker/compose",
        "pr_number": 10202,
        "pr_file": "cmd/formatter/colors.go",
        "discussion_id": "1086811372",
        "commented_code": "@@ -86,38 +86,31 @@ func makeColorFunc(code string) colorFunc {\n }\n \n var nextColor = rainbowColor\n+var rainbow []colorFunc\n+var currentIndex = 0\n \n func rainbowColor() colorFunc {\n-\treturn <-loop\n+\tresult := rainbow[currentIndex]",
        "comment_created_at": "2023-01-25T15:46:28+00:00",
        "comment_author": "ndeloof",
        "comment_body": "this isn't thread safe, would require a mutex (this is why we used a channel here)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1072856583",
    "pr_number": 10172,
    "pr_file": "pkg/compose/watch.go",
    "created_at": "2023-01-17T21:37:44+00:00",
    "commented_code": "return eg.Wait()\n }\n+\n+func debounce(ctx context.Context, interval time.Duration, input chan string, fn func(services []string)) {\n+\tservices := utils.Set[string]{}\n+\ttimer := time.NewTimer(interval)\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase service := <-input:\n+\t\t\ttimer.Reset(interval)",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1072856583",
        "repo_full_name": "docker/compose",
        "pr_number": 10172,
        "pr_file": "pkg/compose/watch.go",
        "discussion_id": "1072856583",
        "commented_code": "@@ -77,3 +91,23 @@ func (s *composeService) Watch(ctx context.Context, project *types.Project, serv\n \n \treturn eg.Wait()\n }\n+\n+func debounce(ctx context.Context, interval time.Duration, input chan string, fn func(services []string)) {\n+\tservices := utils.Set[string]{}\n+\ttimer := time.NewTimer(interval)\n+\tfor {\n+\t\tselect {\n+\t\tcase <-ctx.Done():\n+\t\t\treturn\n+\t\tcase service := <-input:\n+\t\t\ttimer.Reset(interval)",
        "comment_created_at": "2023-01-17T21:37:44+00:00",
        "comment_author": "milas",
        "comment_body": "Since we don't know if the timer has fired here, we need to stop it/drain first:\r\n```go\r\nif !timer.Stop() {\r\n\t<-timer.C\r\n}\r\ntimer.Reset(interval)\r\n```\r\n\r\nhttps://pkg.go.dev/time#Timer.Reset",
        "pr_file_module": null
      }
    ]
  }
]