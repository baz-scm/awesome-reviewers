[
  {
    "discussion_id": "737119051",
    "pr_number": 8777,
    "pr_file": "pkg/compose/start.go",
    "created_at": "2021-10-27T05:33:20+00:00",
    "commented_code": "if err != nil {\n \t\t\treturn err\n \t\t}\n-\t\treturn s.startService(ctx, project, service)\n+\n+\t\terr = s.startService(ctx, project, service)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\treturn nil\n \t})\n \tif err != nil {\n \t\treturn err\n \t}\n+\n+\tif len(options.WaitCondition) != 0 {\n+\t\terr := s.waitServices(ctx, project, options.WaitCondition)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n \treturn eg.Wait()\n }\n \n+func (s *composeService) waitServices(ctx context.Context, project *types.Project, options []string) error {\n+\tdepends := types.DependsOnConfig{}\n+\tfor _, c := range options {\n+\t\tsplit := strings.SplitN(c, \":\", 2)\n+\t\tif len(split) == 2 {\n+\t\t\tservice := split[0]\n+\t\t\tcondition := \"service_\" + split[1]\n+\t\t\tdepends[service] = types.ServiceDependency{\n+\t\t\t\tCondition: condition,\n+\t\t\t}\n+\t\t} else {\n+\t\t\tcondition := \"service_\" + split[0]",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "737119051",
        "repo_full_name": "docker/compose",
        "pr_number": 8777,
        "pr_file": "pkg/compose/start.go",
        "discussion_id": "737119051",
        "commented_code": "@@ -58,14 +59,54 @@ func (s *composeService) start(ctx context.Context, project *types.Project, opti\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\treturn s.startService(ctx, project, service)\n+\n+\t\terr = s.startService(ctx, project, service)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\treturn nil\n \t})\n \tif err != nil {\n \t\treturn err\n \t}\n+\n+\tif len(options.WaitCondition) != 0 {\n+\t\terr := s.waitServices(ctx, project, options.WaitCondition)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n \treturn eg.Wait()\n }\n \n+func (s *composeService) waitServices(ctx context.Context, project *types.Project, options []string) error {\n+\tdepends := types.DependsOnConfig{}\n+\tfor _, c := range options {\n+\t\tsplit := strings.SplitN(c, \":\", 2)\n+\t\tif len(split) == 2 {\n+\t\t\tservice := split[0]\n+\t\t\tcondition := \"service_\" + split[1]\n+\t\t\tdepends[service] = types.ServiceDependency{\n+\t\t\t\tCondition: condition,\n+\t\t\t}\n+\t\t} else {\n+\t\t\tcondition := \"service_\" + split[0]",
        "comment_created_at": "2021-10-27T05:33:20+00:00",
        "comment_author": "mat007",
        "comment_body": "Admittedly this is a corner case, but should we error if `split[0]` is `\"\"`?\r\nI think it may be possible to trigger this with `--wait=\"\"` or something like that.\r\nDefinitely not what a human would type, but with a script it\u2019s always possible?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1223078937",
    "pr_number": 10526,
    "pr_file": "internal/tracing/docker_context.go",
    "created_at": "2023-06-08T13:55:01+00:00",
    "commented_code": "+/*\n+   Copyright 2023 Docker Compose CLI authors\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package tracing\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"time\"\n+\n+\t\"github.com/docker/cli/cli/command\"\n+\t\"github.com/docker/cli/cli/context/store\"\n+\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace\"\n+\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+)\n+\n+const otelConfigFieldName = \"otel\"\n+\n+// traceClientFromDockerContext creates a gRPC OTLP client based on metadata\n+// from the active Docker CLI context.\n+func traceClientFromDockerContext(dockerCli command.Cli, otelEnv envMap) (otlptrace.Client, error) {\n+\t// attempt to extract an OTEL config from the Docker context to enable\n+\t// automatic integration with Docker Desktop;\n+\tcfg, err := ConfigFromDockerContext(dockerCli.ContextStore(), dockerCli.CurrentContext())\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"loading otel config from docker context metadata: %v\", err)\n+\t}\n+\n+\tif cfg.Endpoint == \"\" {\n+\t\treturn nil, nil\n+\t}\n+\n+\t// HACK: unfortunately _all_ public OTEL initialization functions\n+\t// \timplicitly read from the OS env, so temporarily unset them all and\n+\t// \trestore afterwards\n+\tdefer func() {\n+\t\tfor k, v := range otelEnv {\n+\t\t\tif err := os.Setenv(k, v); err != nil {\n+\t\t\t\tpanic(fmt.Errorf(\"restoring env for %q: %v\", k, err))\n+\t\t\t}\n+\t\t}\n+\t}()\n+\tfor k := range otelEnv {\n+\t\tif err := os.Unsetenv(k); err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"stashing env for %q: %v\", k, err)\n+\t\t}\n+\t}\n+\n+\tdialCtx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\tdefer cancel()\n+\tconn, err := grpc.DialContext(\n+\t\tdialCtx,\n+\t\tcfg.Endpoint,\n+\t\tgrpc.WithContextDialer(DialInMemory),\n+\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n+\t\tgrpc.WithBlock(),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"initializing otel connection from docker context metadata: %v\", err)\n+\t}\n+\n+\tclient := otlptracegrpc.NewClient(otlptracegrpc.WithGRPCConn(conn))\n+\treturn client, nil\n+}\n+\n+// ConfigFromDockerContext inspects extra metadata included as part of the\n+// specified Docker context to try and extract a valid OTLP client configuration.\n+func ConfigFromDockerContext(st store.Store, name string) (OTLPConfig, error) {\n+\tmeta, err := st.GetMetadata(name)\n+\tif err != nil {\n+\t\treturn OTLPConfig{}, err\n+\t}\n+\n+\tvar otelCfg interface{}\n+\tswitch m := meta.Metadata.(type) {\n+\tcase command.DockerContext:\n+\t\totelCfg = m.AdditionalFields[otelConfigFieldName]\n+\tcase map[string]interface{}:\n+\t\totelCfg = m[otelConfigFieldName]\n+\t}\n+\totelMap, ok := otelCfg.(map[string]interface{})\n+\tif !ok {\n+\t\treturn OTLPConfig{}, fmt.Errorf(\n+\t\t\t\"unexpected type for field %q: %T (expected: %T)\",\n+\t\t\totelConfigFieldName,\n+\t\t\totelCfg,\n+\t\t\totelMap,\n+\t\t)\n+\t}\n+\n+\t// keys from https://opentelemetry.io/docs/concepts/sdk-configuration/otlp-exporter-configuration/\n+\tcfg := OTLPConfig{\n+\t\tEndpoint: strValue(otelMap, \"OTEL_EXPORTER_OTLP_ENDPOINT\"),\n+\t}\n+\treturn cfg, nil\n+}\n+\n+// strValue returns the string value at the specified key in the map if present\n+// and a string type; otherwise, it returns an empty string.\n+func strValue(m map[string]interface{}, key string) string {\n+\tif v, ok := m[key].(string); ok {\n+\t\treturn v\n+\t}\n+\treturn \"\"\n+}",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1223078937",
        "repo_full_name": "docker/compose",
        "pr_number": 10526,
        "pr_file": "internal/tracing/docker_context.go",
        "discussion_id": "1223078937",
        "commented_code": "@@ -0,0 +1,121 @@\n+/*\n+   Copyright 2023 Docker Compose CLI authors\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package tracing\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"time\"\n+\n+\t\"github.com/docker/cli/cli/command\"\n+\t\"github.com/docker/cli/cli/context/store\"\n+\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace\"\n+\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+)\n+\n+const otelConfigFieldName = \"otel\"\n+\n+// traceClientFromDockerContext creates a gRPC OTLP client based on metadata\n+// from the active Docker CLI context.\n+func traceClientFromDockerContext(dockerCli command.Cli, otelEnv envMap) (otlptrace.Client, error) {\n+\t// attempt to extract an OTEL config from the Docker context to enable\n+\t// automatic integration with Docker Desktop;\n+\tcfg, err := ConfigFromDockerContext(dockerCli.ContextStore(), dockerCli.CurrentContext())\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"loading otel config from docker context metadata: %v\", err)\n+\t}\n+\n+\tif cfg.Endpoint == \"\" {\n+\t\treturn nil, nil\n+\t}\n+\n+\t// HACK: unfortunately _all_ public OTEL initialization functions\n+\t// \timplicitly read from the OS env, so temporarily unset them all and\n+\t// \trestore afterwards\n+\tdefer func() {\n+\t\tfor k, v := range otelEnv {\n+\t\t\tif err := os.Setenv(k, v); err != nil {\n+\t\t\t\tpanic(fmt.Errorf(\"restoring env for %q: %v\", k, err))\n+\t\t\t}\n+\t\t}\n+\t}()\n+\tfor k := range otelEnv {\n+\t\tif err := os.Unsetenv(k); err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"stashing env for %q: %v\", k, err)\n+\t\t}\n+\t}\n+\n+\tdialCtx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\tdefer cancel()\n+\tconn, err := grpc.DialContext(\n+\t\tdialCtx,\n+\t\tcfg.Endpoint,\n+\t\tgrpc.WithContextDialer(DialInMemory),\n+\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n+\t\tgrpc.WithBlock(),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"initializing otel connection from docker context metadata: %v\", err)\n+\t}\n+\n+\tclient := otlptracegrpc.NewClient(otlptracegrpc.WithGRPCConn(conn))\n+\treturn client, nil\n+}\n+\n+// ConfigFromDockerContext inspects extra metadata included as part of the\n+// specified Docker context to try and extract a valid OTLP client configuration.\n+func ConfigFromDockerContext(st store.Store, name string) (OTLPConfig, error) {\n+\tmeta, err := st.GetMetadata(name)\n+\tif err != nil {\n+\t\treturn OTLPConfig{}, err\n+\t}\n+\n+\tvar otelCfg interface{}\n+\tswitch m := meta.Metadata.(type) {\n+\tcase command.DockerContext:\n+\t\totelCfg = m.AdditionalFields[otelConfigFieldName]\n+\tcase map[string]interface{}:\n+\t\totelCfg = m[otelConfigFieldName]\n+\t}\n+\totelMap, ok := otelCfg.(map[string]interface{})\n+\tif !ok {\n+\t\treturn OTLPConfig{}, fmt.Errorf(\n+\t\t\t\"unexpected type for field %q: %T (expected: %T)\",\n+\t\t\totelConfigFieldName,\n+\t\t\totelCfg,\n+\t\t\totelMap,\n+\t\t)\n+\t}\n+\n+\t// keys from https://opentelemetry.io/docs/concepts/sdk-configuration/otlp-exporter-configuration/\n+\tcfg := OTLPConfig{\n+\t\tEndpoint: strValue(otelMap, \"OTEL_EXPORTER_OTLP_ENDPOINT\"),\n+\t}\n+\treturn cfg, nil\n+}\n+\n+// strValue returns the string value at the specified key in the map if present\n+// and a string type; otherwise, it returns an empty string.\n+func strValue(m map[string]interface{}, key string) string {\n+\tif v, ok := m[key].(string); ok {\n+\t\treturn v\n+\t}\n+\treturn \"\"\n+}",
        "comment_created_at": "2023-06-08T13:55:01+00:00",
        "comment_author": "glours",
        "comment_body": "nit: Feel free to completely ignore it \ud83d\ude09 \r\n```suggestion\r\n\t\tEndpoint: strValue[string](otelMap, \"OTEL_EXPORTER_OTLP_ENDPOINT\"),\r\n\t}\r\n\treturn cfg, nil\r\n}\r\n\r\n// strValue returns the string value at the specified key in the map if present\r\n// and a string type; otherwise, it returns an empty string.\r\nfunc strValue[T any](m map[string]interface{}, key string) T {\r\n\tif v, ok := m[key].(T); ok {\r\n\t\treturn v\r\n\t}\r\n\treturn *new(T)\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1223516089",
        "repo_full_name": "docker/compose",
        "pr_number": 10526,
        "pr_file": "internal/tracing/docker_context.go",
        "discussion_id": "1223078937",
        "commented_code": "@@ -0,0 +1,121 @@\n+/*\n+   Copyright 2023 Docker Compose CLI authors\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package tracing\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"time\"\n+\n+\t\"github.com/docker/cli/cli/command\"\n+\t\"github.com/docker/cli/cli/context/store\"\n+\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace\"\n+\t\"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc\"\n+\t\"google.golang.org/grpc\"\n+\t\"google.golang.org/grpc/credentials/insecure\"\n+)\n+\n+const otelConfigFieldName = \"otel\"\n+\n+// traceClientFromDockerContext creates a gRPC OTLP client based on metadata\n+// from the active Docker CLI context.\n+func traceClientFromDockerContext(dockerCli command.Cli, otelEnv envMap) (otlptrace.Client, error) {\n+\t// attempt to extract an OTEL config from the Docker context to enable\n+\t// automatic integration with Docker Desktop;\n+\tcfg, err := ConfigFromDockerContext(dockerCli.ContextStore(), dockerCli.CurrentContext())\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"loading otel config from docker context metadata: %v\", err)\n+\t}\n+\n+\tif cfg.Endpoint == \"\" {\n+\t\treturn nil, nil\n+\t}\n+\n+\t// HACK: unfortunately _all_ public OTEL initialization functions\n+\t// \timplicitly read from the OS env, so temporarily unset them all and\n+\t// \trestore afterwards\n+\tdefer func() {\n+\t\tfor k, v := range otelEnv {\n+\t\t\tif err := os.Setenv(k, v); err != nil {\n+\t\t\t\tpanic(fmt.Errorf(\"restoring env for %q: %v\", k, err))\n+\t\t\t}\n+\t\t}\n+\t}()\n+\tfor k := range otelEnv {\n+\t\tif err := os.Unsetenv(k); err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"stashing env for %q: %v\", k, err)\n+\t\t}\n+\t}\n+\n+\tdialCtx, cancel := context.WithTimeout(context.Background(), 1*time.Second)\n+\tdefer cancel()\n+\tconn, err := grpc.DialContext(\n+\t\tdialCtx,\n+\t\tcfg.Endpoint,\n+\t\tgrpc.WithContextDialer(DialInMemory),\n+\t\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\n+\t\tgrpc.WithBlock(),\n+\t)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"initializing otel connection from docker context metadata: %v\", err)\n+\t}\n+\n+\tclient := otlptracegrpc.NewClient(otlptracegrpc.WithGRPCConn(conn))\n+\treturn client, nil\n+}\n+\n+// ConfigFromDockerContext inspects extra metadata included as part of the\n+// specified Docker context to try and extract a valid OTLP client configuration.\n+func ConfigFromDockerContext(st store.Store, name string) (OTLPConfig, error) {\n+\tmeta, err := st.GetMetadata(name)\n+\tif err != nil {\n+\t\treturn OTLPConfig{}, err\n+\t}\n+\n+\tvar otelCfg interface{}\n+\tswitch m := meta.Metadata.(type) {\n+\tcase command.DockerContext:\n+\t\totelCfg = m.AdditionalFields[otelConfigFieldName]\n+\tcase map[string]interface{}:\n+\t\totelCfg = m[otelConfigFieldName]\n+\t}\n+\totelMap, ok := otelCfg.(map[string]interface{})\n+\tif !ok {\n+\t\treturn OTLPConfig{}, fmt.Errorf(\n+\t\t\t\"unexpected type for field %q: %T (expected: %T)\",\n+\t\t\totelConfigFieldName,\n+\t\t\totelCfg,\n+\t\t\totelMap,\n+\t\t)\n+\t}\n+\n+\t// keys from https://opentelemetry.io/docs/concepts/sdk-configuration/otlp-exporter-configuration/\n+\tcfg := OTLPConfig{\n+\t\tEndpoint: strValue(otelMap, \"OTEL_EXPORTER_OTLP_ENDPOINT\"),\n+\t}\n+\treturn cfg, nil\n+}\n+\n+// strValue returns the string value at the specified key in the map if present\n+// and a string type; otherwise, it returns an empty string.\n+func strValue(m map[string]interface{}, key string) string {\n+\tif v, ok := m[key].(string); ok {\n+\t\treturn v\n+\t}\n+\treturn \"\"\n+}",
        "comment_created_at": "2023-06-08T20:28:09+00:00",
        "comment_author": "milas",
        "comment_body": "Changed! I didn't take the GitHub suggestion as-is because I renamed the func to be `valueOrDefault` since it's \u2728 generic \u2728 now",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "959664410",
    "pr_number": 9729,
    "pr_file": "pkg/compose/build_buildkit.go",
    "created_at": "2022-08-31T14:33:05+00:00",
    "commented_code": "return imagesBuilt, err\n }\n+\n+func (s *composeService) getDrivers(ctx context.Context) ([]build.DriverInfo, error) { //nolint:gocyclo\n+\ttxn, release, err := storeutil.GetStore(s.dockerCli)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer release()\n+\n+\tng, err := storeutil.GetCurrentInstance(txn, s.dockerCli)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdis := make([]build.DriverInfo, len(ng.Nodes))\n+\tvar f driver.Factory\n+\tif ng.Driver != \"\" {\n+\t\tfactories := driver.GetFactories()\n+\t\tfor _, fac := range factories {\n+\t\t\tif fac.Name() == ng.Driver {\n+\t\t\t\tf = fac\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tf = driver.GetFactory(ng.Driver, true)",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "959664410",
        "repo_full_name": "docker/compose",
        "pr_number": 9729,
        "pr_file": "pkg/compose/build_buildkit.go",
        "discussion_id": "959664410",
        "commented_code": "@@ -71,3 +82,197 @@ func (s *composeService) doBuildBuildkit(ctx context.Context, project *types.Pro\n \n \treturn imagesBuilt, err\n }\n+\n+func (s *composeService) getDrivers(ctx context.Context) ([]build.DriverInfo, error) { //nolint:gocyclo\n+\ttxn, release, err := storeutil.GetStore(s.dockerCli)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer release()\n+\n+\tng, err := storeutil.GetCurrentInstance(txn, s.dockerCli)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdis := make([]build.DriverInfo, len(ng.Nodes))\n+\tvar f driver.Factory\n+\tif ng.Driver != \"\" {\n+\t\tfactories := driver.GetFactories()\n+\t\tfor _, fac := range factories {\n+\t\t\tif fac.Name() == ng.Driver {\n+\t\t\t\tf = fac\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tf = driver.GetFactory(ng.Driver, true)",
        "comment_created_at": "2022-08-31T14:33:05+00:00",
        "comment_author": "nicksieger",
        "comment_body": "Looks like this will overwrite any factory set in the loop, do you want an `if f == nil` guard?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "959721857",
        "repo_full_name": "docker/compose",
        "pr_number": 9729,
        "pr_file": "pkg/compose/build_buildkit.go",
        "discussion_id": "959664410",
        "commented_code": "@@ -71,3 +82,197 @@ func (s *composeService) doBuildBuildkit(ctx context.Context, project *types.Pro\n \n \treturn imagesBuilt, err\n }\n+\n+func (s *composeService) getDrivers(ctx context.Context) ([]build.DriverInfo, error) { //nolint:gocyclo\n+\ttxn, release, err := storeutil.GetStore(s.dockerCli)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer release()\n+\n+\tng, err := storeutil.GetCurrentInstance(txn, s.dockerCli)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdis := make([]build.DriverInfo, len(ng.Nodes))\n+\tvar f driver.Factory\n+\tif ng.Driver != \"\" {\n+\t\tfactories := driver.GetFactories()\n+\t\tfor _, fac := range factories {\n+\t\t\tif fac.Name() == ng.Driver {\n+\t\t\t\tf = fac\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\t\tf = driver.GetFactory(ng.Driver, true)",
        "comment_created_at": "2022-08-31T15:21:55+00:00",
        "comment_author": "glours",
        "comment_body": "yes we can",
        "pr_file_module": null
      }
    ]
  }
]