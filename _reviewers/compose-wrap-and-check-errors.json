[
  {
    "discussion_id": "1204720008",
    "pr_number": 10612,
    "pr_file": "pkg/compose/create.go",
    "created_at": "2023-05-24T20:19:39+00:00",
    "commented_code": "if err != nil {\n \t\treturn err\n \t}\n-\tnetworkNotFound := true\n+\n+\t// NetworkList API doesn't return the exact name match, so we can retrieve more than one network with a request\n+\tnetworks = utils.Filter(networks, func(net moby.NetworkResource) bool {\n+\t\treturn net.Name == n.Name\n+\t})\n+\n \tfor _, net := range networks {\n-\t\tif net.Name == n.Name {\n-\t\t\tnetworkNotFound = false\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif networkNotFound {\n-\t\tif n.External.External {\n-\t\t\tif n.Driver == \"overlay\" {\n-\t\t\t\t// Swarm nodes do not register overlay networks that were\n-\t\t\t\t// created on a different node unless they're in use.\n-\t\t\t\t// Here we assume `driver` is relevant for a network we don't manage\n-\t\t\t\t// which is a non-sense, but this is our legacy \u00af\\(\u30c4)/\u00af\n-\t\t\t\t// networkAttach will later fail anyway if network actually doesn't exists\n-\t\t\t\tenabled, err := s.isSWarmEnabled(ctx)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tif enabled {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn fmt.Errorf(\"network %s declared as external, but could not be found\", n.Name)\n-\t\t}\n-\t\tvar ipam *network.IPAM\n-\t\tif n.Ipam.Config != nil {\n-\t\t\tvar config []network.IPAMConfig\n-\t\t\tfor _, pool := range n.Ipam.Config {\n-\t\t\t\tconfig = append(config, network.IPAMConfig{\n-\t\t\t\t\tSubnet:     pool.Subnet,\n-\t\t\t\t\tIPRange:    pool.IPRange,\n-\t\t\t\t\tGateway:    pool.Gateway,\n-\t\t\t\t\tAuxAddress: pool.AuxiliaryAddresses,\n-\t\t\t\t})\n-\t\t\t}\n-\t\t\tipam = &network.IPAM{\n-\t\t\t\tDriver: n.Ipam.Driver,\n-\t\t\t\tConfig: config,\n-\t\t\t}\n+\t\tif net.Labels[api.ProjectLabel] == n.Labels[api.ProjectLabel] &&\n+\t\t\tnet.Labels[api.NetworkLabel] == n.Labels[api.NetworkLabel] {\n+\t\t\tn.Name = net.ID\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\t// we could have set NetworkList with a projectFilter and networkFilter but not doing so allows to catch this\n+\t// scenario were a network with same name exists but doesn't have label, and use of `CheckDuplicate: true`\n+\t// prevents to create another one.\n+\tif len(networks) > 0 {\n+\t\treturn fmt.Errorf(\"a network with name %q already exists but was not created by compose\"+\n+\t\t\t\"Set `external: true` to use a network you created\", n.Name)\n+\t}\n+\n+\tvar ipam *network.IPAM\n+\tif n.Ipam.Config != nil {\n+\t\tvar config []network.IPAMConfig\n+\t\tfor _, pool := range n.Ipam.Config {\n+\t\t\tconfig = append(config, network.IPAMConfig{\n+\t\t\t\tSubnet:     pool.Subnet,\n+\t\t\t\tIPRange:    pool.IPRange,\n+\t\t\t\tGateway:    pool.Gateway,\n+\t\t\t\tAuxAddress: pool.AuxiliaryAddresses,\n+\t\t\t})\n \t\t}\n-\t\tcreateOpts := moby.NetworkCreate{\n-\t\t\tCheckDuplicate: true,\n-\t\t\t// TODO NameSpace Labels\n-\t\t\tLabels:     n.Labels,\n-\t\t\tDriver:     n.Driver,\n-\t\t\tOptions:    n.DriverOpts,\n-\t\t\tInternal:   n.Internal,\n-\t\t\tAttachable: n.Attachable,\n-\t\t\tIPAM:       ipam,\n-\t\t\tEnableIPv6: n.EnableIPv6,\n+\t\tipam = &network.IPAM{\n+\t\t\tDriver: n.Ipam.Driver,\n+\t\t\tConfig: config,\n \t\t}\n+\t}\n+\tcreateOpts := moby.NetworkCreate{\n+\t\tCheckDuplicate: true,\n+\t\tLabels:         n.Labels,\n+\t\tDriver:         n.Driver,\n+\t\tOptions:        n.DriverOpts,\n+\t\tInternal:       n.Internal,\n+\t\tAttachable:     n.Attachable,\n+\t\tIPAM:           ipam,\n+\t\tEnableIPv6:     n.EnableIPv6,\n+\t}\n+\n+\tif n.Ipam.Driver != \"\" || len(n.Ipam.Config) > 0 {\n+\t\tcreateOpts.IPAM = &network.IPAM{}\n+\t}\n+\n+\tif n.Ipam.Driver != \"\" {\n+\t\tcreateOpts.IPAM.Driver = n.Ipam.Driver\n+\t}\n \n-\t\tif n.Ipam.Driver != \"\" || len(n.Ipam.Config) > 0 {\n-\t\t\tcreateOpts.IPAM = &network.IPAM{}\n+\tfor _, ipamConfig := range n.Ipam.Config {\n+\t\tconfig := network.IPAMConfig{\n+\t\t\tSubnet:     ipamConfig.Subnet,\n+\t\t\tIPRange:    ipamConfig.IPRange,\n+\t\t\tGateway:    ipamConfig.Gateway,\n+\t\t\tAuxAddress: ipamConfig.AuxiliaryAddresses,\n \t\t}\n+\t\tcreateOpts.IPAM.Config = append(createOpts.IPAM.Config, config)\n+\t}\n+\tnetworkEventName := fmt.Sprintf(\"Network %s\", n.Name)\n+\tw := progress.ContextWriter(ctx)\n+\tw.Event(progress.CreatingEvent(networkEventName))\n \n-\t\tif n.Ipam.Driver != \"\" {\n-\t\t\tcreateOpts.IPAM.Driver = n.Ipam.Driver\n+\tcreated, err := s.apiClient().NetworkCreate(ctx, n.Name, createOpts)\n+\tif err != nil {\n+\t\tif errdefs.IsConflict(err) {\n+\t\t\t// Maybe another execution of `docker compose up|run` created same network\n+\t\t\t// let's retry\n+\t\t\treturn s.ensureNetwork(ctx, n)",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "1204720008",
        "repo_full_name": "docker/compose",
        "pr_number": 10612,
        "pr_file": "pkg/compose/create.go",
        "discussion_id": "1204720008",
        "commented_code": "@@ -1088,87 +1093,131 @@ func (s *composeService) ensureNetwork(ctx context.Context, n types.NetworkConfi\n \tif err != nil {\n \t\treturn err\n \t}\n-\tnetworkNotFound := true\n+\n+\t// NetworkList API doesn't return the exact name match, so we can retrieve more than one network with a request\n+\tnetworks = utils.Filter(networks, func(net moby.NetworkResource) bool {\n+\t\treturn net.Name == n.Name\n+\t})\n+\n \tfor _, net := range networks {\n-\t\tif net.Name == n.Name {\n-\t\t\tnetworkNotFound = false\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif networkNotFound {\n-\t\tif n.External.External {\n-\t\t\tif n.Driver == \"overlay\" {\n-\t\t\t\t// Swarm nodes do not register overlay networks that were\n-\t\t\t\t// created on a different node unless they're in use.\n-\t\t\t\t// Here we assume `driver` is relevant for a network we don't manage\n-\t\t\t\t// which is a non-sense, but this is our legacy \u00af\\(\u30c4)/\u00af\n-\t\t\t\t// networkAttach will later fail anyway if network actually doesn't exists\n-\t\t\t\tenabled, err := s.isSWarmEnabled(ctx)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tif enabled {\n-\t\t\t\t\treturn nil\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn fmt.Errorf(\"network %s declared as external, but could not be found\", n.Name)\n-\t\t}\n-\t\tvar ipam *network.IPAM\n-\t\tif n.Ipam.Config != nil {\n-\t\t\tvar config []network.IPAMConfig\n-\t\t\tfor _, pool := range n.Ipam.Config {\n-\t\t\t\tconfig = append(config, network.IPAMConfig{\n-\t\t\t\t\tSubnet:     pool.Subnet,\n-\t\t\t\t\tIPRange:    pool.IPRange,\n-\t\t\t\t\tGateway:    pool.Gateway,\n-\t\t\t\t\tAuxAddress: pool.AuxiliaryAddresses,\n-\t\t\t\t})\n-\t\t\t}\n-\t\t\tipam = &network.IPAM{\n-\t\t\t\tDriver: n.Ipam.Driver,\n-\t\t\t\tConfig: config,\n-\t\t\t}\n+\t\tif net.Labels[api.ProjectLabel] == n.Labels[api.ProjectLabel] &&\n+\t\t\tnet.Labels[api.NetworkLabel] == n.Labels[api.NetworkLabel] {\n+\t\t\tn.Name = net.ID\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\t// we could have set NetworkList with a projectFilter and networkFilter but not doing so allows to catch this\n+\t// scenario were a network with same name exists but doesn't have label, and use of `CheckDuplicate: true`\n+\t// prevents to create another one.\n+\tif len(networks) > 0 {\n+\t\treturn fmt.Errorf(\"a network with name %q already exists but was not created by compose\"+\n+\t\t\t\"Set `external: true` to use a network you created\", n.Name)\n+\t}\n+\n+\tvar ipam *network.IPAM\n+\tif n.Ipam.Config != nil {\n+\t\tvar config []network.IPAMConfig\n+\t\tfor _, pool := range n.Ipam.Config {\n+\t\t\tconfig = append(config, network.IPAMConfig{\n+\t\t\t\tSubnet:     pool.Subnet,\n+\t\t\t\tIPRange:    pool.IPRange,\n+\t\t\t\tGateway:    pool.Gateway,\n+\t\t\t\tAuxAddress: pool.AuxiliaryAddresses,\n+\t\t\t})\n \t\t}\n-\t\tcreateOpts := moby.NetworkCreate{\n-\t\t\tCheckDuplicate: true,\n-\t\t\t// TODO NameSpace Labels\n-\t\t\tLabels:     n.Labels,\n-\t\t\tDriver:     n.Driver,\n-\t\t\tOptions:    n.DriverOpts,\n-\t\t\tInternal:   n.Internal,\n-\t\t\tAttachable: n.Attachable,\n-\t\t\tIPAM:       ipam,\n-\t\t\tEnableIPv6: n.EnableIPv6,\n+\t\tipam = &network.IPAM{\n+\t\t\tDriver: n.Ipam.Driver,\n+\t\t\tConfig: config,\n \t\t}\n+\t}\n+\tcreateOpts := moby.NetworkCreate{\n+\t\tCheckDuplicate: true,\n+\t\tLabels:         n.Labels,\n+\t\tDriver:         n.Driver,\n+\t\tOptions:        n.DriverOpts,\n+\t\tInternal:       n.Internal,\n+\t\tAttachable:     n.Attachable,\n+\t\tIPAM:           ipam,\n+\t\tEnableIPv6:     n.EnableIPv6,\n+\t}\n+\n+\tif n.Ipam.Driver != \"\" || len(n.Ipam.Config) > 0 {\n+\t\tcreateOpts.IPAM = &network.IPAM{}\n+\t}\n+\n+\tif n.Ipam.Driver != \"\" {\n+\t\tcreateOpts.IPAM.Driver = n.Ipam.Driver\n+\t}\n \n-\t\tif n.Ipam.Driver != \"\" || len(n.Ipam.Config) > 0 {\n-\t\t\tcreateOpts.IPAM = &network.IPAM{}\n+\tfor _, ipamConfig := range n.Ipam.Config {\n+\t\tconfig := network.IPAMConfig{\n+\t\t\tSubnet:     ipamConfig.Subnet,\n+\t\t\tIPRange:    ipamConfig.IPRange,\n+\t\t\tGateway:    ipamConfig.Gateway,\n+\t\t\tAuxAddress: ipamConfig.AuxiliaryAddresses,\n \t\t}\n+\t\tcreateOpts.IPAM.Config = append(createOpts.IPAM.Config, config)\n+\t}\n+\tnetworkEventName := fmt.Sprintf(\"Network %s\", n.Name)\n+\tw := progress.ContextWriter(ctx)\n+\tw.Event(progress.CreatingEvent(networkEventName))\n \n-\t\tif n.Ipam.Driver != \"\" {\n-\t\t\tcreateOpts.IPAM.Driver = n.Ipam.Driver\n+\tcreated, err := s.apiClient().NetworkCreate(ctx, n.Name, createOpts)\n+\tif err != nil {\n+\t\tif errdefs.IsConflict(err) {\n+\t\t\t// Maybe another execution of `docker compose up|run` created same network\n+\t\t\t// let's retry\n+\t\t\treturn s.ensureNetwork(ctx, n)",
        "comment_created_at": "2023-05-24T20:19:39+00:00",
        "comment_author": "milas",
        "comment_body": "It seems better to let the error propagate here and fail the command. Since there's nothing like a project lock (which causes problems as your comment points out \ud83d\ude48), if state is changing underneath us, we should just fail IMO.\r\n\r\nAlternatively, I think we should at least not have `ensureNetwork` call itself recursively -- `409 Conflict` is unfortunately pretty generic (even in Moby land), so I'm sure there's some possibility of getting this into an infinite loop. I think returning the error and having something like `ensureNetworkWithRetries(name, retries)` that calls `ensureNetwork(name)` would be safer/easier to reason about",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "998393365",
    "pr_number": 9925,
    "pr_file": "pkg/compose/build_buildkit.go",
    "created_at": "2022-10-18T15:26:07+00:00",
    "commented_code": "dis := make([]build.DriverInfo, len(ng.Nodes))\n \tvar f driver.Factory\n \tif ng.Driver != \"\" {\n-\t\tfactories := driver.GetFactories()\n+\t\tfactories := driver.GetFactories(true)\n \t\tfor _, fac := range factories {\n \t\t\tif fac.Name() == ng.Driver {\n \t\t\t\tf = fac\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \t\tif f == nil {\n-\t\t\tif f = driver.GetFactory(ng.Driver, true); f == nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"failed to find buildx driver %q\", ng.Driver)\n+\t\t\tif f, err = driver.GetFactory(ng.Driver, true); f == nil || err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to find buildx driver %q, error: %s\", ng.Driver, err.Error())",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "998393365",
        "repo_full_name": "docker/compose",
        "pr_number": 9925,
        "pr_file": "pkg/compose/build_buildkit.go",
        "discussion_id": "998393365",
        "commented_code": "@@ -95,16 +95,16 @@ func (s *composeService) getDrivers(ctx context.Context) ([]build.DriverInfo, er\n \tdis := make([]build.DriverInfo, len(ng.Nodes))\n \tvar f driver.Factory\n \tif ng.Driver != \"\" {\n-\t\tfactories := driver.GetFactories()\n+\t\tfactories := driver.GetFactories(true)\n \t\tfor _, fac := range factories {\n \t\t\tif fac.Name() == ng.Driver {\n \t\t\t\tf = fac\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \t\tif f == nil {\n-\t\t\tif f = driver.GetFactory(ng.Driver, true); f == nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"failed to find buildx driver %q\", ng.Driver)\n+\t\t\tif f, err = driver.GetFactory(ng.Driver, true); f == nil || err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to find buildx driver %q, error: %s\", ng.Driver, err.Error())",
        "comment_created_at": "2022-10-18T15:26:07+00:00",
        "comment_author": "nicksieger",
        "comment_body": "minor:\r\n```suggestion\r\n\t\t\t\treturn nil, fmt.Errorf(\"failed to find buildx driver %q, error: %w\", ng.Driver, err)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "998401240",
        "repo_full_name": "docker/compose",
        "pr_number": 9925,
        "pr_file": "pkg/compose/build_buildkit.go",
        "discussion_id": "998393365",
        "commented_code": "@@ -95,16 +95,16 @@ func (s *composeService) getDrivers(ctx context.Context) ([]build.DriverInfo, er\n \tdis := make([]build.DriverInfo, len(ng.Nodes))\n \tvar f driver.Factory\n \tif ng.Driver != \"\" {\n-\t\tfactories := driver.GetFactories()\n+\t\tfactories := driver.GetFactories(true)\n \t\tfor _, fac := range factories {\n \t\t\tif fac.Name() == ng.Driver {\n \t\t\t\tf = fac\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n \t\tif f == nil {\n-\t\t\tif f = driver.GetFactory(ng.Driver, true); f == nil {\n-\t\t\t\treturn nil, fmt.Errorf(\"failed to find buildx driver %q\", ng.Driver)\n+\t\t\tif f, err = driver.GetFactory(ng.Driver, true); f == nil || err != nil {\n+\t\t\t\treturn nil, fmt.Errorf(\"failed to find buildx driver %q, error: %s\", ng.Driver, err.Error())",
        "comment_created_at": "2022-10-18T15:32:39+00:00",
        "comment_author": "milas",
        "comment_body": "lol you beat me by 3 mins!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "820517750",
    "pr_number": 9238,
    "pr_file": "pkg/compose/stop.go",
    "created_at": "2022-03-07T09:25:25+00:00",
    "commented_code": "}\n \n \tproject, err := s.projectFromName(containers, projectName, services...)\n-\tif err != nil {\n+\tif err != nil && !strings.HasPrefix(err.Error(), \"no container found for project\") {",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "820517750",
        "repo_full_name": "docker/compose",
        "pr_number": 9238,
        "pr_file": "pkg/compose/stop.go",
        "discussion_id": "820517750",
        "commented_code": "@@ -44,7 +44,7 @@ func (s *composeService) stop(ctx context.Context, projectName string, options a\n \t}\n \n \tproject, err := s.projectFromName(containers, projectName, services...)\n-\tif err != nil {\n+\tif err != nil && !strings.HasPrefix(err.Error(), \"no container found for project\") {",
        "comment_created_at": "2022-03-07T09:25:25+00:00",
        "comment_author": "ndeloof",
        "comment_body": "use `api.IsNotFoundError(err)`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "753009894",
    "pr_number": 8941,
    "pr_file": "pkg/compose/create.go",
    "created_at": "2021-11-19T09:26:12+00:00",
    "commented_code": "return nil\n }\n \n-func (s *composeService) ensureVolume(ctx context.Context, volume types.VolumeConfig) error {\n-\t// TODO could identify volume by label vs name\n-\t_, err := s.apiClient.VolumeInspect(ctx, volume.Name)\n+func (s *composeService) ensureVolume(ctx context.Context, volume types.VolumeConfig, project string) error {\n+\tinspected, err := s.apiClient.VolumeInspect(ctx, volume.Name)\n \tif err != nil {\n \t\tif !errdefs.IsNotFound(err) {\n \t\t\treturn err\n \t\t}\n-\t\teventName := fmt.Sprintf(\"Volume %q\", volume.Name)\n-\t\tw := progress.ContextWriter(ctx)\n-\t\tw.Event(progress.CreatingEvent(eventName))\n-\t\t_, err := s.apiClient.VolumeCreate(ctx, volume_api.VolumeCreateBody{\n-\t\t\tLabels:     volume.Labels,\n-\t\t\tName:       volume.Name,\n-\t\t\tDriver:     volume.Driver,\n-\t\t\tDriverOpts: volume.DriverOpts,\n-\t\t})\n-\t\tif err != nil {\n-\t\t\tw.Event(progress.ErrorEvent(eventName))\n-\t\t\treturn err\n-\t\t}\n-\t\tw.Event(progress.CreatedEvent(eventName))\n+\t\terr := s.createVolume(ctx, volume)\n+\t\treturn err\n+\t}\n+\n+\t// Volume exists with name, but let's double check this is the expected one\n+\t// (better safe than sorry when it comes to user's data)\n+\tp, ok := inspected.Labels[api.ProjectLabel]\n+\tif !ok {\n+\t\treturn fmt.Errorf(\"volume %q alrady exists but was not created by Docker Compose. Use `external: true` to use an existing volume\", volume.Name)",
    "repo_full_name": "docker/compose",
    "discussion_comments": [
      {
        "comment_id": "753009894",
        "repo_full_name": "docker/compose",
        "pr_number": 8941,
        "pr_file": "pkg/compose/create.go",
        "discussion_id": "753009894",
        "commented_code": "@@ -1086,27 +1086,42 @@ func (s *composeService) removeNetwork(ctx context.Context, networkID string, ne\n \treturn nil\n }\n \n-func (s *composeService) ensureVolume(ctx context.Context, volume types.VolumeConfig) error {\n-\t// TODO could identify volume by label vs name\n-\t_, err := s.apiClient.VolumeInspect(ctx, volume.Name)\n+func (s *composeService) ensureVolume(ctx context.Context, volume types.VolumeConfig, project string) error {\n+\tinspected, err := s.apiClient.VolumeInspect(ctx, volume.Name)\n \tif err != nil {\n \t\tif !errdefs.IsNotFound(err) {\n \t\t\treturn err\n \t\t}\n-\t\teventName := fmt.Sprintf(\"Volume %q\", volume.Name)\n-\t\tw := progress.ContextWriter(ctx)\n-\t\tw.Event(progress.CreatingEvent(eventName))\n-\t\t_, err := s.apiClient.VolumeCreate(ctx, volume_api.VolumeCreateBody{\n-\t\t\tLabels:     volume.Labels,\n-\t\t\tName:       volume.Name,\n-\t\t\tDriver:     volume.Driver,\n-\t\t\tDriverOpts: volume.DriverOpts,\n-\t\t})\n-\t\tif err != nil {\n-\t\t\tw.Event(progress.ErrorEvent(eventName))\n-\t\t\treturn err\n-\t\t}\n-\t\tw.Event(progress.CreatedEvent(eventName))\n+\t\terr := s.createVolume(ctx, volume)\n+\t\treturn err\n+\t}\n+\n+\t// Volume exists with name, but let's double check this is the expected one\n+\t// (better safe than sorry when it comes to user's data)\n+\tp, ok := inspected.Labels[api.ProjectLabel]\n+\tif !ok {\n+\t\treturn fmt.Errorf(\"volume %q alrady exists but was not created by Docker Compose. Use `external: true` to use an existing volume\", volume.Name)",
        "comment_created_at": "2021-11-19T09:26:12+00:00",
        "comment_author": "glours",
        "comment_body": "```suggestion\r\n\t\treturn fmt.Errorf(\"volume %q already exists but was not created by Docker Compose. Use `external: true` to use an existing volume\", volume.Name)\r\n```",
        "pr_file_module": null
      }
    ]
  }
]