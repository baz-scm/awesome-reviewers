[
  {
    "discussion_id": "2197789968",
    "pr_number": 6532,
    "pr_file": "extensions/intellij/src/main/kotlin/com/github/continuedev/continueintellijextension/nextEdit/NextEditWindowService.kt",
    "created_at": "2025-07-10T13:49:35+00:00",
    "commented_code": "+package com.github.continuedev.continueintellijextension.nextEdit\n+\n+import com.github.continuedev.continueintellijextension.services.ContinuePluginService\n+import com.intellij.openapi.actionSystem.AnAction\n+import com.intellij.openapi.actionSystem.AnActionEvent\n+import com.intellij.openapi.actionSystem.CustomShortcutSet\n+import com.intellij.openapi.command.WriteCommandAction\n+import com.intellij.openapi.components.Service\n+import com.intellij.openapi.components.service\n+import com.intellij.openapi.editor.Document\n+import com.intellij.openapi.editor.Editor\n+import com.intellij.openapi.editor.EditorSettings\n+import com.intellij.openapi.editor.colors.EditorColorsManager\n+import com.intellij.openapi.editor.ex.EditorEx\n+import com.intellij.openapi.editor.ex.EditorSettingsExternalizable\n+import com.intellij.openapi.editor.highlighter.EditorHighlighterFactory\n+import com.intellij.openapi.fileEditor.FileDocumentManager\n+import com.intellij.openapi.fileTypes.FileTypeManager\n+import com.intellij.openapi.fileTypes.SyntaxHighlighterFactory\n+import com.intellij.openapi.project.Project\n+import com.intellij.openapi.ui.popup.JBPopupFactory\n+import com.intellij.openapi.ui.popup.JBPopupListener\n+import com.intellij.openapi.ui.popup.LightweightWindowEvent\n+import com.intellij.psi.PsiDocumentManager\n+import com.intellij.ui.EditorTextField\n+import com.intellij.ui.components.JBScrollPane\n+import java.awt.BorderLayout\n+import java.awt.Color\n+import java.awt.Dimension\n+import java.awt.FlowLayout\n+import java.awt.Point\n+import java.awt.event.ActionEvent\n+import java.awt.event.KeyAdapter\n+import java.awt.event.KeyEvent\n+import javax.swing.AbstractAction\n+import javax.swing.JButton\n+import javax.swing.JComponent\n+import javax.swing.JPanel\n+import javax.swing.JScrollPane\n+import javax.swing.KeyStroke\n+\n+@Service(Service.Level.PROJECT)\n+class NextEditWindowService(private val project: Project) {\n+    /**\n+     * Creates a Swing component that displays syntax-highlighted code.\n+     *\n+     * @param code The code to display\n+     * @param language The language/file extension of the code (e.g. \"java\", \"kotlin\", \"py\")\n+     * @param isEditable Whether the code should be editable (default: false)\n+     * @return A JComponent that can be added to the UI\n+     */\n+    fun createCodeViewer(code: String, language: String, document: Document, isEditable: Boolean = false): JComponent {\n+        // Get file type based on extension.\n+        // NOTE: This is actually IDE and tier-dependent. For example, TypeScript won't work on IntelliJ CE.\n+        val fileType = FileTypeManager.getInstance().getFileTypeByExtension(language)\n+\n+        // Create an EditorTextField with the specified code and file type.\n+        val editorTextField = object : EditorTextField(code, project, fileType) {\n+            override fun createEditor(): EditorEx {\n+                val editor = super.createEditor()\n+\n+                // Configure editor settings.\n+                val settings: EditorSettings = editor.settings\n+                settings.isLineNumbersShown = true\n+                settings.isLineMarkerAreaShown = true\n+                settings.isIndentGuidesShown = true\n+                settings.isVirtualSpace = false\n+                settings.isRightMarginShown = false\n+                settings.additionalLinesCount = 0\n+                settings.isShowingSpecialChars = false\n+                settings.isCaretRowShown = true\n+\n+                // Set read-only if not editable.\n+                editor.isViewer = !isEditable\n+\n+                // Syntax highlighter.\n+                // Get current editor color scheme.\n+                val currentScheme = EditorColorsManager.getInstance().globalScheme\n+\n+                // Apply syntax highlighting with current theme.\n+                val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+                var syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, virtualFile)\n+\n+                // If we couldn't get a syntax highlighter from the file, try to get one just from the file type.\n+                if (syntaxHighlighter == null) {\n+                    syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, null)\n+                }\n+\n+                // If we have a highlighter, apply it.\n+                if (syntaxHighlighter != null) {\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        syntaxHighlighter,\n+                        currentScheme\n+                    )\n+                } else {\n+                    // Fallback to plain text highlighting if all attempts fail.\n+                    val plainTextFileType = FileTypeManager.getInstance().getFileTypeByExtension(\"txt\")\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        project,\n+                        plainTextFileType\n+                    )\n+                }\n+\n+                // Apply the theme's background color.\n+                editor.backgroundColor = currentScheme.defaultBackground\n+\n+                return editor\n+            }\n+\n+            // Override to ensure multi-line support.\n+            override fun getPreferredSize(): Dimension {\n+                val lineCount = code.lines().size\n+                // Adjust height based on line count (with some minimum).\n+                val preferredSize = super.getPreferredSize()\n+                val lineHeight = preferredSize.height / (if (lineCount > 0) lineCount else 1)\n+                val newHeight = lineHeight * (if (lineCount > 0) lineCount else 1) + 10 // Add padding\n+                return Dimension(preferredSize.width, newHeight)\n+            }\n+        }\n+\n+        // Enable multi-line mode.\n+        editorTextField.setOneLineMode(false)\n+\n+        // Wrap in a scroll pane for larger code blocks.\n+        val panel = JPanel(BorderLayout())\n+        panel.add(JBScrollPane(editorTextField), BorderLayout.CENTER)\n+\n+        return panel\n+    }\n+\n+    /**\n+     * Shows a popup dialog with the code preview.\n+     */\n+    fun showCodePreview(code: String, parentEditor: Editor, completionId: String) {\n+        // Use invokeAndWait or invokeLater to ensure we're on the EDT.\n+        com.intellij.openapi.application.ApplicationManager.getApplication().invokeLater {\n+            val codeViewer = createCodeViewer(code, getFileLanguage(parentEditor.document), parentEditor.document)\n+\n+            // Create a button panel.\n+            val buttonPanel = JPanel(FlowLayout(FlowLayout.RIGHT))\n+            val acceptButton = JButton(\"Accept (Tab)\")\n+            val dismissButton = JButton(\"Dismiss (Esc)\")\n+            buttonPanel.add(acceptButton)\n+            buttonPanel.add(dismissButton)\n+\n+            // Create a panel to hold the code viewer and buttons.\n+            val panel = JPanel(BorderLayout())\n+            panel.add(codeViewer, BorderLayout.CENTER)\n+            panel.add(buttonPanel, BorderLayout.SOUTH)\n+\n+\n+            // Create the popup.\n+            val popup = JBPopupFactory.getInstance()\n+                .createComponentPopupBuilder(panel, codeViewer)\n+                .setMovable(true)\n+                .setResizable(true)\n+                .setRequestFocus(true)\n+                .setCancelOnClickOutside(true)\n+                .setCancelOnOtherWindowOpen(true)\n+                .setFocusable(true)\n+                .addListener(object : JBPopupListener {\n+                    override fun onClosed(event: LightweightWindowEvent) {\n+                        if (!event.isOk) {\n+                            // This only triggers when dismissed, not when accepted.\n+                            println(\"Dismissing code preview popup\")\n+                            project.service<ContinuePluginService>().coreMessenger?.request(\n+                                \"nextEdit/reject\",\n+                                hashMapOf(\"completionId\" to completionId),\n+                                null, ({})\n+                            )\n+                        }\n+                    }\n+                })\n+                .createPopup()\n+\n+            // Helper function to accept the code and apply it to the editor.\n+            fun acceptCode() {\n+                val document = parentEditor.document\n+                val caretModel = parentEditor.caretModel\n+                val caretOffset = caretModel.offset\n+                val caretPosition = document.getLineNumber(caretOffset)\n+\n+                // Calculate start and end lines.\n+                val totalLines = document.lineCount\n+                val startLine = maxOf(0, caretPosition - 5)\n+                val endLine = minOf(totalLines - 1, caretPosition + 5)\n+\n+                // Get start and end offsets.\n+                val startOffset = document.getLineStartOffset(startLine)\n+                val endOffset = document.getLineEndOffset(endLine)\n+\n+                // Write command to replace the text.\n+                WriteCommandAction.runWriteCommandAction(project) {\n+                    document.replaceString(startOffset, endOffset, code)\n+                }\n+\n+                project.service<ContinuePluginService>().coreMessenger?.request(\n+                    \"nextEdit/accept\",\n+                    hashMapOf(\"completionId\" to completionId),\n+                    null, ({})\n+                )\n+            }\n+\n+            // Use ActionManager to handle Tab key globally during popup display.\n+            val acceptAction = object : AnAction() {\n+                override fun actionPerformed(e: AnActionEvent) {\n+                    acceptCode()\n+                    popup.closeOk(null)\n+                }\n+            }\n+\n+            // Create a custom shortcut set for the Tab key.\n+            val customShortcutSet = CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0))\n+\n+\n+            // Register action with shortcut.\n+            acceptAction.registerCustomShortcutSet(customShortcutSet, panel)\n+\n+            // Add button actions.\n+            acceptButton.addActionListener {\n+                acceptCode()\n+                popup.closeOk(null)\n+            }\n+\n+            dismissButton.addActionListener {\n+                popup.cancel()\n+            }\n+\n+            // Get the exact position of the cursor.\n+            val visualPosition = parentEditor.caretModel.visualPosition\n+            val cursorPoint = parentEditor.visualPositionToXY(visualPosition)\n+\n+            // Convert to screen coordinates.\n+            val editorComponent = parentEditor.component\n+            val locationOnScreen = editorComponent.locationOnScreen\n+            val screenPoint = Point(\n+                locationOnScreen.x + cursorPoint.x,\n+                locationOnScreen.y + cursorPoint.y\n+            )\n+\n+            // Show the popup at the cursor position.\n+            popup.showInScreenCoordinates(editorComponent, screenPoint)\n+\n+            // Ensure proper focus for keyboard shortcuts.\n+            codeViewer.requestFocusInWindow()\n+        }\n+    }\n+\n+    // Move editorConfig to a proper instance property that gets actual editor settings.\n+    private val editorConfig: EditorConfig by lazy {\n+        val settings = EditorSettingsExternalizable.getInstance()\n+        val editorFontSize = EditorColorsManager.getInstance().globalScheme.editorFontSize\n+        val editorFontFamily = EditorColorsManager.getInstance().globalScheme.editorFontName\n+\n+        EditorConfig(\n+            fontSize = editorFontSize.toDouble(),\n+            fontFamily = editorFontFamily\n+        )\n+    }\n+\n+    // Data class to hold editor configuration.\n+    private data class EditorConfig(\n+        val fontSize: Double = 14.0,\n+        val fontFamily: String = \"JetBrains Mono\"\n+    )\n+\n+    /**\n+     * Convenience method to map common programming languages to their file extensions.\n+     */\n+    fun mapLanguageToExtension(language: String): String {\n+        return when (language.lowercase()) {\n+            \"javascript\" -> \"js\"\n+            \"typescript\" -> \"ts\"\n+            \"python\" -> \"py\"\n+            \"java\" -> \"java\"\n+            \"kotlin\" -> \"kt\"\n+            \"c++\" -> \"cpp\"\n+            \"c#\" -> \"cs\"\n+            \"go\" -> \"go\"\n+            \"rust\" -> \"rs\"\n+            \"ruby\" -> \"rb\"\n+            \"php\" -> \"php\"\n+            \"swift\" -> \"swift\"\n+            \"shell\", \"bash\" -> \"sh\"\n+            \"html\" -> \"html\"\n+            \"css\" -> \"css\"\n+            \"json\" -> \"json\"\n+            \"xml\" -> \"xml\"\n+            \"yaml\", \"yml\" -> \"yaml\"\n+            \"markdown\", \"md\" -> \"md\"\n+            // Add more mappings as needed\n+            else -> language\n+        }\n+    }\n+\n+    private fun getFileLanguage(document: Document): String {\n+        val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+        return virtualFile?.extension?.lowercase() ?: \"text\"\n+    }\n+\n+    companion object {\n+        fun getInstance(project: Project): NextEditWindowService = project.service()\n+    }\n+}",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2197789968",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6532,
        "pr_file": "extensions/intellij/src/main/kotlin/com/github/continuedev/continueintellijextension/nextEdit/NextEditWindowService.kt",
        "discussion_id": "2197789968",
        "commented_code": "@@ -0,0 +1,304 @@\n+package com.github.continuedev.continueintellijextension.nextEdit\n+\n+import com.github.continuedev.continueintellijextension.services.ContinuePluginService\n+import com.intellij.openapi.actionSystem.AnAction\n+import com.intellij.openapi.actionSystem.AnActionEvent\n+import com.intellij.openapi.actionSystem.CustomShortcutSet\n+import com.intellij.openapi.command.WriteCommandAction\n+import com.intellij.openapi.components.Service\n+import com.intellij.openapi.components.service\n+import com.intellij.openapi.editor.Document\n+import com.intellij.openapi.editor.Editor\n+import com.intellij.openapi.editor.EditorSettings\n+import com.intellij.openapi.editor.colors.EditorColorsManager\n+import com.intellij.openapi.editor.ex.EditorEx\n+import com.intellij.openapi.editor.ex.EditorSettingsExternalizable\n+import com.intellij.openapi.editor.highlighter.EditorHighlighterFactory\n+import com.intellij.openapi.fileEditor.FileDocumentManager\n+import com.intellij.openapi.fileTypes.FileTypeManager\n+import com.intellij.openapi.fileTypes.SyntaxHighlighterFactory\n+import com.intellij.openapi.project.Project\n+import com.intellij.openapi.ui.popup.JBPopupFactory\n+import com.intellij.openapi.ui.popup.JBPopupListener\n+import com.intellij.openapi.ui.popup.LightweightWindowEvent\n+import com.intellij.psi.PsiDocumentManager\n+import com.intellij.ui.EditorTextField\n+import com.intellij.ui.components.JBScrollPane\n+import java.awt.BorderLayout\n+import java.awt.Color\n+import java.awt.Dimension\n+import java.awt.FlowLayout\n+import java.awt.Point\n+import java.awt.event.ActionEvent\n+import java.awt.event.KeyAdapter\n+import java.awt.event.KeyEvent\n+import javax.swing.AbstractAction\n+import javax.swing.JButton\n+import javax.swing.JComponent\n+import javax.swing.JPanel\n+import javax.swing.JScrollPane\n+import javax.swing.KeyStroke\n+\n+@Service(Service.Level.PROJECT)\n+class NextEditWindowService(private val project: Project) {\n+    /**\n+     * Creates a Swing component that displays syntax-highlighted code.\n+     *\n+     * @param code The code to display\n+     * @param language The language/file extension of the code (e.g. \"java\", \"kotlin\", \"py\")\n+     * @param isEditable Whether the code should be editable (default: false)\n+     * @return A JComponent that can be added to the UI\n+     */\n+    fun createCodeViewer(code: String, language: String, document: Document, isEditable: Boolean = false): JComponent {\n+        // Get file type based on extension.\n+        // NOTE: This is actually IDE and tier-dependent. For example, TypeScript won't work on IntelliJ CE.\n+        val fileType = FileTypeManager.getInstance().getFileTypeByExtension(language)\n+\n+        // Create an EditorTextField with the specified code and file type.\n+        val editorTextField = object : EditorTextField(code, project, fileType) {\n+            override fun createEditor(): EditorEx {\n+                val editor = super.createEditor()\n+\n+                // Configure editor settings.\n+                val settings: EditorSettings = editor.settings\n+                settings.isLineNumbersShown = true\n+                settings.isLineMarkerAreaShown = true\n+                settings.isIndentGuidesShown = true\n+                settings.isVirtualSpace = false\n+                settings.isRightMarginShown = false\n+                settings.additionalLinesCount = 0\n+                settings.isShowingSpecialChars = false\n+                settings.isCaretRowShown = true\n+\n+                // Set read-only if not editable.\n+                editor.isViewer = !isEditable\n+\n+                // Syntax highlighter.\n+                // Get current editor color scheme.\n+                val currentScheme = EditorColorsManager.getInstance().globalScheme\n+\n+                // Apply syntax highlighting with current theme.\n+                val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+                var syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, virtualFile)\n+\n+                // If we couldn't get a syntax highlighter from the file, try to get one just from the file type.\n+                if (syntaxHighlighter == null) {\n+                    syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, null)\n+                }\n+\n+                // If we have a highlighter, apply it.\n+                if (syntaxHighlighter != null) {\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        syntaxHighlighter,\n+                        currentScheme\n+                    )\n+                } else {\n+                    // Fallback to plain text highlighting if all attempts fail.\n+                    val plainTextFileType = FileTypeManager.getInstance().getFileTypeByExtension(\"txt\")\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        project,\n+                        plainTextFileType\n+                    )\n+                }\n+\n+                // Apply the theme's background color.\n+                editor.backgroundColor = currentScheme.defaultBackground\n+\n+                return editor\n+            }\n+\n+            // Override to ensure multi-line support.\n+            override fun getPreferredSize(): Dimension {\n+                val lineCount = code.lines().size\n+                // Adjust height based on line count (with some minimum).\n+                val preferredSize = super.getPreferredSize()\n+                val lineHeight = preferredSize.height / (if (lineCount > 0) lineCount else 1)\n+                val newHeight = lineHeight * (if (lineCount > 0) lineCount else 1) + 10 // Add padding\n+                return Dimension(preferredSize.width, newHeight)\n+            }\n+        }\n+\n+        // Enable multi-line mode.\n+        editorTextField.setOneLineMode(false)\n+\n+        // Wrap in a scroll pane for larger code blocks.\n+        val panel = JPanel(BorderLayout())\n+        panel.add(JBScrollPane(editorTextField), BorderLayout.CENTER)\n+\n+        return panel\n+    }\n+\n+    /**\n+     * Shows a popup dialog with the code preview.\n+     */\n+    fun showCodePreview(code: String, parentEditor: Editor, completionId: String) {\n+        // Use invokeAndWait or invokeLater to ensure we're on the EDT.\n+        com.intellij.openapi.application.ApplicationManager.getApplication().invokeLater {\n+            val codeViewer = createCodeViewer(code, getFileLanguage(parentEditor.document), parentEditor.document)\n+\n+            // Create a button panel.\n+            val buttonPanel = JPanel(FlowLayout(FlowLayout.RIGHT))\n+            val acceptButton = JButton(\"Accept (Tab)\")\n+            val dismissButton = JButton(\"Dismiss (Esc)\")\n+            buttonPanel.add(acceptButton)\n+            buttonPanel.add(dismissButton)\n+\n+            // Create a panel to hold the code viewer and buttons.\n+            val panel = JPanel(BorderLayout())\n+            panel.add(codeViewer, BorderLayout.CENTER)\n+            panel.add(buttonPanel, BorderLayout.SOUTH)\n+\n+\n+            // Create the popup.\n+            val popup = JBPopupFactory.getInstance()\n+                .createComponentPopupBuilder(panel, codeViewer)\n+                .setMovable(true)\n+                .setResizable(true)\n+                .setRequestFocus(true)\n+                .setCancelOnClickOutside(true)\n+                .setCancelOnOtherWindowOpen(true)\n+                .setFocusable(true)\n+                .addListener(object : JBPopupListener {\n+                    override fun onClosed(event: LightweightWindowEvent) {\n+                        if (!event.isOk) {\n+                            // This only triggers when dismissed, not when accepted.\n+                            println(\"Dismissing code preview popup\")\n+                            project.service<ContinuePluginService>().coreMessenger?.request(\n+                                \"nextEdit/reject\",\n+                                hashMapOf(\"completionId\" to completionId),\n+                                null, ({})\n+                            )\n+                        }\n+                    }\n+                })\n+                .createPopup()\n+\n+            // Helper function to accept the code and apply it to the editor.\n+            fun acceptCode() {\n+                val document = parentEditor.document\n+                val caretModel = parentEditor.caretModel\n+                val caretOffset = caretModel.offset\n+                val caretPosition = document.getLineNumber(caretOffset)\n+\n+                // Calculate start and end lines.\n+                val totalLines = document.lineCount\n+                val startLine = maxOf(0, caretPosition - 5)\n+                val endLine = minOf(totalLines - 1, caretPosition + 5)\n+\n+                // Get start and end offsets.\n+                val startOffset = document.getLineStartOffset(startLine)\n+                val endOffset = document.getLineEndOffset(endLine)\n+\n+                // Write command to replace the text.\n+                WriteCommandAction.runWriteCommandAction(project) {\n+                    document.replaceString(startOffset, endOffset, code)\n+                }\n+\n+                project.service<ContinuePluginService>().coreMessenger?.request(\n+                    \"nextEdit/accept\",\n+                    hashMapOf(\"completionId\" to completionId),\n+                    null, ({})\n+                )\n+            }\n+\n+            // Use ActionManager to handle Tab key globally during popup display.\n+            val acceptAction = object : AnAction() {\n+                override fun actionPerformed(e: AnActionEvent) {\n+                    acceptCode()\n+                    popup.closeOk(null)\n+                }\n+            }\n+\n+            // Create a custom shortcut set for the Tab key.\n+            val customShortcutSet = CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0))\n+\n+\n+            // Register action with shortcut.\n+            acceptAction.registerCustomShortcutSet(customShortcutSet, panel)\n+\n+            // Add button actions.\n+            acceptButton.addActionListener {\n+                acceptCode()\n+                popup.closeOk(null)\n+            }\n+\n+            dismissButton.addActionListener {\n+                popup.cancel()\n+            }\n+\n+            // Get the exact position of the cursor.\n+            val visualPosition = parentEditor.caretModel.visualPosition\n+            val cursorPoint = parentEditor.visualPositionToXY(visualPosition)\n+\n+            // Convert to screen coordinates.\n+            val editorComponent = parentEditor.component\n+            val locationOnScreen = editorComponent.locationOnScreen\n+            val screenPoint = Point(\n+                locationOnScreen.x + cursorPoint.x,\n+                locationOnScreen.y + cursorPoint.y\n+            )\n+\n+            // Show the popup at the cursor position.\n+            popup.showInScreenCoordinates(editorComponent, screenPoint)\n+\n+            // Ensure proper focus for keyboard shortcuts.\n+            codeViewer.requestFocusInWindow()\n+        }\n+    }\n+\n+    // Move editorConfig to a proper instance property that gets actual editor settings.\n+    private val editorConfig: EditorConfig by lazy {\n+        val settings = EditorSettingsExternalizable.getInstance()\n+        val editorFontSize = EditorColorsManager.getInstance().globalScheme.editorFontSize\n+        val editorFontFamily = EditorColorsManager.getInstance().globalScheme.editorFontName\n+\n+        EditorConfig(\n+            fontSize = editorFontSize.toDouble(),\n+            fontFamily = editorFontFamily\n+        )\n+    }\n+\n+    // Data class to hold editor configuration.\n+    private data class EditorConfig(\n+        val fontSize: Double = 14.0,\n+        val fontFamily: String = \"JetBrains Mono\"\n+    )\n+\n+    /**\n+     * Convenience method to map common programming languages to their file extensions.\n+     */\n+    fun mapLanguageToExtension(language: String): String {\n+        return when (language.lowercase()) {\n+            \"javascript\" -> \"js\"\n+            \"typescript\" -> \"ts\"\n+            \"python\" -> \"py\"\n+            \"java\" -> \"java\"\n+            \"kotlin\" -> \"kt\"\n+            \"c++\" -> \"cpp\"\n+            \"c#\" -> \"cs\"\n+            \"go\" -> \"go\"\n+            \"rust\" -> \"rs\"\n+            \"ruby\" -> \"rb\"\n+            \"php\" -> \"php\"\n+            \"swift\" -> \"swift\"\n+            \"shell\", \"bash\" -> \"sh\"\n+            \"html\" -> \"html\"\n+            \"css\" -> \"css\"\n+            \"json\" -> \"json\"\n+            \"xml\" -> \"xml\"\n+            \"yaml\", \"yml\" -> \"yaml\"\n+            \"markdown\", \"md\" -> \"md\"\n+            // Add more mappings as needed\n+            else -> language\n+        }\n+    }\n+\n+    private fun getFileLanguage(document: Document): String {\n+        val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+        return virtualFile?.extension?.lowercase() ?: \"text\"\n+    }\n+\n+    companion object {\n+        fun getInstance(project: Project): NextEditWindowService = project.service()\n+    }\n+}",
        "comment_created_at": "2025-07-10T13:49:35+00:00",
        "comment_author": "exigow",
        "comment_body": "This `NextEditService` class shares large portions of code with `AutocompleteService`. I compared both files and noticed a lot of copy-paste. :smile:  Shouldn't we extract some common parts into an abstract class or utility methods?\r\n\r\nI’m especially thinking about methods like `deduplicateCompletion`, requests, `triggerNextEdit` (which is basically a copy of `triggerCompletion` + extra code), and probably others as well. I’m not sure it’s a good idea to maintain these two features in this way (long-term).",
        "pr_file_module": null
      },
      {
        "comment_id": "2197807504",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6532,
        "pr_file": "extensions/intellij/src/main/kotlin/com/github/continuedev/continueintellijextension/nextEdit/NextEditWindowService.kt",
        "discussion_id": "2197789968",
        "commented_code": "@@ -0,0 +1,304 @@\n+package com.github.continuedev.continueintellijextension.nextEdit\n+\n+import com.github.continuedev.continueintellijextension.services.ContinuePluginService\n+import com.intellij.openapi.actionSystem.AnAction\n+import com.intellij.openapi.actionSystem.AnActionEvent\n+import com.intellij.openapi.actionSystem.CustomShortcutSet\n+import com.intellij.openapi.command.WriteCommandAction\n+import com.intellij.openapi.components.Service\n+import com.intellij.openapi.components.service\n+import com.intellij.openapi.editor.Document\n+import com.intellij.openapi.editor.Editor\n+import com.intellij.openapi.editor.EditorSettings\n+import com.intellij.openapi.editor.colors.EditorColorsManager\n+import com.intellij.openapi.editor.ex.EditorEx\n+import com.intellij.openapi.editor.ex.EditorSettingsExternalizable\n+import com.intellij.openapi.editor.highlighter.EditorHighlighterFactory\n+import com.intellij.openapi.fileEditor.FileDocumentManager\n+import com.intellij.openapi.fileTypes.FileTypeManager\n+import com.intellij.openapi.fileTypes.SyntaxHighlighterFactory\n+import com.intellij.openapi.project.Project\n+import com.intellij.openapi.ui.popup.JBPopupFactory\n+import com.intellij.openapi.ui.popup.JBPopupListener\n+import com.intellij.openapi.ui.popup.LightweightWindowEvent\n+import com.intellij.psi.PsiDocumentManager\n+import com.intellij.ui.EditorTextField\n+import com.intellij.ui.components.JBScrollPane\n+import java.awt.BorderLayout\n+import java.awt.Color\n+import java.awt.Dimension\n+import java.awt.FlowLayout\n+import java.awt.Point\n+import java.awt.event.ActionEvent\n+import java.awt.event.KeyAdapter\n+import java.awt.event.KeyEvent\n+import javax.swing.AbstractAction\n+import javax.swing.JButton\n+import javax.swing.JComponent\n+import javax.swing.JPanel\n+import javax.swing.JScrollPane\n+import javax.swing.KeyStroke\n+\n+@Service(Service.Level.PROJECT)\n+class NextEditWindowService(private val project: Project) {\n+    /**\n+     * Creates a Swing component that displays syntax-highlighted code.\n+     *\n+     * @param code The code to display\n+     * @param language The language/file extension of the code (e.g. \"java\", \"kotlin\", \"py\")\n+     * @param isEditable Whether the code should be editable (default: false)\n+     * @return A JComponent that can be added to the UI\n+     */\n+    fun createCodeViewer(code: String, language: String, document: Document, isEditable: Boolean = false): JComponent {\n+        // Get file type based on extension.\n+        // NOTE: This is actually IDE and tier-dependent. For example, TypeScript won't work on IntelliJ CE.\n+        val fileType = FileTypeManager.getInstance().getFileTypeByExtension(language)\n+\n+        // Create an EditorTextField with the specified code and file type.\n+        val editorTextField = object : EditorTextField(code, project, fileType) {\n+            override fun createEditor(): EditorEx {\n+                val editor = super.createEditor()\n+\n+                // Configure editor settings.\n+                val settings: EditorSettings = editor.settings\n+                settings.isLineNumbersShown = true\n+                settings.isLineMarkerAreaShown = true\n+                settings.isIndentGuidesShown = true\n+                settings.isVirtualSpace = false\n+                settings.isRightMarginShown = false\n+                settings.additionalLinesCount = 0\n+                settings.isShowingSpecialChars = false\n+                settings.isCaretRowShown = true\n+\n+                // Set read-only if not editable.\n+                editor.isViewer = !isEditable\n+\n+                // Syntax highlighter.\n+                // Get current editor color scheme.\n+                val currentScheme = EditorColorsManager.getInstance().globalScheme\n+\n+                // Apply syntax highlighting with current theme.\n+                val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+                var syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, virtualFile)\n+\n+                // If we couldn't get a syntax highlighter from the file, try to get one just from the file type.\n+                if (syntaxHighlighter == null) {\n+                    syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, null)\n+                }\n+\n+                // If we have a highlighter, apply it.\n+                if (syntaxHighlighter != null) {\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        syntaxHighlighter,\n+                        currentScheme\n+                    )\n+                } else {\n+                    // Fallback to plain text highlighting if all attempts fail.\n+                    val plainTextFileType = FileTypeManager.getInstance().getFileTypeByExtension(\"txt\")\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        project,\n+                        plainTextFileType\n+                    )\n+                }\n+\n+                // Apply the theme's background color.\n+                editor.backgroundColor = currentScheme.defaultBackground\n+\n+                return editor\n+            }\n+\n+            // Override to ensure multi-line support.\n+            override fun getPreferredSize(): Dimension {\n+                val lineCount = code.lines().size\n+                // Adjust height based on line count (with some minimum).\n+                val preferredSize = super.getPreferredSize()\n+                val lineHeight = preferredSize.height / (if (lineCount > 0) lineCount else 1)\n+                val newHeight = lineHeight * (if (lineCount > 0) lineCount else 1) + 10 // Add padding\n+                return Dimension(preferredSize.width, newHeight)\n+            }\n+        }\n+\n+        // Enable multi-line mode.\n+        editorTextField.setOneLineMode(false)\n+\n+        // Wrap in a scroll pane for larger code blocks.\n+        val panel = JPanel(BorderLayout())\n+        panel.add(JBScrollPane(editorTextField), BorderLayout.CENTER)\n+\n+        return panel\n+    }\n+\n+    /**\n+     * Shows a popup dialog with the code preview.\n+     */\n+    fun showCodePreview(code: String, parentEditor: Editor, completionId: String) {\n+        // Use invokeAndWait or invokeLater to ensure we're on the EDT.\n+        com.intellij.openapi.application.ApplicationManager.getApplication().invokeLater {\n+            val codeViewer = createCodeViewer(code, getFileLanguage(parentEditor.document), parentEditor.document)\n+\n+            // Create a button panel.\n+            val buttonPanel = JPanel(FlowLayout(FlowLayout.RIGHT))\n+            val acceptButton = JButton(\"Accept (Tab)\")\n+            val dismissButton = JButton(\"Dismiss (Esc)\")\n+            buttonPanel.add(acceptButton)\n+            buttonPanel.add(dismissButton)\n+\n+            // Create a panel to hold the code viewer and buttons.\n+            val panel = JPanel(BorderLayout())\n+            panel.add(codeViewer, BorderLayout.CENTER)\n+            panel.add(buttonPanel, BorderLayout.SOUTH)\n+\n+\n+            // Create the popup.\n+            val popup = JBPopupFactory.getInstance()\n+                .createComponentPopupBuilder(panel, codeViewer)\n+                .setMovable(true)\n+                .setResizable(true)\n+                .setRequestFocus(true)\n+                .setCancelOnClickOutside(true)\n+                .setCancelOnOtherWindowOpen(true)\n+                .setFocusable(true)\n+                .addListener(object : JBPopupListener {\n+                    override fun onClosed(event: LightweightWindowEvent) {\n+                        if (!event.isOk) {\n+                            // This only triggers when dismissed, not when accepted.\n+                            println(\"Dismissing code preview popup\")\n+                            project.service<ContinuePluginService>().coreMessenger?.request(\n+                                \"nextEdit/reject\",\n+                                hashMapOf(\"completionId\" to completionId),\n+                                null, ({})\n+                            )\n+                        }\n+                    }\n+                })\n+                .createPopup()\n+\n+            // Helper function to accept the code and apply it to the editor.\n+            fun acceptCode() {\n+                val document = parentEditor.document\n+                val caretModel = parentEditor.caretModel\n+                val caretOffset = caretModel.offset\n+                val caretPosition = document.getLineNumber(caretOffset)\n+\n+                // Calculate start and end lines.\n+                val totalLines = document.lineCount\n+                val startLine = maxOf(0, caretPosition - 5)\n+                val endLine = minOf(totalLines - 1, caretPosition + 5)\n+\n+                // Get start and end offsets.\n+                val startOffset = document.getLineStartOffset(startLine)\n+                val endOffset = document.getLineEndOffset(endLine)\n+\n+                // Write command to replace the text.\n+                WriteCommandAction.runWriteCommandAction(project) {\n+                    document.replaceString(startOffset, endOffset, code)\n+                }\n+\n+                project.service<ContinuePluginService>().coreMessenger?.request(\n+                    \"nextEdit/accept\",\n+                    hashMapOf(\"completionId\" to completionId),\n+                    null, ({})\n+                )\n+            }\n+\n+            // Use ActionManager to handle Tab key globally during popup display.\n+            val acceptAction = object : AnAction() {\n+                override fun actionPerformed(e: AnActionEvent) {\n+                    acceptCode()\n+                    popup.closeOk(null)\n+                }\n+            }\n+\n+            // Create a custom shortcut set for the Tab key.\n+            val customShortcutSet = CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0))\n+\n+\n+            // Register action with shortcut.\n+            acceptAction.registerCustomShortcutSet(customShortcutSet, panel)\n+\n+            // Add button actions.\n+            acceptButton.addActionListener {\n+                acceptCode()\n+                popup.closeOk(null)\n+            }\n+\n+            dismissButton.addActionListener {\n+                popup.cancel()\n+            }\n+\n+            // Get the exact position of the cursor.\n+            val visualPosition = parentEditor.caretModel.visualPosition\n+            val cursorPoint = parentEditor.visualPositionToXY(visualPosition)\n+\n+            // Convert to screen coordinates.\n+            val editorComponent = parentEditor.component\n+            val locationOnScreen = editorComponent.locationOnScreen\n+            val screenPoint = Point(\n+                locationOnScreen.x + cursorPoint.x,\n+                locationOnScreen.y + cursorPoint.y\n+            )\n+\n+            // Show the popup at the cursor position.\n+            popup.showInScreenCoordinates(editorComponent, screenPoint)\n+\n+            // Ensure proper focus for keyboard shortcuts.\n+            codeViewer.requestFocusInWindow()\n+        }\n+    }\n+\n+    // Move editorConfig to a proper instance property that gets actual editor settings.\n+    private val editorConfig: EditorConfig by lazy {\n+        val settings = EditorSettingsExternalizable.getInstance()\n+        val editorFontSize = EditorColorsManager.getInstance().globalScheme.editorFontSize\n+        val editorFontFamily = EditorColorsManager.getInstance().globalScheme.editorFontName\n+\n+        EditorConfig(\n+            fontSize = editorFontSize.toDouble(),\n+            fontFamily = editorFontFamily\n+        )\n+    }\n+\n+    // Data class to hold editor configuration.\n+    private data class EditorConfig(\n+        val fontSize: Double = 14.0,\n+        val fontFamily: String = \"JetBrains Mono\"\n+    )\n+\n+    /**\n+     * Convenience method to map common programming languages to their file extensions.\n+     */\n+    fun mapLanguageToExtension(language: String): String {\n+        return when (language.lowercase()) {\n+            \"javascript\" -> \"js\"\n+            \"typescript\" -> \"ts\"\n+            \"python\" -> \"py\"\n+            \"java\" -> \"java\"\n+            \"kotlin\" -> \"kt\"\n+            \"c++\" -> \"cpp\"\n+            \"c#\" -> \"cs\"\n+            \"go\" -> \"go\"\n+            \"rust\" -> \"rs\"\n+            \"ruby\" -> \"rb\"\n+            \"php\" -> \"php\"\n+            \"swift\" -> \"swift\"\n+            \"shell\", \"bash\" -> \"sh\"\n+            \"html\" -> \"html\"\n+            \"css\" -> \"css\"\n+            \"json\" -> \"json\"\n+            \"xml\" -> \"xml\"\n+            \"yaml\", \"yml\" -> \"yaml\"\n+            \"markdown\", \"md\" -> \"md\"\n+            // Add more mappings as needed\n+            else -> language\n+        }\n+    }\n+\n+    private fun getFileLanguage(document: Document): String {\n+        val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+        return virtualFile?.extension?.lowercase() ?: \"text\"\n+    }\n+\n+    companion object {\n+        fun getInstance(project: Project): NextEditWindowService = project.service()\n+    }\n+}",
        "comment_created_at": "2025-07-10T13:54:57+00:00",
        "comment_author": "exigow",
        "comment_body": "BTW, from what I understand, this is for internal testing, so I don’t think my concerns are an issue. :+1: But if we want to enable it at some point, it definitely needs a refactor.",
        "pr_file_module": null
      },
      {
        "comment_id": "2198681476",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6532,
        "pr_file": "extensions/intellij/src/main/kotlin/com/github/continuedev/continueintellijextension/nextEdit/NextEditWindowService.kt",
        "discussion_id": "2197789968",
        "commented_code": "@@ -0,0 +1,304 @@\n+package com.github.continuedev.continueintellijextension.nextEdit\n+\n+import com.github.continuedev.continueintellijextension.services.ContinuePluginService\n+import com.intellij.openapi.actionSystem.AnAction\n+import com.intellij.openapi.actionSystem.AnActionEvent\n+import com.intellij.openapi.actionSystem.CustomShortcutSet\n+import com.intellij.openapi.command.WriteCommandAction\n+import com.intellij.openapi.components.Service\n+import com.intellij.openapi.components.service\n+import com.intellij.openapi.editor.Document\n+import com.intellij.openapi.editor.Editor\n+import com.intellij.openapi.editor.EditorSettings\n+import com.intellij.openapi.editor.colors.EditorColorsManager\n+import com.intellij.openapi.editor.ex.EditorEx\n+import com.intellij.openapi.editor.ex.EditorSettingsExternalizable\n+import com.intellij.openapi.editor.highlighter.EditorHighlighterFactory\n+import com.intellij.openapi.fileEditor.FileDocumentManager\n+import com.intellij.openapi.fileTypes.FileTypeManager\n+import com.intellij.openapi.fileTypes.SyntaxHighlighterFactory\n+import com.intellij.openapi.project.Project\n+import com.intellij.openapi.ui.popup.JBPopupFactory\n+import com.intellij.openapi.ui.popup.JBPopupListener\n+import com.intellij.openapi.ui.popup.LightweightWindowEvent\n+import com.intellij.psi.PsiDocumentManager\n+import com.intellij.ui.EditorTextField\n+import com.intellij.ui.components.JBScrollPane\n+import java.awt.BorderLayout\n+import java.awt.Color\n+import java.awt.Dimension\n+import java.awt.FlowLayout\n+import java.awt.Point\n+import java.awt.event.ActionEvent\n+import java.awt.event.KeyAdapter\n+import java.awt.event.KeyEvent\n+import javax.swing.AbstractAction\n+import javax.swing.JButton\n+import javax.swing.JComponent\n+import javax.swing.JPanel\n+import javax.swing.JScrollPane\n+import javax.swing.KeyStroke\n+\n+@Service(Service.Level.PROJECT)\n+class NextEditWindowService(private val project: Project) {\n+    /**\n+     * Creates a Swing component that displays syntax-highlighted code.\n+     *\n+     * @param code The code to display\n+     * @param language The language/file extension of the code (e.g. \"java\", \"kotlin\", \"py\")\n+     * @param isEditable Whether the code should be editable (default: false)\n+     * @return A JComponent that can be added to the UI\n+     */\n+    fun createCodeViewer(code: String, language: String, document: Document, isEditable: Boolean = false): JComponent {\n+        // Get file type based on extension.\n+        // NOTE: This is actually IDE and tier-dependent. For example, TypeScript won't work on IntelliJ CE.\n+        val fileType = FileTypeManager.getInstance().getFileTypeByExtension(language)\n+\n+        // Create an EditorTextField with the specified code and file type.\n+        val editorTextField = object : EditorTextField(code, project, fileType) {\n+            override fun createEditor(): EditorEx {\n+                val editor = super.createEditor()\n+\n+                // Configure editor settings.\n+                val settings: EditorSettings = editor.settings\n+                settings.isLineNumbersShown = true\n+                settings.isLineMarkerAreaShown = true\n+                settings.isIndentGuidesShown = true\n+                settings.isVirtualSpace = false\n+                settings.isRightMarginShown = false\n+                settings.additionalLinesCount = 0\n+                settings.isShowingSpecialChars = false\n+                settings.isCaretRowShown = true\n+\n+                // Set read-only if not editable.\n+                editor.isViewer = !isEditable\n+\n+                // Syntax highlighter.\n+                // Get current editor color scheme.\n+                val currentScheme = EditorColorsManager.getInstance().globalScheme\n+\n+                // Apply syntax highlighting with current theme.\n+                val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+                var syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, virtualFile)\n+\n+                // If we couldn't get a syntax highlighter from the file, try to get one just from the file type.\n+                if (syntaxHighlighter == null) {\n+                    syntaxHighlighter = SyntaxHighlighterFactory.getSyntaxHighlighter(fileType, project, null)\n+                }\n+\n+                // If we have a highlighter, apply it.\n+                if (syntaxHighlighter != null) {\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        syntaxHighlighter,\n+                        currentScheme\n+                    )\n+                } else {\n+                    // Fallback to plain text highlighting if all attempts fail.\n+                    val plainTextFileType = FileTypeManager.getInstance().getFileTypeByExtension(\"txt\")\n+                    editor.highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(\n+                        project,\n+                        plainTextFileType\n+                    )\n+                }\n+\n+                // Apply the theme's background color.\n+                editor.backgroundColor = currentScheme.defaultBackground\n+\n+                return editor\n+            }\n+\n+            // Override to ensure multi-line support.\n+            override fun getPreferredSize(): Dimension {\n+                val lineCount = code.lines().size\n+                // Adjust height based on line count (with some minimum).\n+                val preferredSize = super.getPreferredSize()\n+                val lineHeight = preferredSize.height / (if (lineCount > 0) lineCount else 1)\n+                val newHeight = lineHeight * (if (lineCount > 0) lineCount else 1) + 10 // Add padding\n+                return Dimension(preferredSize.width, newHeight)\n+            }\n+        }\n+\n+        // Enable multi-line mode.\n+        editorTextField.setOneLineMode(false)\n+\n+        // Wrap in a scroll pane for larger code blocks.\n+        val panel = JPanel(BorderLayout())\n+        panel.add(JBScrollPane(editorTextField), BorderLayout.CENTER)\n+\n+        return panel\n+    }\n+\n+    /**\n+     * Shows a popup dialog with the code preview.\n+     */\n+    fun showCodePreview(code: String, parentEditor: Editor, completionId: String) {\n+        // Use invokeAndWait or invokeLater to ensure we're on the EDT.\n+        com.intellij.openapi.application.ApplicationManager.getApplication().invokeLater {\n+            val codeViewer = createCodeViewer(code, getFileLanguage(parentEditor.document), parentEditor.document)\n+\n+            // Create a button panel.\n+            val buttonPanel = JPanel(FlowLayout(FlowLayout.RIGHT))\n+            val acceptButton = JButton(\"Accept (Tab)\")\n+            val dismissButton = JButton(\"Dismiss (Esc)\")\n+            buttonPanel.add(acceptButton)\n+            buttonPanel.add(dismissButton)\n+\n+            // Create a panel to hold the code viewer and buttons.\n+            val panel = JPanel(BorderLayout())\n+            panel.add(codeViewer, BorderLayout.CENTER)\n+            panel.add(buttonPanel, BorderLayout.SOUTH)\n+\n+\n+            // Create the popup.\n+            val popup = JBPopupFactory.getInstance()\n+                .createComponentPopupBuilder(panel, codeViewer)\n+                .setMovable(true)\n+                .setResizable(true)\n+                .setRequestFocus(true)\n+                .setCancelOnClickOutside(true)\n+                .setCancelOnOtherWindowOpen(true)\n+                .setFocusable(true)\n+                .addListener(object : JBPopupListener {\n+                    override fun onClosed(event: LightweightWindowEvent) {\n+                        if (!event.isOk) {\n+                            // This only triggers when dismissed, not when accepted.\n+                            println(\"Dismissing code preview popup\")\n+                            project.service<ContinuePluginService>().coreMessenger?.request(\n+                                \"nextEdit/reject\",\n+                                hashMapOf(\"completionId\" to completionId),\n+                                null, ({})\n+                            )\n+                        }\n+                    }\n+                })\n+                .createPopup()\n+\n+            // Helper function to accept the code and apply it to the editor.\n+            fun acceptCode() {\n+                val document = parentEditor.document\n+                val caretModel = parentEditor.caretModel\n+                val caretOffset = caretModel.offset\n+                val caretPosition = document.getLineNumber(caretOffset)\n+\n+                // Calculate start and end lines.\n+                val totalLines = document.lineCount\n+                val startLine = maxOf(0, caretPosition - 5)\n+                val endLine = minOf(totalLines - 1, caretPosition + 5)\n+\n+                // Get start and end offsets.\n+                val startOffset = document.getLineStartOffset(startLine)\n+                val endOffset = document.getLineEndOffset(endLine)\n+\n+                // Write command to replace the text.\n+                WriteCommandAction.runWriteCommandAction(project) {\n+                    document.replaceString(startOffset, endOffset, code)\n+                }\n+\n+                project.service<ContinuePluginService>().coreMessenger?.request(\n+                    \"nextEdit/accept\",\n+                    hashMapOf(\"completionId\" to completionId),\n+                    null, ({})\n+                )\n+            }\n+\n+            // Use ActionManager to handle Tab key globally during popup display.\n+            val acceptAction = object : AnAction() {\n+                override fun actionPerformed(e: AnActionEvent) {\n+                    acceptCode()\n+                    popup.closeOk(null)\n+                }\n+            }\n+\n+            // Create a custom shortcut set for the Tab key.\n+            val customShortcutSet = CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_TAB, 0))\n+\n+\n+            // Register action with shortcut.\n+            acceptAction.registerCustomShortcutSet(customShortcutSet, panel)\n+\n+            // Add button actions.\n+            acceptButton.addActionListener {\n+                acceptCode()\n+                popup.closeOk(null)\n+            }\n+\n+            dismissButton.addActionListener {\n+                popup.cancel()\n+            }\n+\n+            // Get the exact position of the cursor.\n+            val visualPosition = parentEditor.caretModel.visualPosition\n+            val cursorPoint = parentEditor.visualPositionToXY(visualPosition)\n+\n+            // Convert to screen coordinates.\n+            val editorComponent = parentEditor.component\n+            val locationOnScreen = editorComponent.locationOnScreen\n+            val screenPoint = Point(\n+                locationOnScreen.x + cursorPoint.x,\n+                locationOnScreen.y + cursorPoint.y\n+            )\n+\n+            // Show the popup at the cursor position.\n+            popup.showInScreenCoordinates(editorComponent, screenPoint)\n+\n+            // Ensure proper focus for keyboard shortcuts.\n+            codeViewer.requestFocusInWindow()\n+        }\n+    }\n+\n+    // Move editorConfig to a proper instance property that gets actual editor settings.\n+    private val editorConfig: EditorConfig by lazy {\n+        val settings = EditorSettingsExternalizable.getInstance()\n+        val editorFontSize = EditorColorsManager.getInstance().globalScheme.editorFontSize\n+        val editorFontFamily = EditorColorsManager.getInstance().globalScheme.editorFontName\n+\n+        EditorConfig(\n+            fontSize = editorFontSize.toDouble(),\n+            fontFamily = editorFontFamily\n+        )\n+    }\n+\n+    // Data class to hold editor configuration.\n+    private data class EditorConfig(\n+        val fontSize: Double = 14.0,\n+        val fontFamily: String = \"JetBrains Mono\"\n+    )\n+\n+    /**\n+     * Convenience method to map common programming languages to their file extensions.\n+     */\n+    fun mapLanguageToExtension(language: String): String {\n+        return when (language.lowercase()) {\n+            \"javascript\" -> \"js\"\n+            \"typescript\" -> \"ts\"\n+            \"python\" -> \"py\"\n+            \"java\" -> \"java\"\n+            \"kotlin\" -> \"kt\"\n+            \"c++\" -> \"cpp\"\n+            \"c#\" -> \"cs\"\n+            \"go\" -> \"go\"\n+            \"rust\" -> \"rs\"\n+            \"ruby\" -> \"rb\"\n+            \"php\" -> \"php\"\n+            \"swift\" -> \"swift\"\n+            \"shell\", \"bash\" -> \"sh\"\n+            \"html\" -> \"html\"\n+            \"css\" -> \"css\"\n+            \"json\" -> \"json\"\n+            \"xml\" -> \"xml\"\n+            \"yaml\", \"yml\" -> \"yaml\"\n+            \"markdown\", \"md\" -> \"md\"\n+            // Add more mappings as needed\n+            else -> language\n+        }\n+    }\n+\n+    private fun getFileLanguage(document: Document): String {\n+        val virtualFile = FileDocumentManager.getInstance().getFile(document)\n+        return virtualFile?.extension?.lowercase() ?: \"text\"\n+    }\n+\n+    companion object {\n+        fun getInstance(project: Project): NextEditWindowService = project.service()\n+    }\n+}",
        "comment_created_at": "2025-07-10T20:39:36+00:00",
        "comment_author": "jpoly1219",
        "comment_body": "You raise legitimate concerns. The purpose of this PR was to test if the feature was possible in JetBrains, and I was planning to add more polish to it in coming PRs. We definitely should address all the above concerns before the actual release!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2093807665",
    "pr_number": 5708,
    "pr_file": "extensions/intellij/src/main/kotlin/com/github/continuedev/continueintellijextension/editor/RangeInFileWithContents.kt",
    "created_at": "2025-05-17T01:05:23+00:00",
    "commented_code": "+package com.github.continuedev.continueintellijextension.editor\n+\n+import com.github.continuedev.continueintellijextension.Position\n+import com.github.continuedev.continueintellijextension.Range\n+import com.intellij.openapi.editor.Document\n+import com.intellij.openapi.util.TextRange\n+\n+/**\n+ * Represents a range of text in a file with its contents.\n+ * Provides utility methods for working with document positions and offsets.\n+ */\n+class RangeInFileWithContents(",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2093807665",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5708,
        "pr_file": "extensions/intellij/src/main/kotlin/com/github/continuedev/continueintellijextension/editor/RangeInFileWithContents.kt",
        "discussion_id": "2093807665",
        "commented_code": "@@ -0,0 +1,62 @@\n+package com.github.continuedev.continueintellijextension.editor\n+\n+import com.github.continuedev.continueintellijextension.Position\n+import com.github.continuedev.continueintellijextension.Range\n+import com.intellij.openapi.editor.Document\n+import com.intellij.openapi.util.TextRange\n+\n+/**\n+ * Represents a range of text in a file with its contents.\n+ * Provides utility methods for working with document positions and offsets.\n+ */\n+class RangeInFileWithContents(",
        "comment_created_at": "2025-05-17T01:05:23+00:00",
        "comment_author": "sestinj",
        "comment_body": "This is a great pattern, we should do this more often (classes for data types that need attached utility methods)",
        "pr_file_module": null
      },
      {
        "comment_id": "2093810412",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5708,
        "pr_file": "extensions/intellij/src/main/kotlin/com/github/continuedev/continueintellijextension/editor/RangeInFileWithContents.kt",
        "discussion_id": "2093807665",
        "commented_code": "@@ -0,0 +1,62 @@\n+package com.github.continuedev.continueintellijextension.editor\n+\n+import com.github.continuedev.continueintellijextension.Position\n+import com.github.continuedev.continueintellijextension.Range\n+import com.intellij.openapi.editor.Document\n+import com.intellij.openapi.util.TextRange\n+\n+/**\n+ * Represents a range of text in a file with its contents.\n+ * Provides utility methods for working with document positions and offsets.\n+ */\n+class RangeInFileWithContents(",
        "comment_created_at": "2025-05-17T01:15:19+00:00",
        "comment_author": "sestinj",
        "comment_body": "We should definitely write unit tests for it, but nothing changed and this PR is such a large improvement that I want to merge",
        "pr_file_module": null
      }
    ]
  }
]