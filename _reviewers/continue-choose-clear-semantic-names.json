[
  {
    "discussion_id": "2116890020",
    "pr_number": 5921,
    "pr_file": "extensions/vscode/src/autocomplete/completionProvider.ts",
    "created_at": "2025-05-31T00:13:34+00:00",
    "commented_code": "this.onError.bind(this),\n       getDefinitionsFromLsp,\n     );\n+    // NOTE: Only turn it on locally when testing (for review purposes).\n+    if (!IGNORE_NEXT_EDIT) {",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2116890020",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5921,
        "pr_file": "extensions/vscode/src/autocomplete/completionProvider.ts",
        "discussion_id": "2116890020",
        "commented_code": "@@ -83,12 +86,21 @@ export class ContinueCompletionProvider\n       this.onError.bind(this),\n       getDefinitionsFromLsp,\n     );\n+    // NOTE: Only turn it on locally when testing (for review purposes).\n+    if (!IGNORE_NEXT_EDIT) {",
        "comment_created_at": "2025-05-31T00:13:34+00:00",
        "comment_author": "tomasz-stefaniak",
        "comment_body": "Naming-wise, it's better to not have \"negative\" boolean flags. For example, instead of `IGNORE_NEXT_EDIT` you could use `IS_NEXT_EDIT_ACTIVE`. This helps avoid confusion and makes control flows simpler (no negation needed).\r\n\r\n```suggestion\r\n    if (IS_NEXT_EDIT_ACTIVE) {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2096464825",
    "pr_number": 5723,
    "pr_file": "core/control-plane/client.ts",
    "created_at": "2025-05-19T20:48:06+00:00",
    "commented_code": "return (await resp.json()) as any;\n   }\n \n-  get userId(): Promise<string | undefined> {",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2096464825",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5723,
        "pr_file": "core/control-plane/client.ts",
        "discussion_id": "2096464825",
        "commented_code": "@@ -64,19 +56,24 @@ export class ControlPlaneClient {\n     return (await resp.json()) as any;\n   }\n \n-  get userId(): Promise<string | undefined> {",
        "comment_created_at": "2025-05-19T20:48:06+00:00",
        "comment_author": "sestinj",
        "comment_body": "We were previously using the `userId` in a lot of places _just_ as a way to check whether the user was signed in at all or not. Changed to a method `isSignedIn` that makes more sense",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2005906267",
    "pr_number": 4725,
    "pr_file": "extensions/vscode/src/quickEdit/EditDecorationManager.ts",
    "created_at": "2025-03-20T15:28:58+00:00",
    "commented_code": ");\n   }\n \n-  setDecoration(editor: vscode.TextEditor, range: vscode.Range) {\n-    if (this._lastEditor) {\n-      this._lastEditor.setDecorations(this.decorationType, []);\n+  // converting each range to a unique string for storing in set\n+  private rangeToString(range: vscode.Range): string {\n+    return `${range.start.line}:${range.start.character}-${range.end.line}:${range.end.character}`;\n+  }\n+\n+  setDecoration(editor: vscode.TextEditor, ranges: vscode.Range[]): void {",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2005906267",
        "repo_full_name": "continuedev/continue",
        "pr_number": 4725,
        "pr_file": "extensions/vscode/src/quickEdit/EditDecorationManager.ts",
        "discussion_id": "2005906267",
        "commented_code": "@@ -23,18 +25,40 @@ class EditDecorationManager {\n     );\n   }\n \n-  setDecoration(editor: vscode.TextEditor, range: vscode.Range) {\n-    if (this._lastEditor) {\n-      this._lastEditor.setDecorations(this.decorationType, []);\n+  // converting each range to a unique string for storing in set\n+  private rangeToString(range: vscode.Range): string {\n+    return `${range.start.line}:${range.start.character}-${range.end.line}:${range.end.character}`;\n+  }\n+\n+  setDecoration(editor: vscode.TextEditor, ranges: vscode.Range[]): void {",
        "comment_created_at": "2025-03-20T15:28:58+00:00",
        "comment_author": "halfline",
        "comment_body": "\"set\" usually means \"replace\" but this function augments not replaces now.should probably be renamed `addDecorations`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2006276198",
    "pr_number": 4725,
    "pr_file": "extensions/vscode/src/quickEdit/EditDecorationManager.ts",
    "created_at": "2025-03-20T19:00:01+00:00",
    "commented_code": ");\n   }\n \n-  setDecoration(editor: vscode.TextEditor, range: vscode.Range) {\n-    if (this._lastEditor) {\n-      this._lastEditor.setDecorations(this.decorationType, []);\n+  // Converts each range to a unique string for storing in the map\n+  private rangeToString(range: vscode.Range): string {\n+    return `(${range.start.line},${range.start.character}-${range.end.line},${range.end.character})`;\n+  }\n+\n+  // Checks if two ranges are adjacent or overlapping\n+  private rangesCoincide(range1: vscode.Range, range2: vscode.Range): boolean {\n+    return range1.start.isEqual(range2.start)\n+    || range1.end.isEqual(range2.start)\n+    || range2.end.isEqual(range1.start)\n+    || !!range1.intersection(range2);\n+  }\n+\n+  // Merges new range with existing ranges in the map\n+  private mergeNewRange(newRange: vscode.Range): void {\n+    let mergedRange = newRange;\n+    const rangesToPrune: string[] = [];\n+\n+    for (const [key, existingRange] of this.activeRangesMap.entries()) {\n+      if (!this.rangesCoincide(mergedRange, existingRange)) continue; \n+      mergedRange = mergedRange.union(existingRange);\n+      rangesToPrune.push(key);\n+    }\n+\n+    for (const key of rangesToPrune) this.activeRangesMap.delete(key);\n+    this.activeRangesMap.set(this.rangeToString(mergedRange), mergedRange);\n+  }\n+\n+  // Adds a new decoration to the editor and merges it with existing ranges\n+  addDecoration(editor: vscode.TextEditor, ranges: vscode.Range[]): void {",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2006276198",
        "repo_full_name": "continuedev/continue",
        "pr_number": 4725,
        "pr_file": "extensions/vscode/src/quickEdit/EditDecorationManager.ts",
        "discussion_id": "2006276198",
        "commented_code": "@@ -23,18 +24,55 @@ class EditDecorationManager {\n     );\n   }\n \n-  setDecoration(editor: vscode.TextEditor, range: vscode.Range) {\n-    if (this._lastEditor) {\n-      this._lastEditor.setDecorations(this.decorationType, []);\n+  // Converts each range to a unique string for storing in the map\n+  private rangeToString(range: vscode.Range): string {\n+    return `(${range.start.line},${range.start.character}-${range.end.line},${range.end.character})`;\n+  }\n+\n+  // Checks if two ranges are adjacent or overlapping\n+  private rangesCoincide(range1: vscode.Range, range2: vscode.Range): boolean {\n+    return range1.start.isEqual(range2.start)\n+    || range1.end.isEqual(range2.start)\n+    || range2.end.isEqual(range1.start)\n+    || !!range1.intersection(range2);\n+  }\n+\n+  // Merges new range with existing ranges in the map\n+  private mergeNewRange(newRange: vscode.Range): void {\n+    let mergedRange = newRange;\n+    const rangesToPrune: string[] = [];\n+\n+    for (const [key, existingRange] of this.activeRangesMap.entries()) {\n+      if (!this.rangesCoincide(mergedRange, existingRange)) continue; \n+      mergedRange = mergedRange.union(existingRange);\n+      rangesToPrune.push(key);\n+    }\n+\n+    for (const key of rangesToPrune) this.activeRangesMap.delete(key);\n+    this.activeRangesMap.set(this.rangeToString(mergedRange), mergedRange);\n+  }\n+\n+  // Adds a new decoration to the editor and merges it with existing ranges\n+  addDecoration(editor: vscode.TextEditor, ranges: vscode.Range[]): void {",
        "comment_created_at": "2025-03-20T19:00:01+00:00",
        "comment_author": "halfline",
        "comment_body": "i would make this plural since it's takes an array of ranges and could end up with more than one",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2008625799",
    "pr_number": 4559,
    "pr_file": "core/index.d.ts",
    "created_at": "2025-03-22T02:46:25+00:00",
    "commented_code": "prediction?: Prediction;\n   tools?: Tool[];\n   toolChoice?: ToolChoice;\n+  thinking?: {\n+    type: \"enabled\" | \"disabled\";\n+    budget_tokens?: number;",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2008625799",
        "repo_full_name": "continuedev/continue",
        "pr_number": 4559,
        "pr_file": "core/index.d.ts",
        "discussion_id": "2008625799",
        "commented_code": "@@ -921,11 +937,17 @@ export interface BaseCompletionOptions {\n   prediction?: Prediction;\n   tools?: Tool[];\n   toolChoice?: ToolChoice;\n+  thinking?: {\n+    type: \"enabled\" | \"disabled\";\n+    budget_tokens?: number;",
        "comment_created_at": "2025-03-22T02:46:25+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "Is this supposed to be the budget for the number of tokens to allocate to thinking? If so I think a more declarative `tokenBudget` would be clearer, took me a second to understand.",
        "pr_file_module": null
      }
    ]
  }
]