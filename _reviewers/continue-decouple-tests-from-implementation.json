[
  {
    "discussion_id": "2176144026",
    "pr_number": 6359,
    "pr_file": "core/llm/rules/nestedDirectoryRules.vitest.ts",
    "created_at": "2025-06-30T23:36:51+00:00",
    "commented_code": "// Both rules should apply\n     expect(applicableRules).toHaveLength(2);\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Global Rule\");\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Nested Folder Rule\");\n+    expect(applicableRules.map((r) => r.rule.name)).toContain(\"Global Rule\");",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2176144026",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6359,
        "pr_file": "core/llm/rules/nestedDirectoryRules.vitest.ts",
        "discussion_id": "2176144026",
        "commented_code": "@@ -47,8 +47,8 @@\n \n     // Both rules should apply\n     expect(applicableRules).toHaveLength(2);\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Global Rule\");\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Nested Folder Rule\");\n+    expect(applicableRules.map((r) => r.rule.name)).toContain(\"Global Rule\");",
        "comment_created_at": "2025-06-30T23:36:51+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nThe test now assumes that each element in applicableRules has a 'rule' property with a 'name', which is a breaking change from the previous structure. If any test setup or code under test still returns the old structure, this will cause test failures or runtime errors. Ensure all code paths producing applicableRules are updated to the new tuple/object structure.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2176147199",
    "pr_number": 6359,
    "pr_file": "core/llm/rules/nestedDirectoryRules.vitest.ts",
    "created_at": "2025-06-30T23:41:17+00:00",
    "commented_code": "// Both rules should apply\n     expect(applicableRules).toHaveLength(2);\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Global Rule\");\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Nested Folder Rule\");\n+    expect(applicableRules.map((r) => r.rule.name)).toContain(\"Global Rule\");",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2176147199",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6359,
        "pr_file": "core/llm/rules/nestedDirectoryRules.vitest.ts",
        "discussion_id": "2176147199",
        "commented_code": "@@ -47,8 +47,8 @@ describe(\"Nested directory rules application\", () => {\n \n     // Both rules should apply\n     expect(applicableRules).toHaveLength(2);\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Global Rule\");\n-    expect(applicableRules.map((r) => r.name)).toContain(\"Nested Folder Rule\");\n+    expect(applicableRules.map((r) => r.rule.name)).toContain(\"Global Rule\");",
        "comment_created_at": "2025-06-30T23:41:17+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nThe test now assumes that each element in applicableRules has a 'rule' property with a 'name', which is a breaking change from the previous structure. If any test setup or code under test still returns the old structure, this will cause test failures or runtime errors. Ensure all code paths producing applicableRules are updated to the new tuple/object structure.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2183844649",
    "pr_number": 6439,
    "pr_file": "core/tools/implementations/viewDiff.vitest.ts",
    "created_at": "2025-07-03T22:11:54+00:00",
    "commented_code": "+import { expect, test, vi } from \"vitest\";\n+import { viewDiffImpl } from \"./viewDiff\";\n+\n+// Mock the getDiffsFromCache function\n+vi.mock(\"../../autocomplete/snippets/gitDiffCache\", () => ({\n+  getDiffsFromCache: vi.fn(),\n+}));\n+\n+import { ToolExtras } from \"../..\";\n+import { getDiffsFromCache } from \"../../autocomplete/snippets/gitDiffCache\";\n+const mockExtras = {\n+  fetch: vi.fn() as any,\n+  ide: {} as any,\n+} as unknown as ToolExtras;\n+\n+test(\"viewDiff should not truncate diffs under line limit\", async () => {\n+  // Create a small diff with just a few lines\n+  const smallDiff = [\n+    \"diff --git a/file1.txt b/file1.txt\",\n+    \"index 1234..5678 100644\",\n+    \"--- a/file1.txt\",\n+    \"+++ b/file1.txt\",\n+    \"@@ -1,3 +1,4 @@\",\n+    \" line1\",\n+    \"-line2\",\n+    \"+line2 modified\",\n+    \"+line3 added\",\n+  ];\n+\n+  (getDiffsFromCache as any).mockResolvedValue(smallDiff);\n+\n+  const result = await viewDiffImpl({}, mockExtras);\n+\n+  expect(result).toHaveLength(1); // Just the diff, no warning\n+  expect(result[0].name).toBe(\"Diff\");\n+  expect(result[0].content).toBe(smallDiff.join(\"\n\"));\n+});\n+\n+test(\"viewDiff should truncate diffs exceeding line limit\", async () => {\n+  const DEFAULT_GIT_DIFF_LINE_LIMIT = 5000;",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2183844649",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6439,
        "pr_file": "core/tools/implementations/viewDiff.vitest.ts",
        "discussion_id": "2183844649",
        "commented_code": "@@ -0,0 +1,89 @@\n+import { expect, test, vi } from \"vitest\";\n+import { viewDiffImpl } from \"./viewDiff\";\n+\n+// Mock the getDiffsFromCache function\n+vi.mock(\"../../autocomplete/snippets/gitDiffCache\", () => ({\n+  getDiffsFromCache: vi.fn(),\n+}));\n+\n+import { ToolExtras } from \"../..\";\n+import { getDiffsFromCache } from \"../../autocomplete/snippets/gitDiffCache\";\n+const mockExtras = {\n+  fetch: vi.fn() as any,\n+  ide: {} as any,\n+} as unknown as ToolExtras;\n+\n+test(\"viewDiff should not truncate diffs under line limit\", async () => {\n+  // Create a small diff with just a few lines\n+  const smallDiff = [\n+    \"diff --git a/file1.txt b/file1.txt\",\n+    \"index 1234..5678 100644\",\n+    \"--- a/file1.txt\",\n+    \"+++ b/file1.txt\",\n+    \"@@ -1,3 +1,4 @@\",\n+    \" line1\",\n+    \"-line2\",\n+    \"+line2 modified\",\n+    \"+line3 added\",\n+  ];\n+\n+  (getDiffsFromCache as any).mockResolvedValue(smallDiff);\n+\n+  const result = await viewDiffImpl({}, mockExtras);\n+\n+  expect(result).toHaveLength(1); // Just the diff, no warning\n+  expect(result[0].name).toBe(\"Diff\");\n+  expect(result[0].content).toBe(smallDiff.join(\"\\n\"));\n+});\n+\n+test(\"viewDiff should truncate diffs exceeding line limit\", async () => {\n+  const DEFAULT_GIT_DIFF_LINE_LIMIT = 5000;",
        "comment_created_at": "2025-07-03T22:11:54+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":7,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"pattern\":\"**/gitDiffCache*\"},\"toolName\":\"listFiles\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"pattern\":\"core/tools/implementations/viewDiff.*\"},\"toolName\":\"listFiles\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' core/tools/implementations/viewDiff.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' core/tools/index.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '1,160p' core/tools/implementations/viewDiff.vitest.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"export .*ToolExtras\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '880,920p' core/config/types.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"mockResolvedValue(smallDiff)\\\" -n core/tools/implementations/viewDiff.vitest.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"nl -ba core/tools/implementations/viewDiff.vitest.ts | sed -n '1,160p'\"},\"toolName\":\"executeCommand\"}]}]} -->\nRedefines the git-diff line-limit constant instead of importing it from the implementation, making the test fragile if the production constant changes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2157742979",
    "pr_number": 6205,
    "pr_file": "core/llm/llms/Anthropic.enhanced-caching.test.ts",
    "created_at": "2025-06-19T22:56:30+00:00",
    "commented_code": "+import { ChatMessage } from \"../../index.js\";\n+import Anthropic from \"./Anthropic.js\";\n+\n+// Create a test class that exposes the methods we need to test\n+class TestAnthropic extends Anthropic {\n+  // Make convertMessage public for testing\n+  public convertMessage(message: ChatMessage, addCaching: boolean): any {\n+    return super.convertMessage(message, addCaching);\n+  }\n+\n+  // Make shouldCacheMessage public for testing\n+  public shouldCacheMessage(message: ChatMessage, index: number, filteredMessages: ChatMessage[]): boolean {\n+    return super.shouldCacheMessage(message, index, filteredMessages);\n+  }\n+\n+  // Make convertMessages public for testing\n+  public convertMessages(msgs: ChatMessage[]): any[] {\n+    return super.convertMessages(msgs);\n+  }\n+}\n+\n+describe(\"Anthropic Enhanced Caching\", () => {\n+  let anthropic: TestAnthropic;\n+\n+  beforeEach(() => {\n+    anthropic = new TestAnthropic({\n+      model: \"claude-3-5-sonnet-latest\",\n+      apiKey: \"test-key\",\n+      cacheBehavior: {\n+        cacheConversation: true,\n+        cacheUserMessages: 2,\n+        cacheToolResults: 3,\n+        cacheAssistantToolCalls: 2,\n+        useExtendedCacheTtlBeta: true,\n+        cacheTtl: \"1h\",\n+      },\n+    });\n+  });\n+\n+  test(\"should cache tool result messages\", () => {\n+    const messages: ChatMessage[] = [\n+      {\n+        role: \"user\",\n+        content: \"Read the file main.py\",\n+      },\n+      {\n+        role: \"assistant\",\n+        content: \"\",\n+        toolCalls: [\n+          {\n+            id: \"tool_1\",\n+            type: \"function\",\n+            function: { name: \"readFile\", arguments: '{\"path\": \"main.py\"}' },\n+          },\n+        ],\n+      },\n+      {\n+        role: \"tool\",\n+        content: \"def main():\n    print('Hello')\",\n+        toolCallId: \"tool_1\",\n+      },\n+      {\n+        role: \"user\",\n+        content: \"What does this file do?\",\n+      },\n+    ];\n+\n+    const convertedMessages = anthropic.convertMessages(messages);\n+\n+    // Find the tool result message\n+    const toolResultMsg = convertedMessages.find(\n+      (msg: any) => msg.role === \"user\" && msg.content[0]?.type === \"tool_result\"\n+    );\n+\n+    expect(toolResultMsg).toBeDefined();\n+    expect(toolResultMsg.content[0]).toHaveProperty(\"cache_control\");\n+    expect(toolResultMsg.content[0].cache_control).toEqual({\n+      type: \"ephemeral\",\n+      ttl: \"1h\",\n+    });\n+  });\n+\n+  test(\"should cache assistant tool call messages\", () => {\n+    const messages: ChatMessage[] = [\n+      {\n+        role: \"user\",\n+        content: \"Create a new file\",\n+      },\n+      {\n+        role: \"assistant\",\n+        content: \"\",\n+        toolCalls: [\n+          {\n+            id: \"tool_1\",\n+            type: \"function\",\n+            function: { name: \"createFile\", arguments: '{\"path\": \"test.py\"}' },\n+          },\n+        ],\n+      },\n+    ];\n+\n+    const convertedMessages = anthropic.convertMessages(messages);\n+\n+    // Find the assistant message with tool calls\n+    const assistantToolMsg = convertedMessages.find(\n+      (msg: any) => msg.role === \"assistant\" && Array.isArray(msg.content) && msg.content.some((c: any) => c.type === \"tool_use\")\n+    );\n+\n+    expect(assistantToolMsg).toBeDefined();\n+    expect(assistantToolMsg.content[0]).toHaveProperty(\"cache_control\");\n+    expect(assistantToolMsg.content[0].cache_control).toEqual({\n+      type: \"ephemeral\",\n+      ttl: \"1h\",\n+    });\n+  });\n+\n+  test(\"should respect per-type caching limits\", () => {\n+    // Test with specific limits per type\n+    const anthropicLimited = new TestAnthropic({\n+      model: \"claude-3-5-sonnet-latest\",\n+      apiKey: \"test-key\",\n+      cacheBehavior: {\n+        cacheConversation: true,\n+        cacheUserMessages: 1,     // Only cache last 1 user message\n+        cacheToolResults: 2,      // Cache last 2 tool results\n+        cacheAssistantToolCalls: 1, // Cache last 1 assistant tool call\n+        useExtendedCacheTtlBeta: true,\n+        cacheTtl: \"1h\",\n+      },\n+    });\n+\n+    const messages: ChatMessage[] = [\n+      { role: \"user\", content: \"First user\" },\n+      { role: \"user\", content: \"Second user\" },\n+      { role: \"tool\", content: \"First tool\", toolCallId: \"tool_1\" },\n+      { role: \"tool\", content: \"Second tool\", toolCallId: \"tool_2\" },\n+      { role: \"tool\", content: \"Third tool\", toolCallId: \"tool_3\" },\n+    ];\n+\n+    const convertedMessages = anthropicLimited.convertMessages(messages);\n+\n+    // Only last user message should be cached (1 out of 2)\n+    const userMessages = convertedMessages.filter((msg: any) => \n+      msg.role === \"user\" && msg.content[0]?.type === \"text\"\n+    );\n+    const cachedUserMessages = userMessages.filter((msg: any) => \n+      msg.content[0]?.cache_control\n+    );\n+    expect(cachedUserMessages).toHaveLength(1);\n+\n+    // Last 2 tool results should be cached (2 out of 3)\n+    const toolMessages = convertedMessages.filter((msg: any) => \n+      msg.role === \"user\" && msg.content[0]?.type === \"tool_result\"\n+    );\n+    const cachedToolMessages = toolMessages.filter((msg: any) => \n+      msg.content[0]?.cache_control\n+    );\n+    expect(cachedToolMessages).toHaveLength(2);\n+  });\n+\n+  test(\"should not cache when caching is disabled\", () => {\n+    const anthropicNoCache = new TestAnthropic({\n+      model: \"claude-3-5-sonnet-latest\",\n+      apiKey: \"test-key\",\n+      cacheBehavior: {\n+        cacheConversation: false,\n+      },\n+    });\n+\n+    const messages: ChatMessage[] = [\n+      {\n+        role: \"user\",\n+        content: \"Test message\",\n+      },\n+      {\n+        role: \"tool\",\n+        content: \"Tool result\",\n+        toolCallId: \"tool_1\",\n+      },\n+    ];\n+\n+    const convertedMessages = anthropicNoCache.convertMessages(messages);\n+\n+    // No messages should have cache_control\n+    convertedMessages.forEach((msg: any) => {\n+      if (msg.content && Array.isArray(msg.content)) {\n+        msg.content.forEach((content: any) => {\n+          expect(content).not.toHaveProperty(\"cache_control\");\n+        });\n+      }\n+    });\n+  });\n+\n+  test(\"should use fallback TTL when not specified\", () => {",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2157742979",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6205,
        "pr_file": "core/llm/llms/Anthropic.enhanced-caching.test.ts",
        "discussion_id": "2157742979",
        "commented_code": "@@ -0,0 +1,246 @@\n+import { ChatMessage } from \"../../index.js\";\n+import Anthropic from \"./Anthropic.js\";\n+\n+// Create a test class that exposes the methods we need to test\n+class TestAnthropic extends Anthropic {\n+  // Make convertMessage public for testing\n+  public convertMessage(message: ChatMessage, addCaching: boolean): any {\n+    return super.convertMessage(message, addCaching);\n+  }\n+\n+  // Make shouldCacheMessage public for testing\n+  public shouldCacheMessage(message: ChatMessage, index: number, filteredMessages: ChatMessage[]): boolean {\n+    return super.shouldCacheMessage(message, index, filteredMessages);\n+  }\n+\n+  // Make convertMessages public for testing\n+  public convertMessages(msgs: ChatMessage[]): any[] {\n+    return super.convertMessages(msgs);\n+  }\n+}\n+\n+describe(\"Anthropic Enhanced Caching\", () => {\n+  let anthropic: TestAnthropic;\n+\n+  beforeEach(() => {\n+    anthropic = new TestAnthropic({\n+      model: \"claude-3-5-sonnet-latest\",\n+      apiKey: \"test-key\",\n+      cacheBehavior: {\n+        cacheConversation: true,\n+        cacheUserMessages: 2,\n+        cacheToolResults: 3,\n+        cacheAssistantToolCalls: 2,\n+        useExtendedCacheTtlBeta: true,\n+        cacheTtl: \"1h\",\n+      },\n+    });\n+  });\n+\n+  test(\"should cache tool result messages\", () => {\n+    const messages: ChatMessage[] = [\n+      {\n+        role: \"user\",\n+        content: \"Read the file main.py\",\n+      },\n+      {\n+        role: \"assistant\",\n+        content: \"\",\n+        toolCalls: [\n+          {\n+            id: \"tool_1\",\n+            type: \"function\",\n+            function: { name: \"readFile\", arguments: '{\"path\": \"main.py\"}' },\n+          },\n+        ],\n+      },\n+      {\n+        role: \"tool\",\n+        content: \"def main():\\n    print('Hello')\",\n+        toolCallId: \"tool_1\",\n+      },\n+      {\n+        role: \"user\",\n+        content: \"What does this file do?\",\n+      },\n+    ];\n+\n+    const convertedMessages = anthropic.convertMessages(messages);\n+\n+    // Find the tool result message\n+    const toolResultMsg = convertedMessages.find(\n+      (msg: any) => msg.role === \"user\" && msg.content[0]?.type === \"tool_result\"\n+    );\n+\n+    expect(toolResultMsg).toBeDefined();\n+    expect(toolResultMsg.content[0]).toHaveProperty(\"cache_control\");\n+    expect(toolResultMsg.content[0].cache_control).toEqual({\n+      type: \"ephemeral\",\n+      ttl: \"1h\",\n+    });\n+  });\n+\n+  test(\"should cache assistant tool call messages\", () => {\n+    const messages: ChatMessage[] = [\n+      {\n+        role: \"user\",\n+        content: \"Create a new file\",\n+      },\n+      {\n+        role: \"assistant\",\n+        content: \"\",\n+        toolCalls: [\n+          {\n+            id: \"tool_1\",\n+            type: \"function\",\n+            function: { name: \"createFile\", arguments: '{\"path\": \"test.py\"}' },\n+          },\n+        ],\n+      },\n+    ];\n+\n+    const convertedMessages = anthropic.convertMessages(messages);\n+\n+    // Find the assistant message with tool calls\n+    const assistantToolMsg = convertedMessages.find(\n+      (msg: any) => msg.role === \"assistant\" && Array.isArray(msg.content) && msg.content.some((c: any) => c.type === \"tool_use\")\n+    );\n+\n+    expect(assistantToolMsg).toBeDefined();\n+    expect(assistantToolMsg.content[0]).toHaveProperty(\"cache_control\");\n+    expect(assistantToolMsg.content[0].cache_control).toEqual({\n+      type: \"ephemeral\",\n+      ttl: \"1h\",\n+    });\n+  });\n+\n+  test(\"should respect per-type caching limits\", () => {\n+    // Test with specific limits per type\n+    const anthropicLimited = new TestAnthropic({\n+      model: \"claude-3-5-sonnet-latest\",\n+      apiKey: \"test-key\",\n+      cacheBehavior: {\n+        cacheConversation: true,\n+        cacheUserMessages: 1,     // Only cache last 1 user message\n+        cacheToolResults: 2,      // Cache last 2 tool results\n+        cacheAssistantToolCalls: 1, // Cache last 1 assistant tool call\n+        useExtendedCacheTtlBeta: true,\n+        cacheTtl: \"1h\",\n+      },\n+    });\n+\n+    const messages: ChatMessage[] = [\n+      { role: \"user\", content: \"First user\" },\n+      { role: \"user\", content: \"Second user\" },\n+      { role: \"tool\", content: \"First tool\", toolCallId: \"tool_1\" },\n+      { role: \"tool\", content: \"Second tool\", toolCallId: \"tool_2\" },\n+      { role: \"tool\", content: \"Third tool\", toolCallId: \"tool_3\" },\n+    ];\n+\n+    const convertedMessages = anthropicLimited.convertMessages(messages);\n+\n+    // Only last user message should be cached (1 out of 2)\n+    const userMessages = convertedMessages.filter((msg: any) => \n+      msg.role === \"user\" && msg.content[0]?.type === \"text\"\n+    );\n+    const cachedUserMessages = userMessages.filter((msg: any) => \n+      msg.content[0]?.cache_control\n+    );\n+    expect(cachedUserMessages).toHaveLength(1);\n+\n+    // Last 2 tool results should be cached (2 out of 3)\n+    const toolMessages = convertedMessages.filter((msg: any) => \n+      msg.role === \"user\" && msg.content[0]?.type === \"tool_result\"\n+    );\n+    const cachedToolMessages = toolMessages.filter((msg: any) => \n+      msg.content[0]?.cache_control\n+    );\n+    expect(cachedToolMessages).toHaveLength(2);\n+  });\n+\n+  test(\"should not cache when caching is disabled\", () => {\n+    const anthropicNoCache = new TestAnthropic({\n+      model: \"claude-3-5-sonnet-latest\",\n+      apiKey: \"test-key\",\n+      cacheBehavior: {\n+        cacheConversation: false,\n+      },\n+    });\n+\n+    const messages: ChatMessage[] = [\n+      {\n+        role: \"user\",\n+        content: \"Test message\",\n+      },\n+      {\n+        role: \"tool\",\n+        content: \"Tool result\",\n+        toolCallId: \"tool_1\",\n+      },\n+    ];\n+\n+    const convertedMessages = anthropicNoCache.convertMessages(messages);\n+\n+    // No messages should have cache_control\n+    convertedMessages.forEach((msg: any) => {\n+      if (msg.content && Array.isArray(msg.content)) {\n+        msg.content.forEach((content: any) => {\n+          expect(content).not.toHaveProperty(\"cache_control\");\n+        });\n+      }\n+    });\n+  });\n+\n+  test(\"should use fallback TTL when not specified\", () => {",
        "comment_created_at": "2025-06-19T22:56:30+00:00",
        "comment_author": "recurseml[bot]",
        "comment_body": "The test assumes a default TTL of '5m' without verifying this value against the actual Anthropic.ts implementation. The codebase search shows no explicit default TTL definition in the Anthropic class, which could lead to test failures if the actual default value is different or undefined.\n\n<sub>\ud83d\udd0d This comment matches your `test-assumption-validation` rule.</sub>\n\n---\n\n> *React with \ud83d\udc4d to tell me that this comment was useful, or \ud83d\udc4e if not (and I'll stop posting more comments like this in the future)*",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1834502775",
    "pr_number": 2844,
    "pr_file": "core/autocomplete/context/root-path-context/test/RootPathContextService.test.ts",
    "created_at": "2024-11-08T14:34:22+00:00",
    "commented_code": "+import { testRootPathContext } from \"./testUtils\";\n+\n+describe(\"RootPathContextService\", () => {\n+  describe(\"TypeScript should return expected snippets when editing inside a:\", () => {\n+    test(\"function\", async () => {\n+      await testRootPathContext(\n+        \"typescript\",\n+        \"file1.ts\",\n+        { start: { line: 3, character: 2 }, end: { line: 3, character: 24 } },\n+        [\"EXPECTED SNIPPET 1\", \"EXPECTED SNIPPET 2\"],",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "1834502775",
        "repo_full_name": "continuedev/continue",
        "pr_number": 2844,
        "pr_file": "core/autocomplete/context/root-path-context/test/RootPathContextService.test.ts",
        "discussion_id": "1834502775",
        "commented_code": "@@ -0,0 +1,23 @@\n+import { testRootPathContext } from \"./testUtils\";\n+\n+describe(\"RootPathContextService\", () => {\n+  describe(\"TypeScript should return expected snippets when editing inside a:\", () => {\n+    test(\"function\", async () => {\n+      await testRootPathContext(\n+        \"typescript\",\n+        \"file1.ts\",\n+        { start: { line: 3, character: 2 }, end: { line: 3, character: 24 } },\n+        [\"EXPECTED SNIPPET 1\", \"EXPECTED SNIPPET 2\"],",
        "comment_created_at": "2024-11-08T14:34:22+00:00",
        "comment_author": "tomasz-stefaniak",
        "comment_body": "The effect of mocking `getSnippets` is that we are essentially testing that the right number of snippets is returned in the right order but we don't check the actual content of the snippets.",
        "pr_file_module": null
      },
      {
        "comment_id": "1835755152",
        "repo_full_name": "continuedev/continue",
        "pr_number": 2844,
        "pr_file": "core/autocomplete/context/root-path-context/test/RootPathContextService.test.ts",
        "discussion_id": "1834502775",
        "commented_code": "@@ -0,0 +1,23 @@\n+import { testRootPathContext } from \"./testUtils\";\n+\n+describe(\"RootPathContextService\", () => {\n+  describe(\"TypeScript should return expected snippets when editing inside a:\", () => {\n+    test(\"function\", async () => {\n+      await testRootPathContext(\n+        \"typescript\",\n+        \"file1.ts\",\n+        { start: { line: 3, character: 2 }, end: { line: 3, character: 24 } },\n+        [\"EXPECTED SNIPPET 1\", \"EXPECTED SNIPPET 2\"],",
        "comment_created_at": "2024-11-10T18:25:40+00:00",
        "comment_author": "sestinj",
        "comment_body": "Yeah I think this is problematic as it exists now. What we're trying to test is that the tree-sitter queries are able to find the correct range to go to definition on. We need to test not just the number of times that getSnippets or gotoDefinition is called, but the range that it is called with.",
        "pr_file_module": null
      }
    ]
  }
]