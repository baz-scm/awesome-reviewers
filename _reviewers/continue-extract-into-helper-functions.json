[
  {
    "discussion_id": "2096673487",
    "pr_number": 5725,
    "pr_file": "core/control-plane/mdm.ts",
    "created_at": "2025-05-20T01:08:37+00:00",
    "commented_code": "+import * as crypto from \"crypto\";\n+import * as fs from \"fs\";\n+import * as os from \"os\";\n+import * as path from \"path\";\n+import * as plist from \"plist\";\n+\n+export interface MdmKeys {\n+  licenseKey: string;\n+  apiUrl: string;\n+}\n+\n+const CONTINUE_PUBLIC_KEY = `-----BEGIN PUBLIC KEY-----\n+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz1pFVzsW2UScSnaPAwFp\n+93QU4+txtyJj8AOC3Kx7YkX1d48DGU2Fy1he7SXPHgcuhXYIqfWGn/Vy/4yJxXD7\n+HlU8RM7LlWHRk7ecAvF4WtxZDjPE0OSG5T69w5f7tMCtQPQseInCKqleJuCjxrvA\n+zyTWTwKA1S6e+KxXS/kbqsumriljFujNr6Gmh8ygDnpF055Xo0vTenkMipVw/oYn\n+U0EHx5ic+Fmcob3EyOj25lu/CVYtU1Rn8jPbrBOMiIq5sePh2QXOwGRsuTiZk2mP\n+LXSsjLbeWHifRrQ18wj/PC990E33QaFGNFp0NcBXMPbq5eKYKEzKZ0GsxtLoGxar\n+FQIDAQAB\n+-----END PUBLIC KEY-----`;\n+\n+export interface LicenseData {\n+  customerId: string;\n+  createdAt: string;\n+  expiresAt: string;\n+}\n+\n+export function validateLicenseKey(licenseKey: string): boolean {\n+  try {\n+    // Decode the base64 license key\n+    const decodedString = Buffer.from(licenseKey, \"base64\").toString(\"utf8\");\n+    const { data, signature } = JSON.parse(decodedString);\n+\n+    // Verify the signature\n+    const verify = crypto.createVerify(\"SHA256\");\n+    verify.update(data);\n+    verify.end();\n+\n+    const isValid = verify.verify(CONTINUE_PUBLIC_KEY, signature, \"base64\");\n+\n+    if (!isValid) return false;\n+\n+    // Check license expiration\n+    const licenseData: LicenseData = JSON.parse(data);\n+    const expirationDate = new Date(licenseData.expiresAt);\n+    const now = new Date();\n+\n+    return expirationDate > now;\n+  } catch (error) {\n+    console.error(\"License validation error:\", error);\n+    return false;\n+  }\n+}\n+\n+function readMdmKeysMacOS(): MdmKeys | undefined {\n+  try {\n+    // MDM configuration is typically stored in /Library/Managed Preferences/ on macOS\n+    // The filename is often the bundle identifier of the application\n+    const mdmPaths = [\n+      // Organization-specific MDM plist\n+      \"/Library/Managed Preferences/dev.continue.app.plist\",\n+      // User-specific MDM plist\n+      path.join(\n+        os.homedir(),\n+        \"Library/Managed Preferences/dev.continue.app.plist\",\n+      ),\n+    ];\n+\n+    // Try to find a valid MDM configuration file\n+    for (const mdmPath of mdmPaths) {\n+      if (fs.existsSync(mdmPath)) {\n+        // Read the file content\n+        const fileContent = fs.readFileSync(mdmPath, \"utf8\");\n+\n+        try {\n+          // Parse the plist file using the plist package\n+          const config = plist.parse(fileContent);\n+\n+          // Extract the relevant fields from the config\n+          // Config is an array of alternating keys and values\n+          if (Array.isArray(config)) {\n+            const configObj: Record<string, string> = {};\n+\n+            // Convert array format [key1, value1, key2, value2, ...] to object\n+            for (let i = 0; i < config.length; i += 2) {\n+              if (i + 1 < config.length) {\n+                const key = config[i];\n+                const value = config[i + 1];\n+                if (typeof key === \"string\") {\n+                  configObj[key] = value as string;\n+                }\n+              }\n+            }\n+\n+            // Check if required keys are present\n+            if (configObj.licenseKey && configObj.apiUrl) {\n+              return {\n+                licenseKey: configObj.licenseKey,\n+                apiUrl: configObj.apiUrl,\n+              };\n+            }\n+          }\n+        } catch (parseError) {\n+          console.error(`Error parsing MDM configuration: ${parseError}`);\n+        }\n+      }\n+    }",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2096673487",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5725,
        "pr_file": "core/control-plane/mdm.ts",
        "discussion_id": "2096673487",
        "commented_code": "@@ -0,0 +1,202 @@\n+import * as crypto from \"crypto\";\n+import * as fs from \"fs\";\n+import * as os from \"os\";\n+import * as path from \"path\";\n+import * as plist from \"plist\";\n+\n+export interface MdmKeys {\n+  licenseKey: string;\n+  apiUrl: string;\n+}\n+\n+const CONTINUE_PUBLIC_KEY = `-----BEGIN PUBLIC KEY-----\n+MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz1pFVzsW2UScSnaPAwFp\n+93QU4+txtyJj8AOC3Kx7YkX1d48DGU2Fy1he7SXPHgcuhXYIqfWGn/Vy/4yJxXD7\n+HlU8RM7LlWHRk7ecAvF4WtxZDjPE0OSG5T69w5f7tMCtQPQseInCKqleJuCjxrvA\n+zyTWTwKA1S6e+KxXS/kbqsumriljFujNr6Gmh8ygDnpF055Xo0vTenkMipVw/oYn\n+U0EHx5ic+Fmcob3EyOj25lu/CVYtU1Rn8jPbrBOMiIq5sePh2QXOwGRsuTiZk2mP\n+LXSsjLbeWHifRrQ18wj/PC990E33QaFGNFp0NcBXMPbq5eKYKEzKZ0GsxtLoGxar\n+FQIDAQAB\n+-----END PUBLIC KEY-----`;\n+\n+export interface LicenseData {\n+  customerId: string;\n+  createdAt: string;\n+  expiresAt: string;\n+}\n+\n+export function validateLicenseKey(licenseKey: string): boolean {\n+  try {\n+    // Decode the base64 license key\n+    const decodedString = Buffer.from(licenseKey, \"base64\").toString(\"utf8\");\n+    const { data, signature } = JSON.parse(decodedString);\n+\n+    // Verify the signature\n+    const verify = crypto.createVerify(\"SHA256\");\n+    verify.update(data);\n+    verify.end();\n+\n+    const isValid = verify.verify(CONTINUE_PUBLIC_KEY, signature, \"base64\");\n+\n+    if (!isValid) return false;\n+\n+    // Check license expiration\n+    const licenseData: LicenseData = JSON.parse(data);\n+    const expirationDate = new Date(licenseData.expiresAt);\n+    const now = new Date();\n+\n+    return expirationDate > now;\n+  } catch (error) {\n+    console.error(\"License validation error:\", error);\n+    return false;\n+  }\n+}\n+\n+function readMdmKeysMacOS(): MdmKeys | undefined {\n+  try {\n+    // MDM configuration is typically stored in /Library/Managed Preferences/ on macOS\n+    // The filename is often the bundle identifier of the application\n+    const mdmPaths = [\n+      // Organization-specific MDM plist\n+      \"/Library/Managed Preferences/dev.continue.app.plist\",\n+      // User-specific MDM plist\n+      path.join(\n+        os.homedir(),\n+        \"Library/Managed Preferences/dev.continue.app.plist\",\n+      ),\n+    ];\n+\n+    // Try to find a valid MDM configuration file\n+    for (const mdmPath of mdmPaths) {\n+      if (fs.existsSync(mdmPath)) {\n+        // Read the file content\n+        const fileContent = fs.readFileSync(mdmPath, \"utf8\");\n+\n+        try {\n+          // Parse the plist file using the plist package\n+          const config = plist.parse(fileContent);\n+\n+          // Extract the relevant fields from the config\n+          // Config is an array of alternating keys and values\n+          if (Array.isArray(config)) {\n+            const configObj: Record<string, string> = {};\n+\n+            // Convert array format [key1, value1, key2, value2, ...] to object\n+            for (let i = 0; i < config.length; i += 2) {\n+              if (i + 1 < config.length) {\n+                const key = config[i];\n+                const value = config[i + 1];\n+                if (typeof key === \"string\") {\n+                  configObj[key] = value as string;\n+                }\n+              }\n+            }\n+\n+            // Check if required keys are present\n+            if (configObj.licenseKey && configObj.apiUrl) {\n+              return {\n+                licenseKey: configObj.licenseKey,\n+                apiUrl: configObj.apiUrl,\n+              };\n+            }\n+          }\n+        } catch (parseError) {\n+          console.error(`Error parsing MDM configuration: ${parseError}`);\n+        }\n+      }\n+    }",
        "comment_created_at": "2025-05-20T01:08:37+00:00",
        "comment_author": "tomasz-stefaniak",
        "comment_body": "This is very deeply nested, some helper functions would make this code more readable",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2089769330",
    "pr_number": 5657,
    "pr_file": "gui/src/util/clientTools/editImpl.ts",
    "created_at": "2025-05-14T21:17:09+00:00",
    "commented_code": "if (apply.status === \"error\") {\n     throw new Error(apply.error);\n   }\n-\n-  return {\n-    respondImmediately: false,\n-    output: undefined, //\u00a0No immediate output.\n-  };\n+  const state = extras.getState();\n+  const autoAccept = !!state.config.config.ui?.autoAcceptEditToolDiffs;\n+  if (autoAccept) {\n+    const out = await extras.ideMessenger.request(\"acceptDiff\", {\n+      streamId: extras.streamId,\n+      filepath: firstUriMatch,\n+    });\n+    if (out.status === \"error\") {\n+      throw new Error(out.error);\n+    }\n+    return {\n+      respondImmediately: true,\n+      output: undefined, // TODO - feed edit results back to model (also in parallel listeners)\n+    };\n+  } else {",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2089769330",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5657,
        "pr_file": "gui/src/util/clientTools/editImpl.ts",
        "discussion_id": "2089769330",
        "commented_code": "@@ -25,9 +25,24 @@ export const editToolImpl: ClientToolImpl = async (\n   if (apply.status === \"error\") {\n     throw new Error(apply.error);\n   }\n-\n-  return {\n-    respondImmediately: false,\n-    output: undefined, //\u00a0No immediate output.\n-  };\n+  const state = extras.getState();\n+  const autoAccept = !!state.config.config.ui?.autoAcceptEditToolDiffs;\n+  if (autoAccept) {\n+    const out = await extras.ideMessenger.request(\"acceptDiff\", {\n+      streamId: extras.streamId,\n+      filepath: firstUriMatch,\n+    });\n+    if (out.status === \"error\") {\n+      throw new Error(out.error);\n+    }\n+    return {\n+      respondImmediately: true,\n+      output: undefined, // TODO - feed edit results back to model (also in parallel listeners)\n+    };\n+  } else {",
        "comment_created_at": "2025-05-14T21:17:09+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "another nit but since the `if` clause has a return we could remove the `else` clause here and avoid the unnecessary nesting",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2211923239",
    "pr_number": 6662,
    "pr_file": "core/core.ts",
    "created_at": "2025-07-17T01:01:50+00:00",
    "commented_code": "return await ChatDescriber.describe(currentModel, {}, msg.data.text);\n     });\n \n+    on(\"conversation/compact\", async (msg) => {\n+      const currentModel = (await this.configHandler.loadConfig()).config\n+        ?.selectedModelByRole.chat;\n+\n+      if (!currentModel) {\n+        throw new Error(\"No chat model selected\");\n+      }\n+\n+      // Get the current session\n+      const session = historyManager.load(msg.data.sessionId);\n+      const historyUpToIndex = session.history.slice(0, msg.data.index + 1);\n+\n+      // Apply the same filtering logic as in constructMessages, but exclude the target message\n+      // if it already has a summary (we're re-compacting)\n+      let summaryContent = \"\";\n+      let filteredHistory = historyUpToIndex;\n+\n+      // First, check if the target message already has a summary and ignore it\n+      const targetMessageHasSummary =\n+        historyUpToIndex[msg.data.index].conversationSummary;\n+      const searchHistory = targetMessageHasSummary\n+        ? historyUpToIndex.slice(0, msg.data.index)\n+        : historyUpToIndex;\n+\n+      // Find the most recent conversation summary (excluding target if it has one)\n+      for (let i = searchHistory.length - 1; i >= 0; i--) {\n+        const summary = searchHistory[i].conversationSummary;\n+        if (summary) {\n+          summaryContent = summary;\n+          // Only include messages that come AFTER the message with the summary\n+          filteredHistory = historyUpToIndex.slice(i + 1);\n+          break;\n+        }\n+      }\n+\n+      // Create messages from filtered history\n+      const messages = filteredHistory.map((item: any) => item.message);\n+\n+      // If there's a previous summary, include it as a user message at the beginning\n+      if (summaryContent) {\n+        messages.unshift({\n+          role: \"user\",\n+          content: `Previous conversation summary:\n\n${summaryContent}`,\n+        });\n+      }\n+      const compactionPrompt = {\n+        role: \"user\" as const,\n+        content:\n+          \"Summarize the conversation above in third person, focusing on key points, decisions made, and important context. If there is a previous conversation summary included in the messages above, integrate it with the new conversation content to create a single condensed summary. Remove any redundant or outdated information while preserving essential context. Include specific technical details such as file names, paths, class names, function names, and any other identifiers that would help understand what was worked on. Write an impersonal summary that describes what the user requested and what was accomplished. Do not address the user directly. This summary will replace the conversation history to save tokens while preserving essential information.\",\n+      };\n+\n+      try {\n+        const response = await currentModel.chat(\n+          [...messages, compactionPrompt],\n+          new AbortController().signal,\n+          {},\n+        );\n+\n+        // Update the target message with the conversation summary\n+        const updatedHistory = [...session.history];\n+        updatedHistory[msg.data.index] = {\n+          ...updatedHistory[msg.data.index],\n+          conversationSummary: stripImages(response.content),\n+        };\n+\n+        // Update the session with the new history\n+        const updatedSession = {\n+          ...session,\n+          history: updatedHistory,\n+        };\n+\n+        historyManager.save(updatedSession);\n+\n+        return undefined;\n+      } catch (error) {\n+        console.error(\"Error compacting conversation:\", error);\n+        return undefined;\n+      }\n+    });\n+",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2211923239",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6662,
        "pr_file": "core/core.ts",
        "discussion_id": "2211923239",
        "commented_code": "@@ -537,6 +538,86 @@ export class Core {\n       return await ChatDescriber.describe(currentModel, {}, msg.data.text);\n     });\n \n+    on(\"conversation/compact\", async (msg) => {\n+      const currentModel = (await this.configHandler.loadConfig()).config\n+        ?.selectedModelByRole.chat;\n+\n+      if (!currentModel) {\n+        throw new Error(\"No chat model selected\");\n+      }\n+\n+      // Get the current session\n+      const session = historyManager.load(msg.data.sessionId);\n+      const historyUpToIndex = session.history.slice(0, msg.data.index + 1);\n+\n+      // Apply the same filtering logic as in constructMessages, but exclude the target message\n+      // if it already has a summary (we're re-compacting)\n+      let summaryContent = \"\";\n+      let filteredHistory = historyUpToIndex;\n+\n+      // First, check if the target message already has a summary and ignore it\n+      const targetMessageHasSummary =\n+        historyUpToIndex[msg.data.index].conversationSummary;\n+      const searchHistory = targetMessageHasSummary\n+        ? historyUpToIndex.slice(0, msg.data.index)\n+        : historyUpToIndex;\n+\n+      // Find the most recent conversation summary (excluding target if it has one)\n+      for (let i = searchHistory.length - 1; i >= 0; i--) {\n+        const summary = searchHistory[i].conversationSummary;\n+        if (summary) {\n+          summaryContent = summary;\n+          // Only include messages that come AFTER the message with the summary\n+          filteredHistory = historyUpToIndex.slice(i + 1);\n+          break;\n+        }\n+      }\n+\n+      // Create messages from filtered history\n+      const messages = filteredHistory.map((item: any) => item.message);\n+\n+      // If there's a previous summary, include it as a user message at the beginning\n+      if (summaryContent) {\n+        messages.unshift({\n+          role: \"user\",\n+          content: `Previous conversation summary:\\n\\n${summaryContent}`,\n+        });\n+      }\n+      const compactionPrompt = {\n+        role: \"user\" as const,\n+        content:\n+          \"Summarize the conversation above in third person, focusing on key points, decisions made, and important context. If there is a previous conversation summary included in the messages above, integrate it with the new conversation content to create a single condensed summary. Remove any redundant or outdated information while preserving essential context. Include specific technical details such as file names, paths, class names, function names, and any other identifiers that would help understand what was worked on. Write an impersonal summary that describes what the user requested and what was accomplished. Do not address the user directly. This summary will replace the conversation history to save tokens while preserving essential information.\",\n+      };\n+\n+      try {\n+        const response = await currentModel.chat(\n+          [...messages, compactionPrompt],\n+          new AbortController().signal,\n+          {},\n+        );\n+\n+        // Update the target message with the conversation summary\n+        const updatedHistory = [...session.history];\n+        updatedHistory[msg.data.index] = {\n+          ...updatedHistory[msg.data.index],\n+          conversationSummary: stripImages(response.content),\n+        };\n+\n+        // Update the session with the new history\n+        const updatedSession = {\n+          ...session,\n+          history: updatedHistory,\n+        };\n+\n+        historyManager.save(updatedSession);\n+\n+        return undefined;\n+      } catch (error) {\n+        console.error(\"Error compacting conversation:\", error);\n+        return undefined;\n+      }\n+    });\n+",
        "comment_created_at": "2025-07-17T01:01:50+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "Could we pull this into a `CompactionService` or something to get it out of `core/core.ts`? Could also write tests more easily for it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2008629329",
    "pr_number": 4559,
    "pr_file": "core/llm/llms/Anthropic.ts",
    "created_at": "2025-03-22T02:57:56+00:00",
    "commented_code": "},\n         ],\n       };\n-    } else if (message.role === \"assistant\" && message.toolCalls) {\n-      return {\n-        role: \"assistant\",\n-        content: message.toolCalls.map((toolCall) => ({\n+    } else if (message.role === \"assistant\") {",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2008629329",
        "repo_full_name": "continuedev/continue",
        "pr_number": 4559,
        "pr_file": "core/llm/llms/Anthropic.ts",
        "discussion_id": "2008629329",
        "commented_code": "@@ -53,15 +68,54 @@ class Anthropic extends BaseLLM {\n           },\n         ],\n       };\n-    } else if (message.role === \"assistant\" && message.toolCalls) {\n-      return {\n-        role: \"assistant\",\n-        content: message.toolCalls.map((toolCall) => ({\n+    } else if (message.role === \"assistant\") {",
        "comment_created_at": "2025-03-22T02:57:56+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "This function is quite large - could we pull it out into a util and break it down to make it easier to read/test? Again, another scenario where the surrounding code isn't particularly clean, but trying to keep things more maintainable going forwards",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2096859565",
    "pr_number": 5670,
    "pr_file": "gui/src/components/mainInput/TipTapEditor/useMainEditorWebviewListeners.ts",
    "created_at": "2025-05-20T04:04:11+00:00",
    "commented_code": "},\n     [],\n   );\n+\n+  const activeContextProviders = useAppSelector(",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2096859565",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5670,
        "pr_file": "gui/src/components/mainInput/TipTapEditor/useMainEditorWebviewListeners.ts",
        "discussion_id": "2096859565",
        "commented_code": "@@ -178,4 +181,21 @@ export function useMainEditorWebviewListeners({\n     },\n     [],\n   );\n+\n+  const activeContextProviders = useAppSelector(",
        "comment_created_at": "2025-05-20T04:04:11+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "We don't have linting for this but it's a bit easier to read the file if we keep all these const declarations towards the top of the function before the hooks, eg `useWebviewListener`s",
        "pr_file_module": null
      },
      {
        "comment_id": "2097458573",
        "repo_full_name": "continuedev/continue",
        "pr_number": 5670,
        "pr_file": "gui/src/components/mainInput/TipTapEditor/useMainEditorWebviewListeners.ts",
        "discussion_id": "2096859565",
        "commented_code": "@@ -178,4 +181,21 @@ export function useMainEditorWebviewListeners({\n     },\n     [],\n   );\n+\n+  const activeContextProviders = useAppSelector(",
        "comment_created_at": "2025-05-20T09:17:46+00:00",
        "comment_author": "uinstinct",
        "comment_body": "right. implemented!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1986319141",
    "pr_number": 4559,
    "pr_file": "gui/src/redux/slices/sessionSlice.ts",
    "created_at": "2025-03-09T13:06:40+00:00",
    "commented_code": "} else {\n             // Add to the existing message\n             if (message.content) {\n-              const messageContent = renderChatMessage(message);\n-              if (messageContent.includes(\"<think>\")) {\n+              // Check if the message content is an array with parts\n+              if (\n+                Array.isArray(message.content) &&",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "1986319141",
        "repo_full_name": "continuedev/continue",
        "pr_number": 4559,
        "pr_file": "gui/src/redux/slices/sessionSlice.ts",
        "discussion_id": "1986319141",
        "commented_code": "@@ -358,29 +355,216 @@ export const sessionSlice = createSlice({\n           } else {\n             // Add to the existing message\n             if (message.content) {\n-              const messageContent = renderChatMessage(message);\n-              if (messageContent.includes(\"<think>\")) {\n+              // Check if the message content is an array with parts\n+              if (\n+                Array.isArray(message.content) &&",
        "comment_created_at": "2025-03-09T13:06:40+00:00",
        "comment_author": "FallDownTheSystem",
        "comment_body": "This part is basically handling the content as parts, aka the Messages API",
        "pr_file_module": null
      },
      {
        "comment_id": "2008643579",
        "repo_full_name": "continuedev/continue",
        "pr_number": 4559,
        "pr_file": "gui/src/redux/slices/sessionSlice.ts",
        "discussion_id": "1986319141",
        "commented_code": "@@ -358,29 +355,216 @@ export const sessionSlice = createSlice({\n           } else {\n             // Add to the existing message\n             if (message.content) {\n-              const messageContent = renderChatMessage(message);\n-              if (messageContent.includes(\"<think>\")) {\n+              // Check if the message content is an array with parts\n+              if (\n+                Array.isArray(message.content) &&",
        "comment_created_at": "2025-03-22T04:03:44+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "This all looks solid but there is just so much logic here that I think we really need to break this out into some utils that are smaller/easier to read/more testable. Again, the code around isn't the cleanest, but it would be really helpful for maintenance/debugging.",
        "pr_file_module": null
      }
    ]
  }
]