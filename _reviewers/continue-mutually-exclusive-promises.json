[
  {
    "discussion_id": "2146075825",
    "pr_number": 6022,
    "pr_file": "extensions/vscode/scripts/download-copy-sqlite-esbuild.js",
    "created_at": "2025-06-13T20:51:06+00:00",
    "commented_code": "+const { fork } = require(\"child_process\");\n+const fs = require(\"fs\");\n+const https = require(\"https\");\n+const path = require(\"path\");\n+\n+const { rimrafSync } = require(\"rimraf\");\n+\n+const { execCmdSync } = require(\"../../../scripts/util\");\n+\n+/**\n+ * download a file using nodejs http\n+ * @param {string} url\n+ * @param {string} outputPath\n+ * @param {number} maxRedirects\n+ */\n+async function downloadFile(url, outputPath, maxRedirects = 5) {\n+  return new Promise((resolve, reject) => {\n+    const downloadWithRedirects = (currentUrl, redirectCount = 0) => {\n+      if (redirectCount > maxRedirects) {\n+        return reject(new Error(`Too many redirects (${maxRedirects})`));\n+      }\n+\n+      const request = https.get(currentUrl, (response) => {\n+        if (\n+          response.statusCode >= 300 &&\n+          response.statusCode < 400 &&\n+          response.headers.location\n+        ) {\n+          return downloadWithRedirects(\n+            response.headers.location,\n+            redirectCount + 1,\n+          );\n+        }\n+\n+        if (response.statusCode !== 200) {\n+          return reject(\n+            new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`),\n+          );\n+        }\n+\n+        const outputDir = path.dirname(outputPath);\n+        if (!fs.existsSync(outputDir)) {\n+          fs.mkdirSync(outputDir, { recursive: true });\n+        }\n+\n+        const writeStream = fs.createWriteStream(outputPath);\n+\n+        const totalSize = parseInt(response.headers[\"content-length\"], 10);\n+        let downloadedSize = 0;\n+\n+        response.on(\"data\", (chunk) => {\n+          downloadedSize += chunk.length;\n+          if (totalSize) {\n+            const percent = ((downloadedSize / totalSize) * 100).toFixed(1);\n+            process.stdout.write(\n+              `\\rDownloading: ${percent}% (${downloadedSize}/${totalSize} bytes)`,\n+            );\n+          }\n+        });\n+\n+        response.pipe(writeStream);\n+\n+        writeStream.on(\"finish\", () => {\n+          console.log(`\nDownload completed: ${outputPath}`);\n+          resolve(outputPath);\n+        });\n+\n+        writeStream.on(\"error\", reject);\n+        response.on(\"error\", reject);\n+      });\n+\n+      request.on(\"error\", reject);\n+      request.setTimeout(30000, () => {\n+        request.destroy();\n+        reject(new Error(\"Request timeout\"));\n+      });\n+    };\n+\n+    downloadWithRedirects(url);\n+  });\n+}\n+\n+/**\n+ *\n+ * @param {string} target platform specific target\n+ * @param {string} targetDir the directory to download into\n+ */\n+async function downloadSqlite(target, targetDir) {\n+  const downloadUrl =\n+    // node-sqlite3 doesn't have a pre-built binary for win32-arm64\n+    target === \"win32-arm64\"\n+      ? \"https://continue-server-binaries.s3.us-west-1.amazonaws.com/win32-arm64/node_sqlite3.tar.gz\"\n+      : `https://github.com/TryGhost/node-sqlite3/releases/download/v5.1.7/sqlite3-v5.1.7-napi-v6-${\n+          target\n+        }.tar.gz`;\n+  await downloadFile(downloadUrl, targetDir);\n+}\n+\n+async function installAndCopySqlite(target) {\n+  // Replace the installed with pre-built\n+  console.log(\"[info] Downloading pre-built sqlite3 binary\");\n+  rimrafSync(\"../../core/node_modules/sqlite3/build\");\n+  await downloadSqlite(target, \"../../core/node_modules/sqlite3/build.tar.gz\");\n+  execCmdSync(\"cd ../../core/node_modules/sqlite3 && tar -xvzf build.tar.gz\");\n+  fs.unlinkSync(\"../../core/node_modules/sqlite3/build.tar.gz\");\n+}\n+\n+async function installAndCopyEsbuild(target) {\n+  // Download and unzip esbuild\n+  console.log(\"[info] Downloading pre-built esbuild binary\");\n+  rimrafSync(\"node_modules/@esbuild\");\n+  fs.mkdirSync(\"node_modules/@esbuild\", { recursive: true });\n+  await downloadFile(\n+    `https://continue-server-binaries.s3.us-west-1.amazonaws.com/${target}/esbuild.zip`,\n+    \"node_modules/@esbuild/esbuild.zip\",\n+  );\n+  execCmdSync(\"cd node_modules/@esbuild && unzip esbuild.zip\");\n+  fs.unlinkSync(\"node_modules/@esbuild/esbuild.zip\");\n+}\n+\n+process.on(\"message\", (msg) => {\n+  const { operation, target } = msg.payload;\n+  if (operation === \"sqlite\") {\n+    installAndCopySqlite(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+  if (operation === \"esbuild\") {\n+    installAndCopyEsbuild(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+});\n+\n+/**\n+ * @param {string} target the platform to build for\n+ */\n+async function copySqlite(target) {\n+  const child = fork(__filename, { stdio: \"inherit\", cwd: process.cwd() });\n+  child.send({\n+    payload: {\n+      operation: \"sqlite\",\n+      target,\n+    },\n+  });\n+\n+  return new Promise((resolve, reject) => {\n+    child.on(\"message\", (msg) => {\n+      if (msg.error) {\n+        reject();\n+      }\n+      resolve();",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2146075825",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6022,
        "pr_file": "extensions/vscode/scripts/download-copy-sqlite-esbuild.js",
        "discussion_id": "2146075825",
        "commented_code": "@@ -0,0 +1,189 @@\n+const { fork } = require(\"child_process\");\n+const fs = require(\"fs\");\n+const https = require(\"https\");\n+const path = require(\"path\");\n+\n+const { rimrafSync } = require(\"rimraf\");\n+\n+const { execCmdSync } = require(\"../../../scripts/util\");\n+\n+/**\n+ * download a file using nodejs http\n+ * @param {string} url\n+ * @param {string} outputPath\n+ * @param {number} maxRedirects\n+ */\n+async function downloadFile(url, outputPath, maxRedirects = 5) {\n+  return new Promise((resolve, reject) => {\n+    const downloadWithRedirects = (currentUrl, redirectCount = 0) => {\n+      if (redirectCount > maxRedirects) {\n+        return reject(new Error(`Too many redirects (${maxRedirects})`));\n+      }\n+\n+      const request = https.get(currentUrl, (response) => {\n+        if (\n+          response.statusCode >= 300 &&\n+          response.statusCode < 400 &&\n+          response.headers.location\n+        ) {\n+          return downloadWithRedirects(\n+            response.headers.location,\n+            redirectCount + 1,\n+          );\n+        }\n+\n+        if (response.statusCode !== 200) {\n+          return reject(\n+            new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`),\n+          );\n+        }\n+\n+        const outputDir = path.dirname(outputPath);\n+        if (!fs.existsSync(outputDir)) {\n+          fs.mkdirSync(outputDir, { recursive: true });\n+        }\n+\n+        const writeStream = fs.createWriteStream(outputPath);\n+\n+        const totalSize = parseInt(response.headers[\"content-length\"], 10);\n+        let downloadedSize = 0;\n+\n+        response.on(\"data\", (chunk) => {\n+          downloadedSize += chunk.length;\n+          if (totalSize) {\n+            const percent = ((downloadedSize / totalSize) * 100).toFixed(1);\n+            process.stdout.write(\n+              `\\rDownloading: ${percent}% (${downloadedSize}/${totalSize} bytes)`,\n+            );\n+          }\n+        });\n+\n+        response.pipe(writeStream);\n+\n+        writeStream.on(\"finish\", () => {\n+          console.log(`\\nDownload completed: ${outputPath}`);\n+          resolve(outputPath);\n+        });\n+\n+        writeStream.on(\"error\", reject);\n+        response.on(\"error\", reject);\n+      });\n+\n+      request.on(\"error\", reject);\n+      request.setTimeout(30000, () => {\n+        request.destroy();\n+        reject(new Error(\"Request timeout\"));\n+      });\n+    };\n+\n+    downloadWithRedirects(url);\n+  });\n+}\n+\n+/**\n+ *\n+ * @param {string} target platform specific target\n+ * @param {string} targetDir the directory to download into\n+ */\n+async function downloadSqlite(target, targetDir) {\n+  const downloadUrl =\n+    // node-sqlite3 doesn't have a pre-built binary for win32-arm64\n+    target === \"win32-arm64\"\n+      ? \"https://continue-server-binaries.s3.us-west-1.amazonaws.com/win32-arm64/node_sqlite3.tar.gz\"\n+      : `https://github.com/TryGhost/node-sqlite3/releases/download/v5.1.7/sqlite3-v5.1.7-napi-v6-${\n+          target\n+        }.tar.gz`;\n+  await downloadFile(downloadUrl, targetDir);\n+}\n+\n+async function installAndCopySqlite(target) {\n+  // Replace the installed with pre-built\n+  console.log(\"[info] Downloading pre-built sqlite3 binary\");\n+  rimrafSync(\"../../core/node_modules/sqlite3/build\");\n+  await downloadSqlite(target, \"../../core/node_modules/sqlite3/build.tar.gz\");\n+  execCmdSync(\"cd ../../core/node_modules/sqlite3 && tar -xvzf build.tar.gz\");\n+  fs.unlinkSync(\"../../core/node_modules/sqlite3/build.tar.gz\");\n+}\n+\n+async function installAndCopyEsbuild(target) {\n+  // Download and unzip esbuild\n+  console.log(\"[info] Downloading pre-built esbuild binary\");\n+  rimrafSync(\"node_modules/@esbuild\");\n+  fs.mkdirSync(\"node_modules/@esbuild\", { recursive: true });\n+  await downloadFile(\n+    `https://continue-server-binaries.s3.us-west-1.amazonaws.com/${target}/esbuild.zip`,\n+    \"node_modules/@esbuild/esbuild.zip\",\n+  );\n+  execCmdSync(\"cd node_modules/@esbuild && unzip esbuild.zip\");\n+  fs.unlinkSync(\"node_modules/@esbuild/esbuild.zip\");\n+}\n+\n+process.on(\"message\", (msg) => {\n+  const { operation, target } = msg.payload;\n+  if (operation === \"sqlite\") {\n+    installAndCopySqlite(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+  if (operation === \"esbuild\") {\n+    installAndCopyEsbuild(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+});\n+\n+/**\n+ * @param {string} target the platform to build for\n+ */\n+async function copySqlite(target) {\n+  const child = fork(__filename, { stdio: \"inherit\", cwd: process.cwd() });\n+  child.send({\n+    payload: {\n+      operation: \"sqlite\",\n+      target,\n+    },\n+  });\n+\n+  return new Promise((resolve, reject) => {\n+    child.on(\"message\", (msg) => {\n+      if (msg.error) {\n+        reject();\n+      }\n+      resolve();",
        "comment_created_at": "2025-06-13T20:51:06+00:00",
        "comment_author": "recurseml[bot]",
        "comment_body": "In the copySqlite function, the promise is resolved unconditionally after the error check. If msg.error is true, the code will still call resolve() right after calling reject(), leading to an inconsistent promise state. The resolve() call should be in an else block to ensure mutual exclusion with the error case.\n\n---\n\n> *React with \ud83d\udc4d to tell me that this comment was useful, or \ud83d\udc4e if not (and I'll stop posting more comments like this in the future)*",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2146075847",
    "pr_number": 6022,
    "pr_file": "extensions/vscode/scripts/download-copy-sqlite-esbuild.js",
    "created_at": "2025-06-13T20:51:08+00:00",
    "commented_code": "+const { fork } = require(\"child_process\");\n+const fs = require(\"fs\");\n+const https = require(\"https\");\n+const path = require(\"path\");\n+\n+const { rimrafSync } = require(\"rimraf\");\n+\n+const { execCmdSync } = require(\"../../../scripts/util\");\n+\n+/**\n+ * download a file using nodejs http\n+ * @param {string} url\n+ * @param {string} outputPath\n+ * @param {number} maxRedirects\n+ */\n+async function downloadFile(url, outputPath, maxRedirects = 5) {\n+  return new Promise((resolve, reject) => {\n+    const downloadWithRedirects = (currentUrl, redirectCount = 0) => {\n+      if (redirectCount > maxRedirects) {\n+        return reject(new Error(`Too many redirects (${maxRedirects})`));\n+      }\n+\n+      const request = https.get(currentUrl, (response) => {\n+        if (\n+          response.statusCode >= 300 &&\n+          response.statusCode < 400 &&\n+          response.headers.location\n+        ) {\n+          return downloadWithRedirects(\n+            response.headers.location,\n+            redirectCount + 1,\n+          );\n+        }\n+\n+        if (response.statusCode !== 200) {\n+          return reject(\n+            new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`),\n+          );\n+        }\n+\n+        const outputDir = path.dirname(outputPath);\n+        if (!fs.existsSync(outputDir)) {\n+          fs.mkdirSync(outputDir, { recursive: true });\n+        }\n+\n+        const writeStream = fs.createWriteStream(outputPath);\n+\n+        const totalSize = parseInt(response.headers[\"content-length\"], 10);\n+        let downloadedSize = 0;\n+\n+        response.on(\"data\", (chunk) => {\n+          downloadedSize += chunk.length;\n+          if (totalSize) {\n+            const percent = ((downloadedSize / totalSize) * 100).toFixed(1);\n+            process.stdout.write(\n+              `\\rDownloading: ${percent}% (${downloadedSize}/${totalSize} bytes)`,\n+            );\n+          }\n+        });\n+\n+        response.pipe(writeStream);\n+\n+        writeStream.on(\"finish\", () => {\n+          console.log(`\nDownload completed: ${outputPath}`);\n+          resolve(outputPath);\n+        });\n+\n+        writeStream.on(\"error\", reject);\n+        response.on(\"error\", reject);\n+      });\n+\n+      request.on(\"error\", reject);\n+      request.setTimeout(30000, () => {\n+        request.destroy();\n+        reject(new Error(\"Request timeout\"));\n+      });\n+    };\n+\n+    downloadWithRedirects(url);\n+  });\n+}\n+\n+/**\n+ *\n+ * @param {string} target platform specific target\n+ * @param {string} targetDir the directory to download into\n+ */\n+async function downloadSqlite(target, targetDir) {\n+  const downloadUrl =\n+    // node-sqlite3 doesn't have a pre-built binary for win32-arm64\n+    target === \"win32-arm64\"\n+      ? \"https://continue-server-binaries.s3.us-west-1.amazonaws.com/win32-arm64/node_sqlite3.tar.gz\"\n+      : `https://github.com/TryGhost/node-sqlite3/releases/download/v5.1.7/sqlite3-v5.1.7-napi-v6-${\n+          target\n+        }.tar.gz`;\n+  await downloadFile(downloadUrl, targetDir);\n+}\n+\n+async function installAndCopySqlite(target) {\n+  // Replace the installed with pre-built\n+  console.log(\"[info] Downloading pre-built sqlite3 binary\");\n+  rimrafSync(\"../../core/node_modules/sqlite3/build\");\n+  await downloadSqlite(target, \"../../core/node_modules/sqlite3/build.tar.gz\");\n+  execCmdSync(\"cd ../../core/node_modules/sqlite3 && tar -xvzf build.tar.gz\");\n+  fs.unlinkSync(\"../../core/node_modules/sqlite3/build.tar.gz\");\n+}\n+\n+async function installAndCopyEsbuild(target) {\n+  // Download and unzip esbuild\n+  console.log(\"[info] Downloading pre-built esbuild binary\");\n+  rimrafSync(\"node_modules/@esbuild\");\n+  fs.mkdirSync(\"node_modules/@esbuild\", { recursive: true });\n+  await downloadFile(\n+    `https://continue-server-binaries.s3.us-west-1.amazonaws.com/${target}/esbuild.zip`,\n+    \"node_modules/@esbuild/esbuild.zip\",\n+  );\n+  execCmdSync(\"cd node_modules/@esbuild && unzip esbuild.zip\");\n+  fs.unlinkSync(\"node_modules/@esbuild/esbuild.zip\");\n+}\n+\n+process.on(\"message\", (msg) => {\n+  const { operation, target } = msg.payload;\n+  if (operation === \"sqlite\") {\n+    installAndCopySqlite(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+  if (operation === \"esbuild\") {\n+    installAndCopyEsbuild(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+});\n+\n+/**\n+ * @param {string} target the platform to build for\n+ */\n+async function copySqlite(target) {\n+  const child = fork(__filename, { stdio: \"inherit\", cwd: process.cwd() });\n+  child.send({\n+    payload: {\n+      operation: \"sqlite\",\n+      target,\n+    },\n+  });\n+\n+  return new Promise((resolve, reject) => {\n+    child.on(\"message\", (msg) => {\n+      if (msg.error) {\n+        reject();\n+      }\n+      resolve();\n+    });\n+  });\n+}\n+\n+/**\n+ * @param {string} target the platform to build for\n+ */\n+async function copyEsbuild(target) {\n+  const child = fork(__filename, { stdio: \"inherit\", cwd: process.cwd() });\n+  child.send({\n+    payload: {\n+      operation: \"esbuild\",\n+      target,\n+    },\n+  });\n+\n+  return new Promise((resolve, reject) => {\n+    child.on(\"message\", (msg) => {\n+      if (msg.error) {\n+        reject();\n+      }\n+      resolve();",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2146075847",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6022,
        "pr_file": "extensions/vscode/scripts/download-copy-sqlite-esbuild.js",
        "discussion_id": "2146075847",
        "commented_code": "@@ -0,0 +1,189 @@\n+const { fork } = require(\"child_process\");\n+const fs = require(\"fs\");\n+const https = require(\"https\");\n+const path = require(\"path\");\n+\n+const { rimrafSync } = require(\"rimraf\");\n+\n+const { execCmdSync } = require(\"../../../scripts/util\");\n+\n+/**\n+ * download a file using nodejs http\n+ * @param {string} url\n+ * @param {string} outputPath\n+ * @param {number} maxRedirects\n+ */\n+async function downloadFile(url, outputPath, maxRedirects = 5) {\n+  return new Promise((resolve, reject) => {\n+    const downloadWithRedirects = (currentUrl, redirectCount = 0) => {\n+      if (redirectCount > maxRedirects) {\n+        return reject(new Error(`Too many redirects (${maxRedirects})`));\n+      }\n+\n+      const request = https.get(currentUrl, (response) => {\n+        if (\n+          response.statusCode >= 300 &&\n+          response.statusCode < 400 &&\n+          response.headers.location\n+        ) {\n+          return downloadWithRedirects(\n+            response.headers.location,\n+            redirectCount + 1,\n+          );\n+        }\n+\n+        if (response.statusCode !== 200) {\n+          return reject(\n+            new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`),\n+          );\n+        }\n+\n+        const outputDir = path.dirname(outputPath);\n+        if (!fs.existsSync(outputDir)) {\n+          fs.mkdirSync(outputDir, { recursive: true });\n+        }\n+\n+        const writeStream = fs.createWriteStream(outputPath);\n+\n+        const totalSize = parseInt(response.headers[\"content-length\"], 10);\n+        let downloadedSize = 0;\n+\n+        response.on(\"data\", (chunk) => {\n+          downloadedSize += chunk.length;\n+          if (totalSize) {\n+            const percent = ((downloadedSize / totalSize) * 100).toFixed(1);\n+            process.stdout.write(\n+              `\\rDownloading: ${percent}% (${downloadedSize}/${totalSize} bytes)`,\n+            );\n+          }\n+        });\n+\n+        response.pipe(writeStream);\n+\n+        writeStream.on(\"finish\", () => {\n+          console.log(`\\nDownload completed: ${outputPath}`);\n+          resolve(outputPath);\n+        });\n+\n+        writeStream.on(\"error\", reject);\n+        response.on(\"error\", reject);\n+      });\n+\n+      request.on(\"error\", reject);\n+      request.setTimeout(30000, () => {\n+        request.destroy();\n+        reject(new Error(\"Request timeout\"));\n+      });\n+    };\n+\n+    downloadWithRedirects(url);\n+  });\n+}\n+\n+/**\n+ *\n+ * @param {string} target platform specific target\n+ * @param {string} targetDir the directory to download into\n+ */\n+async function downloadSqlite(target, targetDir) {\n+  const downloadUrl =\n+    // node-sqlite3 doesn't have a pre-built binary for win32-arm64\n+    target === \"win32-arm64\"\n+      ? \"https://continue-server-binaries.s3.us-west-1.amazonaws.com/win32-arm64/node_sqlite3.tar.gz\"\n+      : `https://github.com/TryGhost/node-sqlite3/releases/download/v5.1.7/sqlite3-v5.1.7-napi-v6-${\n+          target\n+        }.tar.gz`;\n+  await downloadFile(downloadUrl, targetDir);\n+}\n+\n+async function installAndCopySqlite(target) {\n+  // Replace the installed with pre-built\n+  console.log(\"[info] Downloading pre-built sqlite3 binary\");\n+  rimrafSync(\"../../core/node_modules/sqlite3/build\");\n+  await downloadSqlite(target, \"../../core/node_modules/sqlite3/build.tar.gz\");\n+  execCmdSync(\"cd ../../core/node_modules/sqlite3 && tar -xvzf build.tar.gz\");\n+  fs.unlinkSync(\"../../core/node_modules/sqlite3/build.tar.gz\");\n+}\n+\n+async function installAndCopyEsbuild(target) {\n+  // Download and unzip esbuild\n+  console.log(\"[info] Downloading pre-built esbuild binary\");\n+  rimrafSync(\"node_modules/@esbuild\");\n+  fs.mkdirSync(\"node_modules/@esbuild\", { recursive: true });\n+  await downloadFile(\n+    `https://continue-server-binaries.s3.us-west-1.amazonaws.com/${target}/esbuild.zip`,\n+    \"node_modules/@esbuild/esbuild.zip\",\n+  );\n+  execCmdSync(\"cd node_modules/@esbuild && unzip esbuild.zip\");\n+  fs.unlinkSync(\"node_modules/@esbuild/esbuild.zip\");\n+}\n+\n+process.on(\"message\", (msg) => {\n+  const { operation, target } = msg.payload;\n+  if (operation === \"sqlite\") {\n+    installAndCopySqlite(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+  if (operation === \"esbuild\") {\n+    installAndCopyEsbuild(target)\n+      .then(() => process.send({ done: true }))\n+      .catch((error) => {\n+        console.error(error); // show the error in the parent process\n+        process.send({ error: true });\n+      });\n+  }\n+});\n+\n+/**\n+ * @param {string} target the platform to build for\n+ */\n+async function copySqlite(target) {\n+  const child = fork(__filename, { stdio: \"inherit\", cwd: process.cwd() });\n+  child.send({\n+    payload: {\n+      operation: \"sqlite\",\n+      target,\n+    },\n+  });\n+\n+  return new Promise((resolve, reject) => {\n+    child.on(\"message\", (msg) => {\n+      if (msg.error) {\n+        reject();\n+      }\n+      resolve();\n+    });\n+  });\n+}\n+\n+/**\n+ * @param {string} target the platform to build for\n+ */\n+async function copyEsbuild(target) {\n+  const child = fork(__filename, { stdio: \"inherit\", cwd: process.cwd() });\n+  child.send({\n+    payload: {\n+      operation: \"esbuild\",\n+      target,\n+    },\n+  });\n+\n+  return new Promise((resolve, reject) => {\n+    child.on(\"message\", (msg) => {\n+      if (msg.error) {\n+        reject();\n+      }\n+      resolve();",
        "comment_created_at": "2025-06-13T20:51:08+00:00",
        "comment_author": "recurseml[bot]",
        "comment_body": "Similar to the copySqlite function, the copyEsbuild function has the same promise resolution issue where resolve() is called unconditionally after the error check. The resolve() call should be in an else block to prevent resolving after an error has occurred.\n\n---\n\n> *React with \ud83d\udc4d to tell me that this comment was useful, or \ud83d\udc4e if not (and I'll stop posting more comments like this in the future)*",
        "pr_file_module": null
      }
    ]
  }
]