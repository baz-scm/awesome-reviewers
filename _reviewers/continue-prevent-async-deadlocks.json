[
  {
    "discussion_id": "2202907886",
    "pr_number": 6595,
    "pr_file": "extensions/vscode/src/stubs/WorkOsAuthProvider.ts",
    "created_at": "2025-07-12T20:33:47+00:00",
    "commented_code": "public async getSessions(\n     scopes?: string[],\n   ): Promise<ContinueAuthenticationSession[]> {\n+    await this.initialRefreshAttempt;",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2202907886",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6595,
        "pr_file": "extensions/vscode/src/stubs/WorkOsAuthProvider.ts",
        "discussion_id": "2202907886",
        "commented_code": "@@ -147,6 +150,7 @@ export class WorkOsAuthProvider implements AuthenticationProvider, Disposable {\n   public async getSessions(\n     scopes?: string[],\n   ): Promise<ContinueAuthenticationSession[]> {\n+    await this.initialRefreshAttempt;",
        "comment_created_at": "2025-07-12T20:33:47+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":9,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"setHasAttemptedRefresh(\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"getSessions(\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"initialRefreshAttempt\\\" extensions/vscode/src/stubs/WorkOsAuthProvider.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"setHasAttemptedRefresh\\\" extensions/vscode/src/stubs/WorkOsAuthProvider.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nAwaiting initialRefreshAttempt inside getSessions creates a deadlock: refreshSessions is triggered immediately in the constructor before this promise is resolved, and refreshSessions itself calls getSessions, meaning getSessions waits on a promise whose resolution depends on getSessions finishing. This stalls authentication forever.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2210249676",
    "pr_number": 6595,
    "pr_file": "extensions/vscode/src/stubs/WorkOsAuthProvider.ts",
    "created_at": "2025-07-16T12:32:27+00:00",
    "commented_code": "if (useOnboarding) {\n       WorkOsAuthProvider.useOnboardingUri = true;\n     }\n-\n+    await WorkOsAuthProvider.hasAttemptedRefresh;",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2210249676",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6595,
        "pr_file": "extensions/vscode/src/stubs/WorkOsAuthProvider.ts",
        "discussion_id": "2210249676",
        "commented_code": "@@ -553,7 +564,7 @@ export async function getControlPlaneSessionInfo(\n     if (useOnboarding) {\n       WorkOsAuthProvider.useOnboardingUri = true;\n     }\n-\n+    await WorkOsAuthProvider.hasAttemptedRefresh;",
        "comment_created_at": "2025-07-16T12:32:27+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[]} -->\nWaiting on hasAttemptedRefresh can block forever when no stored sessions exist because the underlying Promise is resolved only after a token-refresh attempt emits \"attempted\"; if _refreshSessions returns early (no sessions) that emit never occurs, so this await can hang and prevent getControlPlaneSessionInfo from returning.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2209282637",
    "pr_number": 6649,
    "pr_file": "gui/src/redux/thunks/streamResponseAfterToolCall.ts",
    "created_at": "2025-07-16T05:40:26+00:00",
    "commented_code": "import { ChatMessage } from \"core\";\n import { renderContextItems } from \"core/util/messageContent\";\n import {\n+  ChatHistoryItemWithMessageId,\n   resetNextCodeBlockToApplyIndex,\n   streamUpdate,\n } from \"../slices/sessionSlice\";\n-import { AppThunkDispatch, RootState, ThunkApiType } from \"../store\";\n+import { ThunkApiType } from \"../store\";\n import { findToolCallById } from \"../util\";\n import { streamNormalInput } from \"./streamNormalInput\";\n import { streamThunkWrapper } from \"./streamThunkWrapper\";\n \n-/**\n- * Finds the assistant message that contains the specified tool call.\n- */\n-function findAssistantMessageWithToolCall(\n-  history: RootState[\"session\"][\"history\"],\n-  toolCallId: string,\n-) {\n-  return history.find(\n-    (item) =>\n-      item.message.role === \"assistant\" &&\n-      item.toolCallStates?.some((tc) => tc.toolCallId === toolCallId),\n-  );\n-}\n-\n-/**\n- * Checks if all parallel tool calls in an assistant message are complete.\n- */\n-function areAllToolCallsComplete(\n-  toolCallStates: NonNullable<\n-    ReturnType<typeof findAssistantMessageWithToolCall>\n-  >[\"toolCallStates\"],\n-): boolean {\n-  if (!toolCallStates) return false;\n-\n-  const completedToolCalls = toolCallStates.filter(\n-    (tc) => tc.status === \"done\",\n-  );\n-\n-  return completedToolCalls.length === toolCallStates.length;\n-}\n-\n /**\n  * Determines if we should continue streaming based on tool call completion status.\n  */\n-function shouldContinueStreaming(\n-  assistantMessage: ReturnType<typeof findAssistantMessageWithToolCall>,\n+function areAllToolsDoneStreaming(\n+  assistantMessage: ChatHistoryItemWithMessageId | undefined,\n ): boolean {\n+  // This might occur because of race conditions, if so, the tools are completed\n   if (!assistantMessage?.toolCallStates) {\n-    return false; // No assistant message found - don't stream",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2209282637",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6649,
        "pr_file": "gui/src/redux/thunks/streamResponseAfterToolCall.ts",
        "discussion_id": "2209282637",
        "commented_code": "@@ -2,80 +2,32 @@ import { createAsyncThunk, unwrapResult } from \"@reduxjs/toolkit\";\n import { ChatMessage } from \"core\";\n import { renderContextItems } from \"core/util/messageContent\";\n import {\n+  ChatHistoryItemWithMessageId,\n   resetNextCodeBlockToApplyIndex,\n   streamUpdate,\n } from \"../slices/sessionSlice\";\n-import { AppThunkDispatch, RootState, ThunkApiType } from \"../store\";\n+import { ThunkApiType } from \"../store\";\n import { findToolCallById } from \"../util\";\n import { streamNormalInput } from \"./streamNormalInput\";\n import { streamThunkWrapper } from \"./streamThunkWrapper\";\n \n-/**\n- * Finds the assistant message that contains the specified tool call.\n- */\n-function findAssistantMessageWithToolCall(\n-  history: RootState[\"session\"][\"history\"],\n-  toolCallId: string,\n-) {\n-  return history.find(\n-    (item) =>\n-      item.message.role === \"assistant\" &&\n-      item.toolCallStates?.some((tc) => tc.toolCallId === toolCallId),\n-  );\n-}\n-\n-/**\n- * Checks if all parallel tool calls in an assistant message are complete.\n- */\n-function areAllToolCallsComplete(\n-  toolCallStates: NonNullable<\n-    ReturnType<typeof findAssistantMessageWithToolCall>\n-  >[\"toolCallStates\"],\n-): boolean {\n-  if (!toolCallStates) return false;\n-\n-  const completedToolCalls = toolCallStates.filter(\n-    (tc) => tc.status === \"done\",\n-  );\n-\n-  return completedToolCalls.length === toolCallStates.length;\n-}\n-\n /**\n  * Determines if we should continue streaming based on tool call completion status.\n  */\n-function shouldContinueStreaming(\n-  assistantMessage: ReturnType<typeof findAssistantMessageWithToolCall>,\n+function areAllToolsDoneStreaming(\n+  assistantMessage: ChatHistoryItemWithMessageId | undefined,\n ): boolean {\n+  // This might occur because of race conditions, if so, the tools are completed\n   if (!assistantMessage?.toolCallStates) {\n-    return false; // No assistant message found - don't stream",
        "comment_created_at": "2025-07-16T05:40:26+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "The core fix was removing this clause. My hypothesis is that we had a race condition where the `toolCallStates` was getting cleared before we reached this point, which should indicate that the tool call has completed and we should continue streaming, but we were instead returning false.\r\n\r\nThe only reason this `shouldContinueStreaming` is because with the new parallel tool calling support, we want to pause streaming until _all_ tools are complete. Previously this check didn't exist at all, we just always resumed streaming at the end of the thunk.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181091178",
    "pr_number": 6421,
    "pr_file": "gui/src/components/GenerateRuleDialog/useRuleGeneration.ts",
    "created_at": "2025-07-02T22:32:39+00:00",
    "commented_code": "+import { ChatMessage, ToolCallDelta } from \"core\";\n+import { createRuleBlock } from \"core/tools/definitions/createRuleBlock\";\n+import { CreateRuleBlockArgs } from \"core/tools/implementations/createRuleBlock\";\n+import { useCallback, useContext, useState } from \"react\";\n+import { IdeMessengerContext } from \"../../context/IdeMessenger\";\n+import { useAppSelector } from \"../../redux/hooks\";\n+import { selectSelectedChatModel } from \"../../redux/slices/configSlice\";\n+import { addToolCallDeltaToState } from \"../../util/toolCallState\";\n+\n+const RULE_GENERATION_SYSTEM_MESSAGE = `You are an expert at creating effective rules for AI coding assistants. When generating rules, follow these best practices:\n+\n+FOCUS AND SCOPE:\n+- Keep rules focused on a single, specific concern\n+- Make rules actionable with clear, concrete instructions\n+- Write rules like clear internal documentation\n+- Avoid vague guidance - be specific about what to do\n+\n+STRUCTURE:\n+- Keep rules under 500 lines\n+- Use imperative language (\"Use X\", \"Always do Y\", \"Avoid Z\")\n+- Provide concrete examples when possible\n+- Break complex rules into multiple, composable rules\n+\n+CONTENT GUIDELINES:\n+- Include specific coding patterns, conventions, or architectural decisions\n+- Reference actual file examples or templates when relevant\n+- Encode domain-specific knowledge about the codebase\n+- Standardize style or workflow decisions\n+\n+EXAMPLES FROM CHAT HISTORY:\n+- Always try to construct concrete examples for the rule based on the user's request and chat history\n+- If they say \"don't do X\", look in the chat history for instances where \"X\" was done incorrectly\n+- If they mention a pattern or approach, find code examples from the conversation that demonstrate it\n+- Use actual code snippets from the chat history to create before/after examples\n+- Format examples using markdown with the **Example** header like this:\n+\n+**Example**\n+\\`\\`\\`typescript\n+// Bad: Don't do this\n+const badExample = \"from chat history\";\n+\n+// Good: Do this instead  \n+const goodExample = \"corrected version\";\n+\\`\\`\\`\n+\n+RULE METADATA:\n+- Provide a clear, descriptive name that summarizes the rule's purpose\n+- Write a concise description explaining what the rule does\n+- Use appropriate glob patterns to scope the rule to relevant file types\n+- Consider whether the rule should be regex-based for content matching\n+\n+Remember: Good rules are persistent context that helps the AI understand project-specific requirements, coding standards, and workflows. The chat history is a goldmine for finding real examples of what to do or avoid.`;\n+\n+export interface UseRuleGenerationReturn {\n+  generateRule: () => Promise<void>;\n+  isGenerating: boolean;\n+  error: string | null;\n+  reset: () => void;\n+  createRuleBlockArgs: CreateRuleBlockArgs | null;\n+}\n+\n+export function useRuleGeneration(\n+  inputPrompt: string,\n+): UseRuleGenerationReturn {\n+  const [isGenerating, setIsGenerating] = useState(false);\n+  const [error, setError] = useState<string | null>(null);\n+  const [createRuleBlockArgs, setCreateRuleBlockArgs] =\n+    useState<CreateRuleBlockArgs | null>(null);\n+\n+  const ideMessenger = useContext(IdeMessengerContext);\n+  const currentHistory = useAppSelector((state) => state.session.history);\n+  const selectedChatModel = useAppSelector(selectSelectedChatModel);\n+\n+  const generateRule = useCallback(async () => {\n+    if (!selectedChatModel) {\n+      setError(\"No chat model selected\");\n+      return;\n+    }\n+\n+    setIsGenerating(true);\n+    setError(null);\n+    setCreateRuleBlockArgs(null);\n+\n+    try {\n+      debugger;\n+      // Convert current history to ChatMessage format\n+      const chatMessages: ChatMessage[] = currentHistory.map(\n+        (item) => item.message,\n+      );\n+\n+      // Add our rule generation prompt with instruction to use the tool\n+      const messages: ChatMessage[] = [\n+        {\n+          role: \"system\",\n+          content: RULE_GENERATION_SYSTEM_MESSAGE,\n+        },\n+        ...chatMessages,\n+        {\n+          role: \"user\",\n+          content: `The user has requested that we write a new rule. You MUST USE the create_rule_block tool to generate a well-structured rule. Do not say anything else, only call this tool. Here is their request: ${inputPrompt}`,\n+        },\n+      ];\n+\n+      // Create abort controller for this request\n+      const abortController = new AbortController();",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2181091178",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6421,
        "pr_file": "gui/src/components/GenerateRuleDialog/useRuleGeneration.ts",
        "discussion_id": "2181091178",
        "commented_code": "@@ -0,0 +1,160 @@\n+import { ChatMessage, ToolCallDelta } from \"core\";\n+import { createRuleBlock } from \"core/tools/definitions/createRuleBlock\";\n+import { CreateRuleBlockArgs } from \"core/tools/implementations/createRuleBlock\";\n+import { useCallback, useContext, useState } from \"react\";\n+import { IdeMessengerContext } from \"../../context/IdeMessenger\";\n+import { useAppSelector } from \"../../redux/hooks\";\n+import { selectSelectedChatModel } from \"../../redux/slices/configSlice\";\n+import { addToolCallDeltaToState } from \"../../util/toolCallState\";\n+\n+const RULE_GENERATION_SYSTEM_MESSAGE = `You are an expert at creating effective rules for AI coding assistants. When generating rules, follow these best practices:\n+\n+FOCUS AND SCOPE:\n+- Keep rules focused on a single, specific concern\n+- Make rules actionable with clear, concrete instructions\n+- Write rules like clear internal documentation\n+- Avoid vague guidance - be specific about what to do\n+\n+STRUCTURE:\n+- Keep rules under 500 lines\n+- Use imperative language (\"Use X\", \"Always do Y\", \"Avoid Z\")\n+- Provide concrete examples when possible\n+- Break complex rules into multiple, composable rules\n+\n+CONTENT GUIDELINES:\n+- Include specific coding patterns, conventions, or architectural decisions\n+- Reference actual file examples or templates when relevant\n+- Encode domain-specific knowledge about the codebase\n+- Standardize style or workflow decisions\n+\n+EXAMPLES FROM CHAT HISTORY:\n+- Always try to construct concrete examples for the rule based on the user's request and chat history\n+- If they say \"don't do X\", look in the chat history for instances where \"X\" was done incorrectly\n+- If they mention a pattern or approach, find code examples from the conversation that demonstrate it\n+- Use actual code snippets from the chat history to create before/after examples\n+- Format examples using markdown with the **Example** header like this:\n+\n+**Example**\n+\\`\\`\\`typescript\n+// Bad: Don't do this\n+const badExample = \"from chat history\";\n+\n+// Good: Do this instead  \n+const goodExample = \"corrected version\";\n+\\`\\`\\`\n+\n+RULE METADATA:\n+- Provide a clear, descriptive name that summarizes the rule's purpose\n+- Write a concise description explaining what the rule does\n+- Use appropriate glob patterns to scope the rule to relevant file types\n+- Consider whether the rule should be regex-based for content matching\n+\n+Remember: Good rules are persistent context that helps the AI understand project-specific requirements, coding standards, and workflows. The chat history is a goldmine for finding real examples of what to do or avoid.`;\n+\n+export interface UseRuleGenerationReturn {\n+  generateRule: () => Promise<void>;\n+  isGenerating: boolean;\n+  error: string | null;\n+  reset: () => void;\n+  createRuleBlockArgs: CreateRuleBlockArgs | null;\n+}\n+\n+export function useRuleGeneration(\n+  inputPrompt: string,\n+): UseRuleGenerationReturn {\n+  const [isGenerating, setIsGenerating] = useState(false);\n+  const [error, setError] = useState<string | null>(null);\n+  const [createRuleBlockArgs, setCreateRuleBlockArgs] =\n+    useState<CreateRuleBlockArgs | null>(null);\n+\n+  const ideMessenger = useContext(IdeMessengerContext);\n+  const currentHistory = useAppSelector((state) => state.session.history);\n+  const selectedChatModel = useAppSelector(selectSelectedChatModel);\n+\n+  const generateRule = useCallback(async () => {\n+    if (!selectedChatModel) {\n+      setError(\"No chat model selected\");\n+      return;\n+    }\n+\n+    setIsGenerating(true);\n+    setError(null);\n+    setCreateRuleBlockArgs(null);\n+\n+    try {\n+      debugger;\n+      // Convert current history to ChatMessage format\n+      const chatMessages: ChatMessage[] = currentHistory.map(\n+        (item) => item.message,\n+      );\n+\n+      // Add our rule generation prompt with instruction to use the tool\n+      const messages: ChatMessage[] = [\n+        {\n+          role: \"system\",\n+          content: RULE_GENERATION_SYSTEM_MESSAGE,\n+        },\n+        ...chatMessages,\n+        {\n+          role: \"user\",\n+          content: `The user has requested that we write a new rule. You MUST USE the create_rule_block tool to generate a well-structured rule. Do not say anything else, only call this tool. Here is their request: ${inputPrompt}`,\n+        },\n+      ];\n+\n+      // Create abort controller for this request\n+      const abortController = new AbortController();",
        "comment_created_at": "2025-07-02T22:32:39+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":6,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R --line-number \\\"debugger;\\\"\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"file\":\"gui/src/components/context/IdeMessenger.tsx\",\"line\":1,\"symbol\":\"IdeMessengerContext\"},\"toolName\":\"goToDefinition\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"pattern\":\"**/IdeMessenger*\"},\"toolName\":\"listFiles\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '60,120p' gui/src/components/GenerateRuleDialog/useRuleGeneration.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"sed -n '120,240p' gui/src/components/GenerateRuleDialog/useRuleGeneration.ts\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"debugger;\\\" gui/src/components/GenerateRuleDialog/useRuleGeneration.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nAbortController is created but never aborted or exposed, so inflight requests cannot be cancelled, potentially leaking resources if the component unmounts.",
        "pr_file_module": null
      }
    ]
  }
]