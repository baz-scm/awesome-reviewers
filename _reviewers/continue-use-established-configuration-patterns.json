[
  {
    "discussion_id": "2224133755",
    "pr_number": 6756,
    "pr_file": "gui/src/components/mainInput/InputToolbar.tsx",
    "created_at": "2025-07-23T01:38:26+00:00",
    "commented_code": "</ToolTip>\n               </HoverItem>\n             )}\n-            {defaultModel?.provider === \"anthropic\" && (\n+            {defaultModel?.underlyingProviderName === \"anthropic\" && (",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2224133755",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6756,
        "pr_file": "gui/src/components/mainInput/InputToolbar.tsx",
        "discussion_id": "2224133755",
        "commented_code": "@@ -141,19 +141,23 @@ function InputToolbar(props: InputToolbarProps) {\n                 </ToolTip>\n               </HoverItem>\n             )}\n-            {defaultModel?.provider === \"anthropic\" && (\n+            {defaultModel?.underlyingProviderName === \"anthropic\" && (",
        "comment_created_at": "2025-07-23T01:38:26+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "This solves a bug where the reasoning toggle wasn't rendered when using a hub assistant because the provider name is always `continue-proxy` for all models when using the hub.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181091188",
    "pr_number": 6421,
    "pr_file": "gui/src/components/GenerateRuleDialog/GenerationScreen.tsx",
    "created_at": "2025-07-02T22:32:39+00:00",
    "commented_code": "+import {\n+  createRuleMarkdown,\n+  getRuleType,\n+  RuleType,\n+  RuleTypeDescriptions,\n+} from \"@continuedev/config-yaml\";\n+import { InformationCircleIcon } from \"@heroicons/react/24/outline\";\n+import { createRuleFilePath } from \"core/config/markdown/utils\";\n+import { CreateRuleBlockArgs } from \"core/tools/implementations/createRuleBlock\";\n+import { useContext, useEffect, useRef, useState } from \"react\";\n+import { useForm } from \"react-hook-form\";\n+import { IdeMessengerContext } from \"../../context/IdeMessenger\";\n+import Spinner from \"../gui/Spinner\";\n+import { ToolTip } from \"../gui/Tooltip\";\n+import { Button } from \"../ui\";\n+import { useRuleGeneration } from \"./useRuleGeneration\";\n+\n+interface GenerationScreenProps {\n+  inputPrompt: string;\n+  onBack: () => void;\n+  onSuccess: () => void;\n+}\n+\n+export function GenerationScreen({\n+  inputPrompt,\n+  onBack,\n+  onSuccess,\n+}: GenerationScreenProps) {\n+  const ideMessenger = useContext(IdeMessengerContext);\n+\n+  const { register, watch, setValue, reset } = useForm<CreateRuleBlockArgs>({\n+    defaultValues: {\n+      name: \"\",\n+      description: \"\",\n+      globs: \"\",\n+      alwaysApply: true,\n+      rule: \"\",\n+    },\n+  });\n+\n+  const formData = watch();\n+\n+  // Track rule type separately from form data\n+  const [selectedRuleType, setSelectedRuleType] = useState<RuleType>(\n+    RuleType.Always,\n+  );\n+\n+  // Use the generation hook with the input prompt\n+  const { generateRule, isGenerating, error, createRuleBlockArgs } =\n+    useRuleGeneration(inputPrompt);\n+\n+  // Start generation once when component mounts\n+  const hasInitialized = useRef(false);\n+  if (!hasInitialized.current) {\n+    hasInitialized.current = true;\n+    void generateRule();\n+  }\n+\n+  // Handle form updates when generation completes\n+  useEffect(() => {\n+    if (createRuleBlockArgs && !isGenerating && !formData.rule) {\n+      reset(createRuleBlockArgs);\n+      handleRuleTypeChange(getRuleType(createRuleBlockArgs));\n+    }\n+  }, [createRuleBlockArgs, isGenerating, formData.rule, reset]);\n+\n+  const handleRuleTypeChange = (newRuleType: RuleType) => {\n+    setSelectedRuleType(newRuleType);\n+\n+    // Update alwaysApply based on rule type (false only for Agent Requested)\n+    const alwaysApply = newRuleType !== RuleType.AgentRequested;",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "2181091188",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6421,
        "pr_file": "gui/src/components/GenerateRuleDialog/GenerationScreen.tsx",
        "discussion_id": "2181091188",
        "commented_code": "@@ -0,0 +1,301 @@\n+import {\n+  createRuleMarkdown,\n+  getRuleType,\n+  RuleType,\n+  RuleTypeDescriptions,\n+} from \"@continuedev/config-yaml\";\n+import { InformationCircleIcon } from \"@heroicons/react/24/outline\";\n+import { createRuleFilePath } from \"core/config/markdown/utils\";\n+import { CreateRuleBlockArgs } from \"core/tools/implementations/createRuleBlock\";\n+import { useContext, useEffect, useRef, useState } from \"react\";\n+import { useForm } from \"react-hook-form\";\n+import { IdeMessengerContext } from \"../../context/IdeMessenger\";\n+import Spinner from \"../gui/Spinner\";\n+import { ToolTip } from \"../gui/Tooltip\";\n+import { Button } from \"../ui\";\n+import { useRuleGeneration } from \"./useRuleGeneration\";\n+\n+interface GenerationScreenProps {\n+  inputPrompt: string;\n+  onBack: () => void;\n+  onSuccess: () => void;\n+}\n+\n+export function GenerationScreen({\n+  inputPrompt,\n+  onBack,\n+  onSuccess,\n+}: GenerationScreenProps) {\n+  const ideMessenger = useContext(IdeMessengerContext);\n+\n+  const { register, watch, setValue, reset } = useForm<CreateRuleBlockArgs>({\n+    defaultValues: {\n+      name: \"\",\n+      description: \"\",\n+      globs: \"\",\n+      alwaysApply: true,\n+      rule: \"\",\n+    },\n+  });\n+\n+  const formData = watch();\n+\n+  // Track rule type separately from form data\n+  const [selectedRuleType, setSelectedRuleType] = useState<RuleType>(\n+    RuleType.Always,\n+  );\n+\n+  // Use the generation hook with the input prompt\n+  const { generateRule, isGenerating, error, createRuleBlockArgs } =\n+    useRuleGeneration(inputPrompt);\n+\n+  // Start generation once when component mounts\n+  const hasInitialized = useRef(false);\n+  if (!hasInitialized.current) {\n+    hasInitialized.current = true;\n+    void generateRule();\n+  }\n+\n+  // Handle form updates when generation completes\n+  useEffect(() => {\n+    if (createRuleBlockArgs && !isGenerating && !formData.rule) {\n+      reset(createRuleBlockArgs);\n+      handleRuleTypeChange(getRuleType(createRuleBlockArgs));\n+    }\n+  }, [createRuleBlockArgs, isGenerating, formData.rule, reset]);\n+\n+  const handleRuleTypeChange = (newRuleType: RuleType) => {\n+    setSelectedRuleType(newRuleType);\n+\n+    // Update alwaysApply based on rule type (false only for Agent Requested)\n+    const alwaysApply = newRuleType !== RuleType.AgentRequested;",
        "comment_created_at": "2025-07-02T22:32:39+00:00",
        "comment_author": "cubic-dev-ai[bot]",
        "comment_body": "<!-- metadata:{\"confidence\":8,\"steps\":[{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"GenerationScreen\\\" -n gui/src/components/GenerateRuleDialog/GenerationScreen.tsx\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n -A3 -B3 \\\"debugger;\\\" gui/src/components/GenerateRuleDialog/GenerationScreen.tsx\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -n \\\"const options: any\\\" -n gui/src/components/GenerateRuleDialog/GenerationScreen.tsx\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"cat -n gui/src/components/GenerateRuleDialog/GenerationScreen.tsx\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"file\":\"gui/src/components/GenerateRuleDialog/GenerationScreen.tsx\",\"line\":124,\"symbol\":\"createRuleFilePath\"},\"toolName\":\"goToDefinition\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"grep -R \\\"enum RuleType\\\" -n\"},\"toolName\":\"executeCommand\"}]},{\"text\":\"\",\"toolCalls\":[{\"args\":{\"command\":\"cat -n packages/config-yaml/src/markdown/getRuleType.ts\"},\"toolName\":\"executeCommand\"}]}]} -->\nManual rules should also have alwaysApply set to false, but this condition sets it to true for Manual, producing incorrect rule metadata.\n\n```suggestion\n    const alwaysApply = newRuleType === RuleType.Always || newRuleType === RuleType.AutoAttached;\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2181157187",
        "repo_full_name": "continuedev/continue",
        "pr_number": 6421,
        "pr_file": "gui/src/components/GenerateRuleDialog/GenerationScreen.tsx",
        "discussion_id": "2181091188",
        "commented_code": "@@ -0,0 +1,301 @@\n+import {\n+  createRuleMarkdown,\n+  getRuleType,\n+  RuleType,\n+  RuleTypeDescriptions,\n+} from \"@continuedev/config-yaml\";\n+import { InformationCircleIcon } from \"@heroicons/react/24/outline\";\n+import { createRuleFilePath } from \"core/config/markdown/utils\";\n+import { CreateRuleBlockArgs } from \"core/tools/implementations/createRuleBlock\";\n+import { useContext, useEffect, useRef, useState } from \"react\";\n+import { useForm } from \"react-hook-form\";\n+import { IdeMessengerContext } from \"../../context/IdeMessenger\";\n+import Spinner from \"../gui/Spinner\";\n+import { ToolTip } from \"../gui/Tooltip\";\n+import { Button } from \"../ui\";\n+import { useRuleGeneration } from \"./useRuleGeneration\";\n+\n+interface GenerationScreenProps {\n+  inputPrompt: string;\n+  onBack: () => void;\n+  onSuccess: () => void;\n+}\n+\n+export function GenerationScreen({\n+  inputPrompt,\n+  onBack,\n+  onSuccess,\n+}: GenerationScreenProps) {\n+  const ideMessenger = useContext(IdeMessengerContext);\n+\n+  const { register, watch, setValue, reset } = useForm<CreateRuleBlockArgs>({\n+    defaultValues: {\n+      name: \"\",\n+      description: \"\",\n+      globs: \"\",\n+      alwaysApply: true,\n+      rule: \"\",\n+    },\n+  });\n+\n+  const formData = watch();\n+\n+  // Track rule type separately from form data\n+  const [selectedRuleType, setSelectedRuleType] = useState<RuleType>(\n+    RuleType.Always,\n+  );\n+\n+  // Use the generation hook with the input prompt\n+  const { generateRule, isGenerating, error, createRuleBlockArgs } =\n+    useRuleGeneration(inputPrompt);\n+\n+  // Start generation once when component mounts\n+  const hasInitialized = useRef(false);\n+  if (!hasInitialized.current) {\n+    hasInitialized.current = true;\n+    void generateRule();\n+  }\n+\n+  // Handle form updates when generation completes\n+  useEffect(() => {\n+    if (createRuleBlockArgs && !isGenerating && !formData.rule) {\n+      reset(createRuleBlockArgs);\n+      handleRuleTypeChange(getRuleType(createRuleBlockArgs));\n+    }\n+  }, [createRuleBlockArgs, isGenerating, formData.rule, reset]);\n+\n+  const handleRuleTypeChange = (newRuleType: RuleType) => {\n+    setSelectedRuleType(newRuleType);\n+\n+    // Update alwaysApply based on rule type (false only for Agent Requested)\n+    const alwaysApply = newRuleType !== RuleType.AgentRequested;",
        "comment_created_at": "2025-07-02T23:38:53+00:00",
        "comment_author": "RomneyDa",
        "comment_body": "@Patrick-Erichsen is this true?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1792160899",
    "pr_number": 2493,
    "pr_file": "gui/src/context/LastSessionContext.tsx",
    "created_at": "2024-10-08T16:12:05+00:00",
    "commented_code": "+import React, { createContext, useState, useEffect } from \"react\";\n+\n+export const LastSessionContext = createContext<{\n+  lastSessionId: string | undefined;\n+  setLastSessionId: (id: string | undefined) => void;\n+}>({\n+  lastSessionId: undefined,\n+  setLastSessionId: () => {},\n+});\n+\n+export const LastSessionProvider: React.FC<{\n+  children: React.ReactNode;\n+}> = ({ children }) => {\n+  const [lastSessionId, setLastSessionId] = useState<string | undefined>();\n+\n+  useEffect(() => {\n+    const storedId = localStorage.getItem(\"lastSessionId\");",
    "repo_full_name": "continuedev/continue",
    "discussion_comments": [
      {
        "comment_id": "1792160899",
        "repo_full_name": "continuedev/continue",
        "pr_number": 2493,
        "pr_file": "gui/src/context/LastSessionContext.tsx",
        "discussion_id": "1792160899",
        "commented_code": "@@ -0,0 +1,30 @@\n+import React, { createContext, useState, useEffect } from \"react\";\n+\n+export const LastSessionContext = createContext<{\n+  lastSessionId: string | undefined;\n+  setLastSessionId: (id: string | undefined) => void;\n+}>({\n+  lastSessionId: undefined,\n+  setLastSessionId: () => {},\n+});\n+\n+export const LastSessionProvider: React.FC<{\n+  children: React.ReactNode;\n+}> = ({ children }) => {\n+  const [lastSessionId, setLastSessionId] = useState<string | undefined>();\n+\n+  useEffect(() => {\n+    const storedId = localStorage.getItem(\"lastSessionId\");",
        "comment_created_at": "2024-10-08T16:12:05+00:00",
        "comment_author": "Patrick-Erichsen",
        "comment_body": "We have a file with typings for all of our localStorage accessors: https://github.com/continuedev/continue/blob/main/gui/src/util/localStorage.ts\r\n\r\nSo I think we should add this there and update to use the `getLocalStorage` fn.",
        "pr_file_module": null
      },
      {
        "comment_id": "1792198110",
        "repo_full_name": "continuedev/continue",
        "pr_number": 2493,
        "pr_file": "gui/src/context/LastSessionContext.tsx",
        "discussion_id": "1792160899",
        "commented_code": "@@ -0,0 +1,30 @@\n+import React, { createContext, useState, useEffect } from \"react\";\n+\n+export const LastSessionContext = createContext<{\n+  lastSessionId: string | undefined;\n+  setLastSessionId: (id: string | undefined) => void;\n+}>({\n+  lastSessionId: undefined,\n+  setLastSessionId: () => {},\n+});\n+\n+export const LastSessionProvider: React.FC<{\n+  children: React.ReactNode;\n+}> = ({ children }) => {\n+  const [lastSessionId, setLastSessionId] = useState<string | undefined>();\n+\n+  useEffect(() => {\n+    const storedId = localStorage.getItem(\"lastSessionId\");",
        "comment_created_at": "2024-10-08T16:40:10+00:00",
        "comment_author": "tomasz-stefaniak",
        "comment_body": "This code actually wasn't needed. Removed it \ud83d\udc4c ",
        "pr_file_module": null
      }
    ]
  }
]