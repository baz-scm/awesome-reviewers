[
  {
    "discussion_id": "2039112864",
    "pr_number": 136947,
    "pr_file": "homeassistant/components/redgtech/coordinator.py",
    "created_at": "2025-04-11T08:54:31+00:00",
    "commented_code": "+import logging\n+import aiohttp\n+from datetime import timedelta\n+from typing import List, Optional\n+from dataclasses import dataclass\n+from homeassistant.core import HomeAssistant\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import STATE_ON, STATE_OFF, CONF_ACCESS_TOKEN\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api import RedgtechAPI\n+from .const import DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+_LOGGER.debug(\"Coordinator for Redgtech is being initialized.\")\n+\n+@dataclass\n+class RedgtechDevice:\n+    \"\"\"Representation of a Redgtech device.\"\"\"\n+    id: str\n+    name: str\n+    state: str\n+    device_type: str = \"switch\"\n+\n+class RedgtechDataUpdateCoordinator(DataUpdateCoordinator [List[RedgtechDevice]]):\n+    \"\"\"Coordinator to manage fetching data from the Redgtech API.\"\"\"\n+\n+    def __init__(self, hass: HomeAssistant, config_entry: Optional[ConfigEntry] = None):\n+        \"\"\"Initialize the coordinator.\"\"\"\n+        self.api = RedgtechAPI()\n+        self.access_token = config_entry.data[CONF_ACCESS_TOKEN] if config_entry else None\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=5),",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2039112864",
        "repo_full_name": "home-assistant/core",
        "pr_number": 136947,
        "pr_file": "homeassistant/components/redgtech/coordinator.py",
        "discussion_id": "2039112864",
        "commented_code": "@@ -0,0 +1,77 @@\n+import logging\n+import aiohttp\n+from datetime import timedelta\n+from typing import List, Optional\n+from dataclasses import dataclass\n+from homeassistant.core import HomeAssistant\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import STATE_ON, STATE_OFF, CONF_ACCESS_TOKEN\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api import RedgtechAPI\n+from .const import DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+_LOGGER.debug(\"Coordinator for Redgtech is being initialized.\")\n+\n+@dataclass\n+class RedgtechDevice:\n+    \"\"\"Representation of a Redgtech device.\"\"\"\n+    id: str\n+    name: str\n+    state: str\n+    device_type: str = \"switch\"\n+\n+class RedgtechDataUpdateCoordinator(DataUpdateCoordinator [List[RedgtechDevice]]):\n+    \"\"\"Coordinator to manage fetching data from the Redgtech API.\"\"\"\n+\n+    def __init__(self, hass: HomeAssistant, config_entry: Optional[ConfigEntry] = None):\n+        \"\"\"Initialize the coordinator.\"\"\"\n+        self.api = RedgtechAPI()\n+        self.access_token = config_entry.data[CONF_ACCESS_TOKEN] if config_entry else None\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=5),",
        "comment_created_at": "2025-04-11T08:54:31+00:00",
        "comment_author": "zweckj",
        "comment_body": "do we really need to query the api this often?",
        "pr_file_module": null
      },
      {
        "comment_id": "2042696937",
        "repo_full_name": "home-assistant/core",
        "pr_number": 136947,
        "pr_file": "homeassistant/components/redgtech/coordinator.py",
        "discussion_id": "2039112864",
        "commented_code": "@@ -0,0 +1,77 @@\n+import logging\n+import aiohttp\n+from datetime import timedelta\n+from typing import List, Optional\n+from dataclasses import dataclass\n+from homeassistant.core import HomeAssistant\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import STATE_ON, STATE_OFF, CONF_ACCESS_TOKEN\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api import RedgtechAPI\n+from .const import DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+_LOGGER.debug(\"Coordinator for Redgtech is being initialized.\")\n+\n+@dataclass\n+class RedgtechDevice:\n+    \"\"\"Representation of a Redgtech device.\"\"\"\n+    id: str\n+    name: str\n+    state: str\n+    device_type: str = \"switch\"\n+\n+class RedgtechDataUpdateCoordinator(DataUpdateCoordinator [List[RedgtechDevice]]):\n+    \"\"\"Coordinator to manage fetching data from the Redgtech API.\"\"\"\n+\n+    def __init__(self, hass: HomeAssistant, config_entry: Optional[ConfigEntry] = None):\n+        \"\"\"Initialize the coordinator.\"\"\"\n+        self.api = RedgtechAPI()\n+        self.access_token = config_entry.data[CONF_ACCESS_TOKEN] if config_entry else None\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=5),",
        "comment_created_at": "2025-04-14T18:32:13+00:00",
        "comment_author": "Jonhsady",
        "comment_body": "\r\nActually I don't think so, I think I'll apply updates on demand",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163119813",
    "pr_number": 142994,
    "pr_file": "homeassistant/components/volvo/coordinator.py",
    "created_at": "2025-06-24T07:01:16+00:00",
    "commented_code": "+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValue,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+type VolvoConfigEntry = ConfigEntry[tuple[VolvoBaseCoordinator, ...]]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoBaseCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo base coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+    vehicle: VolvoCarsVehicle\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+        update_interval: timedelta,\n+        name: str,\n+        api_calls: list[str],\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=name,\n+            update_interval=update_interval,\n+        )\n+\n+        self.api = api\n+        self.vehicle = vehicle\n+        self._api_calls = api_calls\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+\n+        if not api_calls:\n+            return data\n+\n+        valid = False\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.debug(\n+                    \"%s - Authentication failed. %s\",\n+                    self.config_entry.entry_id,\n+                    result.message,\n+                )\n+                raise ConfigEntryAuthFailed(\n+                    f\"Authentication failed. {result.message}\"\n+                ) from result\n+\n+            if isinstance(result, VolvoApiException):\n+                # Maybe it's just one call that fails. Log the error and\n+                # continue processing the other calls.\n+                _LOGGER.debug(\n+                    \"%s - Error during data update: %s\",\n+                    self.config_entry.entry_id,\n+                    result.message,\n+                )\n+                exception = exception or result\n+                continue\n+\n+            if isinstance(result, Exception):\n+                # Something bad happened, raise immediately.\n+                raise UpdateFailed(\n+                    translation_domain=DOMAIN,\n+                    translation_key=\"update_failed\",\n+                ) from result\n+\n+            data |= cast(CoordinatorData, result)\n+            valid = True\n+\n+        # Raise an error if not a single API call succeeded\n+        if not valid:\n+            raise UpdateFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"update_failed\",\n+            ) from exception\n+\n+        return data\n+\n+    def get_api_field(self, api_field: str | None) -> VolvoCarsApiBaseModel | None:\n+        \"\"\"Get the API field based on the entity description.\"\"\"\n+\n+        return self.data.get(api_field) if api_field else None\n+\n+    def _get_api_calls(\n+        self,\n+    ) -> list[Callable[[], Coroutine[Any, Any, Any]]]:\n+        return [\n+            api_call\n+            for key, (api_call, condition) in self._refresh_conditions.items()\n+            if condition and key in self._api_calls\n+        ]\n+\n+\n+class VolvoVerySlowIntervalCoordinator(VolvoBaseCoordinator):\n+    \"\"\"Volvo coordinator with very slow update rate.\"\"\"\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            entry,\n+            api,\n+            vehicle,\n+            timedelta(minutes=60),\n+            \"Volvo very slow interval coordinator\",\n+            [\"diagnostics\", \"odometer\", \"statistics\"],\n+        )\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        data = await super()._async_update_data()\n+\n+        # Add static values\n+        if self.vehicle.has_battery_engine():\n+            data[DATA_BATTERY_CAPACITY] = VolvoCarsValue.from_dict(\n+                {\n+                    \"value\": self.vehicle.battery_capacity_kwh,\n+                }\n+            )\n+\n+        return data\n+\n+\n+class VolvoSlowIntervalCoordinator(VolvoBaseCoordinator):\n+    \"\"\"Volvo coordinator with slow update rate.\"\"\"\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            entry,\n+            api,\n+            vehicle,\n+            timedelta(minutes=15),",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2163119813",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2163119813",
        "commented_code": "@@ -0,0 +1,236 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValue,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+type VolvoConfigEntry = ConfigEntry[tuple[VolvoBaseCoordinator, ...]]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoBaseCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo base coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+    vehicle: VolvoCarsVehicle\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+        update_interval: timedelta,\n+        name: str,\n+        api_calls: list[str],\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=name,\n+            update_interval=update_interval,\n+        )\n+\n+        self.api = api\n+        self.vehicle = vehicle\n+        self._api_calls = api_calls\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+\n+        if not api_calls:\n+            return data\n+\n+        valid = False\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.debug(\n+                    \"%s - Authentication failed. %s\",\n+                    self.config_entry.entry_id,\n+                    result.message,\n+                )\n+                raise ConfigEntryAuthFailed(\n+                    f\"Authentication failed. {result.message}\"\n+                ) from result\n+\n+            if isinstance(result, VolvoApiException):\n+                # Maybe it's just one call that fails. Log the error and\n+                # continue processing the other calls.\n+                _LOGGER.debug(\n+                    \"%s - Error during data update: %s\",\n+                    self.config_entry.entry_id,\n+                    result.message,\n+                )\n+                exception = exception or result\n+                continue\n+\n+            if isinstance(result, Exception):\n+                # Something bad happened, raise immediately.\n+                raise UpdateFailed(\n+                    translation_domain=DOMAIN,\n+                    translation_key=\"update_failed\",\n+                ) from result\n+\n+            data |= cast(CoordinatorData, result)\n+            valid = True\n+\n+        # Raise an error if not a single API call succeeded\n+        if not valid:\n+            raise UpdateFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"update_failed\",\n+            ) from exception\n+\n+        return data\n+\n+    def get_api_field(self, api_field: str | None) -> VolvoCarsApiBaseModel | None:\n+        \"\"\"Get the API field based on the entity description.\"\"\"\n+\n+        return self.data.get(api_field) if api_field else None\n+\n+    def _get_api_calls(\n+        self,\n+    ) -> list[Callable[[], Coroutine[Any, Any, Any]]]:\n+        return [\n+            api_call\n+            for key, (api_call, condition) in self._refresh_conditions.items()\n+            if condition and key in self._api_calls\n+        ]\n+\n+\n+class VolvoVerySlowIntervalCoordinator(VolvoBaseCoordinator):\n+    \"\"\"Volvo coordinator with very slow update rate.\"\"\"\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            entry,\n+            api,\n+            vehicle,\n+            timedelta(minutes=60),\n+            \"Volvo very slow interval coordinator\",\n+            [\"diagnostics\", \"odometer\", \"statistics\"],\n+        )\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        data = await super()._async_update_data()\n+\n+        # Add static values\n+        if self.vehicle.has_battery_engine():\n+            data[DATA_BATTERY_CAPACITY] = VolvoCarsValue.from_dict(\n+                {\n+                    \"value\": self.vehicle.battery_capacity_kwh,\n+                }\n+            )\n+\n+        return data\n+\n+\n+class VolvoSlowIntervalCoordinator(VolvoBaseCoordinator):\n+    \"\"\"Volvo coordinator with slow update rate.\"\"\"\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            entry,\n+            api,\n+            vehicle,\n+            timedelta(minutes=15),",
        "comment_created_at": "2025-06-24T07:01:16+00:00",
        "comment_author": "zweckj",
        "comment_body": "with the current setup arent't you doing two overlapping API calls every 30, and 3 overlapping calls every 60 minutes? To my understanding your calls are limited here, aren't they?",
        "pr_file_module": null
      },
      {
        "comment_id": "2164649241",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2163119813",
        "commented_code": "@@ -0,0 +1,236 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValue,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+type VolvoConfigEntry = ConfigEntry[tuple[VolvoBaseCoordinator, ...]]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoBaseCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo base coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+    vehicle: VolvoCarsVehicle\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+        update_interval: timedelta,\n+        name: str,\n+        api_calls: list[str],\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=name,\n+            update_interval=update_interval,\n+        )\n+\n+        self.api = api\n+        self.vehicle = vehicle\n+        self._api_calls = api_calls\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+\n+        if not api_calls:\n+            return data\n+\n+        valid = False\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.debug(\n+                    \"%s - Authentication failed. %s\",\n+                    self.config_entry.entry_id,\n+                    result.message,\n+                )\n+                raise ConfigEntryAuthFailed(\n+                    f\"Authentication failed. {result.message}\"\n+                ) from result\n+\n+            if isinstance(result, VolvoApiException):\n+                # Maybe it's just one call that fails. Log the error and\n+                # continue processing the other calls.\n+                _LOGGER.debug(\n+                    \"%s - Error during data update: %s\",\n+                    self.config_entry.entry_id,\n+                    result.message,\n+                )\n+                exception = exception or result\n+                continue\n+\n+            if isinstance(result, Exception):\n+                # Something bad happened, raise immediately.\n+                raise UpdateFailed(\n+                    translation_domain=DOMAIN,\n+                    translation_key=\"update_failed\",\n+                ) from result\n+\n+            data |= cast(CoordinatorData, result)\n+            valid = True\n+\n+        # Raise an error if not a single API call succeeded\n+        if not valid:\n+            raise UpdateFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"update_failed\",\n+            ) from exception\n+\n+        return data\n+\n+    def get_api_field(self, api_field: str | None) -> VolvoCarsApiBaseModel | None:\n+        \"\"\"Get the API field based on the entity description.\"\"\"\n+\n+        return self.data.get(api_field) if api_field else None\n+\n+    def _get_api_calls(\n+        self,\n+    ) -> list[Callable[[], Coroutine[Any, Any, Any]]]:\n+        return [\n+            api_call\n+            for key, (api_call, condition) in self._refresh_conditions.items()\n+            if condition and key in self._api_calls\n+        ]\n+\n+\n+class VolvoVerySlowIntervalCoordinator(VolvoBaseCoordinator):\n+    \"\"\"Volvo coordinator with very slow update rate.\"\"\"\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            entry,\n+            api,\n+            vehicle,\n+            timedelta(minutes=60),\n+            \"Volvo very slow interval coordinator\",\n+            [\"diagnostics\", \"odometer\", \"statistics\"],\n+        )\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        data = await super()._async_update_data()\n+\n+        # Add static values\n+        if self.vehicle.has_battery_engine():\n+            data[DATA_BATTERY_CAPACITY] = VolvoCarsValue.from_dict(\n+                {\n+                    \"value\": self.vehicle.battery_capacity_kwh,\n+                }\n+            )\n+\n+        return data\n+\n+\n+class VolvoSlowIntervalCoordinator(VolvoBaseCoordinator):\n+    \"\"\"Volvo coordinator with slow update rate.\"\"\"\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+        vehicle: VolvoCarsVehicle,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            entry,\n+            api,\n+            vehicle,\n+            timedelta(minutes=15),",
        "comment_created_at": "2025-06-24T18:29:15+00:00",
        "comment_author": "thomasddn",
        "comment_body": "Each coordinator will do at least one API call, but most of the time more than one. These API calls fetch different data, so in the end they all need to be refreshed once in a while. The limitation of API calls is on a daily basis, and having multiple calls executing simultaneously is OK.\r\n\r\nIn fact, before we had several coordinators, all API calls were done simultaneously already with `asyncio.gather`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2001021108",
    "pr_number": 139925,
    "pr_file": "homeassistant/components/fluss/button.py",
    "created_at": "2025-03-18T13:14:48+00:00",
    "commented_code": "+\"\"\"Support for Fluss Devices.\"\"\"\n+\n+import logging\n+\n+from fluss_api.main import FlussApiClient\n+\n+from homeassistant.components.button import ButtonEntity\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback\n+\n+LOGGER = logging.getLogger(__package__)\n+DEFAULT_NAME = \"Fluss +\"\n+\n+\n+async def async_setup_entry(\n+    hass: HomeAssistant,\n+    entry: ConfigEntry,\n+    async_add_entities: AddConfigEntryEntitiesCallback,\n+) -> None:\n+    \"\"\"Set up the Fluss Devices.\"\"\"\n+\n+    api: FlussApiClient = entry.runtime_data\n+\n+    devices_data = await api.async_get_devices()\n+    devices = devices_data[\"devices\"]",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2001021108",
        "repo_full_name": "home-assistant/core",
        "pr_number": 139925,
        "pr_file": "homeassistant/components/fluss/button.py",
        "discussion_id": "2001021108",
        "commented_code": "@@ -0,0 +1,53 @@\n+\"\"\"Support for Fluss Devices.\"\"\"\n+\n+import logging\n+\n+from fluss_api.main import FlussApiClient\n+\n+from homeassistant.components.button import ButtonEntity\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback\n+\n+LOGGER = logging.getLogger(__package__)\n+DEFAULT_NAME = \"Fluss +\"\n+\n+\n+async def async_setup_entry(\n+    hass: HomeAssistant,\n+    entry: ConfigEntry,\n+    async_add_entities: AddConfigEntryEntitiesCallback,\n+) -> None:\n+    \"\"\"Set up the Fluss Devices.\"\"\"\n+\n+    api: FlussApiClient = entry.runtime_data\n+\n+    devices_data = await api.async_get_devices()\n+    devices = devices_data[\"devices\"]",
        "comment_created_at": "2025-03-18T13:14:48+00:00",
        "comment_author": "zweckj",
        "comment_body": "Rather implement a coordinator and do that in `_async_setup` there. Since it looks like a general update endpoint per device this will also future proof you for future platforms",
        "pr_file_module": null
      },
      {
        "comment_id": "2012068689",
        "repo_full_name": "home-assistant/core",
        "pr_number": 139925,
        "pr_file": "homeassistant/components/fluss/button.py",
        "discussion_id": "2001021108",
        "commented_code": "@@ -0,0 +1,53 @@\n+\"\"\"Support for Fluss Devices.\"\"\"\n+\n+import logging\n+\n+from fluss_api.main import FlussApiClient\n+\n+from homeassistant.components.button import ButtonEntity\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.helpers.entity_platform import AddConfigEntryEntitiesCallback\n+\n+LOGGER = logging.getLogger(__package__)\n+DEFAULT_NAME = \"Fluss +\"\n+\n+\n+async def async_setup_entry(\n+    hass: HomeAssistant,\n+    entry: ConfigEntry,\n+    async_add_entities: AddConfigEntryEntitiesCallback,\n+) -> None:\n+    \"\"\"Set up the Fluss Devices.\"\"\"\n+\n+    api: FlussApiClient = entry.runtime_data\n+\n+    devices_data = await api.async_get_devices()\n+    devices = devices_data[\"devices\"]",
        "comment_created_at": "2025-03-25T13:14:03+00:00",
        "comment_author": "Marcello17",
        "comment_body": "Good to know thanks, implement a solution",
        "pr_file_module": null
      }
    ]
  }
]