[
  {
    "discussion_id": "2147457221",
    "pr_number": 13478,
    "pr_file": "packages/runtime-core/src/renderer.ts",
    "created_at": "2025-06-15T06:35:38+00:00",
    "commented_code": "optimized,\n       )\n     } else {\n-      patchElement(\n-        n1,\n-        n2,\n-        parentComponent,\n-        parentSuspense,\n-        namespace,\n-        slotScopeIds,\n-        optimized,\n-      )\n+      if (n1.el && (n1.el as VueElement)._isVueCE) {\n+        ;(n1.el as VueElement)._beginPatch()\n+      }\n+      try {\n+        patchElement(\n+          n1,\n+          n2,\n+          parentComponent,\n+          parentSuspense,\n+          namespace,\n+          slotScopeIds,\n+          optimized,\n+        )\n+      } finally {\n+        if (n1.el && (n1.el as VueElement)._isVueCE) {\n+          ;(n1.el as VueElement)._endPatch()\n+        }\n+      }",
    "repo_full_name": "vuejs/core",
    "discussion_comments": [
      {
        "comment_id": "2147457221",
        "repo_full_name": "vuejs/core",
        "pr_number": 13478,
        "pr_file": "packages/runtime-core/src/renderer.ts",
        "discussion_id": "2147457221",
        "commented_code": "@@ -621,15 +621,24 @@ function baseCreateRenderer(\n         optimized,\n       )\n     } else {\n-      patchElement(\n-        n1,\n-        n2,\n-        parentComponent,\n-        parentSuspense,\n-        namespace,\n-        slotScopeIds,\n-        optimized,\n-      )\n+      if (n1.el && (n1.el as VueElement)._isVueCE) {\n+        ;(n1.el as VueElement)._beginPatch()\n+      }\n+      try {\n+        patchElement(\n+          n1,\n+          n2,\n+          parentComponent,\n+          parentSuspense,\n+          namespace,\n+          slotScopeIds,\n+          optimized,\n+        )\n+      } finally {\n+        if (n1.el && (n1.el as VueElement)._isVueCE) {\n+          ;(n1.el as VueElement)._endPatch()\n+        }\n+      }",
        "comment_created_at": "2025-06-15T06:35:38+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**Guarantee `_endPatch()` even if `_beginPatch()` throws**  \n\n`_beginPatch()` is invoked outside the `try` block. If it unexpectedly throws, `_endPatch()` will be skipped and the custom element will remain in a permanent \u201cpatching\u201d state, breaking subsequent updates.\n\nA safer pattern is to call `_beginPatch()` inside the `try` and cache the boolean so the `finally` block can always balance it:\n\n```diff\n-      if (n1.el && (n1.el as VueElement)._isVueCE) {\n-        ;(n1.el as VueElement)._beginPatch()\n-      }\n-      try {\n+      const isVueCE = !!(n1.el && (n1.el as any)._isVueCE)\n+      try {\n+        if (isVueCE) {\n+          ;(n1.el as VueElement)._beginPatch()\n+        }\n         patchElement(\n@@\n-      } finally {\n-        if (n1.el && (n1.el as VueElement)._isVueCE) {\n-          ;(n1.el as VueElement)._endPatch()\n-        }\n-      }\n+      } finally {\n+        if (isVueCE) {\n+          ;(n1.el as VueElement)._endPatch()\n+        }\n+      }\n```\n\nThis also avoids multiple casts and clarifies intent.  \n\n\n\n<!-- suggestion_start -->\n\n<details>\n<summary>\ud83d\udcdd Committable suggestion</summary>\n\n> \u203c\ufe0f **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n      const isVueCE = !!(n1.el && (n1.el as any)._isVueCE)\n      try {\n        if (isVueCE) {\n          ;(n1.el as VueElement)._beginPatch()\n        }\n        patchElement(\n          n1,\n          n2,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized,\n        )\n      } finally {\n        if (isVueCE) {\n          ;(n1.el as VueElement)._endPatch()\n        }\n      }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>\ud83e\udd16 Prompt for AI Agents</summary>\n\n```\nIn packages/runtime-core/src/renderer.ts around lines 624 to 641, move the call\nto _beginPatch() inside the try block and store its result in a boolean\nvariable. Then, in the finally block, check this boolean to decide whether to\ncall _endPatch(). This ensures _endPatch() is always called even if\n_beginPatch() throws, preventing the custom element from remaining in a\npermanent patching state. Also, reduce repeated casting by caching the element\nreference.\n```\n\n</details>\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n\u2705 Addressed in commit f695bc3",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2083404395",
    "pr_number": 13208,
    "pr_file": "packages/runtime-dom/src/apiCustomElement.ts",
    "created_at": "2025-05-11T05:28:47+00:00",
    "commented_code": "private _renderSlots() {\n     const outlets = (this._teleportTarget || this).querySelectorAll('slot')\n     const scopeId = this._instance!.type.__scopeId\n+    this._slotAnchors = new Map()\n+    const processedSlots = new Set<string>()\n+\n     for (let i = 0; i < outlets.length; i++) {\n       const o = outlets[i] as HTMLSlotElement\n       const slotName = o.getAttribute('name') || 'default'\n+      processedSlots.add(slotName)\n       const content = this._slots![slotName]\n       const parent = o.parentNode!\n+\n+      // insert an anchor to facilitate updates\n+      const anchor = document.createTextNode('')\n+      this._slotAnchors.set(slotName, anchor)\n+      parent.insertBefore(anchor, o)\n+\n       if (content) {\n-        for (const n of content) {\n-          // for :slotted css\n-          if (scopeId && n.nodeType === 1) {\n-            const id = scopeId + '-s'\n-            const walker = document.createTreeWalker(n, 1)\n-            ;(n as Element).setAttribute(id, '')\n-            let child\n-            while ((child = walker.nextNode())) {\n-              ;(child as Element).setAttribute(id, '')\n-            }\n+        insertSlottedContent(content, scopeId, parent, anchor)\n+      } else if (this._slotFallbacks) {\n+        const nodes = this._slotFallbacks[slotName]\n+        if (nodes) {\n+          for (const n of nodes) {\n+            parent.insertBefore(n, anchor)\n           }\n-          parent.insertBefore(n, o)\n         }\n-      } else {\n-        while (o.firstChild) parent.insertBefore(o.firstChild, o)\n       }\n       parent.removeChild(o)\n     }\n+\n+    // ensure default slot content is rendered if provided\n+    if (!processedSlots.has('default')) {\n+      let content = this._slots!['default']\n+      if (content) {\n+        insertSlottedContent(content, scopeId, this, this.firstChild)\n+      }\n+    }\n+  }",
    "repo_full_name": "vuejs/core",
    "discussion_comments": [
      {
        "comment_id": "2083404395",
        "repo_full_name": "vuejs/core",
        "pr_number": 13208,
        "pr_file": "packages/runtime-dom/src/apiCustomElement.ts",
        "discussion_id": "2083404395",
        "commented_code": "@@ -631,30 +647,112 @@ export class VueElement\n   private _renderSlots() {\n     const outlets = (this._teleportTarget || this).querySelectorAll('slot')\n     const scopeId = this._instance!.type.__scopeId\n+    this._slotAnchors = new Map()\n+    const processedSlots = new Set<string>()\n+\n     for (let i = 0; i < outlets.length; i++) {\n       const o = outlets[i] as HTMLSlotElement\n       const slotName = o.getAttribute('name') || 'default'\n+      processedSlots.add(slotName)\n       const content = this._slots![slotName]\n       const parent = o.parentNode!\n+\n+      // insert an anchor to facilitate updates\n+      const anchor = document.createTextNode('')\n+      this._slotAnchors.set(slotName, anchor)\n+      parent.insertBefore(anchor, o)\n+\n       if (content) {\n-        for (const n of content) {\n-          // for :slotted css\n-          if (scopeId && n.nodeType === 1) {\n-            const id = scopeId + '-s'\n-            const walker = document.createTreeWalker(n, 1)\n-            ;(n as Element).setAttribute(id, '')\n-            let child\n-            while ((child = walker.nextNode())) {\n-              ;(child as Element).setAttribute(id, '')\n-            }\n+        insertSlottedContent(content, scopeId, parent, anchor)\n+      } else if (this._slotFallbacks) {\n+        const nodes = this._slotFallbacks[slotName]\n+        if (nodes) {\n+          for (const n of nodes) {\n+            parent.insertBefore(n, anchor)\n           }\n-          parent.insertBefore(n, o)\n         }\n-      } else {\n-        while (o.firstChild) parent.insertBefore(o.firstChild, o)\n       }\n       parent.removeChild(o)\n     }\n+\n+    // ensure default slot content is rendered if provided\n+    if (!processedSlots.has('default')) {\n+      let content = this._slots!['default']\n+      if (content) {\n+        insertSlottedContent(content, scopeId, this, this.firstChild)\n+      }\n+    }\n+  }",
        "comment_created_at": "2025-05-11T05:28:47+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\u26a0\ufe0f Potential issue_\n\n**`_slotAnchors` is re-initialised every render \u2013 later fallback insertions may fail**\n\n`_renderSlots` resets `this._slotAnchors = new Map()` even when no `<slot>` elements remain in the DOM (typical after first pass).  \nSubsequent calls to `_updateSlots` rely on previously stored anchors to insert fallback nodes, leading to a `undefined` lookup and a crash for sequences like:\n\n1. Slot provided \u279c fallback removed\n2. Slot removed \u279c fallback re-inserted (requires anchor)\n\nSolution: only create the map once, or preserve existing anchors when no outlets are found:\n\n```diff\n-    this._slotAnchors = new Map()\n+    if (!this._slotAnchors) this._slotAnchors = new Map()\n```\n\nand clear it explicitly in `disconnectedCallback` (already done).\n\n<!-- This is an auto-generated comment by CodeRabbit -->\n\n\u2705 Addressed in commit 2d7e5af",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "711071702",
    "pr_number": 4619,
    "pr_file": "packages/runtime-core/src/apiCreateApp.ts",
    "created_at": "2021-09-17T13:47:54+00:00",
    "commented_code": "unmount() {\n         if (isMounted) {\n           render(null, app._container)\n+          pluginCleanupFns.map(fn => fn())",
    "repo_full_name": "vuejs/core",
    "discussion_comments": [
      {
        "comment_id": "711071702",
        "repo_full_name": "vuejs/core",
        "pr_number": 4619,
        "pr_file": "packages/runtime-core/src/apiCreateApp.ts",
        "discussion_id": "711071702",
        "commented_code": "@@ -323,6 +332,7 @@ export function createAppAPI<HostElement>(\n       unmount() {\n         if (isMounted) {\n           render(null, app._container)\n+          pluginCleanupFns.map(fn => fn())",
        "comment_created_at": "2021-09-17T13:47:54+00:00",
        "comment_author": "edison1105",
        "comment_body": "Does it need to be wrapped in `try catch`? if `fn()` throw an exception, the following code will not be executed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1697040264",
    "pr_number": 7265,
    "pr_file": "packages/reactivity/src/effectScope.ts",
    "created_at": "2024-07-30T14:12:07+00:00",
    "commented_code": "*/\n export function onScopeDispose(fn: () => void) {\n   if (activeEffectScope) {\n-    activeEffectScope.cleanups.push(fn)\n+    activeEffectScope.cleanups.push(() => {\n+      try {\n+        fn()\n+      } catch (e) {\n+        console.error(\n+          'An error occurred while executing a cleanup function:',\n+          e,\n+        )",
    "repo_full_name": "vuejs/core",
    "discussion_comments": [
      {
        "comment_id": "1697040264",
        "repo_full_name": "vuejs/core",
        "pr_number": 7265,
        "pr_file": "packages/reactivity/src/effectScope.ts",
        "discussion_id": "1697040264",
        "commented_code": "@@ -147,7 +149,16 @@ export function getCurrentScope() {\n  */\n export function onScopeDispose(fn: () => void) {\n   if (activeEffectScope) {\n-    activeEffectScope.cleanups.push(fn)\n+    activeEffectScope.cleanups.push(() => {\n+      try {\n+        fn()\n+      } catch (e) {\n+        console.error(\n+          'An error occurred while executing a cleanup function:',\n+          e,\n+        )",
        "comment_created_at": "2024-07-30T14:12:07+00:00",
        "comment_author": "skirtles-code",
        "comment_body": "This isn't what I had in mind when I suggested handling the error cases. I just meant putting the `resetTracking()` call in a `finally` block to ensure it always gets called. Perhaps there are more complete ways to handle errors, but that feels like it's out of scope for the tracking changes being proposed in this PR.\r\n\r\nThere are a couple of problems with the error handling being proposed here:\r\n\r\n1. This error message would be included in production builds, impacting bundle size. Error messages generally aren't included in production builds.\r\n2. Catching the errors will prevent them being handled by `app.config.errorHandler`.\r\n\r\nFor example, consider this Playground:\r\n\r\n- [Playground - `main`](https://play.vuejs.org/#eNp9UsFu2zAM/RVCO9gBAuWwnQon2NYF2HbYirZHXVyVSZTakiBRTYAg/15KrpO0KHowIL33SL9H6iD61li5jeJKmN67QHAAHbAl/OE9HGEVXA/Vc8JK2VdBJgZYzlrv5UAqq52NBIzA/Nyi5m+S2axkxcqsJYbgwu/WPnYYWFtLKduwjhOYL+CgLEDu5DqUnVvX1TKrYTPIqykUqbLHsWnvkqW6+sLnaiKm4tUSB2qiDsYTRKTkFyf/B8DVCjXdaedxCs6Wwy8TvYv4LvKYKmYJe72orNlEgWVItq7P7t82vGQAaBPcDizuoMSqK8JIFXcCOOZQ/DWzwTYb5gth7zseJd8AmodE5Cx8153RT3Mlhv9Hcp7diMV1hpvZoOKKZnYq58EQq8v8t9FZHk+xpIR2vTc82v+eDGdV4mo0q0TbdW73t2AUEk5HXG9QP32Ab+M+Y0rcBIwYnlGJE0e8OKSBXt79wz2fT2TvHlPH6k/IW+Q3kbLHQfYzlRdxoStu/5QlG7u+j8s9oY1jqGy0zLnoleAFX38S/Wz3q/xW6ng94vgCmoITDQ==)\r\n\r\nNotice that clicking the button triggers the `errorHandler`. Contrast that with how it behaves with this PR:\r\n\r\n- [Playground - this PR](https://deploy-preview-7265--vue-sfc-playground.netlify.app/#eNp9UsFu2zAM/RVCO9gBAuWwnQon2NYF2HbYirZHXVyVSZTakiBRTYAg/15KrpO0KHowIL33SL9H6iD61li5jeJKmN67QHAAHbAl/OE9HGEVXA/Vc8JK2VdBJgZYzlrv5UAqq52NBIzA/Nyi5m+S2axkxcqsJYbgwu/WPnYYWFtLKduwjhOYL+CgLEDu5DqUnVvX1TKrYTPIqykUqbLHsWnvkqW6+sLnaiKm4tUSB2qiDsYTRKTkFyf/B8DVCjXdaedxCs6Wwy8TvYv4LvKYKmYJe72orNlEgWVItq7P7t82vGQAaBPcDizuoMSqK8JIFXcCOOZQ/DWzwTYb5gth7zseJd8AmodE5Cx8153RT3Mlhv9Hcp7diMV1hpvZoOKKZnYq58EQq8v8t9FZHk+xpIR2vTc82v+eDGdV4mo0q0TbdW73t2AUEk5HXG9QP32Ab+M+Y0rcBIwYnlGJE0e8OKSBXt79wz2fT2TvHlPH6k/IW+Q3kbLHQfYzlRdxoStu/5QlG7u+j8s9oY1jqGy0zLnoleAFX38S/Wz3q/xW6ng94vgCmoITDQ==)\r\n\r\nI don't think this is desirable.",
        "pr_file_module": null
      },
      {
        "comment_id": "1722642852",
        "repo_full_name": "vuejs/core",
        "pr_number": 7265,
        "pr_file": "packages/reactivity/src/effectScope.ts",
        "discussion_id": "1697040264",
        "commented_code": "@@ -147,7 +149,16 @@ export function getCurrentScope() {\n  */\n export function onScopeDispose(fn: () => void) {\n   if (activeEffectScope) {\n-    activeEffectScope.cleanups.push(fn)\n+    activeEffectScope.cleanups.push(() => {\n+      try {\n+        fn()\n+      } catch (e) {\n+        console.error(\n+          'An error occurred while executing a cleanup function:',\n+          e,\n+        )",
        "comment_created_at": "2024-08-20T03:35:43+00:00",
        "comment_author": "edison1105",
        "comment_body": "I agree with @skirtles-code.\r\n",
        "pr_file_module": null
      }
    ]
  }
]