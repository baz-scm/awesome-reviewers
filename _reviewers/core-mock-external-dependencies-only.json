[
  {
    "discussion_id": "2092464296",
    "pr_number": 136947,
    "pr_file": "tests/components/redgtech/test_switch.py",
    "created_at": "2025-05-16T07:07:17+00:00",
    "commented_code": "+\"\"\"Test Redgtech switch platform.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.switch import DOMAIN as SWITCH_DOMAIN\n+from homeassistant.components.redgtech.switch import RedgtechSwitch\n+from homeassistant.components.redgtech.const import DOMAIN\n+from homeassistant.const import CONF_EMAIL, CONF_PASSWORD, STATE_ON, STATE_OFF, Platform\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api.api import RedgtechConnectionError\n+from tests.common import MockConfigEntry\n+\n+\n+@pytest.fixture\n+def mock_device():\n+    \"\"\"Return a mocked Redgtech device.\"\"\"\n+    device = MagicMock()\n+    device.id = \"1234-5678\"\n+    device.name = \"Test Switch\"\n+    device.state = STATE_OFF\n+    return device\n+\n+\n+@pytest.fixture\n+def mock_coordinator(mock_device):\n+    \"\"\"Return a mocked RedgtechDataUpdateCoordinator.\"\"\"\n+    coordinator = AsyncMock()\n+    coordinator.data = [mock_device]\n+    coordinator.api = AsyncMock()\n+    coordinator.api.set_switch_state = AsyncMock()\n+    coordinator.access_token = \"test_access_token\"\n+    return coordinator",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2092464296",
        "repo_full_name": "home-assistant/core",
        "pr_number": 136947,
        "pr_file": "tests/components/redgtech/test_switch.py",
        "discussion_id": "2092464296",
        "commented_code": "@@ -0,0 +1,116 @@\n+\"\"\"Test Redgtech switch platform.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.switch import DOMAIN as SWITCH_DOMAIN\n+from homeassistant.components.redgtech.switch import RedgtechSwitch\n+from homeassistant.components.redgtech.const import DOMAIN\n+from homeassistant.const import CONF_EMAIL, CONF_PASSWORD, STATE_ON, STATE_OFF, Platform\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api.api import RedgtechConnectionError\n+from tests.common import MockConfigEntry\n+\n+\n+@pytest.fixture\n+def mock_device():\n+    \"\"\"Return a mocked Redgtech device.\"\"\"\n+    device = MagicMock()\n+    device.id = \"1234-5678\"\n+    device.name = \"Test Switch\"\n+    device.state = STATE_OFF\n+    return device\n+\n+\n+@pytest.fixture\n+def mock_coordinator(mock_device):\n+    \"\"\"Return a mocked RedgtechDataUpdateCoordinator.\"\"\"\n+    coordinator = AsyncMock()\n+    coordinator.data = [mock_device]\n+    coordinator.api = AsyncMock()\n+    coordinator.api.set_switch_state = AsyncMock()\n+    coordinator.access_token = \"test_access_token\"\n+    return coordinator",
        "comment_created_at": "2025-05-16T07:07:17+00:00",
        "comment_author": "zweckj",
        "comment_body": "I already told you last time: don't mock home assistant internals, instead mock the objects from your library you need to work",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2125767493",
    "pr_number": 136947,
    "pr_file": "tests/components/redgtech/test_switch.py",
    "created_at": "2025-06-04T06:38:15+00:00",
    "commented_code": "+\"\"\"Teste da plataforma switch Redgtech.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.switch import DOMAIN as SWITCH_DOMAIN\n+from homeassistant.components.redgtech.switch import RedgtechSwitch\n+from homeassistant.components.redgtech.const import DOMAIN\n+from homeassistant.const import CONF_EMAIL, CONF_PASSWORD, STATE_ON, STATE_OFF, Platform\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api.api import RedgtechConnectionError\n+from tests.common import MockConfigEntry\n+from homeassistant.helpers import entity_registry as er\n+from homeassistant.helpers.entity_platform import async_get_platforms\n+from homeassistant.helpers import device_registry as dr\n+\n+\n+@pytest.fixture\n+def mock_device():\n+    \"\"\"Cria um dispositivo simulado.\"\"\"\n+    device = MagicMock()\n+    device.id = \"1234-5678\"\n+    device.name = \"Teste Interruptor\"\n+    device.state = STATE_OFF\n+    return device\n+\n+\n+@pytest.fixture\n+def mock_coordinator(mock_device):\n+    \"\"\"Cria um coordenador simulado.\"\"\"\n+    coordinator = AsyncMock()\n+    coordinator.data = [mock_device]\n+    coordinator.api = AsyncMock()\n+    coordinator.api.set_switch_state = AsyncMock()\n+    coordinator.access_token = \"token_teste\"\n+    coordinator.email = \"teste@exemplo.com\"\n+    coordinator.password = \"senha123\"\n+    return coordinator",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2125767493",
        "repo_full_name": "home-assistant/core",
        "pr_number": 136947,
        "pr_file": "tests/components/redgtech/test_switch.py",
        "discussion_id": "2125767493",
        "commented_code": "@@ -0,0 +1,128 @@\n+\"\"\"Teste da plataforma switch Redgtech.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.switch import DOMAIN as SWITCH_DOMAIN\n+from homeassistant.components.redgtech.switch import RedgtechSwitch\n+from homeassistant.components.redgtech.const import DOMAIN\n+from homeassistant.const import CONF_EMAIL, CONF_PASSWORD, STATE_ON, STATE_OFF, Platform\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api.api import RedgtechConnectionError\n+from tests.common import MockConfigEntry\n+from homeassistant.helpers import entity_registry as er\n+from homeassistant.helpers.entity_platform import async_get_platforms\n+from homeassistant.helpers import device_registry as dr\n+\n+\n+@pytest.fixture\n+def mock_device():\n+    \"\"\"Cria um dispositivo simulado.\"\"\"\n+    device = MagicMock()\n+    device.id = \"1234-5678\"\n+    device.name = \"Teste Interruptor\"\n+    device.state = STATE_OFF\n+    return device\n+\n+\n+@pytest.fixture\n+def mock_coordinator(mock_device):\n+    \"\"\"Cria um coordenador simulado.\"\"\"\n+    coordinator = AsyncMock()\n+    coordinator.data = [mock_device]\n+    coordinator.api = AsyncMock()\n+    coordinator.api.set_switch_state = AsyncMock()\n+    coordinator.access_token = \"token_teste\"\n+    coordinator.email = \"teste@exemplo.com\"\n+    coordinator.password = \"senha123\"\n+    return coordinator",
        "comment_created_at": "2025-06-04T06:38:15+00:00",
        "comment_author": "zweckj",
        "comment_body": "don't mock the coordinator, mock your API instead (with a fixture)",
        "pr_file_module": null
      },
      {
        "comment_id": "2175613161",
        "repo_full_name": "home-assistant/core",
        "pr_number": 136947,
        "pr_file": "tests/components/redgtech/test_switch.py",
        "discussion_id": "2125767493",
        "commented_code": "@@ -0,0 +1,128 @@\n+\"\"\"Teste da plataforma switch Redgtech.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.switch import DOMAIN as SWITCH_DOMAIN\n+from homeassistant.components.redgtech.switch import RedgtechSwitch\n+from homeassistant.components.redgtech.const import DOMAIN\n+from homeassistant.const import CONF_EMAIL, CONF_PASSWORD, STATE_ON, STATE_OFF, Platform\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import HomeAssistantError\n+from redgtech_api.api import RedgtechConnectionError\n+from tests.common import MockConfigEntry\n+from homeassistant.helpers import entity_registry as er\n+from homeassistant.helpers.entity_platform import async_get_platforms\n+from homeassistant.helpers import device_registry as dr\n+\n+\n+@pytest.fixture\n+def mock_device():\n+    \"\"\"Cria um dispositivo simulado.\"\"\"\n+    device = MagicMock()\n+    device.id = \"1234-5678\"\n+    device.name = \"Teste Interruptor\"\n+    device.state = STATE_OFF\n+    return device\n+\n+\n+@pytest.fixture\n+def mock_coordinator(mock_device):\n+    \"\"\"Cria um coordenador simulado.\"\"\"\n+    coordinator = AsyncMock()\n+    coordinator.data = [mock_device]\n+    coordinator.api = AsyncMock()\n+    coordinator.api.set_switch_state = AsyncMock()\n+    coordinator.access_token = \"token_teste\"\n+    coordinator.email = \"teste@exemplo.com\"\n+    coordinator.password = \"senha123\"\n+    return coordinator",
        "comment_created_at": "2025-06-30T17:57:43+00:00",
        "comment_author": "Jonhsady",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2115996539",
    "pr_number": 142994,
    "pr_file": "tests/components/volvo/test_coordinator.py",
    "created_at": "2025-05-30T14:05:21+00:00",
    "commented_code": "+\"\"\"Test Volvo coordinator.\"\"\"\n+\n+from unittest.mock import AsyncMock\n+\n+import pytest\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoApiException, VolvoAuthException\n+\n+from homeassistant.components.volvo.coordinator import VolvoDataCoordinator\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.update_coordinator import UpdateFailed\n+\n+from tests.common import MockConfigEntry\n+\n+\n+async def test_setup_coordinator_auth_failure(",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2115996539",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "tests/components/volvo/test_coordinator.py",
        "discussion_id": "2115996539",
        "commented_code": "@@ -0,0 +1,94 @@\n+\"\"\"Test Volvo coordinator.\"\"\"\n+\n+from unittest.mock import AsyncMock\n+\n+import pytest\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoApiException, VolvoAuthException\n+\n+from homeassistant.components.volvo.coordinator import VolvoDataCoordinator\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.update_coordinator import UpdateFailed\n+\n+from tests.common import MockConfigEntry\n+\n+\n+async def test_setup_coordinator_auth_failure(",
        "comment_created_at": "2025-05-30T14:05:21+00:00",
        "comment_author": "gjohansson-ST",
        "comment_body": "We normally avoid testing internal things like the coordinator own methods but instead just asserting entity state etc when a coordinator fails to setup or refresh.\r\nYou can take a look at `nordpool` for a simple example.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162445906",
    "pr_number": 142994,
    "pr_file": "tests/components/volvo/test_coordinator.py",
    "created_at": "2025-06-23T20:09:24+00:00",
    "commented_code": "+\"\"\"Test Volvo coordinator.\"\"\"\n+\n+from collections.abc import Awaitable, Callable\n+from datetime import timedelta\n+from unittest.mock import AsyncMock\n+\n+from freezegun.api import FrozenDateTimeFactory\n+import pytest\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoApiException, VolvoAuthException\n+\n+from homeassistant.components.volvo.coordinator import (\n+    VolvoBaseCoordinator,\n+    VolvoVerySlowIntervalCoordinator,\n+)\n+from homeassistant.const import STATE_UNAVAILABLE\n+from homeassistant.core import HomeAssistant\n+\n+from .common import configure_mock\n+\n+from tests.common import MockConfigEntry, async_fire_time_changed\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_coordinator_update(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_config_entry: MockConfigEntry,\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test coordinator update with errors.\"\"\"\n+    assert await setup_integration()\n+\n+    sensor_id = \"sensor.volvo_xc40_odometer\"\n+    coordinators: tuple[VolvoBaseCoordinator] = mock_config_entry.runtime_data\n+    coordinator = next(\n+        c for c in coordinators if isinstance(c, VolvoVerySlowIntervalCoordinator)\n+    )\n+\n+    interval = timedelta(seconds=coordinator.update_interval.total_seconds() + 5)\n+    original_value = coordinator._refresh_conditions[\"odometer\"][0].return_value\n+    mock_method: AsyncMock = mock_api.async_get_odometer\n+\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoApiException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoAuthException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    # Explicitly refresh to recover from auth failure\n+    await coordinator.async_refresh()\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=Exception())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_update_coordinator_all_error(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test API returning error for all calls during coordinator update.\"\"\"\n+    assert await setup_integration()\n+\n+    _mock_api_failure(mock_api)\n+    freezer.tick(timedelta(minutes=65))\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    for state in hass.states.async_all():\n+        assert state.state == STATE_UNAVAILABLE\n+\n+\n+def _mock_api_failure(mock_api: VolvoCarsApi) -> AsyncMock:\n+    \"\"\"Mock the Volvo API so that it raises an exception for all calls.\"\"\"\n+\n+    mock_api.async_get_brakes_status.side_effect = VolvoApiException()\n+    mock_api.async_get_command_accessibility.side_effect = VolvoApiException()\n+    mock_api.async_get_commands.side_effect = VolvoApiException()\n+    mock_api.async_get_diagnostics.side_effect = VolvoApiException()\n+    mock_api.async_get_doors_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_fuel_status.side_effect = VolvoApiException()\n+    mock_api.async_get_location.side_effect = VolvoApiException()\n+    mock_api.async_get_odometer.side_effect = VolvoApiException()\n+    mock_api.async_get_recharge_status.side_effect = VolvoApiException()\n+    mock_api.async_get_statistics.side_effect = VolvoApiException()\n+    mock_api.async_get_tyre_states.side_effect = VolvoApiException()\n+    mock_api.async_get_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_window_states.side_effect = VolvoApiException()\n+\n+    return mock_api",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2162445906",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "tests/components/volvo/test_coordinator.py",
        "discussion_id": "2162445906",
        "commented_code": "@@ -0,0 +1,133 @@\n+\"\"\"Test Volvo coordinator.\"\"\"\n+\n+from collections.abc import Awaitable, Callable\n+from datetime import timedelta\n+from unittest.mock import AsyncMock\n+\n+from freezegun.api import FrozenDateTimeFactory\n+import pytest\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoApiException, VolvoAuthException\n+\n+from homeassistant.components.volvo.coordinator import (\n+    VolvoBaseCoordinator,\n+    VolvoVerySlowIntervalCoordinator,\n+)\n+from homeassistant.const import STATE_UNAVAILABLE\n+from homeassistant.core import HomeAssistant\n+\n+from .common import configure_mock\n+\n+from tests.common import MockConfigEntry, async_fire_time_changed\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_coordinator_update(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_config_entry: MockConfigEntry,\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test coordinator update with errors.\"\"\"\n+    assert await setup_integration()\n+\n+    sensor_id = \"sensor.volvo_xc40_odometer\"\n+    coordinators: tuple[VolvoBaseCoordinator] = mock_config_entry.runtime_data\n+    coordinator = next(\n+        c for c in coordinators if isinstance(c, VolvoVerySlowIntervalCoordinator)\n+    )\n+\n+    interval = timedelta(seconds=coordinator.update_interval.total_seconds() + 5)\n+    original_value = coordinator._refresh_conditions[\"odometer\"][0].return_value\n+    mock_method: AsyncMock = mock_api.async_get_odometer\n+\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoApiException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoAuthException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    # Explicitly refresh to recover from auth failure\n+    await coordinator.async_refresh()\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=Exception())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_update_coordinator_all_error(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test API returning error for all calls during coordinator update.\"\"\"\n+    assert await setup_integration()\n+\n+    _mock_api_failure(mock_api)\n+    freezer.tick(timedelta(minutes=65))\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    for state in hass.states.async_all():\n+        assert state.state == STATE_UNAVAILABLE\n+\n+\n+def _mock_api_failure(mock_api: VolvoCarsApi) -> AsyncMock:\n+    \"\"\"Mock the Volvo API so that it raises an exception for all calls.\"\"\"\n+\n+    mock_api.async_get_brakes_status.side_effect = VolvoApiException()\n+    mock_api.async_get_command_accessibility.side_effect = VolvoApiException()\n+    mock_api.async_get_commands.side_effect = VolvoApiException()\n+    mock_api.async_get_diagnostics.side_effect = VolvoApiException()\n+    mock_api.async_get_doors_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_fuel_status.side_effect = VolvoApiException()\n+    mock_api.async_get_location.side_effect = VolvoApiException()\n+    mock_api.async_get_odometer.side_effect = VolvoApiException()\n+    mock_api.async_get_recharge_status.side_effect = VolvoApiException()\n+    mock_api.async_get_statistics.side_effect = VolvoApiException()\n+    mock_api.async_get_tyre_states.side_effect = VolvoApiException()\n+    mock_api.async_get_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_window_states.side_effect = VolvoApiException()\n+\n+    return mock_api",
        "comment_created_at": "2025-06-23T20:09:24+00:00",
        "comment_author": "joostlek",
        "comment_body": "We should not touch internals like entry.runtime_data, instead we should check the behavior of the entities that are attached",
        "pr_file_module": null
      },
      {
        "comment_id": "2164615941",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "tests/components/volvo/test_coordinator.py",
        "discussion_id": "2162445906",
        "commented_code": "@@ -0,0 +1,133 @@\n+\"\"\"Test Volvo coordinator.\"\"\"\n+\n+from collections.abc import Awaitable, Callable\n+from datetime import timedelta\n+from unittest.mock import AsyncMock\n+\n+from freezegun.api import FrozenDateTimeFactory\n+import pytest\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoApiException, VolvoAuthException\n+\n+from homeassistant.components.volvo.coordinator import (\n+    VolvoBaseCoordinator,\n+    VolvoVerySlowIntervalCoordinator,\n+)\n+from homeassistant.const import STATE_UNAVAILABLE\n+from homeassistant.core import HomeAssistant\n+\n+from .common import configure_mock\n+\n+from tests.common import MockConfigEntry, async_fire_time_changed\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_coordinator_update(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_config_entry: MockConfigEntry,\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test coordinator update with errors.\"\"\"\n+    assert await setup_integration()\n+\n+    sensor_id = \"sensor.volvo_xc40_odometer\"\n+    coordinators: tuple[VolvoBaseCoordinator] = mock_config_entry.runtime_data\n+    coordinator = next(\n+        c for c in coordinators if isinstance(c, VolvoVerySlowIntervalCoordinator)\n+    )\n+\n+    interval = timedelta(seconds=coordinator.update_interval.total_seconds() + 5)\n+    original_value = coordinator._refresh_conditions[\"odometer\"][0].return_value\n+    mock_method: AsyncMock = mock_api.async_get_odometer\n+\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoApiException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoAuthException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    # Explicitly refresh to recover from auth failure\n+    await coordinator.async_refresh()\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=Exception())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_update_coordinator_all_error(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test API returning error for all calls during coordinator update.\"\"\"\n+    assert await setup_integration()\n+\n+    _mock_api_failure(mock_api)\n+    freezer.tick(timedelta(minutes=65))\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    for state in hass.states.async_all():\n+        assert state.state == STATE_UNAVAILABLE\n+\n+\n+def _mock_api_failure(mock_api: VolvoCarsApi) -> AsyncMock:\n+    \"\"\"Mock the Volvo API so that it raises an exception for all calls.\"\"\"\n+\n+    mock_api.async_get_brakes_status.side_effect = VolvoApiException()\n+    mock_api.async_get_command_accessibility.side_effect = VolvoApiException()\n+    mock_api.async_get_commands.side_effect = VolvoApiException()\n+    mock_api.async_get_diagnostics.side_effect = VolvoApiException()\n+    mock_api.async_get_doors_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_fuel_status.side_effect = VolvoApiException()\n+    mock_api.async_get_location.side_effect = VolvoApiException()\n+    mock_api.async_get_odometer.side_effect = VolvoApiException()\n+    mock_api.async_get_recharge_status.side_effect = VolvoApiException()\n+    mock_api.async_get_statistics.side_effect = VolvoApiException()\n+    mock_api.async_get_tyre_states.side_effect = VolvoApiException()\n+    mock_api.async_get_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_window_states.side_effect = VolvoApiException()\n+\n+    return mock_api",
        "comment_created_at": "2025-06-24T18:11:00+00:00",
        "comment_author": "thomasddn",
        "comment_body": "Do you mean that I should not test the coordinator directly, but instead have tests in a test_[platform].py that would simulate failures in the coordinator?",
        "pr_file_module": null
      },
      {
        "comment_id": "2167289527",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "tests/components/volvo/test_coordinator.py",
        "discussion_id": "2162445906",
        "commented_code": "@@ -0,0 +1,133 @@\n+\"\"\"Test Volvo coordinator.\"\"\"\n+\n+from collections.abc import Awaitable, Callable\n+from datetime import timedelta\n+from unittest.mock import AsyncMock\n+\n+from freezegun.api import FrozenDateTimeFactory\n+import pytest\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoApiException, VolvoAuthException\n+\n+from homeassistant.components.volvo.coordinator import (\n+    VolvoBaseCoordinator,\n+    VolvoVerySlowIntervalCoordinator,\n+)\n+from homeassistant.const import STATE_UNAVAILABLE\n+from homeassistant.core import HomeAssistant\n+\n+from .common import configure_mock\n+\n+from tests.common import MockConfigEntry, async_fire_time_changed\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_coordinator_update(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_config_entry: MockConfigEntry,\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test coordinator update with errors.\"\"\"\n+    assert await setup_integration()\n+\n+    sensor_id = \"sensor.volvo_xc40_odometer\"\n+    coordinators: tuple[VolvoBaseCoordinator] = mock_config_entry.runtime_data\n+    coordinator = next(\n+        c for c in coordinators if isinstance(c, VolvoVerySlowIntervalCoordinator)\n+    )\n+\n+    interval = timedelta(seconds=coordinator.update_interval.total_seconds() + 5)\n+    original_value = coordinator._refresh_conditions[\"odometer\"][0].return_value\n+    mock_method: AsyncMock = mock_api.async_get_odometer\n+\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoApiException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=VolvoAuthException())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    # Explicitly refresh to recover from auth failure\n+    await coordinator.async_refresh()\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+    configure_mock(mock_method, return_value=None, side_effect=Exception())\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == STATE_UNAVAILABLE\n+\n+    configure_mock(mock_method, return_value=original_value, side_effect=None)\n+    freezer.tick(interval)\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    assert mock_method.call_count == 1\n+    state = hass.states.get(sensor_id)\n+    assert state.state == \"30000\"\n+\n+\n+@pytest.mark.freeze_time(\"2025-05-31T10:00:00+00:00\")\n+async def test_update_coordinator_all_error(\n+    hass: HomeAssistant,\n+    freezer: FrozenDateTimeFactory,\n+    setup_integration: Callable[[], Awaitable[bool]],\n+    mock_api: VolvoCarsApi,\n+) -> None:\n+    \"\"\"Test API returning error for all calls during coordinator update.\"\"\"\n+    assert await setup_integration()\n+\n+    _mock_api_failure(mock_api)\n+    freezer.tick(timedelta(minutes=65))\n+    async_fire_time_changed(hass)\n+    await hass.async_block_till_done(wait_background_tasks=True)\n+    for state in hass.states.async_all():\n+        assert state.state == STATE_UNAVAILABLE\n+\n+\n+def _mock_api_failure(mock_api: VolvoCarsApi) -> AsyncMock:\n+    \"\"\"Mock the Volvo API so that it raises an exception for all calls.\"\"\"\n+\n+    mock_api.async_get_brakes_status.side_effect = VolvoApiException()\n+    mock_api.async_get_command_accessibility.side_effect = VolvoApiException()\n+    mock_api.async_get_commands.side_effect = VolvoApiException()\n+    mock_api.async_get_diagnostics.side_effect = VolvoApiException()\n+    mock_api.async_get_doors_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_status.side_effect = VolvoApiException()\n+    mock_api.async_get_engine_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_fuel_status.side_effect = VolvoApiException()\n+    mock_api.async_get_location.side_effect = VolvoApiException()\n+    mock_api.async_get_odometer.side_effect = VolvoApiException()\n+    mock_api.async_get_recharge_status.side_effect = VolvoApiException()\n+    mock_api.async_get_statistics.side_effect = VolvoApiException()\n+    mock_api.async_get_tyre_states.side_effect = VolvoApiException()\n+    mock_api.async_get_warnings.side_effect = VolvoApiException()\n+    mock_api.async_get_window_states.side_effect = VolvoApiException()\n+\n+    return mock_api",
        "comment_created_at": "2025-06-25T17:50:56+00:00",
        "comment_author": "gjohansson-ST",
        "comment_body": "I think we should leave this test intact for coordinator explicit tests but we should remove the internals (line 36 etc. ) and just use the contants or whatever to reference the refresh times.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2190139428",
    "pr_number": 148275,
    "pr_file": "tests/components/velux/test_binary_sensor.py",
    "created_at": "2025-07-07T13:37:59+00:00",
    "commented_code": "+\"\"\"Tests for the Velux rain sensor binary_sensor platform.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock\n+\n+import pytest\n+from pyvlx.exception import PyVLXException\n+\n+from homeassistant.components.velux.binary_sensor import VeluxRainSensor\n+\n+\n+@pytest.fixture\n+def mock_window():\n+    \"\"\"Return a mock Velux window with a rain sensor.\"\"\"\n+    node = MagicMock(spec=[\"name\", \"rain_sensor\", \"get_limitation\", \"serial_number\"])\n+    node.name = \"Test Window\"\n+    node.rain_sensor = True\n+    node.serial_number = \"1234567890\"\n+    return node\n+\n+\n+@pytest.fixture\n+def mock_limitation_rain():\n+    \"\"\"Return a mock limitation object indicating rain detected.\"\"\"\n+    limitation = MagicMock()\n+    limitation.max_value = 100\n+    limitation.min_value = 93\n+    return limitation\n+\n+\n+@pytest.fixture\n+def mock_limitation_dry():\n+    \"\"\"Return a mock limitation object indicating no rain.\"\"\"\n+    limitation = MagicMock()\n+    limitation.max_value = 100\n+    limitation.min_value = 0\n+    return limitation\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_detected(mock_window, mock_limitation_rain) -> None:\n+    \"\"\"Test VeluxRainSensor is_on is True when rain is detected.\"\"\"\n+    mock_window.get_limitation = AsyncMock(return_value=mock_limitation_rain)\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    assert sensor.is_on is True\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_not_detected(mock_window, mock_limitation_dry) -> None:\n+    \"\"\"Test VeluxRainSensor is_on is False when rain is not detected.\"\"\"\n+    mock_window.get_limitation = AsyncMock(return_value=mock_limitation_dry)\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    assert sensor.is_on is False\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_update_error(mock_window) -> None:\n+    \"\"\"Test VeluxRainSensor handles PyVLXException gracefully.\"\"\"\n+\n+    mock_window.get_limitation = AsyncMock(side_effect=PyVLXException(\"Test error\"))\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    # Should remain default (False)\n+    assert sensor.is_on is False\n+\n+\n+def test_unique_id_and_name(mock_window) -> None:\n+    \"\"\"Test unique_id and name are set correctly.\"\"\"\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    assert sensor._attr_unique_id.endswith(\"_rain_sensor\")\n+    assert sensor._attr_name == \"Test Window Rain Sensor\"",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2190139428",
        "repo_full_name": "home-assistant/core",
        "pr_number": 148275,
        "pr_file": "tests/components/velux/test_binary_sensor.py",
        "discussion_id": "2190139428",
        "commented_code": "@@ -0,0 +1,72 @@\n+\"\"\"Tests for the Velux rain sensor binary_sensor platform.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock\n+\n+import pytest\n+from pyvlx.exception import PyVLXException\n+\n+from homeassistant.components.velux.binary_sensor import VeluxRainSensor\n+\n+\n+@pytest.fixture\n+def mock_window():\n+    \"\"\"Return a mock Velux window with a rain sensor.\"\"\"\n+    node = MagicMock(spec=[\"name\", \"rain_sensor\", \"get_limitation\", \"serial_number\"])\n+    node.name = \"Test Window\"\n+    node.rain_sensor = True\n+    node.serial_number = \"1234567890\"\n+    return node\n+\n+\n+@pytest.fixture\n+def mock_limitation_rain():\n+    \"\"\"Return a mock limitation object indicating rain detected.\"\"\"\n+    limitation = MagicMock()\n+    limitation.max_value = 100\n+    limitation.min_value = 93\n+    return limitation\n+\n+\n+@pytest.fixture\n+def mock_limitation_dry():\n+    \"\"\"Return a mock limitation object indicating no rain.\"\"\"\n+    limitation = MagicMock()\n+    limitation.max_value = 100\n+    limitation.min_value = 0\n+    return limitation\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_detected(mock_window, mock_limitation_rain) -> None:\n+    \"\"\"Test VeluxRainSensor is_on is True when rain is detected.\"\"\"\n+    mock_window.get_limitation = AsyncMock(return_value=mock_limitation_rain)\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    assert sensor.is_on is True\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_not_detected(mock_window, mock_limitation_dry) -> None:\n+    \"\"\"Test VeluxRainSensor is_on is False when rain is not detected.\"\"\"\n+    mock_window.get_limitation = AsyncMock(return_value=mock_limitation_dry)\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    assert sensor.is_on is False\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_update_error(mock_window) -> None:\n+    \"\"\"Test VeluxRainSensor handles PyVLXException gracefully.\"\"\"\n+\n+    mock_window.get_limitation = AsyncMock(side_effect=PyVLXException(\"Test error\"))\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    # Should remain default (False)\n+    assert sensor.is_on is False\n+\n+\n+def test_unique_id_and_name(mock_window) -> None:\n+    \"\"\"Test unique_id and name are set correctly.\"\"\"\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    assert sensor._attr_unique_id.endswith(\"_rain_sensor\")\n+    assert sensor._attr_name == \"Test Window Rain Sensor\"",
        "comment_created_at": "2025-07-07T13:37:59+00:00",
        "comment_author": "joostlek",
        "comment_body": "We don't want to create entities manually in the tests. Instead, mock out the library and have the test setup the integration and then observe the entity via the state machine or the entity registry",
        "pr_file_module": null
      },
      {
        "comment_id": "2202067005",
        "repo_full_name": "home-assistant/core",
        "pr_number": 148275,
        "pr_file": "tests/components/velux/test_binary_sensor.py",
        "discussion_id": "2190139428",
        "commented_code": "@@ -0,0 +1,72 @@\n+\"\"\"Tests for the Velux rain sensor binary_sensor platform.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock\n+\n+import pytest\n+from pyvlx.exception import PyVLXException\n+\n+from homeassistant.components.velux.binary_sensor import VeluxRainSensor\n+\n+\n+@pytest.fixture\n+def mock_window():\n+    \"\"\"Return a mock Velux window with a rain sensor.\"\"\"\n+    node = MagicMock(spec=[\"name\", \"rain_sensor\", \"get_limitation\", \"serial_number\"])\n+    node.name = \"Test Window\"\n+    node.rain_sensor = True\n+    node.serial_number = \"1234567890\"\n+    return node\n+\n+\n+@pytest.fixture\n+def mock_limitation_rain():\n+    \"\"\"Return a mock limitation object indicating rain detected.\"\"\"\n+    limitation = MagicMock()\n+    limitation.max_value = 100\n+    limitation.min_value = 93\n+    return limitation\n+\n+\n+@pytest.fixture\n+def mock_limitation_dry():\n+    \"\"\"Return a mock limitation object indicating no rain.\"\"\"\n+    limitation = MagicMock()\n+    limitation.max_value = 100\n+    limitation.min_value = 0\n+    return limitation\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_detected(mock_window, mock_limitation_rain) -> None:\n+    \"\"\"Test VeluxRainSensor is_on is True when rain is detected.\"\"\"\n+    mock_window.get_limitation = AsyncMock(return_value=mock_limitation_rain)\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    assert sensor.is_on is True\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_not_detected(mock_window, mock_limitation_dry) -> None:\n+    \"\"\"Test VeluxRainSensor is_on is False when rain is not detected.\"\"\"\n+    mock_window.get_limitation = AsyncMock(return_value=mock_limitation_dry)\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    assert sensor.is_on is False\n+\n+\n+@pytest.mark.asyncio\n+async def test_rain_sensor_update_error(mock_window) -> None:\n+    \"\"\"Test VeluxRainSensor handles PyVLXException gracefully.\"\"\"\n+\n+    mock_window.get_limitation = AsyncMock(side_effect=PyVLXException(\"Test error\"))\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    await sensor.async_update()\n+    # Should remain default (False)\n+    assert sensor.is_on is False\n+\n+\n+def test_unique_id_and_name(mock_window) -> None:\n+    \"\"\"Test unique_id and name are set correctly.\"\"\"\n+    sensor = VeluxRainSensor(mock_window, \"test_entry_id\")\n+    assert sensor._attr_unique_id.endswith(\"_rain_sensor\")\n+    assert sensor._attr_name == \"Test Window Rain Sensor\"",
        "comment_created_at": "2025-07-11T23:44:15+00:00",
        "comment_author": "wollew",
        "comment_body": "Well, it took me an embarrasingly long time to figure out why my entity was available in the entity registry but not in the state machine (it is disabled by default :D), but now I finally reworked the tests. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2116548484",
    "pr_number": 144292,
    "pr_file": "tests/components/zimi/common.py",
    "created_at": "2025-05-30T19:52:44+00:00",
    "commented_code": "+\"\"\"Common items for testing the zimi component.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+from homeassistant.components.zimi.const import DOMAIN\n+from homeassistant.const import CONF_HOST, CONF_PORT\n+from homeassistant.core import HomeAssistant\n+from homeassistant.setup import async_setup_component\n+\n+from tests.common import MockConfigEntry\n+\n+DEVICE_INFO = {\n+    \"id\": \"test-device-id\",\n+    \"name\": \"unknown\",\n+    \"manufacturer\": \"Zimi\",\n+    \"model\": \"Controller XYZ\",\n+    \"hwVersion\": \"2.2.2\",\n+    \"fwVersion\": \"3.3.3\",\n+}\n+\n+ENTITY_INFO = {\n+    \"id\": \"test-entity-id\",\n+    \"name\": \"Test Entity Name\",\n+    \"room\": \"Test Entity Room\",\n+    \"type\": \"unknown\",\n+}\n+\n+INPUT_HOST = \"192.168.1.100\"\n+INPUT_PORT = 5003\n+\n+\n+async def check_states(\n+    hass: HomeAssistant,\n+    entity_type: str,\n+    entity_key: str,\n+) -> None:\n+    \"\"\"Check that the entity states exist.\"\"\"\n+\n+    state = hass.states.get(entity_key)\n+    assert state is not None\n+    assert state.entity_id == entity_key\n+\n+\n+async def check_toggle(\n+    hass: HomeAssistant,\n+    entity_type: str,\n+    entity_key: str,\n+    mock_device: MagicMock,\n+    entity_type_override: str | None = None,\n+    turn_on_override: AsyncMock | None = None,\n+    turn_off_override: AsyncMock | None = None,\n+) -> None:\n+    \"\"\"Check that the entity can be toggled on and off.\n+\n+    Allows for override of default entity_type and turn_on and turn_off.\n+    \"\"\"\n+\n+    services = hass.services.async_services()\n+\n+    assert \"turn_on\" in services[entity_type_override or entity_type]\n+\n+    await hass.services.async_call(\n+        entity_type_override or entity_type,\n+        \"turn_on\",\n+        {\"entity_id\": entity_key},\n+        blocking=True,\n+    )\n+\n+    if turn_on_override:\n+        assert turn_on_override.called\n+    else:\n+        assert mock_device.turn_on.called\n+\n+    assert \"turn_off\" in services[entity_type_override or entity_type]\n+\n+    await hass.services.async_call(",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2116548484",
        "repo_full_name": "home-assistant/core",
        "pr_number": 144292,
        "pr_file": "tests/components/zimi/common.py",
        "discussion_id": "2116548484",
        "commented_code": "@@ -0,0 +1,143 @@\n+\"\"\"Common items for testing the zimi component.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+from homeassistant.components.zimi.const import DOMAIN\n+from homeassistant.const import CONF_HOST, CONF_PORT\n+from homeassistant.core import HomeAssistant\n+from homeassistant.setup import async_setup_component\n+\n+from tests.common import MockConfigEntry\n+\n+DEVICE_INFO = {\n+    \"id\": \"test-device-id\",\n+    \"name\": \"unknown\",\n+    \"manufacturer\": \"Zimi\",\n+    \"model\": \"Controller XYZ\",\n+    \"hwVersion\": \"2.2.2\",\n+    \"fwVersion\": \"3.3.3\",\n+}\n+\n+ENTITY_INFO = {\n+    \"id\": \"test-entity-id\",\n+    \"name\": \"Test Entity Name\",\n+    \"room\": \"Test Entity Room\",\n+    \"type\": \"unknown\",\n+}\n+\n+INPUT_HOST = \"192.168.1.100\"\n+INPUT_PORT = 5003\n+\n+\n+async def check_states(\n+    hass: HomeAssistant,\n+    entity_type: str,\n+    entity_key: str,\n+) -> None:\n+    \"\"\"Check that the entity states exist.\"\"\"\n+\n+    state = hass.states.get(entity_key)\n+    assert state is not None\n+    assert state.entity_id == entity_key\n+\n+\n+async def check_toggle(\n+    hass: HomeAssistant,\n+    entity_type: str,\n+    entity_key: str,\n+    mock_device: MagicMock,\n+    entity_type_override: str | None = None,\n+    turn_on_override: AsyncMock | None = None,\n+    turn_off_override: AsyncMock | None = None,\n+) -> None:\n+    \"\"\"Check that the entity can be toggled on and off.\n+\n+    Allows for override of default entity_type and turn_on and turn_off.\n+    \"\"\"\n+\n+    services = hass.services.async_services()\n+\n+    assert \"turn_on\" in services[entity_type_override or entity_type]\n+\n+    await hass.services.async_call(\n+        entity_type_override or entity_type,\n+        \"turn_on\",\n+        {\"entity_id\": entity_key},\n+        blocking=True,\n+    )\n+\n+    if turn_on_override:\n+        assert turn_on_override.called\n+    else:\n+        assert mock_device.turn_on.called\n+\n+    assert \"turn_off\" in services[entity_type_override or entity_type]\n+\n+    await hass.services.async_call(",
        "comment_created_at": "2025-05-30T19:52:44+00:00",
        "comment_author": "zweckj",
        "comment_body": "just move those service calls to the actual tests, in tests we like to have it more explicit",
        "pr_file_module": null
      },
      {
        "comment_id": "2218060545",
        "repo_full_name": "home-assistant/core",
        "pr_number": 144292,
        "pr_file": "tests/components/zimi/common.py",
        "discussion_id": "2116548484",
        "commented_code": "@@ -0,0 +1,143 @@\n+\"\"\"Common items for testing the zimi component.\"\"\"\n+\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+from homeassistant.components.zimi.const import DOMAIN\n+from homeassistant.const import CONF_HOST, CONF_PORT\n+from homeassistant.core import HomeAssistant\n+from homeassistant.setup import async_setup_component\n+\n+from tests.common import MockConfigEntry\n+\n+DEVICE_INFO = {\n+    \"id\": \"test-device-id\",\n+    \"name\": \"unknown\",\n+    \"manufacturer\": \"Zimi\",\n+    \"model\": \"Controller XYZ\",\n+    \"hwVersion\": \"2.2.2\",\n+    \"fwVersion\": \"3.3.3\",\n+}\n+\n+ENTITY_INFO = {\n+    \"id\": \"test-entity-id\",\n+    \"name\": \"Test Entity Name\",\n+    \"room\": \"Test Entity Room\",\n+    \"type\": \"unknown\",\n+}\n+\n+INPUT_HOST = \"192.168.1.100\"\n+INPUT_PORT = 5003\n+\n+\n+async def check_states(\n+    hass: HomeAssistant,\n+    entity_type: str,\n+    entity_key: str,\n+) -> None:\n+    \"\"\"Check that the entity states exist.\"\"\"\n+\n+    state = hass.states.get(entity_key)\n+    assert state is not None\n+    assert state.entity_id == entity_key\n+\n+\n+async def check_toggle(\n+    hass: HomeAssistant,\n+    entity_type: str,\n+    entity_key: str,\n+    mock_device: MagicMock,\n+    entity_type_override: str | None = None,\n+    turn_on_override: AsyncMock | None = None,\n+    turn_off_override: AsyncMock | None = None,\n+) -> None:\n+    \"\"\"Check that the entity can be toggled on and off.\n+\n+    Allows for override of default entity_type and turn_on and turn_off.\n+    \"\"\"\n+\n+    services = hass.services.async_services()\n+\n+    assert \"turn_on\" in services[entity_type_override or entity_type]\n+\n+    await hass.services.async_call(\n+        entity_type_override or entity_type,\n+        \"turn_on\",\n+        {\"entity_id\": entity_key},\n+        blocking=True,\n+    )\n+\n+    if turn_on_override:\n+        assert turn_on_override.called\n+    else:\n+        assert mock_device.turn_on.called\n+\n+    assert \"turn_off\" in services[entity_type_override or entity_type]\n+\n+    await hass.services.async_call(",
        "comment_created_at": "2025-07-21T01:45:20+00:00",
        "comment_author": "markhannon",
        "comment_body": "https://github.com/home-assistant/core/pull/144292/commits/3b57bde05d4c0e3d3b760627f542e11f3be67bb6",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2209751763",
    "pr_number": 139925,
    "pr_file": "tests/components/fluss/test_button.py",
    "created_at": "2025-07-16T09:09:28+00:00",
    "commented_code": "+\"\"\"Test Script for Fluss Button.\"\"\"\n+\n+from unittest.mock import AsyncMock, Mock, patch\n+\n+from fluss_api import FlussApiClient\n+import pytest\n+\n+from homeassistant.components.fluss.button import (\n+    FlussButton,\n+    async_setup_entry,\n+    validate_device,\n+)\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.helpers.entity_platform import AddEntitiesCallback\n+\n+\n+@pytest.fixture\n+def mock_hass():\n+    \"\"\"Mock Home Assistant Environment.\"\"\"\n+    hass = Mock(spec=HomeAssistant)\n+    hass.config_entries = Mock()\n+    return hass\n+\n+\n+@pytest.fixture\n+def mock_entry():\n+    \"\"\"Mock API Entry.\"\"\"\n+    entry = Mock(spec=ConfigEntry)\n+    entry.data = {\"api_key\": \"test_api_key\"}\n+    entry.runtime_data = None  # Will be set in tests\n+    return entry\n+\n+\n+@pytest.fixture\n+def mock_api_client():\n+    \"\"\"Mock API Client Session.\"\"\"\n+    api_client = Mock(spec=FlussApiClient)\n+    api_client.async_get_devices = AsyncMock(\n+        return_value={\"devices\": [{\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}]}\n+    )\n+    return api_client\n+\n+\n+@pytest.mark.asyncio\n+async def test_async_setup_entry(mock_hass, mock_entry, mock_api_client) -> None:\n+    \"\"\"Test successful setup of the button.\"\"\"\n+    mock_entry.runtime_data = mock_api_client  # Assign directly, not as a dict\n+    mock_add_entities = AsyncMock(spec=AddEntitiesCallback)\n+    mock_api_client.async_get_devices.return_value = {\n+        \"devices\": [{\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}]\n+    }\n+    # Patch to return the mock API client\n+    with patch(\n+        \"fluss_api.main.FlussApiClient\",\n+        return_value=mock_api_client,\n+    ):\n+        await async_setup_entry(mock_hass, mock_entry, mock_add_entities)\n+\n+    # Verify that async_get_devices was called\n+    mock_api_client.async_get_devices.assert_awaited_once()\n+\n+    # Verify that FlussButton instances were created correctly\n+    mock_add_entities.assert_called_once()\n+    added_entities = mock_add_entities.call_args[0][0]\n+    assert len(added_entities) == 1\n+    added_button = added_entities[0]\n+    assert isinstance(added_button, FlussButton)\n+    assert added_button.api == mock_api_client\n+    assert added_button.device == {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}\n+    assert added_button.name == \"Test Device\"\n+    assert added_button.unique_id == \"fluss_1\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_fluss_button() -> None:\n+    \"\"\"Test Scenario of Fluss Button.\"\"\"\n+    mock_api = Mock(spec=FlussApiClient)\n+    device = {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}\n+    button = FlussButton(mock_api, device)",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2209751763",
        "repo_full_name": "home-assistant/core",
        "pr_number": 139925,
        "pr_file": "tests/components/fluss/test_button.py",
        "discussion_id": "2209751763",
        "commented_code": "@@ -0,0 +1,179 @@\n+\"\"\"Test Script for Fluss Button.\"\"\"\n+\n+from unittest.mock import AsyncMock, Mock, patch\n+\n+from fluss_api import FlussApiClient\n+import pytest\n+\n+from homeassistant.components.fluss.button import (\n+    FlussButton,\n+    async_setup_entry,\n+    validate_device,\n+)\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.helpers.entity_platform import AddEntitiesCallback\n+\n+\n+@pytest.fixture\n+def mock_hass():\n+    \"\"\"Mock Home Assistant Environment.\"\"\"\n+    hass = Mock(spec=HomeAssistant)\n+    hass.config_entries = Mock()\n+    return hass\n+\n+\n+@pytest.fixture\n+def mock_entry():\n+    \"\"\"Mock API Entry.\"\"\"\n+    entry = Mock(spec=ConfigEntry)\n+    entry.data = {\"api_key\": \"test_api_key\"}\n+    entry.runtime_data = None  # Will be set in tests\n+    return entry\n+\n+\n+@pytest.fixture\n+def mock_api_client():\n+    \"\"\"Mock API Client Session.\"\"\"\n+    api_client = Mock(spec=FlussApiClient)\n+    api_client.async_get_devices = AsyncMock(\n+        return_value={\"devices\": [{\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}]}\n+    )\n+    return api_client\n+\n+\n+@pytest.mark.asyncio\n+async def test_async_setup_entry(mock_hass, mock_entry, mock_api_client) -> None:\n+    \"\"\"Test successful setup of the button.\"\"\"\n+    mock_entry.runtime_data = mock_api_client  # Assign directly, not as a dict\n+    mock_add_entities = AsyncMock(spec=AddEntitiesCallback)\n+    mock_api_client.async_get_devices.return_value = {\n+        \"devices\": [{\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}]\n+    }\n+    # Patch to return the mock API client\n+    with patch(\n+        \"fluss_api.main.FlussApiClient\",\n+        return_value=mock_api_client,\n+    ):\n+        await async_setup_entry(mock_hass, mock_entry, mock_add_entities)\n+\n+    # Verify that async_get_devices was called\n+    mock_api_client.async_get_devices.assert_awaited_once()\n+\n+    # Verify that FlussButton instances were created correctly\n+    mock_add_entities.assert_called_once()\n+    added_entities = mock_add_entities.call_args[0][0]\n+    assert len(added_entities) == 1\n+    added_button = added_entities[0]\n+    assert isinstance(added_button, FlussButton)\n+    assert added_button.api == mock_api_client\n+    assert added_button.device == {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}\n+    assert added_button.name == \"Test Device\"\n+    assert added_button.unique_id == \"fluss_1\"\n+\n+\n+@pytest.mark.asyncio\n+async def test_fluss_button() -> None:\n+    \"\"\"Test Scenario of Fluss Button.\"\"\"\n+    mock_api = Mock(spec=FlussApiClient)\n+    device = {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}\n+    button = FlussButton(mock_api, device)",
        "comment_created_at": "2025-07-16T09:09:28+00:00",
        "comment_author": "zweckj",
        "comment_body": "let the integration set up and use `await hass.services.async_call(` to simulate the press, check how other integrations are doing it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234957743",
    "pr_number": 139925,
    "pr_file": "tests/components/fluss/test_button.py",
    "created_at": "2025-07-28T06:58:34+00:00",
    "commented_code": "+\"\"\"Test Script for Fluss Button.\"\"\"\n+\n+from unittest.mock import AsyncMock, Mock, patch\n+\n+from fluss_api import FlussApiClient\n+import pytest\n+\n+from homeassistant.components.fluss import CONF_API_KEY\n+from homeassistant.components.fluss.button import FlussButton, async_setup_entry\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.helpers.entity import DeviceInfo\n+from homeassistant.helpers.entity_platform import AddEntitiesCallback\n+\n+from .coordinator import FlussDataUpdateCoordinator\n+\n+\n+@pytest.fixture\n+def mock_hass() -> HomeAssistant:\n+    \"\"\"Mock Home Assistant Environment.\"\"\"\n+    hass = Mock(spec=HomeAssistant)\n+    hass.config_entries = Mock()\n+    hass.config_entries.async_forward_entry_setups = AsyncMock()\n+    return hass\n+\n+\n+@pytest.fixture\n+def mock_entry() -> ConfigEntry:\n+    \"\"\"Mock API Entry.\"\"\"\n+    entry = Mock(spec=ConfigEntry)\n+    entry.data = {CONF_API_KEY: \"test_api_key\"}\n+    entry.runtime_data = None  # Will be set by integration setup\n+    return entry\n+\n+\n+@pytest.fixture\n+def mock_api_client() -> FlussApiClient:\n+    \"\"\"Mock API Client Session.\"\"\"\n+    api_client = Mock(spec=FlussApiClient)\n+    api_client.async_get_devices = AsyncMock(\n+        return_value={\"devices\": [{\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}]}\n+    )\n+    return api_client\n+\n+\n+@pytest.fixture\n+def mock_fluss_api_client(mock_api_client: FlussApiClient) -> FlussApiClient:\n+    \"\"\"Mock the FlussApiClient class.\"\"\"\n+    with patch(\"fluss_api.main.FlussApiClient\", return_value=mock_api_client):\n+        yield mock_api_client\n+\n+\n+@pytest.fixture\n+def mock_coordinator(mock_hass: HomeAssistant, mock_api_client: FlussApiClient) -> FlussDataUpdateCoordinator:\n+    \"\"\"Mock the FlussDataUpdateCoordinator.\"\"\"\n+    coordinator = Mock(spec=FlussDataUpdateCoordinator)\n+    coordinator.hass = mock_hass\n+    coordinator.api = mock_api_client\n+    coordinator.data = {\"1\": {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}}\n+    coordinator.async_config_entry_first_refresh = AsyncMock()\n+    return coordinator\n+\n+\n+@pytest.mark.asyncio\n+async def test_async_setup_entry(\n+    hass: HomeAssistant, mock_entry: ConfigEntry, mock_coordinator: FlussDataUpdateCoordinator, entity_registry\n+) -> None:\n+    \"\"\"Test successful setup of the button.\"\"\"\n+    with patch(\n+        \"homeassistant.components.fluss.async_setup_entry\",\n+        return_value=True,\n+    ) as mock_setup:\n+        await async_setup_entry(hass, mock_entry, AsyncMock())\n+        mock_setup.assert_awaited_once_with(hass, mock_entry)\n+\n+    # Verify that async_get_devices was called via coordinator\n+    mock_coordinator.api.async_get_devices.assert_awaited_once()\n+\n+    # Check the entity registry for the button\n+    entity = entity_registry.async_get(\"button.test_device\")\n+    assert entity is not None\n+    assert entity.unique_id == \"fluss_1\"\n+    assert entity.platform == \"fluss\"\n+    assert entity.device_id == \"1\"\n+\n+    # Verify button properties\n+    device = {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}\n+    button = FlussButton(mock_coordinator, \"1\", device)\n+    assert button.name == \"Test Device\"\n+    assert button.unique_id == \"fluss_1\"\n+    assert button.device_info == DeviceInfo(\n+        identifiers={(\"fluss\", \"1\")},\n+        name=\"Test Device\",\n+        manufacturer=\"Fluss\",\n+        model=\"Fluss Device\",\n+    )\n+\n+\n+@pytest.mark.asyncio\n+async def test_fluss_button(\n+    mock_hass: HomeAssistant, mock_entry: ConfigEntry, mock_coordinator: FlussDataUpdateCoordinator\n+) -> None:\n+    \"\"\"Test Fluss Button by simulating a service call.\"\"\"\n+    mock_registry = Mock()\n+    mock_registry.async_get.return_value = Mock(\n+        entity_id=\"button.test_device\",\n+        unique_id=\"fluss_1\",\n+        platform=\"fluss\",\n+        device_id=\"1\",\n+    )\n+    mock_hass.entity_registry = mock_registry\n+\n+    mock_hass.services = Mock()\n+    mock_hass.services.async_call = AsyncMock()\n+\n+    with patch(\n+        \"homeassistant.components.fluss.async_setup_entry\",\n+        return_value=True,\n+    ):\n+        await async_setup_entry(mock_hass, mock_entry, AsyncMock())",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2234957743",
        "repo_full_name": "home-assistant/core",
        "pr_number": 139925,
        "pr_file": "tests/components/fluss/test_button.py",
        "discussion_id": "2234957743",
        "commented_code": "@@ -0,0 +1,221 @@\n+\"\"\"Test Script for Fluss Button.\"\"\"\n+\n+from unittest.mock import AsyncMock, Mock, patch\n+\n+from fluss_api import FlussApiClient\n+import pytest\n+\n+from homeassistant.components.fluss import CONF_API_KEY\n+from homeassistant.components.fluss.button import FlussButton, async_setup_entry\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.helpers.entity import DeviceInfo\n+from homeassistant.helpers.entity_platform import AddEntitiesCallback\n+\n+from .coordinator import FlussDataUpdateCoordinator\n+\n+\n+@pytest.fixture\n+def mock_hass() -> HomeAssistant:\n+    \"\"\"Mock Home Assistant Environment.\"\"\"\n+    hass = Mock(spec=HomeAssistant)\n+    hass.config_entries = Mock()\n+    hass.config_entries.async_forward_entry_setups = AsyncMock()\n+    return hass\n+\n+\n+@pytest.fixture\n+def mock_entry() -> ConfigEntry:\n+    \"\"\"Mock API Entry.\"\"\"\n+    entry = Mock(spec=ConfigEntry)\n+    entry.data = {CONF_API_KEY: \"test_api_key\"}\n+    entry.runtime_data = None  # Will be set by integration setup\n+    return entry\n+\n+\n+@pytest.fixture\n+def mock_api_client() -> FlussApiClient:\n+    \"\"\"Mock API Client Session.\"\"\"\n+    api_client = Mock(spec=FlussApiClient)\n+    api_client.async_get_devices = AsyncMock(\n+        return_value={\"devices\": [{\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}]}\n+    )\n+    return api_client\n+\n+\n+@pytest.fixture\n+def mock_fluss_api_client(mock_api_client: FlussApiClient) -> FlussApiClient:\n+    \"\"\"Mock the FlussApiClient class.\"\"\"\n+    with patch(\"fluss_api.main.FlussApiClient\", return_value=mock_api_client):\n+        yield mock_api_client\n+\n+\n+@pytest.fixture\n+def mock_coordinator(mock_hass: HomeAssistant, mock_api_client: FlussApiClient) -> FlussDataUpdateCoordinator:\n+    \"\"\"Mock the FlussDataUpdateCoordinator.\"\"\"\n+    coordinator = Mock(spec=FlussDataUpdateCoordinator)\n+    coordinator.hass = mock_hass\n+    coordinator.api = mock_api_client\n+    coordinator.data = {\"1\": {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}}\n+    coordinator.async_config_entry_first_refresh = AsyncMock()\n+    return coordinator\n+\n+\n+@pytest.mark.asyncio\n+async def test_async_setup_entry(\n+    hass: HomeAssistant, mock_entry: ConfigEntry, mock_coordinator: FlussDataUpdateCoordinator, entity_registry\n+) -> None:\n+    \"\"\"Test successful setup of the button.\"\"\"\n+    with patch(\n+        \"homeassistant.components.fluss.async_setup_entry\",\n+        return_value=True,\n+    ) as mock_setup:\n+        await async_setup_entry(hass, mock_entry, AsyncMock())\n+        mock_setup.assert_awaited_once_with(hass, mock_entry)\n+\n+    # Verify that async_get_devices was called via coordinator\n+    mock_coordinator.api.async_get_devices.assert_awaited_once()\n+\n+    # Check the entity registry for the button\n+    entity = entity_registry.async_get(\"button.test_device\")\n+    assert entity is not None\n+    assert entity.unique_id == \"fluss_1\"\n+    assert entity.platform == \"fluss\"\n+    assert entity.device_id == \"1\"\n+\n+    # Verify button properties\n+    device = {\"deviceId\": \"1\", \"deviceName\": \"Test Device\"}\n+    button = FlussButton(mock_coordinator, \"1\", device)\n+    assert button.name == \"Test Device\"\n+    assert button.unique_id == \"fluss_1\"\n+    assert button.device_info == DeviceInfo(\n+        identifiers={(\"fluss\", \"1\")},\n+        name=\"Test Device\",\n+        manufacturer=\"Fluss\",\n+        model=\"Fluss Device\",\n+    )\n+\n+\n+@pytest.mark.asyncio\n+async def test_fluss_button(\n+    mock_hass: HomeAssistant, mock_entry: ConfigEntry, mock_coordinator: FlussDataUpdateCoordinator\n+) -> None:\n+    \"\"\"Test Fluss Button by simulating a service call.\"\"\"\n+    mock_registry = Mock()\n+    mock_registry.async_get.return_value = Mock(\n+        entity_id=\"button.test_device\",\n+        unique_id=\"fluss_1\",\n+        platform=\"fluss\",\n+        device_id=\"1\",\n+    )\n+    mock_hass.entity_registry = mock_registry\n+\n+    mock_hass.services = Mock()\n+    mock_hass.services.async_call = AsyncMock()\n+\n+    with patch(\n+        \"homeassistant.components.fluss.async_setup_entry\",\n+        return_value=True,\n+    ):\n+        await async_setup_entry(mock_hass, mock_entry, AsyncMock())",
        "comment_created_at": "2025-07-28T06:58:34+00:00",
        "comment_author": "zweckj",
        "comment_body": "again don't patch internals. Let the entry set up normally. Check how other integrations do the button tests e.g. lamarzocco",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2209837114",
    "pr_number": 148646,
    "pr_file": "tests/components/tuya/test_climate.py",
    "created_at": "2025-07-16T09:48:14+00:00",
    "commented_code": "from __future__ import annotations\n \n+from typing import cast\n from unittest.mock import patch\n \n import pytest\n from syrupy.assertion import SnapshotAssertion\n-from tuya_sharing import CustomerDevice\n+from tuya_sharing import CustomerDevice, Manager\n \n+from homeassistant.components.climate import HVACMode\n from homeassistant.components.tuya import ManagerCompat\n-from homeassistant.const import Platform\n+from homeassistant.components.tuya.climate import (\n+    TuyaClimateEntity,\n+    TuyaClimateEntityDescription,\n+)\n+from homeassistant.components.tuya.const import DPCode\n+from homeassistant.const import Platform, UnitOfTemperature\n from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import HomeAssistantError\n from homeassistant.helpers import entity_registry as er\n \n from . import DEVICE_MOCKS, initialize_entry\n \n from tests.common import MockConfigEntry, snapshot_platform\n \n \n+class DummyDevice:\n+    \"\"\"Dummy device for testing.\"\"\"\n+\n+    def __init__(self, function, status) -> None:\n+        \"\"\"Initialize the dummy device.\"\"\"\n+        self.function = function\n+        self.status = status\n+        self.id = \"dummy\"\n+        self.name = \"Dummy\"\n+        self.product_name = \"Dummy\"\n+        self.product_id = \"dummy\"\n+        self.status_range = {}\n+        self.online = True\n+\n+\n+class DummyManager:\n+    \"\"\"Dummy manager for testing.\"\"\"\n+\n+    def send_commands(self, device_id: str, commands: list) -> None:\n+        \"\"\"Send commands to the device.\"\"\"\n+\n+\n+class DummyFunction:\n+    \"\"\"Dummy function for testing.\"\"\"\n+\n+    def __init__(self, type_: str, values: str) -> None:\n+        \"\"\"Initialize the dummy function.\"\"\"\n+        self.type = type_\n+        self.values = values\n+\n+\n+def make_climate_entity(function, status):\n+    \"\"\"Make a dummy climate entity for testing.\"\"\"\n+    return TuyaClimateEntity(\n+        cast(\"CustomerDevice\", DummyDevice(function, status)),\n+        cast(\"Manager\", DummyManager()),\n+        TuyaClimateEntityDescription(key=\"kt\", switch_only_hvac_mode=HVACMode.COOL),\n+        UnitOfTemperature.CELSIUS,\n+    )\n+\n+\n+def test_fan_mode_windspeed() -> None:\n+    \"\"\"Test fan mode with windspeed.\"\"\"\n+    entity = make_climate_entity(\n+        {\"windspeed\": DummyFunction(\"Enum\", '{\"range\": [\"1\", \"2\"]}')},\n+        {\"windspeed\": \"2\"},\n+    )\n+    assert entity.fan_mode == \"2\"\n+    entity.set_fan_mode(\"1\")",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2209837114",
        "repo_full_name": "home-assistant/core",
        "pr_number": 148646,
        "pr_file": "tests/components/tuya/test_climate.py",
        "discussion_id": "2209837114",
        "commented_code": "@@ -2,22 +2,99 @@\n \n from __future__ import annotations\n \n+from typing import cast\n from unittest.mock import patch\n \n import pytest\n from syrupy.assertion import SnapshotAssertion\n-from tuya_sharing import CustomerDevice\n+from tuya_sharing import CustomerDevice, Manager\n \n+from homeassistant.components.climate import HVACMode\n from homeassistant.components.tuya import ManagerCompat\n-from homeassistant.const import Platform\n+from homeassistant.components.tuya.climate import (\n+    TuyaClimateEntity,\n+    TuyaClimateEntityDescription,\n+)\n+from homeassistant.components.tuya.const import DPCode\n+from homeassistant.const import Platform, UnitOfTemperature\n from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import HomeAssistantError\n from homeassistant.helpers import entity_registry as er\n \n from . import DEVICE_MOCKS, initialize_entry\n \n from tests.common import MockConfigEntry, snapshot_platform\n \n \n+class DummyDevice:\n+    \"\"\"Dummy device for testing.\"\"\"\n+\n+    def __init__(self, function, status) -> None:\n+        \"\"\"Initialize the dummy device.\"\"\"\n+        self.function = function\n+        self.status = status\n+        self.id = \"dummy\"\n+        self.name = \"Dummy\"\n+        self.product_name = \"Dummy\"\n+        self.product_id = \"dummy\"\n+        self.status_range = {}\n+        self.online = True\n+\n+\n+class DummyManager:\n+    \"\"\"Dummy manager for testing.\"\"\"\n+\n+    def send_commands(self, device_id: str, commands: list) -> None:\n+        \"\"\"Send commands to the device.\"\"\"\n+\n+\n+class DummyFunction:\n+    \"\"\"Dummy function for testing.\"\"\"\n+\n+    def __init__(self, type_: str, values: str) -> None:\n+        \"\"\"Initialize the dummy function.\"\"\"\n+        self.type = type_\n+        self.values = values\n+\n+\n+def make_climate_entity(function, status):\n+    \"\"\"Make a dummy climate entity for testing.\"\"\"\n+    return TuyaClimateEntity(\n+        cast(\"CustomerDevice\", DummyDevice(function, status)),\n+        cast(\"Manager\", DummyManager()),\n+        TuyaClimateEntityDescription(key=\"kt\", switch_only_hvac_mode=HVACMode.COOL),\n+        UnitOfTemperature.CELSIUS,\n+    )\n+\n+\n+def test_fan_mode_windspeed() -> None:\n+    \"\"\"Test fan mode with windspeed.\"\"\"\n+    entity = make_climate_entity(\n+        {\"windspeed\": DummyFunction(\"Enum\", '{\"range\": [\"1\", \"2\"]}')},\n+        {\"windspeed\": \"2\"},\n+    )\n+    assert entity.fan_mode == \"2\"\n+    entity.set_fan_mode(\"1\")",
        "comment_created_at": "2025-07-16T09:48:14+00:00",
        "comment_author": "epenet",
        "comment_body": "`set_fan_mode` should be tested using service calls - not direct function calls on the entity\r\nThe best would be to make the service call, and then check that the manager received the correct instructions\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2210166104",
    "pr_number": 148646,
    "pr_file": "tests/components/tuya/test_climate.py",
    "created_at": "2025-07-16T11:57:22+00:00",
    "commented_code": "assert not er.async_entries_for_config_entry(\n         entity_registry, mock_config_entry.entry_id\n     )\n+\n+\n+@pytest.mark.parametrize(\n+    \"mock_device_code\",\n+    [\"kt_serenelife_slpac905wuk_air_conditioner\"],\n+)\n+async def test_fan_mode_windspeed(\n+    hass: HomeAssistant,\n+    mock_manager: ManagerCompat,\n+    mock_config_entry: MockConfigEntry,\n+    mock_device: CustomerDevice,\n+) -> None:\n+    \"\"\"Test fan mode with windspeed.\"\"\"\n+    await initialize_entry(hass, mock_manager, mock_config_entry, mock_device)\n+\n+    state = hass.states.get(\"climate.air_conditioner\")\n+    assert state is not None, \"climate.air_conditioner does not exist\"\n+    assert state.attributes[\"fan_mode\"] == WINDSPEED_LOW\n+    await hass.services.async_call(\n+        Platform.CLIMATE,\n+        \"set_fan_mode\",\n+        {\n+            \"entity_id\": \"climate.air_conditioner\",\n+            \"fan_mode\": WINDSPEED_HIGH,\n+        },\n+    )\n+    await hass.async_block_till_done()",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2210166104",
        "repo_full_name": "home-assistant/core",
        "pr_number": 148646,
        "pr_file": "tests/components/tuya/test_climate.py",
        "discussion_id": "2210166104",
        "commented_code": "@@ -55,3 +59,78 @@ async def test_platform_setup_no_discovery(\n     assert not er.async_entries_for_config_entry(\n         entity_registry, mock_config_entry.entry_id\n     )\n+\n+\n+@pytest.mark.parametrize(\n+    \"mock_device_code\",\n+    [\"kt_serenelife_slpac905wuk_air_conditioner\"],\n+)\n+async def test_fan_mode_windspeed(\n+    hass: HomeAssistant,\n+    mock_manager: ManagerCompat,\n+    mock_config_entry: MockConfigEntry,\n+    mock_device: CustomerDevice,\n+) -> None:\n+    \"\"\"Test fan mode with windspeed.\"\"\"\n+    await initialize_entry(hass, mock_manager, mock_config_entry, mock_device)\n+\n+    state = hass.states.get(\"climate.air_conditioner\")\n+    assert state is not None, \"climate.air_conditioner does not exist\"\n+    assert state.attributes[\"fan_mode\"] == WINDSPEED_LOW\n+    await hass.services.async_call(\n+        Platform.CLIMATE,\n+        \"set_fan_mode\",\n+        {\n+            \"entity_id\": \"climate.air_conditioner\",\n+            \"fan_mode\": WINDSPEED_HIGH,\n+        },\n+    )\n+    await hass.async_block_till_done()",
        "comment_created_at": "2025-07-16T11:57:22+00:00",
        "comment_author": "epenet",
        "comment_body": "Ensure that send_commands has been called with correct arguments:\r\n```suggestion\r\n    await hass.async_block_till_done()\r\n    mock_manager.send_commands.assert_called_once_with(\r\n        mock_device.id, [{\"code\": \"windspeed\", \"value\": \"2\"}]\r\n    )\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2168440130",
    "pr_number": 135844,
    "pr_file": "tests/components/backup_sftp/conftest.py",
    "created_at": "2025-06-26T07:56:57+00:00",
    "commented_code": "+\"\"\"PyTest fixtures and test helpers.\"\"\"\n+\n+from collections.abc import AsyncIterator, Generator\n+from io import BytesIO\n+import tarfile\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.backup_sftp.const import (\n+    CONF_BACKUP_LOCATION,\n+    CONF_HOST,\n+    CONF_PASSWORD,\n+    CONF_PORT,\n+    CONF_PRIVATE_KEY_FILE,\n+    CONF_USERNAME,\n+    DOMAIN,\n+)\n+from homeassistant.util import slugify\n+\n+from tests.common import MockConfigEntry\n+\n+CONFIG_ENTRY_TITLE = \"testsshuser@127.0.0.1\"\n+USER_INPUT = {\n+    CONF_HOST: \"127.0.0.1\",\n+    CONF_PORT: 22,\n+    CONF_USERNAME: \"username\",\n+    CONF_PASSWORD: \"password\",\n+    CONF_PRIVATE_KEY_FILE: \"private_key\",\n+    CONF_BACKUP_LOCATION: \"backup_location\",\n+}\n+TEST_AGENT_ID = slugify(\n+    \".\".join(\n+        [\n+            USER_INPUT[CONF_HOST],\n+            str(USER_INPUT[CONF_PORT]),\n+            USER_INPUT[CONF_USERNAME],\n+            USER_INPUT[CONF_BACKUP_LOCATION],\n+        ]\n+    )\n+)\n+\n+\n+class AsyncFileIteratorMock:\n+    \"\"\"Class that mocks `homeassistant.components.backup_sftp.client.AsyncFileIterator`.\"\"\"\n+\n+    def __init__(self, content: bytes) -> None:\n+        \"\"\"Initialize `AsyncFileIteratorMock`.\"\"\"\n+        self.content = BytesIO(content)\n+\n+    def __aiter__(self) -> AsyncIterator[bytes]:\n+        \"\"\"Initialize iteration.\"\"\"\n+        return self\n+\n+    async def __anext__(self) -> bytes:\n+        \"\"\"Return next content in iteration.\"\"\"\n+        chunk = self.content.read()\n+        if not chunk:\n+            try:\n+                self.content.close()\n+            finally:\n+                raise StopAsyncIteration\n+        return chunk\n+\n+\n+def create_tar_bytes(files: dict) -> bytes:\n+    \"\"\"Create an in-memory tar archive.\"\"\"\n+    buf = BytesIO()\n+    with tarfile.open(mode=\"w\", fileobj=buf) as tar:\n+        for name, content in files.items():\n+            if isinstance(content, str):\n+                content = content.encode(\"utf-8\")\n+            info = tarfile.TarInfo(name=name)\n+            info.size = len(content)\n+            tar.addfile(tarinfo=info, fileobj=BytesIO(content))\n+    return buf.getvalue()\n+\n+\n+@pytest.fixture\n+def async_cm_mock() -> AsyncMock:\n+    \"\"\"Test agent list backups.\"\"\"\n+    mocked_client = AsyncMock()\n+    mocked_client.__aenter__ = AsyncMock(return_value=mocked_client)\n+    mocked_client.__aexit__ = AsyncMock(return_value=None)\n+    return mocked_client\n+\n+\n+@pytest.fixture\n+def async_cm_mock_generator() -> callable:\n+    \"\"\"Return function that generates AsyncMock context manager.\"\"\"\n+\n+    def _generator():\n+        mocked_client = MagicMock()\n+        mocked_client.return_value.__aenter__ = AsyncMock(return_value=mocked_client)\n+        mocked_client.return_value.__aexit__ = AsyncMock(return_value=None)\n+        return mocked_client\n+\n+    return _generator\n+\n+\n+@pytest.fixture\n+def fake_connect(async_cm_mock):\n+    \"Prepare a fake `asyncssh.connect` cm to simulate a successful connection.\"\n+    mck = AsyncMock()\n+    mck.__aenter__.return_value = mck\n+    mck.start_sftp_client = lambda: async_cm_mock\n+    return mck\n+\n+\n+@pytest.fixture(name=\"config_entry\")\n+def mock_config_entry() -> MockConfigEntry:\n+    \"\"\"Fixture for MockConfigEntry.\"\"\"\n+    return MockConfigEntry(\n+        domain=DOMAIN,\n+        unique_id=TEST_AGENT_ID,\n+        title=CONFIG_ENTRY_TITLE,\n+        data={\n+            CONF_HOST: \"127.0.0.1\",\n+            CONF_PORT: 22,\n+            CONF_USERNAME: \"username\",\n+            CONF_PASSWORD: \"password\",\n+            CONF_PRIVATE_KEY_FILE: \"private_key\",\n+            CONF_BACKUP_LOCATION: \"backup_location\",\n+        },\n+    )\n+\n+\n+@pytest.fixture\n+def mock_client() -> Generator[MagicMock]:\n+    \"\"\"Return a mocked Backup Agent Client.\"\"\"\n+    with patch(\n+        \"homeassistant.components.backup_sftp.client.BackupAgentClient\"\n+    ) as mocked_client_class:\n+        # Use an AsyncMock for the client so its async context methods are awaitable\n+        mocked_client = AsyncMock()\n+        mocked_client_class.return_value = mocked_client\n+\n+        # When entering the async context, return the client itself\n+        mocked_client.__aenter__ = AsyncMock(return_value=mocked_client)\n+        mocked_client.__aexit__ = AsyncMock(return_value=None)\n+\n+        mocked_client.list_backup_location = AsyncMock(return_value=[])\n+        yield mocked_client",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2168440130",
        "repo_full_name": "home-assistant/core",
        "pr_number": 135844,
        "pr_file": "tests/components/backup_sftp/conftest.py",
        "discussion_id": "2168440130",
        "commented_code": "@@ -0,0 +1,143 @@\n+\"\"\"PyTest fixtures and test helpers.\"\"\"\n+\n+from collections.abc import AsyncIterator, Generator\n+from io import BytesIO\n+import tarfile\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.backup_sftp.const import (\n+    CONF_BACKUP_LOCATION,\n+    CONF_HOST,\n+    CONF_PASSWORD,\n+    CONF_PORT,\n+    CONF_PRIVATE_KEY_FILE,\n+    CONF_USERNAME,\n+    DOMAIN,\n+)\n+from homeassistant.util import slugify\n+\n+from tests.common import MockConfigEntry\n+\n+CONFIG_ENTRY_TITLE = \"testsshuser@127.0.0.1\"\n+USER_INPUT = {\n+    CONF_HOST: \"127.0.0.1\",\n+    CONF_PORT: 22,\n+    CONF_USERNAME: \"username\",\n+    CONF_PASSWORD: \"password\",\n+    CONF_PRIVATE_KEY_FILE: \"private_key\",\n+    CONF_BACKUP_LOCATION: \"backup_location\",\n+}\n+TEST_AGENT_ID = slugify(\n+    \".\".join(\n+        [\n+            USER_INPUT[CONF_HOST],\n+            str(USER_INPUT[CONF_PORT]),\n+            USER_INPUT[CONF_USERNAME],\n+            USER_INPUT[CONF_BACKUP_LOCATION],\n+        ]\n+    )\n+)\n+\n+\n+class AsyncFileIteratorMock:\n+    \"\"\"Class that mocks `homeassistant.components.backup_sftp.client.AsyncFileIterator`.\"\"\"\n+\n+    def __init__(self, content: bytes) -> None:\n+        \"\"\"Initialize `AsyncFileIteratorMock`.\"\"\"\n+        self.content = BytesIO(content)\n+\n+    def __aiter__(self) -> AsyncIterator[bytes]:\n+        \"\"\"Initialize iteration.\"\"\"\n+        return self\n+\n+    async def __anext__(self) -> bytes:\n+        \"\"\"Return next content in iteration.\"\"\"\n+        chunk = self.content.read()\n+        if not chunk:\n+            try:\n+                self.content.close()\n+            finally:\n+                raise StopAsyncIteration\n+        return chunk\n+\n+\n+def create_tar_bytes(files: dict) -> bytes:\n+    \"\"\"Create an in-memory tar archive.\"\"\"\n+    buf = BytesIO()\n+    with tarfile.open(mode=\"w\", fileobj=buf) as tar:\n+        for name, content in files.items():\n+            if isinstance(content, str):\n+                content = content.encode(\"utf-8\")\n+            info = tarfile.TarInfo(name=name)\n+            info.size = len(content)\n+            tar.addfile(tarinfo=info, fileobj=BytesIO(content))\n+    return buf.getvalue()\n+\n+\n+@pytest.fixture\n+def async_cm_mock() -> AsyncMock:\n+    \"\"\"Test agent list backups.\"\"\"\n+    mocked_client = AsyncMock()\n+    mocked_client.__aenter__ = AsyncMock(return_value=mocked_client)\n+    mocked_client.__aexit__ = AsyncMock(return_value=None)\n+    return mocked_client\n+\n+\n+@pytest.fixture\n+def async_cm_mock_generator() -> callable:\n+    \"\"\"Return function that generates AsyncMock context manager.\"\"\"\n+\n+    def _generator():\n+        mocked_client = MagicMock()\n+        mocked_client.return_value.__aenter__ = AsyncMock(return_value=mocked_client)\n+        mocked_client.return_value.__aexit__ = AsyncMock(return_value=None)\n+        return mocked_client\n+\n+    return _generator\n+\n+\n+@pytest.fixture\n+def fake_connect(async_cm_mock):\n+    \"Prepare a fake `asyncssh.connect` cm to simulate a successful connection.\"\n+    mck = AsyncMock()\n+    mck.__aenter__.return_value = mck\n+    mck.start_sftp_client = lambda: async_cm_mock\n+    return mck\n+\n+\n+@pytest.fixture(name=\"config_entry\")\n+def mock_config_entry() -> MockConfigEntry:\n+    \"\"\"Fixture for MockConfigEntry.\"\"\"\n+    return MockConfigEntry(\n+        domain=DOMAIN,\n+        unique_id=TEST_AGENT_ID,\n+        title=CONFIG_ENTRY_TITLE,\n+        data={\n+            CONF_HOST: \"127.0.0.1\",\n+            CONF_PORT: 22,\n+            CONF_USERNAME: \"username\",\n+            CONF_PASSWORD: \"password\",\n+            CONF_PRIVATE_KEY_FILE: \"private_key\",\n+            CONF_BACKUP_LOCATION: \"backup_location\",\n+        },\n+    )\n+\n+\n+@pytest.fixture\n+def mock_client() -> Generator[MagicMock]:\n+    \"\"\"Return a mocked Backup Agent Client.\"\"\"\n+    with patch(\n+        \"homeassistant.components.backup_sftp.client.BackupAgentClient\"\n+    ) as mocked_client_class:\n+        # Use an AsyncMock for the client so its async context methods are awaitable\n+        mocked_client = AsyncMock()\n+        mocked_client_class.return_value = mocked_client\n+\n+        # When entering the async context, return the client itself\n+        mocked_client.__aenter__ = AsyncMock(return_value=mocked_client)\n+        mocked_client.__aexit__ = AsyncMock(return_value=None)\n+\n+        mocked_client.list_backup_location = AsyncMock(return_value=[])\n+        yield mocked_client",
        "comment_created_at": "2025-06-26T07:56:57+00:00",
        "comment_author": "emontnemery",
        "comment_body": "The problem with this fixture is that we don't test that `SFTPBackupAgent` and `BackupAgentClient` can cooperate; if `BackupAgentClient` is modified tests still pass without modifications to `SFTPBackupAgent`.\r\n\r\nPlease change to instead only mock the `asyncssh` library.",
        "pr_file_module": null
      },
      {
        "comment_id": "2231074610",
        "repo_full_name": "home-assistant/core",
        "pr_number": 135844,
        "pr_file": "tests/components/backup_sftp/conftest.py",
        "discussion_id": "2168440130",
        "commented_code": "@@ -0,0 +1,143 @@\n+\"\"\"PyTest fixtures and test helpers.\"\"\"\n+\n+from collections.abc import AsyncIterator, Generator\n+from io import BytesIO\n+import tarfile\n+from unittest.mock import AsyncMock, MagicMock, patch\n+\n+import pytest\n+\n+from homeassistant.components.backup_sftp.const import (\n+    CONF_BACKUP_LOCATION,\n+    CONF_HOST,\n+    CONF_PASSWORD,\n+    CONF_PORT,\n+    CONF_PRIVATE_KEY_FILE,\n+    CONF_USERNAME,\n+    DOMAIN,\n+)\n+from homeassistant.util import slugify\n+\n+from tests.common import MockConfigEntry\n+\n+CONFIG_ENTRY_TITLE = \"testsshuser@127.0.0.1\"\n+USER_INPUT = {\n+    CONF_HOST: \"127.0.0.1\",\n+    CONF_PORT: 22,\n+    CONF_USERNAME: \"username\",\n+    CONF_PASSWORD: \"password\",\n+    CONF_PRIVATE_KEY_FILE: \"private_key\",\n+    CONF_BACKUP_LOCATION: \"backup_location\",\n+}\n+TEST_AGENT_ID = slugify(\n+    \".\".join(\n+        [\n+            USER_INPUT[CONF_HOST],\n+            str(USER_INPUT[CONF_PORT]),\n+            USER_INPUT[CONF_USERNAME],\n+            USER_INPUT[CONF_BACKUP_LOCATION],\n+        ]\n+    )\n+)\n+\n+\n+class AsyncFileIteratorMock:\n+    \"\"\"Class that mocks `homeassistant.components.backup_sftp.client.AsyncFileIterator`.\"\"\"\n+\n+    def __init__(self, content: bytes) -> None:\n+        \"\"\"Initialize `AsyncFileIteratorMock`.\"\"\"\n+        self.content = BytesIO(content)\n+\n+    def __aiter__(self) -> AsyncIterator[bytes]:\n+        \"\"\"Initialize iteration.\"\"\"\n+        return self\n+\n+    async def __anext__(self) -> bytes:\n+        \"\"\"Return next content in iteration.\"\"\"\n+        chunk = self.content.read()\n+        if not chunk:\n+            try:\n+                self.content.close()\n+            finally:\n+                raise StopAsyncIteration\n+        return chunk\n+\n+\n+def create_tar_bytes(files: dict) -> bytes:\n+    \"\"\"Create an in-memory tar archive.\"\"\"\n+    buf = BytesIO()\n+    with tarfile.open(mode=\"w\", fileobj=buf) as tar:\n+        for name, content in files.items():\n+            if isinstance(content, str):\n+                content = content.encode(\"utf-8\")\n+            info = tarfile.TarInfo(name=name)\n+            info.size = len(content)\n+            tar.addfile(tarinfo=info, fileobj=BytesIO(content))\n+    return buf.getvalue()\n+\n+\n+@pytest.fixture\n+def async_cm_mock() -> AsyncMock:\n+    \"\"\"Test agent list backups.\"\"\"\n+    mocked_client = AsyncMock()\n+    mocked_client.__aenter__ = AsyncMock(return_value=mocked_client)\n+    mocked_client.__aexit__ = AsyncMock(return_value=None)\n+    return mocked_client\n+\n+\n+@pytest.fixture\n+def async_cm_mock_generator() -> callable:\n+    \"\"\"Return function that generates AsyncMock context manager.\"\"\"\n+\n+    def _generator():\n+        mocked_client = MagicMock()\n+        mocked_client.return_value.__aenter__ = AsyncMock(return_value=mocked_client)\n+        mocked_client.return_value.__aexit__ = AsyncMock(return_value=None)\n+        return mocked_client\n+\n+    return _generator\n+\n+\n+@pytest.fixture\n+def fake_connect(async_cm_mock):\n+    \"Prepare a fake `asyncssh.connect` cm to simulate a successful connection.\"\n+    mck = AsyncMock()\n+    mck.__aenter__.return_value = mck\n+    mck.start_sftp_client = lambda: async_cm_mock\n+    return mck\n+\n+\n+@pytest.fixture(name=\"config_entry\")\n+def mock_config_entry() -> MockConfigEntry:\n+    \"\"\"Fixture for MockConfigEntry.\"\"\"\n+    return MockConfigEntry(\n+        domain=DOMAIN,\n+        unique_id=TEST_AGENT_ID,\n+        title=CONFIG_ENTRY_TITLE,\n+        data={\n+            CONF_HOST: \"127.0.0.1\",\n+            CONF_PORT: 22,\n+            CONF_USERNAME: \"username\",\n+            CONF_PASSWORD: \"password\",\n+            CONF_PRIVATE_KEY_FILE: \"private_key\",\n+            CONF_BACKUP_LOCATION: \"backup_location\",\n+        },\n+    )\n+\n+\n+@pytest.fixture\n+def mock_client() -> Generator[MagicMock]:\n+    \"\"\"Return a mocked Backup Agent Client.\"\"\"\n+    with patch(\n+        \"homeassistant.components.backup_sftp.client.BackupAgentClient\"\n+    ) as mocked_client_class:\n+        # Use an AsyncMock for the client so its async context methods are awaitable\n+        mocked_client = AsyncMock()\n+        mocked_client_class.return_value = mocked_client\n+\n+        # When entering the async context, return the client itself\n+        mocked_client.__aenter__ = AsyncMock(return_value=mocked_client)\n+        mocked_client.__aexit__ = AsyncMock(return_value=None)\n+\n+        mocked_client.list_backup_location = AsyncMock(return_value=[])\n+        yield mocked_client",
        "comment_created_at": "2025-07-25T13:22:41+00:00",
        "comment_author": "maretodoric",
        "comment_body": "Actually, that one is not even used. Will remove it.",
        "pr_file_module": null
      }
    ]
  }
]