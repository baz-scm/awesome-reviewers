[
  {
    "discussion_id": "2225753111",
    "pr_number": 147085,
    "pr_file": "homeassistant/components/hanna/config_flow.py",
    "created_at": "2025-07-23T14:15:13+00:00",
    "commented_code": "+\"\"\"Config flow for Hanna Instruments integration.\"\"\"\n+\n+from __future__ import annotations\n+\n+import logging\n+from typing import Any\n+\n+from hanna_cloud import HannaCloudClient\n+from requests.exceptions import (\n+    ConnectionError as RequestsConnectionError,\n+    RequestException,\n+    Timeout,\n+)\n+import voluptuous as vol\n+\n+from homeassistant.config_entries import ConfigFlow, ConfigFlowResult\n+from homeassistant.const import CONF_CODE, CONF_EMAIL, CONF_PASSWORD\n+\n+from .const import DEFAULT_ENCRYPTION_KEY, DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+class HannaConfigFlow(ConfigFlow, domain=DOMAIN):\n+    \"\"\"Handle a config flow for Hanna Instruments.\"\"\"\n+\n+    VERSION = 1\n+    data_schema = vol.Schema(\n+        {\n+            vol.Required(CONF_EMAIL): str,\n+            vol.Required(CONF_PASSWORD): str,\n+            vol.Required(CONF_CODE, default=DEFAULT_ENCRYPTION_KEY): str,\n+        }\n+    )\n+\n+    async def async_step_user(\n+        self, user_input: dict[str, Any] | None = None\n+    ) -> ConfigFlowResult:\n+        \"\"\"Handle the initial step.\"\"\"\n+        errors: dict[str, str] = {}\n+\n+        if user_input is None:\n+            return self.async_show_form(\n+                step_id=\"user\",\n+                data_schema=self.data_schema,\n+                errors=errors,\n+            )\n+\n+        try:\n+            client = HannaCloudClient()\n+            await self.hass.async_add_executor_job(\n+                client.authenticate,\n+                user_input[CONF_EMAIL],\n+                user_input[CONF_PASSWORD],\n+                user_input[CONF_CODE],\n+            )\n+        except (Timeout, RequestsConnectionError):\n+            _LOGGER.exception(\"Connection timeout or error\")\n+            errors[\"base\"] = \"cannot_connect\"\n+        except RequestException as ex:\n+            if hasattr(ex, \"response\") and ex.response is not None:\n+                if ex.response.status_code in (401, 403):\n+                    _LOGGER.exception(\"Authentication failed\")\n+                    errors[\"base\"] = \"invalid_auth\"\n+                else:\n+                    _LOGGER.exception(\n+                        \"Request failed with status %s\", ex.response.status_code\n+                    )\n+                    errors[\"base\"] = \"cannot_connect\"\n+            else:\n+                _LOGGER.exception(\"Request failed\")",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2225753111",
        "repo_full_name": "home-assistant/core",
        "pr_number": 147085,
        "pr_file": "homeassistant/components/hanna/config_flow.py",
        "discussion_id": "2225753111",
        "commented_code": "@@ -0,0 +1,142 @@\n+\"\"\"Config flow for Hanna Instruments integration.\"\"\"\n+\n+from __future__ import annotations\n+\n+import logging\n+from typing import Any\n+\n+from hanna_cloud import HannaCloudClient\n+from requests.exceptions import (\n+    ConnectionError as RequestsConnectionError,\n+    RequestException,\n+    Timeout,\n+)\n+import voluptuous as vol\n+\n+from homeassistant.config_entries import ConfigFlow, ConfigFlowResult\n+from homeassistant.const import CONF_CODE, CONF_EMAIL, CONF_PASSWORD\n+\n+from .const import DEFAULT_ENCRYPTION_KEY, DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+class HannaConfigFlow(ConfigFlow, domain=DOMAIN):\n+    \"\"\"Handle a config flow for Hanna Instruments.\"\"\"\n+\n+    VERSION = 1\n+    data_schema = vol.Schema(\n+        {\n+            vol.Required(CONF_EMAIL): str,\n+            vol.Required(CONF_PASSWORD): str,\n+            vol.Required(CONF_CODE, default=DEFAULT_ENCRYPTION_KEY): str,\n+        }\n+    )\n+\n+    async def async_step_user(\n+        self, user_input: dict[str, Any] | None = None\n+    ) -> ConfigFlowResult:\n+        \"\"\"Handle the initial step.\"\"\"\n+        errors: dict[str, str] = {}\n+\n+        if user_input is None:\n+            return self.async_show_form(\n+                step_id=\"user\",\n+                data_schema=self.data_schema,\n+                errors=errors,\n+            )\n+\n+        try:\n+            client = HannaCloudClient()\n+            await self.hass.async_add_executor_job(\n+                client.authenticate,\n+                user_input[CONF_EMAIL],\n+                user_input[CONF_PASSWORD],\n+                user_input[CONF_CODE],\n+            )\n+        except (Timeout, RequestsConnectionError):\n+            _LOGGER.exception(\"Connection timeout or error\")\n+            errors[\"base\"] = \"cannot_connect\"\n+        except RequestException as ex:\n+            if hasattr(ex, \"response\") and ex.response is not None:\n+                if ex.response.status_code in (401, 403):\n+                    _LOGGER.exception(\"Authentication failed\")\n+                    errors[\"base\"] = \"invalid_auth\"\n+                else:\n+                    _LOGGER.exception(\n+                        \"Request failed with status %s\", ex.response.status_code\n+                    )\n+                    errors[\"base\"] = \"cannot_connect\"\n+            else:\n+                _LOGGER.exception(\"Request failed\")",
        "comment_created_at": "2025-07-23T14:15:13+00:00",
        "comment_author": "joostlek",
        "comment_body": "Ideally we only log the `Exception` with `logger.exception` as there we truly don't know what happened and need the full stack trace. With the rest I am wondering if we need to have the full stack trace every time",
        "pr_file_module": null
      },
      {
        "comment_id": "2230729694",
        "repo_full_name": "home-assistant/core",
        "pr_number": 147085,
        "pr_file": "homeassistant/components/hanna/config_flow.py",
        "discussion_id": "2225753111",
        "commented_code": "@@ -0,0 +1,142 @@\n+\"\"\"Config flow for Hanna Instruments integration.\"\"\"\n+\n+from __future__ import annotations\n+\n+import logging\n+from typing import Any\n+\n+from hanna_cloud import HannaCloudClient\n+from requests.exceptions import (\n+    ConnectionError as RequestsConnectionError,\n+    RequestException,\n+    Timeout,\n+)\n+import voluptuous as vol\n+\n+from homeassistant.config_entries import ConfigFlow, ConfigFlowResult\n+from homeassistant.const import CONF_CODE, CONF_EMAIL, CONF_PASSWORD\n+\n+from .const import DEFAULT_ENCRYPTION_KEY, DOMAIN\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+class HannaConfigFlow(ConfigFlow, domain=DOMAIN):\n+    \"\"\"Handle a config flow for Hanna Instruments.\"\"\"\n+\n+    VERSION = 1\n+    data_schema = vol.Schema(\n+        {\n+            vol.Required(CONF_EMAIL): str,\n+            vol.Required(CONF_PASSWORD): str,\n+            vol.Required(CONF_CODE, default=DEFAULT_ENCRYPTION_KEY): str,\n+        }\n+    )\n+\n+    async def async_step_user(\n+        self, user_input: dict[str, Any] | None = None\n+    ) -> ConfigFlowResult:\n+        \"\"\"Handle the initial step.\"\"\"\n+        errors: dict[str, str] = {}\n+\n+        if user_input is None:\n+            return self.async_show_form(\n+                step_id=\"user\",\n+                data_schema=self.data_schema,\n+                errors=errors,\n+            )\n+\n+        try:\n+            client = HannaCloudClient()\n+            await self.hass.async_add_executor_job(\n+                client.authenticate,\n+                user_input[CONF_EMAIL],\n+                user_input[CONF_PASSWORD],\n+                user_input[CONF_CODE],\n+            )\n+        except (Timeout, RequestsConnectionError):\n+            _LOGGER.exception(\"Connection timeout or error\")\n+            errors[\"base\"] = \"cannot_connect\"\n+        except RequestException as ex:\n+            if hasattr(ex, \"response\") and ex.response is not None:\n+                if ex.response.status_code in (401, 403):\n+                    _LOGGER.exception(\"Authentication failed\")\n+                    errors[\"base\"] = \"invalid_auth\"\n+                else:\n+                    _LOGGER.exception(\n+                        \"Request failed with status %s\", ex.response.status_code\n+                    )\n+                    errors[\"base\"] = \"cannot_connect\"\n+            else:\n+                _LOGGER.exception(\"Request failed\")",
        "comment_created_at": "2025-07-25T10:19:03+00:00",
        "comment_author": "bestycame",
        "comment_body": "Your are right, \r\nChanged to:\r\n```\r\n        except (Timeout, RequestsConnectionError):\r\n            _LOGGER.warning(\"Connection timeout or error during Hanna authentication\")\r\n            errors[\"base\"] = \"cannot_connect\"\r\n        except AuthenticationError:\r\n            _LOGGER.warning(\"Authentication failed for user %s\", user_input[CONF_EMAIL])\r\n            errors[\"base\"] = \"invalid_auth\"\r\n        except Exception:\r\n            _LOGGER.exception(\"Unexpected error during Hanna authentication\")\r\n            errors[\"base\"] = \"unknown\"\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1960289386",
    "pr_number": 136947,
    "pr_file": "homeassistant/components/redgtech/config_flow.py",
    "created_at": "2025-02-18T18:26:11+00:00",
    "commented_code": "+from homeassistant import config_entries\n+import voluptuous as vol\n+import logging\n+from .const import DOMAIN\n+from redgtech_api import RedgtechAPI\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+class RedgtechConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):\n+    \"\"\"Config Flow for Redgtech integration.\"\"\"\n+\n+    VERSION = 1\n+\n+    async def async_step_user(self, user_input=None):\n+        \"\"\"Handle the initial user step for login.\"\"\"\n+        errors = {}\n+        \n+        if user_input is not None:\n+            email = user_input.get(\"email\")\n+            password = user_input.get(\"password\")\n+            \n+            api = RedgtechAPI()\n+            try:\n+                access_token = await api.login(email, password)\n+                if access_token:\n+                    _LOGGER.info(\"Login successful\")",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "1960289386",
        "repo_full_name": "home-assistant/core",
        "pr_number": 136947,
        "pr_file": "homeassistant/components/redgtech/config_flow.py",
        "discussion_id": "1960289386",
        "commented_code": "@@ -0,0 +1,46 @@\n+from homeassistant import config_entries\n+import voluptuous as vol\n+import logging\n+from .const import DOMAIN\n+from redgtech_api import RedgtechAPI\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+class RedgtechConfigFlow(config_entries.ConfigFlow, domain=DOMAIN):\n+    \"\"\"Config Flow for Redgtech integration.\"\"\"\n+\n+    VERSION = 1\n+\n+    async def async_step_user(self, user_input=None):\n+        \"\"\"Handle the initial user step for login.\"\"\"\n+        errors = {}\n+        \n+        if user_input is not None:\n+            email = user_input.get(\"email\")\n+            password = user_input.get(\"password\")\n+            \n+            api = RedgtechAPI()\n+            try:\n+                access_token = await api.login(email, password)\n+                if access_token:\n+                    _LOGGER.info(\"Login successful\")",
        "comment_created_at": "2025-02-18T18:26:11+00:00",
        "comment_author": "zweckj",
        "comment_body": "info logging is reserverd for the system, use debug",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2046486420",
    "pr_number": 142994,
    "pr_file": "homeassistant/components/volvo/coordinator.py",
    "created_at": "2025-04-16T09:19:48+00:00",
    "commented_code": "+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2046486420",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2046486420",
        "commented_code": "@@ -0,0 +1,217 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
        "comment_created_at": "2025-04-16T09:19:48+00:00",
        "comment_author": "erwindouna",
        "comment_body": "Is this a rightful usage of Exception? Shouldn't this be `_LOGGER.error`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2047258478",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2046486420",
        "commented_code": "@@ -0,0 +1,217 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
        "comment_created_at": "2025-04-16T16:05:03+00:00",
        "comment_author": "thomasddn",
        "comment_body": "I'm not sure, tbh. Don't we want to know what exactly happened?",
        "pr_file_module": null
      },
      {
        "comment_id": "2047258740",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2046486420",
        "commented_code": "@@ -0,0 +1,217 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
        "comment_created_at": "2025-04-16T16:05:13+00:00",
        "comment_author": "ivanfmartinez",
        "comment_body": "As I contributed in some part of this checks here is my comments about this part:\r\n\r\nthis _LOGGER.exception is very usefull to understand some problems  that we got from Volvo API. And that VolvoAuthCondition is one that we must understand what are the real cause.\r\n\r\nIf the Volvo servers are really trustable I agree to use only error, but we still receive strange messages from Volvo servers and this helps to understand. As an example there is an API entrypoint that sometimes return correct result and sometimes 404.\r\n\r\nI suggest to keep this for sometime until Volvo servers return to be stable, and we dont have to understand what is happening on some of the API calls.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2047316464",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2046486420",
        "commented_code": "@@ -0,0 +1,217 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
        "comment_created_at": "2025-04-16T16:33:33+00:00",
        "comment_author": "erwindouna",
        "comment_body": "Do we also know why the Volvo servers are unstable?\nGenerally speaking the exception is used when something truly breaks and can't continue. Is that also the case here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2047337314",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2046486420",
        "commented_code": "@@ -0,0 +1,217 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
        "comment_created_at": "2025-04-16T16:45:07+00:00",
        "comment_author": "thomasddn",
        "comment_body": "> Do we also know why the Volvo servers are unstable?\r\n\r\nNo, not really.\r\n\r\n> Generally speaking the exception is used when something truly breaks and can't continue. Is that also the case here?\r\n\r\nIf a `VolvoAuthException` is raised during the coordinator update cycle, then it means that the token refresh has failed and no data will be retrieved.",
        "pr_file_module": null
      },
      {
        "comment_id": "2047346998",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2046486420",
        "commented_code": "@@ -0,0 +1,217 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
        "comment_created_at": "2025-04-16T16:50:33+00:00",
        "comment_author": "ivanfmartinez",
        "comment_body": "@erwindouna some have tried to contact them without responses. Apparently they have many servers and depends what server responds to your request or what route you take. One time that I got timeouts using my fiber connection I was able to get responses using my starlink. For me the problem with 404 is related to some kind of reverse proxy and backend that is not correctly configured.",
        "pr_file_module": null
      },
      {
        "comment_id": "2090425581",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/coordinator.py",
        "discussion_id": "2046486420",
        "commented_code": "@@ -0,0 +1,217 @@\n+\"\"\"Volvo coordinators.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import Callable, Coroutine\n+from dataclasses import dataclass\n+from datetime import timedelta\n+import logging\n+from typing import Any, cast\n+\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import (\n+    VolvoApiException,\n+    VolvoAuthException,\n+    VolvoCarsApiBaseModel,\n+    VolvoCarsValueField,\n+    VolvoCarsVehicle,\n+)\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import ConfigEntryAuthFailed, HomeAssistantError\n+from homeassistant.helpers.device_registry import DeviceInfo\n+from homeassistant.helpers.update_coordinator import DataUpdateCoordinator, UpdateFailed\n+\n+from .const import DATA_BATTERY_CAPACITY, DOMAIN, MANUFACTURER\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class VolvoData:\n+    \"\"\"Data for Volvo Cars integration.\"\"\"\n+\n+    coordinator: VolvoDataCoordinator\n+\n+\n+type VolvoConfigEntry = ConfigEntry[VolvoData]\n+type CoordinatorData = dict[str, VolvoCarsApiBaseModel | None]\n+\n+\n+class VolvoDataCoordinator(DataUpdateCoordinator[CoordinatorData]):\n+    \"\"\"Volvo Data Coordinator.\"\"\"\n+\n+    config_entry: VolvoConfigEntry\n+\n+    def __init__(\n+        self,\n+        hass: HomeAssistant,\n+        entry: VolvoConfigEntry,\n+        api: VolvoCarsApi,\n+    ) -> None:\n+        \"\"\"Initialize the coordinator.\"\"\"\n+\n+        super().__init__(\n+            hass,\n+            _LOGGER,\n+            config_entry=entry,\n+            name=DOMAIN,\n+            update_interval=timedelta(seconds=135),\n+        )\n+\n+        self.api = api\n+\n+        self.vehicle: VolvoCarsVehicle\n+        self.device: DeviceInfo\n+\n+        # The variable is set during _async_setup().\n+        self._refresh_conditions: dict[\n+            str, tuple[Callable[[], Coroutine[Any, Any, Any]], bool]\n+        ] = {}\n+\n+    async def _async_setup(self) -> None:\n+        \"\"\"Set up the coordinator.\n+\n+        This method is called automatically during\n+        coordinator.async_config_entry_first_refresh.\n+        \"\"\"\n+        _LOGGER.debug(\"%s - Setting up\", self.config_entry.entry_id)\n+\n+        try:\n+            vehicle = await self.api.async_get_vehicle_details()\n+\n+            if vehicle is None:\n+                raise HomeAssistantError(\n+                    translation_domain=DOMAIN, translation_key=\"no_vehicle\"\n+                )\n+\n+        except VolvoAuthException as ex:\n+            raise ConfigEntryAuthFailed(\n+                translation_domain=DOMAIN,\n+                translation_key=\"unauthorized\",\n+                translation_placeholders={\"message\": ex.message},\n+            ) from ex\n+\n+        self.vehicle = vehicle\n+        self.data = self.data or {}\n+\n+        device_name = (\n+            f\"{MANUFACTURER} {vehicle.description.model} {vehicle.model_year}\"\n+            if vehicle.fuel_type == \"NONE\"\n+            else f\"{MANUFACTURER} {vehicle.description.model} {vehicle.fuel_type} {vehicle.model_year}\"\n+        )\n+\n+        self.device = DeviceInfo(\n+            identifiers={(DOMAIN, vehicle.vin)},\n+            manufacturer=MANUFACTURER,\n+            model=f\"{vehicle.description.model} ({vehicle.model_year})\",\n+            name=device_name,\n+            serial_number=vehicle.vin,\n+        )\n+\n+        self.hass.config_entries.async_update_entry(\n+            self.config_entry,\n+            title=f\"{MANUFACTURER} {vehicle.description.model} ({vehicle.vin})\",\n+        )\n+\n+        self._refresh_conditions = {\n+            \"command_accessibility\": (self.api.async_get_command_accessibility, True),\n+            \"diagnostics\": (self.api.async_get_diagnostics, True),\n+            \"fuel\": (\n+                self.api.async_get_fuel_status,\n+                self.vehicle.has_combustion_engine(),\n+            ),\n+            \"odometer\": (self.api.async_get_odometer, True),\n+            \"recharge_status\": (\n+                self.api.async_get_recharge_status,\n+                self.vehicle.has_battery_engine(),\n+            ),\n+            \"statistics\": (self.api.async_get_statistics, True),\n+        }\n+\n+    async def _async_update_data(self) -> CoordinatorData:\n+        \"\"\"Fetch data from API.\"\"\"\n+        _LOGGER.debug(\"%s - Updating data\", self.config_entry.entry_id)\n+\n+        api_calls = self._get_api_calls()\n+        data: CoordinatorData = {}\n+        valid = 0\n+        exception: Exception | None = None\n+\n+        results = await asyncio.gather(\n+            *(call() for call in api_calls), return_exceptions=True\n+        )\n+\n+        for result in results:\n+            if isinstance(result, VolvoAuthException):\n+                # If one result is a VolvoAuthException, then probably all requests\n+                # will fail. In this case we can cancel everything to\n+                # reauthenticate.\n+                #\n+                # Raising ConfigEntryAuthFailed will cancel future updates\n+                # and start a config flow with SOURCE_REAUTH (async_step_reauth)\n+                _LOGGER.exception(",
        "comment_created_at": "2025-05-15T06:57:44+00:00",
        "comment_author": "gjohansson-ST",
        "comment_body": "This seems to be only when we have authentication issues e.g. token expires so I also wonder why we need an exception message then (or any logging at all more than possibly a debug in that case)?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2108902062",
    "pr_number": 138206,
    "pr_file": "homeassistant/components/energyid/config_flow.py",
    "created_at": "2025-05-27T11:11:07+00:00",
    "commented_code": "+\"\"\"Config flow for EnergyID integration.\"\"\"\n+\n+import logging\n+import secrets\n+from typing import Any\n+\n+from aiohttp import ClientError\n+from energyid_webhooks.client_v2 import WebhookClient\n+import voluptuous as vol\n+\n+from homeassistant.config_entries import ConfigEntry, ConfigFlow, ConfigFlowResult\n+from homeassistant.core import callback\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+import homeassistant.helpers.config_validation as cv\n+\n+from . import EnergyIDConfigEntry\n+from .const import (\n+    CONF_DEVICE_ID,\n+    CONF_DEVICE_NAME,\n+    CONF_PROVISIONING_KEY,\n+    CONF_PROVISIONING_SECRET,\n+    DOMAIN,\n+)\n+from .subentry_flow import EnergyIDSubentryFlowHandler\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+DEFAULT_ENERGYID_DEVICE_NAME_FOR_WEBHOOK = \"Home Assistant\"\n+ENERGYID_DEVICE_ID_FOR_WEBHOOK_PREFIX = \"homeassistant_eid_\"\n+\n+\n+def _generate_energyid_device_id_for_webhook() -> str:\n+    \"\"\"Generate a unique device ID for this Home Assistant instance to use with EnergyID webhook.\"\"\"\n+    return f\"{ENERGYID_DEVICE_ID_FOR_WEBHOOK_PREFIX}{secrets.token_hex(4)}\"\n+\n+\n+class EnergyIDConfigFlow(ConfigFlow, domain=DOMAIN):\n+    \"\"\"Handle the configuration flow for the EnergyID integration.\"\"\"\n+\n+    VERSION = 1\n+    _config_entry_being_reconfigured: ConfigEntry | None = None\n+\n+    def __init__(self) -> None:\n+        \"\"\"Initialize the config flow with default flow data.\"\"\"\n+        self._flow_data: dict[str, Any] = {\n+            \"provisioning_key\": None,\n+            \"provisioning_secret\": None,\n+            \"webhook_device_id\": _generate_energyid_device_id_for_webhook(),\n+            \"webhook_device_name\": DEFAULT_ENERGYID_DEVICE_NAME_FOR_WEBHOOK,\n+            \"claim_info\": None,\n+            \"record_number\": None,\n+            \"record_name\": None,\n+        }\n+\n+    async def _perform_auth_and_get_details(self) -> str | None:\n+        \"\"\"Authenticate with EnergyID and retrieve device details.\"\"\"\n+        if (\n+            not self._flow_data[\"provisioning_key\"]\n+            or not self._flow_data[\"provisioning_secret\"]\n+        ):\n+            _LOGGER.error(\"Missing credentials for authentication\")\n+            return \"missing_credentials\"\n+\n+        _LOGGER.debug(\n+            \"Attempting authentication with device ID: %s, device name: %s\",\n+            self._flow_data[\"webhook_device_id\"],\n+            self._flow_data[\"webhook_device_name\"],\n+        )\n+\n+        session = async_get_clientsession(self.hass)\n+        client = WebhookClient(\n+            provisioning_key=self._flow_data[\"provisioning_key\"],\n+            provisioning_secret=self._flow_data[\"provisioning_secret\"],\n+            device_id=self._flow_data[\"webhook_device_id\"],\n+            device_name=self._flow_data[\"webhook_device_name\"],\n+            session=session,\n+        )\n+\n+        try:\n+            is_claimed = await client.authenticate()\n+        except ClientError:\n+            _LOGGER.warning(\n+                \"Connection error during EnergyID authentication\", exc_info=True\n+            )\n+            return \"cannot_connect\"\n+        except RuntimeError:\n+            _LOGGER.exception(\"Unexpected runtime error during EnergyID authentication\")\n+            return \"unknown_auth_error\"\n+\n+        if is_claimed:\n+            self._flow_data[\"record_number\"] = client.recordNumber\n+            self._flow_data[\"record_name\"] = client.recordName\n+            self._flow_data[\"claim_info\"] = None\n+            _LOGGER.info(",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2108902062",
        "repo_full_name": "home-assistant/core",
        "pr_number": 138206,
        "pr_file": "homeassistant/components/energyid/config_flow.py",
        "discussion_id": "2108902062",
        "commented_code": "@@ -0,0 +1,365 @@\n+\"\"\"Config flow for EnergyID integration.\"\"\"\n+\n+import logging\n+import secrets\n+from typing import Any\n+\n+from aiohttp import ClientError\n+from energyid_webhooks.client_v2 import WebhookClient\n+import voluptuous as vol\n+\n+from homeassistant.config_entries import ConfigEntry, ConfigFlow, ConfigFlowResult\n+from homeassistant.core import callback\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+import homeassistant.helpers.config_validation as cv\n+\n+from . import EnergyIDConfigEntry\n+from .const import (\n+    CONF_DEVICE_ID,\n+    CONF_DEVICE_NAME,\n+    CONF_PROVISIONING_KEY,\n+    CONF_PROVISIONING_SECRET,\n+    DOMAIN,\n+)\n+from .subentry_flow import EnergyIDSubentryFlowHandler\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+DEFAULT_ENERGYID_DEVICE_NAME_FOR_WEBHOOK = \"Home Assistant\"\n+ENERGYID_DEVICE_ID_FOR_WEBHOOK_PREFIX = \"homeassistant_eid_\"\n+\n+\n+def _generate_energyid_device_id_for_webhook() -> str:\n+    \"\"\"Generate a unique device ID for this Home Assistant instance to use with EnergyID webhook.\"\"\"\n+    return f\"{ENERGYID_DEVICE_ID_FOR_WEBHOOK_PREFIX}{secrets.token_hex(4)}\"\n+\n+\n+class EnergyIDConfigFlow(ConfigFlow, domain=DOMAIN):\n+    \"\"\"Handle the configuration flow for the EnergyID integration.\"\"\"\n+\n+    VERSION = 1\n+    _config_entry_being_reconfigured: ConfigEntry | None = None\n+\n+    def __init__(self) -> None:\n+        \"\"\"Initialize the config flow with default flow data.\"\"\"\n+        self._flow_data: dict[str, Any] = {\n+            \"provisioning_key\": None,\n+            \"provisioning_secret\": None,\n+            \"webhook_device_id\": _generate_energyid_device_id_for_webhook(),\n+            \"webhook_device_name\": DEFAULT_ENERGYID_DEVICE_NAME_FOR_WEBHOOK,\n+            \"claim_info\": None,\n+            \"record_number\": None,\n+            \"record_name\": None,\n+        }\n+\n+    async def _perform_auth_and_get_details(self) -> str | None:\n+        \"\"\"Authenticate with EnergyID and retrieve device details.\"\"\"\n+        if (\n+            not self._flow_data[\"provisioning_key\"]\n+            or not self._flow_data[\"provisioning_secret\"]\n+        ):\n+            _LOGGER.error(\"Missing credentials for authentication\")\n+            return \"missing_credentials\"\n+\n+        _LOGGER.debug(\n+            \"Attempting authentication with device ID: %s, device name: %s\",\n+            self._flow_data[\"webhook_device_id\"],\n+            self._flow_data[\"webhook_device_name\"],\n+        )\n+\n+        session = async_get_clientsession(self.hass)\n+        client = WebhookClient(\n+            provisioning_key=self._flow_data[\"provisioning_key\"],\n+            provisioning_secret=self._flow_data[\"provisioning_secret\"],\n+            device_id=self._flow_data[\"webhook_device_id\"],\n+            device_name=self._flow_data[\"webhook_device_name\"],\n+            session=session,\n+        )\n+\n+        try:\n+            is_claimed = await client.authenticate()\n+        except ClientError:\n+            _LOGGER.warning(\n+                \"Connection error during EnergyID authentication\", exc_info=True\n+            )\n+            return \"cannot_connect\"\n+        except RuntimeError:\n+            _LOGGER.exception(\"Unexpected runtime error during EnergyID authentication\")\n+            return \"unknown_auth_error\"\n+\n+        if is_claimed:\n+            self._flow_data[\"record_number\"] = client.recordNumber\n+            self._flow_data[\"record_name\"] = client.recordName\n+            self._flow_data[\"claim_info\"] = None\n+            _LOGGER.info(",
        "comment_created_at": "2025-05-27T11:11:07+00:00",
        "comment_author": "zweckj",
        "comment_body": "```suggestion\r\n            _LOGGER.debug(\r\n```\r\ninfo is reserved for the system",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2210308657",
    "pr_number": 138206,
    "pr_file": "homeassistant/components/energyid/__init__.py",
    "created_at": "2025-07-16T12:49:27+00:00",
    "commented_code": "+\"\"\"The EnergyID integration.\"\"\"\n+\n+import datetime as dt\n+import functools\n+import logging\n+from typing import Any, Final, TypeVar\n+\n+from energyid_webhooks.client_v2 import WebhookClient\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import (\n+    EVENT_HOMEASSISTANT_STOP,\n+    STATE_UNAVAILABLE,\n+    STATE_UNKNOWN,\n+    Platform,\n+)\n+from homeassistant.core import CALLBACK_TYPE, Event, HomeAssistant, callback\n+from homeassistant.exceptions import ConfigEntryNotReady\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+from homeassistant.helpers.dispatcher import async_dispatcher_send\n+from homeassistant.helpers.event import async_track_state_change_event\n+\n+from .const import (\n+    CONF_DEVICE_ID,\n+    CONF_DEVICE_NAME,\n+    CONF_ENERGYID_KEY,\n+    CONF_HA_ENTITY_ID,\n+    CONF_PROVISIONING_KEY,\n+    CONF_PROVISIONING_SECRET,\n+    DATA_CLIENT,\n+    DATA_LISTENERS,\n+    DATA_MAPPINGS,\n+    DEFAULT_UPLOAD_INTERVAL_SECONDS,\n+    DOMAIN,\n+    SIGNAL_CONFIG_ENTRY_CHANGED,\n+)\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+PLATFORMS: list[Platform] = [Platform.SENSOR]\n+\n+# Custom type for the EnergyID config entry\n+EnergyIDClientT = TypeVar(\"EnergyIDClientT\", bound=WebhookClient)\n+EnergyIDConfigEntry = ConfigEntry[EnergyIDClientT]\n+# Listener keys\n+LISTENER_KEY_STATE: Final = \"state_listener\"\n+LISTENER_KEY_STOP: Final = \"stop_listener\"\n+LISTENER_KEY_CONFIG_UPDATE: Final = \"config_update_listener\"\n+\n+\n+async def async_setup_entry(hass: HomeAssistant, entry: EnergyIDConfigEntry) -> bool:\n+    \"\"\"Set up EnergyID from a config entry.\"\"\"\n+    domain_data = hass.data.setdefault(DOMAIN, {}).setdefault(entry.entry_id, {})\n+\n+    # Initialize listeners as a dictionary\n+    listeners: dict[str, CALLBACK_TYPE] = {}\n+    domain_data[DATA_LISTENERS] = listeners\n+    domain_data[DATA_MAPPINGS] = {}\n+\n+    session = async_get_clientsession(hass)\n+    client = WebhookClient(\n+        provisioning_key=entry.data[CONF_PROVISIONING_KEY],\n+        provisioning_secret=entry.data[CONF_PROVISIONING_SECRET],\n+        device_id=entry.data[CONF_DEVICE_ID],\n+        device_name=entry.data[CONF_DEVICE_NAME],\n+        session=session,\n+    )\n+\n+    # Set the client in runtime_data\n+    entry.runtime_data = client\n+\n+    # Also keep in domain_data for backward compatibility\n+    domain_data[DATA_CLIENT] = client\n+\n+    @callback\n+    def _cleanup_all_listeners() -> None:\n+        \"\"\"Remove all listeners associated with this entry.\"\"\"\n+        _LOGGER.debug(\"Cleaning up all listeners for %s\", entry.entry_id)\n+        if unsub := listeners.pop(LISTENER_KEY_STATE, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_STOP, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_CONFIG_UPDATE, None):\n+            unsub()\n+        domain_data[DATA_LISTENERS] = {}\n+\n+    async def _close_entry_client(*_: Any) -> None:\n+        _LOGGER.debug(\"Closing EnergyID client for %s\", entry.runtime_data.device_name)\n+        await entry.runtime_data.close()\n+\n+    entry.async_on_unload(_cleanup_all_listeners)\n+    entry.async_on_unload(_close_entry_client)\n+\n+    async def _hass_stopping_cleanup(_event: Event) -> None:\n+        _LOGGER.debug(\n+            \"Home Assistant stopping; ensuring client for %s is closed\",\n+            entry.runtime_data.device_name,\n+        )\n+        await entry.runtime_data.close()\n+        listeners.pop(LISTENER_KEY_STOP, None)\n+\n+    listeners[LISTENER_KEY_STOP] = hass.bus.async_listen_once(\n+        EVENT_HOMEASSISTANT_STOP, _hass_stopping_cleanup\n+    )\n+\n+    try:\n+        is_claimed = await entry.runtime_data.authenticate()\n+        if not is_claimed:\n+            _LOGGER.warning(\n+                \"EnergyID device '%s' is not claimed. Please claim it. \"\n+                \"Data sending will not work until claimed and HA is reloaded/entry reloaded\",\n+                entry.runtime_data.device_name,\n+            )\n+        else:\n+            _LOGGER.info(\n+                \"EnergyID device '%s' authenticated and claimed\",\n+                entry.runtime_data.device_name,\n+            )\n+    except Exception as err:\n+        _LOGGER.error(\n+            \"Failed to authenticate with EnergyID for %s: %s\",\n+            entry.runtime_data.device_name,\n+            err,\n+        )\n+        raise ConfigEntryNotReady(\n+            translation_domain=DOMAIN,\n+            translation_key=\"auth_failed_on_setup\",\n+            translation_placeholders={\n+                \"device_name\": entry.runtime_data.device_name,\n+                \"error_details\": str(err),\n+            },\n+        ) from err\n+\n+    # Set up listeners for existing subentries\n+    await async_update_listeners(hass, entry)\n+\n+    # Add listener for config entry updates (including subentry changes)\n+    listeners[LISTENER_KEY_CONFIG_UPDATE] = entry.add_update_listener(\n+        async_config_entry_update_listener\n+    )\n+\n+    # Start auto-sync if device is claimed\n+    if is_claimed:\n+        upload_interval = DEFAULT_UPLOAD_INTERVAL_SECONDS\n+        if entry.runtime_data.webhook_policy:\n+            upload_interval = (\n+                entry.runtime_data.webhook_policy.get(\"uploadInterval\")\n+                or DEFAULT_UPLOAD_INTERVAL_SECONDS\n+            )\n+        _LOGGER.info(",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2210308657",
        "repo_full_name": "home-assistant/core",
        "pr_number": 138206,
        "pr_file": "homeassistant/components/energyid/__init__.py",
        "discussion_id": "2210308657",
        "commented_code": "@@ -0,0 +1,427 @@\n+\"\"\"The EnergyID integration.\"\"\"\n+\n+import datetime as dt\n+import functools\n+import logging\n+from typing import Any, Final, TypeVar\n+\n+from energyid_webhooks.client_v2 import WebhookClient\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import (\n+    EVENT_HOMEASSISTANT_STOP,\n+    STATE_UNAVAILABLE,\n+    STATE_UNKNOWN,\n+    Platform,\n+)\n+from homeassistant.core import CALLBACK_TYPE, Event, HomeAssistant, callback\n+from homeassistant.exceptions import ConfigEntryNotReady\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+from homeassistant.helpers.dispatcher import async_dispatcher_send\n+from homeassistant.helpers.event import async_track_state_change_event\n+\n+from .const import (\n+    CONF_DEVICE_ID,\n+    CONF_DEVICE_NAME,\n+    CONF_ENERGYID_KEY,\n+    CONF_HA_ENTITY_ID,\n+    CONF_PROVISIONING_KEY,\n+    CONF_PROVISIONING_SECRET,\n+    DATA_CLIENT,\n+    DATA_LISTENERS,\n+    DATA_MAPPINGS,\n+    DEFAULT_UPLOAD_INTERVAL_SECONDS,\n+    DOMAIN,\n+    SIGNAL_CONFIG_ENTRY_CHANGED,\n+)\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+PLATFORMS: list[Platform] = [Platform.SENSOR]\n+\n+# Custom type for the EnergyID config entry\n+EnergyIDClientT = TypeVar(\"EnergyIDClientT\", bound=WebhookClient)\n+EnergyIDConfigEntry = ConfigEntry[EnergyIDClientT]\n+# Listener keys\n+LISTENER_KEY_STATE: Final = \"state_listener\"\n+LISTENER_KEY_STOP: Final = \"stop_listener\"\n+LISTENER_KEY_CONFIG_UPDATE: Final = \"config_update_listener\"\n+\n+\n+async def async_setup_entry(hass: HomeAssistant, entry: EnergyIDConfigEntry) -> bool:\n+    \"\"\"Set up EnergyID from a config entry.\"\"\"\n+    domain_data = hass.data.setdefault(DOMAIN, {}).setdefault(entry.entry_id, {})\n+\n+    # Initialize listeners as a dictionary\n+    listeners: dict[str, CALLBACK_TYPE] = {}\n+    domain_data[DATA_LISTENERS] = listeners\n+    domain_data[DATA_MAPPINGS] = {}\n+\n+    session = async_get_clientsession(hass)\n+    client = WebhookClient(\n+        provisioning_key=entry.data[CONF_PROVISIONING_KEY],\n+        provisioning_secret=entry.data[CONF_PROVISIONING_SECRET],\n+        device_id=entry.data[CONF_DEVICE_ID],\n+        device_name=entry.data[CONF_DEVICE_NAME],\n+        session=session,\n+    )\n+\n+    # Set the client in runtime_data\n+    entry.runtime_data = client\n+\n+    # Also keep in domain_data for backward compatibility\n+    domain_data[DATA_CLIENT] = client\n+\n+    @callback\n+    def _cleanup_all_listeners() -> None:\n+        \"\"\"Remove all listeners associated with this entry.\"\"\"\n+        _LOGGER.debug(\"Cleaning up all listeners for %s\", entry.entry_id)\n+        if unsub := listeners.pop(LISTENER_KEY_STATE, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_STOP, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_CONFIG_UPDATE, None):\n+            unsub()\n+        domain_data[DATA_LISTENERS] = {}\n+\n+    async def _close_entry_client(*_: Any) -> None:\n+        _LOGGER.debug(\"Closing EnergyID client for %s\", entry.runtime_data.device_name)\n+        await entry.runtime_data.close()\n+\n+    entry.async_on_unload(_cleanup_all_listeners)\n+    entry.async_on_unload(_close_entry_client)\n+\n+    async def _hass_stopping_cleanup(_event: Event) -> None:\n+        _LOGGER.debug(\n+            \"Home Assistant stopping; ensuring client for %s is closed\",\n+            entry.runtime_data.device_name,\n+        )\n+        await entry.runtime_data.close()\n+        listeners.pop(LISTENER_KEY_STOP, None)\n+\n+    listeners[LISTENER_KEY_STOP] = hass.bus.async_listen_once(\n+        EVENT_HOMEASSISTANT_STOP, _hass_stopping_cleanup\n+    )\n+\n+    try:\n+        is_claimed = await entry.runtime_data.authenticate()\n+        if not is_claimed:\n+            _LOGGER.warning(\n+                \"EnergyID device '%s' is not claimed. Please claim it. \"\n+                \"Data sending will not work until claimed and HA is reloaded/entry reloaded\",\n+                entry.runtime_data.device_name,\n+            )\n+        else:\n+            _LOGGER.info(\n+                \"EnergyID device '%s' authenticated and claimed\",\n+                entry.runtime_data.device_name,\n+            )\n+    except Exception as err:\n+        _LOGGER.error(\n+            \"Failed to authenticate with EnergyID for %s: %s\",\n+            entry.runtime_data.device_name,\n+            err,\n+        )\n+        raise ConfigEntryNotReady(\n+            translation_domain=DOMAIN,\n+            translation_key=\"auth_failed_on_setup\",\n+            translation_placeholders={\n+                \"device_name\": entry.runtime_data.device_name,\n+                \"error_details\": str(err),\n+            },\n+        ) from err\n+\n+    # Set up listeners for existing subentries\n+    await async_update_listeners(hass, entry)\n+\n+    # Add listener for config entry updates (including subentry changes)\n+    listeners[LISTENER_KEY_CONFIG_UPDATE] = entry.add_update_listener(\n+        async_config_entry_update_listener\n+    )\n+\n+    # Start auto-sync if device is claimed\n+    if is_claimed:\n+        upload_interval = DEFAULT_UPLOAD_INTERVAL_SECONDS\n+        if entry.runtime_data.webhook_policy:\n+            upload_interval = (\n+                entry.runtime_data.webhook_policy.get(\"uploadInterval\")\n+                or DEFAULT_UPLOAD_INTERVAL_SECONDS\n+            )\n+        _LOGGER.info(",
        "comment_created_at": "2025-07-16T12:49:27+00:00",
        "comment_author": "zweckj",
        "comment_body": "info is reserved for the system, use debug",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1988736001",
    "pr_number": 135844,
    "pr_file": "homeassistant/components/backup_sftp/backup.py",
    "created_at": "2025-03-11T09:00:47+00:00",
    "commented_code": "+\"\"\"Backup platform for the SFTP Backup Storage integration.\"\"\"\n+\n+from __future__ import annotations\n+\n+from collections.abc import AsyncIterator, Callable, Coroutine\n+from typing import Any\n+\n+from asyncssh.sftp import SFTPError\n+\n+from homeassistant.components.backup import AgentBackup, BackupAgent, BackupAgentError\n+from homeassistant.core import HomeAssistant, callback\n+\n+from . import SFTPConfigEntry\n+from .client import BackupAgentClient\n+from .const import DATA_BACKUP_AGENT_LISTENERS, DOMAIN, LOGGER\n+\n+\n+async def async_get_backup_agents(\n+    hass: HomeAssistant,\n+) -> list[BackupAgent]:\n+    \"\"\"Register the backup agents.\"\"\"\n+    entries: list[SFTPConfigEntry] = hass.config_entries.async_entries(DOMAIN)\n+    return [SFTPBackupAgent(hass, entry) for entry in entries]\n+\n+\n+@callback\n+def async_register_backup_agents_listener(\n+    hass: HomeAssistant,\n+    *,\n+    listener: Callable[[], None],\n+    **kwargs: Any,\n+) -> Callable[[], None]:\n+    \"\"\"Register a listener to be called when agents are added or removed.\"\"\"\n+    hass.data.setdefault(DATA_BACKUP_AGENT_LISTENERS, []).append(listener)\n+\n+    @callback\n+    def remove_listener() -> None:\n+        \"\"\"Remove the listener.\"\"\"\n+        hass.data[DATA_BACKUP_AGENT_LISTENERS].remove(listener)\n+\n+    return remove_listener\n+\n+\n+class SFTPBackupAgent(BackupAgent):\n+    \"\"\"SFTP Backup agent.\"\"\"\n+\n+    domain = DOMAIN\n+\n+    def __init__(self, hass: HomeAssistant, entry: SFTPConfigEntry) -> None:\n+        \"\"\"Initialize the SFTPBackupAgent backup sync agent.\"\"\"\n+        super().__init__()\n+        self._entry = entry\n+        self._hass = hass\n+        self.name = entry.title\n+        self.unique_id = self._entry.unique_id\n+\n+    async def async_download_backup(\n+        self,\n+        backup_id: str,\n+        **kwargs: Any,\n+    ) -> AsyncIterator[bytes]:\n+        \"\"\"Download a backup file from SFTP.\"\"\"\n+        LOGGER.debug(\"Received request to download backup id: %s\", backup_id)\n+        try:\n+            backup = await self.async_get_backup(backup_id)\n+            LOGGER.debug(\n+                \"Establishing SFTP connection to remote host in order to download backup\"\n+            )\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                return await client.iter_file(backup)\n+        except (AssertionError, FileNotFoundError) as e:\n+            raise BackupAgentError(\n+                f\"Unable to initiate download of backup id: {backup_id}. {e}\"\n+            ) from e\n+        except Exception as e:\n+            raise BackupAgentError(\n+                f\"Unexpected error while initiating download of backup id: {backup_id}. {e}\"\n+            ) from e\n+\n+    async def async_upload_backup(\n+        self,\n+        *,\n+        open_stream: Callable[[], Coroutine[Any, Any, AsyncIterator[bytes]]],\n+        backup: AgentBackup,\n+        **kwargs: Any,\n+    ) -> None:\n+        \"\"\"Upload a backup.\"\"\"\n+        LOGGER.debug(\"Received request to upload backup: %s\", backup)\n+        iterator = await open_stream()\n+\n+        try:\n+            LOGGER.debug(\n+                \"Establishing SFTP connection to remote host in order to upload backup\"\n+            )\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                LOGGER.debug(\"Uploading backup: %s\", backup.backup_id)\n+                await client.async_upload_backup(iterator, backup)\n+        except Exception as e:\n+            raise BackupAgentError(\n+                f\"Failed to upload backup to remote SFTP location. Error: {e}\"\n+            ) from e\n+        LOGGER.debug(\"Successfully uploaded backup id: %s\", backup.backup_id)\n+\n+    async def async_delete_backup(\n+        self,\n+        backup_id: str,\n+        **kwargs: Any,\n+    ) -> None:\n+        \"\"\"Delete a backup file from SFTP Backup Storage.\"\"\"\n+        LOGGER.debug(\"Received request to delete backup id: %s\", backup_id)\n+\n+        try:\n+            backup = await self.async_get_backup(backup_id)\n+            LOGGER.debug(\n+                \"Establishing SFTP connection to remote host in order to delete backup\"\n+            )\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                await client.async_delete_backup(backup)\n+        except (AssertionError, SFTPError) as err:\n+            raise BackupAgentError(\n+                f\"Failed to delete backup id: {backup_id}: {err}\"\n+            ) from err\n+        except Exception as err:\n+            raise BackupAgentError(\n+                f\"Unexpected error while removing backup: {backup_id}: {err}\"\n+            ) from err\n+\n+        LOGGER.debug(\"Successfully removed backup id: %s\", backup_id)\n+\n+    async def async_list_backups(self, **kwargs: Any) -> list[AgentBackup]:\n+        \"\"\"List backups stored on SFTP Storage.\"\"\"\n+        try:\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                return await client.async_list_backups()\n+        except Exception as e:\n+            LOGGER.exception(e)\n+            LOGGER.error(\n+                \"Listing backups failed. Please review previous exception traceback\"\n+            )",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "1988736001",
        "repo_full_name": "home-assistant/core",
        "pr_number": 135844,
        "pr_file": "homeassistant/components/backup_sftp/backup.py",
        "discussion_id": "1988736001",
        "commented_code": "@@ -0,0 +1,155 @@\n+\"\"\"Backup platform for the SFTP Backup Storage integration.\"\"\"\n+\n+from __future__ import annotations\n+\n+from collections.abc import AsyncIterator, Callable, Coroutine\n+from typing import Any\n+\n+from asyncssh.sftp import SFTPError\n+\n+from homeassistant.components.backup import AgentBackup, BackupAgent, BackupAgentError\n+from homeassistant.core import HomeAssistant, callback\n+\n+from . import SFTPConfigEntry\n+from .client import BackupAgentClient\n+from .const import DATA_BACKUP_AGENT_LISTENERS, DOMAIN, LOGGER\n+\n+\n+async def async_get_backup_agents(\n+    hass: HomeAssistant,\n+) -> list[BackupAgent]:\n+    \"\"\"Register the backup agents.\"\"\"\n+    entries: list[SFTPConfigEntry] = hass.config_entries.async_entries(DOMAIN)\n+    return [SFTPBackupAgent(hass, entry) for entry in entries]\n+\n+\n+@callback\n+def async_register_backup_agents_listener(\n+    hass: HomeAssistant,\n+    *,\n+    listener: Callable[[], None],\n+    **kwargs: Any,\n+) -> Callable[[], None]:\n+    \"\"\"Register a listener to be called when agents are added or removed.\"\"\"\n+    hass.data.setdefault(DATA_BACKUP_AGENT_LISTENERS, []).append(listener)\n+\n+    @callback\n+    def remove_listener() -> None:\n+        \"\"\"Remove the listener.\"\"\"\n+        hass.data[DATA_BACKUP_AGENT_LISTENERS].remove(listener)\n+\n+    return remove_listener\n+\n+\n+class SFTPBackupAgent(BackupAgent):\n+    \"\"\"SFTP Backup agent.\"\"\"\n+\n+    domain = DOMAIN\n+\n+    def __init__(self, hass: HomeAssistant, entry: SFTPConfigEntry) -> None:\n+        \"\"\"Initialize the SFTPBackupAgent backup sync agent.\"\"\"\n+        super().__init__()\n+        self._entry = entry\n+        self._hass = hass\n+        self.name = entry.title\n+        self.unique_id = self._entry.unique_id\n+\n+    async def async_download_backup(\n+        self,\n+        backup_id: str,\n+        **kwargs: Any,\n+    ) -> AsyncIterator[bytes]:\n+        \"\"\"Download a backup file from SFTP.\"\"\"\n+        LOGGER.debug(\"Received request to download backup id: %s\", backup_id)\n+        try:\n+            backup = await self.async_get_backup(backup_id)\n+            LOGGER.debug(\n+                \"Establishing SFTP connection to remote host in order to download backup\"\n+            )\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                return await client.iter_file(backup)\n+        except (AssertionError, FileNotFoundError) as e:\n+            raise BackupAgentError(\n+                f\"Unable to initiate download of backup id: {backup_id}. {e}\"\n+            ) from e\n+        except Exception as e:\n+            raise BackupAgentError(\n+                f\"Unexpected error while initiating download of backup id: {backup_id}. {e}\"\n+            ) from e\n+\n+    async def async_upload_backup(\n+        self,\n+        *,\n+        open_stream: Callable[[], Coroutine[Any, Any, AsyncIterator[bytes]]],\n+        backup: AgentBackup,\n+        **kwargs: Any,\n+    ) -> None:\n+        \"\"\"Upload a backup.\"\"\"\n+        LOGGER.debug(\"Received request to upload backup: %s\", backup)\n+        iterator = await open_stream()\n+\n+        try:\n+            LOGGER.debug(\n+                \"Establishing SFTP connection to remote host in order to upload backup\"\n+            )\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                LOGGER.debug(\"Uploading backup: %s\", backup.backup_id)\n+                await client.async_upload_backup(iterator, backup)\n+        except Exception as e:\n+            raise BackupAgentError(\n+                f\"Failed to upload backup to remote SFTP location. Error: {e}\"\n+            ) from e\n+        LOGGER.debug(\"Successfully uploaded backup id: %s\", backup.backup_id)\n+\n+    async def async_delete_backup(\n+        self,\n+        backup_id: str,\n+        **kwargs: Any,\n+    ) -> None:\n+        \"\"\"Delete a backup file from SFTP Backup Storage.\"\"\"\n+        LOGGER.debug(\"Received request to delete backup id: %s\", backup_id)\n+\n+        try:\n+            backup = await self.async_get_backup(backup_id)\n+            LOGGER.debug(\n+                \"Establishing SFTP connection to remote host in order to delete backup\"\n+            )\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                await client.async_delete_backup(backup)\n+        except (AssertionError, SFTPError) as err:\n+            raise BackupAgentError(\n+                f\"Failed to delete backup id: {backup_id}: {err}\"\n+            ) from err\n+        except Exception as err:\n+            raise BackupAgentError(\n+                f\"Unexpected error while removing backup: {backup_id}: {err}\"\n+            ) from err\n+\n+        LOGGER.debug(\"Successfully removed backup id: %s\", backup_id)\n+\n+    async def async_list_backups(self, **kwargs: Any) -> list[AgentBackup]:\n+        \"\"\"List backups stored on SFTP Storage.\"\"\"\n+        try:\n+            async with BackupAgentClient(self._entry, self._hass) as client:\n+                return await client.async_list_backups()\n+        except Exception as e:\n+            LOGGER.exception(e)\n+            LOGGER.error(\n+                \"Listing backups failed. Please review previous exception traceback\"\n+            )",
        "comment_created_at": "2025-03-11T09:00:47+00:00",
        "comment_author": "zweckj",
        "comment_body": "```suggestion\r\n            LOGGER.exception(\"Listing backups failed.\")\r\n```\r\ndon't log both an error and a exception",
        "pr_file_module": null
      }
    ]
  }
]