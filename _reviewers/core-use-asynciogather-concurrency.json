[
  {
    "discussion_id": "2163108834",
    "pr_number": 142994,
    "pr_file": "homeassistant/components/volvo/__init__.py",
    "created_at": "2025-06-24T06:55:16+00:00",
    "commented_code": "+\"\"\"The Volvo integration.\"\"\"\n+\n+from __future__ import annotations\n+\n+from aiohttp import ClientResponseError\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoAuthException, VolvoCarsVehicle\n+\n+from homeassistant.const import CONF_API_KEY\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import (\n+    ConfigEntryAuthFailed,\n+    ConfigEntryError,\n+    ConfigEntryNotReady,\n+)\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+from homeassistant.helpers.config_entry_oauth2_flow import (\n+    OAuth2Session,\n+    async_get_config_entry_implementation,\n+)\n+\n+from .api import VolvoAuth\n+from .const import CONF_VIN, DOMAIN, PLATFORMS\n+from .coordinator import (\n+    VolvoConfigEntry,\n+    VolvoMediumIntervalCoordinator,\n+    VolvoSlowIntervalCoordinator,\n+    VolvoVerySlowIntervalCoordinator,\n+)\n+\n+\n+async def async_setup_entry(hass: HomeAssistant, entry: VolvoConfigEntry) -> bool:\n+    \"\"\"Set up Volvo from a config entry.\"\"\"\n+\n+    api = await _async_auth_and_create_api(hass, entry)\n+    vehicle = await _async_load_vehicle(api)\n+\n+    coordinators = (\n+        VolvoVerySlowIntervalCoordinator(hass, entry, api, vehicle),\n+        VolvoSlowIntervalCoordinator(hass, entry, api, vehicle),\n+        VolvoMediumIntervalCoordinator(hass, entry, api, vehicle),\n+    )\n+\n+    for coordinator in coordinators:\n+        await coordinator.async_config_entry_first_refresh()",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2163108834",
        "repo_full_name": "home-assistant/core",
        "pr_number": 142994,
        "pr_file": "homeassistant/components/volvo/__init__.py",
        "discussion_id": "2163108834",
        "commented_code": "@@ -0,0 +1,95 @@\n+\"\"\"The Volvo integration.\"\"\"\n+\n+from __future__ import annotations\n+\n+from aiohttp import ClientResponseError\n+from volvocarsapi.api import VolvoCarsApi\n+from volvocarsapi.models import VolvoAuthException, VolvoCarsVehicle\n+\n+from homeassistant.const import CONF_API_KEY\n+from homeassistant.core import HomeAssistant\n+from homeassistant.exceptions import (\n+    ConfigEntryAuthFailed,\n+    ConfigEntryError,\n+    ConfigEntryNotReady,\n+)\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+from homeassistant.helpers.config_entry_oauth2_flow import (\n+    OAuth2Session,\n+    async_get_config_entry_implementation,\n+)\n+\n+from .api import VolvoAuth\n+from .const import CONF_VIN, DOMAIN, PLATFORMS\n+from .coordinator import (\n+    VolvoConfigEntry,\n+    VolvoMediumIntervalCoordinator,\n+    VolvoSlowIntervalCoordinator,\n+    VolvoVerySlowIntervalCoordinator,\n+)\n+\n+\n+async def async_setup_entry(hass: HomeAssistant, entry: VolvoConfigEntry) -> bool:\n+    \"\"\"Set up Volvo from a config entry.\"\"\"\n+\n+    api = await _async_auth_and_create_api(hass, entry)\n+    vehicle = await _async_load_vehicle(api)\n+\n+    coordinators = (\n+        VolvoVerySlowIntervalCoordinator(hass, entry, api, vehicle),\n+        VolvoSlowIntervalCoordinator(hass, entry, api, vehicle),\n+        VolvoMediumIntervalCoordinator(hass, entry, api, vehicle),\n+    )\n+\n+    for coordinator in coordinators:\n+        await coordinator.async_config_entry_first_refresh()",
        "comment_created_at": "2025-06-24T06:55:16+00:00",
        "comment_author": "zweckj",
        "comment_body": "can we parallelize with `asyncio.gather` to speed up setup a bit?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2210321411",
    "pr_number": 138206,
    "pr_file": "homeassistant/components/energyid/__init__.py",
    "created_at": "2025-07-16T12:53:35+00:00",
    "commented_code": "+\"\"\"The EnergyID integration.\"\"\"\n+\n+import datetime as dt\n+import functools\n+import logging\n+from typing import Any, Final, TypeVar\n+\n+from energyid_webhooks.client_v2 import WebhookClient\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import (\n+    EVENT_HOMEASSISTANT_STOP,\n+    STATE_UNAVAILABLE,\n+    STATE_UNKNOWN,\n+    Platform,\n+)\n+from homeassistant.core import CALLBACK_TYPE, Event, HomeAssistant, callback\n+from homeassistant.exceptions import ConfigEntryNotReady\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+from homeassistant.helpers.dispatcher import async_dispatcher_send\n+from homeassistant.helpers.event import async_track_state_change_event\n+\n+from .const import (\n+    CONF_DEVICE_ID,\n+    CONF_DEVICE_NAME,\n+    CONF_ENERGYID_KEY,\n+    CONF_HA_ENTITY_ID,\n+    CONF_PROVISIONING_KEY,\n+    CONF_PROVISIONING_SECRET,\n+    DATA_CLIENT,\n+    DATA_LISTENERS,\n+    DATA_MAPPINGS,\n+    DEFAULT_UPLOAD_INTERVAL_SECONDS,\n+    DOMAIN,\n+    SIGNAL_CONFIG_ENTRY_CHANGED,\n+)\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+PLATFORMS: list[Platform] = [Platform.SENSOR]\n+\n+# Custom type for the EnergyID config entry\n+EnergyIDClientT = TypeVar(\"EnergyIDClientT\", bound=WebhookClient)\n+EnergyIDConfigEntry = ConfigEntry[EnergyIDClientT]\n+# Listener keys\n+LISTENER_KEY_STATE: Final = \"state_listener\"\n+LISTENER_KEY_STOP: Final = \"stop_listener\"\n+LISTENER_KEY_CONFIG_UPDATE: Final = \"config_update_listener\"\n+\n+\n+async def async_setup_entry(hass: HomeAssistant, entry: EnergyIDConfigEntry) -> bool:\n+    \"\"\"Set up EnergyID from a config entry.\"\"\"\n+    domain_data = hass.data.setdefault(DOMAIN, {}).setdefault(entry.entry_id, {})\n+\n+    # Initialize listeners as a dictionary\n+    listeners: dict[str, CALLBACK_TYPE] = {}\n+    domain_data[DATA_LISTENERS] = listeners\n+    domain_data[DATA_MAPPINGS] = {}\n+\n+    session = async_get_clientsession(hass)\n+    client = WebhookClient(\n+        provisioning_key=entry.data[CONF_PROVISIONING_KEY],\n+        provisioning_secret=entry.data[CONF_PROVISIONING_SECRET],\n+        device_id=entry.data[CONF_DEVICE_ID],\n+        device_name=entry.data[CONF_DEVICE_NAME],\n+        session=session,\n+    )\n+\n+    # Set the client in runtime_data\n+    entry.runtime_data = client\n+\n+    # Also keep in domain_data for backward compatibility\n+    domain_data[DATA_CLIENT] = client\n+\n+    @callback\n+    def _cleanup_all_listeners() -> None:\n+        \"\"\"Remove all listeners associated with this entry.\"\"\"\n+        _LOGGER.debug(\"Cleaning up all listeners for %s\", entry.entry_id)\n+        if unsub := listeners.pop(LISTENER_KEY_STATE, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_STOP, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_CONFIG_UPDATE, None):\n+            unsub()\n+        domain_data[DATA_LISTENERS] = {}\n+\n+    async def _close_entry_client(*_: Any) -> None:\n+        _LOGGER.debug(\"Closing EnergyID client for %s\", entry.runtime_data.device_name)\n+        await entry.runtime_data.close()\n+\n+    entry.async_on_unload(_cleanup_all_listeners)\n+    entry.async_on_unload(_close_entry_client)\n+\n+    async def _hass_stopping_cleanup(_event: Event) -> None:\n+        _LOGGER.debug(\n+            \"Home Assistant stopping; ensuring client for %s is closed\",\n+            entry.runtime_data.device_name,\n+        )\n+        await entry.runtime_data.close()\n+        listeners.pop(LISTENER_KEY_STOP, None)\n+\n+    listeners[LISTENER_KEY_STOP] = hass.bus.async_listen_once(\n+        EVENT_HOMEASSISTANT_STOP, _hass_stopping_cleanup\n+    )\n+\n+    try:\n+        is_claimed = await entry.runtime_data.authenticate()\n+        if not is_claimed:\n+            _LOGGER.warning(\n+                \"EnergyID device '%s' is not claimed. Please claim it. \"\n+                \"Data sending will not work until claimed and HA is reloaded/entry reloaded\",\n+                entry.runtime_data.device_name,\n+            )\n+        else:\n+            _LOGGER.info(\n+                \"EnergyID device '%s' authenticated and claimed\",\n+                entry.runtime_data.device_name,\n+            )\n+    except Exception as err:\n+        _LOGGER.error(\n+            \"Failed to authenticate with EnergyID for %s: %s\",\n+            entry.runtime_data.device_name,\n+            err,\n+        )\n+        raise ConfigEntryNotReady(\n+            translation_domain=DOMAIN,\n+            translation_key=\"auth_failed_on_setup\",\n+            translation_placeholders={\n+                \"device_name\": entry.runtime_data.device_name,\n+                \"error_details\": str(err),\n+            },\n+        ) from err\n+\n+    # Set up listeners for existing subentries\n+    await async_update_listeners(hass, entry)\n+\n+    # Add listener for config entry updates (including subentry changes)\n+    listeners[LISTENER_KEY_CONFIG_UPDATE] = entry.add_update_listener(\n+        async_config_entry_update_listener\n+    )\n+\n+    # Start auto-sync if device is claimed\n+    if is_claimed:\n+        upload_interval = DEFAULT_UPLOAD_INTERVAL_SECONDS\n+        if entry.runtime_data.webhook_policy:\n+            upload_interval = (\n+                entry.runtime_data.webhook_policy.get(\"uploadInterval\")\n+                or DEFAULT_UPLOAD_INTERVAL_SECONDS\n+            )\n+        _LOGGER.info(\n+            \"Starting EnergyID auto-sync for '%s' with interval: %s seconds\",\n+            entry.runtime_data.device_name,\n+            upload_interval,\n+        )\n+        entry.runtime_data.start_auto_sync(interval_seconds=upload_interval)\n+    else:\n+        _LOGGER.info(\n+            \"Auto-sync not started for '%s' because device is not claimed\",\n+            entry.runtime_data.device_name,\n+        )\n+\n+    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)\n+    return True\n+\n+\n+async def async_config_entry_update_listener(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry\n+) -> None:\n+    \"\"\"Handle config entry updates, including subentry changes.\"\"\"\n+    _LOGGER.debug(\"Config entry updated for %s, reloading listeners\", entry.entry_id)\n+    await async_update_listeners(hass, entry)\n+    async_dispatcher_send(hass, SIGNAL_CONFIG_ENTRY_CHANGED, \"subentry_update\", entry)\n+\n+\n+async def async_update_listeners(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry\n+) -> None:\n+    \"\"\"Set up or update state listeners based on current subentries.\"\"\"\n+\n+    _LOGGER.debug(\"=== DEBUGGING CONFIG ENTRY ===\")\n+    _LOGGER.debug(\"Entry ID: %s\", entry.entry_id)\n+    _LOGGER.debug(\"Entry data: %s\", dict(entry.data))\n+    _LOGGER.debug(\"Entry options: %s\", dict(entry.options))\n+    _LOGGER.debug(\"Entry subentries: %s\", dict(entry.subentries))\n+    _LOGGER.debug(\"Number of subentries: %d\", len(entry.subentries))\n+\n+    for subentry_id, subentry in entry.subentries.items():\n+        _LOGGER.debug(\n+            \"Subentry %s: type=%s, data=%s\",\n+            subentry_id,\n+            subentry.subentry_type,\n+            dict(subentry.data),\n+        )\n+    _LOGGER.debug(\"=== END DEBUG ===\")\n+\n+    if DOMAIN not in hass.data or entry.entry_id not in hass.data[DOMAIN]:\n+        _LOGGER.error(\n+            \"Integration data missing for %s during listener update\", entry.entry_id\n+        )\n+        return\n+\n+    domain_data = hass.data[DOMAIN][entry.entry_id]\n+    client = entry.runtime_data\n+    listeners_dict: dict[str, CALLBACK_TYPE | None] = domain_data[DATA_LISTENERS]\n+\n+    # Remove existing state listener if it exists\n+    if old_state_listener := listeners_dict.pop(LISTENER_KEY_STATE, None):\n+        _LOGGER.debug(\"Removing old state listener for %s\", entry.entry_id)\n+        old_state_listener()\n+    # Ensure it's marked as None if no new one is added\n+    listeners_dict[LISTENER_KEY_STATE] = None\n+\n+    mappings: dict[str, str] = {}\n+    entities_to_track: list[str] = []\n+\n+    # Process subentries instead of options\n+    for subentry in entry.subentries.values():\n+        # Each subentry has a .data attribute containing the mapping configuration\n+        subentry_data = subentry.data\n+\n+        ha_entity_id = subentry_data.get(CONF_HA_ENTITY_ID)\n+        energyid_key = subentry_data.get(CONF_ENERGYID_KEY)\n+\n+        if not isinstance(ha_entity_id, str) or not isinstance(energyid_key, str):\n+            _LOGGER.warning(\"Skipping invalid subentry mapping data: %s\", subentry_data)\n+            continue\n+\n+        # Validate entity exists in Home Assistant\n+        if not hass.states.get(ha_entity_id):\n+            _LOGGER.warning(\n+                \"Entity %s does not exist in Home Assistant, skipping mapping to %s\",\n+                ha_entity_id,\n+                energyid_key,\n+            )\n+            continue\n+\n+        mappings[ha_entity_id] = energyid_key\n+        entities_to_track.append(ha_entity_id)\n+\n+        # Ensure sensor exists in EnergyID client\n+        client.get_or_create_sensor(energyid_key)\n+\n+        _LOGGER.debug(\n+            \"Mapping configured: %s \u2192 %s for device '%s'\",\n+            ha_entity_id,\n+            energyid_key,\n+            client.device_name,\n+        )\n+\n+    domain_data[DATA_MAPPINGS] = mappings\n+\n+    if not entities_to_track:\n+        _LOGGER.info(\n+            \"No valid sensor mappings configured for EnergyID device '%s'\",\n+            client.device_name,\n+        )\n+        return\n+\n+    # Set up state change listener for all tracked entities\n+    unsub_state_change = async_track_state_change_event(\n+        hass,\n+        entities_to_track,\n+        functools.partial(_async_handle_state_change, hass, entry.entry_id),\n+    )\n+    listeners_dict[LISTENER_KEY_STATE] = unsub_state_change\n+\n+    _LOGGER.info(\n+        \"Started tracking state changes for %d entities for device '%s': %s\",\n+        len(entities_to_track),\n+        client.device_name,\n+        \", \".join(entities_to_track),\n+    )\n+\n+    # Send initial states for newly configured entities\n+    await _send_initial_states(hass, entry, mappings)\n+\n+\n+async def _send_initial_states(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry, mappings: dict[str, str]\n+) -> None:\n+    \"\"\"Send initial states for all mapped entities to EnergyID.\"\"\"\n+    client = entry.runtime_data\n+\n+    for ha_entity_id, energyid_key in mappings.items():\n+        current_state = hass.states.get(ha_entity_id)\n+        if not current_state or current_state.state in (\n+            STATE_UNKNOWN,\n+            STATE_UNAVAILABLE,\n+        ):\n+            _LOGGER.debug(\n+                \"Skipping initial state for %s: state is %s\",\n+                ha_entity_id,\n+                current_state.state if current_state else \"None\",\n+            )\n+            continue\n+\n+        try:\n+            value = float(current_state.state)\n+        except (ValueError, TypeError):\n+            _LOGGER.warning(\n+                \"Cannot convert initial state '%s' of %s to float, skipping\",\n+                current_state.state,\n+                ha_entity_id,\n+            )\n+            continue\n+\n+        timestamp = current_state.last_updated or dt.datetime.now(dt.UTC)\n+        if timestamp.tzinfo is None:\n+            timestamp = timestamp.replace(tzinfo=dt.UTC)\n+        elif timestamp.tzinfo != dt.UTC:\n+            timestamp = timestamp.astimezone(dt.UTC)\n+\n+        try:\n+            await client.update_sensor(energyid_key, value, timestamp)\n+            _LOGGER.info(\n+                \"Sent initial state for %s \u2192 %s: %s\",\n+                ha_entity_id,\n+                energyid_key,\n+                value,\n+            )\n+        except (ValueError, TypeError, ConnectionError) as err:\n+            _LOGGER.warning(\n+                \"Failed to send initial state for %s \u2192 %s: %s\",\n+                ha_entity_id,\n+                energyid_key,\n+                err,\n+            )\n+\n+\n+@callback\n+def _async_handle_state_change(\n+    hass: HomeAssistant, entry_id: str, event: Event\n+) -> None:\n+    \"\"\"Handle state changes for tracked entities.\"\"\"\n+    entity_id = event.data.get(\"entity_id\")\n+    new_state = event.data.get(\"new_state\")\n+\n+    if (\n+        not entity_id\n+        or new_state is None\n+        or new_state.state in (STATE_UNKNOWN, STATE_UNAVAILABLE)\n+    ):\n+        return\n+\n+    try:\n+        domain_data = hass.data[DOMAIN][entry_id]\n+        entry = hass.config_entries.async_get_entry(entry_id)\n+        if entry is None:\n+            _LOGGER.error(\"Failed to get config entry for %s\", entry_id)\n+            return\n+\n+        client = entry.runtime_data\n+\n+        mappings = domain_data[DATA_MAPPINGS]\n+        energyid_key = mappings.get(entity_id)\n+    except KeyError:\n+        _LOGGER.debug(\n+            \"Integration data not found for entry %s during state change for %s (likely unloading)\",\n+            entry_id,\n+            entity_id,\n+        )\n+        return\n+\n+    if not energyid_key:\n+        _LOGGER.debug(\n+            \"No EnergyID key mapping for entity %s in entry %s\", entity_id, entry_id\n+        )\n+        return\n+\n+    try:\n+        value = float(new_state.state)\n+    except (ValueError, TypeError):\n+        _LOGGER.warning(\n+            \"Cannot convert state '%s' of %s to float\", new_state.state, entity_id\n+        )\n+        return\n+\n+    timestamp = new_state.last_updated\n+    if not isinstance(timestamp, dt.datetime):\n+        _LOGGER.warning(\n+            \"Invalid timestamp type (%s) for %s, using current UTC time\",\n+            type(timestamp).__name__,\n+            entity_id,\n+        )\n+        timestamp = dt.datetime.now(dt.UTC)\n+\n+    if timestamp.tzinfo is None:\n+        timestamp = timestamp.replace(tzinfo=dt.UTC)\n+    elif timestamp.tzinfo != dt.UTC:\n+        timestamp = timestamp.astimezone(dt.UTC)\n+\n+    # Create async task to send data to EnergyID\n+    hass.async_create_task(\n+        client.update_sensor(energyid_key, value, timestamp),\n+        name=f\"energyid_update_{entity_id}\",\n+    )",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2210321411",
        "repo_full_name": "home-assistant/core",
        "pr_number": 138206,
        "pr_file": "homeassistant/components/energyid/__init__.py",
        "discussion_id": "2210321411",
        "commented_code": "@@ -0,0 +1,427 @@\n+\"\"\"The EnergyID integration.\"\"\"\n+\n+import datetime as dt\n+import functools\n+import logging\n+from typing import Any, Final, TypeVar\n+\n+from energyid_webhooks.client_v2 import WebhookClient\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import (\n+    EVENT_HOMEASSISTANT_STOP,\n+    STATE_UNAVAILABLE,\n+    STATE_UNKNOWN,\n+    Platform,\n+)\n+from homeassistant.core import CALLBACK_TYPE, Event, HomeAssistant, callback\n+from homeassistant.exceptions import ConfigEntryNotReady\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+from homeassistant.helpers.dispatcher import async_dispatcher_send\n+from homeassistant.helpers.event import async_track_state_change_event\n+\n+from .const import (\n+    CONF_DEVICE_ID,\n+    CONF_DEVICE_NAME,\n+    CONF_ENERGYID_KEY,\n+    CONF_HA_ENTITY_ID,\n+    CONF_PROVISIONING_KEY,\n+    CONF_PROVISIONING_SECRET,\n+    DATA_CLIENT,\n+    DATA_LISTENERS,\n+    DATA_MAPPINGS,\n+    DEFAULT_UPLOAD_INTERVAL_SECONDS,\n+    DOMAIN,\n+    SIGNAL_CONFIG_ENTRY_CHANGED,\n+)\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+PLATFORMS: list[Platform] = [Platform.SENSOR]\n+\n+# Custom type for the EnergyID config entry\n+EnergyIDClientT = TypeVar(\"EnergyIDClientT\", bound=WebhookClient)\n+EnergyIDConfigEntry = ConfigEntry[EnergyIDClientT]\n+# Listener keys\n+LISTENER_KEY_STATE: Final = \"state_listener\"\n+LISTENER_KEY_STOP: Final = \"stop_listener\"\n+LISTENER_KEY_CONFIG_UPDATE: Final = \"config_update_listener\"\n+\n+\n+async def async_setup_entry(hass: HomeAssistant, entry: EnergyIDConfigEntry) -> bool:\n+    \"\"\"Set up EnergyID from a config entry.\"\"\"\n+    domain_data = hass.data.setdefault(DOMAIN, {}).setdefault(entry.entry_id, {})\n+\n+    # Initialize listeners as a dictionary\n+    listeners: dict[str, CALLBACK_TYPE] = {}\n+    domain_data[DATA_LISTENERS] = listeners\n+    domain_data[DATA_MAPPINGS] = {}\n+\n+    session = async_get_clientsession(hass)\n+    client = WebhookClient(\n+        provisioning_key=entry.data[CONF_PROVISIONING_KEY],\n+        provisioning_secret=entry.data[CONF_PROVISIONING_SECRET],\n+        device_id=entry.data[CONF_DEVICE_ID],\n+        device_name=entry.data[CONF_DEVICE_NAME],\n+        session=session,\n+    )\n+\n+    # Set the client in runtime_data\n+    entry.runtime_data = client\n+\n+    # Also keep in domain_data for backward compatibility\n+    domain_data[DATA_CLIENT] = client\n+\n+    @callback\n+    def _cleanup_all_listeners() -> None:\n+        \"\"\"Remove all listeners associated with this entry.\"\"\"\n+        _LOGGER.debug(\"Cleaning up all listeners for %s\", entry.entry_id)\n+        if unsub := listeners.pop(LISTENER_KEY_STATE, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_STOP, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_CONFIG_UPDATE, None):\n+            unsub()\n+        domain_data[DATA_LISTENERS] = {}\n+\n+    async def _close_entry_client(*_: Any) -> None:\n+        _LOGGER.debug(\"Closing EnergyID client for %s\", entry.runtime_data.device_name)\n+        await entry.runtime_data.close()\n+\n+    entry.async_on_unload(_cleanup_all_listeners)\n+    entry.async_on_unload(_close_entry_client)\n+\n+    async def _hass_stopping_cleanup(_event: Event) -> None:\n+        _LOGGER.debug(\n+            \"Home Assistant stopping; ensuring client for %s is closed\",\n+            entry.runtime_data.device_name,\n+        )\n+        await entry.runtime_data.close()\n+        listeners.pop(LISTENER_KEY_STOP, None)\n+\n+    listeners[LISTENER_KEY_STOP] = hass.bus.async_listen_once(\n+        EVENT_HOMEASSISTANT_STOP, _hass_stopping_cleanup\n+    )\n+\n+    try:\n+        is_claimed = await entry.runtime_data.authenticate()\n+        if not is_claimed:\n+            _LOGGER.warning(\n+                \"EnergyID device '%s' is not claimed. Please claim it. \"\n+                \"Data sending will not work until claimed and HA is reloaded/entry reloaded\",\n+                entry.runtime_data.device_name,\n+            )\n+        else:\n+            _LOGGER.info(\n+                \"EnergyID device '%s' authenticated and claimed\",\n+                entry.runtime_data.device_name,\n+            )\n+    except Exception as err:\n+        _LOGGER.error(\n+            \"Failed to authenticate with EnergyID for %s: %s\",\n+            entry.runtime_data.device_name,\n+            err,\n+        )\n+        raise ConfigEntryNotReady(\n+            translation_domain=DOMAIN,\n+            translation_key=\"auth_failed_on_setup\",\n+            translation_placeholders={\n+                \"device_name\": entry.runtime_data.device_name,\n+                \"error_details\": str(err),\n+            },\n+        ) from err\n+\n+    # Set up listeners for existing subentries\n+    await async_update_listeners(hass, entry)\n+\n+    # Add listener for config entry updates (including subentry changes)\n+    listeners[LISTENER_KEY_CONFIG_UPDATE] = entry.add_update_listener(\n+        async_config_entry_update_listener\n+    )\n+\n+    # Start auto-sync if device is claimed\n+    if is_claimed:\n+        upload_interval = DEFAULT_UPLOAD_INTERVAL_SECONDS\n+        if entry.runtime_data.webhook_policy:\n+            upload_interval = (\n+                entry.runtime_data.webhook_policy.get(\"uploadInterval\")\n+                or DEFAULT_UPLOAD_INTERVAL_SECONDS\n+            )\n+        _LOGGER.info(\n+            \"Starting EnergyID auto-sync for '%s' with interval: %s seconds\",\n+            entry.runtime_data.device_name,\n+            upload_interval,\n+        )\n+        entry.runtime_data.start_auto_sync(interval_seconds=upload_interval)\n+    else:\n+        _LOGGER.info(\n+            \"Auto-sync not started for '%s' because device is not claimed\",\n+            entry.runtime_data.device_name,\n+        )\n+\n+    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)\n+    return True\n+\n+\n+async def async_config_entry_update_listener(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry\n+) -> None:\n+    \"\"\"Handle config entry updates, including subentry changes.\"\"\"\n+    _LOGGER.debug(\"Config entry updated for %s, reloading listeners\", entry.entry_id)\n+    await async_update_listeners(hass, entry)\n+    async_dispatcher_send(hass, SIGNAL_CONFIG_ENTRY_CHANGED, \"subentry_update\", entry)\n+\n+\n+async def async_update_listeners(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry\n+) -> None:\n+    \"\"\"Set up or update state listeners based on current subentries.\"\"\"\n+\n+    _LOGGER.debug(\"=== DEBUGGING CONFIG ENTRY ===\")\n+    _LOGGER.debug(\"Entry ID: %s\", entry.entry_id)\n+    _LOGGER.debug(\"Entry data: %s\", dict(entry.data))\n+    _LOGGER.debug(\"Entry options: %s\", dict(entry.options))\n+    _LOGGER.debug(\"Entry subentries: %s\", dict(entry.subentries))\n+    _LOGGER.debug(\"Number of subentries: %d\", len(entry.subentries))\n+\n+    for subentry_id, subentry in entry.subentries.items():\n+        _LOGGER.debug(\n+            \"Subentry %s: type=%s, data=%s\",\n+            subentry_id,\n+            subentry.subentry_type,\n+            dict(subentry.data),\n+        )\n+    _LOGGER.debug(\"=== END DEBUG ===\")\n+\n+    if DOMAIN not in hass.data or entry.entry_id not in hass.data[DOMAIN]:\n+        _LOGGER.error(\n+            \"Integration data missing for %s during listener update\", entry.entry_id\n+        )\n+        return\n+\n+    domain_data = hass.data[DOMAIN][entry.entry_id]\n+    client = entry.runtime_data\n+    listeners_dict: dict[str, CALLBACK_TYPE | None] = domain_data[DATA_LISTENERS]\n+\n+    # Remove existing state listener if it exists\n+    if old_state_listener := listeners_dict.pop(LISTENER_KEY_STATE, None):\n+        _LOGGER.debug(\"Removing old state listener for %s\", entry.entry_id)\n+        old_state_listener()\n+    # Ensure it's marked as None if no new one is added\n+    listeners_dict[LISTENER_KEY_STATE] = None\n+\n+    mappings: dict[str, str] = {}\n+    entities_to_track: list[str] = []\n+\n+    # Process subentries instead of options\n+    for subentry in entry.subentries.values():\n+        # Each subentry has a .data attribute containing the mapping configuration\n+        subentry_data = subentry.data\n+\n+        ha_entity_id = subentry_data.get(CONF_HA_ENTITY_ID)\n+        energyid_key = subentry_data.get(CONF_ENERGYID_KEY)\n+\n+        if not isinstance(ha_entity_id, str) or not isinstance(energyid_key, str):\n+            _LOGGER.warning(\"Skipping invalid subentry mapping data: %s\", subentry_data)\n+            continue\n+\n+        # Validate entity exists in Home Assistant\n+        if not hass.states.get(ha_entity_id):\n+            _LOGGER.warning(\n+                \"Entity %s does not exist in Home Assistant, skipping mapping to %s\",\n+                ha_entity_id,\n+                energyid_key,\n+            )\n+            continue\n+\n+        mappings[ha_entity_id] = energyid_key\n+        entities_to_track.append(ha_entity_id)\n+\n+        # Ensure sensor exists in EnergyID client\n+        client.get_or_create_sensor(energyid_key)\n+\n+        _LOGGER.debug(\n+            \"Mapping configured: %s \u2192 %s for device '%s'\",\n+            ha_entity_id,\n+            energyid_key,\n+            client.device_name,\n+        )\n+\n+    domain_data[DATA_MAPPINGS] = mappings\n+\n+    if not entities_to_track:\n+        _LOGGER.info(\n+            \"No valid sensor mappings configured for EnergyID device '%s'\",\n+            client.device_name,\n+        )\n+        return\n+\n+    # Set up state change listener for all tracked entities\n+    unsub_state_change = async_track_state_change_event(\n+        hass,\n+        entities_to_track,\n+        functools.partial(_async_handle_state_change, hass, entry.entry_id),\n+    )\n+    listeners_dict[LISTENER_KEY_STATE] = unsub_state_change\n+\n+    _LOGGER.info(\n+        \"Started tracking state changes for %d entities for device '%s': %s\",\n+        len(entities_to_track),\n+        client.device_name,\n+        \", \".join(entities_to_track),\n+    )\n+\n+    # Send initial states for newly configured entities\n+    await _send_initial_states(hass, entry, mappings)\n+\n+\n+async def _send_initial_states(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry, mappings: dict[str, str]\n+) -> None:\n+    \"\"\"Send initial states for all mapped entities to EnergyID.\"\"\"\n+    client = entry.runtime_data\n+\n+    for ha_entity_id, energyid_key in mappings.items():\n+        current_state = hass.states.get(ha_entity_id)\n+        if not current_state or current_state.state in (\n+            STATE_UNKNOWN,\n+            STATE_UNAVAILABLE,\n+        ):\n+            _LOGGER.debug(\n+                \"Skipping initial state for %s: state is %s\",\n+                ha_entity_id,\n+                current_state.state if current_state else \"None\",\n+            )\n+            continue\n+\n+        try:\n+            value = float(current_state.state)\n+        except (ValueError, TypeError):\n+            _LOGGER.warning(\n+                \"Cannot convert initial state '%s' of %s to float, skipping\",\n+                current_state.state,\n+                ha_entity_id,\n+            )\n+            continue\n+\n+        timestamp = current_state.last_updated or dt.datetime.now(dt.UTC)\n+        if timestamp.tzinfo is None:\n+            timestamp = timestamp.replace(tzinfo=dt.UTC)\n+        elif timestamp.tzinfo != dt.UTC:\n+            timestamp = timestamp.astimezone(dt.UTC)\n+\n+        try:\n+            await client.update_sensor(energyid_key, value, timestamp)\n+            _LOGGER.info(\n+                \"Sent initial state for %s \u2192 %s: %s\",\n+                ha_entity_id,\n+                energyid_key,\n+                value,\n+            )\n+        except (ValueError, TypeError, ConnectionError) as err:\n+            _LOGGER.warning(\n+                \"Failed to send initial state for %s \u2192 %s: %s\",\n+                ha_entity_id,\n+                energyid_key,\n+                err,\n+            )\n+\n+\n+@callback\n+def _async_handle_state_change(\n+    hass: HomeAssistant, entry_id: str, event: Event\n+) -> None:\n+    \"\"\"Handle state changes for tracked entities.\"\"\"\n+    entity_id = event.data.get(\"entity_id\")\n+    new_state = event.data.get(\"new_state\")\n+\n+    if (\n+        not entity_id\n+        or new_state is None\n+        or new_state.state in (STATE_UNKNOWN, STATE_UNAVAILABLE)\n+    ):\n+        return\n+\n+    try:\n+        domain_data = hass.data[DOMAIN][entry_id]\n+        entry = hass.config_entries.async_get_entry(entry_id)\n+        if entry is None:\n+            _LOGGER.error(\"Failed to get config entry for %s\", entry_id)\n+            return\n+\n+        client = entry.runtime_data\n+\n+        mappings = domain_data[DATA_MAPPINGS]\n+        energyid_key = mappings.get(entity_id)\n+    except KeyError:\n+        _LOGGER.debug(\n+            \"Integration data not found for entry %s during state change for %s (likely unloading)\",\n+            entry_id,\n+            entity_id,\n+        )\n+        return\n+\n+    if not energyid_key:\n+        _LOGGER.debug(\n+            \"No EnergyID key mapping for entity %s in entry %s\", entity_id, entry_id\n+        )\n+        return\n+\n+    try:\n+        value = float(new_state.state)\n+    except (ValueError, TypeError):\n+        _LOGGER.warning(\n+            \"Cannot convert state '%s' of %s to float\", new_state.state, entity_id\n+        )\n+        return\n+\n+    timestamp = new_state.last_updated\n+    if not isinstance(timestamp, dt.datetime):\n+        _LOGGER.warning(\n+            \"Invalid timestamp type (%s) for %s, using current UTC time\",\n+            type(timestamp).__name__,\n+            entity_id,\n+        )\n+        timestamp = dt.datetime.now(dt.UTC)\n+\n+    if timestamp.tzinfo is None:\n+        timestamp = timestamp.replace(tzinfo=dt.UTC)\n+    elif timestamp.tzinfo != dt.UTC:\n+        timestamp = timestamp.astimezone(dt.UTC)\n+\n+    # Create async task to send data to EnergyID\n+    hass.async_create_task(\n+        client.update_sensor(energyid_key, value, timestamp),\n+        name=f\"energyid_update_{entity_id}\",\n+    )",
        "comment_created_at": "2025-07-16T12:53:35+00:00",
        "comment_author": "zweckj",
        "comment_body": "I think we'll need to find some queuing and batching mechanism here so we don't send each individual state change and are spawning individual tasks all the time",
        "pr_file_module": null
      },
      {
        "comment_id": "2210676899",
        "repo_full_name": "home-assistant/core",
        "pr_number": 138206,
        "pr_file": "homeassistant/components/energyid/__init__.py",
        "discussion_id": "2210321411",
        "commented_code": "@@ -0,0 +1,427 @@\n+\"\"\"The EnergyID integration.\"\"\"\n+\n+import datetime as dt\n+import functools\n+import logging\n+from typing import Any, Final, TypeVar\n+\n+from energyid_webhooks.client_v2 import WebhookClient\n+\n+from homeassistant.config_entries import ConfigEntry\n+from homeassistant.const import (\n+    EVENT_HOMEASSISTANT_STOP,\n+    STATE_UNAVAILABLE,\n+    STATE_UNKNOWN,\n+    Platform,\n+)\n+from homeassistant.core import CALLBACK_TYPE, Event, HomeAssistant, callback\n+from homeassistant.exceptions import ConfigEntryNotReady\n+from homeassistant.helpers.aiohttp_client import async_get_clientsession\n+from homeassistant.helpers.dispatcher import async_dispatcher_send\n+from homeassistant.helpers.event import async_track_state_change_event\n+\n+from .const import (\n+    CONF_DEVICE_ID,\n+    CONF_DEVICE_NAME,\n+    CONF_ENERGYID_KEY,\n+    CONF_HA_ENTITY_ID,\n+    CONF_PROVISIONING_KEY,\n+    CONF_PROVISIONING_SECRET,\n+    DATA_CLIENT,\n+    DATA_LISTENERS,\n+    DATA_MAPPINGS,\n+    DEFAULT_UPLOAD_INTERVAL_SECONDS,\n+    DOMAIN,\n+    SIGNAL_CONFIG_ENTRY_CHANGED,\n+)\n+\n+_LOGGER = logging.getLogger(__name__)\n+\n+PLATFORMS: list[Platform] = [Platform.SENSOR]\n+\n+# Custom type for the EnergyID config entry\n+EnergyIDClientT = TypeVar(\"EnergyIDClientT\", bound=WebhookClient)\n+EnergyIDConfigEntry = ConfigEntry[EnergyIDClientT]\n+# Listener keys\n+LISTENER_KEY_STATE: Final = \"state_listener\"\n+LISTENER_KEY_STOP: Final = \"stop_listener\"\n+LISTENER_KEY_CONFIG_UPDATE: Final = \"config_update_listener\"\n+\n+\n+async def async_setup_entry(hass: HomeAssistant, entry: EnergyIDConfigEntry) -> bool:\n+    \"\"\"Set up EnergyID from a config entry.\"\"\"\n+    domain_data = hass.data.setdefault(DOMAIN, {}).setdefault(entry.entry_id, {})\n+\n+    # Initialize listeners as a dictionary\n+    listeners: dict[str, CALLBACK_TYPE] = {}\n+    domain_data[DATA_LISTENERS] = listeners\n+    domain_data[DATA_MAPPINGS] = {}\n+\n+    session = async_get_clientsession(hass)\n+    client = WebhookClient(\n+        provisioning_key=entry.data[CONF_PROVISIONING_KEY],\n+        provisioning_secret=entry.data[CONF_PROVISIONING_SECRET],\n+        device_id=entry.data[CONF_DEVICE_ID],\n+        device_name=entry.data[CONF_DEVICE_NAME],\n+        session=session,\n+    )\n+\n+    # Set the client in runtime_data\n+    entry.runtime_data = client\n+\n+    # Also keep in domain_data for backward compatibility\n+    domain_data[DATA_CLIENT] = client\n+\n+    @callback\n+    def _cleanup_all_listeners() -> None:\n+        \"\"\"Remove all listeners associated with this entry.\"\"\"\n+        _LOGGER.debug(\"Cleaning up all listeners for %s\", entry.entry_id)\n+        if unsub := listeners.pop(LISTENER_KEY_STATE, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_STOP, None):\n+            unsub()\n+        if unsub := listeners.pop(LISTENER_KEY_CONFIG_UPDATE, None):\n+            unsub()\n+        domain_data[DATA_LISTENERS] = {}\n+\n+    async def _close_entry_client(*_: Any) -> None:\n+        _LOGGER.debug(\"Closing EnergyID client for %s\", entry.runtime_data.device_name)\n+        await entry.runtime_data.close()\n+\n+    entry.async_on_unload(_cleanup_all_listeners)\n+    entry.async_on_unload(_close_entry_client)\n+\n+    async def _hass_stopping_cleanup(_event: Event) -> None:\n+        _LOGGER.debug(\n+            \"Home Assistant stopping; ensuring client for %s is closed\",\n+            entry.runtime_data.device_name,\n+        )\n+        await entry.runtime_data.close()\n+        listeners.pop(LISTENER_KEY_STOP, None)\n+\n+    listeners[LISTENER_KEY_STOP] = hass.bus.async_listen_once(\n+        EVENT_HOMEASSISTANT_STOP, _hass_stopping_cleanup\n+    )\n+\n+    try:\n+        is_claimed = await entry.runtime_data.authenticate()\n+        if not is_claimed:\n+            _LOGGER.warning(\n+                \"EnergyID device '%s' is not claimed. Please claim it. \"\n+                \"Data sending will not work until claimed and HA is reloaded/entry reloaded\",\n+                entry.runtime_data.device_name,\n+            )\n+        else:\n+            _LOGGER.info(\n+                \"EnergyID device '%s' authenticated and claimed\",\n+                entry.runtime_data.device_name,\n+            )\n+    except Exception as err:\n+        _LOGGER.error(\n+            \"Failed to authenticate with EnergyID for %s: %s\",\n+            entry.runtime_data.device_name,\n+            err,\n+        )\n+        raise ConfigEntryNotReady(\n+            translation_domain=DOMAIN,\n+            translation_key=\"auth_failed_on_setup\",\n+            translation_placeholders={\n+                \"device_name\": entry.runtime_data.device_name,\n+                \"error_details\": str(err),\n+            },\n+        ) from err\n+\n+    # Set up listeners for existing subentries\n+    await async_update_listeners(hass, entry)\n+\n+    # Add listener for config entry updates (including subentry changes)\n+    listeners[LISTENER_KEY_CONFIG_UPDATE] = entry.add_update_listener(\n+        async_config_entry_update_listener\n+    )\n+\n+    # Start auto-sync if device is claimed\n+    if is_claimed:\n+        upload_interval = DEFAULT_UPLOAD_INTERVAL_SECONDS\n+        if entry.runtime_data.webhook_policy:\n+            upload_interval = (\n+                entry.runtime_data.webhook_policy.get(\"uploadInterval\")\n+                or DEFAULT_UPLOAD_INTERVAL_SECONDS\n+            )\n+        _LOGGER.info(\n+            \"Starting EnergyID auto-sync for '%s' with interval: %s seconds\",\n+            entry.runtime_data.device_name,\n+            upload_interval,\n+        )\n+        entry.runtime_data.start_auto_sync(interval_seconds=upload_interval)\n+    else:\n+        _LOGGER.info(\n+            \"Auto-sync not started for '%s' because device is not claimed\",\n+            entry.runtime_data.device_name,\n+        )\n+\n+    await hass.config_entries.async_forward_entry_setups(entry, PLATFORMS)\n+    return True\n+\n+\n+async def async_config_entry_update_listener(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry\n+) -> None:\n+    \"\"\"Handle config entry updates, including subentry changes.\"\"\"\n+    _LOGGER.debug(\"Config entry updated for %s, reloading listeners\", entry.entry_id)\n+    await async_update_listeners(hass, entry)\n+    async_dispatcher_send(hass, SIGNAL_CONFIG_ENTRY_CHANGED, \"subentry_update\", entry)\n+\n+\n+async def async_update_listeners(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry\n+) -> None:\n+    \"\"\"Set up or update state listeners based on current subentries.\"\"\"\n+\n+    _LOGGER.debug(\"=== DEBUGGING CONFIG ENTRY ===\")\n+    _LOGGER.debug(\"Entry ID: %s\", entry.entry_id)\n+    _LOGGER.debug(\"Entry data: %s\", dict(entry.data))\n+    _LOGGER.debug(\"Entry options: %s\", dict(entry.options))\n+    _LOGGER.debug(\"Entry subentries: %s\", dict(entry.subentries))\n+    _LOGGER.debug(\"Number of subentries: %d\", len(entry.subentries))\n+\n+    for subentry_id, subentry in entry.subentries.items():\n+        _LOGGER.debug(\n+            \"Subentry %s: type=%s, data=%s\",\n+            subentry_id,\n+            subentry.subentry_type,\n+            dict(subentry.data),\n+        )\n+    _LOGGER.debug(\"=== END DEBUG ===\")\n+\n+    if DOMAIN not in hass.data or entry.entry_id not in hass.data[DOMAIN]:\n+        _LOGGER.error(\n+            \"Integration data missing for %s during listener update\", entry.entry_id\n+        )\n+        return\n+\n+    domain_data = hass.data[DOMAIN][entry.entry_id]\n+    client = entry.runtime_data\n+    listeners_dict: dict[str, CALLBACK_TYPE | None] = domain_data[DATA_LISTENERS]\n+\n+    # Remove existing state listener if it exists\n+    if old_state_listener := listeners_dict.pop(LISTENER_KEY_STATE, None):\n+        _LOGGER.debug(\"Removing old state listener for %s\", entry.entry_id)\n+        old_state_listener()\n+    # Ensure it's marked as None if no new one is added\n+    listeners_dict[LISTENER_KEY_STATE] = None\n+\n+    mappings: dict[str, str] = {}\n+    entities_to_track: list[str] = []\n+\n+    # Process subentries instead of options\n+    for subentry in entry.subentries.values():\n+        # Each subentry has a .data attribute containing the mapping configuration\n+        subentry_data = subentry.data\n+\n+        ha_entity_id = subentry_data.get(CONF_HA_ENTITY_ID)\n+        energyid_key = subentry_data.get(CONF_ENERGYID_KEY)\n+\n+        if not isinstance(ha_entity_id, str) or not isinstance(energyid_key, str):\n+            _LOGGER.warning(\"Skipping invalid subentry mapping data: %s\", subentry_data)\n+            continue\n+\n+        # Validate entity exists in Home Assistant\n+        if not hass.states.get(ha_entity_id):\n+            _LOGGER.warning(\n+                \"Entity %s does not exist in Home Assistant, skipping mapping to %s\",\n+                ha_entity_id,\n+                energyid_key,\n+            )\n+            continue\n+\n+        mappings[ha_entity_id] = energyid_key\n+        entities_to_track.append(ha_entity_id)\n+\n+        # Ensure sensor exists in EnergyID client\n+        client.get_or_create_sensor(energyid_key)\n+\n+        _LOGGER.debug(\n+            \"Mapping configured: %s \u2192 %s for device '%s'\",\n+            ha_entity_id,\n+            energyid_key,\n+            client.device_name,\n+        )\n+\n+    domain_data[DATA_MAPPINGS] = mappings\n+\n+    if not entities_to_track:\n+        _LOGGER.info(\n+            \"No valid sensor mappings configured for EnergyID device '%s'\",\n+            client.device_name,\n+        )\n+        return\n+\n+    # Set up state change listener for all tracked entities\n+    unsub_state_change = async_track_state_change_event(\n+        hass,\n+        entities_to_track,\n+        functools.partial(_async_handle_state_change, hass, entry.entry_id),\n+    )\n+    listeners_dict[LISTENER_KEY_STATE] = unsub_state_change\n+\n+    _LOGGER.info(\n+        \"Started tracking state changes for %d entities for device '%s': %s\",\n+        len(entities_to_track),\n+        client.device_name,\n+        \", \".join(entities_to_track),\n+    )\n+\n+    # Send initial states for newly configured entities\n+    await _send_initial_states(hass, entry, mappings)\n+\n+\n+async def _send_initial_states(\n+    hass: HomeAssistant, entry: EnergyIDConfigEntry, mappings: dict[str, str]\n+) -> None:\n+    \"\"\"Send initial states for all mapped entities to EnergyID.\"\"\"\n+    client = entry.runtime_data\n+\n+    for ha_entity_id, energyid_key in mappings.items():\n+        current_state = hass.states.get(ha_entity_id)\n+        if not current_state or current_state.state in (\n+            STATE_UNKNOWN,\n+            STATE_UNAVAILABLE,\n+        ):\n+            _LOGGER.debug(\n+                \"Skipping initial state for %s: state is %s\",\n+                ha_entity_id,\n+                current_state.state if current_state else \"None\",\n+            )\n+            continue\n+\n+        try:\n+            value = float(current_state.state)\n+        except (ValueError, TypeError):\n+            _LOGGER.warning(\n+                \"Cannot convert initial state '%s' of %s to float, skipping\",\n+                current_state.state,\n+                ha_entity_id,\n+            )\n+            continue\n+\n+        timestamp = current_state.last_updated or dt.datetime.now(dt.UTC)\n+        if timestamp.tzinfo is None:\n+            timestamp = timestamp.replace(tzinfo=dt.UTC)\n+        elif timestamp.tzinfo != dt.UTC:\n+            timestamp = timestamp.astimezone(dt.UTC)\n+\n+        try:\n+            await client.update_sensor(energyid_key, value, timestamp)\n+            _LOGGER.info(\n+                \"Sent initial state for %s \u2192 %s: %s\",\n+                ha_entity_id,\n+                energyid_key,\n+                value,\n+            )\n+        except (ValueError, TypeError, ConnectionError) as err:\n+            _LOGGER.warning(\n+                \"Failed to send initial state for %s \u2192 %s: %s\",\n+                ha_entity_id,\n+                energyid_key,\n+                err,\n+            )\n+\n+\n+@callback\n+def _async_handle_state_change(\n+    hass: HomeAssistant, entry_id: str, event: Event\n+) -> None:\n+    \"\"\"Handle state changes for tracked entities.\"\"\"\n+    entity_id = event.data.get(\"entity_id\")\n+    new_state = event.data.get(\"new_state\")\n+\n+    if (\n+        not entity_id\n+        or new_state is None\n+        or new_state.state in (STATE_UNKNOWN, STATE_UNAVAILABLE)\n+    ):\n+        return\n+\n+    try:\n+        domain_data = hass.data[DOMAIN][entry_id]\n+        entry = hass.config_entries.async_get_entry(entry_id)\n+        if entry is None:\n+            _LOGGER.error(\"Failed to get config entry for %s\", entry_id)\n+            return\n+\n+        client = entry.runtime_data\n+\n+        mappings = domain_data[DATA_MAPPINGS]\n+        energyid_key = mappings.get(entity_id)\n+    except KeyError:\n+        _LOGGER.debug(\n+            \"Integration data not found for entry %s during state change for %s (likely unloading)\",\n+            entry_id,\n+            entity_id,\n+        )\n+        return\n+\n+    if not energyid_key:\n+        _LOGGER.debug(\n+            \"No EnergyID key mapping for entity %s in entry %s\", entity_id, entry_id\n+        )\n+        return\n+\n+    try:\n+        value = float(new_state.state)\n+    except (ValueError, TypeError):\n+        _LOGGER.warning(\n+            \"Cannot convert state '%s' of %s to float\", new_state.state, entity_id\n+        )\n+        return\n+\n+    timestamp = new_state.last_updated\n+    if not isinstance(timestamp, dt.datetime):\n+        _LOGGER.warning(\n+            \"Invalid timestamp type (%s) for %s, using current UTC time\",\n+            type(timestamp).__name__,\n+            entity_id,\n+        )\n+        timestamp = dt.datetime.now(dt.UTC)\n+\n+    if timestamp.tzinfo is None:\n+        timestamp = timestamp.replace(tzinfo=dt.UTC)\n+    elif timestamp.tzinfo != dt.UTC:\n+        timestamp = timestamp.astimezone(dt.UTC)\n+\n+    # Create async task to send data to EnergyID\n+    hass.async_create_task(\n+        client.update_sensor(energyid_key, value, timestamp),\n+        name=f\"energyid_update_{entity_id}\",\n+    )",
        "comment_created_at": "2025-07-16T14:57:12+00:00",
        "comment_author": "Molier",
        "comment_body": "i have already implemented that in the webhook client, forgot to use it! thanks haha",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2235443174",
    "pr_number": 149016,
    "pr_file": "homeassistant/components/cloudflare/config_flow.py",
    "created_at": "2025-07-28T09:01:19+00:00",
    "commented_code": "zones = await client.list_zones()\n     if zone and (zone_id := get_zone_id(zone, zones)) is not None:\n-        records = await client.list_dns_records(zone_id=zone_id, type=\"A\")\n+        # Fetch both A and AAAA records for the selected zone\n+        records_a = await client.list_dns_records(zone_id=zone_id, type=\"A\")\n+        records_aaaa = await client.list_dns_records(zone_id=zone_id, type=\"AAAA\")\n+        records = records_a + records_aaaa",
    "repo_full_name": "home-assistant/core",
    "discussion_comments": [
      {
        "comment_id": "2235443174",
        "repo_full_name": "home-assistant/core",
        "pr_number": 149016,
        "pr_file": "homeassistant/components/cloudflare/config_flow.py",
        "discussion_id": "2235443174",
        "commented_code": "@@ -66,7 +69,10 @@ async def _validate_input(\n \n     zones = await client.list_zones()\n     if zone and (zone_id := get_zone_id(zone, zones)) is not None:\n-        records = await client.list_dns_records(zone_id=zone_id, type=\"A\")\n+        # Fetch both A and AAAA records for the selected zone\n+        records_a = await client.list_dns_records(zone_id=zone_id, type=\"A\")\n+        records_aaaa = await client.list_dns_records(zone_id=zone_id, type=\"AAAA\")\n+        records = records_a + records_aaaa",
        "comment_created_at": "2025-07-28T09:01:19+00:00",
        "comment_author": "ludeeus",
        "comment_body": "Call these 2 at the same time (asyncio gather)",
        "pr_file_module": null
      }
    ]
  }
]