[
  {
    "discussion_id": "2135649637",
    "pr_number": 2852,
    "pr_file": "src/crewai/agents/agent_adapters/foundry_agents/foundry_adapter.py",
    "created_at": "2025-06-09T12:41:21+00:00",
    "commented_code": "+from typing import Any, List, Optional\n+import os\n+import time\n+import json\n+from pydantic import Field, PrivateAttr\n+\n+from crewai.agents.agent_adapters.base_agent_adapter import BaseAgentAdapter\n+from crewai.agents.agent_adapters.foundry_agents.structured_output_converter import (\n+    FoundryConverterAdapter,\n+)\n+from crewai.agents.agent_builder.base_agent import BaseAgent\n+from crewai.tools import BaseTool\n+from crewai.tools.agent_tools.agent_tools import AgentTools\n+from crewai.utilities import Logger\n+from crewai.utilities.events import crewai_event_bus\n+from crewai.utilities.events.agent_events import (\n+    AgentExecutionCompletedEvent,\n+    AgentExecutionErrorEvent,\n+    AgentExecutionStartedEvent,\n+)\n+\n+try:\n+    from azure.ai.projects import AIProjectClient as FoundryClient\n+    from azure.ai.projects.models import MessageTextContent\n+    from azure.identity import DefaultAzureCredential\n+    from azure.ai.projects.models import FunctionTool\n+\n+\n+    from .foundry_agent_tool_adapter import FoundryAgentToolAdapter\n+\n+    FOUNDRY_AVAILABLE = True\n+except ImportError:\n+    FOUNDRY_AVAILABLE = False\n+\n+\n+class FoundryAgentAdapter(BaseAgentAdapter):\n+    \"\"\"Adapter for Foundry Assistants\"\"\"\n+\n+    model_config = {\"arbitrary_types_allowed\": True}\n+\n+    _foundry_client: \"FoundryClient\" = PrivateAttr()\n+    _logger: Logger = PrivateAttr(default_factory=lambda: Logger())\n+    _active_thread_id: Optional[str] = PrivateAttr(default=None)\n+    function_calling_llm: Any = Field(default=None)\n+    step_callback: Any = Field(default=None)\n+    _tool_adapter: \"FoundryAgentToolAdapter\" = PrivateAttr()\n+    _converter_adapter: FoundryConverterAdapter = PrivateAttr()\n+    _converted_tools: Optional[FunctionTool] = PrivateAttr(default=None)\n+\n+    def __init__(\n+        self,\n+        model: str = \"gpt-4.1-mini\",\n+        tools: Optional[List[BaseTool]] = None,\n+        agent_config: Optional[dict] = None,\n+        **kwargs,\n+    ):\n+        if not FOUNDRY_AVAILABLE:\n+            raise ImportError(\n+                \"Foundry Agent Dependencies are not installed. Please install it using `uv pip install azure-ai-projects azure-identity`\"\n+            )\n+        else:",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2135649637",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2852,
        "pr_file": "src/crewai/agents/agent_adapters/foundry_agents/foundry_adapter.py",
        "discussion_id": "2135649637",
        "commented_code": "@@ -0,0 +1,184 @@\n+from typing import Any, List, Optional\n+import os\n+import time\n+import json\n+from pydantic import Field, PrivateAttr\n+\n+from crewai.agents.agent_adapters.base_agent_adapter import BaseAgentAdapter\n+from crewai.agents.agent_adapters.foundry_agents.structured_output_converter import (\n+    FoundryConverterAdapter,\n+)\n+from crewai.agents.agent_builder.base_agent import BaseAgent\n+from crewai.tools import BaseTool\n+from crewai.tools.agent_tools.agent_tools import AgentTools\n+from crewai.utilities import Logger\n+from crewai.utilities.events import crewai_event_bus\n+from crewai.utilities.events.agent_events import (\n+    AgentExecutionCompletedEvent,\n+    AgentExecutionErrorEvent,\n+    AgentExecutionStartedEvent,\n+)\n+\n+try:\n+    from azure.ai.projects import AIProjectClient as FoundryClient\n+    from azure.ai.projects.models import MessageTextContent\n+    from azure.identity import DefaultAzureCredential\n+    from azure.ai.projects.models import FunctionTool\n+\n+\n+    from .foundry_agent_tool_adapter import FoundryAgentToolAdapter\n+\n+    FOUNDRY_AVAILABLE = True\n+except ImportError:\n+    FOUNDRY_AVAILABLE = False\n+\n+\n+class FoundryAgentAdapter(BaseAgentAdapter):\n+    \"\"\"Adapter for Foundry Assistants\"\"\"\n+\n+    model_config = {\"arbitrary_types_allowed\": True}\n+\n+    _foundry_client: \"FoundryClient\" = PrivateAttr()\n+    _logger: Logger = PrivateAttr(default_factory=lambda: Logger())\n+    _active_thread_id: Optional[str] = PrivateAttr(default=None)\n+    function_calling_llm: Any = Field(default=None)\n+    step_callback: Any = Field(default=None)\n+    _tool_adapter: \"FoundryAgentToolAdapter\" = PrivateAttr()\n+    _converter_adapter: FoundryConverterAdapter = PrivateAttr()\n+    _converted_tools: Optional[FunctionTool] = PrivateAttr(default=None)\n+\n+    def __init__(\n+        self,\n+        model: str = \"gpt-4.1-mini\",\n+        tools: Optional[List[BaseTool]] = None,\n+        agent_config: Optional[dict] = None,\n+        **kwargs,\n+    ):\n+        if not FOUNDRY_AVAILABLE:\n+            raise ImportError(\n+                \"Foundry Agent Dependencies are not installed. Please install it using `uv pip install azure-ai-projects azure-identity`\"\n+            )\n+        else:",
        "comment_created_at": "2025-06-09T12:41:21+00:00",
        "comment_author": "lucasgomide",
        "comment_body": "You can drop the `else` since you are throwing an error if `not FOUNDRY_AVAILABLE` ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2075897724",
    "pr_number": 2765,
    "pr_file": "src/crewai/crew.py",
    "created_at": "2025-05-06T16:51:06+00:00",
    "commented_code": "raise RuntimeError(\n                 f\"[Crew ({self.name if self.name else self.id})] Failed to reset {name} memory: {str(e)}\"\n             ) from e\n+\n+    def _reset_agent_knowledge(self) -> None:\n+        \"\"\"Reset agent knowledge storage.\"\"\"\n+        for agent in self.agents:\n+            knowledge_storage = getattr(agent, \"knowledge\", None)\n+            if knowledge_storage is not None:\n+                knowledge_storage.reset()",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2075897724",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2765,
        "pr_file": "src/crewai/crew.py",
        "discussion_id": "2075897724",
        "commented_code": "@@ -1447,3 +1451,10 @@ def _reset_specific_memory(self, memory_type: str) -> None:\n             raise RuntimeError(\n                 f\"[Crew ({self.name if self.name else self.id})] Failed to reset {name} memory: {str(e)}\"\n             ) from e\n+\n+    def _reset_agent_knowledge(self) -> None:\n+        \"\"\"Reset agent knowledge storage.\"\"\"\n+        for agent in self.agents:\n+            knowledge_storage = getattr(agent, \"knowledge\", None)\n+            if knowledge_storage is not None:\n+                knowledge_storage.reset()",
        "comment_created_at": "2025-05-06T16:51:06+00:00",
        "comment_author": "lorenzejay",
        "comment_body": "great ! what about walrus operator for more conciseness ?\r\n\r\n```py\r\nif (knowledge_storage := getattr(agent, \"knowledge\", None)) is not None:\r\n                knowledge_storage.reset()\r\n```\r\ndont forget the missing new line at end of file",
        "pr_file_module": null
      },
      {
        "comment_id": "2076141649",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2765,
        "pr_file": "src/crewai/crew.py",
        "discussion_id": "2075897724",
        "commented_code": "@@ -1447,3 +1451,10 @@ def _reset_specific_memory(self, memory_type: str) -> None:\n             raise RuntimeError(\n                 f\"[Crew ({self.name if self.name else self.id})] Failed to reset {name} memory: {str(e)}\"\n             ) from e\n+\n+    def _reset_agent_knowledge(self) -> None:\n+        \"\"\"Reset agent knowledge storage.\"\"\"\n+        for agent in self.agents:\n+            knowledge_storage = getattr(agent, \"knowledge\", None)\n+            if knowledge_storage is not None:\n+                knowledge_storage.reset()",
        "comment_created_at": "2025-05-06T19:42:41+00:00",
        "comment_author": "Vidit-Ostwal",
        "comment_body": "Yes, I think changing to walrus operator would be better.\r\nThanks",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2069291489",
    "pr_number": 2723,
    "pr_file": "src/crewai/crew.py",
    "created_at": "2025-04-30T19:06:39+00:00",
    "commented_code": "return self\n \n+    @model_validator(mode=\"after\")\n+    def set_parent_flow(self, max_depth: int = 5) -> Optional[\"Crew\"]:\n+        \"\"\"Find the nearest Flow instance in the call stack.\n+\n+        Args:\n+            max_depth: Maximum frames to traverse up the call stack.\n+\n+        Returns:\n+            The first Flow instance found in the call stack, or None.\n+        \"\"\"\n+        stack = inspect.stack(context=0)[1 : max_depth + 1]\n+        try:\n+            for frame_info in stack:\n+                candidate = frame_info.frame.f_locals.get(\"self\")\n+                if isinstance(candidate, Flow):\n+                    self.parent_flow = candidate\n+                    break\n+            else:\n+                self.parent_flow = None\n+        finally:\n+            del stack",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2069291489",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2723,
        "pr_file": "src/crewai/crew.py",
        "discussion_id": "2069291489",
        "commented_code": "@@ -275,6 +291,29 @@ def set_private_attrs(self) -> \"Crew\":\n \n         return self\n \n+    @model_validator(mode=\"after\")\n+    def set_parent_flow(self, max_depth: int = 5) -> Optional[\"Crew\"]:\n+        \"\"\"Find the nearest Flow instance in the call stack.\n+\n+        Args:\n+            max_depth: Maximum frames to traverse up the call stack.\n+\n+        Returns:\n+            The first Flow instance found in the call stack, or None.\n+        \"\"\"\n+        stack = inspect.stack(context=0)[1 : max_depth + 1]\n+        try:\n+            for frame_info in stack:\n+                candidate = frame_info.frame.f_locals.get(\"self\")\n+                if isinstance(candidate, Flow):\n+                    self.parent_flow = candidate\n+                    break\n+            else:\n+                self.parent_flow = None\n+        finally:\n+            del stack",
        "comment_created_at": "2025-04-30T19:06:39+00:00",
        "comment_author": "lucasgomide",
        "comment_body": "A few suggestions to make it a little more readable\r\n```suggestion\r\n        try:\r\n            self.parent_flow = None\r\n            for frame_info in stack:\r\n                candidate = frame_info.frame.f_locals.get(\"self\")\r\n                if isinstance(candidate, Flow):\r\n                    self.parent_flow = candidate\r\n                    break\r\n             return self   \r\n        finally:\r\n            del stack\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071700749",
    "pr_number": 2737,
    "pr_file": "src/crewai/cli/utils.py",
    "created_at": "2025-05-02T14:29:34+00:00",
    "commented_code": "if require:\n             console.print(\"No valid Crew instance found in crew.py\", style=\"bold red\")\n             raise SystemExit\n-        return None\n \n     except Exception as e:\n         if require:\n             console.print(\n                 f\"Unexpected error while loading crew: {str(e)}\", style=\"bold red\"\n             )\n             raise SystemExit\n+    return crew_instances\n+\n+\n+def get_crew_instance(module_attr) -> Crew | None:\n+    if (\n+        callable(module_attr)\n+        and hasattr(module_attr, \"is_crew_class\")\n+        and module_attr.is_crew_class\n+    ):\n+        return module_attr().crew()\n+    if (ismethod(module_attr) or isfunction(module_attr)) and get_type_hints(\n+        module_attr\n+    ).get(\"return\") is Crew:\n+        return module_attr()\n+    elif isinstance(module_attr, Crew):\n+        return module_attr\n+    else:\n         return None\n+\n+\n+def fetch_crews(module_attr) -> list[Crew]:\n+    crew_instances: list[Crew] = []\n+    crew_instance = get_crew_instance(module_attr)\n+\n+    if crew_instance:\n+        crew_instances.append(crew_instance)",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2071700749",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2737,
        "pr_file": "src/crewai/cli/utils.py",
        "discussion_id": "2071700749",
        "commented_code": "@@ -300,12 +299,45 @@ def get_crew(crew_path: str = \"crew.py\", require: bool = False) -> Crew | None:\n         if require:\n             console.print(\"No valid Crew instance found in crew.py\", style=\"bold red\")\n             raise SystemExit\n-        return None\n \n     except Exception as e:\n         if require:\n             console.print(\n                 f\"Unexpected error while loading crew: {str(e)}\", style=\"bold red\"\n             )\n             raise SystemExit\n+    return crew_instances\n+\n+\n+def get_crew_instance(module_attr) -> Crew | None:\n+    if (\n+        callable(module_attr)\n+        and hasattr(module_attr, \"is_crew_class\")\n+        and module_attr.is_crew_class\n+    ):\n+        return module_attr().crew()\n+    if (ismethod(module_attr) or isfunction(module_attr)) and get_type_hints(\n+        module_attr\n+    ).get(\"return\") is Crew:\n+        return module_attr()\n+    elif isinstance(module_attr, Crew):\n+        return module_attr\n+    else:\n         return None\n+\n+\n+def fetch_crews(module_attr) -> list[Crew]:\n+    crew_instances: list[Crew] = []\n+    crew_instance = get_crew_instance(module_attr)\n+\n+    if crew_instance:\n+        crew_instances.append(crew_instance)",
        "comment_created_at": "2025-05-02T14:29:34+00:00",
        "comment_author": "lorenzejay",
        "comment_body": "thoughts on using a walrus operator here? a bit more idiomatic ?\r\n\r\n```python\r\ncrew_instances: list[Crew] = []\r\nif crew_instance := get_crew_instance(module_attr):\r\n     crew_instances.append(crew_instance)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1630440054",
    "pr_number": 542,
    "pr_file": "src/crewai/memory/memory.py",
    "created_at": "2024-06-07T00:21:37+00:00",
    "commented_code": "+from pathlib import Path\n from typing import Any, Dict\n \n from crewai.memory.storage.interface import Storage\n+from crewai.utilities.paths import db_storage_path\n+\n+\n+def get_memory_paths(memory_path: str = None):\n+    if not memory_path:",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1630440054",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 542,
        "pr_file": "src/crewai/memory/memory.py",
        "discussion_id": "1630440054",
        "commented_code": "@@ -1,6 +1,20 @@\n+from pathlib import Path\n from typing import Any, Dict\n \n from crewai.memory.storage.interface import Storage\n+from crewai.utilities.paths import db_storage_path\n+\n+\n+def get_memory_paths(memory_path: str = None):\n+    if not memory_path:",
        "comment_created_at": "2024-06-07T00:21:37+00:00",
        "comment_author": "gvieira",
        "comment_body": "Can we update this code prevent code duplication? I'm thinking something like `memory_path = memory_path or db_storage_path()`, so your logic will be the same with less branches.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1797353490",
    "pr_number": 1430,
    "pr_file": "src/crewai/cli/create_crew.py",
    "created_at": "2024-10-11T19:32:55+00:00",
    "commented_code": "bold=True,\n     )\n \n+    # Create necessary directories\n     if not folder_path.exists():\n         folder_path.mkdir(parents=True)\n         (folder_path / \"tests\").mkdir(exist_ok=True)\n         if not parent_folder:\n             (folder_path / \"src\" / folder_name).mkdir(parents=True)\n             (folder_path / \"src\" / folder_name / \"tools\").mkdir(parents=True)\n             (folder_path / \"src\" / folder_name / \"config\").mkdir(parents=True)\n-            with open(folder_path / \".env\", \"w\") as file:\n-                file.write(\"OPENAI_API_KEY=YOUR_API_KEY\")\n     else:\n         click.secho(\n-            f\"\\tFolder {folder_name} already exists. Please choose a different name.\",\n-            fg=\"red\",\n+            f\"\\tFolder {folder_name} already exists. Updating .env file...\",\n+            fg=\"yellow\",\n         )\n+    \n+    # Path to the .env file\n+    env_file_path = folder_path / \".env\"\n+\n+    # Initialize env_vars\n+    env_vars = {}\n+    if env_file_path.exists():\n+        with open(env_file_path, \"r\") as file:\n+            for line in file:\n+                key_value = line.strip().split('=', 1)\n+                if len(key_value) == 2:\n+                    env_vars[key_value[0]] = key_value[1]\n+\n+    # Caching setup\n+    cache_dir = Path.home() / '.crewai'\n+    cache_dir.mkdir(exist_ok=True)\n+    cache_file = cache_dir / 'provider_cache.json'\n+    cache_expiry = 24 * 3600 \n+\n+    # Load API providers and models from JSON with caching\n+    json_url = \"https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json\"\n+    current_time = time.time()\n+    data = {}          \n+\n+    \"\"\"\n+    Attempts to load provider data from the cache. If the cache is valid (i.e., not expired), it loads the data from the cache.\n+    If the cache is invalid or corrupted, it fetches the provider data from the web.\n+    \"\"\"\n+    if cache_file.exists() and (current_time - cache_file.stat().st_mtime) < cache_expiry:\n+        click.secho(\"Loading provider data from cache...\", fg=\"cyan\")\n+        try:\n+            with open(cache_file, \"r\") as f:\n+                data = json.load(f)\n+            click.secho(\"Provider data loaded from cache successfully.\", fg=\"green\")\n+        except json.JSONDecodeError:\n+            click.secho(\"Cache is corrupted. Fetching provider data from the web...\", fg=\"yellow\")\n+            data = {}\n+    else:\n+        click.secho(\"Cache expired or not found. Fetching provider data from the web...\", fg=\"cyan\")\n+        data = {}\n+\n+    if not data:\n+        try:\n+            with requests.get(json_url, stream=True, timeout=10) as response:\n+                response.raise_for_status()\n+                total_size = response.headers.get('content-length')\n+                total_size = int(total_size) if total_size else None\n+                block_size = 8192  # Increased block size for faster download\n+                data_chunks = []\n+                \n+                # Removed 'dynamic_ncols=True' as it is not a valid argument for Click's progressbar\n+                with click.progressbar(length=total_size, label='Downloading', show_pos=True) as progress_bar:\n+                    for chunk in response.iter_content(block_size):\n+                        if chunk:\n+                            data_chunks.append(chunk)\n+                            progress_bar.update(len(chunk))\n+                \n+                data_content = b''.join(data_chunks)\n+                data = json.loads(data_content.decode('utf-8'))\n+\n+            # Save fetched data to cache\n+            with open(cache_file, \"w\") as f:\n+                json.dump(data, f)\n+            click.secho(\"Provider data fetched and cached successfully.\", fg=\"green\")\n+        except requests.RequestException as e:\n+            click.secho(f\"Error fetching provider data: {e}\", fg=\"red\")\n+            return\n+        except json.JSONDecodeError:\n+            click.secho(\"Error parsing provider data. Invalid JSON format.\", fg=\"red\")\n+            return\n+\n+    # Extract unique providers based on 'litellm_provider' and map models\n+    provider_models = defaultdict(list)\n+    for model_name, properties in data.items():\n+        provider_full = properties.get(\"litellm_provider\")\n+        if provider_full:\n+            provider_key = provider_full.strip().lower()  # Ensure consistent casing and strip whitespace\n+\n+            # Skip invalid provider entries\n+            if 'http' in provider_key:\n+                click.secho(f\"Skipping invalid provider entry: '{provider_full}'\", fg=\"yellow\")\n+                continue\n+\n+            if provider_key and provider_key != 'other':  # Exclude 'other' and empty strings\n+                provider_models[provider_key].append(model_name)\n+\n+    # Merge predefined PROVIDERS with providers from JSON, ensuring consistent casing\n+    predefined_providers = [p.lower() for p in PROVIDERS]\n+    all_providers = set(predefined_providers)\n+    all_providers.update(provider_models.keys())\n+\n+    # Convert to a sorted list for consistent display\n+    all_providers = sorted(all_providers)\n+\n+    # Adjust provider selection logic to handle 'other' by displaying all providers from JSON data\n+    if provider:\n+        provider_lower = provider.lower()\n+        if provider_lower == 'other':\n+            # Load all providers from JSON data\n+            all_providers = sorted(provider_models.keys())\n+            if not all_providers:\n+                click.secho(\"No additional providers available.\", fg=\"yellow\")\n+                return\n+            click.secho(\"Select a provider from the full list:\", fg=\"cyan\")\n+            for index, provider_name in enumerate(all_providers, start=1):\n+                click.secho(f\"{index}. {provider_name}\", fg=\"cyan\")\n+            \n+            while True:\n+                try:\n+                    selected_index = click.prompt(\n+                        \"Enter the number of your choice\", type=int\n+                    ) - 1\n+                    if 0 <= selected_index < len(all_providers):\n+                        provider = all_providers[selected_index]  # Update provider to the selected one\n+                        break\n+                    else:\n+                        click.secho(\"Invalid selection. Please try again.\", fg=\"red\")\n+                except click.exceptions.Abort:\n+                    click.secho(\"Operation aborted by the user.\", fg=\"red\")\n+                    return\n+        else:\n+            # Validate provider\n+            if provider_lower not in provider_models and provider_lower not in [p.lower() for p in PROVIDERS]:",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1797353490",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 1430,
        "pr_file": "src/crewai/cli/create_crew.py",
        "discussion_id": "1797353490",
        "commented_code": "@@ -21,22 +47,250 @@ def create_crew(name, parent_folder=None):\n         bold=True,\n     )\n \n+    # Create necessary directories\n     if not folder_path.exists():\n         folder_path.mkdir(parents=True)\n         (folder_path / \"tests\").mkdir(exist_ok=True)\n         if not parent_folder:\n             (folder_path / \"src\" / folder_name).mkdir(parents=True)\n             (folder_path / \"src\" / folder_name / \"tools\").mkdir(parents=True)\n             (folder_path / \"src\" / folder_name / \"config\").mkdir(parents=True)\n-            with open(folder_path / \".env\", \"w\") as file:\n-                file.write(\"OPENAI_API_KEY=YOUR_API_KEY\")\n     else:\n         click.secho(\n-            f\"\\tFolder {folder_name} already exists. Please choose a different name.\",\n-            fg=\"red\",\n+            f\"\\tFolder {folder_name} already exists. Updating .env file...\",\n+            fg=\"yellow\",\n         )\n+    \n+    # Path to the .env file\n+    env_file_path = folder_path / \".env\"\n+\n+    # Initialize env_vars\n+    env_vars = {}\n+    if env_file_path.exists():\n+        with open(env_file_path, \"r\") as file:\n+            for line in file:\n+                key_value = line.strip().split('=', 1)\n+                if len(key_value) == 2:\n+                    env_vars[key_value[0]] = key_value[1]\n+\n+    # Caching setup\n+    cache_dir = Path.home() / '.crewai'\n+    cache_dir.mkdir(exist_ok=True)\n+    cache_file = cache_dir / 'provider_cache.json'\n+    cache_expiry = 24 * 3600 \n+\n+    # Load API providers and models from JSON with caching\n+    json_url = \"https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json\"\n+    current_time = time.time()\n+    data = {}          \n+\n+    \"\"\"\n+    Attempts to load provider data from the cache. If the cache is valid (i.e., not expired), it loads the data from the cache.\n+    If the cache is invalid or corrupted, it fetches the provider data from the web.\n+    \"\"\"\n+    if cache_file.exists() and (current_time - cache_file.stat().st_mtime) < cache_expiry:\n+        click.secho(\"Loading provider data from cache...\", fg=\"cyan\")\n+        try:\n+            with open(cache_file, \"r\") as f:\n+                data = json.load(f)\n+            click.secho(\"Provider data loaded from cache successfully.\", fg=\"green\")\n+        except json.JSONDecodeError:\n+            click.secho(\"Cache is corrupted. Fetching provider data from the web...\", fg=\"yellow\")\n+            data = {}\n+    else:\n+        click.secho(\"Cache expired or not found. Fetching provider data from the web...\", fg=\"cyan\")\n+        data = {}\n+\n+    if not data:\n+        try:\n+            with requests.get(json_url, stream=True, timeout=10) as response:\n+                response.raise_for_status()\n+                total_size = response.headers.get('content-length')\n+                total_size = int(total_size) if total_size else None\n+                block_size = 8192  # Increased block size for faster download\n+                data_chunks = []\n+                \n+                # Removed 'dynamic_ncols=True' as it is not a valid argument for Click's progressbar\n+                with click.progressbar(length=total_size, label='Downloading', show_pos=True) as progress_bar:\n+                    for chunk in response.iter_content(block_size):\n+                        if chunk:\n+                            data_chunks.append(chunk)\n+                            progress_bar.update(len(chunk))\n+                \n+                data_content = b''.join(data_chunks)\n+                data = json.loads(data_content.decode('utf-8'))\n+\n+            # Save fetched data to cache\n+            with open(cache_file, \"w\") as f:\n+                json.dump(data, f)\n+            click.secho(\"Provider data fetched and cached successfully.\", fg=\"green\")\n+        except requests.RequestException as e:\n+            click.secho(f\"Error fetching provider data: {e}\", fg=\"red\")\n+            return\n+        except json.JSONDecodeError:\n+            click.secho(\"Error parsing provider data. Invalid JSON format.\", fg=\"red\")\n+            return\n+\n+    # Extract unique providers based on 'litellm_provider' and map models\n+    provider_models = defaultdict(list)\n+    for model_name, properties in data.items():\n+        provider_full = properties.get(\"litellm_provider\")\n+        if provider_full:\n+            provider_key = provider_full.strip().lower()  # Ensure consistent casing and strip whitespace\n+\n+            # Skip invalid provider entries\n+            if 'http' in provider_key:\n+                click.secho(f\"Skipping invalid provider entry: '{provider_full}'\", fg=\"yellow\")\n+                continue\n+\n+            if provider_key and provider_key != 'other':  # Exclude 'other' and empty strings\n+                provider_models[provider_key].append(model_name)\n+\n+    # Merge predefined PROVIDERS with providers from JSON, ensuring consistent casing\n+    predefined_providers = [p.lower() for p in PROVIDERS]\n+    all_providers = set(predefined_providers)\n+    all_providers.update(provider_models.keys())\n+\n+    # Convert to a sorted list for consistent display\n+    all_providers = sorted(all_providers)\n+\n+    # Adjust provider selection logic to handle 'other' by displaying all providers from JSON data\n+    if provider:\n+        provider_lower = provider.lower()\n+        if provider_lower == 'other':\n+            # Load all providers from JSON data\n+            all_providers = sorted(provider_models.keys())\n+            if not all_providers:\n+                click.secho(\"No additional providers available.\", fg=\"yellow\")\n+                return\n+            click.secho(\"Select a provider from the full list:\", fg=\"cyan\")\n+            for index, provider_name in enumerate(all_providers, start=1):\n+                click.secho(f\"{index}. {provider_name}\", fg=\"cyan\")\n+            \n+            while True:\n+                try:\n+                    selected_index = click.prompt(\n+                        \"Enter the number of your choice\", type=int\n+                    ) - 1\n+                    if 0 <= selected_index < len(all_providers):\n+                        provider = all_providers[selected_index]  # Update provider to the selected one\n+                        break\n+                    else:\n+                        click.secho(\"Invalid selection. Please try again.\", fg=\"red\")\n+                except click.exceptions.Abort:\n+                    click.secho(\"Operation aborted by the user.\", fg=\"red\")\n+                    return\n+        else:\n+            # Validate provider\n+            if provider_lower not in provider_models and provider_lower not in [p.lower() for p in PROVIDERS]:",
        "comment_created_at": "2024-10-11T19:32:55+00:00",
        "comment_author": "bhancockio",
        "comment_body": "It would be nice to do an early return statement. Basically, check for the not valid provider first. If it's not valid, give error message and return\r\n\r\nThat way you don't have to put everything in an if / else.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1784629393",
    "pr_number": 1381,
    "pr_file": "src/crewai/cli/git.py",
    "created_at": "2024-10-02T14:24:38+00:00",
    "commented_code": "+import subprocess\n+\n+\n+class Repository:\n+    def __init__(self, path=\".\"):\n+        self.path = path\n+\n+        if not self.is_git_installed():\n+            raise ValueError(\"Git is not installed or not found in your PATH.\")\n+\n+        if not self.is_git_repo():\n+            raise ValueError(f\"{self.path} is not a Git repository.\")\n+\n+        self.fetch()\n+\n+    def is_git_installed(self) -> bool:\n+        \"\"\"Check if Git is installed and available in the system.\"\"\"\n+        try:\n+            subprocess.run(\n+                [\"git\", \"--version\"], capture_output=True, check=True, text=True\n+            )\n+            return True\n+        except (subprocess.CalledProcessError, FileNotFoundError):\n+            return False\n+\n+    def fetch(self) -> None:\n+        \"\"\"Fetch latest updates from the remote.\"\"\"\n+        subprocess.run([\"git\", \"fetch\"], cwd=self.path, check=True)\n+\n+    def status(self) -> str:\n+        \"\"\"Get the git status in porcelain format.\"\"\"\n+        return subprocess.check_output(\n+            [\"git\", \"status\", \"--branch\", \"--porcelain\"],\n+            cwd=self.path,\n+            encoding=\"utf-8\",\n+        ).strip()\n+\n+    def is_git_repo(self) -> bool:\n+        \"\"\"Check if the current directory is a git repository.\"\"\"\n+        try:\n+            subprocess.check_output(\n+                [\"git\", \"rev-parse\", \"--is-inside-work-tree\"],\n+                cwd=self.path,\n+                encoding=\"utf-8\",\n+            )\n+            return True\n+        except subprocess.CalledProcessError:\n+            return False\n+\n+    def has_uncommitted_changes(self) -> bool:\n+        \"\"\"Check if the repository has uncommitted changes.\"\"\"\n+        return len(self.status().splitlines()) > 1\n+\n+    def is_ahead_or_behind(self) -> bool:\n+        \"\"\"Check if the repository is ahead or behind the remote.\"\"\"\n+        for line in self.status().splitlines():\n+            if line.startswith(\"##\") and (\"ahead\" in line or \"behind\" in line):\n+                return True\n+        return False\n+\n+    def is_synced(self) -> bool:\n+        \"\"\"Return True if the Git repository is fully synced with the remote, False otherwise.\"\"\"\n+        if self.has_uncommitted_changes() or self.is_ahead_or_behind():\n+            return False\n+        else:\n+            return True",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1784629393",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 1381,
        "pr_file": "src/crewai/cli/git.py",
        "discussion_id": "1784629393",
        "commented_code": "@@ -0,0 +1,80 @@\n+import subprocess\n+\n+\n+class Repository:\n+    def __init__(self, path=\".\"):\n+        self.path = path\n+\n+        if not self.is_git_installed():\n+            raise ValueError(\"Git is not installed or not found in your PATH.\")\n+\n+        if not self.is_git_repo():\n+            raise ValueError(f\"{self.path} is not a Git repository.\")\n+\n+        self.fetch()\n+\n+    def is_git_installed(self) -> bool:\n+        \"\"\"Check if Git is installed and available in the system.\"\"\"\n+        try:\n+            subprocess.run(\n+                [\"git\", \"--version\"], capture_output=True, check=True, text=True\n+            )\n+            return True\n+        except (subprocess.CalledProcessError, FileNotFoundError):\n+            return False\n+\n+    def fetch(self) -> None:\n+        \"\"\"Fetch latest updates from the remote.\"\"\"\n+        subprocess.run([\"git\", \"fetch\"], cwd=self.path, check=True)\n+\n+    def status(self) -> str:\n+        \"\"\"Get the git status in porcelain format.\"\"\"\n+        return subprocess.check_output(\n+            [\"git\", \"status\", \"--branch\", \"--porcelain\"],\n+            cwd=self.path,\n+            encoding=\"utf-8\",\n+        ).strip()\n+\n+    def is_git_repo(self) -> bool:\n+        \"\"\"Check if the current directory is a git repository.\"\"\"\n+        try:\n+            subprocess.check_output(\n+                [\"git\", \"rev-parse\", \"--is-inside-work-tree\"],\n+                cwd=self.path,\n+                encoding=\"utf-8\",\n+            )\n+            return True\n+        except subprocess.CalledProcessError:\n+            return False\n+\n+    def has_uncommitted_changes(self) -> bool:\n+        \"\"\"Check if the repository has uncommitted changes.\"\"\"\n+        return len(self.status().splitlines()) > 1\n+\n+    def is_ahead_or_behind(self) -> bool:\n+        \"\"\"Check if the repository is ahead or behind the remote.\"\"\"\n+        for line in self.status().splitlines():\n+            if line.startswith(\"##\") and (\"ahead\" in line or \"behind\" in line):\n+                return True\n+        return False\n+\n+    def is_synced(self) -> bool:\n+        \"\"\"Return True if the Git repository is fully synced with the remote, False otherwise.\"\"\"\n+        if self.has_uncommitted_changes() or self.is_ahead_or_behind():\n+            return False\n+        else:\n+            return True",
        "comment_created_at": "2024-10-02T14:24:38+00:00",
        "comment_author": "thiagomoretto",
        "comment_body": "I like the expressiveness of a if...else.\r\nit can be short tho. Your call.\r\n\r\n```suggestion\r\n        return not (self.has_uncommitted_changes() or self.is_ahead_or_behind())\r\n```\r\n\r\nto avoid the negation, perhaps invert the logic like `is_out_of_sync`. Pure juice of nitpicking on my side :)\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1784684799",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 1381,
        "pr_file": "src/crewai/cli/git.py",
        "discussion_id": "1784629393",
        "commented_code": "@@ -0,0 +1,80 @@\n+import subprocess\n+\n+\n+class Repository:\n+    def __init__(self, path=\".\"):\n+        self.path = path\n+\n+        if not self.is_git_installed():\n+            raise ValueError(\"Git is not installed or not found in your PATH.\")\n+\n+        if not self.is_git_repo():\n+            raise ValueError(f\"{self.path} is not a Git repository.\")\n+\n+        self.fetch()\n+\n+    def is_git_installed(self) -> bool:\n+        \"\"\"Check if Git is installed and available in the system.\"\"\"\n+        try:\n+            subprocess.run(\n+                [\"git\", \"--version\"], capture_output=True, check=True, text=True\n+            )\n+            return True\n+        except (subprocess.CalledProcessError, FileNotFoundError):\n+            return False\n+\n+    def fetch(self) -> None:\n+        \"\"\"Fetch latest updates from the remote.\"\"\"\n+        subprocess.run([\"git\", \"fetch\"], cwd=self.path, check=True)\n+\n+    def status(self) -> str:\n+        \"\"\"Get the git status in porcelain format.\"\"\"\n+        return subprocess.check_output(\n+            [\"git\", \"status\", \"--branch\", \"--porcelain\"],\n+            cwd=self.path,\n+            encoding=\"utf-8\",\n+        ).strip()\n+\n+    def is_git_repo(self) -> bool:\n+        \"\"\"Check if the current directory is a git repository.\"\"\"\n+        try:\n+            subprocess.check_output(\n+                [\"git\", \"rev-parse\", \"--is-inside-work-tree\"],\n+                cwd=self.path,\n+                encoding=\"utf-8\",\n+            )\n+            return True\n+        except subprocess.CalledProcessError:\n+            return False\n+\n+    def has_uncommitted_changes(self) -> bool:\n+        \"\"\"Check if the repository has uncommitted changes.\"\"\"\n+        return len(self.status().splitlines()) > 1\n+\n+    def is_ahead_or_behind(self) -> bool:\n+        \"\"\"Check if the repository is ahead or behind the remote.\"\"\"\n+        for line in self.status().splitlines():\n+            if line.startswith(\"##\") and (\"ahead\" in line or \"behind\" in line):\n+                return True\n+        return False\n+\n+    def is_synced(self) -> bool:\n+        \"\"\"Return True if the Git repository is fully synced with the remote, False otherwise.\"\"\"\n+        if self.has_uncommitted_changes() or self.is_ahead_or_behind():\n+            return False\n+        else:\n+            return True",
        "comment_created_at": "2024-10-02T14:46:02+00:00",
        "comment_author": "vinibrsl",
        "comment_body": "Thanks! I was wrapping my head around this, and I decided to go with the verbose way. `not` combined with `or` crashes my inner agent \ud83d\ude06 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1722121839",
    "pr_number": 1211,
    "pr_file": "src/crewai/agents/agent_builder/base_agent.py",
    "created_at": "2024-08-19T17:26:29+00:00",
    "commented_code": "default=None, description=\"Maximum number of tokens for the agent's execution.\"\n     )\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def process_config(cls, values):\n+        config = values.get(\"config\", {})\n+        if not config:\n+            return values\n+\n+        for key, value in config.items():\n+            if key in cls.model_fields:",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1722121839",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 1211,
        "pr_file": "src/crewai/agents/agent_builder/base_agent.py",
        "discussion_id": "1722121839",
        "commented_code": "@@ -127,11 +127,46 @@ class BaseAgent(ABC, BaseModel):\n         default=None, description=\"Maximum number of tokens for the agent's execution.\"\n     )\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def process_config(cls, values):\n+        config = values.get(\"config\", {})\n+        if not config:\n+            return values\n+\n+        for key, value in config.items():\n+            if key in cls.model_fields:",
        "comment_created_at": "2024-08-19T17:26:29+00:00",
        "comment_author": "gvieira",
        "comment_body": "How do you feel about early returns? In this case, early continue? I like it to prevent block nesting.",
        "pr_file_module": null
      },
      {
        "comment_id": "1722246243",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 1211,
        "pr_file": "src/crewai/agents/agent_builder/base_agent.py",
        "discussion_id": "1722121839",
        "commented_code": "@@ -127,11 +127,46 @@ class BaseAgent(ABC, BaseModel):\n         default=None, description=\"Maximum number of tokens for the agent's execution.\"\n     )\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def process_config(cls, values):\n+        config = values.get(\"config\", {})\n+        if not config:\n+            return values\n+\n+        for key, value in config.items():\n+            if key in cls.model_fields:",
        "comment_created_at": "2024-08-19T19:21:11+00:00",
        "comment_author": "bhancockio",
        "comment_body": "Refactored for early breaks with continues!",
        "pr_file_module": null
      }
    ]
  }
]