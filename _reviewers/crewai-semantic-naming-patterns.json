[
  {
    "discussion_id": "2132177723",
    "pr_number": 2969,
    "pr_file": "src/crewai/cli/organization/main.py",
    "created_at": "2025-06-06T13:14:41+00:00",
    "commented_code": "+from rich.console import Console\n+from rich.table import Table\n+\n+from crewai.cli.command import BaseCommand, PlusAPIMixin\n+from crewai.cli.config import Settings\n+\n+console = Console()\n+\n+class OrganizationCommand(BaseCommand, PlusAPIMixin):\n+    def __init__(self):\n+        BaseCommand.__init__(self)\n+        PlusAPIMixin.__init__(self, telemetry=self._telemetry)\n+\n+    def list(self):\n+        try:\n+            response = self.plus_api_client.get_organizations()\n+            response.raise_for_status()\n+            orgs = response.json()\n+            \n+            if not orgs:\n+                console.print(\"You don't belong to any organizations yet.\", style=\"yellow\")\n+                return\n+\n+            table = Table(title=\"Your Organizations\")\n+            table.add_column(\"Name\", style=\"cyan\")\n+            table.add_column(\"Handle\", style=\"green\")",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2132177723",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2969,
        "pr_file": "src/crewai/cli/organization/main.py",
        "discussion_id": "2132177723",
        "commented_code": "@@ -0,0 +1,63 @@\n+from rich.console import Console\n+from rich.table import Table\n+\n+from crewai.cli.command import BaseCommand, PlusAPIMixin\n+from crewai.cli.config import Settings\n+\n+console = Console()\n+\n+class OrganizationCommand(BaseCommand, PlusAPIMixin):\n+    def __init__(self):\n+        BaseCommand.__init__(self)\n+        PlusAPIMixin.__init__(self, telemetry=self._telemetry)\n+\n+    def list(self):\n+        try:\n+            response = self.plus_api_client.get_organizations()\n+            response.raise_for_status()\n+            orgs = response.json()\n+            \n+            if not orgs:\n+                console.print(\"You don't belong to any organizations yet.\", style=\"yellow\")\n+                return\n+\n+            table = Table(title=\"Your Organizations\")\n+            table.add_column(\"Name\", style=\"cyan\")\n+            table.add_column(\"Handle\", style=\"green\")",
        "comment_created_at": "2025-06-06T13:14:41+00:00",
        "comment_author": "vinibrsl",
        "comment_body": "In this case I think we should name it `ID` or `UUID` as we don't actually have a handle/friendly ID.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2054402003",
    "pr_number": 2636,
    "pr_file": "src/crewai/tasks/guardrail_task.py",
    "created_at": "2025-04-22T15:51:50+00:00",
    "commented_code": "+from typing import Any, Tuple\n+\n+from crewai.llm import LLM\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+from crewai.utilities.printer import Printer\n+\n+\n+class GuardrailTask:",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2054402003",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2636,
        "pr_file": "src/crewai/tasks/guardrail_task.py",
        "discussion_id": "2054402003",
        "commented_code": "@@ -0,0 +1,174 @@\n+from typing import Any, Tuple\n+\n+from crewai.llm import LLM\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+from crewai.utilities.printer import Printer\n+\n+\n+class GuardrailTask:",
        "comment_created_at": "2025-04-22T15:51:50+00:00",
        "comment_author": "gvieira",
        "comment_body": "I think the name here is a bit off \u2013 it sounds like it's a task of type guardrail. It should probably be the other way around, `TaskGuardrail`, but our English-first friends can confirm.",
        "pr_file_module": null
      },
      {
        "comment_id": "2054466511",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2636,
        "pr_file": "src/crewai/tasks/guardrail_task.py",
        "discussion_id": "2054402003",
        "commented_code": "@@ -0,0 +1,174 @@\n+from typing import Any, Tuple\n+\n+from crewai.llm import LLM\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+from crewai.utilities.printer import Printer\n+\n+\n+class GuardrailTask:",
        "comment_created_at": "2025-04-22T16:33:19+00:00",
        "comment_author": "greysonlalonde",
        "comment_body": "Good catch here, `TaskGuardrail` is more appropriate ",
        "pr_file_module": null
      },
      {
        "comment_id": "2054466597",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2636,
        "pr_file": "src/crewai/tasks/guardrail_task.py",
        "discussion_id": "2054402003",
        "commented_code": "@@ -0,0 +1,174 @@\n+from typing import Any, Tuple\n+\n+from crewai.llm import LLM\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+from crewai.utilities.printer import Printer\n+\n+\n+class GuardrailTask:",
        "comment_created_at": "2025-04-22T16:33:23+00:00",
        "comment_author": "lucasgomide",
        "comment_body": "good call, I didn't notice that. I'm going to rename that, tks",
        "pr_file_module": null
      },
      {
        "comment_id": "2056753085",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2636,
        "pr_file": "src/crewai/tasks/guardrail_task.py",
        "discussion_id": "2054402003",
        "commented_code": "@@ -0,0 +1,174 @@\n+from typing import Any, Tuple\n+\n+from crewai.llm import LLM\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+from crewai.utilities.printer import Printer\n+\n+\n+class GuardrailTask:",
        "comment_created_at": "2025-04-23T19:26:30+00:00",
        "comment_author": "lucasgomide",
        "comment_body": "done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1952985220",
    "pr_number": 2048,
    "pr_file": "src/crewai/utilities/events/event_bus.py",
    "created_at": "2025-02-12T16:15:01+00:00",
    "commented_code": "+import threading\n+from contextlib import contextmanager\n+from typing import Any, Callable, Dict, List, Type\n+\n+from blinker import Signal\n+\n+from .event_types import EventTypes\n+\n+\n+class EventBus:\n+    \"\"\"\n+    A singleton event bus that uses blinker signals for event handling.\n+    Allows both internal (Flow/Crew) and external event handling.\n+    \"\"\"\n+\n+    _instance = None\n+    _lock = threading.Lock()\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            with cls._lock:\n+                if cls._instance is None:  # prevent race condition\n+                    cls._instance = super(EventBus, cls).__new__(cls)\n+                    cls._instance._initialize()\n+        return cls._instance\n+\n+    def _initialize(self):\n+        \"\"\"Initialize the event bus internal state\"\"\"\n+        self._signal = Signal(\"event_bus\")",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1952985220",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2048,
        "pr_file": "src/crewai/utilities/events/event_bus.py",
        "discussion_id": "1952985220",
        "commented_code": "@@ -0,0 +1,99 @@\n+import threading\n+from contextlib import contextmanager\n+from typing import Any, Callable, Dict, List, Type\n+\n+from blinker import Signal\n+\n+from .event_types import EventTypes\n+\n+\n+class EventBus:\n+    \"\"\"\n+    A singleton event bus that uses blinker signals for event handling.\n+    Allows both internal (Flow/Crew) and external event handling.\n+    \"\"\"\n+\n+    _instance = None\n+    _lock = threading.Lock()\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            with cls._lock:\n+                if cls._instance is None:  # prevent race condition\n+                    cls._instance = super(EventBus, cls).__new__(cls)\n+                    cls._instance._initialize()\n+        return cls._instance\n+\n+    def _initialize(self):\n+        \"\"\"Initialize the event bus internal state\"\"\"\n+        self._signal = Signal(\"event_bus\")",
        "comment_created_at": "2025-02-12T16:15:01+00:00",
        "comment_author": "bhancockio",
        "comment_body": "Instead of \"event_bus\", let's call it \"crewai_events\", \"crewai_event_bus\", or something else that's specific to CrewAI.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2017292352",
    "pr_number": 2491,
    "pr_file": "src/crewai/utilities/events/base_events.py",
    "created_at": "2025-03-27T17:46:30+00:00",
    "commented_code": "from pydantic import BaseModel, Field\n \n+from crewai.flow.state_utils import to_serializable\n \n-class CrewEvent(BaseModel):\n-    \"\"\"Base class for all crew events\"\"\"\n+\n+class BaseEvent(BaseModel):",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2017292352",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2491,
        "pr_file": "src/crewai/utilities/events/base_events.py",
        "discussion_id": "2017292352",
        "commented_code": "@@ -3,12 +3,26 @@\n \n from pydantic import BaseModel, Field\n \n+from crewai.flow.state_utils import to_serializable\n \n-class CrewEvent(BaseModel):\n-    \"\"\"Base class for all crew events\"\"\"\n+\n+class BaseEvent(BaseModel):",
        "comment_created_at": "2025-03-27T17:46:30+00:00",
        "comment_author": "vinibrsl",
        "comment_body": "Every event from flows to crews were based in this class, so I renamed it to `BaseEvent`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1691507720",
    "pr_number": 998,
    "pr_file": "src/crewai/utilities/evaluators/crew_evaluator_handler.py",
    "created_at": "2024-07-25T14:06:46+00:00",
    "commented_code": "+from collections import defaultdict\n+\n+from langchain_openai import ChatOpenAI\n+from pydantic import BaseModel, Field\n+from rich.console import Console\n+from rich.table import Table\n+\n+from crewai.agent import Agent\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+\n+\n+class TaskEvaluationPydanticOutput(BaseModel):\n+    quality: float = Field(\n+        description=\"A score from 1 to 10 evaluating on completion, quality, and overall performance from the task_description and task_expected_output to the actual Task Output.\"\n+    )\n+\n+\n+class CrewEvaluator:\n+    \"\"\"\n+    A class to evaluate the performance of the agents in the crew based on the tasks they have performed.\n+\n+    Attributes:\n+        crew (Crew): The crew of agents to evaluate.\n+        model (str): The model to use for evaluating the performance of the agents (for now ONLY OpenAI accepted).\n+        tasks_scores (defaultdict): A dictionary to store the scores of the agents for each task.\n+        iteration (int): The current iteration of the evaluation.\n+    \"\"\"\n+\n+    tasks_scores: defaultdict = defaultdict(list)\n+    iteration: int = 0\n+\n+    def __init__(self, crew, model: str):\n+        self.crew = crew\n+        self.model = model",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1691507720",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 998,
        "pr_file": "src/crewai/utilities/evaluators/crew_evaluator_handler.py",
        "discussion_id": "1691507720",
        "commented_code": "@@ -0,0 +1,149 @@\n+from collections import defaultdict\n+\n+from langchain_openai import ChatOpenAI\n+from pydantic import BaseModel, Field\n+from rich.console import Console\n+from rich.table import Table\n+\n+from crewai.agent import Agent\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+\n+\n+class TaskEvaluationPydanticOutput(BaseModel):\n+    quality: float = Field(\n+        description=\"A score from 1 to 10 evaluating on completion, quality, and overall performance from the task_description and task_expected_output to the actual Task Output.\"\n+    )\n+\n+\n+class CrewEvaluator:\n+    \"\"\"\n+    A class to evaluate the performance of the agents in the crew based on the tasks they have performed.\n+\n+    Attributes:\n+        crew (Crew): The crew of agents to evaluate.\n+        model (str): The model to use for evaluating the performance of the agents (for now ONLY OpenAI accepted).\n+        tasks_scores (defaultdict): A dictionary to store the scores of the agents for each task.\n+        iteration (int): The current iteration of the evaluation.\n+    \"\"\"\n+\n+    tasks_scores: defaultdict = defaultdict(list)\n+    iteration: int = 0\n+\n+    def __init__(self, crew, model: str):\n+        self.crew = crew\n+        self.model = model",
        "comment_created_at": "2024-07-25T14:06:46+00:00",
        "comment_author": "bhancockio",
        "comment_body": "Might want to rename this to openai_model_name since we are only supporting OpenAI models right now with testing.",
        "pr_file_module": null
      },
      {
        "comment_id": "1691651786",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 998,
        "pr_file": "src/crewai/utilities/evaluators/crew_evaluator_handler.py",
        "discussion_id": "1691507720",
        "commented_code": "@@ -0,0 +1,149 @@\n+from collections import defaultdict\n+\n+from langchain_openai import ChatOpenAI\n+from pydantic import BaseModel, Field\n+from rich.console import Console\n+from rich.table import Table\n+\n+from crewai.agent import Agent\n+from crewai.task import Task\n+from crewai.tasks.task_output import TaskOutput\n+\n+\n+class TaskEvaluationPydanticOutput(BaseModel):\n+    quality: float = Field(\n+        description=\"A score from 1 to 10 evaluating on completion, quality, and overall performance from the task_description and task_expected_output to the actual Task Output.\"\n+    )\n+\n+\n+class CrewEvaluator:\n+    \"\"\"\n+    A class to evaluate the performance of the agents in the crew based on the tasks they have performed.\n+\n+    Attributes:\n+        crew (Crew): The crew of agents to evaluate.\n+        model (str): The model to use for evaluating the performance of the agents (for now ONLY OpenAI accepted).\n+        tasks_scores (defaultdict): A dictionary to store the scores of the agents for each task.\n+        iteration (int): The current iteration of the evaluation.\n+    \"\"\"\n+\n+    tasks_scores: defaultdict = defaultdict(list)\n+    iteration: int = 0\n+\n+    def __init__(self, crew, model: str):\n+        self.crew = crew\n+        self.model = model",
        "comment_created_at": "2024-07-25T15:21:15+00:00",
        "comment_author": "pythonbyte",
        "comment_body": "Makes sense, thanks \ud83d\udc4d\ud83c\udffd ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1630425508",
    "pr_number": 246,
    "pr_file": "src/crewai/agents/agent_interface.py",
    "created_at": "2024-06-07T00:03:10+00:00",
    "commented_code": "+from abc import ABC, abstractmethod\n+from typing import Optional, List, Any, Dict\n+\n+from pydantic import BaseModel, PrivateAttr, Field\n+\n+from crewai.utilities import I18N\n+\n+\n+class AgentWrapperParent(ABC, BaseModel):",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1630425508",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 246,
        "pr_file": "src/crewai/agents/agent_interface.py",
        "discussion_id": "1630425508",
        "commented_code": "@@ -0,0 +1,52 @@\n+from abc import ABC, abstractmethod\n+from typing import Optional, List, Any, Dict\n+\n+from pydantic import BaseModel, PrivateAttr, Field\n+\n+from crewai.utilities import I18N\n+\n+\n+class AgentWrapperParent(ABC, BaseModel):",
        "comment_created_at": "2024-06-07T00:03:10+00:00",
        "comment_author": "gvieira",
        "comment_body": "Really loved the generic agent interface. In a perfect world, this would be the only way the engine would refer to agents, right!? Should we call it `AgentInterface`, like the file name? #namingishard",
        "pr_file_module": null
      },
      {
        "comment_id": "1630426827",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 246,
        "pr_file": "src/crewai/agents/agent_interface.py",
        "discussion_id": "1630425508",
        "commented_code": "@@ -0,0 +1,52 @@\n+from abc import ABC, abstractmethod\n+from typing import Optional, List, Any, Dict\n+\n+from pydantic import BaseModel, PrivateAttr, Field\n+\n+from crewai.utilities import I18N\n+\n+\n+class AgentWrapperParent(ABC, BaseModel):",
        "comment_created_at": "2024-06-07T00:04:49+00:00",
        "comment_author": "gvieira",
        "comment_body": "Just to make it clear, the dream here is that even `Agent` respects `AgentInterface`, then anything that complies to the interface would be able to be an agent.",
        "pr_file_module": null
      },
      {
        "comment_id": "1630842018",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 246,
        "pr_file": "src/crewai/agents/agent_interface.py",
        "discussion_id": "1630425508",
        "commented_code": "@@ -0,0 +1,52 @@\n+from abc import ABC, abstractmethod\n+from typing import Optional, List, Any, Dict\n+\n+from pydantic import BaseModel, PrivateAttr, Field\n+\n+from crewai.utilities import I18N\n+\n+\n+class AgentWrapperParent(ABC, BaseModel):",
        "comment_created_at": "2024-06-07T08:30:21+00:00",
        "comment_author": "ZmeiGorynych",
        "comment_body": "Good suggestion,  that was exactly the idea :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1674233723",
    "pr_number": 916,
    "pr_file": "src/crewai/crew.py",
    "created_at": "2024-07-11T15:32:07+00:00",
    "commented_code": "return results\n \n+    def _store_execution_log(\n+        self,\n+        task: Task,\n+        output: TaskOutput,\n+        task_index: int,\n+        was_replayed: bool = False,\n+    ):\n+        if self._inputs:\n+            inputs = self._inputs\n+        else:\n+            inputs = {}\n+        log = {\n+            \"task_id\": str(task.id),\n+            \"description\": task.description,\n+            \"expected_output\": task.expected_output,\n+            \"agent_role\": task.agent.role if task.agent else \"None\",\n+            \"output\": {\n+                \"description\": output.description,\n+                \"summary\": output.summary,\n+                \"raw\": output.raw,\n+                \"pydantic\": output.pydantic,\n+                \"json_dict\": output.json_dict,\n+                \"output_format\": output.output_format,\n+                \"agent\": output.agent,\n+            },\n+            \"timestamp\": datetime.now().isoformat(),\n+            \"task_index\": task_index,\n+            \"inputs\": inputs,\n+            \"was_replayed\": was_replayed,\n+        }\n+        # Update the existing log or append if it's a new entry\n+        if task_index < len(self.execution_logs):\n+            self.execution_logs[task_index] = log\n+        else:\n+            self.execution_logs.append(log)\n+\n+        self._task_output_handler.update(task_index, log)\n+\n     def _run_sequential_process(self) -> CrewOutput:\n         \"\"\"Executes tasks sequentially and returns the final output.\"\"\"\n-        task_outputs: List[TaskOutput] = []\n-        futures: List[Tuple[Task, Future[TaskOutput]]] = []\n+        self.execution_logs = []\n+        return self._execute_tasks(self.tasks)\n \n-        for task in self.tasks:\n+    def _execute_tasks(\n+        self,\n+        tasks: List[Task],\n+        manager: Optional[BaseAgent] = None,\n+    ) -> CrewOutput:\n+        task_outputs: List[TaskOutput] = []\n+        futures: List[Tuple[Task, Future[TaskOutput], int]] = []\n+        for task_index, task in enumerate(tasks):\n             if task.agent and task.agent.allow_delegation:\n                 agents_for_delegation = [\n                     agent for agent in self.agents if agent != task.agent\n                 ]\n                 if len(self.agents) > 1 and len(agents_for_delegation) > 0:\n                     task.tools += task.agent.get_delegation_tools(agents_for_delegation)\n \n-            role = task.agent.role if task.agent is not None else \"None\"\n-            self._logger.log(\"debug\", f\"== Working Agent: {role}\", color=\"bold_purple\")\n+            if self.process == Process.hierarchical:\n+                if task.agent and manager:\n+                    manager.tools = task.agent.get_delegation_tools([task.agent])\n+                if manager:\n+                    manager.tools = manager.get_delegation_tools(self.agents)\n+\n+            agent_to_use = task.agent if task.agent else manager\n+            role = agent_to_use.role if agent_to_use is not None else \"None\"\n+\n+            self._logger.log(\"debug\", f\"Working Agent: {role}\", color=\"bold_purple\")\n             self._logger.log(\n-                \"info\", f\"== Starting Task: {task.description}\", color=\"bold_purple\"\n+                \"info\",\n+                f\"Starting Task: {task.description}\",\n+                color=\"bold_purple\",\n             )\n \n             if self.output_log_file:\n                 self._file_handler.log(\n                     agent=role, task=task.description, status=\"started\"\n                 )\n-\n             if task.async_execution:\n-                context = (\n-                    aggregate_raw_outputs_from_tasks(task.context)\n-                    if task.context\n-                    else aggregate_raw_outputs_from_task_outputs(task_outputs)\n-                )\n-                future = task.execute_async(\n-                    agent=task.agent, context=context, tools=task.tools\n-                )\n-                futures.append((task, future))\n-            else:\n-                # Before executing a synchronous task, wait for all async tasks to complete\n+                context = self._set_context(task, task_outputs)",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1674233723",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 916,
        "pr_file": "src/crewai/crew.py",
        "discussion_id": "1674233723",
        "commented_code": "@@ -492,78 +509,116 @@ async def run_crew(crew, input_data):\n \n         return results\n \n+    def _store_execution_log(\n+        self,\n+        task: Task,\n+        output: TaskOutput,\n+        task_index: int,\n+        was_replayed: bool = False,\n+    ):\n+        if self._inputs:\n+            inputs = self._inputs\n+        else:\n+            inputs = {}\n+        log = {\n+            \"task_id\": str(task.id),\n+            \"description\": task.description,\n+            \"expected_output\": task.expected_output,\n+            \"agent_role\": task.agent.role if task.agent else \"None\",\n+            \"output\": {\n+                \"description\": output.description,\n+                \"summary\": output.summary,\n+                \"raw\": output.raw,\n+                \"pydantic\": output.pydantic,\n+                \"json_dict\": output.json_dict,\n+                \"output_format\": output.output_format,\n+                \"agent\": output.agent,\n+            },\n+            \"timestamp\": datetime.now().isoformat(),\n+            \"task_index\": task_index,\n+            \"inputs\": inputs,\n+            \"was_replayed\": was_replayed,\n+        }\n+        # Update the existing log or append if it's a new entry\n+        if task_index < len(self.execution_logs):\n+            self.execution_logs[task_index] = log\n+        else:\n+            self.execution_logs.append(log)\n+\n+        self._task_output_handler.update(task_index, log)\n+\n     def _run_sequential_process(self) -> CrewOutput:\n         \"\"\"Executes tasks sequentially and returns the final output.\"\"\"\n-        task_outputs: List[TaskOutput] = []\n-        futures: List[Tuple[Task, Future[TaskOutput]]] = []\n+        self.execution_logs = []\n+        return self._execute_tasks(self.tasks)\n \n-        for task in self.tasks:\n+    def _execute_tasks(\n+        self,\n+        tasks: List[Task],\n+        manager: Optional[BaseAgent] = None,\n+    ) -> CrewOutput:\n+        task_outputs: List[TaskOutput] = []\n+        futures: List[Tuple[Task, Future[TaskOutput], int]] = []\n+        for task_index, task in enumerate(tasks):\n             if task.agent and task.agent.allow_delegation:\n                 agents_for_delegation = [\n                     agent for agent in self.agents if agent != task.agent\n                 ]\n                 if len(self.agents) > 1 and len(agents_for_delegation) > 0:\n                     task.tools += task.agent.get_delegation_tools(agents_for_delegation)\n \n-            role = task.agent.role if task.agent is not None else \"None\"\n-            self._logger.log(\"debug\", f\"== Working Agent: {role}\", color=\"bold_purple\")\n+            if self.process == Process.hierarchical:\n+                if task.agent and manager:\n+                    manager.tools = task.agent.get_delegation_tools([task.agent])\n+                if manager:\n+                    manager.tools = manager.get_delegation_tools(self.agents)\n+\n+            agent_to_use = task.agent if task.agent else manager\n+            role = agent_to_use.role if agent_to_use is not None else \"None\"\n+\n+            self._logger.log(\"debug\", f\"Working Agent: {role}\", color=\"bold_purple\")\n             self._logger.log(\n-                \"info\", f\"== Starting Task: {task.description}\", color=\"bold_purple\"\n+                \"info\",\n+                f\"Starting Task: {task.description}\",\n+                color=\"bold_purple\",\n             )\n \n             if self.output_log_file:\n                 self._file_handler.log(\n                     agent=role, task=task.description, status=\"started\"\n                 )\n-\n             if task.async_execution:\n-                context = (\n-                    aggregate_raw_outputs_from_tasks(task.context)\n-                    if task.context\n-                    else aggregate_raw_outputs_from_task_outputs(task_outputs)\n-                )\n-                future = task.execute_async(\n-                    agent=task.agent, context=context, tools=task.tools\n-                )\n-                futures.append((task, future))\n-            else:\n-                # Before executing a synchronous task, wait for all async tasks to complete\n+                context = self._set_context(task, task_outputs)",
        "comment_created_at": "2024-07-11T15:32:07+00:00",
        "comment_author": "bhancockio",
        "comment_body": "I think this function should be renamed to `_get_context` because you are getting the context from the current task and task outputs.\r\n\r\nThen, once you have the result, you are assigning it to the current context variable.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1630465527",
    "pr_number": 686,
    "pr_file": "src/crewai/agents/executor.py",
    "created_at": "2024-06-07T00:54:03+00:00",
    "commented_code": "# If the tool chosen is the finishing tool, then we end and return.\n         if isinstance(output, AgentFinish):\n             if self.should_ask_for_human_input:\n+                human_feedback = self._ask_human_input(output.return_values[\"output\"])\n+\n+                if self.crew._train:\n+                    self._training_handler(output, human_feedback)",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "1630465527",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 686,
        "pr_file": "src/crewai/agents/executor.py",
        "discussion_id": "1630465527",
        "commented_code": "@@ -246,12 +247,17 @@ def _iter_next_step(\n         # If the tool chosen is the finishing tool, then we end and return.\n         if isinstance(output, AgentFinish):\n             if self.should_ask_for_human_input:\n+                human_feedback = self._ask_human_input(output.return_values[\"output\"])\n+\n+                if self.crew._train:\n+                    self._training_handler(output, human_feedback)",
        "comment_created_at": "2024-06-07T00:54:03+00:00",
        "comment_author": "gvieira",
        "comment_body": "Above, you've used a verb to name the method (`_ask_human_input`). This is perfect, because that's exactly what it does \u2013 there's even no need for documentation on the method in this case. For `_training_handler` however, it doesn't feel the same. How could we name this method to make it more clear what it's doing?",
        "pr_file_module": null
      },
      {
        "comment_id": "1638695214",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 686,
        "pr_file": "src/crewai/agents/executor.py",
        "discussion_id": "1630465527",
        "commented_code": "@@ -246,12 +247,17 @@ def _iter_next_step(\n         # If the tool chosen is the finishing tool, then we end and return.\n         if isinstance(output, AgentFinish):\n             if self.should_ask_for_human_input:\n+                human_feedback = self._ask_human_input(output.return_values[\"output\"])\n+\n+                if self.crew._train:\n+                    self._training_handler(output, human_feedback)",
        "comment_created_at": "2024-06-13T18:17:34+00:00",
        "comment_author": "pythonbyte",
        "comment_body": "Sure thing, I didn't have the proper time to review it, but I agree. \r\nI'll review and change it to make it more intuitive.",
        "pr_file_module": null
      }
    ]
  }
]