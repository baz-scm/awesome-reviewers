[
  {
    "discussion_id": "2190706267",
    "pr_number": 3111,
    "pr_file": "src/crewai/crew.py",
    "created_at": "2025-07-07T17:39:51+00:00",
    "commented_code": "self,\n         inputs: Optional[Dict[str, Any]] = None,\n     ) -> CrewOutput:\n+        ctx = baggage.set_baggage(",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2190706267",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 3111,
        "pr_file": "src/crewai/crew.py",
        "discussion_id": "2190706267",
        "commented_code": "@@ -616,6 +621,11 @@ def kickoff(\n         self,\n         inputs: Optional[Dict[str, Any]] = None,\n     ) -> CrewOutput:\n+        ctx = baggage.set_baggage(",
        "comment_created_at": "2025-07-07T17:39:51+00:00",
        "comment_author": "vinibrsl",
        "comment_body": "I probably need more context, but is baggage thread-safe? If we're running multiple kickoffs in parallel in a same process, will attach work properly?\n\nBy looking at `src/crewai/utilities/crew/crew_context.py`, it looks like this wouldn't be thread-safe.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190915685",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 3111,
        "pr_file": "src/crewai/crew.py",
        "discussion_id": "2190706267",
        "commented_code": "@@ -616,6 +621,11 @@ def kickoff(\n         self,\n         inputs: Optional[Dict[str, Any]] = None,\n     ) -> CrewOutput:\n+        ctx = baggage.set_baggage(",
        "comment_created_at": "2025-07-07T19:57:00+00:00",
        "comment_author": "greysonlalonde",
        "comment_body": "Hey @vinibrsl , good q - `opentelemetry.baggage` wraps `contextvars` [(seen here)](https://github.com/open-telemetry/opentelemetry-python/blob/main/opentelemetry-api/src/opentelemetry/context/contextvars_context.py), so context is isolated and thread-safe. Initially I used a pure `contextvars` approach before realizing opentelemetry provided a variation of this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190928398",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 3111,
        "pr_file": "src/crewai/crew.py",
        "discussion_id": "2190706267",
        "commented_code": "@@ -616,6 +621,11 @@ def kickoff(\n         self,\n         inputs: Optional[Dict[str, Any]] = None,\n     ) -> CrewOutput:\n+        ctx = baggage.set_baggage(",
        "comment_created_at": "2025-07-07T20:06:31+00:00",
        "comment_author": "vinibrsl",
        "comment_body": "Thanks for clarifying and for adding tests for thread safety :-)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2094297478",
    "pr_number": 2853,
    "pr_file": "tests/telemetry/test_telemetry.py",
    "created_at": "2025-05-18T01:11:36+00:00",
    "commented_code": "export_mock.assert_called_once()\n     logger_mock.assert_called_once_with(error)\n+\n+\n+def test_telemetry_singleton_pattern():",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2094297478",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2853,
        "pr_file": "tests/telemetry/test_telemetry.py",
        "discussion_id": "2094297478",
        "commented_code": "@@ -67,3 +66,32 @@ def test_telemetry_fails_due_connect_timeout(export_mock, logger_mock):\n \n     export_mock.assert_called_once()\n     logger_mock.assert_called_once_with(error)\n+\n+\n+def test_telemetry_singleton_pattern():",
        "comment_created_at": "2025-05-18T01:11:36+00:00",
        "comment_author": "greysonlalonde",
        "comment_body": "this might not always catch race conditions, adding a `_lock: Lock = threading.Lock()` attr might be worth looking into",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2017440350",
    "pr_number": 2024,
    "pr_file": "src/crewai/agent.py",
    "created_at": "2025-03-27T18:50:32+00:00",
    "commented_code": "except (TypeError, ValueError) as e:\n             raise ValueError(f\"Invalid Knowledge Configuration: {str(e)}\")\n \n+    def _execute_with_timeout(\n+        self,\n+        task: Task,\n+        context: Optional[str],\n+        tools: Optional[List[BaseTool]],\n+        timeout: int\n+    ) -> str:\n+        \"\"\"Execute task with timeout using thread-based timeout.\n+        \n+        Args:\n+            task: The task to execute\n+            context: Optional context for the task\n+            tools: Optional list of tools to use\n+            timeout: Maximum execution time in seconds (must be > 0)\n+            \n+        Returns:\n+            The result of the task execution\n+            \n+        Raises:\n+            ValueError: If timeout is not a positive integer\n+            TimeoutError: If execution exceeds the timeout\n+            Exception: Any error that occurs during execution\n+        \"\"\"\n+        # Validate timeout before creating any resources\n+        if not isinstance(timeout, int) or timeout <= 0:\n+            raise ValueError(\"Timeout must be a positive integer greater than zero\")\n+\n+        completion_event: threading.Event = threading.Event()\n+        result_container: List[Optional[str]] = [None]\n+        error_container: List[Optional[Exception]] = [None]\n+        \n+        def target() -> None:\n+            try:\n+                result_container[0] = self._execute_task_without_timeout(task, context, tools)\n+            except Exception as e:\n+                error_container[0] = e\n+            finally:\n+                completion_event.set()\n+        \n+        thread: threading.Thread = threading.Thread(target=target)\n+        thread.daemon = True  # Ensures thread doesn't prevent program exit\n+        thread.start()\n+        \n+        # Wait for either completion or timeout\n+        completed: bool = completion_event.wait(timeout=timeout)\n+        \n+        if not completed:\n+            self._logger.log(\"warning\", f\"Task execution timed out after {timeout} seconds\")\n+            thread.join(timeout=0.1)",
    "repo_full_name": "crewAIInc/crewAI",
    "discussion_comments": [
      {
        "comment_id": "2017440350",
        "repo_full_name": "crewAIInc/crewAI",
        "pr_number": 2024,
        "pr_file": "src/crewai/agent.py",
        "discussion_id": "2017440350",
        "commented_code": "@@ -159,6 +161,75 @@ def _set_knowledge(self):\n         except (TypeError, ValueError) as e:\n             raise ValueError(f\"Invalid Knowledge Configuration: {str(e)}\")\n \n+    def _execute_with_timeout(\n+        self,\n+        task: Task,\n+        context: Optional[str],\n+        tools: Optional[List[BaseTool]],\n+        timeout: int\n+    ) -> str:\n+        \"\"\"Execute task with timeout using thread-based timeout.\n+        \n+        Args:\n+            task: The task to execute\n+            context: Optional context for the task\n+            tools: Optional list of tools to use\n+            timeout: Maximum execution time in seconds (must be > 0)\n+            \n+        Returns:\n+            The result of the task execution\n+            \n+        Raises:\n+            ValueError: If timeout is not a positive integer\n+            TimeoutError: If execution exceeds the timeout\n+            Exception: Any error that occurs during execution\n+        \"\"\"\n+        # Validate timeout before creating any resources\n+        if not isinstance(timeout, int) or timeout <= 0:\n+            raise ValueError(\"Timeout must be a positive integer greater than zero\")\n+\n+        completion_event: threading.Event = threading.Event()\n+        result_container: List[Optional[str]] = [None]\n+        error_container: List[Optional[Exception]] = [None]\n+        \n+        def target() -> None:\n+            try:\n+                result_container[0] = self._execute_task_without_timeout(task, context, tools)\n+            except Exception as e:\n+                error_container[0] = e\n+            finally:\n+                completion_event.set()\n+        \n+        thread: threading.Thread = threading.Thread(target=target)\n+        thread.daemon = True  # Ensures thread doesn't prevent program exit\n+        thread.start()\n+        \n+        # Wait for either completion or timeout\n+        completed: bool = completion_event.wait(timeout=timeout)\n+        \n+        if not completed:\n+            self._logger.log(\"warning\", f\"Task execution timed out after {timeout} seconds\")\n+            thread.join(timeout=0.1) ",
        "comment_created_at": "2025-03-27T18:50:32+00:00",
        "comment_author": "lucasgomide",
        "comment_body": "the following code seems a bit too verbose.. maybe we could use a simpler approach with `join + is_alive`, instead of `wait + join + set` \r\n\r\nhere is a suggestion - needs to test better:\r\n\r\n```python\r\n    result = None\r\n    error = None\r\n\r\n    def target():\r\n        try:\r\n            result = self._execute_task_without_timeout(task, context, tools)\r\n        except Exception as e:\r\n            error = e\r\n\r\n    thread = threading.Thread(target=target, daemon=True)\r\n    thread.start()\r\n    thread.join(timeout=timeout)\r\n\r\n    if thread.is_alive():\r\n        self._logger.log(\"warning\", f\"Task timed out after {timeout}s\")\r\n        raise ...\r\n\r\n    if error:\r\n        self._logger.log(\"error\", f\"Task failed: {str(error)}\")\r\n        raise error\r\n\r\n    return result.get(\"output\", \"\")\r\n```",
        "pr_file_module": null
      }
    ]
  }
]