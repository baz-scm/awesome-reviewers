[
  {
    "discussion_id": "1036094414",
    "pr_number": 24892,
    "pr_file": "packages/data-context/src/actions/BrowserActions.ts",
    "created_at": "2022-11-30T15:11:05+00:00",
    "commented_code": "await this.browserApi.focusActiveBrowserWindow()\n   }\n \n+  resetFocusIfMacOS () {",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "1036094414",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 24892,
        "pr_file": "packages/data-context/src/actions/BrowserActions.ts",
        "discussion_id": "1036094414",
        "commented_code": "@@ -44,6 +44,14 @@ export class BrowserActions {\n     await this.browserApi.focusActiveBrowserWindow()\n   }\n \n+  resetFocusIfMacOS () {",
        "comment_created_at": "2022-11-30T15:11:05+00:00",
        "comment_author": "mike-plummer",
        "comment_body": "/nit: Personal preference, I would put the \"this is a workaround\" and GH issue link on the function as JSDoc",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "678290930",
    "pr_number": 14350,
    "pr_file": "packages/driver/src/cy/commands/sessions.ts",
    "created_at": "2021-07-28T13:17:28+00:00",
    "commented_code": "+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "678290930",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 14350,
        "pr_file": "packages/driver/src/cy/commands/sessions.ts",
        "discussion_id": "678290930",
        "commented_code": "@@ -0,0 +1,822 @@\n+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)",
        "comment_created_at": "2021-07-28T13:17:28+00:00",
        "comment_author": "chrisbreiding",
        "comment_body": "Some code comments would be useful here to explain why using postMessage is necessary.",
        "pr_file_module": null
      },
      {
        "comment_id": "680240143",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 14350,
        "pr_file": "packages/driver/src/cy/commands/sessions.ts",
        "discussion_id": "678290930",
        "commented_code": "@@ -0,0 +1,822 @@\n+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)",
        "comment_created_at": "2021-07-30T21:55:21+00:00",
        "comment_author": "kuceb",
        "comment_body": " 85d85eaeeb",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "678717018",
    "pr_number": 17508,
    "pr_file": "npm/vue/src/index.ts",
    "created_at": "2021-07-28T23:25:46+00:00",
    "commented_code": "const document: Document = cy.state('document')\n     let el = document.getElementById(ROOT_ID)\n \n+    if (!el) {\n+      throw Error(`no element found at query #${ROOT_ID}. Please use the mount utils to mount it properly`)\n+    }\n+\n     el.innerHTML = ''\n     document.head.innerHTML = initialInnerHtml\n   })\n })\n \n-export function mount<Props = any> (\n-  comp: Component<Props>,\n-  options: CyMountOptions<Props> = {},\n+type PublicProps = VNodeProps & AllowedComponentProps & ComponentCustomProps;\n+\n+// Class component - no props\n+export function mount<V>(",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "678717018",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 17508,
        "pr_file": "npm/vue/src/index.ts",
        "discussion_id": "678717018",
        "commented_code": "@@ -53,17 +58,162 @@ Cypress.on('run:start', () => {\n     const document: Document = cy.state('document')\n     let el = document.getElementById(ROOT_ID)\n \n+    if (!el) {\n+      throw Error(`no element found at query #${ROOT_ID}. Please use the mount utils to mount it properly`)\n+    }\n+\n     el.innerHTML = ''\n     document.head.innerHTML = initialInnerHtml\n   })\n })\n \n-export function mount<Props = any> (\n-  comp: Component<Props>,\n-  options: CyMountOptions<Props> = {},\n+type PublicProps = VNodeProps & AllowedComponentProps & ComponentCustomProps;\n+\n+// Class component - no props\n+export function mount<V>(",
        "comment_created_at": "2021-07-28T23:25:46+00:00",
        "comment_author": "lmiller1990",
        "comment_body": "Can we put a link to where these came from? So if someone looks at in the future and wants to update they can copy paste again - actually reading this type is basically impossible unless you know Vue 3 inside-out",
        "pr_file_module": null
      },
      {
        "comment_id": "679427094",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 17508,
        "pr_file": "npm/vue/src/index.ts",
        "discussion_id": "678717018",
        "commented_code": "@@ -53,17 +58,162 @@ Cypress.on('run:start', () => {\n     const document: Document = cy.state('document')\n     let el = document.getElementById(ROOT_ID)\n \n+    if (!el) {\n+      throw Error(`no element found at query #${ROOT_ID}. Please use the mount utils to mount it properly`)\n+    }\n+\n     el.innerHTML = ''\n     document.head.innerHTML = initialInnerHtml\n   })\n })\n \n-export function mount<Props = any> (\n-  comp: Component<Props>,\n-  options: CyMountOptions<Props> = {},\n+type PublicProps = VNodeProps & AllowedComponentProps & ComponentCustomProps;\n+\n+// Class component - no props\n+export function mount<V>(",
        "comment_created_at": "2021-07-29T19:25:05+00:00",
        "comment_author": "elevatebart",
        "comment_body": "Done !!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "678717343",
    "pr_number": 17508,
    "pr_file": "npm/vue/src/index.ts",
    "created_at": "2021-07-28T23:26:47+00:00",
    "commented_code": "})\n }\n \n+function getComponentDisplayName (componentOptions: any): string {\n+  if (componentOptions.name) {\n+    return componentOptions.name\n+  }\n+\n+  if (componentOptions.__file) {\n+    const filepathSplit = componentOptions.__file.split('/')\n+    const fileName = filepathSplit[filepathSplit.length - 1]\n+\n+    return fileName.replace(/\\....?$/, '')",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "678717343",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 17508,
        "pr_file": "npm/vue/src/index.ts",
        "discussion_id": "678717343",
        "commented_code": "@@ -119,17 +273,34 @@ export function mount<Props = any> (\n   })\n }\n \n+function getComponentDisplayName (componentOptions: any): string {\n+  if (componentOptions.name) {\n+    return componentOptions.name\n+  }\n+\n+  if (componentOptions.__file) {\n+    const filepathSplit = componentOptions.__file.split('/')\n+    const fileName = filepathSplit[filepathSplit.length - 1]\n+\n+    return fileName.replace(/\\....?$/, '')",
        "comment_created_at": "2021-07-28T23:26:47+00:00",
        "comment_author": "lmiller1990",
        "comment_body": "What does this do? Can you put a comment explaning (very hard to understand regexp without knowing expected input)",
        "pr_file_module": null
      },
      {
        "comment_id": "679181623",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 17508,
        "pr_file": "npm/vue/src/index.ts",
        "discussion_id": "678717343",
        "commented_code": "@@ -119,17 +273,34 @@ export function mount<Props = any> (\n   })\n }\n \n+function getComponentDisplayName (componentOptions: any): string {\n+  if (componentOptions.name) {\n+    return componentOptions.name\n+  }\n+\n+  if (componentOptions.__file) {\n+    const filepathSplit = componentOptions.__file.split('/')\n+    const fileName = filepathSplit[filepathSplit.length - 1]\n+\n+    return fileName.replace(/\\....?$/, '')",
        "comment_created_at": "2021-07-29T14:03:29+00:00",
        "comment_author": "elevatebart",
        "comment_body": "yep will do",
        "pr_file_module": null
      },
      {
        "comment_id": "679427532",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 17508,
        "pr_file": "npm/vue/src/index.ts",
        "discussion_id": "678717343",
        "commented_code": "@@ -119,17 +273,34 @@ export function mount<Props = any> (\n   })\n }\n \n+function getComponentDisplayName (componentOptions: any): string {\n+  if (componentOptions.name) {\n+    return componentOptions.name\n+  }\n+\n+  if (componentOptions.__file) {\n+    const filepathSplit = componentOptions.__file.split('/')\n+    const fileName = filepathSplit[filepathSplit.length - 1]\n+\n+    return fileName.replace(/\\....?$/, '')",
        "comment_created_at": "2021-07-29T19:25:44+00:00",
        "comment_author": "elevatebart",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "596069516",
    "pr_number": 15517,
    "pr_file": "packages/server/lib/util/tests_utils.ts",
    "created_at": "2021-03-17T14:27:42+00:00",
    "commented_code": ")\n   }\n \n+  if (!suite || !suite.suites) {",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "596069516",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 15517,
        "pr_file": "packages/server/lib/util/tests_utils.ts",
        "discussion_id": "596069516",
        "commented_code": "@@ -9,6 +9,10 @@ export const flattenSuiteIntoRunnables = (suite, tests = [], hooks = []) => {\n     )\n   }\n \n+  if (!suite || !suite.suites) {",
        "comment_created_at": "2021-03-17T14:27:42+00:00",
        "comment_author": "brian-mann",
        "comment_body": "maybe explain why this is necessary and link to the github issue that this is fixing, this is a specific regression\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]