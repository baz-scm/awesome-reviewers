[
  {
    "discussion_id": "1033831087",
    "pr_number": 22458,
    "pr_file": "packages/driver/src/cypress/error_messages.ts",
    "created_at": "2022-11-28T17:23:42+00:00",
    "commented_code": "},\n   },\n \n+  network_logs: {\n+    docsUrl: 'https://on.cypress.io/request-logs',\n+    filter_must_be_function: ({ filterFn }) => `RequestLogs.filter should be set to a function, but a ${typeof filterFn} was passed.`,",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "1033831087",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 22458,
        "pr_file": "packages/driver/src/cypress/error_messages.ts",
        "discussion_id": "1033831087",
        "commented_code": "@@ -1171,6 +1171,11 @@ export default {\n     },\n   },\n \n+  network_logs: {\n+    docsUrl: 'https://on.cypress.io/request-logs',\n+    filter_must_be_function: ({ filterFn }) => `RequestLogs.filter should be set to a function, but a ${typeof filterFn} was passed.`,",
        "comment_created_at": "2022-11-28T17:23:42+00:00",
        "comment_author": "BlueWinds",
        "comment_body": "```suggestion\r\n    filter_must_be_function: ({ filterFn }) => `RequestLogs.filter should be set to a function, but you tried to assign ${format(filterFn)}.`,\r\n```\r\n\r\nThey tried to assign a value, not really pass something.",
        "pr_file_module": null
      },
      {
        "comment_id": "1036322049",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 22458,
        "pr_file": "packages/driver/src/cypress/error_messages.ts",
        "discussion_id": "1033831087",
        "commented_code": "@@ -1171,6 +1171,11 @@ export default {\n     },\n   },\n \n+  network_logs: {\n+    docsUrl: 'https://on.cypress.io/request-logs',\n+    filter_must_be_function: ({ filterFn }) => `RequestLogs.filter should be set to a function, but a ${typeof filterFn} was passed.`,",
        "comment_created_at": "2022-11-30T18:38:48+00:00",
        "comment_author": "flotwig",
        "comment_body": "Thanks, I missed this when moving from `.filter(newFilter)` to `.filter = newFilter`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "678277015",
    "pr_number": 14350,
    "pr_file": "packages/driver/src/cy/commands/sessions.ts",
    "created_at": "2021-07-28T13:00:01+00:00",
    "commented_code": "+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)\n+    })\n+    .timeout(2000)\n+    .catch((err) => {\n+      Cypress.log({\n+        name: 'warning',\n+        message: `failed to set session storage on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+      })\n+    })\n+    .finally(() => {\n+      specWindow.removeEventListener('message', onPostMessage)\n+      $iframeContainer.remove()\n+    })\n+  }\n+\n+  async function getAllHtmlOrigins () {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const origins = _.uniq([..._.keys(await Cypress.backend('get:renderedHTMLOrigins')), current_origin]) as string[]\n+\n+    return origins\n+  }\n+\n+  function throwIfNoSessionSupport () {\n+    if (!Cypress.config('experimentalSessionSupport')) {\n+      // TODO: proper error msg\n+      throw new Error('experimentalSessionSupport is not enabled. You must enable the experimentalSessionSupport flag in order to use Cypress session commands')\n+    }\n+  }\n+\n+  const sessions = {\n+\n+    defineSession (options = {} as any) {\n+      const sess_state = {\n+        id: options.id,\n+        cookies: null,\n+        localStorage: null,\n+        setup: options.setup,\n+        hydrated: false,\n+        validate: options.validate,\n+      }\n+\n+      setActiveSession({ [sess_state.id]: sess_state })\n+\n+      return sess_state\n+    },\n+\n+    async clearAllSavedSessions () {\n+      clearActiveSessions()\n+\n+      return Cypress.backend('clear:session', null)\n+    },\n+\n+    async clearCurrentSessionData () {\n+      window.localStorage.clear()\n+      window.sessionStorage.clear()\n+\n+      await Promise.all([\n+        sessions.clearStorage(),\n+        sessions.clearCookies(),\n+      ])\n+    },\n+\n+    async setSessionData (data) {\n+      const allHtmlOrigins = await getAllHtmlOrigins()\n+\n+      let _localStorage = data.localStorage || []\n+      let _sessionStorage = data.sessionStorage || []\n+\n+      _.each(allHtmlOrigins, (v) => {\n+        if (!_.find(_localStorage, v)) {\n+          _localStorage = _localStorage.concat({ origin: v, clear: true })\n+        }\n+\n+        if (!_.find(_sessionStorage, v)) {\n+          _sessionStorage = _sessionStorage.concat({ origin: v, clear: true })\n+        }\n+      })\n+\n+      await Promise.all([\n+        sessions.setStorage({ localStorage: _localStorage, sessionStorage: _sessionStorage }),\n+        Cypress.automation('clear:cookies', null),\n+      ])\n+\n+      await sessions.setCookies(data.cookies)\n+    },\n+\n+    getCookies () {\n+      return Cypress.automation('get:cookies', {})\n+    },\n+\n+    setCookies (data) {\n+      return Cypress.automation('set:cookies', data)\n+    },\n+\n+    async clearCookies () {\n+      return Cypress.automation('clear:cookies', await sessions.getCookies())\n+    },\n+\n+    async getCurrentSessionData () {\n+      const storage = await sessions.getStorage({ origin: '*' })\n+\n+      let cookies = [] as any[]\n+\n+      cookies = await Cypress.automation('get:cookies', {})\n+\n+      const ses = {\n+        ...storage,\n+        cookies,\n+      }\n+\n+      return ses\n+    },\n+\n+    getSession (id) {\n+      return Cypress.backend('get:session', id)\n+    },\n+\n+    /**\n+     * 1) if we only need current_origin localStorage, access sync\n+     * 2) if cross-origin http, we need to load in iframe from our proxy that will intercept all http reqs at /__cypress/automation/*\n+     *      and postMessage() the localStorage value to us\n+     * 3) if cross-origin https, since we pass-thru https conntections in the proxy, we need to\n+     *      send a message telling our proxy server to intercept the next req to the https domain,\n+     *      then follow 2)\n+     */\n+    async getStorage (options = {}) {\n+      const specWindow = cy.state('specWindow')\n+\n+      if (!_.isObject(options)) {\n+        throw new Error('getStorage() takes an object')\n+      }\n+\n+      const opts = _.defaults({}, options, {\n+        origin: 'current_origin',\n+      })\n+\n+      const current_origin = $Location.create(window.location.href).origin\n+\n+      const origins = await mapOrigins(opts.origin)\n+\n+      const getResults = () => {\n+        return results\n+      }\n+      const results = {\n+        localStorage: [] as any[],\n+        sessionStorage: [] as any[],\n+      }\n+\n+      function pushValue (origin, value) {\n+        if (!_.isEmpty(value.localStorage)) {\n+          results.localStorage.push({ origin, value: value.localStorage })\n+        }\n+\n+        if (!_.isEmpty(value.sessionStorage)) {\n+          results.sessionStorage.push({ origin, value: value.sessionStorage })\n+        }\n+      }\n+\n+      const currentOriginIndex = origins.indexOf(current_origin)\n+\n+      if (currentOriginIndex !== -1) {\n+        origins.splice(currentOriginIndex, 1)\n+        // localStorage.length propery is not always accurate, we must stringify to check for entries\n+        // for ex) try setting localStorge.key = 'val' and reading localStorage.length, may be 0.\n+        const _localStorageStr = JSON.stringify(window.localStorage)\n+        const _localStorage = _localStorageStr.length > 2 && JSON.parse(_localStorageStr)\n+        const _sessionStorageStr = JSON.stringify(window.sessionStorage)\n+        const _sessionStorage = _sessionStorageStr.length > 2 && JSON.parse(JSON.stringify(window.sessionStorage))\n+\n+        const value = {} as any\n+\n+        if (_localStorage) {\n+          value.localStorage = _localStorage\n+        }\n+\n+        if (_sessionStorage) {\n+          value.sessionStorage = _sessionStorage\n+        }\n+\n+        pushValue(current_origin, value)\n+      }\n+\n+      if (_.isEmpty(origins)) {\n+        return getResults()\n+      }\n+\n+      if (current_origin.startsWith('https:')) {\n+        _.remove(origins, (v) => v.startsWith('http:'))\n+      }\n+\n+      const iframes: JQuery<HTMLElement>[] = []\n+\n+      const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+      _.each(origins, (u) => {\n+        const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/getLocalStorage`}\"></iframe>`)\n+\n+        $iframe.appendTo($iframeContainer)\n+        iframes.push($iframe)\n+      })\n+\n+      let onPostMessage\n+      const successOrigins = [] as string[]\n+\n+      await new Promise((resolve) => {\n+        onPostMessage = ((event) => {\n+          const data = event.data\n+\n+          if (data.type !== 'localStorage') return\n+\n+          const value = data.value\n+\n+          pushValue(event.origin, value)\n+\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        })\n+\n+        specWindow.addEventListener('message', onPostMessage)\n+      })\n+      .catch((err) => {\n+        Cypress.log({\n+          name: 'warning',\n+          message: `failed to set session storage data on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+        })\n+      })\n+      .finally(() => {\n+        specWindow.removeEventListener('message', onPostMessage)\n+        $iframeContainer.remove()\n+      })\n+\n+      return getResults()\n+    },\n+\n+    async clearStorage () {\n+      const origins = await getAllHtmlOrigins()\n+\n+      const originOptions = origins.map((v) => ({ origin: v, clear: true }))\n+\n+      await sessions.setStorage({\n+        localStorage: originOptions,\n+        sessionStorage: originOptions,\n+      })\n+    },\n+\n+    async setStorage (options: any, clearAll = false) {\n+      const current_origin = $Location.create(window.location.href).origin as string\n+\n+      const mapToCurrentOrigin = (v) => ({ ...v, origin: (v.origin && v.origin !== 'current_origin') ? $Location.create(v.origin).origin : current_origin })\n+\n+      const mappedLocalStorage = _.map(options.localStorage, (v) => {\n+        const mapped = { origin: v.origin, localStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.localStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const mappedSessionStorage = _.map(options.sessionStorage, (v) => {\n+        const mapped = { origin: v.origin, sessionStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.sessionStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const storageOptions = _.map(_.groupBy(mappedLocalStorage.concat(mappedSessionStorage), 'origin'), (v) => _.merge({}, ...v))\n+\n+      await _setStorageOnOrigins(storageOptions)\n+    },\n+\n+    registerSessionHooks () {\n+      Cypress.on('test:before:run:async', () => {\n+        if (Cypress.config('experimentalSessionSupport')) {\n+          currentTestRegisteredSessions.clear()\n+\n+          return navigateAboutBlank(false)\n+          .then(() => sessions.clearCurrentSessionData())\n+          .then(() => {\n+            return Cypress.backend('reset:renderedHTMLOrigins')\n+          })\n+        }\n+\n+        return\n+      })\n+    },\n+\n+  }\n+\n+  Cypress.on('run:start', () => {\n+    sessions.registerSessionHooks()\n+  })\n+\n+  Commands.addAll({\n+    session (id, setup?: Function, options: {\n+      validate?: Function\n+    } = {}) {\n+      throwIfNoSessionSupport()\n+\n+      if (!id || !_.isString(id) && !_.isObject(id)) {\n+        throw new Error('cy.session requires a string or object as the first argument')\n+      }\n+\n+      // backup session command so we can set it as codeFrame location for errors later on\n+      const sessionCommand = cy.state('current')\n+\n+      // stringfy determinitically if we were given an object\n+      id = typeof id === 'string' ? id : stringifyStable(id)\n+\n+      if (options) {\n+        if (!_.isObject(options)) {\n+          throw new Error('cy.session optional third argument must be an object')\n+        }\n+\n+        const validopts = {\n+          'validate': 'function',\n+        }\n+\n+        Object.keys(options).forEach((key) => {\n+          const expectedType = validopts[key]\n+\n+          if (!expectedType) {\n+            throw new Error(`unexpected option **${key}** passed to cy.session options`)\n+          }\n+\n+          const actualType = typeof options[key]\n+\n+          if (actualType !== expectedType) {\n+            throw new Error(`invalid option **${key}** passed to cy.session options. Expected **${expectedType}**, got ${actualType}`)\n+          }\n+        })\n+      }\n+\n+      let existingSession = getActiveSession(id)\n+\n+      if (!setup) {\n+        if (!existingSession || !currentTestRegisteredSessions.has(id)) {\n+          $errUtils.throwErrByPath('sessions.session.not_found', { args: { id } })\n+        }\n+      } else {\n+        const isUniqSessionDefinition = !existingSession || existingSession.setup.toString().trim() !== setup.toString().trim()\n+\n+        if (isUniqSessionDefinition) {\n+          if (currentTestRegisteredSessions.has(id)) {\n+            throw $errUtils.errByPath('sessions.session.duplicateId', { id: existingSession.id })\n+          }\n+\n+          existingSession = sessions.defineSession({\n+            id,\n+            setup,\n+            validate: options.validate,\n+          })\n+\n+          currentTestRegisteredSessions.set(id, true)\n+        }\n+      }\n+\n+      const _log = Cypress.log({\n+        name: 'session',\n+        message: `${existingSession.id > 50 ? `${existingSession.id.substr(0, 47)}...` : existingSession.id}`,\n+        groupStart: true,\n+        snapshot: false,\n+      })\n+\n+      const dataLog = Cypress.log({\n+        name: 'session',\n+        sessionInfo: getSessionDetails(existingSession),\n+        message: `${existingSession.id > 50 ? `${existingSession.id.substr(0, 47)}...` : existingSession.id}`,\n+      })\n+\n+      async function runsetup (existingSession) {\n+        Cypress.log({\n+          name: 'Create New Session',\n+          state: 'passed',\n+          event: true,\n+          type: 'system',\n+          message: ``,\n+          groupStart: true,\n+        })\n+\n+        if (!hadValidationError) {\n+          _log.set({\n+            renderProps: () => {\n+              return {\n+                indicator: 'successful',\n+                message: `(new) ${_log.get().message}`,\n+              }\n+            },\n+          })\n+        }\n+\n+        await navigateAboutBlank()\n+\n+        cy.then(() => sessions.clearCurrentSessionData())\n+        .then(() => existingSession.setup())\n+\n+        return cy.then(() => sessions.getCurrentSessionData())\n+        .then((data) => {\n+          Cypress.log({ groupEnd: true, emitOnly: true })\n+\n+          _.extend(existingSession, data)\n+          existingSession.hydrated = true\n+\n+          setActiveSession({ [existingSession.id]: existingSession })\n+\n+          dataLog.set({\n+            consoleProps: () => getConsoleProps(existingSession),\n+          })\n+\n+          // persist the session to the server. Only matters in openMode OR if there's a top navigation on a future test.\n+          // eslint-disable-next-line no-console\n+\n+          // eslint-disable-next-line no-console\n+          return Cypress.backend('save:session', { ...existingSession, setup: existingSession.setup.toString() }).catch(console.error)\n+        })\n+      }\n+\n+      // uses Cypress hackery to resolve `false` if validate() resolves/returns false or throws/fails a cypress command.\n+      function validateSession (existingSession, _onFail) {\n+        navigateAboutBlank()\n+\n+        const validatingLog = Cypress.log({\n+          name: 'Validate Session',\n+          message: '',\n+          snapshot: false,\n+          type: 'system',\n+          state: 'passed',\n+          event: true,\n+          groupStart: true,\n+        })\n+\n+        const onSuccess = () => {\n+          validatingLog.set({\n+            name: 'Validate Session: valid',\n+            message: '',\n+            type: 'system',\n+            event: true,\n+            state: 'warning',\n+          })\n+\n+          Cypress.log({ groupEnd: true, emitOnly: true })\n+        }\n+\n+        const onFail = (err) => {\n+          _onFail(err, validatingLog)\n+        }\n+\n+        let _commandToResume: any = null\n+\n+        let _didThrow = false\n+\n+        let returnVal\n+\n+        try {\n+          returnVal = existingSession.validate()\n+        } catch (e) {\n+          onFail(e)\n+\n+          return\n+        }\n+\n+        if (typeof returnVal === 'object' && typeof returnVal.catch === 'function' && typeof returnVal.then === 'function') {\n+          return returnVal\n+          .then((val) => {\n+            if (val === false) {\n+              // set current command to cy.session for more accurate codeFrame\n+              cy.state('current', sessionCommand)\n+              throw $errUtils.errByPath('sessions.callback_returned_false', { reason: 'resolved false' })\n+            }\n+\n+            onSuccess()\n+          })\n+          .catch((err) => {\n+            onFail(err)\n+          })\n+        }\n+\n+        cy.state('onCommandFailed', (err, queue, next) => {\n+          const index = _.findIndex(queue.commands, (v: any) => _commandToResume && v.attributes.chainerId === _commandToResume.chainerId)\n+\n+          // attach codeframe and cleanse the stack trace since we may not hit the cy.fail callback\n+          if (typeof err === 'string') {\n+            err = new Error(err)\n+          }\n+\n+          err.stack = $stackUtils.normalizedStack(err)\n+\n+          err = $errUtils.enhanceStack({\n+            err,\n+            userInvocationStack: $stackUtils.getUserInvocationStack(err, Cypress.state),\n+            projectRoot: Cypress.config('projectRoot'),\n+          })\n+\n+          cy.state('index', index)\n+\n+          cy.state('onCommandFailed', null)\n+\n+          _didThrow = err\n+\n+          return next()\n+        })\n+\n+        const _catchCommand = cy.then(async () => {\n+          cy.state('onCommandFailed', null)\n+          if (_didThrow) return onFail((_didThrow))\n+\n+          if (returnVal === false) {\n+            // set current command to cy.session for more accurate codeframe\n+            cy.state('current', sessionCommand)\n+\n+            return onFail($errUtils.errByPath('sessions.callback_returned_false', { reason: 'returned false' }))\n+            // return onFail((new Error('Your `cy.session` **validate** callback returned false.')))\n+          }\n+\n+          if (returnVal === undefined || Cypress.isCy(returnVal)) {\n+            const val = cy.state('current').get('prev')?.attributes?.subject\n+\n+            if (val === false) {\n+              return onFail((new Error('Your `cy.session` **validate** callback resolved false')))\n+            }\n+          }\n+\n+          onSuccess()\n+        })\n+\n+        _commandToResume = _catchCommand\n+\n+        return _catchCommand\n+      }\n+\n+      let hadValidationError = false\n+      let onValidationError: Function = (err, log) => {\n+        log.set({\n+          name: 'Validate Session: invalid',\n+          message: '',\n+          type: 'system',\n+          event: true,\n+          state: 'warning',\n+        })\n+\n+        const errorLog = Cypress.log({\n+          showError: true,\n+          type: 'system',\n+          event: true,\n+          name: '',\n+          message: '',\n+        })\n+\n+        errorLog.error(err)\n+        errorLog.set({\n+          state: 'warn',\n+\n+        })\n+\n+        _log.set({\n+          renderProps: () => {\n+            return {\n+              indicator: 'bad',\n+              message: `(recreated) ${_log.get().message}`,\n+            }\n+          },\n+        })\n+\n+        Cypress.log({ groupEnd: true, emitOnly: true })\n+\n+        hadValidationError = true\n+\n+        return runsetup(existingSession)\n+        .then(() => {\n+          cy.then(() => {\n+            return validateSession(existingSession, throwValidationError)\n+          })\n+          .then(() => {\n+            cy.then(async () => {\n+              await navigateAboutBlank()\n+              Cypress.log({ groupEnd: true, name: '', message: '', emitOnly: true })\n+            })\n+          })\n+        })\n+      }\n+\n+      const throwValidationError = (err) => {\n+        err.message += '\n\nThis error occurred in a session validate hook after initializing the session. Because validation failed immediately after session setup we failed the test.'",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "678277015",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 14350,
        "pr_file": "packages/driver/src/cy/commands/sessions.ts",
        "discussion_id": "678277015",
        "commented_code": "@@ -0,0 +1,822 @@\n+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)\n+    })\n+    .timeout(2000)\n+    .catch((err) => {\n+      Cypress.log({\n+        name: 'warning',\n+        message: `failed to set session storage on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+      })\n+    })\n+    .finally(() => {\n+      specWindow.removeEventListener('message', onPostMessage)\n+      $iframeContainer.remove()\n+    })\n+  }\n+\n+  async function getAllHtmlOrigins () {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const origins = _.uniq([..._.keys(await Cypress.backend('get:renderedHTMLOrigins')), current_origin]) as string[]\n+\n+    return origins\n+  }\n+\n+  function throwIfNoSessionSupport () {\n+    if (!Cypress.config('experimentalSessionSupport')) {\n+      // TODO: proper error msg\n+      throw new Error('experimentalSessionSupport is not enabled. You must enable the experimentalSessionSupport flag in order to use Cypress session commands')\n+    }\n+  }\n+\n+  const sessions = {\n+\n+    defineSession (options = {} as any) {\n+      const sess_state = {\n+        id: options.id,\n+        cookies: null,\n+        localStorage: null,\n+        setup: options.setup,\n+        hydrated: false,\n+        validate: options.validate,\n+      }\n+\n+      setActiveSession({ [sess_state.id]: sess_state })\n+\n+      return sess_state\n+    },\n+\n+    async clearAllSavedSessions () {\n+      clearActiveSessions()\n+\n+      return Cypress.backend('clear:session', null)\n+    },\n+\n+    async clearCurrentSessionData () {\n+      window.localStorage.clear()\n+      window.sessionStorage.clear()\n+\n+      await Promise.all([\n+        sessions.clearStorage(),\n+        sessions.clearCookies(),\n+      ])\n+    },\n+\n+    async setSessionData (data) {\n+      const allHtmlOrigins = await getAllHtmlOrigins()\n+\n+      let _localStorage = data.localStorage || []\n+      let _sessionStorage = data.sessionStorage || []\n+\n+      _.each(allHtmlOrigins, (v) => {\n+        if (!_.find(_localStorage, v)) {\n+          _localStorage = _localStorage.concat({ origin: v, clear: true })\n+        }\n+\n+        if (!_.find(_sessionStorage, v)) {\n+          _sessionStorage = _sessionStorage.concat({ origin: v, clear: true })\n+        }\n+      })\n+\n+      await Promise.all([\n+        sessions.setStorage({ localStorage: _localStorage, sessionStorage: _sessionStorage }),\n+        Cypress.automation('clear:cookies', null),\n+      ])\n+\n+      await sessions.setCookies(data.cookies)\n+    },\n+\n+    getCookies () {\n+      return Cypress.automation('get:cookies', {})\n+    },\n+\n+    setCookies (data) {\n+      return Cypress.automation('set:cookies', data)\n+    },\n+\n+    async clearCookies () {\n+      return Cypress.automation('clear:cookies', await sessions.getCookies())\n+    },\n+\n+    async getCurrentSessionData () {\n+      const storage = await sessions.getStorage({ origin: '*' })\n+\n+      let cookies = [] as any[]\n+\n+      cookies = await Cypress.automation('get:cookies', {})\n+\n+      const ses = {\n+        ...storage,\n+        cookies,\n+      }\n+\n+      return ses\n+    },\n+\n+    getSession (id) {\n+      return Cypress.backend('get:session', id)\n+    },\n+\n+    /**\n+     * 1) if we only need current_origin localStorage, access sync\n+     * 2) if cross-origin http, we need to load in iframe from our proxy that will intercept all http reqs at /__cypress/automation/*\n+     *      and postMessage() the localStorage value to us\n+     * 3) if cross-origin https, since we pass-thru https conntections in the proxy, we need to\n+     *      send a message telling our proxy server to intercept the next req to the https domain,\n+     *      then follow 2)\n+     */\n+    async getStorage (options = {}) {\n+      const specWindow = cy.state('specWindow')\n+\n+      if (!_.isObject(options)) {\n+        throw new Error('getStorage() takes an object')\n+      }\n+\n+      const opts = _.defaults({}, options, {\n+        origin: 'current_origin',\n+      })\n+\n+      const current_origin = $Location.create(window.location.href).origin\n+\n+      const origins = await mapOrigins(opts.origin)\n+\n+      const getResults = () => {\n+        return results\n+      }\n+      const results = {\n+        localStorage: [] as any[],\n+        sessionStorage: [] as any[],\n+      }\n+\n+      function pushValue (origin, value) {\n+        if (!_.isEmpty(value.localStorage)) {\n+          results.localStorage.push({ origin, value: value.localStorage })\n+        }\n+\n+        if (!_.isEmpty(value.sessionStorage)) {\n+          results.sessionStorage.push({ origin, value: value.sessionStorage })\n+        }\n+      }\n+\n+      const currentOriginIndex = origins.indexOf(current_origin)\n+\n+      if (currentOriginIndex !== -1) {\n+        origins.splice(currentOriginIndex, 1)\n+        // localStorage.length propery is not always accurate, we must stringify to check for entries\n+        // for ex) try setting localStorge.key = 'val' and reading localStorage.length, may be 0.\n+        const _localStorageStr = JSON.stringify(window.localStorage)\n+        const _localStorage = _localStorageStr.length > 2 && JSON.parse(_localStorageStr)\n+        const _sessionStorageStr = JSON.stringify(window.sessionStorage)\n+        const _sessionStorage = _sessionStorageStr.length > 2 && JSON.parse(JSON.stringify(window.sessionStorage))\n+\n+        const value = {} as any\n+\n+        if (_localStorage) {\n+          value.localStorage = _localStorage\n+        }\n+\n+        if (_sessionStorage) {\n+          value.sessionStorage = _sessionStorage\n+        }\n+\n+        pushValue(current_origin, value)\n+      }\n+\n+      if (_.isEmpty(origins)) {\n+        return getResults()\n+      }\n+\n+      if (current_origin.startsWith('https:')) {\n+        _.remove(origins, (v) => v.startsWith('http:'))\n+      }\n+\n+      const iframes: JQuery<HTMLElement>[] = []\n+\n+      const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+      _.each(origins, (u) => {\n+        const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/getLocalStorage`}\"></iframe>`)\n+\n+        $iframe.appendTo($iframeContainer)\n+        iframes.push($iframe)\n+      })\n+\n+      let onPostMessage\n+      const successOrigins = [] as string[]\n+\n+      await new Promise((resolve) => {\n+        onPostMessage = ((event) => {\n+          const data = event.data\n+\n+          if (data.type !== 'localStorage') return\n+\n+          const value = data.value\n+\n+          pushValue(event.origin, value)\n+\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        })\n+\n+        specWindow.addEventListener('message', onPostMessage)\n+      })\n+      .catch((err) => {\n+        Cypress.log({\n+          name: 'warning',\n+          message: `failed to set session storage data on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+        })\n+      })\n+      .finally(() => {\n+        specWindow.removeEventListener('message', onPostMessage)\n+        $iframeContainer.remove()\n+      })\n+\n+      return getResults()\n+    },\n+\n+    async clearStorage () {\n+      const origins = await getAllHtmlOrigins()\n+\n+      const originOptions = origins.map((v) => ({ origin: v, clear: true }))\n+\n+      await sessions.setStorage({\n+        localStorage: originOptions,\n+        sessionStorage: originOptions,\n+      })\n+    },\n+\n+    async setStorage (options: any, clearAll = false) {\n+      const current_origin = $Location.create(window.location.href).origin as string\n+\n+      const mapToCurrentOrigin = (v) => ({ ...v, origin: (v.origin && v.origin !== 'current_origin') ? $Location.create(v.origin).origin : current_origin })\n+\n+      const mappedLocalStorage = _.map(options.localStorage, (v) => {\n+        const mapped = { origin: v.origin, localStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.localStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const mappedSessionStorage = _.map(options.sessionStorage, (v) => {\n+        const mapped = { origin: v.origin, sessionStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.sessionStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const storageOptions = _.map(_.groupBy(mappedLocalStorage.concat(mappedSessionStorage), 'origin'), (v) => _.merge({}, ...v))\n+\n+      await _setStorageOnOrigins(storageOptions)\n+    },\n+\n+    registerSessionHooks () {\n+      Cypress.on('test:before:run:async', () => {\n+        if (Cypress.config('experimentalSessionSupport')) {\n+          currentTestRegisteredSessions.clear()\n+\n+          return navigateAboutBlank(false)\n+          .then(() => sessions.clearCurrentSessionData())\n+          .then(() => {\n+            return Cypress.backend('reset:renderedHTMLOrigins')\n+          })\n+        }\n+\n+        return\n+      })\n+    },\n+\n+  }\n+\n+  Cypress.on('run:start', () => {\n+    sessions.registerSessionHooks()\n+  })\n+\n+  Commands.addAll({\n+    session (id, setup?: Function, options: {\n+      validate?: Function\n+    } = {}) {\n+      throwIfNoSessionSupport()\n+\n+      if (!id || !_.isString(id) && !_.isObject(id)) {\n+        throw new Error('cy.session requires a string or object as the first argument')\n+      }\n+\n+      // backup session command so we can set it as codeFrame location for errors later on\n+      const sessionCommand = cy.state('current')\n+\n+      // stringfy determinitically if we were given an object\n+      id = typeof id === 'string' ? id : stringifyStable(id)\n+\n+      if (options) {\n+        if (!_.isObject(options)) {\n+          throw new Error('cy.session optional third argument must be an object')\n+        }\n+\n+        const validopts = {\n+          'validate': 'function',\n+        }\n+\n+        Object.keys(options).forEach((key) => {\n+          const expectedType = validopts[key]\n+\n+          if (!expectedType) {\n+            throw new Error(`unexpected option **${key}** passed to cy.session options`)\n+          }\n+\n+          const actualType = typeof options[key]\n+\n+          if (actualType !== expectedType) {\n+            throw new Error(`invalid option **${key}** passed to cy.session options. Expected **${expectedType}**, got ${actualType}`)\n+          }\n+        })\n+      }\n+\n+      let existingSession = getActiveSession(id)\n+\n+      if (!setup) {\n+        if (!existingSession || !currentTestRegisteredSessions.has(id)) {\n+          $errUtils.throwErrByPath('sessions.session.not_found', { args: { id } })\n+        }\n+      } else {\n+        const isUniqSessionDefinition = !existingSession || existingSession.setup.toString().trim() !== setup.toString().trim()\n+\n+        if (isUniqSessionDefinition) {\n+          if (currentTestRegisteredSessions.has(id)) {\n+            throw $errUtils.errByPath('sessions.session.duplicateId', { id: existingSession.id })\n+          }\n+\n+          existingSession = sessions.defineSession({\n+            id,\n+            setup,\n+            validate: options.validate,\n+          })\n+\n+          currentTestRegisteredSessions.set(id, true)\n+        }\n+      }\n+\n+      const _log = Cypress.log({\n+        name: 'session',\n+        message: `${existingSession.id > 50 ? `${existingSession.id.substr(0, 47)}...` : existingSession.id}`,\n+        groupStart: true,\n+        snapshot: false,\n+      })\n+\n+      const dataLog = Cypress.log({\n+        name: 'session',\n+        sessionInfo: getSessionDetails(existingSession),\n+        message: `${existingSession.id > 50 ? `${existingSession.id.substr(0, 47)}...` : existingSession.id}`,\n+      })\n+\n+      async function runsetup (existingSession) {\n+        Cypress.log({\n+          name: 'Create New Session',\n+          state: 'passed',\n+          event: true,\n+          type: 'system',\n+          message: ``,\n+          groupStart: true,\n+        })\n+\n+        if (!hadValidationError) {\n+          _log.set({\n+            renderProps: () => {\n+              return {\n+                indicator: 'successful',\n+                message: `(new) ${_log.get().message}`,\n+              }\n+            },\n+          })\n+        }\n+\n+        await navigateAboutBlank()\n+\n+        cy.then(() => sessions.clearCurrentSessionData())\n+        .then(() => existingSession.setup())\n+\n+        return cy.then(() => sessions.getCurrentSessionData())\n+        .then((data) => {\n+          Cypress.log({ groupEnd: true, emitOnly: true })\n+\n+          _.extend(existingSession, data)\n+          existingSession.hydrated = true\n+\n+          setActiveSession({ [existingSession.id]: existingSession })\n+\n+          dataLog.set({\n+            consoleProps: () => getConsoleProps(existingSession),\n+          })\n+\n+          // persist the session to the server. Only matters in openMode OR if there's a top navigation on a future test.\n+          // eslint-disable-next-line no-console\n+\n+          // eslint-disable-next-line no-console\n+          return Cypress.backend('save:session', { ...existingSession, setup: existingSession.setup.toString() }).catch(console.error)\n+        })\n+      }\n+\n+      // uses Cypress hackery to resolve `false` if validate() resolves/returns false or throws/fails a cypress command.\n+      function validateSession (existingSession, _onFail) {\n+        navigateAboutBlank()\n+\n+        const validatingLog = Cypress.log({\n+          name: 'Validate Session',\n+          message: '',\n+          snapshot: false,\n+          type: 'system',\n+          state: 'passed',\n+          event: true,\n+          groupStart: true,\n+        })\n+\n+        const onSuccess = () => {\n+          validatingLog.set({\n+            name: 'Validate Session: valid',\n+            message: '',\n+            type: 'system',\n+            event: true,\n+            state: 'warning',\n+          })\n+\n+          Cypress.log({ groupEnd: true, emitOnly: true })\n+        }\n+\n+        const onFail = (err) => {\n+          _onFail(err, validatingLog)\n+        }\n+\n+        let _commandToResume: any = null\n+\n+        let _didThrow = false\n+\n+        let returnVal\n+\n+        try {\n+          returnVal = existingSession.validate()\n+        } catch (e) {\n+          onFail(e)\n+\n+          return\n+        }\n+\n+        if (typeof returnVal === 'object' && typeof returnVal.catch === 'function' && typeof returnVal.then === 'function') {\n+          return returnVal\n+          .then((val) => {\n+            if (val === false) {\n+              // set current command to cy.session for more accurate codeFrame\n+              cy.state('current', sessionCommand)\n+              throw $errUtils.errByPath('sessions.callback_returned_false', { reason: 'resolved false' })\n+            }\n+\n+            onSuccess()\n+          })\n+          .catch((err) => {\n+            onFail(err)\n+          })\n+        }\n+\n+        cy.state('onCommandFailed', (err, queue, next) => {\n+          const index = _.findIndex(queue.commands, (v: any) => _commandToResume && v.attributes.chainerId === _commandToResume.chainerId)\n+\n+          // attach codeframe and cleanse the stack trace since we may not hit the cy.fail callback\n+          if (typeof err === 'string') {\n+            err = new Error(err)\n+          }\n+\n+          err.stack = $stackUtils.normalizedStack(err)\n+\n+          err = $errUtils.enhanceStack({\n+            err,\n+            userInvocationStack: $stackUtils.getUserInvocationStack(err, Cypress.state),\n+            projectRoot: Cypress.config('projectRoot'),\n+          })\n+\n+          cy.state('index', index)\n+\n+          cy.state('onCommandFailed', null)\n+\n+          _didThrow = err\n+\n+          return next()\n+        })\n+\n+        const _catchCommand = cy.then(async () => {\n+          cy.state('onCommandFailed', null)\n+          if (_didThrow) return onFail((_didThrow))\n+\n+          if (returnVal === false) {\n+            // set current command to cy.session for more accurate codeframe\n+            cy.state('current', sessionCommand)\n+\n+            return onFail($errUtils.errByPath('sessions.callback_returned_false', { reason: 'returned false' }))\n+            // return onFail((new Error('Your `cy.session` **validate** callback returned false.')))\n+          }\n+\n+          if (returnVal === undefined || Cypress.isCy(returnVal)) {\n+            const val = cy.state('current').get('prev')?.attributes?.subject\n+\n+            if (val === false) {\n+              return onFail((new Error('Your `cy.session` **validate** callback resolved false')))\n+            }\n+          }\n+\n+          onSuccess()\n+        })\n+\n+        _commandToResume = _catchCommand\n+\n+        return _catchCommand\n+      }\n+\n+      let hadValidationError = false\n+      let onValidationError: Function = (err, log) => {\n+        log.set({\n+          name: 'Validate Session: invalid',\n+          message: '',\n+          type: 'system',\n+          event: true,\n+          state: 'warning',\n+        })\n+\n+        const errorLog = Cypress.log({\n+          showError: true,\n+          type: 'system',\n+          event: true,\n+          name: '',\n+          message: '',\n+        })\n+\n+        errorLog.error(err)\n+        errorLog.set({\n+          state: 'warn',\n+\n+        })\n+\n+        _log.set({\n+          renderProps: () => {\n+            return {\n+              indicator: 'bad',\n+              message: `(recreated) ${_log.get().message}`,\n+            }\n+          },\n+        })\n+\n+        Cypress.log({ groupEnd: true, emitOnly: true })\n+\n+        hadValidationError = true\n+\n+        return runsetup(existingSession)\n+        .then(() => {\n+          cy.then(() => {\n+            return validateSession(existingSession, throwValidationError)\n+          })\n+          .then(() => {\n+            cy.then(async () => {\n+              await navigateAboutBlank()\n+              Cypress.log({ groupEnd: true, name: '', message: '', emitOnly: true })\n+            })\n+          })\n+        })\n+      }\n+\n+      const throwValidationError = (err) => {\n+        err.message += '\\n\\nThis error occurred in a session validate hook after initializing the session. Because validation failed immediately after session setup we failed the test.'",
        "comment_created_at": "2021-07-28T13:00:01+00:00",
        "comment_author": "chrisbreiding",
        "comment_body": "This should use [$errUtils.modifyErrMsg](https://github.com/cypress-io/cypress/blob/8550842e3696095c9391e89f30c87af6369ecfb9/packages/driver/src/cypress/error_utils.js#L118) so that it updates the message in the stack as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "680240497",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 14350,
        "pr_file": "packages/driver/src/cy/commands/sessions.ts",
        "discussion_id": "678277015",
        "commented_code": "@@ -0,0 +1,822 @@\n+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)\n+    })\n+    .timeout(2000)\n+    .catch((err) => {\n+      Cypress.log({\n+        name: 'warning',\n+        message: `failed to set session storage on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+      })\n+    })\n+    .finally(() => {\n+      specWindow.removeEventListener('message', onPostMessage)\n+      $iframeContainer.remove()\n+    })\n+  }\n+\n+  async function getAllHtmlOrigins () {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const origins = _.uniq([..._.keys(await Cypress.backend('get:renderedHTMLOrigins')), current_origin]) as string[]\n+\n+    return origins\n+  }\n+\n+  function throwIfNoSessionSupport () {\n+    if (!Cypress.config('experimentalSessionSupport')) {\n+      // TODO: proper error msg\n+      throw new Error('experimentalSessionSupport is not enabled. You must enable the experimentalSessionSupport flag in order to use Cypress session commands')\n+    }\n+  }\n+\n+  const sessions = {\n+\n+    defineSession (options = {} as any) {\n+      const sess_state = {\n+        id: options.id,\n+        cookies: null,\n+        localStorage: null,\n+        setup: options.setup,\n+        hydrated: false,\n+        validate: options.validate,\n+      }\n+\n+      setActiveSession({ [sess_state.id]: sess_state })\n+\n+      return sess_state\n+    },\n+\n+    async clearAllSavedSessions () {\n+      clearActiveSessions()\n+\n+      return Cypress.backend('clear:session', null)\n+    },\n+\n+    async clearCurrentSessionData () {\n+      window.localStorage.clear()\n+      window.sessionStorage.clear()\n+\n+      await Promise.all([\n+        sessions.clearStorage(),\n+        sessions.clearCookies(),\n+      ])\n+    },\n+\n+    async setSessionData (data) {\n+      const allHtmlOrigins = await getAllHtmlOrigins()\n+\n+      let _localStorage = data.localStorage || []\n+      let _sessionStorage = data.sessionStorage || []\n+\n+      _.each(allHtmlOrigins, (v) => {\n+        if (!_.find(_localStorage, v)) {\n+          _localStorage = _localStorage.concat({ origin: v, clear: true })\n+        }\n+\n+        if (!_.find(_sessionStorage, v)) {\n+          _sessionStorage = _sessionStorage.concat({ origin: v, clear: true })\n+        }\n+      })\n+\n+      await Promise.all([\n+        sessions.setStorage({ localStorage: _localStorage, sessionStorage: _sessionStorage }),\n+        Cypress.automation('clear:cookies', null),\n+      ])\n+\n+      await sessions.setCookies(data.cookies)\n+    },\n+\n+    getCookies () {\n+      return Cypress.automation('get:cookies', {})\n+    },\n+\n+    setCookies (data) {\n+      return Cypress.automation('set:cookies', data)\n+    },\n+\n+    async clearCookies () {\n+      return Cypress.automation('clear:cookies', await sessions.getCookies())\n+    },\n+\n+    async getCurrentSessionData () {\n+      const storage = await sessions.getStorage({ origin: '*' })\n+\n+      let cookies = [] as any[]\n+\n+      cookies = await Cypress.automation('get:cookies', {})\n+\n+      const ses = {\n+        ...storage,\n+        cookies,\n+      }\n+\n+      return ses\n+    },\n+\n+    getSession (id) {\n+      return Cypress.backend('get:session', id)\n+    },\n+\n+    /**\n+     * 1) if we only need current_origin localStorage, access sync\n+     * 2) if cross-origin http, we need to load in iframe from our proxy that will intercept all http reqs at /__cypress/automation/*\n+     *      and postMessage() the localStorage value to us\n+     * 3) if cross-origin https, since we pass-thru https conntections in the proxy, we need to\n+     *      send a message telling our proxy server to intercept the next req to the https domain,\n+     *      then follow 2)\n+     */\n+    async getStorage (options = {}) {\n+      const specWindow = cy.state('specWindow')\n+\n+      if (!_.isObject(options)) {\n+        throw new Error('getStorage() takes an object')\n+      }\n+\n+      const opts = _.defaults({}, options, {\n+        origin: 'current_origin',\n+      })\n+\n+      const current_origin = $Location.create(window.location.href).origin\n+\n+      const origins = await mapOrigins(opts.origin)\n+\n+      const getResults = () => {\n+        return results\n+      }\n+      const results = {\n+        localStorage: [] as any[],\n+        sessionStorage: [] as any[],\n+      }\n+\n+      function pushValue (origin, value) {\n+        if (!_.isEmpty(value.localStorage)) {\n+          results.localStorage.push({ origin, value: value.localStorage })\n+        }\n+\n+        if (!_.isEmpty(value.sessionStorage)) {\n+          results.sessionStorage.push({ origin, value: value.sessionStorage })\n+        }\n+      }\n+\n+      const currentOriginIndex = origins.indexOf(current_origin)\n+\n+      if (currentOriginIndex !== -1) {\n+        origins.splice(currentOriginIndex, 1)\n+        // localStorage.length propery is not always accurate, we must stringify to check for entries\n+        // for ex) try setting localStorge.key = 'val' and reading localStorage.length, may be 0.\n+        const _localStorageStr = JSON.stringify(window.localStorage)\n+        const _localStorage = _localStorageStr.length > 2 && JSON.parse(_localStorageStr)\n+        const _sessionStorageStr = JSON.stringify(window.sessionStorage)\n+        const _sessionStorage = _sessionStorageStr.length > 2 && JSON.parse(JSON.stringify(window.sessionStorage))\n+\n+        const value = {} as any\n+\n+        if (_localStorage) {\n+          value.localStorage = _localStorage\n+        }\n+\n+        if (_sessionStorage) {\n+          value.sessionStorage = _sessionStorage\n+        }\n+\n+        pushValue(current_origin, value)\n+      }\n+\n+      if (_.isEmpty(origins)) {\n+        return getResults()\n+      }\n+\n+      if (current_origin.startsWith('https:')) {\n+        _.remove(origins, (v) => v.startsWith('http:'))\n+      }\n+\n+      const iframes: JQuery<HTMLElement>[] = []\n+\n+      const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+      _.each(origins, (u) => {\n+        const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/getLocalStorage`}\"></iframe>`)\n+\n+        $iframe.appendTo($iframeContainer)\n+        iframes.push($iframe)\n+      })\n+\n+      let onPostMessage\n+      const successOrigins = [] as string[]\n+\n+      await new Promise((resolve) => {\n+        onPostMessage = ((event) => {\n+          const data = event.data\n+\n+          if (data.type !== 'localStorage') return\n+\n+          const value = data.value\n+\n+          pushValue(event.origin, value)\n+\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        })\n+\n+        specWindow.addEventListener('message', onPostMessage)\n+      })\n+      .catch((err) => {\n+        Cypress.log({\n+          name: 'warning',\n+          message: `failed to set session storage data on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+        })\n+      })\n+      .finally(() => {\n+        specWindow.removeEventListener('message', onPostMessage)\n+        $iframeContainer.remove()\n+      })\n+\n+      return getResults()\n+    },\n+\n+    async clearStorage () {\n+      const origins = await getAllHtmlOrigins()\n+\n+      const originOptions = origins.map((v) => ({ origin: v, clear: true }))\n+\n+      await sessions.setStorage({\n+        localStorage: originOptions,\n+        sessionStorage: originOptions,\n+      })\n+    },\n+\n+    async setStorage (options: any, clearAll = false) {\n+      const current_origin = $Location.create(window.location.href).origin as string\n+\n+      const mapToCurrentOrigin = (v) => ({ ...v, origin: (v.origin && v.origin !== 'current_origin') ? $Location.create(v.origin).origin : current_origin })\n+\n+      const mappedLocalStorage = _.map(options.localStorage, (v) => {\n+        const mapped = { origin: v.origin, localStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.localStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const mappedSessionStorage = _.map(options.sessionStorage, (v) => {\n+        const mapped = { origin: v.origin, sessionStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.sessionStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const storageOptions = _.map(_.groupBy(mappedLocalStorage.concat(mappedSessionStorage), 'origin'), (v) => _.merge({}, ...v))\n+\n+      await _setStorageOnOrigins(storageOptions)\n+    },\n+\n+    registerSessionHooks () {\n+      Cypress.on('test:before:run:async', () => {\n+        if (Cypress.config('experimentalSessionSupport')) {\n+          currentTestRegisteredSessions.clear()\n+\n+          return navigateAboutBlank(false)\n+          .then(() => sessions.clearCurrentSessionData())\n+          .then(() => {\n+            return Cypress.backend('reset:renderedHTMLOrigins')\n+          })\n+        }\n+\n+        return\n+      })\n+    },\n+\n+  }\n+\n+  Cypress.on('run:start', () => {\n+    sessions.registerSessionHooks()\n+  })\n+\n+  Commands.addAll({\n+    session (id, setup?: Function, options: {\n+      validate?: Function\n+    } = {}) {\n+      throwIfNoSessionSupport()\n+\n+      if (!id || !_.isString(id) && !_.isObject(id)) {\n+        throw new Error('cy.session requires a string or object as the first argument')\n+      }\n+\n+      // backup session command so we can set it as codeFrame location for errors later on\n+      const sessionCommand = cy.state('current')\n+\n+      // stringfy determinitically if we were given an object\n+      id = typeof id === 'string' ? id : stringifyStable(id)\n+\n+      if (options) {\n+        if (!_.isObject(options)) {\n+          throw new Error('cy.session optional third argument must be an object')\n+        }\n+\n+        const validopts = {\n+          'validate': 'function',\n+        }\n+\n+        Object.keys(options).forEach((key) => {\n+          const expectedType = validopts[key]\n+\n+          if (!expectedType) {\n+            throw new Error(`unexpected option **${key}** passed to cy.session options`)\n+          }\n+\n+          const actualType = typeof options[key]\n+\n+          if (actualType !== expectedType) {\n+            throw new Error(`invalid option **${key}** passed to cy.session options. Expected **${expectedType}**, got ${actualType}`)\n+          }\n+        })\n+      }\n+\n+      let existingSession = getActiveSession(id)\n+\n+      if (!setup) {\n+        if (!existingSession || !currentTestRegisteredSessions.has(id)) {\n+          $errUtils.throwErrByPath('sessions.session.not_found', { args: { id } })\n+        }\n+      } else {\n+        const isUniqSessionDefinition = !existingSession || existingSession.setup.toString().trim() !== setup.toString().trim()\n+\n+        if (isUniqSessionDefinition) {\n+          if (currentTestRegisteredSessions.has(id)) {\n+            throw $errUtils.errByPath('sessions.session.duplicateId', { id: existingSession.id })\n+          }\n+\n+          existingSession = sessions.defineSession({\n+            id,\n+            setup,\n+            validate: options.validate,\n+          })\n+\n+          currentTestRegisteredSessions.set(id, true)\n+        }\n+      }\n+\n+      const _log = Cypress.log({\n+        name: 'session',\n+        message: `${existingSession.id > 50 ? `${existingSession.id.substr(0, 47)}...` : existingSession.id}`,\n+        groupStart: true,\n+        snapshot: false,\n+      })\n+\n+      const dataLog = Cypress.log({\n+        name: 'session',\n+        sessionInfo: getSessionDetails(existingSession),\n+        message: `${existingSession.id > 50 ? `${existingSession.id.substr(0, 47)}...` : existingSession.id}`,\n+      })\n+\n+      async function runsetup (existingSession) {\n+        Cypress.log({\n+          name: 'Create New Session',\n+          state: 'passed',\n+          event: true,\n+          type: 'system',\n+          message: ``,\n+          groupStart: true,\n+        })\n+\n+        if (!hadValidationError) {\n+          _log.set({\n+            renderProps: () => {\n+              return {\n+                indicator: 'successful',\n+                message: `(new) ${_log.get().message}`,\n+              }\n+            },\n+          })\n+        }\n+\n+        await navigateAboutBlank()\n+\n+        cy.then(() => sessions.clearCurrentSessionData())\n+        .then(() => existingSession.setup())\n+\n+        return cy.then(() => sessions.getCurrentSessionData())\n+        .then((data) => {\n+          Cypress.log({ groupEnd: true, emitOnly: true })\n+\n+          _.extend(existingSession, data)\n+          existingSession.hydrated = true\n+\n+          setActiveSession({ [existingSession.id]: existingSession })\n+\n+          dataLog.set({\n+            consoleProps: () => getConsoleProps(existingSession),\n+          })\n+\n+          // persist the session to the server. Only matters in openMode OR if there's a top navigation on a future test.\n+          // eslint-disable-next-line no-console\n+\n+          // eslint-disable-next-line no-console\n+          return Cypress.backend('save:session', { ...existingSession, setup: existingSession.setup.toString() }).catch(console.error)\n+        })\n+      }\n+\n+      // uses Cypress hackery to resolve `false` if validate() resolves/returns false or throws/fails a cypress command.\n+      function validateSession (existingSession, _onFail) {\n+        navigateAboutBlank()\n+\n+        const validatingLog = Cypress.log({\n+          name: 'Validate Session',\n+          message: '',\n+          snapshot: false,\n+          type: 'system',\n+          state: 'passed',\n+          event: true,\n+          groupStart: true,\n+        })\n+\n+        const onSuccess = () => {\n+          validatingLog.set({\n+            name: 'Validate Session: valid',\n+            message: '',\n+            type: 'system',\n+            event: true,\n+            state: 'warning',\n+          })\n+\n+          Cypress.log({ groupEnd: true, emitOnly: true })\n+        }\n+\n+        const onFail = (err) => {\n+          _onFail(err, validatingLog)\n+        }\n+\n+        let _commandToResume: any = null\n+\n+        let _didThrow = false\n+\n+        let returnVal\n+\n+        try {\n+          returnVal = existingSession.validate()\n+        } catch (e) {\n+          onFail(e)\n+\n+          return\n+        }\n+\n+        if (typeof returnVal === 'object' && typeof returnVal.catch === 'function' && typeof returnVal.then === 'function') {\n+          return returnVal\n+          .then((val) => {\n+            if (val === false) {\n+              // set current command to cy.session for more accurate codeFrame\n+              cy.state('current', sessionCommand)\n+              throw $errUtils.errByPath('sessions.callback_returned_false', { reason: 'resolved false' })\n+            }\n+\n+            onSuccess()\n+          })\n+          .catch((err) => {\n+            onFail(err)\n+          })\n+        }\n+\n+        cy.state('onCommandFailed', (err, queue, next) => {\n+          const index = _.findIndex(queue.commands, (v: any) => _commandToResume && v.attributes.chainerId === _commandToResume.chainerId)\n+\n+          // attach codeframe and cleanse the stack trace since we may not hit the cy.fail callback\n+          if (typeof err === 'string') {\n+            err = new Error(err)\n+          }\n+\n+          err.stack = $stackUtils.normalizedStack(err)\n+\n+          err = $errUtils.enhanceStack({\n+            err,\n+            userInvocationStack: $stackUtils.getUserInvocationStack(err, Cypress.state),\n+            projectRoot: Cypress.config('projectRoot'),\n+          })\n+\n+          cy.state('index', index)\n+\n+          cy.state('onCommandFailed', null)\n+\n+          _didThrow = err\n+\n+          return next()\n+        })\n+\n+        const _catchCommand = cy.then(async () => {\n+          cy.state('onCommandFailed', null)\n+          if (_didThrow) return onFail((_didThrow))\n+\n+          if (returnVal === false) {\n+            // set current command to cy.session for more accurate codeframe\n+            cy.state('current', sessionCommand)\n+\n+            return onFail($errUtils.errByPath('sessions.callback_returned_false', { reason: 'returned false' }))\n+            // return onFail((new Error('Your `cy.session` **validate** callback returned false.')))\n+          }\n+\n+          if (returnVal === undefined || Cypress.isCy(returnVal)) {\n+            const val = cy.state('current').get('prev')?.attributes?.subject\n+\n+            if (val === false) {\n+              return onFail((new Error('Your `cy.session` **validate** callback resolved false')))\n+            }\n+          }\n+\n+          onSuccess()\n+        })\n+\n+        _commandToResume = _catchCommand\n+\n+        return _catchCommand\n+      }\n+\n+      let hadValidationError = false\n+      let onValidationError: Function = (err, log) => {\n+        log.set({\n+          name: 'Validate Session: invalid',\n+          message: '',\n+          type: 'system',\n+          event: true,\n+          state: 'warning',\n+        })\n+\n+        const errorLog = Cypress.log({\n+          showError: true,\n+          type: 'system',\n+          event: true,\n+          name: '',\n+          message: '',\n+        })\n+\n+        errorLog.error(err)\n+        errorLog.set({\n+          state: 'warn',\n+\n+        })\n+\n+        _log.set({\n+          renderProps: () => {\n+            return {\n+              indicator: 'bad',\n+              message: `(recreated) ${_log.get().message}`,\n+            }\n+          },\n+        })\n+\n+        Cypress.log({ groupEnd: true, emitOnly: true })\n+\n+        hadValidationError = true\n+\n+        return runsetup(existingSession)\n+        .then(() => {\n+          cy.then(() => {\n+            return validateSession(existingSession, throwValidationError)\n+          })\n+          .then(() => {\n+            cy.then(async () => {\n+              await navigateAboutBlank()\n+              Cypress.log({ groupEnd: true, name: '', message: '', emitOnly: true })\n+            })\n+          })\n+        })\n+      }\n+\n+      const throwValidationError = (err) => {\n+        err.message += '\\n\\nThis error occurred in a session validate hook after initializing the session. Because validation failed immediately after session setup we failed the test.'",
        "comment_created_at": "2021-07-30T21:56:11+00:00",
        "comment_author": "kuceb",
        "comment_body": " 85d85eaeeb",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "678280748",
    "pr_number": 14350,
    "pr_file": "packages/driver/src/cy/commands/sessions.ts",
    "created_at": "2021-07-28T13:04:52+00:00",
    "commented_code": "+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)\n+    })\n+    .timeout(2000)\n+    .catch((err) => {\n+      Cypress.log({\n+        name: 'warning',\n+        message: `failed to set session storage on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+      })\n+    })\n+    .finally(() => {\n+      specWindow.removeEventListener('message', onPostMessage)\n+      $iframeContainer.remove()\n+    })\n+  }\n+\n+  async function getAllHtmlOrigins () {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const origins = _.uniq([..._.keys(await Cypress.backend('get:renderedHTMLOrigins')), current_origin]) as string[]\n+\n+    return origins\n+  }\n+\n+  function throwIfNoSessionSupport () {\n+    if (!Cypress.config('experimentalSessionSupport')) {\n+      // TODO: proper error msg\n+      throw new Error('experimentalSessionSupport is not enabled. You must enable the experimentalSessionSupport flag in order to use Cypress session commands')\n+    }\n+  }\n+\n+  const sessions = {\n+\n+    defineSession (options = {} as any) {\n+      const sess_state = {\n+        id: options.id,\n+        cookies: null,\n+        localStorage: null,\n+        setup: options.setup,\n+        hydrated: false,\n+        validate: options.validate,\n+      }\n+\n+      setActiveSession({ [sess_state.id]: sess_state })\n+\n+      return sess_state\n+    },\n+\n+    async clearAllSavedSessions () {\n+      clearActiveSessions()\n+\n+      return Cypress.backend('clear:session', null)\n+    },\n+\n+    async clearCurrentSessionData () {\n+      window.localStorage.clear()\n+      window.sessionStorage.clear()\n+\n+      await Promise.all([\n+        sessions.clearStorage(),\n+        sessions.clearCookies(),\n+      ])\n+    },\n+\n+    async setSessionData (data) {\n+      const allHtmlOrigins = await getAllHtmlOrigins()\n+\n+      let _localStorage = data.localStorage || []\n+      let _sessionStorage = data.sessionStorage || []\n+\n+      _.each(allHtmlOrigins, (v) => {\n+        if (!_.find(_localStorage, v)) {\n+          _localStorage = _localStorage.concat({ origin: v, clear: true })\n+        }\n+\n+        if (!_.find(_sessionStorage, v)) {\n+          _sessionStorage = _sessionStorage.concat({ origin: v, clear: true })\n+        }\n+      })\n+\n+      await Promise.all([\n+        sessions.setStorage({ localStorage: _localStorage, sessionStorage: _sessionStorage }),\n+        Cypress.automation('clear:cookies', null),\n+      ])\n+\n+      await sessions.setCookies(data.cookies)\n+    },\n+\n+    getCookies () {\n+      return Cypress.automation('get:cookies', {})\n+    },\n+\n+    setCookies (data) {\n+      return Cypress.automation('set:cookies', data)\n+    },\n+\n+    async clearCookies () {\n+      return Cypress.automation('clear:cookies', await sessions.getCookies())\n+    },\n+\n+    async getCurrentSessionData () {\n+      const storage = await sessions.getStorage({ origin: '*' })\n+\n+      let cookies = [] as any[]\n+\n+      cookies = await Cypress.automation('get:cookies', {})\n+\n+      const ses = {\n+        ...storage,\n+        cookies,\n+      }\n+\n+      return ses\n+    },\n+\n+    getSession (id) {\n+      return Cypress.backend('get:session', id)\n+    },\n+\n+    /**\n+     * 1) if we only need current_origin localStorage, access sync\n+     * 2) if cross-origin http, we need to load in iframe from our proxy that will intercept all http reqs at /__cypress/automation/*\n+     *      and postMessage() the localStorage value to us\n+     * 3) if cross-origin https, since we pass-thru https conntections in the proxy, we need to\n+     *      send a message telling our proxy server to intercept the next req to the https domain,\n+     *      then follow 2)\n+     */\n+    async getStorage (options = {}) {\n+      const specWindow = cy.state('specWindow')\n+\n+      if (!_.isObject(options)) {\n+        throw new Error('getStorage() takes an object')\n+      }\n+\n+      const opts = _.defaults({}, options, {\n+        origin: 'current_origin',\n+      })\n+\n+      const current_origin = $Location.create(window.location.href).origin\n+\n+      const origins = await mapOrigins(opts.origin)\n+\n+      const getResults = () => {\n+        return results\n+      }\n+      const results = {\n+        localStorage: [] as any[],\n+        sessionStorage: [] as any[],\n+      }\n+\n+      function pushValue (origin, value) {\n+        if (!_.isEmpty(value.localStorage)) {\n+          results.localStorage.push({ origin, value: value.localStorage })\n+        }\n+\n+        if (!_.isEmpty(value.sessionStorage)) {\n+          results.sessionStorage.push({ origin, value: value.sessionStorage })\n+        }\n+      }\n+\n+      const currentOriginIndex = origins.indexOf(current_origin)\n+\n+      if (currentOriginIndex !== -1) {\n+        origins.splice(currentOriginIndex, 1)\n+        // localStorage.length propery is not always accurate, we must stringify to check for entries\n+        // for ex) try setting localStorge.key = 'val' and reading localStorage.length, may be 0.\n+        const _localStorageStr = JSON.stringify(window.localStorage)\n+        const _localStorage = _localStorageStr.length > 2 && JSON.parse(_localStorageStr)\n+        const _sessionStorageStr = JSON.stringify(window.sessionStorage)\n+        const _sessionStorage = _sessionStorageStr.length > 2 && JSON.parse(JSON.stringify(window.sessionStorage))\n+\n+        const value = {} as any\n+\n+        if (_localStorage) {\n+          value.localStorage = _localStorage\n+        }\n+\n+        if (_sessionStorage) {\n+          value.sessionStorage = _sessionStorage\n+        }\n+\n+        pushValue(current_origin, value)\n+      }\n+\n+      if (_.isEmpty(origins)) {\n+        return getResults()\n+      }\n+\n+      if (current_origin.startsWith('https:')) {\n+        _.remove(origins, (v) => v.startsWith('http:'))\n+      }\n+\n+      const iframes: JQuery<HTMLElement>[] = []\n+\n+      const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+      _.each(origins, (u) => {\n+        const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/getLocalStorage`}\"></iframe>`)\n+\n+        $iframe.appendTo($iframeContainer)\n+        iframes.push($iframe)\n+      })\n+\n+      let onPostMessage\n+      const successOrigins = [] as string[]\n+\n+      await new Promise((resolve) => {\n+        onPostMessage = ((event) => {\n+          const data = event.data\n+\n+          if (data.type !== 'localStorage') return\n+\n+          const value = data.value\n+\n+          pushValue(event.origin, value)\n+\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        })\n+\n+        specWindow.addEventListener('message', onPostMessage)\n+      })\n+      .catch((err) => {\n+        Cypress.log({\n+          name: 'warning',\n+          message: `failed to set session storage data on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+        })\n+      })\n+      .finally(() => {\n+        specWindow.removeEventListener('message', onPostMessage)\n+        $iframeContainer.remove()\n+      })\n+\n+      return getResults()\n+    },\n+\n+    async clearStorage () {\n+      const origins = await getAllHtmlOrigins()\n+\n+      const originOptions = origins.map((v) => ({ origin: v, clear: true }))\n+\n+      await sessions.setStorage({\n+        localStorage: originOptions,\n+        sessionStorage: originOptions,\n+      })\n+    },\n+\n+    async setStorage (options: any, clearAll = false) {\n+      const current_origin = $Location.create(window.location.href).origin as string\n+\n+      const mapToCurrentOrigin = (v) => ({ ...v, origin: (v.origin && v.origin !== 'current_origin') ? $Location.create(v.origin).origin : current_origin })\n+\n+      const mappedLocalStorage = _.map(options.localStorage, (v) => {\n+        const mapped = { origin: v.origin, localStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.localStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const mappedSessionStorage = _.map(options.sessionStorage, (v) => {\n+        const mapped = { origin: v.origin, sessionStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.sessionStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const storageOptions = _.map(_.groupBy(mappedLocalStorage.concat(mappedSessionStorage), 'origin'), (v) => _.merge({}, ...v))\n+\n+      await _setStorageOnOrigins(storageOptions)\n+    },\n+\n+    registerSessionHooks () {\n+      Cypress.on('test:before:run:async', () => {\n+        if (Cypress.config('experimentalSessionSupport')) {\n+          currentTestRegisteredSessions.clear()\n+\n+          return navigateAboutBlank(false)\n+          .then(() => sessions.clearCurrentSessionData())\n+          .then(() => {\n+            return Cypress.backend('reset:renderedHTMLOrigins')\n+          })\n+        }\n+\n+        return\n+      })\n+    },\n+\n+  }\n+\n+  Cypress.on('run:start', () => {\n+    sessions.registerSessionHooks()\n+  })\n+\n+  Commands.addAll({\n+    session (id, setup?: Function, options: {\n+      validate?: Function\n+    } = {}) {\n+      throwIfNoSessionSupport()\n+\n+      if (!id || !_.isString(id) && !_.isObject(id)) {\n+        throw new Error('cy.session requires a string or object as the first argument')\n+      }\n+\n+      // backup session command so we can set it as codeFrame location for errors later on\n+      const sessionCommand = cy.state('current')\n+\n+      // stringfy determinitically if we were given an object\n+      id = typeof id === 'string' ? id : stringifyStable(id)\n+\n+      if (options) {\n+        if (!_.isObject(options)) {\n+          throw new Error('cy.session optional third argument must be an object')\n+        }\n+\n+        const validopts = {\n+          'validate': 'function',\n+        }\n+\n+        Object.keys(options).forEach((key) => {\n+          const expectedType = validopts[key]\n+\n+          if (!expectedType) {\n+            throw new Error(`unexpected option **${key}** passed to cy.session options`)\n+          }\n+\n+          const actualType = typeof options[key]\n+\n+          if (actualType !== expectedType) {\n+            throw new Error(`invalid option **${key}** passed to cy.session options. Expected **${expectedType}**, got ${actualType}`)\n+          }\n+        })\n+      }",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "678280748",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 14350,
        "pr_file": "packages/driver/src/cy/commands/sessions.ts",
        "discussion_id": "678280748",
        "commented_code": "@@ -0,0 +1,822 @@\n+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)\n+    })\n+    .timeout(2000)\n+    .catch((err) => {\n+      Cypress.log({\n+        name: 'warning',\n+        message: `failed to set session storage on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+      })\n+    })\n+    .finally(() => {\n+      specWindow.removeEventListener('message', onPostMessage)\n+      $iframeContainer.remove()\n+    })\n+  }\n+\n+  async function getAllHtmlOrigins () {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const origins = _.uniq([..._.keys(await Cypress.backend('get:renderedHTMLOrigins')), current_origin]) as string[]\n+\n+    return origins\n+  }\n+\n+  function throwIfNoSessionSupport () {\n+    if (!Cypress.config('experimentalSessionSupport')) {\n+      // TODO: proper error msg\n+      throw new Error('experimentalSessionSupport is not enabled. You must enable the experimentalSessionSupport flag in order to use Cypress session commands')\n+    }\n+  }\n+\n+  const sessions = {\n+\n+    defineSession (options = {} as any) {\n+      const sess_state = {\n+        id: options.id,\n+        cookies: null,\n+        localStorage: null,\n+        setup: options.setup,\n+        hydrated: false,\n+        validate: options.validate,\n+      }\n+\n+      setActiveSession({ [sess_state.id]: sess_state })\n+\n+      return sess_state\n+    },\n+\n+    async clearAllSavedSessions () {\n+      clearActiveSessions()\n+\n+      return Cypress.backend('clear:session', null)\n+    },\n+\n+    async clearCurrentSessionData () {\n+      window.localStorage.clear()\n+      window.sessionStorage.clear()\n+\n+      await Promise.all([\n+        sessions.clearStorage(),\n+        sessions.clearCookies(),\n+      ])\n+    },\n+\n+    async setSessionData (data) {\n+      const allHtmlOrigins = await getAllHtmlOrigins()\n+\n+      let _localStorage = data.localStorage || []\n+      let _sessionStorage = data.sessionStorage || []\n+\n+      _.each(allHtmlOrigins, (v) => {\n+        if (!_.find(_localStorage, v)) {\n+          _localStorage = _localStorage.concat({ origin: v, clear: true })\n+        }\n+\n+        if (!_.find(_sessionStorage, v)) {\n+          _sessionStorage = _sessionStorage.concat({ origin: v, clear: true })\n+        }\n+      })\n+\n+      await Promise.all([\n+        sessions.setStorage({ localStorage: _localStorage, sessionStorage: _sessionStorage }),\n+        Cypress.automation('clear:cookies', null),\n+      ])\n+\n+      await sessions.setCookies(data.cookies)\n+    },\n+\n+    getCookies () {\n+      return Cypress.automation('get:cookies', {})\n+    },\n+\n+    setCookies (data) {\n+      return Cypress.automation('set:cookies', data)\n+    },\n+\n+    async clearCookies () {\n+      return Cypress.automation('clear:cookies', await sessions.getCookies())\n+    },\n+\n+    async getCurrentSessionData () {\n+      const storage = await sessions.getStorage({ origin: '*' })\n+\n+      let cookies = [] as any[]\n+\n+      cookies = await Cypress.automation('get:cookies', {})\n+\n+      const ses = {\n+        ...storage,\n+        cookies,\n+      }\n+\n+      return ses\n+    },\n+\n+    getSession (id) {\n+      return Cypress.backend('get:session', id)\n+    },\n+\n+    /**\n+     * 1) if we only need current_origin localStorage, access sync\n+     * 2) if cross-origin http, we need to load in iframe from our proxy that will intercept all http reqs at /__cypress/automation/*\n+     *      and postMessage() the localStorage value to us\n+     * 3) if cross-origin https, since we pass-thru https conntections in the proxy, we need to\n+     *      send a message telling our proxy server to intercept the next req to the https domain,\n+     *      then follow 2)\n+     */\n+    async getStorage (options = {}) {\n+      const specWindow = cy.state('specWindow')\n+\n+      if (!_.isObject(options)) {\n+        throw new Error('getStorage() takes an object')\n+      }\n+\n+      const opts = _.defaults({}, options, {\n+        origin: 'current_origin',\n+      })\n+\n+      const current_origin = $Location.create(window.location.href).origin\n+\n+      const origins = await mapOrigins(opts.origin)\n+\n+      const getResults = () => {\n+        return results\n+      }\n+      const results = {\n+        localStorage: [] as any[],\n+        sessionStorage: [] as any[],\n+      }\n+\n+      function pushValue (origin, value) {\n+        if (!_.isEmpty(value.localStorage)) {\n+          results.localStorage.push({ origin, value: value.localStorage })\n+        }\n+\n+        if (!_.isEmpty(value.sessionStorage)) {\n+          results.sessionStorage.push({ origin, value: value.sessionStorage })\n+        }\n+      }\n+\n+      const currentOriginIndex = origins.indexOf(current_origin)\n+\n+      if (currentOriginIndex !== -1) {\n+        origins.splice(currentOriginIndex, 1)\n+        // localStorage.length propery is not always accurate, we must stringify to check for entries\n+        // for ex) try setting localStorge.key = 'val' and reading localStorage.length, may be 0.\n+        const _localStorageStr = JSON.stringify(window.localStorage)\n+        const _localStorage = _localStorageStr.length > 2 && JSON.parse(_localStorageStr)\n+        const _sessionStorageStr = JSON.stringify(window.sessionStorage)\n+        const _sessionStorage = _sessionStorageStr.length > 2 && JSON.parse(JSON.stringify(window.sessionStorage))\n+\n+        const value = {} as any\n+\n+        if (_localStorage) {\n+          value.localStorage = _localStorage\n+        }\n+\n+        if (_sessionStorage) {\n+          value.sessionStorage = _sessionStorage\n+        }\n+\n+        pushValue(current_origin, value)\n+      }\n+\n+      if (_.isEmpty(origins)) {\n+        return getResults()\n+      }\n+\n+      if (current_origin.startsWith('https:')) {\n+        _.remove(origins, (v) => v.startsWith('http:'))\n+      }\n+\n+      const iframes: JQuery<HTMLElement>[] = []\n+\n+      const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+      _.each(origins, (u) => {\n+        const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/getLocalStorage`}\"></iframe>`)\n+\n+        $iframe.appendTo($iframeContainer)\n+        iframes.push($iframe)\n+      })\n+\n+      let onPostMessage\n+      const successOrigins = [] as string[]\n+\n+      await new Promise((resolve) => {\n+        onPostMessage = ((event) => {\n+          const data = event.data\n+\n+          if (data.type !== 'localStorage') return\n+\n+          const value = data.value\n+\n+          pushValue(event.origin, value)\n+\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        })\n+\n+        specWindow.addEventListener('message', onPostMessage)\n+      })\n+      .catch((err) => {\n+        Cypress.log({\n+          name: 'warning',\n+          message: `failed to set session storage data on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+        })\n+      })\n+      .finally(() => {\n+        specWindow.removeEventListener('message', onPostMessage)\n+        $iframeContainer.remove()\n+      })\n+\n+      return getResults()\n+    },\n+\n+    async clearStorage () {\n+      const origins = await getAllHtmlOrigins()\n+\n+      const originOptions = origins.map((v) => ({ origin: v, clear: true }))\n+\n+      await sessions.setStorage({\n+        localStorage: originOptions,\n+        sessionStorage: originOptions,\n+      })\n+    },\n+\n+    async setStorage (options: any, clearAll = false) {\n+      const current_origin = $Location.create(window.location.href).origin as string\n+\n+      const mapToCurrentOrigin = (v) => ({ ...v, origin: (v.origin && v.origin !== 'current_origin') ? $Location.create(v.origin).origin : current_origin })\n+\n+      const mappedLocalStorage = _.map(options.localStorage, (v) => {\n+        const mapped = { origin: v.origin, localStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.localStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const mappedSessionStorage = _.map(options.sessionStorage, (v) => {\n+        const mapped = { origin: v.origin, sessionStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.sessionStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const storageOptions = _.map(_.groupBy(mappedLocalStorage.concat(mappedSessionStorage), 'origin'), (v) => _.merge({}, ...v))\n+\n+      await _setStorageOnOrigins(storageOptions)\n+    },\n+\n+    registerSessionHooks () {\n+      Cypress.on('test:before:run:async', () => {\n+        if (Cypress.config('experimentalSessionSupport')) {\n+          currentTestRegisteredSessions.clear()\n+\n+          return navigateAboutBlank(false)\n+          .then(() => sessions.clearCurrentSessionData())\n+          .then(() => {\n+            return Cypress.backend('reset:renderedHTMLOrigins')\n+          })\n+        }\n+\n+        return\n+      })\n+    },\n+\n+  }\n+\n+  Cypress.on('run:start', () => {\n+    sessions.registerSessionHooks()\n+  })\n+\n+  Commands.addAll({\n+    session (id, setup?: Function, options: {\n+      validate?: Function\n+    } = {}) {\n+      throwIfNoSessionSupport()\n+\n+      if (!id || !_.isString(id) && !_.isObject(id)) {\n+        throw new Error('cy.session requires a string or object as the first argument')\n+      }\n+\n+      // backup session command so we can set it as codeFrame location for errors later on\n+      const sessionCommand = cy.state('current')\n+\n+      // stringfy determinitically if we were given an object\n+      id = typeof id === 'string' ? id : stringifyStable(id)\n+\n+      if (options) {\n+        if (!_.isObject(options)) {\n+          throw new Error('cy.session optional third argument must be an object')\n+        }\n+\n+        const validopts = {\n+          'validate': 'function',\n+        }\n+\n+        Object.keys(options).forEach((key) => {\n+          const expectedType = validopts[key]\n+\n+          if (!expectedType) {\n+            throw new Error(`unexpected option **${key}** passed to cy.session options`)\n+          }\n+\n+          const actualType = typeof options[key]\n+\n+          if (actualType !== expectedType) {\n+            throw new Error(`invalid option **${key}** passed to cy.session options. Expected **${expectedType}**, got ${actualType}`)\n+          }\n+        })\n+      }",
        "comment_created_at": "2021-07-28T13:04:52+00:00",
        "comment_author": "chrisbreiding",
        "comment_body": "These error messages should be in [error_messages.js](https://github.com/cypress-io/cypress/blob/8550842e3696095c9391e89f30c87af6369ecfb9/packages/driver/src/cypress/error_messages.js), utilizing `cmd('sessions')` so it's formatted consistently. They should all include the value of the argument when it's incorrect. For example, `cy.session() optional third argument must be an object, you passed: true`.",
        "pr_file_module": null
      },
      {
        "comment_id": "680240449",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 14350,
        "pr_file": "packages/driver/src/cy/commands/sessions.ts",
        "discussion_id": "678280748",
        "commented_code": "@@ -0,0 +1,822 @@\n+import _ from 'lodash'\n+import $ from 'jquery'\n+import $Location from '../../cypress/location'\n+import $errUtils from '../../cypress/error_utils'\n+import stringifyStable from 'json-stable-stringify'\n+import * as $stackUtils from '../../cypress/stack_utils'\n+const currentTestRegisteredSessions = new Map()\n+const getSessionDetails = (sessState) => {\n+  return {\n+    id: sessState.id,\n+    data: _.merge(\n+      _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v.length })),\n+      ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: Object.keys(v.value).length } })),\n+    ) }\n+}\n+const getSessionDetailsForTable = (sessState) => {\n+  return _.merge(\n+    _.mapValues(_.groupBy(sessState.cookies, 'domain'), (v) => ({ cookies: v })),\n+    ..._.map(sessState.localStorage, (v) => ({ [$Location.create(v.origin).hostname]: { localStorage: v } })),\n+  )\n+}\n+\n+const getConsoleProps = (sessState) => {\n+  const ret = {\n+    id: sessState.id,\n+    table: _.compact(_.flatMap(getSessionDetailsForTable(sessState), (val, domain) => {\n+      return [() => {\n+        return {\n+          name: `\ud83c\udf6a Cookies - ${domain} (${val.cookies.length})`,\n+          data: val.cookies,\n+        }\n+      },\n+      val.localStorage && (() => {\n+        return {\n+          name: `\ud83d\udcc1 Storage - ${domain} (${_.keys(val.localStorage.value).length})`,\n+          data: _.map(val.localStorage.value, (value, key) => {\n+            return {\n+              key, value,\n+            }\n+          }),\n+        }\n+      })]\n+    }))\n+    ,\n+  }\n+\n+  return ret\n+}\n+\n+export default function (Commands, Cypress, cy) {\n+  const { Promise } = Cypress\n+\n+  const setActiveSession = (obj) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    const newSessions = { ...currentSessions, ...obj }\n+\n+    cy.state('activeSessions', newSessions)\n+  }\n+  const getActiveSession = (id) => {\n+    const currentSessions = cy.state('activeSessions') || {}\n+\n+    return currentSessions[id]\n+  }\n+  const clearActiveSessions = () => {\n+    const curSessions = cy.state('activeSessions') || {}\n+\n+    cy.state('activeSessions', _.mapValues(curSessions, (v) => ({ ...v, hydrated: false })))\n+  }\n+\n+  async function mapOrigins (origins) {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    return _.uniq(\n+      _.flatten(await Promise.map(\n+        ([] as string[]).concat(origins), async (v) => {\n+          if (v === '*') {\n+            return _.keys(await Cypress.backend('get:renderedHTMLOrigins')).concat([current_origin])\n+          }\n+\n+          if (v === 'current_origin') return current_origin\n+\n+          return $Location.create(v).origin\n+        },\n+      )),\n+    ) as string[]\n+  }\n+\n+  async function _setStorageOnOrigins (originOptions) {\n+    const specWindow = cy.state('specWindow')\n+\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const current_origin_options_index = _.findIndex(originOptions, { origin: current_origin })\n+\n+    if (current_origin_options_index !== -1) {\n+      const opts = originOptions.splice(current_origin_options_index, 1)[0]\n+\n+      if (!_.isEmpty(opts.localStorage)) {\n+        if (opts.localStorage.clear) {\n+          window.localStorage.clear()\n+        }\n+\n+        _.each(opts.localStorage.value, (val, key) => localStorage.setItem(key, val))\n+      }\n+\n+      if (opts.sessionStorage) {\n+        if (opts.sessionStorage.clear) {\n+          window.sessionStorage.clear()\n+        }\n+\n+        _.each(opts.sessionStorage.value, (val, key) => sessionStorage.setItem(key, val))\n+      }\n+    }\n+\n+    if (_.isEmpty(originOptions)) {\n+      return\n+    }\n+\n+    const origins = originOptions.map((v) => v.origin) as string[]\n+\n+    const iframes: JQuery<HTMLElement>[] = []\n+\n+    const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+    // if we're on an https domain, there is no way for the secure context to access insecure origins from iframes\n+    // since there is no way for the app to access localStorage on insecure contexts, we don't have to clear any localStorage on http domains.\n+    if (current_origin.startsWith('https:')) {\n+      _.remove(origins, (v) => v.startsWith('http:'))\n+    }\n+\n+    _.each(origins, (u) => {\n+      const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/setLocalStorage?${u}`}\"></iframe>`)\n+\n+      $iframe.appendTo($iframeContainer)\n+      iframes.push($iframe)\n+    })\n+\n+    let onPostMessage\n+\n+    const successOrigins = [] as string[]\n+\n+    await new Promise((resolve) => {\n+      onPostMessage = (event) => {\n+        const data = event.data\n+\n+        if (data.type === 'set:storage:load') {\n+          if (!event.source) {\n+            throw new Error('failed to get localStorage')\n+          }\n+\n+          const opts = _.find(originOptions, { origin: event.origin })!\n+\n+          event.source.postMessage({ type: 'set:storage:data', data: opts }, '*')\n+        } else if (data.type === 'set:storage:complete') {\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        }\n+      }\n+\n+      specWindow.addEventListener('message', onPostMessage)\n+    })\n+    .timeout(2000)\n+    .catch((err) => {\n+      Cypress.log({\n+        name: 'warning',\n+        message: `failed to set session storage on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+      })\n+    })\n+    .finally(() => {\n+      specWindow.removeEventListener('message', onPostMessage)\n+      $iframeContainer.remove()\n+    })\n+  }\n+\n+  async function getAllHtmlOrigins () {\n+    const current_origin = $Location.create(window.location.href).origin\n+\n+    const origins = _.uniq([..._.keys(await Cypress.backend('get:renderedHTMLOrigins')), current_origin]) as string[]\n+\n+    return origins\n+  }\n+\n+  function throwIfNoSessionSupport () {\n+    if (!Cypress.config('experimentalSessionSupport')) {\n+      // TODO: proper error msg\n+      throw new Error('experimentalSessionSupport is not enabled. You must enable the experimentalSessionSupport flag in order to use Cypress session commands')\n+    }\n+  }\n+\n+  const sessions = {\n+\n+    defineSession (options = {} as any) {\n+      const sess_state = {\n+        id: options.id,\n+        cookies: null,\n+        localStorage: null,\n+        setup: options.setup,\n+        hydrated: false,\n+        validate: options.validate,\n+      }\n+\n+      setActiveSession({ [sess_state.id]: sess_state })\n+\n+      return sess_state\n+    },\n+\n+    async clearAllSavedSessions () {\n+      clearActiveSessions()\n+\n+      return Cypress.backend('clear:session', null)\n+    },\n+\n+    async clearCurrentSessionData () {\n+      window.localStorage.clear()\n+      window.sessionStorage.clear()\n+\n+      await Promise.all([\n+        sessions.clearStorage(),\n+        sessions.clearCookies(),\n+      ])\n+    },\n+\n+    async setSessionData (data) {\n+      const allHtmlOrigins = await getAllHtmlOrigins()\n+\n+      let _localStorage = data.localStorage || []\n+      let _sessionStorage = data.sessionStorage || []\n+\n+      _.each(allHtmlOrigins, (v) => {\n+        if (!_.find(_localStorage, v)) {\n+          _localStorage = _localStorage.concat({ origin: v, clear: true })\n+        }\n+\n+        if (!_.find(_sessionStorage, v)) {\n+          _sessionStorage = _sessionStorage.concat({ origin: v, clear: true })\n+        }\n+      })\n+\n+      await Promise.all([\n+        sessions.setStorage({ localStorage: _localStorage, sessionStorage: _sessionStorage }),\n+        Cypress.automation('clear:cookies', null),\n+      ])\n+\n+      await sessions.setCookies(data.cookies)\n+    },\n+\n+    getCookies () {\n+      return Cypress.automation('get:cookies', {})\n+    },\n+\n+    setCookies (data) {\n+      return Cypress.automation('set:cookies', data)\n+    },\n+\n+    async clearCookies () {\n+      return Cypress.automation('clear:cookies', await sessions.getCookies())\n+    },\n+\n+    async getCurrentSessionData () {\n+      const storage = await sessions.getStorage({ origin: '*' })\n+\n+      let cookies = [] as any[]\n+\n+      cookies = await Cypress.automation('get:cookies', {})\n+\n+      const ses = {\n+        ...storage,\n+        cookies,\n+      }\n+\n+      return ses\n+    },\n+\n+    getSession (id) {\n+      return Cypress.backend('get:session', id)\n+    },\n+\n+    /**\n+     * 1) if we only need current_origin localStorage, access sync\n+     * 2) if cross-origin http, we need to load in iframe from our proxy that will intercept all http reqs at /__cypress/automation/*\n+     *      and postMessage() the localStorage value to us\n+     * 3) if cross-origin https, since we pass-thru https conntections in the proxy, we need to\n+     *      send a message telling our proxy server to intercept the next req to the https domain,\n+     *      then follow 2)\n+     */\n+    async getStorage (options = {}) {\n+      const specWindow = cy.state('specWindow')\n+\n+      if (!_.isObject(options)) {\n+        throw new Error('getStorage() takes an object')\n+      }\n+\n+      const opts = _.defaults({}, options, {\n+        origin: 'current_origin',\n+      })\n+\n+      const current_origin = $Location.create(window.location.href).origin\n+\n+      const origins = await mapOrigins(opts.origin)\n+\n+      const getResults = () => {\n+        return results\n+      }\n+      const results = {\n+        localStorage: [] as any[],\n+        sessionStorage: [] as any[],\n+      }\n+\n+      function pushValue (origin, value) {\n+        if (!_.isEmpty(value.localStorage)) {\n+          results.localStorage.push({ origin, value: value.localStorage })\n+        }\n+\n+        if (!_.isEmpty(value.sessionStorage)) {\n+          results.sessionStorage.push({ origin, value: value.sessionStorage })\n+        }\n+      }\n+\n+      const currentOriginIndex = origins.indexOf(current_origin)\n+\n+      if (currentOriginIndex !== -1) {\n+        origins.splice(currentOriginIndex, 1)\n+        // localStorage.length propery is not always accurate, we must stringify to check for entries\n+        // for ex) try setting localStorge.key = 'val' and reading localStorage.length, may be 0.\n+        const _localStorageStr = JSON.stringify(window.localStorage)\n+        const _localStorage = _localStorageStr.length > 2 && JSON.parse(_localStorageStr)\n+        const _sessionStorageStr = JSON.stringify(window.sessionStorage)\n+        const _sessionStorage = _sessionStorageStr.length > 2 && JSON.parse(JSON.stringify(window.sessionStorage))\n+\n+        const value = {} as any\n+\n+        if (_localStorage) {\n+          value.localStorage = _localStorage\n+        }\n+\n+        if (_sessionStorage) {\n+          value.sessionStorage = _sessionStorage\n+        }\n+\n+        pushValue(current_origin, value)\n+      }\n+\n+      if (_.isEmpty(origins)) {\n+        return getResults()\n+      }\n+\n+      if (current_origin.startsWith('https:')) {\n+        _.remove(origins, (v) => v.startsWith('http:'))\n+      }\n+\n+      const iframes: JQuery<HTMLElement>[] = []\n+\n+      const $iframeContainer = $(`<div style=\"display:none\"></div>`).appendTo($('body', specWindow.document))\n+\n+      _.each(origins, (u) => {\n+        const $iframe = $(`<iframe src=\"${`${u}/__cypress/automation/getLocalStorage`}\"></iframe>`)\n+\n+        $iframe.appendTo($iframeContainer)\n+        iframes.push($iframe)\n+      })\n+\n+      let onPostMessage\n+      const successOrigins = [] as string[]\n+\n+      await new Promise((resolve) => {\n+        onPostMessage = ((event) => {\n+          const data = event.data\n+\n+          if (data.type !== 'localStorage') return\n+\n+          const value = data.value\n+\n+          pushValue(event.origin, value)\n+\n+          successOrigins.push(event.origin)\n+          if (successOrigins.length === origins.length) {\n+            resolve()\n+          }\n+        })\n+\n+        specWindow.addEventListener('message', onPostMessage)\n+      })\n+      .catch((err) => {\n+        Cypress.log({\n+          name: 'warning',\n+          message: `failed to set session storage data on origin(s): ${_.xor(origins, successOrigins).join(', ')}`,\n+        })\n+      })\n+      .finally(() => {\n+        specWindow.removeEventListener('message', onPostMessage)\n+        $iframeContainer.remove()\n+      })\n+\n+      return getResults()\n+    },\n+\n+    async clearStorage () {\n+      const origins = await getAllHtmlOrigins()\n+\n+      const originOptions = origins.map((v) => ({ origin: v, clear: true }))\n+\n+      await sessions.setStorage({\n+        localStorage: originOptions,\n+        sessionStorage: originOptions,\n+      })\n+    },\n+\n+    async setStorage (options: any, clearAll = false) {\n+      const current_origin = $Location.create(window.location.href).origin as string\n+\n+      const mapToCurrentOrigin = (v) => ({ ...v, origin: (v.origin && v.origin !== 'current_origin') ? $Location.create(v.origin).origin : current_origin })\n+\n+      const mappedLocalStorage = _.map(options.localStorage, (v) => {\n+        const mapped = { origin: v.origin, localStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.localStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const mappedSessionStorage = _.map(options.sessionStorage, (v) => {\n+        const mapped = { origin: v.origin, sessionStorage: _.pick(v, 'value', 'clear') }\n+\n+        if (clearAll) {\n+          mapped.sessionStorage.clear = true\n+        }\n+\n+        return mapped\n+      }).map(mapToCurrentOrigin)\n+\n+      const storageOptions = _.map(_.groupBy(mappedLocalStorage.concat(mappedSessionStorage), 'origin'), (v) => _.merge({}, ...v))\n+\n+      await _setStorageOnOrigins(storageOptions)\n+    },\n+\n+    registerSessionHooks () {\n+      Cypress.on('test:before:run:async', () => {\n+        if (Cypress.config('experimentalSessionSupport')) {\n+          currentTestRegisteredSessions.clear()\n+\n+          return navigateAboutBlank(false)\n+          .then(() => sessions.clearCurrentSessionData())\n+          .then(() => {\n+            return Cypress.backend('reset:renderedHTMLOrigins')\n+          })\n+        }\n+\n+        return\n+      })\n+    },\n+\n+  }\n+\n+  Cypress.on('run:start', () => {\n+    sessions.registerSessionHooks()\n+  })\n+\n+  Commands.addAll({\n+    session (id, setup?: Function, options: {\n+      validate?: Function\n+    } = {}) {\n+      throwIfNoSessionSupport()\n+\n+      if (!id || !_.isString(id) && !_.isObject(id)) {\n+        throw new Error('cy.session requires a string or object as the first argument')\n+      }\n+\n+      // backup session command so we can set it as codeFrame location for errors later on\n+      const sessionCommand = cy.state('current')\n+\n+      // stringfy determinitically if we were given an object\n+      id = typeof id === 'string' ? id : stringifyStable(id)\n+\n+      if (options) {\n+        if (!_.isObject(options)) {\n+          throw new Error('cy.session optional third argument must be an object')\n+        }\n+\n+        const validopts = {\n+          'validate': 'function',\n+        }\n+\n+        Object.keys(options).forEach((key) => {\n+          const expectedType = validopts[key]\n+\n+          if (!expectedType) {\n+            throw new Error(`unexpected option **${key}** passed to cy.session options`)\n+          }\n+\n+          const actualType = typeof options[key]\n+\n+          if (actualType !== expectedType) {\n+            throw new Error(`invalid option **${key}** passed to cy.session options. Expected **${expectedType}**, got ${actualType}`)\n+          }\n+        })\n+      }",
        "comment_created_at": "2021-07-30T21:56:07+00:00",
        "comment_author": "kuceb",
        "comment_body": " 85d85eaeeb",
        "pr_file_module": null
      }
    ]
  }
]