[
  {
    "discussion_id": "2293846557",
    "pr_number": 32337,
    "pr_file": "packages/server/lib/plugins/preprocessor.ts",
    "created_at": "2025-08-25T14:00:20+00:00",
    "commented_code": "+import '../cwd'\n+\n+import _ from 'lodash'\n+import { EventEmitter } from 'events'\n+import path from 'path'\n+import debug from 'debug'\n+import Promise from 'bluebird'\n+import appData from '../util/app_data'\n+import * as plugins from '../plugins'\n+import { telemetry } from '@packages/telemetry'\n+import type { PluginIpcHandler, PreprocessorError } from '@packages/types'\n+import type { Cfg } from '../project-base'\n+\n+const debugFn = debug('cypress:server:preprocessor')\n+\n+// Interface for file objects that extend EventEmitter with additional properties\n+interface FileObject extends EventEmitter {\n+  filePath: string\n+  shouldWatch: boolean\n+  outputPath: string\n+}\n+\n+const errorMessage = function (err: PreprocessorError = {} as PreprocessorError) {\n+  return err.stack || err.annotated || err.message || err.toString()\n+}\n+\n+const clientSideError = function (err: PreprocessorError) {\n+  // eslint-disable-next-line no-console\n+  console.log(err.message)\n+\n+  const errorString = errorMessage(err)\n+\n+  return `\\\n+(function () {\n+  Cypress.action(\"spec:script:error\", {\n+    type: \"BUNDLE_ERROR\",\n+    error: ${JSON.stringify(errorString)}\n+  })\n+}())\\\n+`\n+}\n+\n+const baseEmitter = new EventEmitter()\n+let fileObjects: Record<string, FileObject> = {}\n+let fileProcessors: Record<string, Promise<string>> = {}\n+let processedFiles: Record<string, boolean> = {}\n+\n+plugins.registerHandler((ipc: PluginIpcHandler) => {\n+  ipc.on('preprocessor:rerun', (filePath: string) => {\n+    debugFn('ipc preprocessor:rerun event')\n+\n+    baseEmitter.emit('file:updated', filePath)\n+  })\n+\n+  baseEmitter.on('close', (filePath: string) => {\n+    debugFn('base emitter plugin close event')\n+\n+    ipc.send('preprocessor:close', filePath)\n+  })\n+})\n+\n+// for simpler stubbing from unit tests\n+interface PreprocessorAPI {\n+  errorMessage: (err?: PreprocessorError) => string\n+  clientSideError: (err: PreprocessorError) => string\n+  emitter: EventEmitter\n+  getFile: (filePath: string, config: Cfg) => Promise<string>\n+  removeFile: (filePath: string, config: Cfg) => void\n+  close: () => void\n+}\n+\n+const API: PreprocessorAPI = {\n+  errorMessage,\n+\n+  clientSideError,\n+\n+  emitter: baseEmitter,\n+\n+  getFile (filePath: string, config: Cfg) {\n+    let fileObject: FileObject\n+\n+    debugFn(`getting file ${filePath}`)\n+    filePath = path.resolve(config.projectRoot, filePath)\n+\n+    debugFn(`getFile ${filePath}`)\n+\n+    if (!(fileObject = fileObjects[filePath])) {\n+      // we should be watching the file if we are NOT\n+      // in a text terminal aka cypress run\n+      // TODO: rename this to config.isRunMode\n+      // vs config.isInteractiveMode\n+      const shouldWatch = !config.isTextTerminal || Boolean(process.env.CYPRESS_INTERNAL_FORCE_FILEWATCH)\n+\n+      const baseFilePath = filePath.replace(config.projectRoot, '')\n+\n+      fileObject = (fileObjects[filePath] = _.extend(new EventEmitter(), {\n+        filePath,\n+        shouldWatch,\n+        outputPath: appData.getBundledFilePath(config.projectRoot, baseFilePath),\n+      }))\n+\n+      fileObject.on('rerun', () => {\n+        debugFn('file object rerun event')\n+\n+        return baseEmitter.emit('file:updated', filePath)\n+      })\n+\n+      baseEmitter.once('close', () => {\n+        debugFn('base emitter native close event')\n+\n+        return fileObject.emit('close')\n+      })\n+    }\n+\n+    // Check if we already have a processor for this file in headless mode\n+    if (config.isTextTerminal && processedFiles[filePath]) {\n+      debugFn('headless and already processed')\n+\n+      return fileProcessors[filePath]\n+    }",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "2298194757",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 32337,
        "pr_file": "packages/server/lib/plugins/preprocessor.ts",
        "discussion_id": "2293846557",
        "commented_code": "@@ -0,0 +1,174 @@\n+import '../cwd'\n+\n+import _ from 'lodash'\n+import { EventEmitter } from 'events'\n+import path from 'path'\n+import debug from 'debug'\n+import Promise from 'bluebird'\n+import appData from '../util/app_data'\n+import * as plugins from '../plugins'\n+import { telemetry } from '@packages/telemetry'\n+import type { PluginIpcHandler, PreprocessorError } from '@packages/types'\n+import type { Cfg } from '../project-base'\n+\n+const debugFn = debug('cypress:server:preprocessor')\n+\n+// Interface for file objects that extend EventEmitter with additional properties\n+interface FileObject extends EventEmitter {\n+  filePath: string\n+  shouldWatch: boolean\n+  outputPath: string\n+}\n+\n+const errorMessage = function (err: PreprocessorError = {} as PreprocessorError) {\n+  return err.stack || err.annotated || err.message || err.toString()\n+}\n+\n+const clientSideError = function (err: PreprocessorError) {\n+  // eslint-disable-next-line no-console\n+  console.log(err.message)\n+\n+  const errorString = errorMessage(err)\n+\n+  return `\\\n+(function () {\n+  Cypress.action(\"spec:script:error\", {\n+    type: \"BUNDLE_ERROR\",\n+    error: ${JSON.stringify(errorString)}\n+  })\n+}())\\\n+`\n+}\n+\n+const baseEmitter = new EventEmitter()\n+let fileObjects: Record<string, FileObject> = {}\n+let fileProcessors: Record<string, Promise<string>> = {}\n+let processedFiles: Record<string, boolean> = {}\n+\n+plugins.registerHandler((ipc: PluginIpcHandler) => {\n+  ipc.on('preprocessor:rerun', (filePath: string) => {\n+    debugFn('ipc preprocessor:rerun event')\n+\n+    baseEmitter.emit('file:updated', filePath)\n+  })\n+\n+  baseEmitter.on('close', (filePath: string) => {\n+    debugFn('base emitter plugin close event')\n+\n+    ipc.send('preprocessor:close', filePath)\n+  })\n+})\n+\n+// for simpler stubbing from unit tests\n+interface PreprocessorAPI {\n+  errorMessage: (err?: PreprocessorError) => string\n+  clientSideError: (err: PreprocessorError) => string\n+  emitter: EventEmitter\n+  getFile: (filePath: string, config: Cfg) => Promise<string>\n+  removeFile: (filePath: string, config: Cfg) => void\n+  close: () => void\n+}\n+\n+const API: PreprocessorAPI = {\n+  errorMessage,\n+\n+  clientSideError,\n+\n+  emitter: baseEmitter,\n+\n+  getFile (filePath: string, config: Cfg) {\n+    let fileObject: FileObject\n+\n+    debugFn(`getting file ${filePath}`)\n+    filePath = path.resolve(config.projectRoot, filePath)\n+\n+    debugFn(`getFile ${filePath}`)\n+\n+    if (!(fileObject = fileObjects[filePath])) {\n+      // we should be watching the file if we are NOT\n+      // in a text terminal aka cypress run\n+      // TODO: rename this to config.isRunMode\n+      // vs config.isInteractiveMode\n+      const shouldWatch = !config.isTextTerminal || Boolean(process.env.CYPRESS_INTERNAL_FORCE_FILEWATCH)\n+\n+      const baseFilePath = filePath.replace(config.projectRoot, '')\n+\n+      fileObject = (fileObjects[filePath] = _.extend(new EventEmitter(), {\n+        filePath,\n+        shouldWatch,\n+        outputPath: appData.getBundledFilePath(config.projectRoot, baseFilePath),\n+      }))\n+\n+      fileObject.on('rerun', () => {\n+        debugFn('file object rerun event')\n+\n+        return baseEmitter.emit('file:updated', filePath)\n+      })\n+\n+      baseEmitter.once('close', () => {\n+        debugFn('base emitter native close event')\n+\n+        return fileObject.emit('close')\n+      })\n+    }\n+\n+    // Check if we already have a processor for this file in headless mode\n+    if (config.isTextTerminal && processedFiles[filePath]) {\n+      debugFn('headless and already processed')\n+\n+      return fileProcessors[filePath]\n+    }",
        "comment_created_at": "2025-08-25T14:00:20+00:00",
        "comment_author": "jennifer-shehane",
        "comment_body": "Previous logic: https://github.com/cypress-io/cypress/pull/32337/files#diff-989c205583a571a949ac4e6f11535a211dbff55797c44ef10b124f3220766562L94\r\n\r\n<img width=\"600\" height=\"170\" alt=\"Screenshot 2025-08-25 at 9 59 59\u202fAM\" src=\"https://github.com/user-attachments/assets/82b68a30-d3cf-49ee-8d25-43166f169944\" />\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2298427989",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 32337,
        "pr_file": "packages/server/lib/plugins/preprocessor.ts",
        "discussion_id": "2293846557",
        "commented_code": "@@ -0,0 +1,174 @@\n+import '../cwd'\n+\n+import _ from 'lodash'\n+import { EventEmitter } from 'events'\n+import path from 'path'\n+import debug from 'debug'\n+import Promise from 'bluebird'\n+import appData from '../util/app_data'\n+import * as plugins from '../plugins'\n+import { telemetry } from '@packages/telemetry'\n+import type { PluginIpcHandler, PreprocessorError } from '@packages/types'\n+import type { Cfg } from '../project-base'\n+\n+const debugFn = debug('cypress:server:preprocessor')\n+\n+// Interface for file objects that extend EventEmitter with additional properties\n+interface FileObject extends EventEmitter {\n+  filePath: string\n+  shouldWatch: boolean\n+  outputPath: string\n+}\n+\n+const errorMessage = function (err: PreprocessorError = {} as PreprocessorError) {\n+  return err.stack || err.annotated || err.message || err.toString()\n+}\n+\n+const clientSideError = function (err: PreprocessorError) {\n+  // eslint-disable-next-line no-console\n+  console.log(err.message)\n+\n+  const errorString = errorMessage(err)\n+\n+  return `\\\n+(function () {\n+  Cypress.action(\"spec:script:error\", {\n+    type: \"BUNDLE_ERROR\",\n+    error: ${JSON.stringify(errorString)}\n+  })\n+}())\\\n+`\n+}\n+\n+const baseEmitter = new EventEmitter()\n+let fileObjects: Record<string, FileObject> = {}\n+let fileProcessors: Record<string, Promise<string>> = {}\n+let processedFiles: Record<string, boolean> = {}\n+\n+plugins.registerHandler((ipc: PluginIpcHandler) => {\n+  ipc.on('preprocessor:rerun', (filePath: string) => {\n+    debugFn('ipc preprocessor:rerun event')\n+\n+    baseEmitter.emit('file:updated', filePath)\n+  })\n+\n+  baseEmitter.on('close', (filePath: string) => {\n+    debugFn('base emitter plugin close event')\n+\n+    ipc.send('preprocessor:close', filePath)\n+  })\n+})\n+\n+// for simpler stubbing from unit tests\n+interface PreprocessorAPI {\n+  errorMessage: (err?: PreprocessorError) => string\n+  clientSideError: (err: PreprocessorError) => string\n+  emitter: EventEmitter\n+  getFile: (filePath: string, config: Cfg) => Promise<string>\n+  removeFile: (filePath: string, config: Cfg) => void\n+  close: () => void\n+}\n+\n+const API: PreprocessorAPI = {\n+  errorMessage,\n+\n+  clientSideError,\n+\n+  emitter: baseEmitter,\n+\n+  getFile (filePath: string, config: Cfg) {\n+    let fileObject: FileObject\n+\n+    debugFn(`getting file ${filePath}`)\n+    filePath = path.resolve(config.projectRoot, filePath)\n+\n+    debugFn(`getFile ${filePath}`)\n+\n+    if (!(fileObject = fileObjects[filePath])) {\n+      // we should be watching the file if we are NOT\n+      // in a text terminal aka cypress run\n+      // TODO: rename this to config.isRunMode\n+      // vs config.isInteractiveMode\n+      const shouldWatch = !config.isTextTerminal || Boolean(process.env.CYPRESS_INTERNAL_FORCE_FILEWATCH)\n+\n+      const baseFilePath = filePath.replace(config.projectRoot, '')\n+\n+      fileObject = (fileObjects[filePath] = _.extend(new EventEmitter(), {\n+        filePath,\n+        shouldWatch,\n+        outputPath: appData.getBundledFilePath(config.projectRoot, baseFilePath),\n+      }))\n+\n+      fileObject.on('rerun', () => {\n+        debugFn('file object rerun event')\n+\n+        return baseEmitter.emit('file:updated', filePath)\n+      })\n+\n+      baseEmitter.once('close', () => {\n+        debugFn('base emitter native close event')\n+\n+        return fileObject.emit('close')\n+      })\n+    }\n+\n+    // Check if we already have a processor for this file in headless mode\n+    if (config.isTextTerminal && processedFiles[filePath]) {\n+      debugFn('headless and already processed')\n+\n+      return fileProcessors[filePath]\n+    }",
        "comment_created_at": "2025-08-25T15:27:33+00:00",
        "comment_author": "jennifer-shehane",
        "comment_body": "Following up on this. Since `fileProcessors` is typed as `Record<string, Promise<string>>`, the values are always `Promise<string>` objects, which are always truthy.\r\n\r\nChanged this to: `filePath in fileProcessors`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2298443958",
    "pr_number": 32337,
    "pr_file": "packages/server/lib/plugins/preprocessor.ts",
    "created_at": "2025-08-25T15:35:03+00:00",
    "commented_code": "+import '../cwd'\n+\n+import _ from 'lodash'\n+import { EventEmitter } from 'events'\n+import path from 'path'\n+import debug from 'debug'\n+import Promise from 'bluebird'\n+import appData from '../util/app_data'\n+import * as plugins from '../plugins'\n+import { telemetry } from '@packages/telemetry'\n+import type { PluginIpcHandler, PreprocessorError } from '@packages/types'\n+import type { Cfg } from '../project-base'\n+\n+const debugFn = debug('cypress:server:preprocessor')\n+\n+// Interface for file objects that extend EventEmitter with additional properties\n+interface FileObject extends EventEmitter {\n+  filePath: string\n+  shouldWatch: boolean\n+  outputPath: string\n+  on(event: 'rerun', listener: () => void): this\n+  on(event: 'close', listener: () => void): this\n+  emit(event: 'rerun'): boolean\n+  emit(event: 'close'): boolean\n+}\n+\n+const errorMessage = function (err: PreprocessorError = {} as PreprocessorError): string {\n+  return err.stack || err.annotated || err.message || err.toString()\n+}\n+\n+const clientSideError = function (err: PreprocessorError): string {\n+  // eslint-disable-next-line no-console\n+  console.log(err.message)\n+\n+  const errorString = errorMessage(err)\n+\n+  return `\\\n+(function () {\n+  Cypress.action(\"spec:script:error\", {\n+    type: \"BUNDLE_ERROR\",\n+    error: ${JSON.stringify(errorString)}\n+  })\n+}())\\\n+`\n+}\n+\n+const baseEmitter = new EventEmitter()\n+let fileObjects: Record<string, FileObject> = {}\n+let fileProcessors: Record<string, Promise<string>> = {}\n+let processedFiles: Record<string, boolean> = {}\n+\n+plugins.registerHandler((ipc: PluginIpcHandler) => {\n+  ipc.on('preprocessor:rerun', (filePath: string) => {\n+    debugFn('ipc preprocessor:rerun event')\n+\n+    baseEmitter.emit('file:updated', filePath)\n+  })\n+\n+  baseEmitter.on('close', (filePath: string) => {\n+    debugFn('base emitter plugin close event')\n+    ipc.send('preprocessor:close', filePath)\n+  })\n+})\n+\n+// for simpler stubbing from unit tests\n+interface PreprocessorAPI {\n+  errorMessage: (err?: PreprocessorError) => string\n+  clientSideError: (err: PreprocessorError) => string\n+  emitter: EventEmitter\n+  getFile: (filePath: string, config: Cfg) => Promise<string>\n+  removeFile: (filePath: string, config: Cfg) => void\n+  close: () => void\n+}\n+\n+const API: PreprocessorAPI = {\n+  errorMessage,\n+\n+  clientSideError,\n+\n+  emitter: baseEmitter,\n+\n+  getFile (filePath: string, config: Cfg) {\n+    let fileObject: FileObject\n+\n+    debugFn(`getting file ${filePath}`)\n+    filePath = path.resolve(config.projectRoot, filePath)\n+\n+    debugFn(`getFile ${filePath}`)\n+\n+    if (!(fileObject = fileObjects[filePath])) {\n+      // we should be watching the file if we are NOT\n+      // in a text terminal aka cypress run\n+      // TODO: rename this to config.isRunMode\n+      // vs config.isInteractiveMode\n+      const shouldWatch = !config.isTextTerminal || Boolean(process.env.CYPRESS_INTERNAL_FORCE_FILEWATCH)\n+\n+      const baseFilePath = filePath.replace(config.projectRoot, '')\n+\n+      fileObject = (fileObjects[filePath] = _.extend(new EventEmitter(), {\n+        filePath,\n+        shouldWatch,\n+        outputPath: appData.getBundledFilePath(config.projectRoot, baseFilePath),\n+      }))\n+\n+      fileObject.on('rerun', () => {\n+        debugFn('file object rerun event')\n+\n+        return baseEmitter.emit('file:updated', filePath)\n+      })\n+\n+      baseEmitter.once('close', () => {\n+        debugFn('base emitter native close event')\n+\n+        return fileObject.emit('close')\n+      })\n+    }\n+\n+    // Check if we already have a processor for this file in headless mode\n+    if (config.isTextTerminal && filePath in fileProcessors) {\n+      debugFn('headless and already processed')\n+\n+      return fileProcessors[filePath]\n+    }\n+\n+    const preprocessor = (fileProcessors[filePath] = Promise.try(() => {\n+      const span = telemetry.startSpan({ name: 'file:preprocessor' })\n+\n+      return plugins.execute('file:preprocessor', fileObject).then((arg: string) => {\n+        span?.setAttribute('file', arg)\n+        span?.end()\n+        processedFiles[filePath] = true\n+\n+        return arg\n+      })\n+    }))\n+\n+    return preprocessor\n+  },\n+\n+  removeFile (filePath: string, config: Cfg) {\n+    let fileObject: FileObject\n+\n+    filePath = path.resolve(config.projectRoot, filePath)\n+\n+    if (!(filePath in fileProcessors)) {\n+      return\n+    }",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "2298443958",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 32337,
        "pr_file": "packages/server/lib/plugins/preprocessor.ts",
        "discussion_id": "2298443958",
        "commented_code": "@@ -0,0 +1,179 @@\n+import '../cwd'\n+\n+import _ from 'lodash'\n+import { EventEmitter } from 'events'\n+import path from 'path'\n+import debug from 'debug'\n+import Promise from 'bluebird'\n+import appData from '../util/app_data'\n+import * as plugins from '../plugins'\n+import { telemetry } from '@packages/telemetry'\n+import type { PluginIpcHandler, PreprocessorError } from '@packages/types'\n+import type { Cfg } from '../project-base'\n+\n+const debugFn = debug('cypress:server:preprocessor')\n+\n+// Interface for file objects that extend EventEmitter with additional properties\n+interface FileObject extends EventEmitter {\n+  filePath: string\n+  shouldWatch: boolean\n+  outputPath: string\n+  on(event: 'rerun', listener: () => void): this\n+  on(event: 'close', listener: () => void): this\n+  emit(event: 'rerun'): boolean\n+  emit(event: 'close'): boolean\n+}\n+\n+const errorMessage = function (err: PreprocessorError = {} as PreprocessorError): string {\n+  return err.stack || err.annotated || err.message || err.toString()\n+}\n+\n+const clientSideError = function (err: PreprocessorError): string {\n+  // eslint-disable-next-line no-console\n+  console.log(err.message)\n+\n+  const errorString = errorMessage(err)\n+\n+  return `\\\n+(function () {\n+  Cypress.action(\"spec:script:error\", {\n+    type: \"BUNDLE_ERROR\",\n+    error: ${JSON.stringify(errorString)}\n+  })\n+}())\\\n+`\n+}\n+\n+const baseEmitter = new EventEmitter()\n+let fileObjects: Record<string, FileObject> = {}\n+let fileProcessors: Record<string, Promise<string>> = {}\n+let processedFiles: Record<string, boolean> = {}\n+\n+plugins.registerHandler((ipc: PluginIpcHandler) => {\n+  ipc.on('preprocessor:rerun', (filePath: string) => {\n+    debugFn('ipc preprocessor:rerun event')\n+\n+    baseEmitter.emit('file:updated', filePath)\n+  })\n+\n+  baseEmitter.on('close', (filePath: string) => {\n+    debugFn('base emitter plugin close event')\n+    ipc.send('preprocessor:close', filePath)\n+  })\n+})\n+\n+// for simpler stubbing from unit tests\n+interface PreprocessorAPI {\n+  errorMessage: (err?: PreprocessorError) => string\n+  clientSideError: (err: PreprocessorError) => string\n+  emitter: EventEmitter\n+  getFile: (filePath: string, config: Cfg) => Promise<string>\n+  removeFile: (filePath: string, config: Cfg) => void\n+  close: () => void\n+}\n+\n+const API: PreprocessorAPI = {\n+  errorMessage,\n+\n+  clientSideError,\n+\n+  emitter: baseEmitter,\n+\n+  getFile (filePath: string, config: Cfg) {\n+    let fileObject: FileObject\n+\n+    debugFn(`getting file ${filePath}`)\n+    filePath = path.resolve(config.projectRoot, filePath)\n+\n+    debugFn(`getFile ${filePath}`)\n+\n+    if (!(fileObject = fileObjects[filePath])) {\n+      // we should be watching the file if we are NOT\n+      // in a text terminal aka cypress run\n+      // TODO: rename this to config.isRunMode\n+      // vs config.isInteractiveMode\n+      const shouldWatch = !config.isTextTerminal || Boolean(process.env.CYPRESS_INTERNAL_FORCE_FILEWATCH)\n+\n+      const baseFilePath = filePath.replace(config.projectRoot, '')\n+\n+      fileObject = (fileObjects[filePath] = _.extend(new EventEmitter(), {\n+        filePath,\n+        shouldWatch,\n+        outputPath: appData.getBundledFilePath(config.projectRoot, baseFilePath),\n+      }))\n+\n+      fileObject.on('rerun', () => {\n+        debugFn('file object rerun event')\n+\n+        return baseEmitter.emit('file:updated', filePath)\n+      })\n+\n+      baseEmitter.once('close', () => {\n+        debugFn('base emitter native close event')\n+\n+        return fileObject.emit('close')\n+      })\n+    }\n+\n+    // Check if we already have a processor for this file in headless mode\n+    if (config.isTextTerminal && filePath in fileProcessors) {\n+      debugFn('headless and already processed')\n+\n+      return fileProcessors[filePath]\n+    }\n+\n+    const preprocessor = (fileProcessors[filePath] = Promise.try(() => {\n+      const span = telemetry.startSpan({ name: 'file:preprocessor' })\n+\n+      return plugins.execute('file:preprocessor', fileObject).then((arg: string) => {\n+        span?.setAttribute('file', arg)\n+        span?.end()\n+        processedFiles[filePath] = true\n+\n+        return arg\n+      })\n+    }))\n+\n+    return preprocessor\n+  },\n+\n+  removeFile (filePath: string, config: Cfg) {\n+    let fileObject: FileObject\n+\n+    filePath = path.resolve(config.projectRoot, filePath)\n+\n+    if (!(filePath in fileProcessors)) {\n+      return\n+    }",
        "comment_created_at": "2025-08-25T15:35:03+00:00",
        "comment_author": "jennifer-shehane",
        "comment_body": "Code used to be:\r\n\r\n```js\r\n    if (!fileProcessors[filePath]) {\r\n      return\r\n    }\r\n```\r\n\r\nSince `fileProcessors` is typed as `Record<string, Promise<string>>`, the values are always `Promise<string> objects`, which are always truthy.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2294593522",
    "pr_number": 32063,
    "pr_file": "cli/lib/util.ts",
    "created_at": "2025-08-22T19:54:42+00:00",
    "commented_code": "// so for sanity sake we should first trim whitespace characters and remove\n     // double quotes around environment strings if the caller is expected to\n     // use this environment string as a file path\n-    return trim ? dequote(_.trim(result)) : result\n+    return trim && result ? dequote(_.trim(result)) : result",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "2294593522",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 32063,
        "pr_file": "cli/lib/util.ts",
        "discussion_id": "2294593522",
        "commented_code": "@@ -531,14 +535,14 @@ const util = {\n     // so for sanity sake we should first trim whitespace characters and remove\n     // double quotes around environment strings if the caller is expected to\n     // use this environment string as a file path\n-    return trim ? dequote(_.trim(result)) : result\n+    return trim && result ? dequote(_.trim(result)) : result",
        "comment_created_at": "2025-08-22T19:54:42+00:00",
        "comment_author": "jennifer-shehane",
        "comment_body": "@AtofStryker This check prevents processing of valid string values (like \"0\") that are falsy but should still be trimmed/dequoted. Would be better to do something like `result != null`",
        "pr_file_module": null
      },
      {
        "comment_id": "2294601529",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 32063,
        "pr_file": "cli/lib/util.ts",
        "discussion_id": "2294593522",
        "commented_code": "@@ -531,14 +535,14 @@ const util = {\n     // so for sanity sake we should first trim whitespace characters and remove\n     // double quotes around environment strings if the caller is expected to\n     // use this environment string as a file path\n-    return trim ? dequote(_.trim(result)) : result\n+    return trim && result ? dequote(_.trim(result)) : result",
        "comment_created_at": "2025-08-22T19:58:35+00:00",
        "comment_author": "AtofStryker",
        "comment_body": "good to know. So make sure its not `null` or `undefined` otherwise proceed?",
        "pr_file_module": null
      },
      {
        "comment_id": "2294603936",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 32063,
        "pr_file": "cli/lib/util.ts",
        "discussion_id": "2294593522",
        "commented_code": "@@ -531,14 +535,14 @@ const util = {\n     // so for sanity sake we should first trim whitespace characters and remove\n     // double quotes around environment strings if the caller is expected to\n     // use this environment string as a file path\n-    return trim ? dequote(_.trim(result)) : result\n+    return trim && result ? dequote(_.trim(result)) : result",
        "comment_created_at": "2025-08-22T19:59:40+00:00",
        "comment_author": "AtofStryker",
        "comment_body": "added in 67713881e0",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "596485666",
    "pr_number": 15546,
    "pr_file": "npm/design-system/src/library/hooks/useFuzzySearch.ts",
    "created_at": "2021-03-18T01:13:36+00:00",
    "commented_code": "+import Fuse from 'fuse.js'\n+import { useEffect, useLayoutEffect, useMemo, useState } from 'react'\n+\n+/**\n+ * Supports all Fuse options, with modified key definitions\n+ */\n+export interface FuzzySearchConfig<T> extends Omit<Fuse.IFuseOptions<T>, 'keys'> {\n+  keys?: {\n+    [Key in keyof T]?: true | {\n+      weight: number\n+    }\n+  }\n+}\n+\n+/**\n+ * Provides fuzzy matching search over the supplied items, using weighted keys\n+ * @param items The items to search\n+ * @param searchInput A search string, provided if the hook is driven by external state\n+ * @param config The configuration of how to perform searches, based on Fuse config options\n+ *\n+ * @see https://fusejs.io/api/options.html\n+ */\n+export const useFuzzySearch = <T>(items: T[], searchInput?: string, config?: FuzzySearchConfig<T>): {\n+  searchInput: string\n+  results: Fuse.FuseResult<T>[] | undefined\n+  orderedResults: T[]\n+  onSearch: (searchInput: string) => void\n+} => {\n+  const finalConfig = useMemo((): Fuse.IFuseOptions<T> | undefined => {\n+    if (config?.keys === undefined) {\n+      return config as Fuse.IFuseOptions<T>\n+    }\n+\n+    return {\n+      ...config,\n+      keys: Object.keys(config.keys).map((key) => {\n+        const keyEntry = config.keys?.[key as keyof T] as true | {\n+          weight: number\n+        } | undefined\n+\n+        if (keyEntry === undefined) {",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "596485666",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 15546,
        "pr_file": "npm/design-system/src/library/hooks/useFuzzySearch.ts",
        "discussion_id": "596485666",
        "commented_code": "@@ -0,0 +1,74 @@\n+import Fuse from 'fuse.js'\n+import { useEffect, useLayoutEffect, useMemo, useState } from 'react'\n+\n+/**\n+ * Supports all Fuse options, with modified key definitions\n+ */\n+export interface FuzzySearchConfig<T> extends Omit<Fuse.IFuseOptions<T>, 'keys'> {\n+  keys?: {\n+    [Key in keyof T]?: true | {\n+      weight: number\n+    }\n+  }\n+}\n+\n+/**\n+ * Provides fuzzy matching search over the supplied items, using weighted keys\n+ * @param items The items to search\n+ * @param searchInput A search string, provided if the hook is driven by external state\n+ * @param config The configuration of how to perform searches, based on Fuse config options\n+ *\n+ * @see https://fusejs.io/api/options.html\n+ */\n+export const useFuzzySearch = <T>(items: T[], searchInput?: string, config?: FuzzySearchConfig<T>): {\n+  searchInput: string\n+  results: Fuse.FuseResult<T>[] | undefined\n+  orderedResults: T[]\n+  onSearch: (searchInput: string) => void\n+} => {\n+  const finalConfig = useMemo((): Fuse.IFuseOptions<T> | undefined => {\n+    if (config?.keys === undefined) {\n+      return config as Fuse.IFuseOptions<T>\n+    }\n+\n+    return {\n+      ...config,\n+      keys: Object.keys(config.keys).map((key) => {\n+        const keyEntry = config.keys?.[key as keyof T] as true | {\n+          weight: number\n+        } | undefined\n+\n+        if (keyEntry === undefined) {",
        "comment_created_at": "2021-03-18T01:13:36+00:00",
        "comment_author": "lmiller1990",
        "comment_body": "Any reason to prefer `=== undefined` over `(!keyEntry)`?",
        "pr_file_module": null
      },
      {
        "comment_id": "596848640",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 15546,
        "pr_file": "npm/design-system/src/library/hooks/useFuzzySearch.ts",
        "discussion_id": "596485666",
        "commented_code": "@@ -0,0 +1,74 @@\n+import Fuse from 'fuse.js'\n+import { useEffect, useLayoutEffect, useMemo, useState } from 'react'\n+\n+/**\n+ * Supports all Fuse options, with modified key definitions\n+ */\n+export interface FuzzySearchConfig<T> extends Omit<Fuse.IFuseOptions<T>, 'keys'> {\n+  keys?: {\n+    [Key in keyof T]?: true | {\n+      weight: number\n+    }\n+  }\n+}\n+\n+/**\n+ * Provides fuzzy matching search over the supplied items, using weighted keys\n+ * @param items The items to search\n+ * @param searchInput A search string, provided if the hook is driven by external state\n+ * @param config The configuration of how to perform searches, based on Fuse config options\n+ *\n+ * @see https://fusejs.io/api/options.html\n+ */\n+export const useFuzzySearch = <T>(items: T[], searchInput?: string, config?: FuzzySearchConfig<T>): {\n+  searchInput: string\n+  results: Fuse.FuseResult<T>[] | undefined\n+  orderedResults: T[]\n+  onSearch: (searchInput: string) => void\n+} => {\n+  const finalConfig = useMemo((): Fuse.IFuseOptions<T> | undefined => {\n+    if (config?.keys === undefined) {\n+      return config as Fuse.IFuseOptions<T>\n+    }\n+\n+    return {\n+      ...config,\n+      keys: Object.keys(config.keys).map((key) => {\n+        const keyEntry = config.keys?.[key as keyof T] as true | {\n+          weight: number\n+        } | undefined\n+\n+        if (keyEntry === undefined) {",
        "comment_created_at": "2021-03-18T13:05:27+00:00",
        "comment_author": "agg23",
        "comment_body": "In this scenario, yes, because `keyEntry` can be a boolean. Even though that boolean is true, that is a little too edgy for me, so I would rather explicitly check for the value I want here.",
        "pr_file_module": null
      }
    ]
  }
]