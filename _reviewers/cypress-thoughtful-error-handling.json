[
  {
    "discussion_id": "1148006706",
    "pr_number": 26202,
    "pr_file": "npm/vite-dev-server/client/initCypressTests.js",
    "created_at": "2023-03-24T20:02:51+00:00",
    "commented_code": "// This file is merged in a <script type=module> into index.html\n // it will be used to load and kick start the selected spec\n \n+// Fetch a dynamic import and re-try 3 times with a 2-second back-off.\n+// We want to re-try these if they fail because sometimes (seemingly due to network issues)\n+// the modules aren't available when we first request them.\n+// See https://github.com/cypress-io/cypress/issues/25913\n+async function importWithRetry (importFn) {\n+  try {\n+    return await importFn()\n+  } catch (error) {\n+    for (let i = 0; i < 3; i++) {\n+      await new Promise((resolve) => setTimeout(resolve, 1000 * 2 ** i))\n+\n+      let url\n+\n+      try {\n+        // Get request URL from error message from original import\n+        url = new URL(\n+          error.message\n+          .replace('Failed to fetch dynamically imported module: ', '')\n+          .trim(),\n+        )\n+\n+        console.error(`retrying import of ${url?.href}`)\n+\n+        // add a timestamp to the end of the URL to force re-load the module instead of using the cache\n+        url.searchParams.set('t', `${+new Date()}`)\n+\n+        return await import(url.href)\n+      } catch (e) {\n+        console.error(`retrying import of ${url?.href}`)",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "1148006706",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 26202,
        "pr_file": "npm/vite-dev-server/client/initCypressTests.js",
        "discussion_id": "1148006706",
        "commented_code": "@@ -1,6 +1,42 @@\n // This file is merged in a <script type=module> into index.html\n // it will be used to load and kick start the selected spec\n \n+// Fetch a dynamic import and re-try 3 times with a 2-second back-off.\n+// We want to re-try these if they fail because sometimes (seemingly due to network issues)\n+// the modules aren't available when we first request them.\n+// See https://github.com/cypress-io/cypress/issues/25913\n+async function importWithRetry (importFn) {\n+  try {\n+    return await importFn()\n+  } catch (error) {\n+    for (let i = 0; i < 3; i++) {\n+      await new Promise((resolve) => setTimeout(resolve, 1000 * 2 ** i))\n+\n+      let url\n+\n+      try {\n+        // Get request URL from error message from original import\n+        url = new URL(\n+          error.message\n+          .replace('Failed to fetch dynamically imported module: ', '')\n+          .trim(),\n+        )\n+\n+        console.error(`retrying import of ${url?.href}`)\n+\n+        // add a timestamp to the end of the URL to force re-load the module instead of using the cache\n+        url.searchParams.set('t', `${+new Date()}`)\n+\n+        return await import(url.href)\n+      } catch (e) {\n+        console.error(`retrying import of ${url?.href}`)",
        "comment_created_at": "2023-03-24T20:02:51+00:00",
        "comment_author": "mike-plummer",
        "comment_body": "Nitpick - will print a message that we're going to retry on the last attempt",
        "pr_file_module": null
      },
      {
        "comment_id": "1148008536",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 26202,
        "pr_file": "npm/vite-dev-server/client/initCypressTests.js",
        "discussion_id": "1148006706",
        "commented_code": "@@ -1,6 +1,42 @@\n // This file is merged in a <script type=module> into index.html\n // it will be used to load and kick start the selected spec\n \n+// Fetch a dynamic import and re-try 3 times with a 2-second back-off.\n+// We want to re-try these if they fail because sometimes (seemingly due to network issues)\n+// the modules aren't available when we first request them.\n+// See https://github.com/cypress-io/cypress/issues/25913\n+async function importWithRetry (importFn) {\n+  try {\n+    return await importFn()\n+  } catch (error) {\n+    for (let i = 0; i < 3; i++) {\n+      await new Promise((resolve) => setTimeout(resolve, 1000 * 2 ** i))\n+\n+      let url\n+\n+      try {\n+        // Get request URL from error message from original import\n+        url = new URL(\n+          error.message\n+          .replace('Failed to fetch dynamically imported module: ', '')\n+          .trim(),\n+        )\n+\n+        console.error(`retrying import of ${url?.href}`)\n+\n+        // add a timestamp to the end of the URL to force re-load the module instead of using the cache\n+        url.searchParams.set('t', `${+new Date()}`)\n+\n+        return await import(url.href)\n+      } catch (e) {\n+        console.error(`retrying import of ${url?.href}`)",
        "comment_created_at": "2023-03-24T20:05:36+00:00",
        "comment_author": "mike-plummer",
        "comment_body": "Also, maybe more of a warning than an error if we're potentially going to recover from it with a retry. A total failure constitutes an error, at least in my mind",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1148012566",
    "pr_number": 26202,
    "pr_file": "npm/vite-dev-server/client/initCypressTests.js",
    "created_at": "2023-03-24T20:11:42+00:00",
    "commented_code": "// This file is merged in a <script type=module> into index.html\n // it will be used to load and kick start the selected spec\n \n+// Fetch a dynamic import and re-try 3 times with a 2-second back-off.\n+// We want to re-try these if they fail because sometimes (seemingly due to network issues)\n+// the modules aren't available when we first request them.\n+// See https://github.com/cypress-io/cypress/issues/25913\n+async function importWithRetry (importFn) {\n+  try {\n+    return await importFn()\n+  } catch (error) {\n+    for (let i = 0; i < 3; i++) {\n+      await new Promise((resolve) => setTimeout(resolve, 1000 * 2 ** i))\n+\n+      let url\n+\n+      try {\n+        // Get request URL from error message from original import\n+        url = new URL(\n+          error.message\n+          .replace('Failed to fetch dynamically imported module: ', '')\n+          .trim(),\n+        )",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "1148012566",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 26202,
        "pr_file": "npm/vite-dev-server/client/initCypressTests.js",
        "discussion_id": "1148012566",
        "commented_code": "@@ -1,6 +1,42 @@\n // This file is merged in a <script type=module> into index.html\n // it will be used to load and kick start the selected spec\n \n+// Fetch a dynamic import and re-try 3 times with a 2-second back-off.\n+// We want to re-try these if they fail because sometimes (seemingly due to network issues)\n+// the modules aren't available when we first request them.\n+// See https://github.com/cypress-io/cypress/issues/25913\n+async function importWithRetry (importFn) {\n+  try {\n+    return await importFn()\n+  } catch (error) {\n+    for (let i = 0; i < 3; i++) {\n+      await new Promise((resolve) => setTimeout(resolve, 1000 * 2 ** i))\n+\n+      let url\n+\n+      try {\n+        // Get request URL from error message from original import\n+        url = new URL(\n+          error.message\n+          .replace('Failed to fetch dynamically imported module: ', '')\n+          .trim(),\n+        )",
        "comment_created_at": "2023-03-24T20:11:42+00:00",
        "comment_author": "mike-plummer",
        "comment_body": "Just out of curiosity, what sort of details do we get from this error message? Can we tell the difference between a module not being ready and the dev server being totally hosed (misconfigured, etc) so we don't unnecessarily hang the test on retries if it can't possibly succeed?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "729072966",
    "pr_number": 18445,
    "pr_file": "packages/server/lib/scaffold.js",
    "created_at": "2021-10-14T14:59:13+00:00",
    "commented_code": "return this._assertInFileTree(dest, config)\n     .then(() => {\n       return fs.copyAsync(src, dest)\n+    }).catch((error) => {\n+      if (error.code === 'EACCES') {\n+        const err = errors.get('ERROR_WRITING_FILE', dest, error)\n+\n+        errors.log(err)",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "729072966",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 18445,
        "pr_file": "packages/server/lib/scaffold.js",
        "discussion_id": "729072966",
        "commented_code": "@@ -254,6 +254,14 @@ module.exports = {\n     return this._assertInFileTree(dest, config)\n     .then(() => {\n       return fs.copyAsync(src, dest)\n+    }).catch((error) => {\n+      if (error.code === 'EACCES') {\n+        const err = errors.get('ERROR_WRITING_FILE', dest, error)\n+\n+        errors.log(err)",
        "comment_created_at": "2021-10-14T14:59:13+00:00",
        "comment_author": "flotwig",
        "comment_body": "No need to log and then throw, I think, since the `ERROR_WRITING_FILE` error wraps `error`.\r\n\r\n```suggestion\r\n        error = errors.get('ERROR_WRITING_FILE', dest, error)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "729169650",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 18445,
        "pr_file": "packages/server/lib/scaffold.js",
        "discussion_id": "729072966",
        "commented_code": "@@ -254,6 +254,14 @@ module.exports = {\n     return this._assertInFileTree(dest, config)\n     .then(() => {\n       return fs.copyAsync(src, dest)\n+    }).catch((error) => {\n+      if (error.code === 'EACCES') {\n+        const err = errors.get('ERROR_WRITING_FILE', dest, error)\n+\n+        errors.log(err)",
        "comment_created_at": "2021-10-14T16:51:48+00:00",
        "comment_author": "BlueWinds",
        "comment_body": "That is cleaner, reduces the duplicate logging of the error.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "396776549",
    "pr_number": 6799,
    "pr_file": "packages/driver/src/cypress/cy.js",
    "created_at": "2020-03-23T21:47:20+00:00",
    "commented_code": "curCy = cy\n \n-  const onTopError = function () {\n-    return curCy.onUncaughtException.apply(curCy, arguments)\n-  }\n+  // prevent overriding top.onerror twice when loading more than one\n+  // instance of test runner.\n+  if (!top.__cypress__onerror) {\n+    top.__cypress__onerror = true\n+    const onTopError = function () {\n+      return curCy.onUncaughtException.apply(curCy, arguments)\n+    }\n \n-  top.onerror = onTopError\n+    top.onerror = onTopError\n \n-  // Prevent Mocha from setting top.onerror which would override our handler\n-  // Since the setter will change which event handler gets invoked, we make it a noop\n-  return Object.defineProperty(top, 'onerror', {\n-    set () {},\n-    get () {\n-      return onTopError\n-    },\n-    configurable: false,\n-    enumerable: true,\n-  })\n+    // Prevent Mocha from setting top.onerror which would override our handler\n+    // Since the setter will change which event handler gets invoked, we make it a noop\n+    return Object.defineProperty(top, 'onerror', {\n+      set () {},\n+      get () {\n+        return onTopError\n+      },\n+      configurable: false,\n+      enumerable: true,\n+    })\n+  }",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "396776549",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 6799,
        "pr_file": "packages/driver/src/cypress/cy.js",
        "discussion_id": "396776549",
        "commented_code": "@@ -72,25 +72,31 @@ const setTopOnError = function (cy) {\n \n   curCy = cy\n \n-  const onTopError = function () {\n-    return curCy.onUncaughtException.apply(curCy, arguments)\n-  }\n+  // prevent overriding top.onerror twice when loading more than one\n+  // instance of test runner.\n+  if (!top.__cypress__onerror) {\n+    top.__cypress__onerror = true\n+    const onTopError = function () {\n+      return curCy.onUncaughtException.apply(curCy, arguments)\n+    }\n \n-  top.onerror = onTopError\n+    top.onerror = onTopError\n \n-  // Prevent Mocha from setting top.onerror which would override our handler\n-  // Since the setter will change which event handler gets invoked, we make it a noop\n-  return Object.defineProperty(top, 'onerror', {\n-    set () {},\n-    get () {\n-      return onTopError\n-    },\n-    configurable: false,\n-    enumerable: true,\n-  })\n+    // Prevent Mocha from setting top.onerror which would override our handler\n+    // Since the setter will change which event handler gets invoked, we make it a noop\n+    return Object.defineProperty(top, 'onerror', {\n+      set () {},\n+      get () {\n+        return onTopError\n+      },\n+      configurable: false,\n+      enumerable: true,\n+    })\n+  }",
        "comment_created_at": "2020-03-23T21:47:20+00:00",
        "comment_author": "brian-mann",
        "comment_body": "- prevent additional top global property assignment, and assign a property to the onerror handler such as isCypressHandler\r\n- cleanup the logic to make the return early logic simpler: if (top.onerror && top.onerror.isCypressHandler) { return }",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "419658407",
    "pr_number": 7192,
    "pr_file": "packages/server/test/unit/modes/run_spec.js",
    "created_at": "2020-05-04T19:00:15+00:00",
    "commented_code": "})\n     })\n \n+    it('logs warning and resolves on failed video end', async function () {\n+      process.nextTick(() => {\n+        return this.projectInstance.emit('end', {\n+          stats: {\n+            failures: 0,\n+          },\n+        })\n+      })\n+\n+      sinon.spy(videoCapture, 'process')\n+      const endVideoCapture = sinon.stub().rejects()\n+\n+      await runMode.waitForTestsToFinishRunning({\n+        project: this.projectInstance,\n+        videoName: 'foo.mp4',\n+        compressedVideoName: 'foo-compressed.mp4',\n+        videoCompression: 32,\n+        videoUploadOnPasses: true,\n+        gui: false,\n+        endVideoCapture,\n+      })\n+\n+      expect(errors.warning).to.be.calledWith('VIDEO_POST_PROCESSING_FAILED')\n+\n+      expect(videoCapture.process).not.to.be.called",
    "repo_full_name": "cypress-io/cypress",
    "discussion_comments": [
      {
        "comment_id": "419658407",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 7192,
        "pr_file": "packages/server/test/unit/modes/run_spec.js",
        "discussion_id": "419658407",
        "commented_code": "@@ -522,6 +495,59 @@ describe('lib/modes/run', () => {\n       })\n     })\n \n+    it('logs warning and resolves on failed video end', async function () {\n+      process.nextTick(() => {\n+        return this.projectInstance.emit('end', {\n+          stats: {\n+            failures: 0,\n+          },\n+        })\n+      })\n+\n+      sinon.spy(videoCapture, 'process')\n+      const endVideoCapture = sinon.stub().rejects()\n+\n+      await runMode.waitForTestsToFinishRunning({\n+        project: this.projectInstance,\n+        videoName: 'foo.mp4',\n+        compressedVideoName: 'foo-compressed.mp4',\n+        videoCompression: 32,\n+        videoUploadOnPasses: true,\n+        gui: false,\n+        endVideoCapture,\n+      })\n+\n+      expect(errors.warning).to.be.calledWith('VIDEO_POST_PROCESSING_FAILED')\n+\n+      expect(videoCapture.process).not.to.be.called",
        "comment_created_at": "2020-05-04T19:00:15+00:00",
        "comment_author": "flotwig",
        "comment_body": "to check my understanding: previously, this error would crash the process, now it's dressed up in a warning?\r\n\r\nso e2e tests *can* still fail, but only in these 2 (more rare than now) conditions:\r\n\r\n1. `WAIT_FOR_MORE_FRAMES_TIMEOUT` is exceeded and <2 frames are received; or\r\n2. `ffmpeg` gives an error *not* caused by receiving 0 frames\r\n\r\nis that all correct?",
        "pr_file_module": null
      },
      {
        "comment_id": "419703587",
        "repo_full_name": "cypress-io/cypress",
        "pr_number": 7192,
        "pr_file": "packages/server/test/unit/modes/run_spec.js",
        "discussion_id": "419658407",
        "commented_code": "@@ -522,6 +495,59 @@ describe('lib/modes/run', () => {\n       })\n     })\n \n+    it('logs warning and resolves on failed video end', async function () {\n+      process.nextTick(() => {\n+        return this.projectInstance.emit('end', {\n+          stats: {\n+            failures: 0,\n+          },\n+        })\n+      })\n+\n+      sinon.spy(videoCapture, 'process')\n+      const endVideoCapture = sinon.stub().rejects()\n+\n+      await runMode.waitForTestsToFinishRunning({\n+        project: this.projectInstance,\n+        videoName: 'foo.mp4',\n+        compressedVideoName: 'foo-compressed.mp4',\n+        videoCompression: 32,\n+        videoUploadOnPasses: true,\n+        gui: false,\n+        endVideoCapture,\n+      })\n+\n+      expect(errors.warning).to.be.calledWith('VIDEO_POST_PROCESSING_FAILED')\n+\n+      expect(videoCapture.process).not.to.be.called",
        "comment_created_at": "2020-05-04T20:20:49+00:00",
        "comment_author": "kuceb",
        "comment_body": "the error was always a warning, but it would cause our tests to fail because the stdout didnt match when we printed the warning message.\r\n\r\nyes those scenarios would cause stdout to show the warning and e2e tests to fail\r\n\r\n",
        "pr_file_module": null
      }
    ]
  }
]