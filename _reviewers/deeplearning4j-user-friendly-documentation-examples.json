[
  {
    "discussion_id": "307206667",
    "pr_number": 8043,
    "pr_file": "docs/samediff/templates/ops.md",
    "created_at": "2019-07-25T09:40:48+00:00",
    "commented_code": "-# SameDiff operations\n-\n-{{autogenerated}}\n\\ No newline at end of file\n+---\r\n+title: Operations in SameDiff\r\n+short_title: Ops\r\n+description: What kind of operations is there in `SameDiff` and how to use them\r\n+category: SameDiff\r\n+weight: 4\r\n+---\r\n+\r\n+# SameDiff operations\r\n+\r\n+Operations in `SameDiff` work mostly the way you'd expect them to. You take variables - in our framework, those are \r\n+objects of type `SDVariable` - apply operations to them, and thus produce new variables. Before we proceed to the \r\n+overview of the available operations, let us list some of their common properties.\r\n+\r\n+## Common properties of operations\r\n+\r\n+- All operations should return a new `SDVariable`. Thus, a standalone operation like ```x.mul(2);``` will not work; one \r\n+needs to have something like\r\n+```java\r\n+SDVariable _2x = x.mul(2);\r\n+``` \r\n+- All variables in an operation have to belong to the same instance of `SamdeDiff` (see the [variables](./samediff/variables)\r\n+section on how variables are added to a `SameDiff` instance). In other words, the following code will also produce an \r\n+exception \r\n+```java\r\n+SDVariable x = sameDiff0.var(DataType.FLOAT, 1);\r\n+SDVariable y = sameDiff1.placeHolder(DataType.FLOAT, 1);\r\n+//The following code produces exception, because SameDiff instances are different\r\n+SDVariable z = x.add(y);\r\n+```\r\n+- Operations **may not** be used to redefine variables that were already introduced. The following code will produce an \r\n+exception\r\n+```java\r\n+SDVariable z = x.add(y);\r\n+//The following code produces an exception!!!\r\n+x = z.mul(y);",
    "repo_full_name": "deeplearning4j/deeplearning4j",
    "discussion_comments": [
      {
        "comment_id": "307206667",
        "repo_full_name": "deeplearning4j/deeplearning4j",
        "pr_number": 8043,
        "pr_file": "docs/samediff/templates/ops.md",
        "discussion_id": "307206667",
        "commented_code": "@@ -1,3 +1,243 @@\n-# SameDiff operations\n-\n-{{autogenerated}}\n\\ No newline at end of file\n+---\r\n+title: Operations in SameDiff\r\n+short_title: Ops\r\n+description: What kind of operations is there in `SameDiff` and how to use them\r\n+category: SameDiff\r\n+weight: 4\r\n+---\r\n+\r\n+# SameDiff operations\r\n+\r\n+Operations in `SameDiff` work mostly the way you'd expect them to. You take variables - in our framework, those are \r\n+objects of type `SDVariable` - apply operations to them, and thus produce new variables. Before we proceed to the \r\n+overview of the available operations, let us list some of their common properties.\r\n+\r\n+## Common properties of operations\r\n+\r\n+- All operations should return a new `SDVariable`. Thus, a standalone operation like ```x.mul(2);``` will not work; one \r\n+needs to have something like\r\n+```java\r\n+SDVariable _2x = x.mul(2);\r\n+``` \r\n+- All variables in an operation have to belong to the same instance of `SamdeDiff` (see the [variables](./samediff/variables)\r\n+section on how variables are added to a `SameDiff` instance). In other words, the following code will also produce an \r\n+exception \r\n+```java\r\n+SDVariable x = sameDiff0.var(DataType.FLOAT, 1);\r\n+SDVariable y = sameDiff1.placeHolder(DataType.FLOAT, 1);\r\n+//The following code produces exception, because SameDiff instances are different\r\n+SDVariable z = x.add(y);\r\n+```\r\n+- Operations **may not** be used to redefine variables that were already introduced. The following code will produce an \r\n+exception\r\n+```java\r\n+SDVariable z = x.add(y);\r\n+//The following code produces an exception!!!\r\n+x = z.mul(y);\r",
        "comment_created_at": "2019-07-25T09:40:48+00:00",
        "comment_author": "AlexDBlack",
        "comment_body": "Let's move these two \"don't do this\" to a section at the very end. Totally fine to mention them, but we shouldn't be opening with a bunch of things to *not* do that the user might not have even thought to try...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "298435154",
    "pr_number": 7916,
    "pr_file": "docs/nd4j/templates/quickstart.md",
    "created_at": "2019-06-28T02:41:56+00:00",
    "commented_code": "+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\n+SLF4J: Defaulting to no-operation (NOP) logger implementation\n+SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.shape().length;\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.create` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.create(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.create(arr_1d);\n+```\n+\n+There are overloaded `create` functions for INDArrays up to 4 dimensions. To create INDArrays with any shape use the `create` functions that take a shape as one of their arguments.\n+\n+```java\n+double[] flat = ArrayUtil.flattenDoubleArray(myDoubleArray);\n+int[] shape = ...;\t//Array shape here\n+INDArray myArr = Nd4j.create(flat,shape,'c');\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDarray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(shape, DataType.DOUBLE);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5);\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]",
    "repo_full_name": "deeplearning4j/deeplearning4j",
    "discussion_comments": [
      {
        "comment_id": "298435154",
        "repo_full_name": "deeplearning4j/deeplearning4j",
        "pr_number": 7916,
        "pr_file": "docs/nd4j/templates/quickstart.md",
        "discussion_id": "298435154",
        "commented_code": "@@ -0,0 +1,381 @@\n+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\n+SLF4J: Defaulting to no-operation (NOP) logger implementation\n+SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.shape().length;\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.create` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.create(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.create(arr_1d);\n+```\n+\n+There are overloaded `create` functions for INDArrays up to 4 dimensions. To create INDArrays with any shape use the `create` functions that take a shape as one of their arguments.\n+\n+```java\n+double[] flat = ArrayUtil.flattenDoubleArray(myDoubleArray);\n+int[] shape = ...;\t//Array shape here\n+INDArray myArr = Nd4j.create(flat,shape,'c');\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDarray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(shape, DataType.DOUBLE);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5);\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]",
        "comment_created_at": "2019-06-28T02:41:56+00:00",
        "comment_author": "AlexDBlack",
        "comment_body": "Maybe add comment for args order: (start, stop, count)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "298435906",
    "pr_number": 7916,
    "pr_file": "docs/nd4j/templates/quickstart.md",
    "created_at": "2019-06-28T02:47:25+00:00",
    "commented_code": "+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\n+SLF4J: Defaulting to no-operation (NOP) logger implementation\n+SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.shape().length;\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.create` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.create(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.create(arr_1d);\n+```\n+\n+There are overloaded `create` functions for INDArrays up to 4 dimensions. To create INDArrays with any shape use the `create` functions that take a shape as one of their arguments.\n+\n+```java\n+double[] flat = ArrayUtil.flattenDoubleArray(myDoubleArray);\n+int[] shape = ...;\t//Array shape here\n+INDArray myArr = Nd4j.create(flat,shape,'c');\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDarray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(shape, DataType.DOUBLE);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5);\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]\n+\n+// Evaluate a function over many points.\n+import static org.nd4j.linalg.ops.transforms.Transforms.sin;\n+INDArray  x = Nd4j.linspace(0.0, Math.PI, 100, DataType.DOUBLE);\n+INDArray  y = sin(x);  \n+```\n+\n+### Printing Arrays\n+The INDArray supports Java's `toString()` method. The output is similar to printing NumPy arrays:\n+```java\n+INDArray  x = Nd4j.arange(6);  //1d array\n+System.out.println(x);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+int [] shape = {4,3};\n+x = Nd4j.arange(12).reshape(shape);   //2d array\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+int [] shape2 = {2,3,4};\n+x = Nd4j.arange(24).reshape(shape2);  //3d array\n+System.out.println(x);\n+/*\n+[[[         0,    1.0000,    2.0000,    3.0000], \n+  [    4.0000,    5.0000,    6.0000,    7.0000], \n+  [    8.0000,    9.0000,   10.0000,   11.0000]], \n+\n+ [[   12.0000,   13.0000,   14.0000,   15.0000], \n+  [   16.0000,   17.0000,   18.0000,   19.0000], \n+  [   20.0000,   21.0000,   22.0000,   23.0000]]]\n+*/\n+```\n+\n+### Basic Operations\n+You will have to use INDArray methods to perform operations on your arrays. There are  in-place and copy overloads and scalar and element wise overloaded versions. The in-place operators return a reference to the array so you can conveniently chain operations together.\n+\n+```java\n+//Copy\n+arr_new = arr.add(scalar);    // return a new array with scalar added to each element of arr.\n+arr_new = arr.add(other_arr); // return a new array with element wise addition of arr and other_arr.\n+\n+//in place.\n+arr_new = arr.addi(scalar); //Heads up: arr_new points to the same array as arr.\n+arr_new = arr.addi(other_arr);\n+```\n+\n+addition: arr.add(...), arr.addi(...)\n+substraction: arr.sub(...), arr.subi(...)\n+multiplication: arr.mul(...), arr.muli(...)\n+division: arr.div(...), arr.divi(...)\n+\n+When you perform the basic operations you must make sure the underlying data types are the same.\n+```java\n+int [] shape = {5};\n+INDArray  x = Nd4j.zeros(shape, DataType.DOUBLE);\n+INDArray  x2 = Nd4j.zeros(shape, DataType.INT);\n+INDArray  x3 = x.add(x2);\n+// java.lang.IllegalArgumentException: Op.X and Op.Y must have the same data type, but got INT vs DOUBLE\n+```\n+<!--- Moving matrix operations after Transforms. In Nd4j the dot product is a transform. -->\n+\n+The IndArray has methods implementing operations such as `sum`, `min`, `max`.",
    "repo_full_name": "deeplearning4j/deeplearning4j",
    "discussion_comments": [
      {
        "comment_id": "298435906",
        "repo_full_name": "deeplearning4j/deeplearning4j",
        "pr_number": 7916,
        "pr_file": "docs/nd4j/templates/quickstart.md",
        "discussion_id": "298435906",
        "commented_code": "@@ -0,0 +1,381 @@\n+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\n+SLF4J: Defaulting to no-operation (NOP) logger implementation\n+SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.shape().length;\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.create` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.create(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.create(arr_1d);\n+```\n+\n+There are overloaded `create` functions for INDArrays up to 4 dimensions. To create INDArrays with any shape use the `create` functions that take a shape as one of their arguments.\n+\n+```java\n+double[] flat = ArrayUtil.flattenDoubleArray(myDoubleArray);\n+int[] shape = ...;\t//Array shape here\n+INDArray myArr = Nd4j.create(flat,shape,'c');\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDarray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(shape, DataType.DOUBLE);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5);\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]\n+\n+// Evaluate a function over many points.\n+import static org.nd4j.linalg.ops.transforms.Transforms.sin;\n+INDArray  x = Nd4j.linspace(0.0, Math.PI, 100, DataType.DOUBLE);\n+INDArray  y = sin(x);  \n+```\n+\n+### Printing Arrays\n+The INDArray supports Java's `toString()` method. The output is similar to printing NumPy arrays:\n+```java\n+INDArray  x = Nd4j.arange(6);  //1d array\n+System.out.println(x);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+int [] shape = {4,3};\n+x = Nd4j.arange(12).reshape(shape);   //2d array\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+int [] shape2 = {2,3,4};\n+x = Nd4j.arange(24).reshape(shape2);  //3d array\n+System.out.println(x);\n+/*\n+[[[         0,    1.0000,    2.0000,    3.0000], \n+  [    4.0000,    5.0000,    6.0000,    7.0000], \n+  [    8.0000,    9.0000,   10.0000,   11.0000]], \n+\n+ [[   12.0000,   13.0000,   14.0000,   15.0000], \n+  [   16.0000,   17.0000,   18.0000,   19.0000], \n+  [   20.0000,   21.0000,   22.0000,   23.0000]]]\n+*/\n+```\n+\n+### Basic Operations\n+You will have to use INDArray methods to perform operations on your arrays. There are  in-place and copy overloads and scalar and element wise overloaded versions. The in-place operators return a reference to the array so you can conveniently chain operations together.\n+\n+```java\n+//Copy\n+arr_new = arr.add(scalar);    // return a new array with scalar added to each element of arr.\n+arr_new = arr.add(other_arr); // return a new array with element wise addition of arr and other_arr.\n+\n+//in place.\n+arr_new = arr.addi(scalar); //Heads up: arr_new points to the same array as arr.\n+arr_new = arr.addi(other_arr);\n+```\n+\n+addition: arr.add(...), arr.addi(...)\n+substraction: arr.sub(...), arr.subi(...)\n+multiplication: arr.mul(...), arr.muli(...)\n+division: arr.div(...), arr.divi(...)\n+\n+When you perform the basic operations you must make sure the underlying data types are the same.\n+```java\n+int [] shape = {5};\n+INDArray  x = Nd4j.zeros(shape, DataType.DOUBLE);\n+INDArray  x2 = Nd4j.zeros(shape, DataType.INT);\n+INDArray  x3 = x.add(x2);\n+// java.lang.IllegalArgumentException: Op.X and Op.Y must have the same data type, but got INT vs DOUBLE\n+```\n+<!--- Moving matrix operations after Transforms. In Nd4j the dot product is a transform. -->\n+\n+The IndArray has methods implementing operations such as `sum`, `min`, `max`.",
        "comment_created_at": "2019-06-28T02:47:25+00:00",
        "comment_author": "AlexDBlack",
        "comment_body": "IndArray -> INDArray\r\n\"operations such as\" - mention they are called reduction/accumulation operations.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "298436866",
    "pr_number": 7916,
    "pr_file": "docs/nd4j/templates/quickstart.md",
    "created_at": "2019-06-28T02:53:21+00:00",
    "commented_code": "+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\n+SLF4J: Defaulting to no-operation (NOP) logger implementation\n+SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.shape().length;\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.create` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.create(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.create(arr_1d);\n+```\n+\n+There are overloaded `create` functions for INDArrays up to 4 dimensions. To create INDArrays with any shape use the `create` functions that take a shape as one of their arguments.\n+\n+```java\n+double[] flat = ArrayUtil.flattenDoubleArray(myDoubleArray);\n+int[] shape = ...;\t//Array shape here\n+INDArray myArr = Nd4j.create(flat,shape,'c');\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDarray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(shape, DataType.DOUBLE);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5);\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]\n+\n+// Evaluate a function over many points.\n+import static org.nd4j.linalg.ops.transforms.Transforms.sin;\n+INDArray  x = Nd4j.linspace(0.0, Math.PI, 100, DataType.DOUBLE);\n+INDArray  y = sin(x);  \n+```\n+\n+### Printing Arrays\n+The INDArray supports Java's `toString()` method. The output is similar to printing NumPy arrays:\n+```java\n+INDArray  x = Nd4j.arange(6);  //1d array\n+System.out.println(x);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+int [] shape = {4,3};\n+x = Nd4j.arange(12).reshape(shape);   //2d array\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+int [] shape2 = {2,3,4};\n+x = Nd4j.arange(24).reshape(shape2);  //3d array\n+System.out.println(x);\n+/*\n+[[[         0,    1.0000,    2.0000,    3.0000], \n+  [    4.0000,    5.0000,    6.0000,    7.0000], \n+  [    8.0000,    9.0000,   10.0000,   11.0000]], \n+\n+ [[   12.0000,   13.0000,   14.0000,   15.0000], \n+  [   16.0000,   17.0000,   18.0000,   19.0000], \n+  [   20.0000,   21.0000,   22.0000,   23.0000]]]\n+*/\n+```\n+\n+### Basic Operations\n+You will have to use INDArray methods to perform operations on your arrays. There are  in-place and copy overloads and scalar and element wise overloaded versions. The in-place operators return a reference to the array so you can conveniently chain operations together.\n+\n+```java\n+//Copy\n+arr_new = arr.add(scalar);    // return a new array with scalar added to each element of arr.\n+arr_new = arr.add(other_arr); // return a new array with element wise addition of arr and other_arr.\n+\n+//in place.\n+arr_new = arr.addi(scalar); //Heads up: arr_new points to the same array as arr.\n+arr_new = arr.addi(other_arr);\n+```\n+\n+addition: arr.add(...), arr.addi(...)\n+substraction: arr.sub(...), arr.subi(...)\n+multiplication: arr.mul(...), arr.muli(...)\n+division: arr.div(...), arr.divi(...)\n+\n+When you perform the basic operations you must make sure the underlying data types are the same.\n+```java\n+int [] shape = {5};\n+INDArray  x = Nd4j.zeros(shape, DataType.DOUBLE);\n+INDArray  x2 = Nd4j.zeros(shape, DataType.INT);\n+INDArray  x3 = x.add(x2);\n+// java.lang.IllegalArgumentException: Op.X and Op.Y must have the same data type, but got INT vs DOUBLE\n+```\n+<!--- Moving matrix operations after Transforms. In Nd4j the dot product is a transform. -->\n+\n+The IndArray has methods implementing operations such as `sum`, `min`, `max`.\n+```java\n+int [] shape = {2,3};\n+INDArray  x = Nd4j.rand(shape);\n+System.out.println(x);\n+\n+System.out.println(x.sum());\n+System.out.println(x.min());\n+System.out.println(x.max());\n+/*\n+[[    0.8621,    0.9224,    0.8407], \n+ [    0.1504,    0.5489,    0.9584]]\n+4.2830\n+0.1504\n+0.9584\n+*/\n+```\n+\n+Provide a dimension argument to apply the operation across the specified dimension:\n+\n+```java\n+int [] shape = {3,4};\n+INDArray x = Nd4j.arange(12).reshape(shape);\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/        \n+\n+System.out.println(x.sum(0)); // Sum of each column.\n+//[   12.0000,   15.0000,   18.0000,   21.0000]\n+\n+System.out.println(x.min(1)); // Min of each row\n+//[         0,    4.0000,    8.0000]\n+\n+System.out.println(x.cumsum(1)); // cumulative sum across each row,\n+/*\n+[[         0,    1.0000,    3.0000,    6.0000], \n+ [    4.0000,    9.0000,   15.0000,   22.0000], \n+ [    8.0000,   17.0000,   27.0000,   38.0000]]\n+*/\n+\n+```\n+\n+<!--- The numpy quickstart calls them Universal Functions. -->\n+### Transform operation\n+Nd4j provides familiar mathematical functions such as sin, cos, and exp. These are called transform operations. The result is returned as an INDArray.\n+\n+```java\n+INDArray x = Nd4j.arange(3);\n+System.out.println(x);\n+// [         0,    1.0000,    2.0000]\n+System.out.println(exp(x));\n+// [    1.0000,    2.7183,    7.3891]\n+System.out.println(sqrt(x));\n+// [         0,    1.0000,    1.4142]\n+```\n+\n+You can check out a complete list of transform operations in the [Javadoc](https://deeplearning4j.org/api/latest/org/nd4j/linalg/api/ops/impl/transforms/package-summary.html )\n+\n+\n+### Matrix multiplication\n+We have already seen the element wise multiplcation in the basic operations. The other Matrix operations have their own methods:\n+\n+```java\n+int[] shape = {3, 4};\n+INDArray x = Nd4j.arange(12).reshape(shape);\n+int[] shape2 = {4, 3};\n+INDArray y = Nd4j.arange(12).reshape(shape2);\n+\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+System.out.println(y);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+System.out.println(x.mmul(y));  // matrix product.\n+/*\n+[[   42.0000,   48.0000,   54.0000], \n+ [  114.0000,  136.0000,  158.0000], \n+ [  186.0000,  224.0000,  262.0000]]\n+*/\n+\n+// dot product.\n+INDArray x = Nd4j.arange(12);\n+INDArray y = Nd4j.arange(12);\n+System.out.println(dot(x, y));  \n+//506.0000\n+```\n+\n+### Indexing, Slicing and Iterating\n+Indexing, Slicing and Iterating is harder in Java than in Python. \n+To retreive individual values from an INDArray you can use the `getDouble`, `getFloat` or `getInt` methods. INDArrays cannot be indexed like Java arrays. You can get a Java array from an INDArray using `.data().asDouble()`.",
    "repo_full_name": "deeplearning4j/deeplearning4j",
    "discussion_comments": [
      {
        "comment_id": "298436866",
        "repo_full_name": "deeplearning4j/deeplearning4j",
        "pr_number": 7916,
        "pr_file": "docs/nd4j/templates/quickstart.md",
        "discussion_id": "298436866",
        "commented_code": "@@ -0,0 +1,381 @@\n+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\n+SLF4J: Defaulting to no-operation (NOP) logger implementation\n+SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.shape().length;\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.create` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.create(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.create(arr_1d);\n+```\n+\n+There are overloaded `create` functions for INDArrays up to 4 dimensions. To create INDArrays with any shape use the `create` functions that take a shape as one of their arguments.\n+\n+```java\n+double[] flat = ArrayUtil.flattenDoubleArray(myDoubleArray);\n+int[] shape = ...;\t//Array shape here\n+INDArray myArr = Nd4j.create(flat,shape,'c');\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDarray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(shape, DataType.DOUBLE);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5);\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]\n+\n+// Evaluate a function over many points.\n+import static org.nd4j.linalg.ops.transforms.Transforms.sin;\n+INDArray  x = Nd4j.linspace(0.0, Math.PI, 100, DataType.DOUBLE);\n+INDArray  y = sin(x);  \n+```\n+\n+### Printing Arrays\n+The INDArray supports Java's `toString()` method. The output is similar to printing NumPy arrays:\n+```java\n+INDArray  x = Nd4j.arange(6);  //1d array\n+System.out.println(x);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+int [] shape = {4,3};\n+x = Nd4j.arange(12).reshape(shape);   //2d array\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+int [] shape2 = {2,3,4};\n+x = Nd4j.arange(24).reshape(shape2);  //3d array\n+System.out.println(x);\n+/*\n+[[[         0,    1.0000,    2.0000,    3.0000], \n+  [    4.0000,    5.0000,    6.0000,    7.0000], \n+  [    8.0000,    9.0000,   10.0000,   11.0000]], \n+\n+ [[   12.0000,   13.0000,   14.0000,   15.0000], \n+  [   16.0000,   17.0000,   18.0000,   19.0000], \n+  [   20.0000,   21.0000,   22.0000,   23.0000]]]\n+*/\n+```\n+\n+### Basic Operations\n+You will have to use INDArray methods to perform operations on your arrays. There are  in-place and copy overloads and scalar and element wise overloaded versions. The in-place operators return a reference to the array so you can conveniently chain operations together.\n+\n+```java\n+//Copy\n+arr_new = arr.add(scalar);    // return a new array with scalar added to each element of arr.\n+arr_new = arr.add(other_arr); // return a new array with element wise addition of arr and other_arr.\n+\n+//in place.\n+arr_new = arr.addi(scalar); //Heads up: arr_new points to the same array as arr.\n+arr_new = arr.addi(other_arr);\n+```\n+\n+addition: arr.add(...), arr.addi(...)\n+substraction: arr.sub(...), arr.subi(...)\n+multiplication: arr.mul(...), arr.muli(...)\n+division: arr.div(...), arr.divi(...)\n+\n+When you perform the basic operations you must make sure the underlying data types are the same.\n+```java\n+int [] shape = {5};\n+INDArray  x = Nd4j.zeros(shape, DataType.DOUBLE);\n+INDArray  x2 = Nd4j.zeros(shape, DataType.INT);\n+INDArray  x3 = x.add(x2);\n+// java.lang.IllegalArgumentException: Op.X and Op.Y must have the same data type, but got INT vs DOUBLE\n+```\n+<!--- Moving matrix operations after Transforms. In Nd4j the dot product is a transform. -->\n+\n+The IndArray has methods implementing operations such as `sum`, `min`, `max`.\n+```java\n+int [] shape = {2,3};\n+INDArray  x = Nd4j.rand(shape);\n+System.out.println(x);\n+\n+System.out.println(x.sum());\n+System.out.println(x.min());\n+System.out.println(x.max());\n+/*\n+[[    0.8621,    0.9224,    0.8407], \n+ [    0.1504,    0.5489,    0.9584]]\n+4.2830\n+0.1504\n+0.9584\n+*/\n+```\n+\n+Provide a dimension argument to apply the operation across the specified dimension:\n+\n+```java\n+int [] shape = {3,4};\n+INDArray x = Nd4j.arange(12).reshape(shape);\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/        \n+\n+System.out.println(x.sum(0)); // Sum of each column.\n+//[   12.0000,   15.0000,   18.0000,   21.0000]\n+\n+System.out.println(x.min(1)); // Min of each row\n+//[         0,    4.0000,    8.0000]\n+\n+System.out.println(x.cumsum(1)); // cumulative sum across each row,\n+/*\n+[[         0,    1.0000,    3.0000,    6.0000], \n+ [    4.0000,    9.0000,   15.0000,   22.0000], \n+ [    8.0000,   17.0000,   27.0000,   38.0000]]\n+*/\n+\n+```\n+\n+<!--- The numpy quickstart calls them Universal Functions. -->\n+### Transform operation\n+Nd4j provides familiar mathematical functions such as sin, cos, and exp. These are called transform operations. The result is returned as an INDArray.\n+\n+```java\n+INDArray x = Nd4j.arange(3);\n+System.out.println(x);\n+// [         0,    1.0000,    2.0000]\n+System.out.println(exp(x));\n+// [    1.0000,    2.7183,    7.3891]\n+System.out.println(sqrt(x));\n+// [         0,    1.0000,    1.4142]\n+```\n+\n+You can check out a complete list of transform operations in the [Javadoc](https://deeplearning4j.org/api/latest/org/nd4j/linalg/api/ops/impl/transforms/package-summary.html )\n+\n+\n+### Matrix multiplication\n+We have already seen the element wise multiplcation in the basic operations. The other Matrix operations have their own methods:\n+\n+```java\n+int[] shape = {3, 4};\n+INDArray x = Nd4j.arange(12).reshape(shape);\n+int[] shape2 = {4, 3};\n+INDArray y = Nd4j.arange(12).reshape(shape2);\n+\n+System.out.println(x);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+System.out.println(y);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+System.out.println(x.mmul(y));  // matrix product.\n+/*\n+[[   42.0000,   48.0000,   54.0000], \n+ [  114.0000,  136.0000,  158.0000], \n+ [  186.0000,  224.0000,  262.0000]]\n+*/\n+\n+// dot product.\n+INDArray x = Nd4j.arange(12);\n+INDArray y = Nd4j.arange(12);\n+System.out.println(dot(x, y));  \n+//506.0000\n+```\n+\n+### Indexing, Slicing and Iterating\n+Indexing, Slicing and Iterating is harder in Java than in Python. \n+To retreive individual values from an INDArray you can use the `getDouble`, `getFloat` or `getInt` methods. INDArrays cannot be indexed like Java arrays. You can get a Java array from an INDArray using `.data().asDouble()`. ",
        "comment_created_at": "2019-06-28T02:53:21+00:00",
        "comment_author": "AlexDBlack",
        "comment_body": "`.data().asDouble()` etc isn't something I want in the quickstart, it's confusing for new users due to views and f/c order (not to mention permuted arrays).\r\nInstead, direct users to toFloatVector(), toDoubleMatrix() etc\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "299006736",
    "pr_number": 7916,
    "pr_file": "docs/nd4j/templates/quickstart.md",
    "created_at": "2019-07-01T11:53:39+00:00",
    "commented_code": "+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+    * all major operating systems: win/linux/osx/android.\n+    * architectures: x86, arm, ppc.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You can use Nd4J from any [JVM Language](https://en.wikipedia.org/wiki/List_of_JVM_languages). (For example: Scala, Kotlin). You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+To improve readability we show you the output of `System.out.println(...)`.  But we have not show the print statement in the sample code. If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+import org.nd4j.linalg.factory.Nd4j;\n+import org.nd4j.linalg.api.buffer.DataType;\n+        \n+INDArray x = Nd4j.zeros(3,4);\n+\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.rank();\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+long length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.createFromArray` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`. The `Nd4j.createFromArray` function has overloads up to 4d for all types.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.createFromArray(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.createFromArray(arr_1d);\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDArray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(DataType.DOUBLE, 5);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5); //start, stop, count.\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]\n+\n+// Evaluate a function over many points.\n+import static org.nd4j.linalg.ops.transforms.Transforms.sin;\n+INDArray  x = Nd4j.linspace(0.0, Math.PI, 100, DataType.DOUBLE);\n+INDArray  y = sin(x);  \n+```\n+\n+### Printing Arrays\n+The INDArray supports Java's `toString()` method. The current implementation has limited precision and a limited number of elements.  The output is similar to printing NumPy arrays:\n+```java\n+INDArray  x = Nd4j.arange(6);  //1d array\n+System.out.println(x);  //We just give the output of the print command from here on.\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+int [] shape = {4,3};\n+x = Nd4j.arange(12).reshape(shape);   //2d array\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+int [] shape2 = {2,3,4};\n+x = Nd4j.arange(24).reshape(shape2);  //3d array\n+/*\n+[[[         0,    1.0000,    2.0000,    3.0000], \n+  [    4.0000,    5.0000,    6.0000,    7.0000], \n+  [    8.0000,    9.0000,   10.0000,   11.0000]], \n+\n+ [[   12.0000,   13.0000,   14.0000,   15.0000], \n+  [   16.0000,   17.0000,   18.0000,   19.0000], \n+  [   20.0000,   21.0000,   22.0000,   23.0000]]]\n+*/\n+```\n+\n+### Basic Operations\n+You will have to use INDArray methods to perform operations on your arrays. There are  in-place and copy overloads and scalar and element wise overloaded versions. The in-place operators return a reference to the array so you can conveniently chain operations together. Use in-place operators where possible to improve performance. Copy operators have new array creation overhead.\n+\n+```java\n+//Copy\n+arr_new = arr.add(scalar);    // return a new array with scalar added to each element of arr.\n+arr_new = arr.add(other_arr); // return a new array with element wise addition of arr and other_arr.\n+\n+//in place.\n+arr_new = arr.addi(scalar); //Heads up: arr_new points to the same array as arr.\n+arr_new = arr.addi(other_arr);\n+```\n+\n+addition: arr.add(...), arr.addi(...)\n+substraction: arr.sub(...), arr.subi(...)\n+multiplication: arr.mul(...), arr.muli(...)\n+division: arr.div(...), arr.divi(...)\n+\n+When you perform the basic operations you must make sure the underlying data types are the same.\n+```java\n+int [] shape = {5};\n+INDArray  x = Nd4j.zeros(shape, DataType.DOUBLE);\n+INDArray  x2 = Nd4j.zeros(shape, DataType.INT);\n+INDArray  x3 = x.add(x2);\n+// java.lang.IllegalArgumentException: Op.X and Op.Y must have the same data type, but got INT vs DOUBLE\n+\n+// casting x2 to DOUBLE solves the problem:\n+INDArray x3 = x.add(x2.castTo(DataType.DOUBLE));\n+```\n+<!--- Moving matrix operations after Transforms. In Nd4j the dot product is a transform. -->\n+\n+The INDArray has methods implementing reduction/accumulation operations such as `sum`, `min`, `max`.\n+```java\n+int [] shape = {2,3};\n+INDArray  x = Nd4j.rand(shape);\n+x;\n+x.sum();\n+x.min();\n+x.max();\n+/*\n+[[    0.8621,    0.9224,    0.8407], \n+ [    0.1504,    0.5489,    0.9584]]\n+4.2830\n+0.1504\n+0.9584\n+*/\n+```\n+\n+Provide a dimension argument to apply the operation across the specified dimension:\n+\n+```java\n+INDArray x = Nd4j.arange(12).reshape(3, 4);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/        \n+\n+x.sum(0); // Sum of each column.\n+//[   12.0000,   15.0000,   18.0000,   21.0000]\n+\n+x.min(1); // Min of each row\n+//[         0,    4.0000,    8.0000]\n+\n+x.cumsum(1); // cumulative sum across each row,\n+/*\n+[[         0,    1.0000,    3.0000,    6.0000], \n+ [    4.0000,    9.0000,   15.0000,   22.0000], \n+ [    8.0000,   17.0000,   27.0000,   38.0000]]\n+*/\n+\n+```\n+\n+<!--- The numpy quickstart calls them Universal Functions. -->\n+### Transform operation\n+Nd4j provides familiar mathematical functions such as sin, cos, and exp. These are called transform operations. The result is returned as an INDArray.\n+\n+```java\n+import static org.nd4j.linalg.ops.transforms.Transforms.exp;\n+import static org.nd4j.linalg.ops.transforms.Transforms.sqrt;\n+\n+INDArray x = Nd4j.arange(3);\n+// [         0,    1.0000,    2.0000]\n+exp(x);\n+// [    1.0000,    2.7183,    7.3891]\n+sqrt(x);\n+// [         0,    1.0000,    1.4142]\n+```\n+\n+You can check out a complete list of transform operations in the [Javadoc](https://deeplearning4j.org/api/latest/org/nd4j/linalg/api/ops/impl/transforms/package-summary.html )\n+\n+\n+### Matrix multiplication\n+We have already seen the element wise multiplcation in the basic operations. The other Matrix operations have their own methods:\n+\n+```java\n+INDArray x = Nd4j.arange(12).reshape(3, 4);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+INDArray y = Nd4j.arange(12).reshape(4, 3);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+x.mmul(y);  // matrix product.\n+/*\n+[[   42.0000,   48.0000,   54.0000], \n+ [  114.0000,  136.0000,  158.0000], \n+ [  186.0000,  224.0000,  262.0000]]\n+*/\n+\n+// dot product.\n+INDArray x = Nd4j.arange(12);\n+INDArray y = Nd4j.arange(12);\n+dot(x, y);  \n+//506.0000\n+```\n+\n+### Indexing, Slicing and Iterating\n+Indexing, Slicing and Iterating is harder in Java than in Python. \n+To retreive individual values from an INDArray you can use the `getDouble`, `getFloat` or `getInt` methods. INDArrays cannot be indexed like Java arrays. You can get a Java array from an INDArray using `toDoubleVector()`,  `toDoubleMatrix()`, `toFloatVector()` and `toFloatMatrix()` \n+\n+```java\n+\n+INDArray x = Nd4j.arange(12);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000,    6.0000,    7.0000,    8.0000,    9.0000,   10.0000,   11.0000]\n+\n+float f = x.getFloat(3);  // Single element access. Other methods: getDouble, getInt, ...\n+// 3.0\n+\n+float []  fArr = x.toFloatVector(); //Convert to Java array.\n+// [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0]\n+\n+INDArray x2 = x.get(NDArrayIndex.interval(2, 6));\n+// [    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+// On a copy of x: From start to position 6, exclusive, set every 2nd element to -1.0\n+INDArray y = x.dup();\n+y.get(NDArrayIndex.interval(0, 2, 6)).assign(-1.0);\n+//[   -1.0000,    1.0000,   -1.0000,    3.0000,   -1.0000,    5.0000,    6.0000,    7.0000,    8.0000,    9.0000,   10.0000,   11.0000]\n+\n+// reversed copy of y.\n+INDArray y2 = Nd4j.reverse(y.dup());\n+//[   11.0000,   10.0000,    9.0000,    8.0000,    7.0000,    6.0000,    5.0000,   -1.0000,    3.0000,   -1.0000,    1.0000,   -1.0000]\n+\n+```\n+\n+For multidimensional arrays you should use `INDArray.get(NDArrayIndex...)`. The example below shows how to iterate over the rows and columns of a 2D array. Note that for 2D arrays we could have used the `getColumn` and `getRow` convenience methods. \n+\n+```java\n+// Iterate over the rows and columns of a 2d arrray.\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+\n+INDArray x = Nd4j.rand(shape);\n+/*\n+[[    0.2228,    0.2871,    0.3880,    0.7167,    0.9951], \n+ [    0.7181,    0.8106,    0.9062,    0.9291,    0.5115], \n+ [    0.5483,    0.7515,    0.3623,    0.7797,    0.5887], \n+ [    0.6822,    0.7785,    0.4456,    0.4231,    0.9157]]\n+*/\n+        \n+for (int row=0; row<rows; row++) {\n+\tINDArray y = x.get(NDArrayIndex.point(row), NDArrayIndex.all());\n+\t}\n+/*\n+[    0.2228,    0.2871,    0.3880,    0.7167,    0.9951]\n+[    0.7181,    0.8106,    0.9062,    0.9291,    0.5115]\n+[    0.5483,    0.7515,    0.3623,    0.7797,    0.5887]\n+[    0.6822,    0.7785,    0.4456,    0.4231,    0.9157]\n+*/\n+\t\n+for (int col=0; col<cols; col++) {\n+\tINDArray y = x.get(NDArrayIndex.all(), NDArrayIndex.point(col));\n+\t}\n+/*\n+[    0.2228,    0.7181,    0.5483,    0.6822]\n+[    0.2871,    0.8106,    0.7515,    0.7785]\n+[    0.3880,    0.9062,    0.3623,    0.4456]\n+[    0.7167,    0.9291,    0.7797,    0.4231]\n+[    0.9951,    0.5115,    0.5887,    0.9157]\n+*/\n+\t\n+```\n+\n+## Shape Manipulation\n+### Changing the shape of an array\n+The number of elements along each axis is in the shape. The shape can be changed with various methods,.\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+x.shape();\n+// [3, 4]\n+\n+INDArray x2 = x.ravel();\n+x2.shape();\n+// [12]\n+\n+INDArray x3 = x.reshape(6,2).shape();\n+x3.shape();\n+//[6, 2]\n+\n+// Be aware that x, x2, and x3 share the same data. \n+x2.putScalar(5, -1.0);\n+\n+System.out.println( x);\n+/*\n+[[    0.0270,    0.3799,    0.5576,    0.3086], \n+ [    0.2266,   -1.0000,    0.1107,    0.4895], \n+ [    0.8431,    0.6011,    0.2996,    0.7500]]\n+*/\n+\n+System.out.println( x2);\n+// [    0.0270,    0.3799,    0.5576,    0.3086,    0.2266,   -1.0000,    0.1107,    0.4895,    0.8431,    0.6011,    0.2996,    0.7500]\n+\n+System.out.println( x3);\n+/*        \n+[[    0.0270,    0.3799], \n+ [    0.5576,    0.3086], \n+ [    0.2266,   -1.0000], \n+ [    0.1107,    0.4895], \n+ [    0.8431,    0.6011], \n+ [    0.2996,    0.7500]]\n+*/\n+```\n+\n+### Stacking together different arrays\n+Arrays can be stacked together using the `vstack` and `hstack` methods.\n+\n+```java\n+INDArray x = Nd4j.rand(2,2);\n+INDArray y = Nd4j.rand(2,2);\n+\n+x\n+/*\n+[[    0.1462,    0.5037], \n+ [    0.1418,    0.8645]]\n+*/\n+\n+y;\n+/*\n+[[    0.2305,    0.4798], \n+ [    0.9407,    0.9735]]\n+*/\n+ \n+Nd4j.vstack(x, y);\n+/*\n+[[    0.1462,    0.5037], \n+ [    0.1418,    0.8645], \n+ [    0.2305,    0.4798], \n+ [    0.9407,    0.9735]]\n+*/\n+\n+Nd4j.hstack(x, y);\n+/*\n+[[    0.1462,    0.5037,    0.2305,    0.4798], \n+ [    0.1418,    0.8645,    0.9407,    0.9735]]\n+*/\n+```\n+\n+<!--- No hsplit and vsplit functions in Nd4J. -->\n+<!--- ### Splitting one array into several smaller ones -->\n+\n+\n+## Copies and View\n+When working with INDArrays the data is not always copied. Here are three cases you should be aware of.\n+\n+### No Copy at All\n+Simple assignments make no copy of the data. Java passes objects by reference. No copies are made on a method call. \n+\n+```java\n+INDArray x = Nd4j.rand(2,2);\n+INDArray y = x; // y and x point to the same INData object.\n+\n+public static void f(INDArray x){\n+    // No copy is made. Any changes to x are visible after the function call.\n+    }\n+\n+```\n+\n+### View or Shallow Copy\n+Some functions will return a view of an array. \n+\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+INDArray  x2 = x.ravel();\n+INDArray  x3 = x.reshape(6,2);\n+\n+x2.putScalar(5, -1.0); // Changes x, x2 and x3\n+\n+x\n+/*\n+[[    0.8546,    0.1509,    0.0331,    0.1308], \n+ [    0.1753,   -1.0000,    0.2277,    0.1998], \n+ [    0.2741,    0.8257,    0.6946,    0.6851]]\n+*/\n+\n+x2\n+// [    0.8546,    0.1509,    0.0331,    0.1308,    0.1753,   -1.0000,    0.2277,    0.1998,    0.2741,    0.8257,    0.6946,    0.6851]\n+\n+x3\n+/*\n+[[    0.8546,    0.1509], \n+ [    0.0331,    0.1308], \n+ [    0.1753,   -1.0000], \n+ [    0.2277,    0.1998], \n+ [    0.2741,    0.8257], \n+ [    0.6946,    0.6851]]\n+*/\n+\n+```\n+\n+### Deep Copy\n+To make a copy of the array use the `dup` method. This will give you a new array with new data.\n+\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+INDArray  x2 = x.ravel().dup();\n+\n+x2.putScalar(5, -1.0); // Now only changes x2.\n+        \n+x\n+/*\n+[[    0.1604,    0.0322,    0.8910,    0.4604], \n+ [    0.7724,    0.1267,    0.1617,    0.7586], \n+ [    0.6117,    0.5385,    0.1251,    0.6886]]\n+*/\n+\n+x2\n+// [    0.1604,    0.0322,    0.8910,    0.4604,    0.7724,   -1.0000,    0.1617,    0.7586,    0.6117,    0.5385,    0.1251,    0.6886]\n+```\n+\n+## Functions and Methods Overview\n+\n+### Array Creation",
    "repo_full_name": "deeplearning4j/deeplearning4j",
    "discussion_comments": [
      {
        "comment_id": "299006736",
        "repo_full_name": "deeplearning4j/deeplearning4j",
        "pr_number": 7916,
        "pr_file": "docs/nd4j/templates/quickstart.md",
        "discussion_id": "299006736",
        "commented_code": "@@ -0,0 +1,565 @@\n+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+    * all major operating systems: win/linux/osx/android.\n+    * architectures: x86, arm, ppc.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You can use Nd4J from any [JVM Language](https://en.wikipedia.org/wiki/List_of_JVM_languages). (For example: Scala, Kotlin). You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+To improve readability we show you the output of `System.out.println(...)`.  But we have not show the print statement in the sample code. If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+import org.nd4j.linalg.factory.Nd4j;\n+import org.nd4j.linalg.api.buffer.DataType;\n+        \n+INDArray x = Nd4j.zeros(3,4);\n+\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.rank();\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+long length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.createFromArray` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`. The `Nd4j.createFromArray` function has overloads up to 4d for all types.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.createFromArray(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.createFromArray(arr_1d);\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDArray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(DataType.DOUBLE, 5);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5); //start, stop, count.\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]\n+\n+// Evaluate a function over many points.\n+import static org.nd4j.linalg.ops.transforms.Transforms.sin;\n+INDArray  x = Nd4j.linspace(0.0, Math.PI, 100, DataType.DOUBLE);\n+INDArray  y = sin(x);  \n+```\n+\n+### Printing Arrays\n+The INDArray supports Java's `toString()` method. The current implementation has limited precision and a limited number of elements.  The output is similar to printing NumPy arrays:\n+```java\n+INDArray  x = Nd4j.arange(6);  //1d array\n+System.out.println(x);  //We just give the output of the print command from here on.\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+int [] shape = {4,3};\n+x = Nd4j.arange(12).reshape(shape);   //2d array\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+int [] shape2 = {2,3,4};\n+x = Nd4j.arange(24).reshape(shape2);  //3d array\n+/*\n+[[[         0,    1.0000,    2.0000,    3.0000], \n+  [    4.0000,    5.0000,    6.0000,    7.0000], \n+  [    8.0000,    9.0000,   10.0000,   11.0000]], \n+\n+ [[   12.0000,   13.0000,   14.0000,   15.0000], \n+  [   16.0000,   17.0000,   18.0000,   19.0000], \n+  [   20.0000,   21.0000,   22.0000,   23.0000]]]\n+*/\n+```\n+\n+### Basic Operations\n+You will have to use INDArray methods to perform operations on your arrays. There are  in-place and copy overloads and scalar and element wise overloaded versions. The in-place operators return a reference to the array so you can conveniently chain operations together. Use in-place operators where possible to improve performance. Copy operators have new array creation overhead.\n+\n+```java\n+//Copy\n+arr_new = arr.add(scalar);    // return a new array with scalar added to each element of arr.\n+arr_new = arr.add(other_arr); // return a new array with element wise addition of arr and other_arr.\n+\n+//in place.\n+arr_new = arr.addi(scalar); //Heads up: arr_new points to the same array as arr.\n+arr_new = arr.addi(other_arr);\n+```\n+\n+addition: arr.add(...), arr.addi(...)\n+substraction: arr.sub(...), arr.subi(...)\n+multiplication: arr.mul(...), arr.muli(...)\n+division: arr.div(...), arr.divi(...)\n+\n+When you perform the basic operations you must make sure the underlying data types are the same.\n+```java\n+int [] shape = {5};\n+INDArray  x = Nd4j.zeros(shape, DataType.DOUBLE);\n+INDArray  x2 = Nd4j.zeros(shape, DataType.INT);\n+INDArray  x3 = x.add(x2);\n+// java.lang.IllegalArgumentException: Op.X and Op.Y must have the same data type, but got INT vs DOUBLE\n+\n+// casting x2 to DOUBLE solves the problem:\n+INDArray x3 = x.add(x2.castTo(DataType.DOUBLE));\n+```\n+<!--- Moving matrix operations after Transforms. In Nd4j the dot product is a transform. -->\n+\n+The INDArray has methods implementing reduction/accumulation operations such as `sum`, `min`, `max`.\n+```java\n+int [] shape = {2,3};\n+INDArray  x = Nd4j.rand(shape);\n+x;\n+x.sum();\n+x.min();\n+x.max();\n+/*\n+[[    0.8621,    0.9224,    0.8407], \n+ [    0.1504,    0.5489,    0.9584]]\n+4.2830\n+0.1504\n+0.9584\n+*/\n+```\n+\n+Provide a dimension argument to apply the operation across the specified dimension:\n+\n+```java\n+INDArray x = Nd4j.arange(12).reshape(3, 4);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/        \n+\n+x.sum(0); // Sum of each column.\n+//[   12.0000,   15.0000,   18.0000,   21.0000]\n+\n+x.min(1); // Min of each row\n+//[         0,    4.0000,    8.0000]\n+\n+x.cumsum(1); // cumulative sum across each row,\n+/*\n+[[         0,    1.0000,    3.0000,    6.0000], \n+ [    4.0000,    9.0000,   15.0000,   22.0000], \n+ [    8.0000,   17.0000,   27.0000,   38.0000]]\n+*/\n+\n+```\n+\n+<!--- The numpy quickstart calls them Universal Functions. -->\n+### Transform operation\n+Nd4j provides familiar mathematical functions such as sin, cos, and exp. These are called transform operations. The result is returned as an INDArray.\n+\n+```java\n+import static org.nd4j.linalg.ops.transforms.Transforms.exp;\n+import static org.nd4j.linalg.ops.transforms.Transforms.sqrt;\n+\n+INDArray x = Nd4j.arange(3);\n+// [         0,    1.0000,    2.0000]\n+exp(x);\n+// [    1.0000,    2.7183,    7.3891]\n+sqrt(x);\n+// [         0,    1.0000,    1.4142]\n+```\n+\n+You can check out a complete list of transform operations in the [Javadoc](https://deeplearning4j.org/api/latest/org/nd4j/linalg/api/ops/impl/transforms/package-summary.html )\n+\n+\n+### Matrix multiplication\n+We have already seen the element wise multiplcation in the basic operations. The other Matrix operations have their own methods:\n+\n+```java\n+INDArray x = Nd4j.arange(12).reshape(3, 4);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+INDArray y = Nd4j.arange(12).reshape(4, 3);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+x.mmul(y);  // matrix product.\n+/*\n+[[   42.0000,   48.0000,   54.0000], \n+ [  114.0000,  136.0000,  158.0000], \n+ [  186.0000,  224.0000,  262.0000]]\n+*/\n+\n+// dot product.\n+INDArray x = Nd4j.arange(12);\n+INDArray y = Nd4j.arange(12);\n+dot(x, y);  \n+//506.0000\n+```\n+\n+### Indexing, Slicing and Iterating\n+Indexing, Slicing and Iterating is harder in Java than in Python. \n+To retreive individual values from an INDArray you can use the `getDouble`, `getFloat` or `getInt` methods. INDArrays cannot be indexed like Java arrays. You can get a Java array from an INDArray using `toDoubleVector()`,  `toDoubleMatrix()`, `toFloatVector()` and `toFloatMatrix()` \n+\n+```java\n+\n+INDArray x = Nd4j.arange(12);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000,    6.0000,    7.0000,    8.0000,    9.0000,   10.0000,   11.0000]\n+\n+float f = x.getFloat(3);  // Single element access. Other methods: getDouble, getInt, ...\n+// 3.0\n+\n+float []  fArr = x.toFloatVector(); //Convert to Java array.\n+// [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0]\n+\n+INDArray x2 = x.get(NDArrayIndex.interval(2, 6));\n+// [    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+// On a copy of x: From start to position 6, exclusive, set every 2nd element to -1.0\n+INDArray y = x.dup();\n+y.get(NDArrayIndex.interval(0, 2, 6)).assign(-1.0);\n+//[   -1.0000,    1.0000,   -1.0000,    3.0000,   -1.0000,    5.0000,    6.0000,    7.0000,    8.0000,    9.0000,   10.0000,   11.0000]\n+\n+// reversed copy of y.\n+INDArray y2 = Nd4j.reverse(y.dup());\n+//[   11.0000,   10.0000,    9.0000,    8.0000,    7.0000,    6.0000,    5.0000,   -1.0000,    3.0000,   -1.0000,    1.0000,   -1.0000]\n+\n+```\n+\n+For multidimensional arrays you should use `INDArray.get(NDArrayIndex...)`. The example below shows how to iterate over the rows and columns of a 2D array. Note that for 2D arrays we could have used the `getColumn` and `getRow` convenience methods. \n+\n+```java\n+// Iterate over the rows and columns of a 2d arrray.\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+\n+INDArray x = Nd4j.rand(shape);\n+/*\n+[[    0.2228,    0.2871,    0.3880,    0.7167,    0.9951], \n+ [    0.7181,    0.8106,    0.9062,    0.9291,    0.5115], \n+ [    0.5483,    0.7515,    0.3623,    0.7797,    0.5887], \n+ [    0.6822,    0.7785,    0.4456,    0.4231,    0.9157]]\n+*/\n+        \n+for (int row=0; row<rows; row++) {\n+\tINDArray y = x.get(NDArrayIndex.point(row), NDArrayIndex.all());\n+\t}\n+/*\n+[    0.2228,    0.2871,    0.3880,    0.7167,    0.9951]\n+[    0.7181,    0.8106,    0.9062,    0.9291,    0.5115]\n+[    0.5483,    0.7515,    0.3623,    0.7797,    0.5887]\n+[    0.6822,    0.7785,    0.4456,    0.4231,    0.9157]\n+*/\n+\t\n+for (int col=0; col<cols; col++) {\n+\tINDArray y = x.get(NDArrayIndex.all(), NDArrayIndex.point(col));\n+\t}\n+/*\n+[    0.2228,    0.7181,    0.5483,    0.6822]\n+[    0.2871,    0.8106,    0.7515,    0.7785]\n+[    0.3880,    0.9062,    0.3623,    0.4456]\n+[    0.7167,    0.9291,    0.7797,    0.4231]\n+[    0.9951,    0.5115,    0.5887,    0.9157]\n+*/\n+\t\n+```\n+\n+## Shape Manipulation\n+### Changing the shape of an array\n+The number of elements along each axis is in the shape. The shape can be changed with various methods,.\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+x.shape();\n+// [3, 4]\n+\n+INDArray x2 = x.ravel();\n+x2.shape();\n+// [12]\n+\n+INDArray x3 = x.reshape(6,2).shape();\n+x3.shape();\n+//[6, 2]\n+\n+// Be aware that x, x2, and x3 share the same data. \n+x2.putScalar(5, -1.0);\n+\n+System.out.println( x);\n+/*\n+[[    0.0270,    0.3799,    0.5576,    0.3086], \n+ [    0.2266,   -1.0000,    0.1107,    0.4895], \n+ [    0.8431,    0.6011,    0.2996,    0.7500]]\n+*/\n+\n+System.out.println( x2);\n+// [    0.0270,    0.3799,    0.5576,    0.3086,    0.2266,   -1.0000,    0.1107,    0.4895,    0.8431,    0.6011,    0.2996,    0.7500]\n+\n+System.out.println( x3);\n+/*        \n+[[    0.0270,    0.3799], \n+ [    0.5576,    0.3086], \n+ [    0.2266,   -1.0000], \n+ [    0.1107,    0.4895], \n+ [    0.8431,    0.6011], \n+ [    0.2996,    0.7500]]\n+*/\n+```\n+\n+### Stacking together different arrays\n+Arrays can be stacked together using the `vstack` and `hstack` methods.\n+\n+```java\n+INDArray x = Nd4j.rand(2,2);\n+INDArray y = Nd4j.rand(2,2);\n+\n+x\n+/*\n+[[    0.1462,    0.5037], \n+ [    0.1418,    0.8645]]\n+*/\n+\n+y;\n+/*\n+[[    0.2305,    0.4798], \n+ [    0.9407,    0.9735]]\n+*/\n+ \n+Nd4j.vstack(x, y);\n+/*\n+[[    0.1462,    0.5037], \n+ [    0.1418,    0.8645], \n+ [    0.2305,    0.4798], \n+ [    0.9407,    0.9735]]\n+*/\n+\n+Nd4j.hstack(x, y);\n+/*\n+[[    0.1462,    0.5037,    0.2305,    0.4798], \n+ [    0.1418,    0.8645,    0.9407,    0.9735]]\n+*/\n+```\n+\n+<!--- No hsplit and vsplit functions in Nd4J. -->\n+<!--- ### Splitting one array into several smaller ones -->\n+\n+\n+## Copies and View\n+When working with INDArrays the data is not always copied. Here are three cases you should be aware of.\n+\n+### No Copy at All\n+Simple assignments make no copy of the data. Java passes objects by reference. No copies are made on a method call. \n+\n+```java\n+INDArray x = Nd4j.rand(2,2);\n+INDArray y = x; // y and x point to the same INData object.\n+\n+public static void f(INDArray x){\n+    // No copy is made. Any changes to x are visible after the function call.\n+    }\n+\n+```\n+\n+### View or Shallow Copy\n+Some functions will return a view of an array. \n+\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+INDArray  x2 = x.ravel();\n+INDArray  x3 = x.reshape(6,2);\n+\n+x2.putScalar(5, -1.0); // Changes x, x2 and x3\n+\n+x\n+/*\n+[[    0.8546,    0.1509,    0.0331,    0.1308], \n+ [    0.1753,   -1.0000,    0.2277,    0.1998], \n+ [    0.2741,    0.8257,    0.6946,    0.6851]]\n+*/\n+\n+x2\n+// [    0.8546,    0.1509,    0.0331,    0.1308,    0.1753,   -1.0000,    0.2277,    0.1998,    0.2741,    0.8257,    0.6946,    0.6851]\n+\n+x3\n+/*\n+[[    0.8546,    0.1509], \n+ [    0.0331,    0.1308], \n+ [    0.1753,   -1.0000], \n+ [    0.2277,    0.1998], \n+ [    0.2741,    0.8257], \n+ [    0.6946,    0.6851]]\n+*/\n+\n+```\n+\n+### Deep Copy\n+To make a copy of the array use the `dup` method. This will give you a new array with new data.\n+\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+INDArray  x2 = x.ravel().dup();\n+\n+x2.putScalar(5, -1.0); // Now only changes x2.\n+        \n+x\n+/*\n+[[    0.1604,    0.0322,    0.8910,    0.4604], \n+ [    0.7724,    0.1267,    0.1617,    0.7586], \n+ [    0.6117,    0.5385,    0.1251,    0.6886]]\n+*/\n+\n+x2\n+// [    0.1604,    0.0322,    0.8910,    0.4604,    0.7724,   -1.0000,    0.1617,    0.7586,    0.6117,    0.5385,    0.1251,    0.6886]\n+```\n+\n+## Functions and Methods Overview\n+\n+### Array Creation",
        "comment_created_at": "2019-07-01T11:53:39+00:00",
        "comment_author": "AlexDBlack",
        "comment_body": "Missing createFromArray, valueArrayOf, createUninitialized, scalar. Remove copy method (I didn't even realize it was a thing, users can just use assign).\r\n\r\nMaybe also consider splitting out into new subsections:\r\n- Random array creation (randn, randomBernoulli, randomBinomial, randomExponential, choice)\r\n- (De)Serialization (read, readNumpy, createFromNpy/Npz etc) + write methods\r\n\r\nAlso, generally, note that this is just a few of the ops. We have literally hundreds of ops, too many to list here... we don't want users to think that this list is it :)",
        "pr_file_module": null
      },
      {
        "comment_id": "299253967",
        "repo_full_name": "deeplearning4j/deeplearning4j",
        "pr_number": 7916,
        "pr_file": "docs/nd4j/templates/quickstart.md",
        "discussion_id": "299006736",
        "commented_code": "@@ -0,0 +1,565 @@\n+---\n+title: Quickstart\n+short_title: Quick start tutorial\n+description: ND4J Key features and brief samples.\n+category: ND4J\n+weight: 1\n+---\n+<!--- Comments are standard html. Tripple dash based on stackoverflow: https://stackoverflow.com/questions/4823468/comments-in-markdown -->\n+\n+<!--- Borrowing the layout of the Numpy quickstart to get started. -->\n+\n+## Introduction\n+<!--- What is ND4J and why is it important. From the nd4j repo readme.  -->\n+ND4J is a scientific computing library for the JVM. It is meant to be used in production environments rather than as a research tool, which means routines are designed to run fast with minimum RAM requirements. The main features are:\n+* A versatile n-dimensional array object.\n+* Linear algebra and signal processing functions.\n+* Multiplatform functionality including GPUs.\n+    * all major operating systems: win/linux/osx/android.\n+    * architectures: x86, arm, ppc.\n+\n+This quickstart follows the same layout and approach of the [Numpy quickstart](https://docs.scipy.org/doc/numpy/user/quickstart.html). This should help people familiar with Python and Numpy get started quickly with Nd4J.\n+\n+## Prerequisites\n+<!--- // Java, Maven, git. Coding skills and hello world example. -->\n+\n+To follow the examples in this quick start you will need to know some Java. You can use Nd4J from any [JVM Language](https://en.wikipedia.org/wiki/List_of_JVM_languages). (For example: Scala, Kotlin). You will also need to install the following software on your computer:\n+<!--- from the dl4j quickstart, pointing to the dl4j quiclstart for details. -->\n+* [Java (developer version)](./deeplearning4j-quickstart#Java) 1.7 or later (Only 64-Bit versions supported)\n+* [Apache Maven](./deeplearning4j-quickstart#Maven) (automated build and dependency manager)\n+<!--- git allows us to start with a cleaner project than mvn create. -->\n+* [Git](./deeplearning4j-quickstart#Git)(distributed version control system)\n+\n+To improve readability we show you the output of `System.out.println(...)`.  But we have not show the print statement in the sample code. If you are confident you know how to use maven and git, please feel free to skip to the [Basics](#Basics). In the remainder of this section we will build a small 'hello ND4J' application to verify the prequisites are set up correctly.\n+\n+Execute the following commands to get the project from github. \n+\n+<!--- TODO: Create HelloNd4J or Quickstart-nd4j repo in Deeplearning4J. -->\n+```shell\n+git clone https://github.com/RobAltena/HelloNd4J.git\n+\n+cd HelloNd4J\n+\n+mvn install\n+\n+mvn exec:java -Dexec.mainClass=\"HelloNd4j\"\n+```\n+\n+When everything is set up correctly you should see the following output:\n+\n+```shell\n+[         0,         0]\n+```\n+\n+## Basics\n+<!--- TODO: We will put some into this page. Start with refering to existing doc. -->\n+While this quickstart is being build, please refer to our existing \n+[basics usage](./nd4j-basics) document.\n+\n+The main feature of Nd4j is the versatile n-dimensional array interface called INDArray. To improve performance Nd4j uses off-heap memory to store data. The INDArray is different from standard Java arrays.\n+\n+Some of the key properties and methods for an INDArray x are as follows:\n+\n+```java\n+import org.nd4j.linalg.factory.Nd4j;\n+import org.nd4j.linalg.api.buffer.DataType;\n+        \n+INDArray x = Nd4j.zeros(3,4);\n+\n+// The number of axes (dimensions) of the array.\n+int dimensions = x.rank();\n+\n+// The dimensions of the array. The size in each dimension.\n+long[] shape = x.shape();\n+\n+// The total number of elements.\n+long length = x.length();\n+\n+// The type of the array elements. \n+DataType dt = x.dataType();\n+```\n+<!--- staying away from itemsize and data buffer. The numpy quickstart has these. -->\n+\n+### Array Creation\n+To create INDArrays you use the static factory methods of the [Nd4j](https://deeplearning4j.org/api/latest/org/nd4j/linalg/factory/Nd4j.html ) class.\n+\n+<!--- We have good docs on creating INDArrays already.  -->\n+<!--- https://deeplearning4j.org/docs/latest/nd4j-overview#creating -->\n+The `Nd4j.createFromArray` function is overloaded to make it easy to create INDArrays from regular Java arrays. The example below uses Java `double` arrays. Similar create methods are overloaded for `float`, `int` and `long`. The `Nd4j.createFromArray` function has overloads up to 4d for all types.\n+\n+```java\n+double arr_2d[][]={{1.0,2.0,3.0},{4.0,5.0,6.0},{7.0,8.0,9.0}};\n+INDArray x_2d = Nd4j.createFromArray(arr_2d);\n+\n+double arr_1d[]={1.0,2.0,3.0};\n+INDArray  x_1d = Nd4j.createFromArray(arr_1d);\n+```\n+\n+Nd4j can create arrays initialized with zeros and ones using the functions `zeros` and `ones`. The `rand` function allows you to create an array initialized with random values.\n+The default datatype of the INDArray created is `float`. Some overloads allow you to set the datatype.\n+\n+```java\n+INDArray  x = Nd4j.zeros(5);\n+//[         0,         0,         0,         0,         0], FLOAT\n+\n+int [] shape = {5};\n+x = Nd4j.zeros(DataType.DOUBLE, 5);\n+//[         0,         0,         0,         0,         0], DOUBLE\n+\n+// For higher dimensions you can provide a shape array. 2D random matrix example:\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+INDArray x = Nd4j.rand(shape);\n+```\n+\n+Use the `arange` functions to create an array of evenly spaces values:\n+\n+```java\n+INDArray  x = Nd4j.arange(5);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000]\n+\n+INDArray  x = Nd4j.arange(2, 7);\n+// [    2.0000,    3.0000,    4.0000,    5.0000,    6.0000]\n+```\n+\n+The `linspace` function allows you to specify the number of points generated:\n+```java\n+INDArray  x = Nd4j.linspace(1, 10, 5); //start, stop, count.\n+// [    1.0000,    3.2500,    5.5000,    7.7500,   10.0000]\n+\n+// Evaluate a function over many points.\n+import static org.nd4j.linalg.ops.transforms.Transforms.sin;\n+INDArray  x = Nd4j.linspace(0.0, Math.PI, 100, DataType.DOUBLE);\n+INDArray  y = sin(x);  \n+```\n+\n+### Printing Arrays\n+The INDArray supports Java's `toString()` method. The current implementation has limited precision and a limited number of elements.  The output is similar to printing NumPy arrays:\n+```java\n+INDArray  x = Nd4j.arange(6);  //1d array\n+System.out.println(x);  //We just give the output of the print command from here on.\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+int [] shape = {4,3};\n+x = Nd4j.arange(12).reshape(shape);   //2d array\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+int [] shape2 = {2,3,4};\n+x = Nd4j.arange(24).reshape(shape2);  //3d array\n+/*\n+[[[         0,    1.0000,    2.0000,    3.0000], \n+  [    4.0000,    5.0000,    6.0000,    7.0000], \n+  [    8.0000,    9.0000,   10.0000,   11.0000]], \n+\n+ [[   12.0000,   13.0000,   14.0000,   15.0000], \n+  [   16.0000,   17.0000,   18.0000,   19.0000], \n+  [   20.0000,   21.0000,   22.0000,   23.0000]]]\n+*/\n+```\n+\n+### Basic Operations\n+You will have to use INDArray methods to perform operations on your arrays. There are  in-place and copy overloads and scalar and element wise overloaded versions. The in-place operators return a reference to the array so you can conveniently chain operations together. Use in-place operators where possible to improve performance. Copy operators have new array creation overhead.\n+\n+```java\n+//Copy\n+arr_new = arr.add(scalar);    // return a new array with scalar added to each element of arr.\n+arr_new = arr.add(other_arr); // return a new array with element wise addition of arr and other_arr.\n+\n+//in place.\n+arr_new = arr.addi(scalar); //Heads up: arr_new points to the same array as arr.\n+arr_new = arr.addi(other_arr);\n+```\n+\n+addition: arr.add(...), arr.addi(...)\n+substraction: arr.sub(...), arr.subi(...)\n+multiplication: arr.mul(...), arr.muli(...)\n+division: arr.div(...), arr.divi(...)\n+\n+When you perform the basic operations you must make sure the underlying data types are the same.\n+```java\n+int [] shape = {5};\n+INDArray  x = Nd4j.zeros(shape, DataType.DOUBLE);\n+INDArray  x2 = Nd4j.zeros(shape, DataType.INT);\n+INDArray  x3 = x.add(x2);\n+// java.lang.IllegalArgumentException: Op.X and Op.Y must have the same data type, but got INT vs DOUBLE\n+\n+// casting x2 to DOUBLE solves the problem:\n+INDArray x3 = x.add(x2.castTo(DataType.DOUBLE));\n+```\n+<!--- Moving matrix operations after Transforms. In Nd4j the dot product is a transform. -->\n+\n+The INDArray has methods implementing reduction/accumulation operations such as `sum`, `min`, `max`.\n+```java\n+int [] shape = {2,3};\n+INDArray  x = Nd4j.rand(shape);\n+x;\n+x.sum();\n+x.min();\n+x.max();\n+/*\n+[[    0.8621,    0.9224,    0.8407], \n+ [    0.1504,    0.5489,    0.9584]]\n+4.2830\n+0.1504\n+0.9584\n+*/\n+```\n+\n+Provide a dimension argument to apply the operation across the specified dimension:\n+\n+```java\n+INDArray x = Nd4j.arange(12).reshape(3, 4);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/        \n+\n+x.sum(0); // Sum of each column.\n+//[   12.0000,   15.0000,   18.0000,   21.0000]\n+\n+x.min(1); // Min of each row\n+//[         0,    4.0000,    8.0000]\n+\n+x.cumsum(1); // cumulative sum across each row,\n+/*\n+[[         0,    1.0000,    3.0000,    6.0000], \n+ [    4.0000,    9.0000,   15.0000,   22.0000], \n+ [    8.0000,   17.0000,   27.0000,   38.0000]]\n+*/\n+\n+```\n+\n+<!--- The numpy quickstart calls them Universal Functions. -->\n+### Transform operation\n+Nd4j provides familiar mathematical functions such as sin, cos, and exp. These are called transform operations. The result is returned as an INDArray.\n+\n+```java\n+import static org.nd4j.linalg.ops.transforms.Transforms.exp;\n+import static org.nd4j.linalg.ops.transforms.Transforms.sqrt;\n+\n+INDArray x = Nd4j.arange(3);\n+// [         0,    1.0000,    2.0000]\n+exp(x);\n+// [    1.0000,    2.7183,    7.3891]\n+sqrt(x);\n+// [         0,    1.0000,    1.4142]\n+```\n+\n+You can check out a complete list of transform operations in the [Javadoc](https://deeplearning4j.org/api/latest/org/nd4j/linalg/api/ops/impl/transforms/package-summary.html )\n+\n+\n+### Matrix multiplication\n+We have already seen the element wise multiplcation in the basic operations. The other Matrix operations have their own methods:\n+\n+```java\n+INDArray x = Nd4j.arange(12).reshape(3, 4);\n+/*\n+[[         0,    1.0000,    2.0000,    3.0000], \n+ [    4.0000,    5.0000,    6.0000,    7.0000], \n+ [    8.0000,    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+INDArray y = Nd4j.arange(12).reshape(4, 3);\n+/*\n+[[         0,    1.0000,    2.0000], \n+ [    3.0000,    4.0000,    5.0000], \n+ [    6.0000,    7.0000,    8.0000], \n+ [    9.0000,   10.0000,   11.0000]]\n+*/\n+\n+x.mmul(y);  // matrix product.\n+/*\n+[[   42.0000,   48.0000,   54.0000], \n+ [  114.0000,  136.0000,  158.0000], \n+ [  186.0000,  224.0000,  262.0000]]\n+*/\n+\n+// dot product.\n+INDArray x = Nd4j.arange(12);\n+INDArray y = Nd4j.arange(12);\n+dot(x, y);  \n+//506.0000\n+```\n+\n+### Indexing, Slicing and Iterating\n+Indexing, Slicing and Iterating is harder in Java than in Python. \n+To retreive individual values from an INDArray you can use the `getDouble`, `getFloat` or `getInt` methods. INDArrays cannot be indexed like Java arrays. You can get a Java array from an INDArray using `toDoubleVector()`,  `toDoubleMatrix()`, `toFloatVector()` and `toFloatMatrix()` \n+\n+```java\n+\n+INDArray x = Nd4j.arange(12);\n+// [         0,    1.0000,    2.0000,    3.0000,    4.0000,    5.0000,    6.0000,    7.0000,    8.0000,    9.0000,   10.0000,   11.0000]\n+\n+float f = x.getFloat(3);  // Single element access. Other methods: getDouble, getInt, ...\n+// 3.0\n+\n+float []  fArr = x.toFloatVector(); //Convert to Java array.\n+// [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0]\n+\n+INDArray x2 = x.get(NDArrayIndex.interval(2, 6));\n+// [    2.0000,    3.0000,    4.0000,    5.0000]\n+\n+// On a copy of x: From start to position 6, exclusive, set every 2nd element to -1.0\n+INDArray y = x.dup();\n+y.get(NDArrayIndex.interval(0, 2, 6)).assign(-1.0);\n+//[   -1.0000,    1.0000,   -1.0000,    3.0000,   -1.0000,    5.0000,    6.0000,    7.0000,    8.0000,    9.0000,   10.0000,   11.0000]\n+\n+// reversed copy of y.\n+INDArray y2 = Nd4j.reverse(y.dup());\n+//[   11.0000,   10.0000,    9.0000,    8.0000,    7.0000,    6.0000,    5.0000,   -1.0000,    3.0000,   -1.0000,    1.0000,   -1.0000]\n+\n+```\n+\n+For multidimensional arrays you should use `INDArray.get(NDArrayIndex...)`. The example below shows how to iterate over the rows and columns of a 2D array. Note that for 2D arrays we could have used the `getColumn` and `getRow` convenience methods. \n+\n+```java\n+// Iterate over the rows and columns of a 2d arrray.\n+int rows = 4;\n+int cols = 5;\n+int[] shape = {rows, cols};\n+\n+INDArray x = Nd4j.rand(shape);\n+/*\n+[[    0.2228,    0.2871,    0.3880,    0.7167,    0.9951], \n+ [    0.7181,    0.8106,    0.9062,    0.9291,    0.5115], \n+ [    0.5483,    0.7515,    0.3623,    0.7797,    0.5887], \n+ [    0.6822,    0.7785,    0.4456,    0.4231,    0.9157]]\n+*/\n+        \n+for (int row=0; row<rows; row++) {\n+\tINDArray y = x.get(NDArrayIndex.point(row), NDArrayIndex.all());\n+\t}\n+/*\n+[    0.2228,    0.2871,    0.3880,    0.7167,    0.9951]\n+[    0.7181,    0.8106,    0.9062,    0.9291,    0.5115]\n+[    0.5483,    0.7515,    0.3623,    0.7797,    0.5887]\n+[    0.6822,    0.7785,    0.4456,    0.4231,    0.9157]\n+*/\n+\t\n+for (int col=0; col<cols; col++) {\n+\tINDArray y = x.get(NDArrayIndex.all(), NDArrayIndex.point(col));\n+\t}\n+/*\n+[    0.2228,    0.7181,    0.5483,    0.6822]\n+[    0.2871,    0.8106,    0.7515,    0.7785]\n+[    0.3880,    0.9062,    0.3623,    0.4456]\n+[    0.7167,    0.9291,    0.7797,    0.4231]\n+[    0.9951,    0.5115,    0.5887,    0.9157]\n+*/\n+\t\n+```\n+\n+## Shape Manipulation\n+### Changing the shape of an array\n+The number of elements along each axis is in the shape. The shape can be changed with various methods,.\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+x.shape();\n+// [3, 4]\n+\n+INDArray x2 = x.ravel();\n+x2.shape();\n+// [12]\n+\n+INDArray x3 = x.reshape(6,2).shape();\n+x3.shape();\n+//[6, 2]\n+\n+// Be aware that x, x2, and x3 share the same data. \n+x2.putScalar(5, -1.0);\n+\n+System.out.println( x);\n+/*\n+[[    0.0270,    0.3799,    0.5576,    0.3086], \n+ [    0.2266,   -1.0000,    0.1107,    0.4895], \n+ [    0.8431,    0.6011,    0.2996,    0.7500]]\n+*/\n+\n+System.out.println( x2);\n+// [    0.0270,    0.3799,    0.5576,    0.3086,    0.2266,   -1.0000,    0.1107,    0.4895,    0.8431,    0.6011,    0.2996,    0.7500]\n+\n+System.out.println( x3);\n+/*        \n+[[    0.0270,    0.3799], \n+ [    0.5576,    0.3086], \n+ [    0.2266,   -1.0000], \n+ [    0.1107,    0.4895], \n+ [    0.8431,    0.6011], \n+ [    0.2996,    0.7500]]\n+*/\n+```\n+\n+### Stacking together different arrays\n+Arrays can be stacked together using the `vstack` and `hstack` methods.\n+\n+```java\n+INDArray x = Nd4j.rand(2,2);\n+INDArray y = Nd4j.rand(2,2);\n+\n+x\n+/*\n+[[    0.1462,    0.5037], \n+ [    0.1418,    0.8645]]\n+*/\n+\n+y;\n+/*\n+[[    0.2305,    0.4798], \n+ [    0.9407,    0.9735]]\n+*/\n+ \n+Nd4j.vstack(x, y);\n+/*\n+[[    0.1462,    0.5037], \n+ [    0.1418,    0.8645], \n+ [    0.2305,    0.4798], \n+ [    0.9407,    0.9735]]\n+*/\n+\n+Nd4j.hstack(x, y);\n+/*\n+[[    0.1462,    0.5037,    0.2305,    0.4798], \n+ [    0.1418,    0.8645,    0.9407,    0.9735]]\n+*/\n+```\n+\n+<!--- No hsplit and vsplit functions in Nd4J. -->\n+<!--- ### Splitting one array into several smaller ones -->\n+\n+\n+## Copies and View\n+When working with INDArrays the data is not always copied. Here are three cases you should be aware of.\n+\n+### No Copy at All\n+Simple assignments make no copy of the data. Java passes objects by reference. No copies are made on a method call. \n+\n+```java\n+INDArray x = Nd4j.rand(2,2);\n+INDArray y = x; // y and x point to the same INData object.\n+\n+public static void f(INDArray x){\n+    // No copy is made. Any changes to x are visible after the function call.\n+    }\n+\n+```\n+\n+### View or Shallow Copy\n+Some functions will return a view of an array. \n+\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+INDArray  x2 = x.ravel();\n+INDArray  x3 = x.reshape(6,2);\n+\n+x2.putScalar(5, -1.0); // Changes x, x2 and x3\n+\n+x\n+/*\n+[[    0.8546,    0.1509,    0.0331,    0.1308], \n+ [    0.1753,   -1.0000,    0.2277,    0.1998], \n+ [    0.2741,    0.8257,    0.6946,    0.6851]]\n+*/\n+\n+x2\n+// [    0.8546,    0.1509,    0.0331,    0.1308,    0.1753,   -1.0000,    0.2277,    0.1998,    0.2741,    0.8257,    0.6946,    0.6851]\n+\n+x3\n+/*\n+[[    0.8546,    0.1509], \n+ [    0.0331,    0.1308], \n+ [    0.1753,   -1.0000], \n+ [    0.2277,    0.1998], \n+ [    0.2741,    0.8257], \n+ [    0.6946,    0.6851]]\n+*/\n+\n+```\n+\n+### Deep Copy\n+To make a copy of the array use the `dup` method. This will give you a new array with new data.\n+\n+```java\n+INDArray x = Nd4j.rand(3,4);\n+INDArray  x2 = x.ravel().dup();\n+\n+x2.putScalar(5, -1.0); // Now only changes x2.\n+        \n+x\n+/*\n+[[    0.1604,    0.0322,    0.8910,    0.4604], \n+ [    0.7724,    0.1267,    0.1617,    0.7586], \n+ [    0.6117,    0.5385,    0.1251,    0.6886]]\n+*/\n+\n+x2\n+// [    0.1604,    0.0322,    0.8910,    0.4604,    0.7724,   -1.0000,    0.1617,    0.7586,    0.6117,    0.5385,    0.1251,    0.6886]\n+```\n+\n+## Functions and Methods Overview\n+\n+### Array Creation",
        "comment_created_at": "2019-07-01T23:31:05+00:00",
        "comment_author": "RobAltena",
        "comment_body": "Yes, we can (and should) go deeper here. What I have so far is loop over the links in the Numpy quick start. I have removed functions that Nd4j did not have (Or rather: I could not find quickly). ",
        "pr_file_module": null
      }
    ]
  }
]