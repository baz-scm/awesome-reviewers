[
  {
    "discussion_id": "2067243000",
    "pr_number": 28424,
    "pr_file": "cli/args/flags.rs",
    "created_at": "2025-04-29T19:44:07+00:00",
    "commented_code": "Ok(())\n }\n \n-fn clean_parse(flags: &mut Flags, _matches: &mut ArgMatches) {\n-  flags.subcommand = DenoSubcommand::Clean;\n+fn clean_parse(flags: &mut Flags, matches: &mut ArgMatches) {",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2067243000",
        "repo_full_name": "denoland/deno",
        "pr_number": 28424,
        "pr_file": "cli/args/flags.rs",
        "discussion_id": "2067243000",
        "commented_code": "@@ -4658,8 +4689,21 @@ fn check_parse(\n   Ok(())\n }\n \n-fn clean_parse(flags: &mut Flags, _matches: &mut ArgMatches) {\n-  flags.subcommand = DenoSubcommand::Clean;\n+fn clean_parse(flags: &mut Flags, matches: &mut ArgMatches) {",
        "comment_created_at": "2025-04-29T19:44:07+00:00",
        "comment_author": "dsherret",
        "comment_body": "In this file there are unit tests for flag parsing. Maybe we should add some for the clean command now?",
        "pr_file_module": null
      },
      {
        "comment_id": "2067376095",
        "repo_full_name": "denoland/deno",
        "pr_number": 28424,
        "pr_file": "cli/args/flags.rs",
        "discussion_id": "2067243000",
        "commented_code": "@@ -4658,8 +4689,21 @@ fn check_parse(\n   Ok(())\n }\n \n-fn clean_parse(flags: &mut Flags, _matches: &mut ArgMatches) {\n-  flags.subcommand = DenoSubcommand::Clean;\n+fn clean_parse(flags: &mut Flags, matches: &mut ArgMatches) {",
        "comment_created_at": "2025-04-29T20:30:17+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Agreed, especially that the parsing is a bit quirky",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1842476276",
    "pr_number": 26590,
    "pr_file": "cli/tools/coverage/ignore_directives.rs",
    "created_at": "2024-11-14T15:59:08+00:00",
    "commented_code": "+// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n+\n+use deno_ast::swc::common::comments::Comment;\n+use deno_ast::swc::common::comments::CommentKind;\n+use deno_ast::view as ast_view;\n+use deno_ast::RootNode as _;\n+use deno_ast::SourceRange;\n+use deno_ast::SourceRanged;\n+use deno_ast::SourceRangedForSpanned as _;\n+use deno_ast::SourceTextInfoProvider as _;\n+use deno_core::url::Url;\n+use std::collections::HashMap;\n+\n+static COVERAGE_IGNORE_START_DIRECTIVE: &str = \"deno-coverage-ignore-start\";\n+static COVERAGE_IGNORE_STOP_DIRECTIVE: &str = \"deno-coverage-ignore-stop\";\n+static COVERAGE_IGNORE_NEXT_DIRECTIVE: &str = \"deno-coverage-ignore-next\";\n+static COVERAGE_IGNORE_FILE_DIRECTIVE: &str = \"deno-coverage-ignore-file\";\n+\n+pub type RangeIgnoreDirective = IgnoreDirective<Range>;\n+pub type NextIgnoreDirective = IgnoreDirective<Next>;\n+pub type FileIgnoreDirective = IgnoreDirective<File>;\n+\n+pub enum Range {}\n+pub enum Next {}\n+pub enum File {}\n+pub trait DirectiveKind {}\n+impl DirectiveKind for Range {}\n+impl DirectiveKind for Next {}\n+impl DirectiveKind for File {}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct IgnoreDirective<T: DirectiveKind> {\n+  range: SourceRange,\n+  _marker: std::marker::PhantomData<T>,\n+}\n+\n+impl<T: DirectiveKind> IgnoreDirective<T> {\n+  pub fn range(&self) -> SourceRange {\n+    self.range\n+  }\n+}\n+\n+pub fn parse_range_ignore_directives(\n+  is_quiet: bool,\n+  script_module_specifier: &Url,\n+  program: &ast_view::Program,\n+) -> Vec<RangeIgnoreDirective> {\n+  let mut depth: usize = 0;\n+  let mut directives = Vec::<RangeIgnoreDirective>::new();\n+  let mut current_range: Option<SourceRange> = None;\n+\n+  let mut comments_sorted = program\n+    .comment_container()\n+    .all_comments()\n+    .collect::<Vec<_>>();\n+  comments_sorted.sort_by(|a, b| a.range().start.cmp(&b.range().start));\n+\n+  for comment in comments_sorted.iter() {\n+    if comment.kind != CommentKind::Line {\n+      continue;\n+    }\n+\n+    let comment_text = comment.text.trim();\n+\n+    if let Some(prefix) = comment_text.split_whitespace().next() {\n+      if prefix == COVERAGE_IGNORE_START_DIRECTIVE {\n+        depth += 1;\n+        if current_range.is_none() {\n+          current_range = Some(comment.range());\n+        }\n+      } else if depth > 0 && prefix == COVERAGE_IGNORE_STOP_DIRECTIVE {\n+        depth -= 1;\n+        if depth == 0 {\n+          let mut range = current_range.take().unwrap();\n+          range.end = comment.range().end;\n+          directives.push(IgnoreDirective {\n+            range,\n+            _marker: std::marker::PhantomData,\n+          });\n+          current_range = None;\n+        }\n+      }\n+    }\n+  }\n+\n+  // If the coverage ignore start directive has no corresponding close directive\n+  // then close it at the end of the program.\n+  if let Some(mut range) = current_range.take() {\n+    if !is_quiet {\n+      let text_info = program.text_info();\n+      let loc = text_info.line_and_column_display(range.start);\n+      log::warn!(\n+        \"WARNING: Unterminated {} comment at {}:{}:{}\",\n+        COVERAGE_IGNORE_START_DIRECTIVE,\n+        script_module_specifier,\n+        loc.line_number,\n+        loc.column_number,\n+      );\n+    }\n+    range.end = program.range().end;\n+    directives.push(IgnoreDirective {\n+      range,\n+      _marker: std::marker::PhantomData,\n+    });\n+  }\n+\n+  directives\n+}\n+\n+pub fn parse_next_ignore_directives(\n+  program: &ast_view::Program,\n+) -> HashMap<usize, NextIgnoreDirective> {\n+  program\n+    .comment_container()\n+    .all_comments()\n+    .filter_map(|comment| {\n+      parse_ignore_comment(COVERAGE_IGNORE_NEXT_DIRECTIVE, comment).map(\n+        |directive| {\n+          (\n+            program.text_info().line_index(directive.range().start),\n+            directive,\n+          )\n+        },\n+      )\n+    })\n+    .collect()\n+}\n+\n+pub fn parse_file_ignore_directives(\n+  program: &ast_view::Program,\n+) -> Option<FileIgnoreDirective> {\n+  // We want to get a file's leading comments, even if they come after a\n+  // shebang. There are three cases:\n+  // 1. No shebang. The file's leading comments are the program's leading\n+  //    comments.\n+  // 2. Shebang, and the program has statements or declarations. The file's\n+  //    leading comments are really the first statment/declaration's leading\n+  //    comments.\n+  // 3. Shebang, and the program is empty. The file's leading comments are the\n+  //    program's trailing comments.\n+  let (has_shebang, first_item_range) = match program {\n+    ast_view::Program::Module(module) => (\n+      module.shebang().is_some(),\n+      module.body.first().map(SourceRanged::range),\n+    ),\n+    ast_view::Program::Script(script) => (\n+      script.shebang().is_some(),\n+      script.body.first().map(SourceRanged::range),\n+    ),\n+  };\n+\n+  let comments = program.comment_container();\n+  let mut initial_comments = match (has_shebang, first_item_range) {\n+    (false, _) => comments.leading_comments(program.start()),\n+    (true, Some(range)) => comments.leading_comments(range.start),\n+    (true, None) => comments.trailing_comments(program.end()),\n+  };\n+  initial_comments.find_map(|comment| {\n+    parse_ignore_comment(COVERAGE_IGNORE_FILE_DIRECTIVE, comment)\n+  })\n+}\n+\n+fn parse_ignore_comment<T: DirectiveKind>(\n+  ignore_diagnostic_directive: &str,\n+  comment: &Comment,\n+) -> Option<IgnoreDirective<T>> {\n+  if comment.kind != CommentKind::Line {\n+    return None;\n+  }\n+\n+  let comment_text = comment.text.trim();\n+\n+  if let Some(prefix) = comment_text.split_whitespace().next() {\n+    if prefix == ignore_diagnostic_directive {\n+      return Some(IgnoreDirective::<T> {\n+        range: comment.range(),\n+        _marker: std::marker::PhantomData,\n+      });\n+    }\n+  }\n+\n+  None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+  use std::str::FromStr;\n+\n+  use deno_ast::MediaType;\n+  use deno_ast::ModuleSpecifier;\n+  use deno_ast::ParsedSource;\n+\n+  use crate::tools::coverage::ast_parser;\n+\n+  use super::*;\n+\n+  const TEST_FILE_NAME: &str = \"file:///coverage_test.ts\";\n+\n+  pub fn parse(source_code: &str) -> ParsedSource {\n+    ast_parser::parse_program(\n+      ModuleSpecifier::parse(TEST_FILE_NAME).unwrap(),\n+      MediaType::TypeScript,\n+      source_code,\n+    )\n+    .unwrap()\n+  }\n+\n+  pub fn parse_and_then(source_code: &str, test: impl Fn(ast_view::Program)) {\n+    let parsed_source = parse(source_code);\n+    parsed_source.with_view(|pg| {\n+      test(pg);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_range_ignore_comments() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-start\n+        function foo(): any {}\n+        // deno-coverage-ignore-stop\n+\n+        function bar(): any {\n+          // deno-coverage-ignore-start\n+          foo();\n+          // deno-coverage-ignore-stop\n+        }\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_range_ignore_directives(\n+        true,\n+        &Url::from_str(TEST_FILE_NAME).unwrap(),\n+        &program,\n+      );\n+\n+      assert_eq!(line_directives.len(), 2);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_range_ignore_comments_unterminated() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-start\n+        function foo(): any {}\n+\n+        function bar(): any {\n+          foo();\n+        }\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_range_ignore_directives(\n+        true,\n+        &Url::from_str(TEST_FILE_NAME).unwrap(),\n+        &program,\n+      );\n+\n+      assert_eq!(line_directives.len(), 1);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_range_ignore_comments_nested() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-start\n+        function foo(): any {}\n+\n+        function bar(): any {\n+          // deno-coverage-ignore-start\n+          foo();\n+          // deno-coverage-ignore-stop\n+        }\n+        // deno-coverage-ignore-stop\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_range_ignore_directives(\n+        true,\n+        &Url::from_str(TEST_FILE_NAME).unwrap(),\n+        &program,\n+      );\n+\n+      assert_eq!(line_directives.len(), 1);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_next_ignore_comments() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-next\n+        function foo(): any {}\n+\n+        function bar(): any {\n+          // deno-coverage-ignore-next\n+          foo();\n+        }\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_next_ignore_directives(&program);\n+\n+      assert_eq!(line_directives.len(), 2);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_global_ignore_directives() {\n+    parse_and_then(\"// deno-coverage-ignore-file\", |program| {\n+      let file_directive = parse_file_ignore_directives(&program);\n+\n+      assert!(file_directive.is_some());\n+    });\n+\n+    parse_and_then(\n+      \"// deno-coverage-ignore-file -- reason for ignoring\",\n+      |program| {\n+        let file_directive = parse_file_ignore_directives(&program);\n+\n+        assert!(file_directive.is_some());\n+      },\n+    );\n+\n+    parse_and_then(\n+      \"// deno-coverage-ignore-file foo -- reason for ignoring\",",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1842476276",
        "repo_full_name": "denoland/deno",
        "pr_number": 26590,
        "pr_file": "cli/tools/coverage/ignore_directives.rs",
        "discussion_id": "1842476276",
        "commented_code": "@@ -0,0 +1,381 @@\n+// Copyright 2018-2024 the Deno authors. All rights reserved. MIT license.\n+\n+use deno_ast::swc::common::comments::Comment;\n+use deno_ast::swc::common::comments::CommentKind;\n+use deno_ast::view as ast_view;\n+use deno_ast::RootNode as _;\n+use deno_ast::SourceRange;\n+use deno_ast::SourceRanged;\n+use deno_ast::SourceRangedForSpanned as _;\n+use deno_ast::SourceTextInfoProvider as _;\n+use deno_core::url::Url;\n+use std::collections::HashMap;\n+\n+static COVERAGE_IGNORE_START_DIRECTIVE: &str = \"deno-coverage-ignore-start\";\n+static COVERAGE_IGNORE_STOP_DIRECTIVE: &str = \"deno-coverage-ignore-stop\";\n+static COVERAGE_IGNORE_NEXT_DIRECTIVE: &str = \"deno-coverage-ignore-next\";\n+static COVERAGE_IGNORE_FILE_DIRECTIVE: &str = \"deno-coverage-ignore-file\";\n+\n+pub type RangeIgnoreDirective = IgnoreDirective<Range>;\n+pub type NextIgnoreDirective = IgnoreDirective<Next>;\n+pub type FileIgnoreDirective = IgnoreDirective<File>;\n+\n+pub enum Range {}\n+pub enum Next {}\n+pub enum File {}\n+pub trait DirectiveKind {}\n+impl DirectiveKind for Range {}\n+impl DirectiveKind for Next {}\n+impl DirectiveKind for File {}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct IgnoreDirective<T: DirectiveKind> {\n+  range: SourceRange,\n+  _marker: std::marker::PhantomData<T>,\n+}\n+\n+impl<T: DirectiveKind> IgnoreDirective<T> {\n+  pub fn range(&self) -> SourceRange {\n+    self.range\n+  }\n+}\n+\n+pub fn parse_range_ignore_directives(\n+  is_quiet: bool,\n+  script_module_specifier: &Url,\n+  program: &ast_view::Program,\n+) -> Vec<RangeIgnoreDirective> {\n+  let mut depth: usize = 0;\n+  let mut directives = Vec::<RangeIgnoreDirective>::new();\n+  let mut current_range: Option<SourceRange> = None;\n+\n+  let mut comments_sorted = program\n+    .comment_container()\n+    .all_comments()\n+    .collect::<Vec<_>>();\n+  comments_sorted.sort_by(|a, b| a.range().start.cmp(&b.range().start));\n+\n+  for comment in comments_sorted.iter() {\n+    if comment.kind != CommentKind::Line {\n+      continue;\n+    }\n+\n+    let comment_text = comment.text.trim();\n+\n+    if let Some(prefix) = comment_text.split_whitespace().next() {\n+      if prefix == COVERAGE_IGNORE_START_DIRECTIVE {\n+        depth += 1;\n+        if current_range.is_none() {\n+          current_range = Some(comment.range());\n+        }\n+      } else if depth > 0 && prefix == COVERAGE_IGNORE_STOP_DIRECTIVE {\n+        depth -= 1;\n+        if depth == 0 {\n+          let mut range = current_range.take().unwrap();\n+          range.end = comment.range().end;\n+          directives.push(IgnoreDirective {\n+            range,\n+            _marker: std::marker::PhantomData,\n+          });\n+          current_range = None;\n+        }\n+      }\n+    }\n+  }\n+\n+  // If the coverage ignore start directive has no corresponding close directive\n+  // then close it at the end of the program.\n+  if let Some(mut range) = current_range.take() {\n+    if !is_quiet {\n+      let text_info = program.text_info();\n+      let loc = text_info.line_and_column_display(range.start);\n+      log::warn!(\n+        \"WARNING: Unterminated {} comment at {}:{}:{}\",\n+        COVERAGE_IGNORE_START_DIRECTIVE,\n+        script_module_specifier,\n+        loc.line_number,\n+        loc.column_number,\n+      );\n+    }\n+    range.end = program.range().end;\n+    directives.push(IgnoreDirective {\n+      range,\n+      _marker: std::marker::PhantomData,\n+    });\n+  }\n+\n+  directives\n+}\n+\n+pub fn parse_next_ignore_directives(\n+  program: &ast_view::Program,\n+) -> HashMap<usize, NextIgnoreDirective> {\n+  program\n+    .comment_container()\n+    .all_comments()\n+    .filter_map(|comment| {\n+      parse_ignore_comment(COVERAGE_IGNORE_NEXT_DIRECTIVE, comment).map(\n+        |directive| {\n+          (\n+            program.text_info().line_index(directive.range().start),\n+            directive,\n+          )\n+        },\n+      )\n+    })\n+    .collect()\n+}\n+\n+pub fn parse_file_ignore_directives(\n+  program: &ast_view::Program,\n+) -> Option<FileIgnoreDirective> {\n+  // We want to get a file's leading comments, even if they come after a\n+  // shebang. There are three cases:\n+  // 1. No shebang. The file's leading comments are the program's leading\n+  //    comments.\n+  // 2. Shebang, and the program has statements or declarations. The file's\n+  //    leading comments are really the first statment/declaration's leading\n+  //    comments.\n+  // 3. Shebang, and the program is empty. The file's leading comments are the\n+  //    program's trailing comments.\n+  let (has_shebang, first_item_range) = match program {\n+    ast_view::Program::Module(module) => (\n+      module.shebang().is_some(),\n+      module.body.first().map(SourceRanged::range),\n+    ),\n+    ast_view::Program::Script(script) => (\n+      script.shebang().is_some(),\n+      script.body.first().map(SourceRanged::range),\n+    ),\n+  };\n+\n+  let comments = program.comment_container();\n+  let mut initial_comments = match (has_shebang, first_item_range) {\n+    (false, _) => comments.leading_comments(program.start()),\n+    (true, Some(range)) => comments.leading_comments(range.start),\n+    (true, None) => comments.trailing_comments(program.end()),\n+  };\n+  initial_comments.find_map(|comment| {\n+    parse_ignore_comment(COVERAGE_IGNORE_FILE_DIRECTIVE, comment)\n+  })\n+}\n+\n+fn parse_ignore_comment<T: DirectiveKind>(\n+  ignore_diagnostic_directive: &str,\n+  comment: &Comment,\n+) -> Option<IgnoreDirective<T>> {\n+  if comment.kind != CommentKind::Line {\n+    return None;\n+  }\n+\n+  let comment_text = comment.text.trim();\n+\n+  if let Some(prefix) = comment_text.split_whitespace().next() {\n+    if prefix == ignore_diagnostic_directive {\n+      return Some(IgnoreDirective::<T> {\n+        range: comment.range(),\n+        _marker: std::marker::PhantomData,\n+      });\n+    }\n+  }\n+\n+  None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+  use std::str::FromStr;\n+\n+  use deno_ast::MediaType;\n+  use deno_ast::ModuleSpecifier;\n+  use deno_ast::ParsedSource;\n+\n+  use crate::tools::coverage::ast_parser;\n+\n+  use super::*;\n+\n+  const TEST_FILE_NAME: &str = \"file:///coverage_test.ts\";\n+\n+  pub fn parse(source_code: &str) -> ParsedSource {\n+    ast_parser::parse_program(\n+      ModuleSpecifier::parse(TEST_FILE_NAME).unwrap(),\n+      MediaType::TypeScript,\n+      source_code,\n+    )\n+    .unwrap()\n+  }\n+\n+  pub fn parse_and_then(source_code: &str, test: impl Fn(ast_view::Program)) {\n+    let parsed_source = parse(source_code);\n+    parsed_source.with_view(|pg| {\n+      test(pg);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_range_ignore_comments() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-start\n+        function foo(): any {}\n+        // deno-coverage-ignore-stop\n+\n+        function bar(): any {\n+          // deno-coverage-ignore-start\n+          foo();\n+          // deno-coverage-ignore-stop\n+        }\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_range_ignore_directives(\n+        true,\n+        &Url::from_str(TEST_FILE_NAME).unwrap(),\n+        &program,\n+      );\n+\n+      assert_eq!(line_directives.len(), 2);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_range_ignore_comments_unterminated() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-start\n+        function foo(): any {}\n+\n+        function bar(): any {\n+          foo();\n+        }\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_range_ignore_directives(\n+        true,\n+        &Url::from_str(TEST_FILE_NAME).unwrap(),\n+        &program,\n+      );\n+\n+      assert_eq!(line_directives.len(), 1);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_range_ignore_comments_nested() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-start\n+        function foo(): any {}\n+\n+        function bar(): any {\n+          // deno-coverage-ignore-start\n+          foo();\n+          // deno-coverage-ignore-stop\n+        }\n+        // deno-coverage-ignore-stop\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_range_ignore_directives(\n+        true,\n+        &Url::from_str(TEST_FILE_NAME).unwrap(),\n+        &program,\n+      );\n+\n+      assert_eq!(line_directives.len(), 1);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_next_ignore_comments() {\n+    let source_code = r#\"\n+        // deno-coverage-ignore-next\n+        function foo(): any {}\n+\n+        function bar(): any {\n+          // deno-coverage-ignore-next\n+          foo();\n+        }\n+    \"#;\n+\n+    parse_and_then(source_code, |program| {\n+      let line_directives = parse_next_ignore_directives(&program);\n+\n+      assert_eq!(line_directives.len(), 2);\n+    });\n+  }\n+\n+  #[test]\n+  fn test_parse_global_ignore_directives() {\n+    parse_and_then(\"// deno-coverage-ignore-file\", |program| {\n+      let file_directive = parse_file_ignore_directives(&program);\n+\n+      assert!(file_directive.is_some());\n+    });\n+\n+    parse_and_then(\n+      \"// deno-coverage-ignore-file -- reason for ignoring\",\n+      |program| {\n+        let file_directive = parse_file_ignore_directives(&program);\n+\n+        assert!(file_directive.is_some());\n+      },\n+    );\n+\n+    parse_and_then(\n+      \"// deno-coverage-ignore-file foo -- reason for ignoring\",",
        "comment_created_at": "2024-11-14T15:59:08+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Great, could you add a couple tests for other directives to ensure that they can accept the \"reason for ignoring\"?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2027909975",
    "pr_number": 28737,
    "pr_file": "cli/lsp/urls.rs",
    "created_at": "2025-04-04T00:17:12+00:00",
    "commented_code": "let components = deno_core::url::quirks::internal_components(url);\n   let mut input = String::with_capacity(url.as_str().len());\n   input.push_str(&url.as_str()[..components.path_start as usize]);\n-  if cfg!(windows) && url.scheme() == \"file\" {\n-    let path = url.path();\n-    let mut chars = path.chars();\n-    let has_drive_letter = chars.next().is_some_and(|c| c == '/')\n-      && chars.next().is_some_and(|c| c.is_ascii_alphabetic())\n-      && chars.next().is_some_and(|c| c == ':')\n-      && chars.next().is_none_or(|c| c == '/');\n-    if has_drive_letter {\n-      input.push_str(&path[..3]);\n-      input.push_str(\n-        &percent_encoding::utf8_percent_encode(&path[3..], URL_TO_URI_PATH)\n-          .to_string(),\n-      );\n-    } else {\n-      input.push_str(\n-        &percent_encoding::utf8_percent_encode(path, URL_TO_URI_PATH)\n-          .to_string(),\n-      );\n-    }\n-  } else {\n-    input.push_str(\n-      &percent_encoding::utf8_percent_encode(url.path(), URL_TO_URI_PATH)\n-        .to_string(),\n-    );\n-  }\n+  input.push_str(",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2027909975",
        "repo_full_name": "denoland/deno",
        "pr_number": 28737,
        "pr_file": "cli/lsp/urls.rs",
        "discussion_id": "2027909975",
        "commented_code": "@@ -82,31 +82,10 @@ pub fn url_to_uri(url: &Url) -> Result<Uri, AnyError> {\n   let components = deno_core::url::quirks::internal_components(url);\n   let mut input = String::with_capacity(url.as_str().len());\n   input.push_str(&url.as_str()[..components.path_start as usize]);\n-  if cfg!(windows) && url.scheme() == \"file\" {\n-    let path = url.path();\n-    let mut chars = path.chars();\n-    let has_drive_letter = chars.next().is_some_and(|c| c == '/')\n-      && chars.next().is_some_and(|c| c.is_ascii_alphabetic())\n-      && chars.next().is_some_and(|c| c == ':')\n-      && chars.next().is_none_or(|c| c == '/');\n-    if has_drive_letter {\n-      input.push_str(&path[..3]);\n-      input.push_str(\n-        &percent_encoding::utf8_percent_encode(&path[3..], URL_TO_URI_PATH)\n-          .to_string(),\n-      );\n-    } else {\n-      input.push_str(\n-        &percent_encoding::utf8_percent_encode(path, URL_TO_URI_PATH)\n-          .to_string(),\n-      );\n-    }\n-  } else {\n-    input.push_str(\n-      &percent_encoding::utf8_percent_encode(url.path(), URL_TO_URI_PATH)\n-        .to_string(),\n-    );\n-  }\n+  input.push_str(",
        "comment_created_at": "2025-04-04T00:17:12+00:00",
        "comment_author": "nathanwhit",
        "comment_body": "these functions (`url_to_uri`, `uri_to_url`) could use some unit tests",
        "pr_file_module": null
      }
    ]
  }
]