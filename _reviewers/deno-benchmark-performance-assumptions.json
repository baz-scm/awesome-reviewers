[
  {
    "discussion_id": "1934744887",
    "pr_number": 27855,
    "pr_file": "cli/tsc/98_lsp.js",
    "created_at": "2025-01-29T22:30:01+00:00",
    "commented_code": "// (it's about to be invalidated anyway).\n       const cachedProjectVersion = PROJECT_VERSION_CACHE.get();\n       if (cachedProjectVersion && projectVersion !== cachedProjectVersion) {\n-        return respond(id, {});\n+        return respond(id, [{}, null]);",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1934744887",
        "repo_full_name": "denoland/deno",
        "pr_number": 27855,
        "pr_file": "cli/tsc/98_lsp.js",
        "discussion_id": "1934744887",
        "commented_code": "@@ -432,7 +457,7 @@ function serverRequest(id, method, args, scope, maybeChange) {\n       // (it's about to be invalidated anyway).\n       const cachedProjectVersion = PROJECT_VERSION_CACHE.get();\n       if (cachedProjectVersion && projectVersion !== cachedProjectVersion) {\n-        return respond(id, {});\n+        return respond(id, [{}, null]);",
        "comment_created_at": "2025-01-29T22:30:01+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Ugh, do we really want to create an array here? Maybe use 2 separate arguments here to make it so slightly faster?",
        "pr_file_module": null
      },
      {
        "comment_id": "1934776918",
        "repo_full_name": "denoland/deno",
        "pr_number": 27855,
        "pr_file": "cli/tsc/98_lsp.js",
        "discussion_id": "1934744887",
        "commented_code": "@@ -432,7 +457,7 @@ function serverRequest(id, method, args, scope, maybeChange) {\n       // (it's about to be invalidated anyway).\n       const cachedProjectVersion = PROJECT_VERSION_CACHE.get();\n       if (cachedProjectVersion && projectVersion !== cachedProjectVersion) {\n-        return respond(id, {});\n+        return respond(id, [{}, null]);",
        "comment_created_at": "2025-01-29T23:04:12+00:00",
        "comment_author": "nathanwhit",
        "comment_body": "mm, so adding a third arg to `op_respond`? and it's just null for every other request? or am i misunderstanding",
        "pr_file_module": null
      },
      {
        "comment_id": "1934779420",
        "repo_full_name": "denoland/deno",
        "pr_number": 27855,
        "pr_file": "cli/tsc/98_lsp.js",
        "discussion_id": "1934744887",
        "commented_code": "@@ -432,7 +457,7 @@ function serverRequest(id, method, args, scope, maybeChange) {\n       // (it's about to be invalidated anyway).\n       const cachedProjectVersion = PROJECT_VERSION_CACHE.get();\n       if (cachedProjectVersion && projectVersion !== cachedProjectVersion) {\n-        return respond(id, {});\n+        return respond(id, [{}, null]);",
        "comment_created_at": "2025-01-29T23:06:54+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "I think it's 3th, but yes",
        "pr_file_module": null
      },
      {
        "comment_id": "1934806274",
        "repo_full_name": "denoland/deno",
        "pr_number": 27855,
        "pr_file": "cli/tsc/98_lsp.js",
        "discussion_id": "1934744887",
        "commented_code": "@@ -432,7 +457,7 @@ function serverRequest(id, method, args, scope, maybeChange) {\n       // (it's about to be invalidated anyway).\n       const cachedProjectVersion = PROJECT_VERSION_CACHE.get();\n       if (cachedProjectVersion && projectVersion !== cachedProjectVersion) {\n-        return respond(id, {});\n+        return respond(id, [{}, null]);",
        "comment_created_at": "2025-01-29T23:33:24+00:00",
        "comment_author": "nathanwhit",
        "comment_body": "wrote a small benchmark in deno_core comparing, and adding another arg is about 15% slower than the array version\r\n<details>\r\n<summary> Benchmark: </summary>\r\n\r\n```rs\r\n[derive(serde::Deserialize)]\r\nstruct Diagnostic {\r\n  foo: u32,\r\n  bar: bool,\r\n}\r\n\r\ntype Diagnostics = indexmap::IndexMap<String, Vec<Diagnostic>>;\r\ntype AmbientModules = HashMap<Option<ModuleSpecifier>, Option<Vec<String>>>;\r\n\r\n#[op2(fast)]\r\nfn op_respond_v1(#[string] response: String, #[string] error: String) {\r\n  if !error.is_empty() {\r\n    black_box(error);\r\n  } else {\r\n    let _json = black_box(\r\n      serde_json::from_str::<(Diagnostics, AmbientModules)>(&response),\r\n    );\r\n  }\r\n}\r\n\r\n#[divan::bench]\r\nfn bench_op_respond_v1(b: Bencher) {\r\n  bench_op(\r\n    b,\r\n    BENCH_COUNT,\r\n    \"op_respond_v1\",\r\n    0,\r\n    \"op_respond_v1(JSON.stringify([{}, null]),'')\",\r\n  );\r\n}\r\n#[op2(fast)]\r\nfn op_respond_v2(\r\n  #[string] response: String,\r\n  #[string] response2: String,\r\n  #[string] error: String,\r\n) {\r\n  if !error.is_empty() {\r\n    black_box(error);\r\n  } else {\r\n    let _one = black_box(serde_json::from_str::<Diagnostics>(&response));\r\n    let _two = black_box(serde_json::from_str::<AmbientModules>(&response2));\r\n  }\r\n}\r\n\r\n#[divan::bench]\r\nfn bench_op_respond_v2(b: Bencher) {\r\n  bench_op(\r\n    b,\r\n    BENCH_COUNT,\r\n    \"op_respond_v2\",\r\n    0,\r\n    \"op_respond_v2(JSON.stringify({}), '', '')\",\r\n  );\r\n}\r\n```\r\n</details>\r\n\r\n```\r\nops_sync                fastest       \u2502 slowest       \u2502 median        \u2502 mean          \u2502 samples \u2502 iters\r\n\u251c\u2500 bench_op_respond_v1  76.04 \u00b5s      \u2502 313.3 \u00b5s      \u2502 89.29 \u00b5s      \u2502 93.33 \u00b5s      \u2502 53205   \u2502 53205\r\n\u2570\u2500 bench_op_respond_v2  90.95 \u00b5s      \u2502 649.1 \u00b5s      \u2502 104.5 \u00b5s      \u2502 109.8 \u00b5s      \u2502 45472   \u2502 45472\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1934811883",
        "repo_full_name": "denoland/deno",
        "pr_number": 27855,
        "pr_file": "cli/tsc/98_lsp.js",
        "discussion_id": "1934744887",
        "commented_code": "@@ -432,7 +457,7 @@ function serverRequest(id, method, args, scope, maybeChange) {\n       // (it's about to be invalidated anyway).\n       const cachedProjectVersion = PROJECT_VERSION_CACHE.get();\n       if (cachedProjectVersion && projectVersion !== cachedProjectVersion) {\n-        return respond(id, {});\n+        return respond(id, [{}, null]);",
        "comment_created_at": "2025-01-29T23:39:47+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Okay, let's not do that then.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1786962351",
    "pr_number": 25517,
    "pr_file": "ext/canvas/01_image.js",
    "created_at": "2024-10-04T00:18:19+00:00",
    "commented_code": "if (options.resizeHeight === 0) {\n     return PromiseReject(\n       new DOMException(\n-        \"options.resizeWidth has to be greater than 0\",\n+        \"options.resizeHeight has to be greater than 0\",\n         \"InvalidStateError\",\n       ),\n     );\n   }\n \n   const imageBitmap = webidl.createBranded(ImageBitmap);\n \n-  if (ObjectPrototypeIsPrototypeOf(ImageDataPrototype, image)) {\n-    const processedImage = processImage(\n-      image[_data],\n-      image[_width],\n-      image[_height],\n-      sxOrOptions,\n-      sy,\n-      sw,\n-      sh,\n-      options,\n-    );\n-    imageBitmap[_bitmapData] = processedImage.data;\n-    imageBitmap[_width] = processedImage.outputWidth;\n-    imageBitmap[_height] = processedImage.outputHeight;\n-    return PromiseResolve(imageBitmap);\n-  }\n-  if (ObjectPrototypeIsPrototypeOf(BlobPrototype, image)) {\n-    return (async () => {\n-      const data = await image.arrayBuffer();\n-      const mimetype = sniffImage(image.type);\n-      if (mimetype !== \"image/png\") {\n-        throw new DOMException(\n-          `Unsupported type '${image.type}'`,\n-          \"InvalidStateError\",\n-        );\n-      }\n-      const { data: imageData, width, height } = op_image_decode_png(\n-        new Uint8Array(data),\n-      );\n-      const processedImage = processImage(\n-        imageData,\n-        width,\n-        height,\n-        sxOrOptions,\n-        sy,\n-        sw,\n-        sh,\n-        options,\n-      );\n-      imageBitmap[_bitmapData] = processedImage.data;\n-      imageBitmap[_width] = processedImage.outputWidth;\n-      imageBitmap[_height] = processedImage.outputHeight;\n-      return imageBitmap;\n-    })();\n-  } else {\n-    return PromiseReject(new TypeError(\"Invalid or unsupported image value\"));\n-  }\n-}\n-\n-function processImage(input, width, height, sx, sy, sw, sh, options) {\n-  let sourceRectangle;\n-\n-  if (\n-    sx !== undefined && sy !== undefined && sw !== undefined && sh !== undefined\n-  ) {\n-    sourceRectangle = [\n-      [sx, sy],\n-      [sx + sw, sy],\n-      [sx + sw, sy + sh],\n-      [sx, sy + sh],\n-    ];\n-  } else {\n-    sourceRectangle = [\n-      [0, 0],\n-      [width, 0],\n-      [width, height],\n-      [0, height],\n-    ];\n-  }\n-  const widthOfSourceRect = sourceRectangle[1][0] - sourceRectangle[0][0];\n-  const heightOfSourceRect = sourceRectangle[3][1] - sourceRectangle[0][1];\n-\n-  let outputWidth;\n-  if (options.resizeWidth !== undefined) {\n-    outputWidth = options.resizeWidth;\n-  } else if (options.resizeHeight !== undefined) {\n-    outputWidth = MathCeil(\n-      (widthOfSourceRect * options.resizeHeight) / heightOfSourceRect,\n-    );\n-  } else {\n-    outputWidth = widthOfSourceRect;\n-  }\n-\n-  let outputHeight;\n-  if (options.resizeHeight !== undefined) {\n-    outputHeight = options.resizeHeight;\n-  } else if (options.resizeWidth !== undefined) {\n-    outputHeight = MathCeil(\n-      (heightOfSourceRect * options.resizeWidth) / widthOfSourceRect,\n+  // 3.\n+  const isBlob = ObjectPrototypeIsPrototypeOf(BlobPrototype, image);\n+  const isImageData = ObjectPrototypeIsPrototypeOf(ImageDataPrototype, image);\n+  if (!isBlob && !isImageData) {\n+    return PromiseReject(\n+      new DOMException(\n+        `${prefix}: The provided value for 'image' is not of type '(${\n+          ArrayPrototypeJoin(imageBitmapSources, \" or \")\n+        })'.`,\n+        \"InvalidStateError\",\n+      ),\n     );\n-  } else {\n-    outputHeight = heightOfSourceRect;\n   }\n \n-  if (options.colorSpaceConversion === \"none\") {\n-    throw new TypeError(\n-      \"Cannot create image: invalid colorSpaceConversion option, 'none' is not supported\",\n-    );\n-  }\n+  // 4.\n+  return (async () => {\n+    let width = 0;\n+    let height = 0;\n+    let mimeType = \"\";\n+    let imageBitmapSource, buf;\n+    if (isBlob) {\n+      imageBitmapSource = imageBitmapSources[0];\n+      buf = new Uint8Array(await image.arrayBuffer());\n+      mimeType = sniffImage(image.type);\n+    }\n+    if (isImageData) {\n+      width = image[_width];\n+      height = image[_height];\n+      imageBitmapSource = imageBitmapSources[1];\n+      buf = new Uint8Array(TypedArrayPrototypeGetBuffer(image[_data]));\n+    }\n \n-  /*\n-   * The cropping works differently than the spec specifies:\n-   * The spec states to create an infinite surface and place the top-left corner\n-   * of the image a 0,0 and crop based on sourceRectangle.\n-   *\n-   * We instead create a surface the size of sourceRectangle, and position\n-   * the image at the correct location, which is the inverse of the x & y of\n-   * sourceRectangle's top-left corner.\n-   */\n-  const data = op_image_process(\n-    new Uint8Array(TypedArrayPrototypeGetBuffer(input)),\n-    {\n+    let sx;\n+    if (typeof sxOrOptions === \"number\") {\n+      sx = sxOrOptions;\n+    }\n+    // TODO(Hajime-san): this should be real async\n+    const processedImage = op_create_image_bitmap(",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1786962351",
        "repo_full_name": "denoland/deno",
        "pr_number": 25517,
        "pr_file": "ext/canvas/01_image.js",
        "discussion_id": "1786962351",
        "commented_code": "@@ -204,147 +209,73 @@ function createImageBitmap(\n   if (options.resizeHeight === 0) {\n     return PromiseReject(\n       new DOMException(\n-        \"options.resizeWidth has to be greater than 0\",\n+        \"options.resizeHeight has to be greater than 0\",\n         \"InvalidStateError\",\n       ),\n     );\n   }\n \n   const imageBitmap = webidl.createBranded(ImageBitmap);\n \n-  if (ObjectPrototypeIsPrototypeOf(ImageDataPrototype, image)) {\n-    const processedImage = processImage(\n-      image[_data],\n-      image[_width],\n-      image[_height],\n-      sxOrOptions,\n-      sy,\n-      sw,\n-      sh,\n-      options,\n-    );\n-    imageBitmap[_bitmapData] = processedImage.data;\n-    imageBitmap[_width] = processedImage.outputWidth;\n-    imageBitmap[_height] = processedImage.outputHeight;\n-    return PromiseResolve(imageBitmap);\n-  }\n-  if (ObjectPrototypeIsPrototypeOf(BlobPrototype, image)) {\n-    return (async () => {\n-      const data = await image.arrayBuffer();\n-      const mimetype = sniffImage(image.type);\n-      if (mimetype !== \"image/png\") {\n-        throw new DOMException(\n-          `Unsupported type '${image.type}'`,\n-          \"InvalidStateError\",\n-        );\n-      }\n-      const { data: imageData, width, height } = op_image_decode_png(\n-        new Uint8Array(data),\n-      );\n-      const processedImage = processImage(\n-        imageData,\n-        width,\n-        height,\n-        sxOrOptions,\n-        sy,\n-        sw,\n-        sh,\n-        options,\n-      );\n-      imageBitmap[_bitmapData] = processedImage.data;\n-      imageBitmap[_width] = processedImage.outputWidth;\n-      imageBitmap[_height] = processedImage.outputHeight;\n-      return imageBitmap;\n-    })();\n-  } else {\n-    return PromiseReject(new TypeError(\"Invalid or unsupported image value\"));\n-  }\n-}\n-\n-function processImage(input, width, height, sx, sy, sw, sh, options) {\n-  let sourceRectangle;\n-\n-  if (\n-    sx !== undefined && sy !== undefined && sw !== undefined && sh !== undefined\n-  ) {\n-    sourceRectangle = [\n-      [sx, sy],\n-      [sx + sw, sy],\n-      [sx + sw, sy + sh],\n-      [sx, sy + sh],\n-    ];\n-  } else {\n-    sourceRectangle = [\n-      [0, 0],\n-      [width, 0],\n-      [width, height],\n-      [0, height],\n-    ];\n-  }\n-  const widthOfSourceRect = sourceRectangle[1][0] - sourceRectangle[0][0];\n-  const heightOfSourceRect = sourceRectangle[3][1] - sourceRectangle[0][1];\n-\n-  let outputWidth;\n-  if (options.resizeWidth !== undefined) {\n-    outputWidth = options.resizeWidth;\n-  } else if (options.resizeHeight !== undefined) {\n-    outputWidth = MathCeil(\n-      (widthOfSourceRect * options.resizeHeight) / heightOfSourceRect,\n-    );\n-  } else {\n-    outputWidth = widthOfSourceRect;\n-  }\n-\n-  let outputHeight;\n-  if (options.resizeHeight !== undefined) {\n-    outputHeight = options.resizeHeight;\n-  } else if (options.resizeWidth !== undefined) {\n-    outputHeight = MathCeil(\n-      (heightOfSourceRect * options.resizeWidth) / widthOfSourceRect,\n+  // 3.\n+  const isBlob = ObjectPrototypeIsPrototypeOf(BlobPrototype, image);\n+  const isImageData = ObjectPrototypeIsPrototypeOf(ImageDataPrototype, image);\n+  if (!isBlob && !isImageData) {\n+    return PromiseReject(\n+      new DOMException(\n+        `${prefix}: The provided value for 'image' is not of type '(${\n+          ArrayPrototypeJoin(imageBitmapSources, \" or \")\n+        })'.`,\n+        \"InvalidStateError\",\n+      ),\n     );\n-  } else {\n-    outputHeight = heightOfSourceRect;\n   }\n \n-  if (options.colorSpaceConversion === \"none\") {\n-    throw new TypeError(\n-      \"Cannot create image: invalid colorSpaceConversion option, 'none' is not supported\",\n-    );\n-  }\n+  // 4.\n+  return (async () => {\n+    let width = 0;\n+    let height = 0;\n+    let mimeType = \"\";\n+    let imageBitmapSource, buf;\n+    if (isBlob) {\n+      imageBitmapSource = imageBitmapSources[0];\n+      buf = new Uint8Array(await image.arrayBuffer());\n+      mimeType = sniffImage(image.type);\n+    }\n+    if (isImageData) {\n+      width = image[_width];\n+      height = image[_height];\n+      imageBitmapSource = imageBitmapSources[1];\n+      buf = new Uint8Array(TypedArrayPrototypeGetBuffer(image[_data]));\n+    }\n \n-  /*\n-   * The cropping works differently than the spec specifies:\n-   * The spec states to create an infinite surface and place the top-left corner\n-   * of the image a 0,0 and crop based on sourceRectangle.\n-   *\n-   * We instead create a surface the size of sourceRectangle, and position\n-   * the image at the correct location, which is the inverse of the x & y of\n-   * sourceRectangle's top-left corner.\n-   */\n-  const data = op_image_process(\n-    new Uint8Array(TypedArrayPrototypeGetBuffer(input)),\n-    {\n+    let sx;\n+    if (typeof sxOrOptions === \"number\") {\n+      sx = sxOrOptions;\n+    }\n+    // TODO(Hajime-san): this should be real async\n+    const processedImage = op_create_image_bitmap(",
        "comment_created_at": "2024-10-04T00:18:19+00:00",
        "comment_author": "Hajime-san",
        "comment_body": "Initially, I thought it would be necessary to make it an async op, but when I actually implemented it that seemed to reduce performance compared to fb6b87d65 https://github.com/denoland/deno/pull/25517#issue-2512598465.\r\nIn this case, is it not necessary to make it an async op?\ud83e\udd14\r\n\r\n```bash\r\n% target/release/deno bench bench.ts\r\n    CPU | Apple M1\r\nRuntime | Deno 2.0.0-rc.9 (aarch64-apple-darwin)\r\n\r\nfile:///path/to/deno/bench.ts\r\n\r\nbenchmark           time/iter (avg)        iter/s      (min \u2026 max)           p75      p99     p995\r\n------------------- ----------------------------- --------------------- --------------------------\r\ncreateImageBitmap            4.8 \u00b5s       208,800 (  4.7 \u00b5s \u2026   5.1 \u00b5s)   4.8 \u00b5s   5.1 \u00b5s   5.1 \u00b5s\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1855085116",
        "repo_full_name": "denoland/deno",
        "pr_number": 25517,
        "pr_file": "ext/canvas/01_image.js",
        "discussion_id": "1786962351",
        "commented_code": "@@ -204,147 +209,73 @@ function createImageBitmap(\n   if (options.resizeHeight === 0) {\n     return PromiseReject(\n       new DOMException(\n-        \"options.resizeWidth has to be greater than 0\",\n+        \"options.resizeHeight has to be greater than 0\",\n         \"InvalidStateError\",\n       ),\n     );\n   }\n \n   const imageBitmap = webidl.createBranded(ImageBitmap);\n \n-  if (ObjectPrototypeIsPrototypeOf(ImageDataPrototype, image)) {\n-    const processedImage = processImage(\n-      image[_data],\n-      image[_width],\n-      image[_height],\n-      sxOrOptions,\n-      sy,\n-      sw,\n-      sh,\n-      options,\n-    );\n-    imageBitmap[_bitmapData] = processedImage.data;\n-    imageBitmap[_width] = processedImage.outputWidth;\n-    imageBitmap[_height] = processedImage.outputHeight;\n-    return PromiseResolve(imageBitmap);\n-  }\n-  if (ObjectPrototypeIsPrototypeOf(BlobPrototype, image)) {\n-    return (async () => {\n-      const data = await image.arrayBuffer();\n-      const mimetype = sniffImage(image.type);\n-      if (mimetype !== \"image/png\") {\n-        throw new DOMException(\n-          `Unsupported type '${image.type}'`,\n-          \"InvalidStateError\",\n-        );\n-      }\n-      const { data: imageData, width, height } = op_image_decode_png(\n-        new Uint8Array(data),\n-      );\n-      const processedImage = processImage(\n-        imageData,\n-        width,\n-        height,\n-        sxOrOptions,\n-        sy,\n-        sw,\n-        sh,\n-        options,\n-      );\n-      imageBitmap[_bitmapData] = processedImage.data;\n-      imageBitmap[_width] = processedImage.outputWidth;\n-      imageBitmap[_height] = processedImage.outputHeight;\n-      return imageBitmap;\n-    })();\n-  } else {\n-    return PromiseReject(new TypeError(\"Invalid or unsupported image value\"));\n-  }\n-}\n-\n-function processImage(input, width, height, sx, sy, sw, sh, options) {\n-  let sourceRectangle;\n-\n-  if (\n-    sx !== undefined && sy !== undefined && sw !== undefined && sh !== undefined\n-  ) {\n-    sourceRectangle = [\n-      [sx, sy],\n-      [sx + sw, sy],\n-      [sx + sw, sy + sh],\n-      [sx, sy + sh],\n-    ];\n-  } else {\n-    sourceRectangle = [\n-      [0, 0],\n-      [width, 0],\n-      [width, height],\n-      [0, height],\n-    ];\n-  }\n-  const widthOfSourceRect = sourceRectangle[1][0] - sourceRectangle[0][0];\n-  const heightOfSourceRect = sourceRectangle[3][1] - sourceRectangle[0][1];\n-\n-  let outputWidth;\n-  if (options.resizeWidth !== undefined) {\n-    outputWidth = options.resizeWidth;\n-  } else if (options.resizeHeight !== undefined) {\n-    outputWidth = MathCeil(\n-      (widthOfSourceRect * options.resizeHeight) / heightOfSourceRect,\n-    );\n-  } else {\n-    outputWidth = widthOfSourceRect;\n-  }\n-\n-  let outputHeight;\n-  if (options.resizeHeight !== undefined) {\n-    outputHeight = options.resizeHeight;\n-  } else if (options.resizeWidth !== undefined) {\n-    outputHeight = MathCeil(\n-      (heightOfSourceRect * options.resizeWidth) / widthOfSourceRect,\n+  // 3.\n+  const isBlob = ObjectPrototypeIsPrototypeOf(BlobPrototype, image);\n+  const isImageData = ObjectPrototypeIsPrototypeOf(ImageDataPrototype, image);\n+  if (!isBlob && !isImageData) {\n+    return PromiseReject(\n+      new DOMException(\n+        `${prefix}: The provided value for 'image' is not of type '(${\n+          ArrayPrototypeJoin(imageBitmapSources, \" or \")\n+        })'.`,\n+        \"InvalidStateError\",\n+      ),\n     );\n-  } else {\n-    outputHeight = heightOfSourceRect;\n   }\n \n-  if (options.colorSpaceConversion === \"none\") {\n-    throw new TypeError(\n-      \"Cannot create image: invalid colorSpaceConversion option, 'none' is not supported\",\n-    );\n-  }\n+  // 4.\n+  return (async () => {\n+    let width = 0;\n+    let height = 0;\n+    let mimeType = \"\";\n+    let imageBitmapSource, buf;\n+    if (isBlob) {\n+      imageBitmapSource = imageBitmapSources[0];\n+      buf = new Uint8Array(await image.arrayBuffer());\n+      mimeType = sniffImage(image.type);\n+    }\n+    if (isImageData) {\n+      width = image[_width];\n+      height = image[_height];\n+      imageBitmapSource = imageBitmapSources[1];\n+      buf = new Uint8Array(TypedArrayPrototypeGetBuffer(image[_data]));\n+    }\n \n-  /*\n-   * The cropping works differently than the spec specifies:\n-   * The spec states to create an infinite surface and place the top-left corner\n-   * of the image a 0,0 and crop based on sourceRectangle.\n-   *\n-   * We instead create a surface the size of sourceRectangle, and position\n-   * the image at the correct location, which is the inverse of the x & y of\n-   * sourceRectangle's top-left corner.\n-   */\n-  const data = op_image_process(\n-    new Uint8Array(TypedArrayPrototypeGetBuffer(input)),\n-    {\n+    let sx;\n+    if (typeof sxOrOptions === \"number\") {\n+      sx = sxOrOptions;\n+    }\n+    // TODO(Hajime-san): this should be real async\n+    const processedImage = op_create_image_bitmap(",
        "comment_created_at": "2024-11-23T05:10:18+00:00",
        "comment_author": "crowlKats",
        "comment_body": "i think it should be fine if its sync; afterall it makes sense for browsers to be async since they are handling graphics stuff outside of the js apis sandbox, but for us we dont have that so its fine.",
        "pr_file_module": null
      }
    ]
  }
]