[
  {
    "discussion_id": "436769885",
    "pr_number": 6171,
    "pr_file": "std/io/bufio.ts",
    "created_at": "2020-06-08T14:52:57+00:00",
    "commented_code": "}\n }\n \n+/** BufReaderSync implements buffering for a ReaderSync object. */\n+export class BufReaderSync implements ReaderSync {\n+  private buf!: Uint8Array;\n+  private rd!: ReaderSync; // Reader provided by caller.\n+  private r = 0; // buf read position.\n+  private w = 0; // buf write position.\n+  private eof = false;\n+  // private lastByte: number;\n+  // private lastCharSize: number;\n+\n+  /** return new BufReaderSync unless r is BufReaderSync */\n+  static create(r: ReaderSync, size: number = DEFAULT_BUF_SIZE): BufReaderSync {\n+    return r instanceof BufReaderSync ? r : new BufReaderSync(r, size);\n+  }\n+\n+  constructor(rd: ReaderSync, size: number = DEFAULT_BUF_SIZE) {\n+    if (size < MIN_BUF_SIZE) {\n+      size = MIN_BUF_SIZE;\n+    }\n+    this._reset(new Uint8Array(size), rd);\n+  }\n+\n+  /** Returns the size of the underlying buffer in bytes. */\n+  size(): number {\n+    return this.buf.byteLength;\n+  }\n+\n+  buffered(): number {\n+    return this.w - this.r;\n+  }\n+\n+  // Reads a new chunk into the buffer.\n+  private _fill(): void {\n+    // Slide existing data to beginning.\n+    if (this.r > 0) {\n+      this.buf.copyWithin(0, this.r, this.w);\n+      this.w -= this.r;\n+      this.r = 0;\n+    }\n+\n+    if (this.w >= this.buf.byteLength) {\n+      throw Error(\"bufio: tried to fill full buffer\");\n+    }\n+\n+    // Read new data: try a limited number of times.\n+    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {\n+      const rr = this.rd.readSync(this.buf.subarray(this.w));\n+      if (rr === null) {\n+        this.eof = true;\n+        return;\n+      }\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+      if (rr > 0) {\n+        return;\n+      }\n+    }\n+\n+    throw new Error(\n+      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`\n+    );\n+  }\n+\n+  /** Discards any buffered data, resets all state, and switches\n+   * the buffered reader to read from r.\n+   */\n+  reset(r: ReaderSync): void {\n+    this._reset(this.buf, r);\n+  }\n+\n+  private _reset(buf: Uint8Array, rd: ReaderSync): void {\n+    this.buf = buf;\n+    this.rd = rd;\n+    this.eof = false;\n+    // this.lastByte = -1;\n+    // this.lastCharSize = -1;\n+  }\n+\n+  /** reads data into p.\n+   * It returns the number of bytes read into p.\n+   * The bytes are taken from at most one Read on the underlying Reader,\n+   * hence n may be less than len(p).\n+   * To read exactly len(p) bytes, use io.ReadFull(b, p).\n+   */\n+  readSync(p: Uint8Array): number | null {\n+    let rr: number | null = p.byteLength;\n+    if (p.byteLength === 0) return rr;\n+\n+    if (this.r === this.w) {\n+      if (p.byteLength >= this.buf.byteLength) {\n+        // Large read, empty buffer.\n+        // Read directly into p to avoid copy.\n+        const rr = this.rd.readSync(p);\n+        const nread = rr ?? 0;\n+        assert(nread >= 0, \"negative read\");\n+        // if (rr.nread > 0) {\n+        //   this.lastByte = p[rr.nread - 1];\n+        //   this.lastCharSize = -1;\n+        // }\n+        return rr;\n+      }\n+\n+      // One read.\n+      // Do not use this.fill, which will loop.\n+      this.r = 0;\n+      this.w = 0;\n+      rr = this.rd.readSync(this.buf);\n+      if (rr === 0 || rr === null) return rr;\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+    }\n+\n+    // copy as much as we can\n+    const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);\n+    this.r += copied;\n+    // this.lastByte = this.buf[this.r - 1];\n+    // this.lastCharSize = -1;\n+    return copied;\n+  }\n+\n+  /** reads exactly `p.length` bytes into `p`.\n+   *\n+   * If successful, `p` is returned.\n+   *\n+   * If the end of the underlying stream has been reached, and there are no more\n+   * bytes available in the buffer, `readFull()` returns `null` instead.\n+   *\n+   * An error is thrown if some bytes could be read, but not enough to fill `p`\n+   * entirely before the underlying stream reported an error or EOF. Any error\n+   * thrown will have a `partial` property that indicates the slice of the\n+   * buffer that has been successfully filled with data.\n+   *\n+   * Ported from https://golang.org/pkg/io/#ReadFull\n+   */\n+  readFull(p: Uint8Array): Uint8Array | null {\n+    let bytesRead = 0;\n+    while (bytesRead < p.length) {\n+      try {\n+        const rr = this.readSync(p.subarray(bytesRead));\n+        if (rr === null) {\n+          if (bytesRead === 0) {\n+            return null;\n+          } else {\n+            throw new PartialReadError();\n+          }\n+        }\n+        bytesRead += rr;\n+      } catch (err) {\n+        err.partial = p.subarray(0, bytesRead);\n+        throw err;\n+      }\n+    }\n+    return p;\n+  }\n+\n+  /** Returns the next byte [0, 255] or `null`. */\n+  readByte(): number | null {\n+    while (this.r === this.w) {\n+      if (this.eof) return null;\n+      this._fill(); // buffer is empty.\n+    }\n+    const c = this.buf[this.r];\n+    this.r++;\n+    // this.lastByte = c;\n+    return c;\n+  }\n+\n+  /** readString() reads until the first occurrence of delim in the input,\n+   * returning a string containing the data up to and including the delimiter.\n+   * If ReadString encounters an error before finding a delimiter,\n+   * it returns the data read before the error and the error itself\n+   * (often `null`).\n+   * ReadString returns err != nil if and only if the returned data does not end\n+   * in delim.\n+   * For simple uses, a Scanner may be more convenient.\n+   */\n+  readString(delim: string): string | null {\n+    if (delim.length !== 1) {\n+      throw new Error(\"Delimiter should be a single character\");\n+    }\n+    const buffer = this.readSlice(delim.charCodeAt(0));\n+    if (buffer === null) return null;\n+    return new TextDecoder().decode(buffer);\n+  }\n+\n+  /** `readLine()` is a low-level line-reading primitive. Most callers should\n+   * use `readString('\n')` instead or use a Scanner.\n+   *\n+   * `readLine()` tries to return a single line, not including the end-of-line\n+   * bytes. If the line was too long for the buffer then `more` is set and the\n+   * beginning of the line is returned. The rest of the line will be returned\n+   * from future calls. `more` will be false when returning the last fragment\n+   * of the line. The returned buffer is only valid until the next call to\n+   * `readLine()`.\n+   *\n+   * The text returned from ReadLine does not include the line end (\"\\r\n\" or\n+   * \"\n\").\n+   *\n+   * When the end of the underlying stream is reached, the final bytes in the\n+   * stream are returned. No indication or error is given if the input ends\n+   * without a final line end. When there are no more trailing bytes to read,\n+   * `readLine()` returns `null`.\n+   *\n+   * Calling `unreadByte()` after `readLine()` will always unread the last byte\n+   * read (possibly a character belonging to the line end) even if that byte is\n+   * not part of the line returned by `readLine()`.\n+   */\n+  readLine(): ReadLineResult | null {\n+    let line: Uint8Array | null;\n+\n+    try {\n+      line = this.readSlice(LF);\n+    } catch (err) {\n+      let { partial } = err;\n+      assert(\n+        partial instanceof Uint8Array,\n+        \"bufio: caught error from `readSlice()` without `partial` property\"\n+      );\n+\n+      // Don't throw if `readSlice()` failed with `BufferFullError`, instead we\n+      // just return whatever is available and set the `more` flag.\n+      if (!(err instanceof BufferFullError)) {\n+        throw err;\n+      }\n+\n+      // Handle the case where \"\\r\n\" straddles the buffer.\n+      if (\n+        !this.eof &&\n+        partial.byteLength > 0 &&\n+        partial[partial.byteLength - 1] === CR\n+      ) {\n+        // Put the '\\r' back on buf and drop it from line.\n+        // Let the next call to ReadLine check for \"\\r\n\".\n+        assert(this.r > 0, \"bufio: tried to rewind past start of buffer\");\n+        this.r--;\n+        partial = partial.subarray(0, partial.byteLength - 1);\n+      }\n+\n+      return { line: partial, more: !this.eof };\n+    }\n+\n+    if (line === null) {\n+      return null;\n+    }\n+\n+    if (line.byteLength === 0) {\n+      return { line, more: false };\n+    }\n+\n+    if (line[line.byteLength - 1] == LF) {\n+      let drop = 1;\n+      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {\n+        drop = 2;\n+      }\n+      line = line.subarray(0, line.byteLength - drop);\n+    }\n+    return { line, more: false };\n+  }\n+\n+  /** `readSlice()` reads until the first occurrence of `delim` in the input,\n+   * returning a slice pointing at the bytes in the buffer. The bytes stop\n+   * being valid at the next read.\n+   *\n+   * If `readSlice()` encounters an error before finding a delimiter, or the\n+   * buffer fills without finding a delimiter, it throws an error with a\n+   * `partial` property that contains the entire buffer.\n+   *\n+   * If `readSlice()` encounters the end of the underlying stream and there are\n+   * any bytes left in the buffer, the rest of the buffer is returned. In other\n+   * words, EOF is always treated as a delimiter. Once the buffer is empty,\n+   * it returns `null`.\n+   *\n+   * Because the data returned from `readSlice()` will be overwritten by the\n+   * next I/O operation, most clients should use `readString()` instead.\n+   */\n+  readSlice(delim: number): Uint8Array | null {\n+    let s = 0; // search start index\n+    let slice: Uint8Array | undefined;\n+\n+    while (true) {\n+      // Search buffer.\n+      let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);\n+      if (i >= 0) {\n+        i += s;\n+        slice = this.buf.subarray(this.r, this.r + i + 1);\n+        this.r += i + 1;\n+        break;\n+      }\n+\n+      // EOF?\n+      if (this.eof) {\n+        if (this.r === this.w) {\n+          return null;\n+        }\n+        slice = this.buf.subarray(this.r, this.w);\n+        this.r = this.w;\n+        break;\n+      }\n+\n+      // Buffer full?\n+      if (this.buffered() >= this.buf.byteLength) {\n+        this.r = this.w;\n+        // #4521 The internal buffer should not be reused across reads because it causes corruption of data.\n+        const oldbuf = this.buf;\n+        const newbuf = this.buf.slice(0);\n+        this.buf = newbuf;\n+        throw new BufferFullError(oldbuf);\n+      }\n+\n+      s = this.w - this.r; // do not rescan area we scanned before\n+\n+      // Buffer is not full.\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = slice;\n+        throw err;\n+      }\n+    }\n+\n+    // Handle last byte, if any.\n+    // const i = slice.byteLength - 1;\n+    // if (i >= 0) {\n+    //   this.lastByte = slice[i];\n+    //   this.lastCharSize = -1\n+    // }\n+\n+    return slice;\n+  }\n+\n+  /** `peek()` returns the next `n` bytes without advancing the reader. The\n+   * bytes stop being valid at the next read call.\n+   *\n+   * When the end of the underlying stream is reached, but there are unread\n+   * bytes left in the buffer, those bytes are returned. If there are no bytes\n+   * left in the buffer, it returns `null`.\n+   *\n+   * If an error is encountered before `n` bytes are available, `peek()` throws\n+   * an error with the `partial` property set to a slice of the buffer that\n+   * contains the bytes that were available before the error occurred.\n+   */\n+  peek(n: number): Uint8Array | null {\n+    if (n < 0) {\n+      throw Error(\"negative count\");\n+    }\n+\n+    let avail = this.w - this.r;\n+    while (avail < n && avail < this.buf.byteLength && !this.eof) {\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = this.buf.subarray(this.r, this.w);\n+        throw err;\n+      }\n+      avail = this.w - this.r;\n+    }\n+\n+    if (avail === 0 && this.eof) {\n+      return null;\n+    } else if (avail < n && this.eof) {\n+      return this.buf.subarray(this.r, this.r + avail);\n+    } else if (avail < n) {\n+      throw new BufferFullError(this.buf.subarray(this.r, this.w));\n+    }\n+\n+    return this.buf.subarray(this.r, this.r + n);\n+  }\n+}\n+",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "436769885",
        "repo_full_name": "denoland/deno",
        "pr_number": 6171,
        "pr_file": "std/io/bufio.ts",
        "discussion_id": "436769885",
        "commented_code": "@@ -405,6 +406,375 @@ export class BufReader implements Reader {\n   }\n }\n \n+/** BufReaderSync implements buffering for a ReaderSync object. */\n+export class BufReaderSync implements ReaderSync {\n+  private buf!: Uint8Array;\n+  private rd!: ReaderSync; // Reader provided by caller.\n+  private r = 0; // buf read position.\n+  private w = 0; // buf write position.\n+  private eof = false;\n+  // private lastByte: number;\n+  // private lastCharSize: number;\n+\n+  /** return new BufReaderSync unless r is BufReaderSync */\n+  static create(r: ReaderSync, size: number = DEFAULT_BUF_SIZE): BufReaderSync {\n+    return r instanceof BufReaderSync ? r : new BufReaderSync(r, size);\n+  }\n+\n+  constructor(rd: ReaderSync, size: number = DEFAULT_BUF_SIZE) {\n+    if (size < MIN_BUF_SIZE) {\n+      size = MIN_BUF_SIZE;\n+    }\n+    this._reset(new Uint8Array(size), rd);\n+  }\n+\n+  /** Returns the size of the underlying buffer in bytes. */\n+  size(): number {\n+    return this.buf.byteLength;\n+  }\n+\n+  buffered(): number {\n+    return this.w - this.r;\n+  }\n+\n+  // Reads a new chunk into the buffer.\n+  private _fill(): void {\n+    // Slide existing data to beginning.\n+    if (this.r > 0) {\n+      this.buf.copyWithin(0, this.r, this.w);\n+      this.w -= this.r;\n+      this.r = 0;\n+    }\n+\n+    if (this.w >= this.buf.byteLength) {\n+      throw Error(\"bufio: tried to fill full buffer\");\n+    }\n+\n+    // Read new data: try a limited number of times.\n+    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {\n+      const rr = this.rd.readSync(this.buf.subarray(this.w));\n+      if (rr === null) {\n+        this.eof = true;\n+        return;\n+      }\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+      if (rr > 0) {\n+        return;\n+      }\n+    }\n+\n+    throw new Error(\n+      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`\n+    );\n+  }\n+\n+  /** Discards any buffered data, resets all state, and switches\n+   * the buffered reader to read from r.\n+   */\n+  reset(r: ReaderSync): void {\n+    this._reset(this.buf, r);\n+  }\n+\n+  private _reset(buf: Uint8Array, rd: ReaderSync): void {\n+    this.buf = buf;\n+    this.rd = rd;\n+    this.eof = false;\n+    // this.lastByte = -1;\n+    // this.lastCharSize = -1;\n+  }\n+\n+  /** reads data into p.\n+   * It returns the number of bytes read into p.\n+   * The bytes are taken from at most one Read on the underlying Reader,\n+   * hence n may be less than len(p).\n+   * To read exactly len(p) bytes, use io.ReadFull(b, p).\n+   */\n+  readSync(p: Uint8Array): number | null {\n+    let rr: number | null = p.byteLength;\n+    if (p.byteLength === 0) return rr;\n+\n+    if (this.r === this.w) {\n+      if (p.byteLength >= this.buf.byteLength) {\n+        // Large read, empty buffer.\n+        // Read directly into p to avoid copy.\n+        const rr = this.rd.readSync(p);\n+        const nread = rr ?? 0;\n+        assert(nread >= 0, \"negative read\");\n+        // if (rr.nread > 0) {\n+        //   this.lastByte = p[rr.nread - 1];\n+        //   this.lastCharSize = -1;\n+        // }\n+        return rr;\n+      }\n+\n+      // One read.\n+      // Do not use this.fill, which will loop.\n+      this.r = 0;\n+      this.w = 0;\n+      rr = this.rd.readSync(this.buf);\n+      if (rr === 0 || rr === null) return rr;\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+    }\n+\n+    // copy as much as we can\n+    const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);\n+    this.r += copied;\n+    // this.lastByte = this.buf[this.r - 1];\n+    // this.lastCharSize = -1;\n+    return copied;\n+  }\n+\n+  /** reads exactly `p.length` bytes into `p`.\n+   *\n+   * If successful, `p` is returned.\n+   *\n+   * If the end of the underlying stream has been reached, and there are no more\n+   * bytes available in the buffer, `readFull()` returns `null` instead.\n+   *\n+   * An error is thrown if some bytes could be read, but not enough to fill `p`\n+   * entirely before the underlying stream reported an error or EOF. Any error\n+   * thrown will have a `partial` property that indicates the slice of the\n+   * buffer that has been successfully filled with data.\n+   *\n+   * Ported from https://golang.org/pkg/io/#ReadFull\n+   */\n+  readFull(p: Uint8Array): Uint8Array | null {\n+    let bytesRead = 0;\n+    while (bytesRead < p.length) {\n+      try {\n+        const rr = this.readSync(p.subarray(bytesRead));\n+        if (rr === null) {\n+          if (bytesRead === 0) {\n+            return null;\n+          } else {\n+            throw new PartialReadError();\n+          }\n+        }\n+        bytesRead += rr;\n+      } catch (err) {\n+        err.partial = p.subarray(0, bytesRead);\n+        throw err;\n+      }\n+    }\n+    return p;\n+  }\n+\n+  /** Returns the next byte [0, 255] or `null`. */\n+  readByte(): number | null {\n+    while (this.r === this.w) {\n+      if (this.eof) return null;\n+      this._fill(); // buffer is empty.\n+    }\n+    const c = this.buf[this.r];\n+    this.r++;\n+    // this.lastByte = c;\n+    return c;\n+  }\n+\n+  /** readString() reads until the first occurrence of delim in the input,\n+   * returning a string containing the data up to and including the delimiter.\n+   * If ReadString encounters an error before finding a delimiter,\n+   * it returns the data read before the error and the error itself\n+   * (often `null`).\n+   * ReadString returns err != nil if and only if the returned data does not end\n+   * in delim.\n+   * For simple uses, a Scanner may be more convenient.\n+   */\n+  readString(delim: string): string | null {\n+    if (delim.length !== 1) {\n+      throw new Error(\"Delimiter should be a single character\");\n+    }\n+    const buffer = this.readSlice(delim.charCodeAt(0));\n+    if (buffer === null) return null;\n+    return new TextDecoder().decode(buffer);\n+  }\n+\n+  /** `readLine()` is a low-level line-reading primitive. Most callers should\n+   * use `readString('\\n')` instead or use a Scanner.\n+   *\n+   * `readLine()` tries to return a single line, not including the end-of-line\n+   * bytes. If the line was too long for the buffer then `more` is set and the\n+   * beginning of the line is returned. The rest of the line will be returned\n+   * from future calls. `more` will be false when returning the last fragment\n+   * of the line. The returned buffer is only valid until the next call to\n+   * `readLine()`.\n+   *\n+   * The text returned from ReadLine does not include the line end (\"\\r\\n\" or\n+   * \"\\n\").\n+   *\n+   * When the end of the underlying stream is reached, the final bytes in the\n+   * stream are returned. No indication or error is given if the input ends\n+   * without a final line end. When there are no more trailing bytes to read,\n+   * `readLine()` returns `null`.\n+   *\n+   * Calling `unreadByte()` after `readLine()` will always unread the last byte\n+   * read (possibly a character belonging to the line end) even if that byte is\n+   * not part of the line returned by `readLine()`.\n+   */\n+  readLine(): ReadLineResult | null {\n+    let line: Uint8Array | null;\n+\n+    try {\n+      line = this.readSlice(LF);\n+    } catch (err) {\n+      let { partial } = err;\n+      assert(\n+        partial instanceof Uint8Array,\n+        \"bufio: caught error from `readSlice()` without `partial` property\"\n+      );\n+\n+      // Don't throw if `readSlice()` failed with `BufferFullError`, instead we\n+      // just return whatever is available and set the `more` flag.\n+      if (!(err instanceof BufferFullError)) {\n+        throw err;\n+      }\n+\n+      // Handle the case where \"\\r\\n\" straddles the buffer.\n+      if (\n+        !this.eof &&\n+        partial.byteLength > 0 &&\n+        partial[partial.byteLength - 1] === CR\n+      ) {\n+        // Put the '\\r' back on buf and drop it from line.\n+        // Let the next call to ReadLine check for \"\\r\\n\".\n+        assert(this.r > 0, \"bufio: tried to rewind past start of buffer\");\n+        this.r--;\n+        partial = partial.subarray(0, partial.byteLength - 1);\n+      }\n+\n+      return { line: partial, more: !this.eof };\n+    }\n+\n+    if (line === null) {\n+      return null;\n+    }\n+\n+    if (line.byteLength === 0) {\n+      return { line, more: false };\n+    }\n+\n+    if (line[line.byteLength - 1] == LF) {\n+      let drop = 1;\n+      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {\n+        drop = 2;\n+      }\n+      line = line.subarray(0, line.byteLength - drop);\n+    }\n+    return { line, more: false };\n+  }\n+\n+  /** `readSlice()` reads until the first occurrence of `delim` in the input,\n+   * returning a slice pointing at the bytes in the buffer. The bytes stop\n+   * being valid at the next read.\n+   *\n+   * If `readSlice()` encounters an error before finding a delimiter, or the\n+   * buffer fills without finding a delimiter, it throws an error with a\n+   * `partial` property that contains the entire buffer.\n+   *\n+   * If `readSlice()` encounters the end of the underlying stream and there are\n+   * any bytes left in the buffer, the rest of the buffer is returned. In other\n+   * words, EOF is always treated as a delimiter. Once the buffer is empty,\n+   * it returns `null`.\n+   *\n+   * Because the data returned from `readSlice()` will be overwritten by the\n+   * next I/O operation, most clients should use `readString()` instead.\n+   */\n+  readSlice(delim: number): Uint8Array | null {\n+    let s = 0; // search start index\n+    let slice: Uint8Array | undefined;\n+\n+    while (true) {\n+      // Search buffer.\n+      let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);\n+      if (i >= 0) {\n+        i += s;\n+        slice = this.buf.subarray(this.r, this.r + i + 1);\n+        this.r += i + 1;\n+        break;\n+      }\n+\n+      // EOF?\n+      if (this.eof) {\n+        if (this.r === this.w) {\n+          return null;\n+        }\n+        slice = this.buf.subarray(this.r, this.w);\n+        this.r = this.w;\n+        break;\n+      }\n+\n+      // Buffer full?\n+      if (this.buffered() >= this.buf.byteLength) {\n+        this.r = this.w;\n+        // #4521 The internal buffer should not be reused across reads because it causes corruption of data.\n+        const oldbuf = this.buf;\n+        const newbuf = this.buf.slice(0);\n+        this.buf = newbuf;\n+        throw new BufferFullError(oldbuf);\n+      }\n+\n+      s = this.w - this.r; // do not rescan area we scanned before\n+\n+      // Buffer is not full.\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = slice;\n+        throw err;\n+      }\n+    }\n+\n+    // Handle last byte, if any.\n+    // const i = slice.byteLength - 1;\n+    // if (i >= 0) {\n+    //   this.lastByte = slice[i];\n+    //   this.lastCharSize = -1\n+    // }\n+\n+    return slice;\n+  }\n+\n+  /** `peek()` returns the next `n` bytes without advancing the reader. The\n+   * bytes stop being valid at the next read call.\n+   *\n+   * When the end of the underlying stream is reached, but there are unread\n+   * bytes left in the buffer, those bytes are returned. If there are no bytes\n+   * left in the buffer, it returns `null`.\n+   *\n+   * If an error is encountered before `n` bytes are available, `peek()` throws\n+   * an error with the `partial` property set to a slice of the buffer that\n+   * contains the bytes that were available before the error occurred.\n+   */\n+  peek(n: number): Uint8Array | null {\n+    if (n < 0) {\n+      throw Error(\"negative count\");\n+    }\n+\n+    let avail = this.w - this.r;\n+    while (avail < n && avail < this.buf.byteLength && !this.eof) {\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = this.buf.subarray(this.r, this.w);\n+        throw err;\n+      }\n+      avail = this.w - this.r;\n+    }\n+\n+    if (avail === 0 && this.eof) {\n+      return null;\n+    } else if (avail < n && this.eof) {\n+      return this.buf.subarray(this.r, this.r + avail);\n+    } else if (avail < n) {\n+      throw new BufferFullError(this.buf.subarray(this.r, this.w));\n+    }\n+\n+    return this.buf.subarray(this.r, this.r + n);\n+  }\n+}\n+",
        "comment_created_at": "2020-06-08T14:52:57+00:00",
        "comment_author": "ry",
        "comment_body": "I'm not so happy with having a bunch of very technical duplicated code like this... it's very difficult to keep in-sync with the async version and thus quite prone to bugs.",
        "pr_file_module": null
      },
      {
        "comment_id": "436907370",
        "repo_full_name": "denoland/deno",
        "pr_number": 6171,
        "pr_file": "std/io/bufio.ts",
        "discussion_id": "436769885",
        "commented_code": "@@ -405,6 +406,375 @@ export class BufReader implements Reader {\n   }\n }\n \n+/** BufReaderSync implements buffering for a ReaderSync object. */\n+export class BufReaderSync implements ReaderSync {\n+  private buf!: Uint8Array;\n+  private rd!: ReaderSync; // Reader provided by caller.\n+  private r = 0; // buf read position.\n+  private w = 0; // buf write position.\n+  private eof = false;\n+  // private lastByte: number;\n+  // private lastCharSize: number;\n+\n+  /** return new BufReaderSync unless r is BufReaderSync */\n+  static create(r: ReaderSync, size: number = DEFAULT_BUF_SIZE): BufReaderSync {\n+    return r instanceof BufReaderSync ? r : new BufReaderSync(r, size);\n+  }\n+\n+  constructor(rd: ReaderSync, size: number = DEFAULT_BUF_SIZE) {\n+    if (size < MIN_BUF_SIZE) {\n+      size = MIN_BUF_SIZE;\n+    }\n+    this._reset(new Uint8Array(size), rd);\n+  }\n+\n+  /** Returns the size of the underlying buffer in bytes. */\n+  size(): number {\n+    return this.buf.byteLength;\n+  }\n+\n+  buffered(): number {\n+    return this.w - this.r;\n+  }\n+\n+  // Reads a new chunk into the buffer.\n+  private _fill(): void {\n+    // Slide existing data to beginning.\n+    if (this.r > 0) {\n+      this.buf.copyWithin(0, this.r, this.w);\n+      this.w -= this.r;\n+      this.r = 0;\n+    }\n+\n+    if (this.w >= this.buf.byteLength) {\n+      throw Error(\"bufio: tried to fill full buffer\");\n+    }\n+\n+    // Read new data: try a limited number of times.\n+    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {\n+      const rr = this.rd.readSync(this.buf.subarray(this.w));\n+      if (rr === null) {\n+        this.eof = true;\n+        return;\n+      }\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+      if (rr > 0) {\n+        return;\n+      }\n+    }\n+\n+    throw new Error(\n+      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`\n+    );\n+  }\n+\n+  /** Discards any buffered data, resets all state, and switches\n+   * the buffered reader to read from r.\n+   */\n+  reset(r: ReaderSync): void {\n+    this._reset(this.buf, r);\n+  }\n+\n+  private _reset(buf: Uint8Array, rd: ReaderSync): void {\n+    this.buf = buf;\n+    this.rd = rd;\n+    this.eof = false;\n+    // this.lastByte = -1;\n+    // this.lastCharSize = -1;\n+  }\n+\n+  /** reads data into p.\n+   * It returns the number of bytes read into p.\n+   * The bytes are taken from at most one Read on the underlying Reader,\n+   * hence n may be less than len(p).\n+   * To read exactly len(p) bytes, use io.ReadFull(b, p).\n+   */\n+  readSync(p: Uint8Array): number | null {\n+    let rr: number | null = p.byteLength;\n+    if (p.byteLength === 0) return rr;\n+\n+    if (this.r === this.w) {\n+      if (p.byteLength >= this.buf.byteLength) {\n+        // Large read, empty buffer.\n+        // Read directly into p to avoid copy.\n+        const rr = this.rd.readSync(p);\n+        const nread = rr ?? 0;\n+        assert(nread >= 0, \"negative read\");\n+        // if (rr.nread > 0) {\n+        //   this.lastByte = p[rr.nread - 1];\n+        //   this.lastCharSize = -1;\n+        // }\n+        return rr;\n+      }\n+\n+      // One read.\n+      // Do not use this.fill, which will loop.\n+      this.r = 0;\n+      this.w = 0;\n+      rr = this.rd.readSync(this.buf);\n+      if (rr === 0 || rr === null) return rr;\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+    }\n+\n+    // copy as much as we can\n+    const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);\n+    this.r += copied;\n+    // this.lastByte = this.buf[this.r - 1];\n+    // this.lastCharSize = -1;\n+    return copied;\n+  }\n+\n+  /** reads exactly `p.length` bytes into `p`.\n+   *\n+   * If successful, `p` is returned.\n+   *\n+   * If the end of the underlying stream has been reached, and there are no more\n+   * bytes available in the buffer, `readFull()` returns `null` instead.\n+   *\n+   * An error is thrown if some bytes could be read, but not enough to fill `p`\n+   * entirely before the underlying stream reported an error or EOF. Any error\n+   * thrown will have a `partial` property that indicates the slice of the\n+   * buffer that has been successfully filled with data.\n+   *\n+   * Ported from https://golang.org/pkg/io/#ReadFull\n+   */\n+  readFull(p: Uint8Array): Uint8Array | null {\n+    let bytesRead = 0;\n+    while (bytesRead < p.length) {\n+      try {\n+        const rr = this.readSync(p.subarray(bytesRead));\n+        if (rr === null) {\n+          if (bytesRead === 0) {\n+            return null;\n+          } else {\n+            throw new PartialReadError();\n+          }\n+        }\n+        bytesRead += rr;\n+      } catch (err) {\n+        err.partial = p.subarray(0, bytesRead);\n+        throw err;\n+      }\n+    }\n+    return p;\n+  }\n+\n+  /** Returns the next byte [0, 255] or `null`. */\n+  readByte(): number | null {\n+    while (this.r === this.w) {\n+      if (this.eof) return null;\n+      this._fill(); // buffer is empty.\n+    }\n+    const c = this.buf[this.r];\n+    this.r++;\n+    // this.lastByte = c;\n+    return c;\n+  }\n+\n+  /** readString() reads until the first occurrence of delim in the input,\n+   * returning a string containing the data up to and including the delimiter.\n+   * If ReadString encounters an error before finding a delimiter,\n+   * it returns the data read before the error and the error itself\n+   * (often `null`).\n+   * ReadString returns err != nil if and only if the returned data does not end\n+   * in delim.\n+   * For simple uses, a Scanner may be more convenient.\n+   */\n+  readString(delim: string): string | null {\n+    if (delim.length !== 1) {\n+      throw new Error(\"Delimiter should be a single character\");\n+    }\n+    const buffer = this.readSlice(delim.charCodeAt(0));\n+    if (buffer === null) return null;\n+    return new TextDecoder().decode(buffer);\n+  }\n+\n+  /** `readLine()` is a low-level line-reading primitive. Most callers should\n+   * use `readString('\\n')` instead or use a Scanner.\n+   *\n+   * `readLine()` tries to return a single line, not including the end-of-line\n+   * bytes. If the line was too long for the buffer then `more` is set and the\n+   * beginning of the line is returned. The rest of the line will be returned\n+   * from future calls. `more` will be false when returning the last fragment\n+   * of the line. The returned buffer is only valid until the next call to\n+   * `readLine()`.\n+   *\n+   * The text returned from ReadLine does not include the line end (\"\\r\\n\" or\n+   * \"\\n\").\n+   *\n+   * When the end of the underlying stream is reached, the final bytes in the\n+   * stream are returned. No indication or error is given if the input ends\n+   * without a final line end. When there are no more trailing bytes to read,\n+   * `readLine()` returns `null`.\n+   *\n+   * Calling `unreadByte()` after `readLine()` will always unread the last byte\n+   * read (possibly a character belonging to the line end) even if that byte is\n+   * not part of the line returned by `readLine()`.\n+   */\n+  readLine(): ReadLineResult | null {\n+    let line: Uint8Array | null;\n+\n+    try {\n+      line = this.readSlice(LF);\n+    } catch (err) {\n+      let { partial } = err;\n+      assert(\n+        partial instanceof Uint8Array,\n+        \"bufio: caught error from `readSlice()` without `partial` property\"\n+      );\n+\n+      // Don't throw if `readSlice()` failed with `BufferFullError`, instead we\n+      // just return whatever is available and set the `more` flag.\n+      if (!(err instanceof BufferFullError)) {\n+        throw err;\n+      }\n+\n+      // Handle the case where \"\\r\\n\" straddles the buffer.\n+      if (\n+        !this.eof &&\n+        partial.byteLength > 0 &&\n+        partial[partial.byteLength - 1] === CR\n+      ) {\n+        // Put the '\\r' back on buf and drop it from line.\n+        // Let the next call to ReadLine check for \"\\r\\n\".\n+        assert(this.r > 0, \"bufio: tried to rewind past start of buffer\");\n+        this.r--;\n+        partial = partial.subarray(0, partial.byteLength - 1);\n+      }\n+\n+      return { line: partial, more: !this.eof };\n+    }\n+\n+    if (line === null) {\n+      return null;\n+    }\n+\n+    if (line.byteLength === 0) {\n+      return { line, more: false };\n+    }\n+\n+    if (line[line.byteLength - 1] == LF) {\n+      let drop = 1;\n+      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {\n+        drop = 2;\n+      }\n+      line = line.subarray(0, line.byteLength - drop);\n+    }\n+    return { line, more: false };\n+  }\n+\n+  /** `readSlice()` reads until the first occurrence of `delim` in the input,\n+   * returning a slice pointing at the bytes in the buffer. The bytes stop\n+   * being valid at the next read.\n+   *\n+   * If `readSlice()` encounters an error before finding a delimiter, or the\n+   * buffer fills without finding a delimiter, it throws an error with a\n+   * `partial` property that contains the entire buffer.\n+   *\n+   * If `readSlice()` encounters the end of the underlying stream and there are\n+   * any bytes left in the buffer, the rest of the buffer is returned. In other\n+   * words, EOF is always treated as a delimiter. Once the buffer is empty,\n+   * it returns `null`.\n+   *\n+   * Because the data returned from `readSlice()` will be overwritten by the\n+   * next I/O operation, most clients should use `readString()` instead.\n+   */\n+  readSlice(delim: number): Uint8Array | null {\n+    let s = 0; // search start index\n+    let slice: Uint8Array | undefined;\n+\n+    while (true) {\n+      // Search buffer.\n+      let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);\n+      if (i >= 0) {\n+        i += s;\n+        slice = this.buf.subarray(this.r, this.r + i + 1);\n+        this.r += i + 1;\n+        break;\n+      }\n+\n+      // EOF?\n+      if (this.eof) {\n+        if (this.r === this.w) {\n+          return null;\n+        }\n+        slice = this.buf.subarray(this.r, this.w);\n+        this.r = this.w;\n+        break;\n+      }\n+\n+      // Buffer full?\n+      if (this.buffered() >= this.buf.byteLength) {\n+        this.r = this.w;\n+        // #4521 The internal buffer should not be reused across reads because it causes corruption of data.\n+        const oldbuf = this.buf;\n+        const newbuf = this.buf.slice(0);\n+        this.buf = newbuf;\n+        throw new BufferFullError(oldbuf);\n+      }\n+\n+      s = this.w - this.r; // do not rescan area we scanned before\n+\n+      // Buffer is not full.\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = slice;\n+        throw err;\n+      }\n+    }\n+\n+    // Handle last byte, if any.\n+    // const i = slice.byteLength - 1;\n+    // if (i >= 0) {\n+    //   this.lastByte = slice[i];\n+    //   this.lastCharSize = -1\n+    // }\n+\n+    return slice;\n+  }\n+\n+  /** `peek()` returns the next `n` bytes without advancing the reader. The\n+   * bytes stop being valid at the next read call.\n+   *\n+   * When the end of the underlying stream is reached, but there are unread\n+   * bytes left in the buffer, those bytes are returned. If there are no bytes\n+   * left in the buffer, it returns `null`.\n+   *\n+   * If an error is encountered before `n` bytes are available, `peek()` throws\n+   * an error with the `partial` property set to a slice of the buffer that\n+   * contains the bytes that were available before the error occurred.\n+   */\n+  peek(n: number): Uint8Array | null {\n+    if (n < 0) {\n+      throw Error(\"negative count\");\n+    }\n+\n+    let avail = this.w - this.r;\n+    while (avail < n && avail < this.buf.byteLength && !this.eof) {\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = this.buf.subarray(this.r, this.w);\n+        throw err;\n+      }\n+      avail = this.w - this.r;\n+    }\n+\n+    if (avail === 0 && this.eof) {\n+      return null;\n+    } else if (avail < n && this.eof) {\n+      return this.buf.subarray(this.r, this.r + avail);\n+    } else if (avail < n) {\n+      throw new BufferFullError(this.buf.subarray(this.r, this.w));\n+    }\n+\n+    return this.buf.subarray(this.r, this.r + n);\n+  }\n+}\n+",
        "comment_created_at": "2020-06-08T18:26:11+00:00",
        "comment_author": "ccheng",
        "comment_body": "I wasn't super happy with that either. There are duplicated functions whose difference is one awaited call...  So two thoughts:\r\n\r\n(1) Factoring out some common sync code is an alternative.  But there would be more function calls, some in loops.  It could possibly impact performance with function call overhead, but maybe doesn't matter too much because it's compared to IO?  If that's ok, I can do that.\r\n\r\n(2) Keep sync and async in separate files.  I initially had them in separate files for easy diff'ing.  I saw `BufWriterSync` was previously added into `bufio.ts`, so I went the single file route.  I'd like to make them separate files if that's ok.",
        "pr_file_module": null
      },
      {
        "comment_id": "437011781",
        "repo_full_name": "denoland/deno",
        "pr_number": 6171,
        "pr_file": "std/io/bufio.ts",
        "discussion_id": "436769885",
        "commented_code": "@@ -405,6 +406,375 @@ export class BufReader implements Reader {\n   }\n }\n \n+/** BufReaderSync implements buffering for a ReaderSync object. */\n+export class BufReaderSync implements ReaderSync {\n+  private buf!: Uint8Array;\n+  private rd!: ReaderSync; // Reader provided by caller.\n+  private r = 0; // buf read position.\n+  private w = 0; // buf write position.\n+  private eof = false;\n+  // private lastByte: number;\n+  // private lastCharSize: number;\n+\n+  /** return new BufReaderSync unless r is BufReaderSync */\n+  static create(r: ReaderSync, size: number = DEFAULT_BUF_SIZE): BufReaderSync {\n+    return r instanceof BufReaderSync ? r : new BufReaderSync(r, size);\n+  }\n+\n+  constructor(rd: ReaderSync, size: number = DEFAULT_BUF_SIZE) {\n+    if (size < MIN_BUF_SIZE) {\n+      size = MIN_BUF_SIZE;\n+    }\n+    this._reset(new Uint8Array(size), rd);\n+  }\n+\n+  /** Returns the size of the underlying buffer in bytes. */\n+  size(): number {\n+    return this.buf.byteLength;\n+  }\n+\n+  buffered(): number {\n+    return this.w - this.r;\n+  }\n+\n+  // Reads a new chunk into the buffer.\n+  private _fill(): void {\n+    // Slide existing data to beginning.\n+    if (this.r > 0) {\n+      this.buf.copyWithin(0, this.r, this.w);\n+      this.w -= this.r;\n+      this.r = 0;\n+    }\n+\n+    if (this.w >= this.buf.byteLength) {\n+      throw Error(\"bufio: tried to fill full buffer\");\n+    }\n+\n+    // Read new data: try a limited number of times.\n+    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {\n+      const rr = this.rd.readSync(this.buf.subarray(this.w));\n+      if (rr === null) {\n+        this.eof = true;\n+        return;\n+      }\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+      if (rr > 0) {\n+        return;\n+      }\n+    }\n+\n+    throw new Error(\n+      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`\n+    );\n+  }\n+\n+  /** Discards any buffered data, resets all state, and switches\n+   * the buffered reader to read from r.\n+   */\n+  reset(r: ReaderSync): void {\n+    this._reset(this.buf, r);\n+  }\n+\n+  private _reset(buf: Uint8Array, rd: ReaderSync): void {\n+    this.buf = buf;\n+    this.rd = rd;\n+    this.eof = false;\n+    // this.lastByte = -1;\n+    // this.lastCharSize = -1;\n+  }\n+\n+  /** reads data into p.\n+   * It returns the number of bytes read into p.\n+   * The bytes are taken from at most one Read on the underlying Reader,\n+   * hence n may be less than len(p).\n+   * To read exactly len(p) bytes, use io.ReadFull(b, p).\n+   */\n+  readSync(p: Uint8Array): number | null {\n+    let rr: number | null = p.byteLength;\n+    if (p.byteLength === 0) return rr;\n+\n+    if (this.r === this.w) {\n+      if (p.byteLength >= this.buf.byteLength) {\n+        // Large read, empty buffer.\n+        // Read directly into p to avoid copy.\n+        const rr = this.rd.readSync(p);\n+        const nread = rr ?? 0;\n+        assert(nread >= 0, \"negative read\");\n+        // if (rr.nread > 0) {\n+        //   this.lastByte = p[rr.nread - 1];\n+        //   this.lastCharSize = -1;\n+        // }\n+        return rr;\n+      }\n+\n+      // One read.\n+      // Do not use this.fill, which will loop.\n+      this.r = 0;\n+      this.w = 0;\n+      rr = this.rd.readSync(this.buf);\n+      if (rr === 0 || rr === null) return rr;\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+    }\n+\n+    // copy as much as we can\n+    const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);\n+    this.r += copied;\n+    // this.lastByte = this.buf[this.r - 1];\n+    // this.lastCharSize = -1;\n+    return copied;\n+  }\n+\n+  /** reads exactly `p.length` bytes into `p`.\n+   *\n+   * If successful, `p` is returned.\n+   *\n+   * If the end of the underlying stream has been reached, and there are no more\n+   * bytes available in the buffer, `readFull()` returns `null` instead.\n+   *\n+   * An error is thrown if some bytes could be read, but not enough to fill `p`\n+   * entirely before the underlying stream reported an error or EOF. Any error\n+   * thrown will have a `partial` property that indicates the slice of the\n+   * buffer that has been successfully filled with data.\n+   *\n+   * Ported from https://golang.org/pkg/io/#ReadFull\n+   */\n+  readFull(p: Uint8Array): Uint8Array | null {\n+    let bytesRead = 0;\n+    while (bytesRead < p.length) {\n+      try {\n+        const rr = this.readSync(p.subarray(bytesRead));\n+        if (rr === null) {\n+          if (bytesRead === 0) {\n+            return null;\n+          } else {\n+            throw new PartialReadError();\n+          }\n+        }\n+        bytesRead += rr;\n+      } catch (err) {\n+        err.partial = p.subarray(0, bytesRead);\n+        throw err;\n+      }\n+    }\n+    return p;\n+  }\n+\n+  /** Returns the next byte [0, 255] or `null`. */\n+  readByte(): number | null {\n+    while (this.r === this.w) {\n+      if (this.eof) return null;\n+      this._fill(); // buffer is empty.\n+    }\n+    const c = this.buf[this.r];\n+    this.r++;\n+    // this.lastByte = c;\n+    return c;\n+  }\n+\n+  /** readString() reads until the first occurrence of delim in the input,\n+   * returning a string containing the data up to and including the delimiter.\n+   * If ReadString encounters an error before finding a delimiter,\n+   * it returns the data read before the error and the error itself\n+   * (often `null`).\n+   * ReadString returns err != nil if and only if the returned data does not end\n+   * in delim.\n+   * For simple uses, a Scanner may be more convenient.\n+   */\n+  readString(delim: string): string | null {\n+    if (delim.length !== 1) {\n+      throw new Error(\"Delimiter should be a single character\");\n+    }\n+    const buffer = this.readSlice(delim.charCodeAt(0));\n+    if (buffer === null) return null;\n+    return new TextDecoder().decode(buffer);\n+  }\n+\n+  /** `readLine()` is a low-level line-reading primitive. Most callers should\n+   * use `readString('\\n')` instead or use a Scanner.\n+   *\n+   * `readLine()` tries to return a single line, not including the end-of-line\n+   * bytes. If the line was too long for the buffer then `more` is set and the\n+   * beginning of the line is returned. The rest of the line will be returned\n+   * from future calls. `more` will be false when returning the last fragment\n+   * of the line. The returned buffer is only valid until the next call to\n+   * `readLine()`.\n+   *\n+   * The text returned from ReadLine does not include the line end (\"\\r\\n\" or\n+   * \"\\n\").\n+   *\n+   * When the end of the underlying stream is reached, the final bytes in the\n+   * stream are returned. No indication or error is given if the input ends\n+   * without a final line end. When there are no more trailing bytes to read,\n+   * `readLine()` returns `null`.\n+   *\n+   * Calling `unreadByte()` after `readLine()` will always unread the last byte\n+   * read (possibly a character belonging to the line end) even if that byte is\n+   * not part of the line returned by `readLine()`.\n+   */\n+  readLine(): ReadLineResult | null {\n+    let line: Uint8Array | null;\n+\n+    try {\n+      line = this.readSlice(LF);\n+    } catch (err) {\n+      let { partial } = err;\n+      assert(\n+        partial instanceof Uint8Array,\n+        \"bufio: caught error from `readSlice()` without `partial` property\"\n+      );\n+\n+      // Don't throw if `readSlice()` failed with `BufferFullError`, instead we\n+      // just return whatever is available and set the `more` flag.\n+      if (!(err instanceof BufferFullError)) {\n+        throw err;\n+      }\n+\n+      // Handle the case where \"\\r\\n\" straddles the buffer.\n+      if (\n+        !this.eof &&\n+        partial.byteLength > 0 &&\n+        partial[partial.byteLength - 1] === CR\n+      ) {\n+        // Put the '\\r' back on buf and drop it from line.\n+        // Let the next call to ReadLine check for \"\\r\\n\".\n+        assert(this.r > 0, \"bufio: tried to rewind past start of buffer\");\n+        this.r--;\n+        partial = partial.subarray(0, partial.byteLength - 1);\n+      }\n+\n+      return { line: partial, more: !this.eof };\n+    }\n+\n+    if (line === null) {\n+      return null;\n+    }\n+\n+    if (line.byteLength === 0) {\n+      return { line, more: false };\n+    }\n+\n+    if (line[line.byteLength - 1] == LF) {\n+      let drop = 1;\n+      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {\n+        drop = 2;\n+      }\n+      line = line.subarray(0, line.byteLength - drop);\n+    }\n+    return { line, more: false };\n+  }\n+\n+  /** `readSlice()` reads until the first occurrence of `delim` in the input,\n+   * returning a slice pointing at the bytes in the buffer. The bytes stop\n+   * being valid at the next read.\n+   *\n+   * If `readSlice()` encounters an error before finding a delimiter, or the\n+   * buffer fills without finding a delimiter, it throws an error with a\n+   * `partial` property that contains the entire buffer.\n+   *\n+   * If `readSlice()` encounters the end of the underlying stream and there are\n+   * any bytes left in the buffer, the rest of the buffer is returned. In other\n+   * words, EOF is always treated as a delimiter. Once the buffer is empty,\n+   * it returns `null`.\n+   *\n+   * Because the data returned from `readSlice()` will be overwritten by the\n+   * next I/O operation, most clients should use `readString()` instead.\n+   */\n+  readSlice(delim: number): Uint8Array | null {\n+    let s = 0; // search start index\n+    let slice: Uint8Array | undefined;\n+\n+    while (true) {\n+      // Search buffer.\n+      let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);\n+      if (i >= 0) {\n+        i += s;\n+        slice = this.buf.subarray(this.r, this.r + i + 1);\n+        this.r += i + 1;\n+        break;\n+      }\n+\n+      // EOF?\n+      if (this.eof) {\n+        if (this.r === this.w) {\n+          return null;\n+        }\n+        slice = this.buf.subarray(this.r, this.w);\n+        this.r = this.w;\n+        break;\n+      }\n+\n+      // Buffer full?\n+      if (this.buffered() >= this.buf.byteLength) {\n+        this.r = this.w;\n+        // #4521 The internal buffer should not be reused across reads because it causes corruption of data.\n+        const oldbuf = this.buf;\n+        const newbuf = this.buf.slice(0);\n+        this.buf = newbuf;\n+        throw new BufferFullError(oldbuf);\n+      }\n+\n+      s = this.w - this.r; // do not rescan area we scanned before\n+\n+      // Buffer is not full.\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = slice;\n+        throw err;\n+      }\n+    }\n+\n+    // Handle last byte, if any.\n+    // const i = slice.byteLength - 1;\n+    // if (i >= 0) {\n+    //   this.lastByte = slice[i];\n+    //   this.lastCharSize = -1\n+    // }\n+\n+    return slice;\n+  }\n+\n+  /** `peek()` returns the next `n` bytes without advancing the reader. The\n+   * bytes stop being valid at the next read call.\n+   *\n+   * When the end of the underlying stream is reached, but there are unread\n+   * bytes left in the buffer, those bytes are returned. If there are no bytes\n+   * left in the buffer, it returns `null`.\n+   *\n+   * If an error is encountered before `n` bytes are available, `peek()` throws\n+   * an error with the `partial` property set to a slice of the buffer that\n+   * contains the bytes that were available before the error occurred.\n+   */\n+  peek(n: number): Uint8Array | null {\n+    if (n < 0) {\n+      throw Error(\"negative count\");\n+    }\n+\n+    let avail = this.w - this.r;\n+    while (avail < n && avail < this.buf.byteLength && !this.eof) {\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = this.buf.subarray(this.r, this.w);\n+        throw err;\n+      }\n+      avail = this.w - this.r;\n+    }\n+\n+    if (avail === 0 && this.eof) {\n+      return null;\n+    } else if (avail < n && this.eof) {\n+      return this.buf.subarray(this.r, this.r + avail);\n+    } else if (avail < n) {\n+      throw new BufferFullError(this.buf.subarray(this.r, this.w));\n+    }\n+\n+    return this.buf.subarray(this.r, this.r + n);\n+  }\n+}\n+",
        "comment_created_at": "2020-06-08T21:28:30+00:00",
        "comment_author": "ry",
        "comment_body": "It's not immediately obvious to me what the right thing to do here is. I'll try to dig into this later...",
        "pr_file_module": null
      },
      {
        "comment_id": "439575627",
        "repo_full_name": "denoland/deno",
        "pr_number": 6171,
        "pr_file": "std/io/bufio.ts",
        "discussion_id": "436769885",
        "commented_code": "@@ -405,6 +406,375 @@ export class BufReader implements Reader {\n   }\n }\n \n+/** BufReaderSync implements buffering for a ReaderSync object. */\n+export class BufReaderSync implements ReaderSync {\n+  private buf!: Uint8Array;\n+  private rd!: ReaderSync; // Reader provided by caller.\n+  private r = 0; // buf read position.\n+  private w = 0; // buf write position.\n+  private eof = false;\n+  // private lastByte: number;\n+  // private lastCharSize: number;\n+\n+  /** return new BufReaderSync unless r is BufReaderSync */\n+  static create(r: ReaderSync, size: number = DEFAULT_BUF_SIZE): BufReaderSync {\n+    return r instanceof BufReaderSync ? r : new BufReaderSync(r, size);\n+  }\n+\n+  constructor(rd: ReaderSync, size: number = DEFAULT_BUF_SIZE) {\n+    if (size < MIN_BUF_SIZE) {\n+      size = MIN_BUF_SIZE;\n+    }\n+    this._reset(new Uint8Array(size), rd);\n+  }\n+\n+  /** Returns the size of the underlying buffer in bytes. */\n+  size(): number {\n+    return this.buf.byteLength;\n+  }\n+\n+  buffered(): number {\n+    return this.w - this.r;\n+  }\n+\n+  // Reads a new chunk into the buffer.\n+  private _fill(): void {\n+    // Slide existing data to beginning.\n+    if (this.r > 0) {\n+      this.buf.copyWithin(0, this.r, this.w);\n+      this.w -= this.r;\n+      this.r = 0;\n+    }\n+\n+    if (this.w >= this.buf.byteLength) {\n+      throw Error(\"bufio: tried to fill full buffer\");\n+    }\n+\n+    // Read new data: try a limited number of times.\n+    for (let i = MAX_CONSECUTIVE_EMPTY_READS; i > 0; i--) {\n+      const rr = this.rd.readSync(this.buf.subarray(this.w));\n+      if (rr === null) {\n+        this.eof = true;\n+        return;\n+      }\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+      if (rr > 0) {\n+        return;\n+      }\n+    }\n+\n+    throw new Error(\n+      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`\n+    );\n+  }\n+\n+  /** Discards any buffered data, resets all state, and switches\n+   * the buffered reader to read from r.\n+   */\n+  reset(r: ReaderSync): void {\n+    this._reset(this.buf, r);\n+  }\n+\n+  private _reset(buf: Uint8Array, rd: ReaderSync): void {\n+    this.buf = buf;\n+    this.rd = rd;\n+    this.eof = false;\n+    // this.lastByte = -1;\n+    // this.lastCharSize = -1;\n+  }\n+\n+  /** reads data into p.\n+   * It returns the number of bytes read into p.\n+   * The bytes are taken from at most one Read on the underlying Reader,\n+   * hence n may be less than len(p).\n+   * To read exactly len(p) bytes, use io.ReadFull(b, p).\n+   */\n+  readSync(p: Uint8Array): number | null {\n+    let rr: number | null = p.byteLength;\n+    if (p.byteLength === 0) return rr;\n+\n+    if (this.r === this.w) {\n+      if (p.byteLength >= this.buf.byteLength) {\n+        // Large read, empty buffer.\n+        // Read directly into p to avoid copy.\n+        const rr = this.rd.readSync(p);\n+        const nread = rr ?? 0;\n+        assert(nread >= 0, \"negative read\");\n+        // if (rr.nread > 0) {\n+        //   this.lastByte = p[rr.nread - 1];\n+        //   this.lastCharSize = -1;\n+        // }\n+        return rr;\n+      }\n+\n+      // One read.\n+      // Do not use this.fill, which will loop.\n+      this.r = 0;\n+      this.w = 0;\n+      rr = this.rd.readSync(this.buf);\n+      if (rr === 0 || rr === null) return rr;\n+      assert(rr >= 0, \"negative read\");\n+      this.w += rr;\n+    }\n+\n+    // copy as much as we can\n+    const copied = copyBytes(this.buf.subarray(this.r, this.w), p, 0);\n+    this.r += copied;\n+    // this.lastByte = this.buf[this.r - 1];\n+    // this.lastCharSize = -1;\n+    return copied;\n+  }\n+\n+  /** reads exactly `p.length` bytes into `p`.\n+   *\n+   * If successful, `p` is returned.\n+   *\n+   * If the end of the underlying stream has been reached, and there are no more\n+   * bytes available in the buffer, `readFull()` returns `null` instead.\n+   *\n+   * An error is thrown if some bytes could be read, but not enough to fill `p`\n+   * entirely before the underlying stream reported an error or EOF. Any error\n+   * thrown will have a `partial` property that indicates the slice of the\n+   * buffer that has been successfully filled with data.\n+   *\n+   * Ported from https://golang.org/pkg/io/#ReadFull\n+   */\n+  readFull(p: Uint8Array): Uint8Array | null {\n+    let bytesRead = 0;\n+    while (bytesRead < p.length) {\n+      try {\n+        const rr = this.readSync(p.subarray(bytesRead));\n+        if (rr === null) {\n+          if (bytesRead === 0) {\n+            return null;\n+          } else {\n+            throw new PartialReadError();\n+          }\n+        }\n+        bytesRead += rr;\n+      } catch (err) {\n+        err.partial = p.subarray(0, bytesRead);\n+        throw err;\n+      }\n+    }\n+    return p;\n+  }\n+\n+  /** Returns the next byte [0, 255] or `null`. */\n+  readByte(): number | null {\n+    while (this.r === this.w) {\n+      if (this.eof) return null;\n+      this._fill(); // buffer is empty.\n+    }\n+    const c = this.buf[this.r];\n+    this.r++;\n+    // this.lastByte = c;\n+    return c;\n+  }\n+\n+  /** readString() reads until the first occurrence of delim in the input,\n+   * returning a string containing the data up to and including the delimiter.\n+   * If ReadString encounters an error before finding a delimiter,\n+   * it returns the data read before the error and the error itself\n+   * (often `null`).\n+   * ReadString returns err != nil if and only if the returned data does not end\n+   * in delim.\n+   * For simple uses, a Scanner may be more convenient.\n+   */\n+  readString(delim: string): string | null {\n+    if (delim.length !== 1) {\n+      throw new Error(\"Delimiter should be a single character\");\n+    }\n+    const buffer = this.readSlice(delim.charCodeAt(0));\n+    if (buffer === null) return null;\n+    return new TextDecoder().decode(buffer);\n+  }\n+\n+  /** `readLine()` is a low-level line-reading primitive. Most callers should\n+   * use `readString('\\n')` instead or use a Scanner.\n+   *\n+   * `readLine()` tries to return a single line, not including the end-of-line\n+   * bytes. If the line was too long for the buffer then `more` is set and the\n+   * beginning of the line is returned. The rest of the line will be returned\n+   * from future calls. `more` will be false when returning the last fragment\n+   * of the line. The returned buffer is only valid until the next call to\n+   * `readLine()`.\n+   *\n+   * The text returned from ReadLine does not include the line end (\"\\r\\n\" or\n+   * \"\\n\").\n+   *\n+   * When the end of the underlying stream is reached, the final bytes in the\n+   * stream are returned. No indication or error is given if the input ends\n+   * without a final line end. When there are no more trailing bytes to read,\n+   * `readLine()` returns `null`.\n+   *\n+   * Calling `unreadByte()` after `readLine()` will always unread the last byte\n+   * read (possibly a character belonging to the line end) even if that byte is\n+   * not part of the line returned by `readLine()`.\n+   */\n+  readLine(): ReadLineResult | null {\n+    let line: Uint8Array | null;\n+\n+    try {\n+      line = this.readSlice(LF);\n+    } catch (err) {\n+      let { partial } = err;\n+      assert(\n+        partial instanceof Uint8Array,\n+        \"bufio: caught error from `readSlice()` without `partial` property\"\n+      );\n+\n+      // Don't throw if `readSlice()` failed with `BufferFullError`, instead we\n+      // just return whatever is available and set the `more` flag.\n+      if (!(err instanceof BufferFullError)) {\n+        throw err;\n+      }\n+\n+      // Handle the case where \"\\r\\n\" straddles the buffer.\n+      if (\n+        !this.eof &&\n+        partial.byteLength > 0 &&\n+        partial[partial.byteLength - 1] === CR\n+      ) {\n+        // Put the '\\r' back on buf and drop it from line.\n+        // Let the next call to ReadLine check for \"\\r\\n\".\n+        assert(this.r > 0, \"bufio: tried to rewind past start of buffer\");\n+        this.r--;\n+        partial = partial.subarray(0, partial.byteLength - 1);\n+      }\n+\n+      return { line: partial, more: !this.eof };\n+    }\n+\n+    if (line === null) {\n+      return null;\n+    }\n+\n+    if (line.byteLength === 0) {\n+      return { line, more: false };\n+    }\n+\n+    if (line[line.byteLength - 1] == LF) {\n+      let drop = 1;\n+      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {\n+        drop = 2;\n+      }\n+      line = line.subarray(0, line.byteLength - drop);\n+    }\n+    return { line, more: false };\n+  }\n+\n+  /** `readSlice()` reads until the first occurrence of `delim` in the input,\n+   * returning a slice pointing at the bytes in the buffer. The bytes stop\n+   * being valid at the next read.\n+   *\n+   * If `readSlice()` encounters an error before finding a delimiter, or the\n+   * buffer fills without finding a delimiter, it throws an error with a\n+   * `partial` property that contains the entire buffer.\n+   *\n+   * If `readSlice()` encounters the end of the underlying stream and there are\n+   * any bytes left in the buffer, the rest of the buffer is returned. In other\n+   * words, EOF is always treated as a delimiter. Once the buffer is empty,\n+   * it returns `null`.\n+   *\n+   * Because the data returned from `readSlice()` will be overwritten by the\n+   * next I/O operation, most clients should use `readString()` instead.\n+   */\n+  readSlice(delim: number): Uint8Array | null {\n+    let s = 0; // search start index\n+    let slice: Uint8Array | undefined;\n+\n+    while (true) {\n+      // Search buffer.\n+      let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);\n+      if (i >= 0) {\n+        i += s;\n+        slice = this.buf.subarray(this.r, this.r + i + 1);\n+        this.r += i + 1;\n+        break;\n+      }\n+\n+      // EOF?\n+      if (this.eof) {\n+        if (this.r === this.w) {\n+          return null;\n+        }\n+        slice = this.buf.subarray(this.r, this.w);\n+        this.r = this.w;\n+        break;\n+      }\n+\n+      // Buffer full?\n+      if (this.buffered() >= this.buf.byteLength) {\n+        this.r = this.w;\n+        // #4521 The internal buffer should not be reused across reads because it causes corruption of data.\n+        const oldbuf = this.buf;\n+        const newbuf = this.buf.slice(0);\n+        this.buf = newbuf;\n+        throw new BufferFullError(oldbuf);\n+      }\n+\n+      s = this.w - this.r; // do not rescan area we scanned before\n+\n+      // Buffer is not full.\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = slice;\n+        throw err;\n+      }\n+    }\n+\n+    // Handle last byte, if any.\n+    // const i = slice.byteLength - 1;\n+    // if (i >= 0) {\n+    //   this.lastByte = slice[i];\n+    //   this.lastCharSize = -1\n+    // }\n+\n+    return slice;\n+  }\n+\n+  /** `peek()` returns the next `n` bytes without advancing the reader. The\n+   * bytes stop being valid at the next read call.\n+   *\n+   * When the end of the underlying stream is reached, but there are unread\n+   * bytes left in the buffer, those bytes are returned. If there are no bytes\n+   * left in the buffer, it returns `null`.\n+   *\n+   * If an error is encountered before `n` bytes are available, `peek()` throws\n+   * an error with the `partial` property set to a slice of the buffer that\n+   * contains the bytes that were available before the error occurred.\n+   */\n+  peek(n: number): Uint8Array | null {\n+    if (n < 0) {\n+      throw Error(\"negative count\");\n+    }\n+\n+    let avail = this.w - this.r;\n+    while (avail < n && avail < this.buf.byteLength && !this.eof) {\n+      try {\n+        this._fill();\n+      } catch (err) {\n+        err.partial = this.buf.subarray(this.r, this.w);\n+        throw err;\n+      }\n+      avail = this.w - this.r;\n+    }\n+\n+    if (avail === 0 && this.eof) {\n+      return null;\n+    } else if (avail < n && this.eof) {\n+      return this.buf.subarray(this.r, this.r + avail);\n+    } else if (avail < n) {\n+      throw new BufferFullError(this.buf.subarray(this.r, this.w));\n+    }\n+\n+    return this.buf.subarray(this.r, this.r + n);\n+  }\n+}\n+",
        "comment_created_at": "2020-06-12T18:19:59+00:00",
        "comment_author": "ccheng",
        "comment_body": "I figured out a way to completely deduplicate all async/sync code between `BufReader`/`Sync` through an `AbstractBufReaderBase` that switches between sync/async calls... by working with promises instead of await.  It works!  How does that look?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1833506873",
    "pr_number": 26710,
    "pr_file": "ext/http/00_serve.ts",
    "created_at": "2024-11-07T23:38:18+00:00",
    "commented_code": "*/\n function mapToCallback(context, callback, onError) {\n   return async function (req) {\n-    // Get the response from the user-provided callback. If that fails, use onError. If that fails, return a fallback\n-    // 500 error.\n-    let innerRequest;\n-    let response;\n-    try {\n-      innerRequest = new InnerRequest(req, context);\n-      const request = fromInnerRequest(innerRequest, \"immutable\");\n-      innerRequest.request = request;\n-      response = await callback(\n-        request,\n-        new ServeHandlerInfo(innerRequest),\n-      );\n+    const asyncContext = getAsyncContext();\n+    setAsyncContext(context.asyncContext);\n \n-      // Throwing Error if the handler return value is not a Response class\n-      if (!ObjectPrototypeIsPrototypeOf(ResponsePrototype, response)) {\n-        throw new TypeError(\n-          \"Return value from serve handler must be a response or a promise resolving to a response\",\n-        );\n-      }\n-\n-      if (response.type === \"error\") {\n-        throw new TypeError(\n-          \"Return value from serve handler must not be an error response (like Response.error())\",\n+    try {",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1833506873",
        "repo_full_name": "denoland/deno",
        "pr_number": 26710,
        "pr_file": "ext/http/00_serve.ts",
        "discussion_id": "1833506873",
        "commented_code": "@@ -495,82 +501,89 @@ function fastSyncResponseOrStream(\n  */\n function mapToCallback(context, callback, onError) {\n   return async function (req) {\n-    // Get the response from the user-provided callback. If that fails, use onError. If that fails, return a fallback\n-    // 500 error.\n-    let innerRequest;\n-    let response;\n-    try {\n-      innerRequest = new InnerRequest(req, context);\n-      const request = fromInnerRequest(innerRequest, \"immutable\");\n-      innerRequest.request = request;\n-      response = await callback(\n-        request,\n-        new ServeHandlerInfo(innerRequest),\n-      );\n+    const asyncContext = getAsyncContext();\n+    setAsyncContext(context.asyncContext);\n \n-      // Throwing Error if the handler return value is not a Response class\n-      if (!ObjectPrototypeIsPrototypeOf(ResponsePrototype, response)) {\n-        throw new TypeError(\n-          \"Return value from serve handler must be a response or a promise resolving to a response\",\n-        );\n-      }\n-\n-      if (response.type === \"error\") {\n-        throw new TypeError(\n-          \"Return value from serve handler must not be an error response (like Response.error())\",\n+    try {",
        "comment_created_at": "2024-11-07T23:38:18+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Consider creating another function that is called inside `try {} finally {}` instead of inlining all of this logic here.",
        "pr_file_module": null
      }
    ]
  }
]