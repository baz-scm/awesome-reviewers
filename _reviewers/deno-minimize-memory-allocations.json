[
  {
    "discussion_id": "2130663412",
    "pr_number": 29609,
    "pr_file": "ext/process/lib.rs",
    "created_at": "2025-06-05T22:20:40+00:00",
    "commented_code": "#[cfg(windows)]\n   {\n+    let mut extra_pipe_rids = Vec::new();",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2130663412",
        "repo_full_name": "denoland/deno",
        "pr_number": 29609,
        "pr_file": "ext/process/lib.rs",
        "discussion_id": "2130663412",
        "commented_code": "@@ -529,6 +532,8 @@ fn create_command(\n \n   #[cfg(windows)]\n   {\n+    let mut extra_pipe_rids = Vec::new();",
        "comment_created_at": "2025-06-05T22:20:40+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Pre-allocate based on `args.extra_stdio.len()`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2127514010",
    "pr_number": 29586,
    "pr_file": "resolvers/node/resolution.rs",
    "created_at": "2025-06-04T21:58:30+00:00",
    "commented_code": "use crate::PackageJsonResolverRc;\n use crate::PathClean;\n \n-pub static DEFAULT_CONDITIONS: &[&str] = &[\"deno\", \"node\", \"import\"];\n-pub static REQUIRE_CONDITIONS: &[&str] = &[\"require\", \"node\"];\n-static TYPES_ONLY_CONDITIONS: &[&str] = &[\"types\"];\n-\n-#[allow(clippy::disallowed_types)]\n-type ConditionsFromResolutionModeFn = crate::sync::MaybeArc<\n-  dyn Fn(ResolutionMode) -> &'static [&'static str] + Send + Sync + 'static,\n->;\n-\n-#[derive(Default, Clone)]\n-pub struct ConditionsFromResolutionMode(Option<ConditionsFromResolutionModeFn>);\n+pub static DEFAULT_CONDITIONS: &[Cow<'static, str>] = &[\n+  Cow::Borrowed(\"deno\"),\n+  Cow::Borrowed(\"node\"),\n+  Cow::Borrowed(\"import\"),\n+];\n+pub static REQUIRE_CONDITIONS: &[Cow<'static, str>] =\n+  &[Cow::Borrowed(\"require\"), Cow::Borrowed(\"node\")];\n+static TYPES_ONLY_CONDITIONS: &[Cow<'static, str>] = &[Cow::Borrowed(\"types\")];\n+\n+#[derive(Debug, Clone)]\n+pub struct ConditionResolverOptions {\n+  pub conditions: Vec<Cow<'static, str>>,\n+  pub default_import_conditions: Vec<Cow<'static, str>>,\n+  pub default_require_conditions: Vec<Cow<'static, str>>,\n+}\n \n-impl Debug for ConditionsFromResolutionMode {\n-  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-    f.debug_struct(\"ConditionsFromResolutionMode\").finish()\n+impl Default for ConditionResolverOptions {\n+  fn default() -> Self {\n+    Self {\n+      conditions: Vec::new(),\n+      default_import_conditions: DEFAULT_CONDITIONS.to_vec(),\n+      default_require_conditions: REQUIRE_CONDITIONS.to_vec(),\n+    }\n   }\n }\n \n-impl ConditionsFromResolutionMode {\n-  pub fn new(func: ConditionsFromResolutionModeFn) -> Self {\n-    Self(Some(func))\n+#[derive(Debug, Default, Clone)]\n+pub struct ConditionResolver {\n+  options: ConditionResolverOptions,\n+}\n+\n+impl ConditionResolver {\n+  pub fn new(options: ConditionResolverOptions) -> Self {\n+    Self { options }\n   }\n \n-  fn resolve(\n+  pub fn resolve(\n     &self,\n     resolution_mode: ResolutionMode,\n-  ) -> &'static [&'static str] {\n-    match &self.0 {\n-      Some(func) => func(ResolutionMode::Import),\n-      None => resolution_mode.default_conditions(),\n-    }\n+  ) -> Vec<Cow<'static, str>> {\n+    let default_conditions = match resolution_mode {\n+      ResolutionMode::Import => &self.options.default_import_conditions,\n+      ResolutionMode::Require => &self.options.default_require_conditions,\n+    };\n+    self\n+      .options\n+      .conditions\n+      .iter()\n+      .chain(default_conditions)\n+      .cloned()\n+      .collect()",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2127514010",
        "repo_full_name": "denoland/deno",
        "pr_number": 29586,
        "pr_file": "resolvers/node/resolution.rs",
        "discussion_id": "2127514010",
        "commented_code": "@@ -61,37 +61,57 @@ use crate::NpmPackageFolderResolver;\n use crate::PackageJsonResolverRc;\n use crate::PathClean;\n \n-pub static DEFAULT_CONDITIONS: &[&str] = &[\"deno\", \"node\", \"import\"];\n-pub static REQUIRE_CONDITIONS: &[&str] = &[\"require\", \"node\"];\n-static TYPES_ONLY_CONDITIONS: &[&str] = &[\"types\"];\n-\n-#[allow(clippy::disallowed_types)]\n-type ConditionsFromResolutionModeFn = crate::sync::MaybeArc<\n-  dyn Fn(ResolutionMode) -> &'static [&'static str] + Send + Sync + 'static,\n->;\n-\n-#[derive(Default, Clone)]\n-pub struct ConditionsFromResolutionMode(Option<ConditionsFromResolutionModeFn>);\n+pub static DEFAULT_CONDITIONS: &[Cow<'static, str>] = &[\n+  Cow::Borrowed(\"deno\"),\n+  Cow::Borrowed(\"node\"),\n+  Cow::Borrowed(\"import\"),\n+];\n+pub static REQUIRE_CONDITIONS: &[Cow<'static, str>] =\n+  &[Cow::Borrowed(\"require\"), Cow::Borrowed(\"node\")];\n+static TYPES_ONLY_CONDITIONS: &[Cow<'static, str>] = &[Cow::Borrowed(\"types\")];\n+\n+#[derive(Debug, Clone)]\n+pub struct ConditionResolverOptions {\n+  pub conditions: Vec<Cow<'static, str>>,\n+  pub default_import_conditions: Vec<Cow<'static, str>>,\n+  pub default_require_conditions: Vec<Cow<'static, str>>,\n+}\n \n-impl Debug for ConditionsFromResolutionMode {\n-  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-    f.debug_struct(\"ConditionsFromResolutionMode\").finish()\n+impl Default for ConditionResolverOptions {\n+  fn default() -> Self {\n+    Self {\n+      conditions: Vec::new(),\n+      default_import_conditions: DEFAULT_CONDITIONS.to_vec(),\n+      default_require_conditions: REQUIRE_CONDITIONS.to_vec(),\n+    }\n   }\n }\n \n-impl ConditionsFromResolutionMode {\n-  pub fn new(func: ConditionsFromResolutionModeFn) -> Self {\n-    Self(Some(func))\n+#[derive(Debug, Default, Clone)]\n+pub struct ConditionResolver {\n+  options: ConditionResolverOptions,\n+}\n+\n+impl ConditionResolver {\n+  pub fn new(options: ConditionResolverOptions) -> Self {\n+    Self { options }\n   }\n \n-  fn resolve(\n+  pub fn resolve(\n     &self,\n     resolution_mode: ResolutionMode,\n-  ) -> &'static [&'static str] {\n-    match &self.0 {\n-      Some(func) => func(ResolutionMode::Import),\n-      None => resolution_mode.default_conditions(),\n-    }\n+  ) -> Vec<Cow<'static, str>> {\n+    let default_conditions = match resolution_mode {\n+      ResolutionMode::Import => &self.options.default_import_conditions,\n+      ResolutionMode::Require => &self.options.default_require_conditions,\n+    };\n+    self\n+      .options\n+      .conditions\n+      .iter()\n+      .chain(default_conditions)\n+      .cloned()\n+      .collect()",
        "comment_created_at": "2025-06-04T21:58:30+00:00",
        "comment_author": "dsherret",
        "comment_body": "Can we change this to do the allocations in the constructor by precomputing the two possible values? (and preferably avoid any allocations there when `self.options.conditions` is empty, though that's not as big of a deal) I think this could return a `&[Cow<'static, str>>]`\r\n\r\nSorry, this might seem nitpicky, but it's not really. I did a lot of work removing allocations from node resolution in order to make it faster.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1822607035",
    "pr_number": 26633,
    "pr_file": "cli/tools/lint/linter.rs",
    "created_at": "2024-10-30T13:18:51+00:00",
    "commented_code": "deno_ast::apply_text_changes(text_info.text_str(), quick_fixes);\n   Some(new_text)\n }\n+\n+#[derive(Debug, Default)]\n+pub struct FileMetrics {\n+  avg_line_length: f64,\n+  long_line_percentage: f64,\n+  whitespace_ratio: f64,\n+  has_source_map: bool,\n+  short_var_name_ratio: f64,\n+}\n+\n+pub fn is_minified_file(code: &str) -> bool {\n+  let mut metrics = FileMetrics::default();\n+\n+  // Split into non-empty lines\n+  let lines: Vec<&str> = code\n+    .lines()\n+    .map(str::trim)\n+    .filter(|line| !line.is_empty())\n+    .collect();",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1822607035",
        "repo_full_name": "denoland/deno",
        "pr_number": 26633,
        "pr_file": "cli/tools/lint/linter.rs",
        "discussion_id": "1822607035",
        "commented_code": "@@ -257,3 +266,105 @@ fn apply_lint_fixes(\n     deno_ast::apply_text_changes(text_info.text_str(), quick_fixes);\n   Some(new_text)\n }\n+\n+#[derive(Debug, Default)]\n+pub struct FileMetrics {\n+  avg_line_length: f64,\n+  long_line_percentage: f64,\n+  whitespace_ratio: f64,\n+  has_source_map: bool,\n+  short_var_name_ratio: f64,\n+}\n+\n+pub fn is_minified_file(code: &str) -> bool {\n+  let mut metrics = FileMetrics::default();\n+\n+  // Split into non-empty lines\n+  let lines: Vec<&str> = code\n+    .lines()\n+    .map(str::trim)\n+    .filter(|line| !line.is_empty())\n+    .collect();",
        "comment_created_at": "2024-10-30T13:18:51+00:00",
        "comment_author": "dsherret",
        "comment_body": "Seems like a lot of work and allocations. Maybe we should just do something that stops after X chars on the first line? (ex. read the first 400 chars and if there's no newline then it's probably minified or maybe read all the chars and if it's over X length and only a max of 2 lines then it's minified)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2033264263",
    "pr_number": 28765,
    "pr_file": "ext/node/ops/handle_wrap.rs",
    "created_at": "2025-04-08T13:57:25+00:00",
    "commented_code": "+// Copyright 2018-2025 the Deno authors. MIT license.\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+use deno_core::error::ResourceError;\n+use deno_core::op2;\n+use deno_core::v8;\n+use deno_core::GarbageCollected;\n+use deno_core::OpState;\n+use deno_core::ResourceId;\n+\n+pub struct AsyncId(i64);\n+\n+impl Default for AsyncId {\n+  // `kAsyncIdCounter` should start at `1` because that'll be the id the execution\n+  // context during bootstrap.\n+  fn default() -> Self {\n+    Self(1)\n+  }\n+}\n+\n+impl AsyncId {\n+  // Increment the internal id counter and return the value.\n+  fn next(&mut self) -> i64 {\n+    self.0 += 1;\n+    self.0\n+  }\n+}\n+\n+fn next_async_id(state: &mut OpState) -> i64 {\n+  let async_id = state.borrow_mut::<AsyncId>().next();\n+  async_id\n+}\n+\n+#[op2(fast)]\n+pub fn op_node_new_async_id(state: &mut OpState) -> f64 {\n+  next_async_id(state) as f64\n+}\n+\n+pub struct AsyncWrap {\n+  provider: i32,\n+  async_id: i64,\n+}\n+\n+impl GarbageCollected for AsyncWrap {}\n+\n+impl AsyncWrap {\n+  pub(crate) fn create(state: &mut OpState, provider: i32) -> Self {\n+    let async_id = next_async_id(state);\n+\n+    Self { provider, async_id }\n+  }\n+}\n+\n+#[op2(base)]\n+impl AsyncWrap {\n+  #[getter]\n+  fn provider(&self) -> i32 {\n+    self.provider\n+  }\n+\n+  #[fast]\n+  fn get_async_id(&self) -> f64 {\n+    self.async_id as f64\n+  }\n+\n+  #[fast]\n+  fn get_provider_type(&self) -> i32 {\n+    self.provider\n+  }\n+}\n+\n+pub struct HandleWrap {\n+  handle: Option<ResourceId>,\n+}\n+\n+impl GarbageCollected for HandleWrap {}\n+\n+impl HandleWrap {\n+  pub(crate) fn create(handle: Option<ResourceId>) -> Self {\n+    Self { handle }\n+  }\n+}\n+\n+#[op2(inherit = AsyncWrap)]\n+impl HandleWrap {\n+  #[constructor]\n+  #[cppgc]\n+  fn new(\n+    state: &mut OpState,\n+    #[smi] provider: i32,\n+    #[smi] handle: Option<ResourceId>,\n+  ) -> (AsyncWrap, HandleWrap) {\n+    (\n+      AsyncWrap::create(state, provider),\n+      HandleWrap::create(handle),\n+    )\n+  }\n+\n+  #[reentrant]\n+  fn close(\n+    &self,\n+    state: Rc<RefCell<OpState>>,\n+    #[this] this: v8::Global<v8::Object>,\n+    scope: &mut v8::HandleScope,\n+    #[global] cb: Option<v8::Global<v8::Function>>,\n+  ) -> Result<(), ResourceError> {\n+    // Call _onClose() on the JS handles. Not needed for Rust handles.\n+    let this = v8::Local::new(scope, this);\n+    let on_close_str = v8::String::new(scope, \"_onClose\").unwrap();\n+    let onclose = this.get(scope, on_close_str.into());",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2033264263",
        "repo_full_name": "denoland/deno",
        "pr_number": 28765,
        "pr_file": "ext/node/ops/handle_wrap.rs",
        "discussion_id": "2033264263",
        "commented_code": "@@ -0,0 +1,162 @@\n+// Copyright 2018-2025 the Deno authors. MIT license.\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+use deno_core::error::ResourceError;\n+use deno_core::op2;\n+use deno_core::v8;\n+use deno_core::GarbageCollected;\n+use deno_core::OpState;\n+use deno_core::ResourceId;\n+\n+pub struct AsyncId(i64);\n+\n+impl Default for AsyncId {\n+  // `kAsyncIdCounter` should start at `1` because that'll be the id the execution\n+  // context during bootstrap.\n+  fn default() -> Self {\n+    Self(1)\n+  }\n+}\n+\n+impl AsyncId {\n+  // Increment the internal id counter and return the value.\n+  fn next(&mut self) -> i64 {\n+    self.0 += 1;\n+    self.0\n+  }\n+}\n+\n+fn next_async_id(state: &mut OpState) -> i64 {\n+  let async_id = state.borrow_mut::<AsyncId>().next();\n+  async_id\n+}\n+\n+#[op2(fast)]\n+pub fn op_node_new_async_id(state: &mut OpState) -> f64 {\n+  next_async_id(state) as f64\n+}\n+\n+pub struct AsyncWrap {\n+  provider: i32,\n+  async_id: i64,\n+}\n+\n+impl GarbageCollected for AsyncWrap {}\n+\n+impl AsyncWrap {\n+  pub(crate) fn create(state: &mut OpState, provider: i32) -> Self {\n+    let async_id = next_async_id(state);\n+\n+    Self { provider, async_id }\n+  }\n+}\n+\n+#[op2(base)]\n+impl AsyncWrap {\n+  #[getter]\n+  fn provider(&self) -> i32 {\n+    self.provider\n+  }\n+\n+  #[fast]\n+  fn get_async_id(&self) -> f64 {\n+    self.async_id as f64\n+  }\n+\n+  #[fast]\n+  fn get_provider_type(&self) -> i32 {\n+    self.provider\n+  }\n+}\n+\n+pub struct HandleWrap {\n+  handle: Option<ResourceId>,\n+}\n+\n+impl GarbageCollected for HandleWrap {}\n+\n+impl HandleWrap {\n+  pub(crate) fn create(handle: Option<ResourceId>) -> Self {\n+    Self { handle }\n+  }\n+}\n+\n+#[op2(inherit = AsyncWrap)]\n+impl HandleWrap {\n+  #[constructor]\n+  #[cppgc]\n+  fn new(\n+    state: &mut OpState,\n+    #[smi] provider: i32,\n+    #[smi] handle: Option<ResourceId>,\n+  ) -> (AsyncWrap, HandleWrap) {\n+    (\n+      AsyncWrap::create(state, provider),\n+      HandleWrap::create(handle),\n+    )\n+  }\n+\n+  #[reentrant]\n+  fn close(\n+    &self,\n+    state: Rc<RefCell<OpState>>,\n+    #[this] this: v8::Global<v8::Object>,\n+    scope: &mut v8::HandleScope,\n+    #[global] cb: Option<v8::Global<v8::Function>>,\n+  ) -> Result<(), ResourceError> {\n+    // Call _onClose() on the JS handles. Not needed for Rust handles.\n+    let this = v8::Local::new(scope, this);\n+    let on_close_str = v8::String::new(scope, \"_onClose\").unwrap();\n+    let onclose = this.get(scope, on_close_str.into());",
        "comment_created_at": "2025-04-08T13:57:25+00:00",
        "comment_author": "ry",
        "comment_body": "is there a way to avoid allocating the string on every call?",
        "pr_file_module": null
      },
      {
        "comment_id": "2035428053",
        "repo_full_name": "denoland/deno",
        "pr_number": 28765,
        "pr_file": "ext/node/ops/handle_wrap.rs",
        "discussion_id": "2033264263",
        "commented_code": "@@ -0,0 +1,162 @@\n+// Copyright 2018-2025 the Deno authors. MIT license.\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+use deno_core::error::ResourceError;\n+use deno_core::op2;\n+use deno_core::v8;\n+use deno_core::GarbageCollected;\n+use deno_core::OpState;\n+use deno_core::ResourceId;\n+\n+pub struct AsyncId(i64);\n+\n+impl Default for AsyncId {\n+  // `kAsyncIdCounter` should start at `1` because that'll be the id the execution\n+  // context during bootstrap.\n+  fn default() -> Self {\n+    Self(1)\n+  }\n+}\n+\n+impl AsyncId {\n+  // Increment the internal id counter and return the value.\n+  fn next(&mut self) -> i64 {\n+    self.0 += 1;\n+    self.0\n+  }\n+}\n+\n+fn next_async_id(state: &mut OpState) -> i64 {\n+  let async_id = state.borrow_mut::<AsyncId>().next();\n+  async_id\n+}\n+\n+#[op2(fast)]\n+pub fn op_node_new_async_id(state: &mut OpState) -> f64 {\n+  next_async_id(state) as f64\n+}\n+\n+pub struct AsyncWrap {\n+  provider: i32,\n+  async_id: i64,\n+}\n+\n+impl GarbageCollected for AsyncWrap {}\n+\n+impl AsyncWrap {\n+  pub(crate) fn create(state: &mut OpState, provider: i32) -> Self {\n+    let async_id = next_async_id(state);\n+\n+    Self { provider, async_id }\n+  }\n+}\n+\n+#[op2(base)]\n+impl AsyncWrap {\n+  #[getter]\n+  fn provider(&self) -> i32 {\n+    self.provider\n+  }\n+\n+  #[fast]\n+  fn get_async_id(&self) -> f64 {\n+    self.async_id as f64\n+  }\n+\n+  #[fast]\n+  fn get_provider_type(&self) -> i32 {\n+    self.provider\n+  }\n+}\n+\n+pub struct HandleWrap {\n+  handle: Option<ResourceId>,\n+}\n+\n+impl GarbageCollected for HandleWrap {}\n+\n+impl HandleWrap {\n+  pub(crate) fn create(handle: Option<ResourceId>) -> Self {\n+    Self { handle }\n+  }\n+}\n+\n+#[op2(inherit = AsyncWrap)]\n+impl HandleWrap {\n+  #[constructor]\n+  #[cppgc]\n+  fn new(\n+    state: &mut OpState,\n+    #[smi] provider: i32,\n+    #[smi] handle: Option<ResourceId>,\n+  ) -> (AsyncWrap, HandleWrap) {\n+    (\n+      AsyncWrap::create(state, provider),\n+      HandleWrap::create(handle),\n+    )\n+  }\n+\n+  #[reentrant]\n+  fn close(\n+    &self,\n+    state: Rc<RefCell<OpState>>,\n+    #[this] this: v8::Global<v8::Object>,\n+    scope: &mut v8::HandleScope,\n+    #[global] cb: Option<v8::Global<v8::Function>>,\n+  ) -> Result<(), ResourceError> {\n+    // Call _onClose() on the JS handles. Not needed for Rust handles.\n+    let this = v8::Local::new(scope, this);\n+    let on_close_str = v8::String::new(scope, \"_onClose\").unwrap();\n+    let onclose = this.get(scope, on_close_str.into());",
        "comment_created_at": "2025-04-09T13:52:32+00:00",
        "comment_author": "littledivy",
        "comment_body": "Switched to using `FastStaticString`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1965408685",
    "pr_number": 28219,
    "pr_file": "cli/tools/coverage/mod.rs",
    "created_at": "2025-02-21T12:35:25+00:00",
    "commented_code": ")\n   };\n \n+  let mut file_reports: Vec<(CoverageReport, String)> = vec![];",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1965408685",
        "repo_full_name": "denoland/deno",
        "pr_number": 28219,
        "pr_file": "cli/tools/coverage/mod.rs",
        "discussion_id": "1965408685",
        "commented_code": "@@ -575,6 +575,8 @@ pub fn cover_files(\n     )\n   };\n \n+  let mut file_reports: Vec<(CoverageReport, String)> = vec![];",
        "comment_created_at": "2025-02-21T12:35:25+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Maybe preallocate this vector to some sensible value? Like 512?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1963810456",
    "pr_number": 28202,
    "pr_file": "cli/lsp/tsc.rs",
    "created_at": "2025-02-20T15:33:26+00:00",
    "commented_code": "},\n   customizer = |ext: &mut deno_core::Extension| {\n     use deno_core::ExtensionFileSource;\n-    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/99_main_compiler.js\", crate::tsc::MAIN_COMPILER_SOURCE.get().into()));\n-    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/97_ts_host.js\", crate::tsc::TS_HOST_SOURCE.get().into()));\n-    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/98_lsp.js\", crate::tsc::LSP_SOURCE.get().into()));\n-    ext.js_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_cli_tsc/00_typescript.js\", crate::tsc::TYPESCRIPT_SOURCE.get().into()));\n+    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/99_main_compiler.js\", crate::tsc::MAIN_COMPILER_SOURCE.as_str().into()));\n+    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/97_ts_host.js\", crate::tsc::TS_HOST_SOURCE.as_str().into()));\n+    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/98_lsp.js\", crate::tsc::LSP_SOURCE.as_str().into()));\n+    ext.js_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_cli_tsc/00_typescript.js\", crate::tsc::TYPESCRIPT_SOURCE.as_str().into()));",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1963810456",
        "repo_full_name": "denoland/deno",
        "pr_number": 28202,
        "pr_file": "cli/lsp/tsc.rs",
        "discussion_id": "1963810456",
        "commented_code": "@@ -5074,10 +5074,10 @@ deno_core::extension!(deno_tsc,\n   },\n   customizer = |ext: &mut deno_core::Extension| {\n     use deno_core::ExtensionFileSource;\n-    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/99_main_compiler.js\", crate::tsc::MAIN_COMPILER_SOURCE.get().into()));\n-    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/97_ts_host.js\", crate::tsc::TS_HOST_SOURCE.get().into()));\n-    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/98_lsp.js\", crate::tsc::LSP_SOURCE.get().into()));\n-    ext.js_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_cli_tsc/00_typescript.js\", crate::tsc::TYPESCRIPT_SOURCE.get().into()));\n+    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/99_main_compiler.js\", crate::tsc::MAIN_COMPILER_SOURCE.as_str().into()));\n+    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/97_ts_host.js\", crate::tsc::TS_HOST_SOURCE.as_str().into()));\n+    ext.esm_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_tsc/98_lsp.js\", crate::tsc::LSP_SOURCE.as_str().into()));\n+    ext.js_files.to_mut().push(ExtensionFileSource::new_computed(\"ext:deno_cli_tsc/00_typescript.js\", crate::tsc::TYPESCRIPT_SOURCE.as_str().into()));",
        "comment_created_at": "2025-02-20T15:33:26+00:00",
        "comment_author": "dsherret",
        "comment_body": "I think there's cloning that shouldn't be done because we have a static string here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1949793166",
    "pr_number": 28034,
    "pr_file": "ext/http/lib.rs",
    "created_at": "2025-02-10T19:55:43+00:00",
    "commented_code": "}\n }\n \n+struct OtelInfo {\n+  instant: std::time::Instant,\n+  attributes: OtelInfoAttributes,\n+  request_size: u64,\n+  response_size: RefCell<u64>,\n+}\n+\n+struct OtelInfoAttributes {\n+  http_request_method: String,\n+  network_protocol_version: String,\n+  url_scheme: String,\n+  server_address: Option<String>,\n+  server_port: Option<i64>,\n+  error_type: OnceCell<&'static str>,\n+  http_response_status_code: OnceCell<i64>,\n+}\n+\n+impl OtelInfoAttributes {\n+  fn for_counter(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+\n+    attributes\n+  }\n+\n+  fn for_histogram(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut histogram_attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+      deno_telemetry::KeyValue::new(\n+        \"network.protocol.version\",\n+        self.network_protocol_version.clone(),\n+      ),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+    if let Some(status_code) = self.http_response_status_code.clone().get() {\n+      histogram_attributes.push(deno_telemetry::KeyValue::new(\n+        \"http.response.status_code\",\n+        *status_code,\n+      ));\n+    }\n+\n+    if let Some(error) = self.error_type.get().cloned() {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"error.type\", error));\n+    }\n+\n+    histogram_attributes\n+  }\n+}\n+\n+impl OtelInfo {\n+  fn new(\n+    instant: std::time::Instant,\n+    request_size: u64,\n+    attributes: OtelInfoAttributes,\n+  ) -> Self {\n+    let otel = OTEL_GLOBALS.get().unwrap();\n+    let collectors = OTEL_COLLECTORS.get_or_init(|| {\n+      let meter = otel\n+        .meter_provider\n+        .meter_with_scope(otel.builtin_instrumentation_scope.clone());\n+\n+      let duration = meter\n+        .f64_histogram(\"http.server.request.duration\")\n+        .with_unit(\"s\")\n+        .with_description(\"Duration of HTTP server requests.\")\n+        .with_boundaries(vec![\n+          0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0,\n+          7.5, 10.0,\n+        ])\n+        .build();\n+\n+      let active_requests = meter\n+        .i64_up_down_counter(\"http.server.active_requests\")\n+        .with_unit(\"{request}\")\n+        .with_description(\"Number of active HTTP server requests.\")\n+        .build();\n+\n+      let request_size = meter\n+        .u64_histogram(\"http.server.request.body.size\")\n+        .with_unit(\"By\")\n+        .with_description(\"Size of HTTP server request bodies.\")\n+        .build();\n+\n+      let response_size = meter\n+        .u64_histogram(\"http.server.response.body.size\")\n+        .with_unit(\"By\")\n+        .with_description(\"Size of HTTP server response bodies.\")\n+        .build();\n+\n+      OtelCollectors {\n+        duration,\n+        active_requests,\n+        request_size,\n+        response_size,\n+      }\n+    });\n+\n+    collectors.active_requests.add(1, &attributes.for_counter());\n+\n+    Self {\n+      instant,\n+      attributes,\n+      request_size,\n+      response_size: RefCell::new(0),\n+    }\n+  }\n+}\n+\n+impl Drop for OtelInfo {\n+  fn drop(&mut self) {\n+    let duration = self.instant.elapsed();\n+    let collectors = OTEL_COLLECTORS.get().unwrap();\n+\n+    collectors\n+      .active_requests\n+      .add(-1, &self.attributes.for_counter());\n+\n+    collectors\n+      .duration\n+      .record(duration.as_secs_f64(), &self.attributes.for_histogram());",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1949793166",
        "repo_full_name": "denoland/deno",
        "pr_number": 28034,
        "pr_file": "ext/http/lib.rs",
        "discussion_id": "1949793166",
        "commented_code": "@@ -231,6 +245,185 @@ impl From<tokio::net::unix::SocketAddr> for HttpSocketAddr {\n   }\n }\n \n+struct OtelInfo {\n+  instant: std::time::Instant,\n+  attributes: OtelInfoAttributes,\n+  request_size: u64,\n+  response_size: RefCell<u64>,\n+}\n+\n+struct OtelInfoAttributes {\n+  http_request_method: String,\n+  network_protocol_version: String,\n+  url_scheme: String,\n+  server_address: Option<String>,\n+  server_port: Option<i64>,\n+  error_type: OnceCell<&'static str>,\n+  http_response_status_code: OnceCell<i64>,\n+}\n+\n+impl OtelInfoAttributes {\n+  fn for_counter(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+\n+    attributes\n+  }\n+\n+  fn for_histogram(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut histogram_attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+      deno_telemetry::KeyValue::new(\n+        \"network.protocol.version\",\n+        self.network_protocol_version.clone(),\n+      ),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+    if let Some(status_code) = self.http_response_status_code.clone().get() {\n+      histogram_attributes.push(deno_telemetry::KeyValue::new(\n+        \"http.response.status_code\",\n+        *status_code,\n+      ));\n+    }\n+\n+    if let Some(error) = self.error_type.get().cloned() {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"error.type\", error));\n+    }\n+\n+    histogram_attributes\n+  }\n+}\n+\n+impl OtelInfo {\n+  fn new(\n+    instant: std::time::Instant,\n+    request_size: u64,\n+    attributes: OtelInfoAttributes,\n+  ) -> Self {\n+    let otel = OTEL_GLOBALS.get().unwrap();\n+    let collectors = OTEL_COLLECTORS.get_or_init(|| {\n+      let meter = otel\n+        .meter_provider\n+        .meter_with_scope(otel.builtin_instrumentation_scope.clone());\n+\n+      let duration = meter\n+        .f64_histogram(\"http.server.request.duration\")\n+        .with_unit(\"s\")\n+        .with_description(\"Duration of HTTP server requests.\")\n+        .with_boundaries(vec![\n+          0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0,\n+          7.5, 10.0,\n+        ])\n+        .build();\n+\n+      let active_requests = meter\n+        .i64_up_down_counter(\"http.server.active_requests\")\n+        .with_unit(\"{request}\")\n+        .with_description(\"Number of active HTTP server requests.\")\n+        .build();\n+\n+      let request_size = meter\n+        .u64_histogram(\"http.server.request.body.size\")\n+        .with_unit(\"By\")\n+        .with_description(\"Size of HTTP server request bodies.\")\n+        .build();\n+\n+      let response_size = meter\n+        .u64_histogram(\"http.server.response.body.size\")\n+        .with_unit(\"By\")\n+        .with_description(\"Size of HTTP server response bodies.\")\n+        .build();\n+\n+      OtelCollectors {\n+        duration,\n+        active_requests,\n+        request_size,\n+        response_size,\n+      }\n+    });\n+\n+    collectors.active_requests.add(1, &attributes.for_counter());\n+\n+    Self {\n+      instant,\n+      attributes,\n+      request_size,\n+      response_size: RefCell::new(0),\n+    }\n+  }\n+}\n+\n+impl Drop for OtelInfo {\n+  fn drop(&mut self) {\n+    let duration = self.instant.elapsed();\n+    let collectors = OTEL_COLLECTORS.get().unwrap();\n+\n+    collectors\n+      .active_requests\n+      .add(-1, &self.attributes.for_counter());\n+\n+    collectors\n+      .duration\n+      .record(duration.as_secs_f64(), &self.attributes.for_histogram());",
        "comment_created_at": "2025-02-10T19:55:43+00:00",
        "comment_author": "lucacasonato",
        "comment_body": "Only call the method that creates the attributes once. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1960440911",
    "pr_number": 28034,
    "pr_file": "ext/http/lib.rs",
    "created_at": "2025-02-18T19:26:01+00:00",
    "commented_code": "}\n }\n \n+struct OtelInfo {\n+  attributes: OtelInfoAttributes,\n+  duration: Option<std::time::Instant>,\n+  request_size: Option<u64>,\n+  response_size: Option<u64>,\n+}\n+\n+struct OtelInfoAttributes {\n+  http_request_method: Cow<'static, str>,\n+  network_protocol_version: &'static str,\n+  url_scheme: Cow<'static, str>,\n+  server_address: Option<String>,\n+  server_port: Option<i64>,\n+  error_type: Option<&'static str>,\n+  http_response_status_code: Option<i64>,\n+}\n+\n+impl OtelInfoAttributes {\n+  fn method(method: &http::method::Method) -> Cow<'static, str> {\n+    use http::method::Method;\n+\n+    match *method {\n+      Method::GET => Cow::Borrowed(\"GET\"),\n+      Method::POST => Cow::Borrowed(\"POST\"),\n+      Method::PUT => Cow::Borrowed(\"PUT\"),\n+      Method::DELETE => Cow::Borrowed(\"DELETE\"),\n+      Method::HEAD => Cow::Borrowed(\"HEAD\"),\n+      Method::OPTIONS => Cow::Borrowed(\"OPTIONS\"),\n+      Method::CONNECT => Cow::Borrowed(\"CONNECT\"),\n+      Method::PATCH => Cow::Borrowed(\"PATCH\"),\n+      Method::TRACE => Cow::Borrowed(\"TRACE\"),\n+      _ => Cow::Owned(method.to_string()),\n+    }\n+  }\n+\n+  fn method_v02(method: &http_v02::method::Method) -> Cow<'static, str> {\n+    use http_v02::method::Method;\n+\n+    match *method {\n+      Method::GET => Cow::Borrowed(\"GET\"),\n+      Method::POST => Cow::Borrowed(\"POST\"),\n+      Method::PUT => Cow::Borrowed(\"PUT\"),\n+      Method::DELETE => Cow::Borrowed(\"DELETE\"),\n+      Method::HEAD => Cow::Borrowed(\"HEAD\"),\n+      Method::OPTIONS => Cow::Borrowed(\"OPTIONS\"),\n+      Method::CONNECT => Cow::Borrowed(\"CONNECT\"),\n+      Method::PATCH => Cow::Borrowed(\"PATCH\"),\n+      Method::TRACE => Cow::Borrowed(\"TRACE\"),\n+      _ => Cow::Owned(method.to_string()),\n+    }\n+  }\n+\n+  fn version(version: http::Version) -> &'static str {\n+    use http::Version;\n+\n+    match version {\n+      Version::HTTP_09 => \"0.9\",\n+      Version::HTTP_10 => \"1.0\",\n+      Version::HTTP_11 => \"1.1\",\n+      Version::HTTP_2 => \"2.0\",\n+      Version::HTTP_3 => \"3.0\",\n+      _ => unreachable!(),\n+    }\n+  }\n+\n+  fn version_v02(version: http_v02::Version) -> &'static str {\n+    use http_v02::Version;\n+\n+    match version {\n+      Version::HTTP_09 => \"0.9\",\n+      Version::HTTP_10 => \"1.0\",\n+      Version::HTTP_11 => \"1.1\",\n+      Version::HTTP_2 => \"2.0\",\n+      Version::HTTP_3 => \"3.0\",\n+      _ => unreachable!(),\n+    }\n+  }\n+\n+  fn for_counter(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+\n+    attributes\n+  }\n+\n+  fn for_histogram(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut histogram_attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+      deno_telemetry::KeyValue::new(\n+        \"network.protocol.version\",\n+        self.network_protocol_version,\n+      ),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+    if let Some(status_code) = self.http_response_status_code {\n+      histogram_attributes.push(deno_telemetry::KeyValue::new(\n+        \"http.response.status_code\",\n+        status_code,\n+      ));\n+    }\n+\n+    if let Some(error) = self.error_type {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"error.type\", error));\n+    }\n+\n+    histogram_attributes\n+  }\n+}\n+\n+impl OtelInfo {\n+  fn new(\n+    instant: std::time::Instant,\n+    request_size: u64,\n+    attributes: OtelInfoAttributes,\n+  ) -> Self {\n+    let otel = OTEL_GLOBALS.get().unwrap();\n+    let collectors = OTEL_COLLECTORS.get_or_init(|| {\n+      let meter = otel\n+        .meter_provider\n+        .meter_with_scope(otel.builtin_instrumentation_scope.clone());\n+\n+      let duration = meter\n+        .f64_histogram(\"http.server.request.duration\")\n+        .with_unit(\"s\")\n+        .with_description(\"Duration of HTTP server requests.\")\n+        .with_boundaries(vec![\n+          0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0,\n+          7.5, 10.0,\n+        ])\n+        .build();\n+\n+      let active_requests = meter\n+        .i64_up_down_counter(\"http.server.active_requests\")\n+        .with_unit(\"{request}\")\n+        .with_description(\"Number of active HTTP server requests.\")\n+        .build();\n+\n+      let request_size = meter\n+        .u64_histogram(\"http.server.request.body.size\")\n+        .with_unit(\"By\")\n+        .with_description(\"Size of HTTP server request bodies.\")",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1960440911",
        "repo_full_name": "denoland/deno",
        "pr_number": 28034,
        "pr_file": "ext/http/lib.rs",
        "discussion_id": "1960440911",
        "commented_code": "@@ -231,6 +245,265 @@ impl From<tokio::net::unix::SocketAddr> for HttpSocketAddr {\n   }\n }\n \n+struct OtelInfo {\n+  attributes: OtelInfoAttributes,\n+  duration: Option<std::time::Instant>,\n+  request_size: Option<u64>,\n+  response_size: Option<u64>,\n+}\n+\n+struct OtelInfoAttributes {\n+  http_request_method: Cow<'static, str>,\n+  network_protocol_version: &'static str,\n+  url_scheme: Cow<'static, str>,\n+  server_address: Option<String>,\n+  server_port: Option<i64>,\n+  error_type: Option<&'static str>,\n+  http_response_status_code: Option<i64>,\n+}\n+\n+impl OtelInfoAttributes {\n+  fn method(method: &http::method::Method) -> Cow<'static, str> {\n+    use http::method::Method;\n+\n+    match *method {\n+      Method::GET => Cow::Borrowed(\"GET\"),\n+      Method::POST => Cow::Borrowed(\"POST\"),\n+      Method::PUT => Cow::Borrowed(\"PUT\"),\n+      Method::DELETE => Cow::Borrowed(\"DELETE\"),\n+      Method::HEAD => Cow::Borrowed(\"HEAD\"),\n+      Method::OPTIONS => Cow::Borrowed(\"OPTIONS\"),\n+      Method::CONNECT => Cow::Borrowed(\"CONNECT\"),\n+      Method::PATCH => Cow::Borrowed(\"PATCH\"),\n+      Method::TRACE => Cow::Borrowed(\"TRACE\"),\n+      _ => Cow::Owned(method.to_string()),\n+    }\n+  }\n+\n+  fn method_v02(method: &http_v02::method::Method) -> Cow<'static, str> {\n+    use http_v02::method::Method;\n+\n+    match *method {\n+      Method::GET => Cow::Borrowed(\"GET\"),\n+      Method::POST => Cow::Borrowed(\"POST\"),\n+      Method::PUT => Cow::Borrowed(\"PUT\"),\n+      Method::DELETE => Cow::Borrowed(\"DELETE\"),\n+      Method::HEAD => Cow::Borrowed(\"HEAD\"),\n+      Method::OPTIONS => Cow::Borrowed(\"OPTIONS\"),\n+      Method::CONNECT => Cow::Borrowed(\"CONNECT\"),\n+      Method::PATCH => Cow::Borrowed(\"PATCH\"),\n+      Method::TRACE => Cow::Borrowed(\"TRACE\"),\n+      _ => Cow::Owned(method.to_string()),\n+    }\n+  }\n+\n+  fn version(version: http::Version) -> &'static str {\n+    use http::Version;\n+\n+    match version {\n+      Version::HTTP_09 => \"0.9\",\n+      Version::HTTP_10 => \"1.0\",\n+      Version::HTTP_11 => \"1.1\",\n+      Version::HTTP_2 => \"2.0\",\n+      Version::HTTP_3 => \"3.0\",\n+      _ => unreachable!(),\n+    }\n+  }\n+\n+  fn version_v02(version: http_v02::Version) -> &'static str {\n+    use http_v02::Version;\n+\n+    match version {\n+      Version::HTTP_09 => \"0.9\",\n+      Version::HTTP_10 => \"1.0\",\n+      Version::HTTP_11 => \"1.1\",\n+      Version::HTTP_2 => \"2.0\",\n+      Version::HTTP_3 => \"3.0\",\n+      _ => unreachable!(),\n+    }\n+  }\n+\n+  fn for_counter(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      attributes.push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+\n+    attributes\n+  }\n+\n+  fn for_histogram(&self) -> Vec<deno_telemetry::KeyValue> {\n+    let mut histogram_attributes = vec![\n+      deno_telemetry::KeyValue::new(\n+        \"http.request.method\",\n+        self.http_request_method.clone(),\n+      ),\n+      deno_telemetry::KeyValue::new(\"url.scheme\", self.url_scheme.clone()),\n+      deno_telemetry::KeyValue::new(\n+        \"network.protocol.version\",\n+        self.network_protocol_version,\n+      ),\n+    ];\n+\n+    if let Some(address) = self.server_address.clone() {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.address\", address));\n+    }\n+    if let Some(port) = self.server_port {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"server.port\", port));\n+    }\n+    if let Some(status_code) = self.http_response_status_code {\n+      histogram_attributes.push(deno_telemetry::KeyValue::new(\n+        \"http.response.status_code\",\n+        status_code,\n+      ));\n+    }\n+\n+    if let Some(error) = self.error_type {\n+      histogram_attributes\n+        .push(deno_telemetry::KeyValue::new(\"error.type\", error));\n+    }\n+\n+    histogram_attributes\n+  }\n+}\n+\n+impl OtelInfo {\n+  fn new(\n+    instant: std::time::Instant,\n+    request_size: u64,\n+    attributes: OtelInfoAttributes,\n+  ) -> Self {\n+    let otel = OTEL_GLOBALS.get().unwrap();\n+    let collectors = OTEL_COLLECTORS.get_or_init(|| {\n+      let meter = otel\n+        .meter_provider\n+        .meter_with_scope(otel.builtin_instrumentation_scope.clone());\n+\n+      let duration = meter\n+        .f64_histogram(\"http.server.request.duration\")\n+        .with_unit(\"s\")\n+        .with_description(\"Duration of HTTP server requests.\")\n+        .with_boundaries(vec![\n+          0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1.0, 2.5, 5.0,\n+          7.5, 10.0,\n+        ])\n+        .build();\n+\n+      let active_requests = meter\n+        .i64_up_down_counter(\"http.server.active_requests\")\n+        .with_unit(\"{request}\")\n+        .with_description(\"Number of active HTTP server requests.\")\n+        .build();\n+\n+      let request_size = meter\n+        .u64_histogram(\"http.server.request.body.size\")\n+        .with_unit(\"By\")\n+        .with_description(\"Size of HTTP server request bodies.\")",
        "comment_created_at": "2025-02-18T19:26:01+00:00",
        "comment_author": "lucacasonato",
        "comment_body": "Can you make the buckets for this `[0, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000]` (also in the other size histogram).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1959507945",
    "pr_number": 28154,
    "pr_file": "ext/node/ops/sqlite/statement.rs",
    "created_at": "2025-02-18T10:53:58+00:00",
    "commented_code": "// SAFETY: `self.inner` is a valid pointer to a sqlite3_stmt\n           // as it lives as long as the StatementSync instance.\n           unsafe {\n-            ffi::sqlite3_bind_int64(raw, i + 1, as_int);\n+            ffi::sqlite3_bind_int64(raw, param_count + 1, as_int);\n+          }\n+          param_count += 1;\n+        } else if value.is_object() {\n+          let mut params: HashMap<String, Local<v8::Value>> = HashMap::new();\n+          let value: v8::Local<v8::Object> = value.try_into().unwrap();\n+          let maybe_keys =\n+            value.get_property_names(scope, GetPropertyNamesArgs::default());\n+\n+          if let Some(keys) = maybe_keys {\n+            let length = keys.length();\n+            for i in 0..length {\n+              if let Some(key) = keys.get_index(scope, i) {\n+                if let Some(key_str) = key.to_string(scope) {\n+                  let key_str = key_str.to_rust_string_lossy(scope);\n+                  if let Some(value) = value.get(scope, key) {\n+                    params.insert(key_str, value);\n+                  }\n+                }\n+              }\n+            }\n+          }\n+          for (key, value) in params {\n+            self.bind_params_object(scope, key, value, param_count)?;\n+            param_count += 1;",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1959507945",
        "repo_full_name": "denoland/deno",
        "pr_number": 28154,
        "pr_file": "ext/node/ops/sqlite/statement.rs",
        "discussion_id": "1959507945",
        "commented_code": "@@ -278,7 +286,31 @@ impl StatementSync {\n           // SAFETY: `self.inner` is a valid pointer to a sqlite3_stmt\n           // as it lives as long as the StatementSync instance.\n           unsafe {\n-            ffi::sqlite3_bind_int64(raw, i + 1, as_int);\n+            ffi::sqlite3_bind_int64(raw, param_count + 1, as_int);\n+          }\n+          param_count += 1;\n+        } else if value.is_object() {\n+          let mut params: HashMap<String, Local<v8::Value>> = HashMap::new();\n+          let value: v8::Local<v8::Object> = value.try_into().unwrap();\n+          let maybe_keys =\n+            value.get_property_names(scope, GetPropertyNamesArgs::default());\n+\n+          if let Some(keys) = maybe_keys {\n+            let length = keys.length();\n+            for i in 0..length {\n+              if let Some(key) = keys.get_index(scope, i) {\n+                if let Some(key_str) = key.to_string(scope) {\n+                  let key_str = key_str.to_rust_string_lossy(scope);\n+                  if let Some(value) = value.get(scope, key) {\n+                    params.insert(key_str, value);\n+                  }\n+                }\n+              }\n+            }\n+          }\n+          for (key, value) in params {\n+            self.bind_params_object(scope, key, value, param_count)?;\n+            param_count += 1;",
        "comment_created_at": "2025-02-18T10:53:58+00:00",
        "comment_author": "littledivy",
        "comment_body": "A single loop should be enough? This saves the Hashmap allocation\r\n\r\n```suggestion\r\n          let value: v8::Local<v8::Object> = value.try_into().unwrap();\r\n          let maybe_keys =\r\n            value.get_property_names(scope, GetPropertyNamesArgs::default());\r\n\r\n          if let Some(keys) = maybe_keys {\r\n            let length = keys.length();\r\n            for i in 0..length {\r\n              if let Some(key) = keys.get_index(scope, i) {\r\n                if let Some(key_str) = key.to_string(scope) {\r\n                  let key_str = key_str.to_rust_string_lossy(scope);\r\n                  if let Some(value) = value.get(scope, key) {\r\n                    self.bind_params_object(scope, key_str, value, param_count)?;\r\n                    param_count += 1;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n```",
        "pr_file_module": null
      }
    ]
  }
]