[
  {
    "discussion_id": "2112654734",
    "pr_number": 29470,
    "pr_file": "cli/tools/bundle/mod.rs",
    "created_at": "2025-05-28T20:02:24+00:00",
    "commented_code": "+use std::path::Path;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use deno_ast::ModuleSpecifier;\n+use deno_cache_dir::GlobalOrLocalHttpCache;\n+use deno_config::deno_json::TsTypeLib;\n+use deno_core::anyhow;\n+use deno_core::error::AnyError;\n+use deno_core::resolve_url_or_path;\n+use deno_core::url::Url;\n+use deno_core::ModuleLoader;\n+use deno_error::JsError;\n+use deno_graph::Position;\n+use deno_lib::worker::ModuleLoaderFactory;\n+use deno_npm::npm_rc::ResolvedNpmRc;\n+use deno_npm::registry::NpmRegistryApi;\n+use deno_npm_cache::TarballCache;\n+use deno_resolver::npm::managed::ResolvePkgFolderFromDenoModuleError;\n+use deno_resolver::workspace::WorkspaceNpmPatchPackages;\n+use deno_runtime::deno_permissions::PermissionsContainer;\n+use deno_semver::npm::NpmPackageReqReference;\n+use deno_semver::package::PackageNv;\n+use esbuild_rs::protocol;\n+use esbuild_rs::EsbuildFlagsBuilder;\n+use esbuild_rs::EsbuildService;\n+use indexmap::IndexMap;\n+use node_resolver::errors::PackageSubpathResolveError;\n+use node_resolver::NodeResolutionKind;\n+use node_resolver::ResolutionMode;\n+use sys_traits::EnvCurrentDir;\n+\n+use crate::args::BundleFlags;\n+use crate::args::BundleFormat;\n+use crate::args::Flags;\n+use crate::args::PackageHandling;\n+use crate::cache::DenoDir;\n+use crate::factory::CliFactory;\n+use crate::graph_container::MainModuleGraphContainer;\n+use crate::graph_container::ModuleGraphContainer;\n+use crate::graph_container::ModuleGraphUpdatePermit;\n+use crate::module_loader::ModuleLoadPreparer;\n+use crate::module_loader::PrepareModuleLoadOptions;\n+use crate::node::CliNodeResolver;\n+use crate::npm::CliNpmCache;\n+use crate::npm::CliNpmCacheHttpClient;\n+use crate::npm::CliNpmRegistryInfoProvider;\n+use crate::npm::CliNpmResolver;\n+use crate::resolver::CliNpmReqResolver;\n+use crate::resolver::CliResolver;\n+use crate::sys::CliSys;\n+\n+const ESBUILD_VERSION: &str = \"0.25.5\";\n+\n+pub async fn ensure_esbuild(",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2112654734",
        "repo_full_name": "denoland/deno",
        "pr_number": 29470,
        "pr_file": "cli/tools/bundle/mod.rs",
        "discussion_id": "2112654734",
        "commented_code": "@@ -0,0 +1,879 @@\n+use std::path::Path;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use deno_ast::ModuleSpecifier;\n+use deno_cache_dir::GlobalOrLocalHttpCache;\n+use deno_config::deno_json::TsTypeLib;\n+use deno_core::anyhow;\n+use deno_core::error::AnyError;\n+use deno_core::resolve_url_or_path;\n+use deno_core::url::Url;\n+use deno_core::ModuleLoader;\n+use deno_error::JsError;\n+use deno_graph::Position;\n+use deno_lib::worker::ModuleLoaderFactory;\n+use deno_npm::npm_rc::ResolvedNpmRc;\n+use deno_npm::registry::NpmRegistryApi;\n+use deno_npm_cache::TarballCache;\n+use deno_resolver::npm::managed::ResolvePkgFolderFromDenoModuleError;\n+use deno_resolver::workspace::WorkspaceNpmPatchPackages;\n+use deno_runtime::deno_permissions::PermissionsContainer;\n+use deno_semver::npm::NpmPackageReqReference;\n+use deno_semver::package::PackageNv;\n+use esbuild_rs::protocol;\n+use esbuild_rs::EsbuildFlagsBuilder;\n+use esbuild_rs::EsbuildService;\n+use indexmap::IndexMap;\n+use node_resolver::errors::PackageSubpathResolveError;\n+use node_resolver::NodeResolutionKind;\n+use node_resolver::ResolutionMode;\n+use sys_traits::EnvCurrentDir;\n+\n+use crate::args::BundleFlags;\n+use crate::args::BundleFormat;\n+use crate::args::Flags;\n+use crate::args::PackageHandling;\n+use crate::cache::DenoDir;\n+use crate::factory::CliFactory;\n+use crate::graph_container::MainModuleGraphContainer;\n+use crate::graph_container::ModuleGraphContainer;\n+use crate::graph_container::ModuleGraphUpdatePermit;\n+use crate::module_loader::ModuleLoadPreparer;\n+use crate::module_loader::PrepareModuleLoadOptions;\n+use crate::node::CliNodeResolver;\n+use crate::npm::CliNpmCache;\n+use crate::npm::CliNpmCacheHttpClient;\n+use crate::npm::CliNpmRegistryInfoProvider;\n+use crate::npm::CliNpmResolver;\n+use crate::resolver::CliNpmReqResolver;\n+use crate::resolver::CliResolver;\n+use crate::sys::CliSys;\n+\n+const ESBUILD_VERSION: &str = \"0.25.5\";\n+\n+pub async fn ensure_esbuild(",
        "comment_created_at": "2025-05-28T20:02:24+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Since this is an implementation detail, maybe you could move it to `bundle/esbuild.rs` module?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2112658173",
    "pr_number": 29470,
    "pr_file": "cli/tools/bundle/mod.rs",
    "created_at": "2025-05-28T20:05:05+00:00",
    "commented_code": "+use std::path::Path;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use deno_ast::ModuleSpecifier;\n+use deno_cache_dir::GlobalOrLocalHttpCache;\n+use deno_config::deno_json::TsTypeLib;\n+use deno_core::anyhow;\n+use deno_core::error::AnyError;\n+use deno_core::resolve_url_or_path;\n+use deno_core::url::Url;\n+use deno_core::ModuleLoader;\n+use deno_error::JsError;\n+use deno_graph::Position;\n+use deno_lib::worker::ModuleLoaderFactory;\n+use deno_npm::npm_rc::ResolvedNpmRc;\n+use deno_npm::registry::NpmRegistryApi;\n+use deno_npm_cache::TarballCache;\n+use deno_resolver::npm::managed::ResolvePkgFolderFromDenoModuleError;\n+use deno_resolver::workspace::WorkspaceNpmPatchPackages;\n+use deno_runtime::deno_permissions::PermissionsContainer;\n+use deno_semver::npm::NpmPackageReqReference;\n+use deno_semver::package::PackageNv;\n+use esbuild_rs::protocol;\n+use esbuild_rs::EsbuildFlagsBuilder;\n+use esbuild_rs::EsbuildService;\n+use indexmap::IndexMap;\n+use node_resolver::errors::PackageSubpathResolveError;\n+use node_resolver::NodeResolutionKind;\n+use node_resolver::ResolutionMode;\n+use sys_traits::EnvCurrentDir;\n+\n+use crate::args::BundleFlags;\n+use crate::args::BundleFormat;\n+use crate::args::Flags;\n+use crate::args::PackageHandling;\n+use crate::cache::DenoDir;\n+use crate::factory::CliFactory;\n+use crate::graph_container::MainModuleGraphContainer;\n+use crate::graph_container::ModuleGraphContainer;\n+use crate::graph_container::ModuleGraphUpdatePermit;\n+use crate::module_loader::ModuleLoadPreparer;\n+use crate::module_loader::PrepareModuleLoadOptions;\n+use crate::node::CliNodeResolver;\n+use crate::npm::CliNpmCache;\n+use crate::npm::CliNpmCacheHttpClient;\n+use crate::npm::CliNpmRegistryInfoProvider;\n+use crate::npm::CliNpmResolver;\n+use crate::resolver::CliNpmReqResolver;\n+use crate::resolver::CliResolver;\n+use crate::sys::CliSys;\n+\n+const ESBUILD_VERSION: &str = \"0.25.5\";\n+\n+pub async fn ensure_esbuild(\n+  deno_dir: &DenoDir,\n+  npmrc: &ResolvedNpmRc,\n+  npm_registry_info: &Arc<CliNpmRegistryInfoProvider>,\n+  workspace_patch_packages: &Arc<WorkspaceNpmPatchPackages>,\n+  tarball_cache: &Arc<TarballCache<CliNpmCacheHttpClient, CliSys>>,\n+  npm_cache: &CliNpmCache,\n+  target: &str,\n+) -> Result<PathBuf, AnyError> {\n+  let esbuild_path = deno_dir\n+    .dl_folder_path()\n+    .join(format!(\"esbuild-{}\", ESBUILD_VERSION))\n+    .join(format!(\"esbuild-{}\", target));\n+\n+  if esbuild_path.exists() {\n+    return Ok(esbuild_path);\n+  }\n+  let pkg_name = format!(\"@esbuild/{}\", target);\n+  let nv =\n+    PackageNv::from_str(&format!(\"{}@{}\", pkg_name, ESBUILD_VERSION)).unwrap();\n+  let api = npm_registry_info.as_npm_registry_api();\n+  let info = api.package_info(&pkg_name).await?;\n+  let version_info = info.version_info(&nv, &workspace_patch_packages.0)?;\n+  if let Some(dist) = &version_info.dist {\n+    let registry_url = npmrc.get_registry_url(&nv.name);\n+    let package_folder =\n+      npm_cache.package_folder_for_nv_and_url(&nv, registry_url);\n+    let existed = package_folder.exists();\n+\n+    if !existed {\n+      tarball_cache.ensure_package(&nv, &dist).await?;\n+    }\n+\n+    let path = package_folder.join(\"bin/esbuild\");\n+\n+    std::fs::create_dir_all(esbuild_path.parent().unwrap())?;\n+    std::fs::copy(&path, &esbuild_path)?;\n+\n+    if !existed {\n+      std::fs::remove_dir_all(&package_folder)?;\n+    }\n+    return Ok(esbuild_path);\n+  }\n+  anyhow::bail!(\"esbuild not found\");\n+}\n+\n+pub async fn bundle(\n+  flags: Arc<Flags>,\n+  mut bundle_flags: BundleFlags,\n+) -> Result<(), AnyError> {\n+  let factory = CliFactory::from_flags(flags);\n+\n+  let installer_factory = factory.npm_installer_factory()?;\n+  let npmrc = factory.npmrc()?;\n+  let deno_dir = factory.deno_dir()?;\n+  let resolver_factory = factory.resolver_factory()?;\n+  let workspace_factory = resolver_factory.workspace_factory();\n+  let npm_registry_info = installer_factory.registry_info_provider()?;\n+  let esbuild_path = ensure_esbuild(\n+    &deno_dir,\n+    &npmrc,\n+    npm_registry_info,\n+    workspace_factory.workspace_npm_patch_packages()?,\n+    installer_factory.tarball_cache()?,\n+    factory.npm_cache()?,\n+    \"darwin-arm64\",\n+  )\n+  .await?;\n+  let resolver = factory.resolver().await?.clone();\n+  let module_load_preparer = factory.module_load_preparer().await?.clone();\n+  let root_permissions = factory.root_permissions_container()?;\n+  let npm_resolver = factory.npm_resolver().await?.clone();\n+  let node_resolver = factory.node_resolver().await?.clone();\n+  let cli_options = factory.cli_options()?;\n+  let module_loader = factory\n+    .create_module_loader_factory()\n+    .await?\n+    .create_for_main(root_permissions.clone())\n+    .module_loader;\n+  let sys = factory.sys();\n+  let init_cwd = cli_options.initial_cwd().canonicalize()?;\n+\n+  let plugin_handler = Arc::new(DenoPluginHandler {\n+    resolver: resolver.clone(),\n+    module_load_preparer,\n+    module_graph_container: factory\n+      .main_module_graph_container()\n+      .await?\n+      .clone(),\n+    permissions: root_permissions.clone(),\n+    npm_req_resolver: factory.npm_req_resolver()?.clone(),\n+    npm_resolver: npm_resolver.clone(),\n+    node_resolver: node_resolver.clone(),\n+    http_cache: factory.http_cache()?.clone(),\n+    module_loader: module_loader.clone(),\n+  });\n+  let start = std::time::Instant::now();\n+\n+  let entrypoint = bundle_flags\n+    .entrypoints\n+    .first()\n+    .iter()\n+    .map(|e| resolve_url_or_path(e, &init_cwd).unwrap())\n+    .collect::<Vec<_>>();\n+  let resolved = {\n+    let mut resolved = vec![];\n+    let init_cwd_url = Url::from_directory_path(&init_cwd).unwrap();\n+    for e in &entrypoint {\n+      let r = resolver\n+        .resolve(\n+          e.as_str(),\n+          &init_cwd_url,\n+          Position::new(0, 0),\n+          ResolutionMode::Import,\n+          NodeResolutionKind::Execution,\n+        )\n+        .unwrap();\n+      resolved.push(r);\n+    }\n+    resolved\n+  };\n+\n+  let roots = resolved\n+    .into_iter()\n+    .map(|url| {\n+      if let Ok(v) = NpmPackageReqReference::from_specifier(&url) {\n+        let referrer =\n+          ModuleSpecifier::from_directory_path(sys.env_current_dir().unwrap())\n+            .unwrap()\n+            .join(\"package.json\")\n+            .unwrap();\n+        let package_folder = npm_resolver\n+          .resolve_pkg_folder_from_deno_module_req(v.req(), &referrer)\n+          .unwrap();\n+        let main_module = node_resolver\n+          .resolve_binary_export(&package_folder, v.sub_path())\n+          .unwrap();\n+        Url::from_file_path(&main_module).unwrap()\n+      } else {\n+        url\n+      }\n+    })\n+    .collect::<Vec<_>>();\n+  let _ = plugin_handler.prepare_module_load(&roots).await;\n+  let esbuild =\n+    EsbuildService::new(esbuild_path, ESBUILD_VERSION, plugin_handler.clone())\n+      .await\n+      .unwrap();\n+  let client = esbuild.client().clone();\n+\n+  {\n+    tokio::spawn(async move {\n+      loop {\n+        tokio::select! {\n+            res = esbuild.wait_for_exit() => {\n+                eprintln!(\"esbuild exited: {:?}\", res);\n+                break;\n+            }\n+        }\n+      }\n+\n+      Ok::<(), AnyError>(())\n+    });\n+  }\n+\n+  bundle_flags.external.push(\"*.node\".into());\n+\n+  let mut builder = EsbuildFlagsBuilder::default();\n+  builder\n+    .bundle(bundle_flags.bundle)\n+    .minify(bundle_flags.minify)\n+    .splitting(bundle_flags.code_splitting)\n+    .external(bundle_flags.external.clone())\n+    .format(match bundle_flags.format {\n+      BundleFormat::Esm => esbuild_rs::Format::Esm,\n+      BundleFormat::Cjs => esbuild_rs::Format::Cjs,\n+      BundleFormat::Iife => esbuild_rs::Format::Iife,\n+    })\n+    .packages(match bundle_flags.packages {\n+      PackageHandling::External => esbuild_rs::PackagesHandling::External,\n+      PackageHandling::Bundle => esbuild_rs::PackagesHandling::Bundle,\n+    });\n+  if let Some(outdir) = bundle_flags.output_dir.clone() {\n+    builder.outdir(outdir);\n+  } else {\n+    builder.outfile(\n+      bundle_flags\n+        .output_path\n+        .clone()\n+        .unwrap_or_else(|| \"./dist/bundled.js\".to_string()),\n+    );\n+  }\n+  let flags = builder.build().unwrap();\n+\n+  let entries = roots.into_iter().map(|e| (\"\".into(), e.into())).collect();\n+\n+  let response = client\n+    .send_build_request(protocol::BuildRequest {\n+      entries,\n+      key: 0,\n+      flags: flags.to_flags(),\n+      write: true,\n+      stdin_contents: None.into(),\n+      stdin_resolve_dir: None.into(),\n+      abs_working_dir: init_cwd.to_string_lossy().to_string(),\n+      context: false,\n+      mangle_cache: None.into(),\n+      node_paths: vec![],\n+      plugins: Some(vec![protocol::BuildPlugin {\n+        name: \"deno\".into(),\n+        on_start: false,\n+        on_end: false,\n+        on_resolve: (vec![protocol::OnResolveSetupOptions {\n+          id: 0,\n+          filter: \".*\".into(),\n+          namespace: \"\".into(),\n+        }]),\n+        on_load: vec![protocol::OnLoadSetupOptions {\n+          id: 0,\n+          filter: \".*\".into(),\n+          namespace: \"\".into(),\n+        }],\n+      }]),\n+    })\n+    .await\n+    .unwrap();\n+\n+  if response.errors.len() > 0 {\n+    for error in &response.errors {\n+      eprintln!(\n+        \"{}: {}\",\n+        deno_terminal::colors::red(\"bundler error\"),\n+        format_message(error)\n+      );\n+    }\n+  }\n+\n+  if response.warnings.len() > 0 {\n+    for warning in &response.warnings {\n+      eprintln!(\n+        \"{}: {}\",\n+        deno_terminal::colors::yellow(\"bundler warning\"),\n+        format_message(warning)\n+      );\n+    }\n+  }\n+\n+  if let Some(stdout) = response.write_to_stdout {\n+    println!(\"{}\", String::from_utf8_lossy(&stdout));\n+  } else if response.errors.len() == 0 {\n+    if bundle_flags.output_dir.is_none()\n+      && std::env::var(\"NO_DENO_BUNDLE_HACK\").is_err()\n+    {\n+      // TODO(nathanwhit): MASSIVE HACK",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2112658173",
        "repo_full_name": "denoland/deno",
        "pr_number": 29470,
        "pr_file": "cli/tools/bundle/mod.rs",
        "discussion_id": "2112658173",
        "commented_code": "@@ -0,0 +1,879 @@\n+use std::path::Path;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use deno_ast::ModuleSpecifier;\n+use deno_cache_dir::GlobalOrLocalHttpCache;\n+use deno_config::deno_json::TsTypeLib;\n+use deno_core::anyhow;\n+use deno_core::error::AnyError;\n+use deno_core::resolve_url_or_path;\n+use deno_core::url::Url;\n+use deno_core::ModuleLoader;\n+use deno_error::JsError;\n+use deno_graph::Position;\n+use deno_lib::worker::ModuleLoaderFactory;\n+use deno_npm::npm_rc::ResolvedNpmRc;\n+use deno_npm::registry::NpmRegistryApi;\n+use deno_npm_cache::TarballCache;\n+use deno_resolver::npm::managed::ResolvePkgFolderFromDenoModuleError;\n+use deno_resolver::workspace::WorkspaceNpmPatchPackages;\n+use deno_runtime::deno_permissions::PermissionsContainer;\n+use deno_semver::npm::NpmPackageReqReference;\n+use deno_semver::package::PackageNv;\n+use esbuild_rs::protocol;\n+use esbuild_rs::EsbuildFlagsBuilder;\n+use esbuild_rs::EsbuildService;\n+use indexmap::IndexMap;\n+use node_resolver::errors::PackageSubpathResolveError;\n+use node_resolver::NodeResolutionKind;\n+use node_resolver::ResolutionMode;\n+use sys_traits::EnvCurrentDir;\n+\n+use crate::args::BundleFlags;\n+use crate::args::BundleFormat;\n+use crate::args::Flags;\n+use crate::args::PackageHandling;\n+use crate::cache::DenoDir;\n+use crate::factory::CliFactory;\n+use crate::graph_container::MainModuleGraphContainer;\n+use crate::graph_container::ModuleGraphContainer;\n+use crate::graph_container::ModuleGraphUpdatePermit;\n+use crate::module_loader::ModuleLoadPreparer;\n+use crate::module_loader::PrepareModuleLoadOptions;\n+use crate::node::CliNodeResolver;\n+use crate::npm::CliNpmCache;\n+use crate::npm::CliNpmCacheHttpClient;\n+use crate::npm::CliNpmRegistryInfoProvider;\n+use crate::npm::CliNpmResolver;\n+use crate::resolver::CliNpmReqResolver;\n+use crate::resolver::CliResolver;\n+use crate::sys::CliSys;\n+\n+const ESBUILD_VERSION: &str = \"0.25.5\";\n+\n+pub async fn ensure_esbuild(\n+  deno_dir: &DenoDir,\n+  npmrc: &ResolvedNpmRc,\n+  npm_registry_info: &Arc<CliNpmRegistryInfoProvider>,\n+  workspace_patch_packages: &Arc<WorkspaceNpmPatchPackages>,\n+  tarball_cache: &Arc<TarballCache<CliNpmCacheHttpClient, CliSys>>,\n+  npm_cache: &CliNpmCache,\n+  target: &str,\n+) -> Result<PathBuf, AnyError> {\n+  let esbuild_path = deno_dir\n+    .dl_folder_path()\n+    .join(format!(\"esbuild-{}\", ESBUILD_VERSION))\n+    .join(format!(\"esbuild-{}\", target));\n+\n+  if esbuild_path.exists() {\n+    return Ok(esbuild_path);\n+  }\n+  let pkg_name = format!(\"@esbuild/{}\", target);\n+  let nv =\n+    PackageNv::from_str(&format!(\"{}@{}\", pkg_name, ESBUILD_VERSION)).unwrap();\n+  let api = npm_registry_info.as_npm_registry_api();\n+  let info = api.package_info(&pkg_name).await?;\n+  let version_info = info.version_info(&nv, &workspace_patch_packages.0)?;\n+  if let Some(dist) = &version_info.dist {\n+    let registry_url = npmrc.get_registry_url(&nv.name);\n+    let package_folder =\n+      npm_cache.package_folder_for_nv_and_url(&nv, registry_url);\n+    let existed = package_folder.exists();\n+\n+    if !existed {\n+      tarball_cache.ensure_package(&nv, &dist).await?;\n+    }\n+\n+    let path = package_folder.join(\"bin/esbuild\");\n+\n+    std::fs::create_dir_all(esbuild_path.parent().unwrap())?;\n+    std::fs::copy(&path, &esbuild_path)?;\n+\n+    if !existed {\n+      std::fs::remove_dir_all(&package_folder)?;\n+    }\n+    return Ok(esbuild_path);\n+  }\n+  anyhow::bail!(\"esbuild not found\");\n+}\n+\n+pub async fn bundle(\n+  flags: Arc<Flags>,\n+  mut bundle_flags: BundleFlags,\n+) -> Result<(), AnyError> {\n+  let factory = CliFactory::from_flags(flags);\n+\n+  let installer_factory = factory.npm_installer_factory()?;\n+  let npmrc = factory.npmrc()?;\n+  let deno_dir = factory.deno_dir()?;\n+  let resolver_factory = factory.resolver_factory()?;\n+  let workspace_factory = resolver_factory.workspace_factory();\n+  let npm_registry_info = installer_factory.registry_info_provider()?;\n+  let esbuild_path = ensure_esbuild(\n+    &deno_dir,\n+    &npmrc,\n+    npm_registry_info,\n+    workspace_factory.workspace_npm_patch_packages()?,\n+    installer_factory.tarball_cache()?,\n+    factory.npm_cache()?,\n+    \"darwin-arm64\",\n+  )\n+  .await?;\n+  let resolver = factory.resolver().await?.clone();\n+  let module_load_preparer = factory.module_load_preparer().await?.clone();\n+  let root_permissions = factory.root_permissions_container()?;\n+  let npm_resolver = factory.npm_resolver().await?.clone();\n+  let node_resolver = factory.node_resolver().await?.clone();\n+  let cli_options = factory.cli_options()?;\n+  let module_loader = factory\n+    .create_module_loader_factory()\n+    .await?\n+    .create_for_main(root_permissions.clone())\n+    .module_loader;\n+  let sys = factory.sys();\n+  let init_cwd = cli_options.initial_cwd().canonicalize()?;\n+\n+  let plugin_handler = Arc::new(DenoPluginHandler {\n+    resolver: resolver.clone(),\n+    module_load_preparer,\n+    module_graph_container: factory\n+      .main_module_graph_container()\n+      .await?\n+      .clone(),\n+    permissions: root_permissions.clone(),\n+    npm_req_resolver: factory.npm_req_resolver()?.clone(),\n+    npm_resolver: npm_resolver.clone(),\n+    node_resolver: node_resolver.clone(),\n+    http_cache: factory.http_cache()?.clone(),\n+    module_loader: module_loader.clone(),\n+  });\n+  let start = std::time::Instant::now();\n+\n+  let entrypoint = bundle_flags\n+    .entrypoints\n+    .first()\n+    .iter()\n+    .map(|e| resolve_url_or_path(e, &init_cwd).unwrap())\n+    .collect::<Vec<_>>();\n+  let resolved = {\n+    let mut resolved = vec![];\n+    let init_cwd_url = Url::from_directory_path(&init_cwd).unwrap();\n+    for e in &entrypoint {\n+      let r = resolver\n+        .resolve(\n+          e.as_str(),\n+          &init_cwd_url,\n+          Position::new(0, 0),\n+          ResolutionMode::Import,\n+          NodeResolutionKind::Execution,\n+        )\n+        .unwrap();\n+      resolved.push(r);\n+    }\n+    resolved\n+  };\n+\n+  let roots = resolved\n+    .into_iter()\n+    .map(|url| {\n+      if let Ok(v) = NpmPackageReqReference::from_specifier(&url) {\n+        let referrer =\n+          ModuleSpecifier::from_directory_path(sys.env_current_dir().unwrap())\n+            .unwrap()\n+            .join(\"package.json\")\n+            .unwrap();\n+        let package_folder = npm_resolver\n+          .resolve_pkg_folder_from_deno_module_req(v.req(), &referrer)\n+          .unwrap();\n+        let main_module = node_resolver\n+          .resolve_binary_export(&package_folder, v.sub_path())\n+          .unwrap();\n+        Url::from_file_path(&main_module).unwrap()\n+      } else {\n+        url\n+      }\n+    })\n+    .collect::<Vec<_>>();\n+  let _ = plugin_handler.prepare_module_load(&roots).await;\n+  let esbuild =\n+    EsbuildService::new(esbuild_path, ESBUILD_VERSION, plugin_handler.clone())\n+      .await\n+      .unwrap();\n+  let client = esbuild.client().clone();\n+\n+  {\n+    tokio::spawn(async move {\n+      loop {\n+        tokio::select! {\n+            res = esbuild.wait_for_exit() => {\n+                eprintln!(\"esbuild exited: {:?}\", res);\n+                break;\n+            }\n+        }\n+      }\n+\n+      Ok::<(), AnyError>(())\n+    });\n+  }\n+\n+  bundle_flags.external.push(\"*.node\".into());\n+\n+  let mut builder = EsbuildFlagsBuilder::default();\n+  builder\n+    .bundle(bundle_flags.bundle)\n+    .minify(bundle_flags.minify)\n+    .splitting(bundle_flags.code_splitting)\n+    .external(bundle_flags.external.clone())\n+    .format(match bundle_flags.format {\n+      BundleFormat::Esm => esbuild_rs::Format::Esm,\n+      BundleFormat::Cjs => esbuild_rs::Format::Cjs,\n+      BundleFormat::Iife => esbuild_rs::Format::Iife,\n+    })\n+    .packages(match bundle_flags.packages {\n+      PackageHandling::External => esbuild_rs::PackagesHandling::External,\n+      PackageHandling::Bundle => esbuild_rs::PackagesHandling::Bundle,\n+    });\n+  if let Some(outdir) = bundle_flags.output_dir.clone() {\n+    builder.outdir(outdir);\n+  } else {\n+    builder.outfile(\n+      bundle_flags\n+        .output_path\n+        .clone()\n+        .unwrap_or_else(|| \"./dist/bundled.js\".to_string()),\n+    );\n+  }\n+  let flags = builder.build().unwrap();\n+\n+  let entries = roots.into_iter().map(|e| (\"\".into(), e.into())).collect();\n+\n+  let response = client\n+    .send_build_request(protocol::BuildRequest {\n+      entries,\n+      key: 0,\n+      flags: flags.to_flags(),\n+      write: true,\n+      stdin_contents: None.into(),\n+      stdin_resolve_dir: None.into(),\n+      abs_working_dir: init_cwd.to_string_lossy().to_string(),\n+      context: false,\n+      mangle_cache: None.into(),\n+      node_paths: vec![],\n+      plugins: Some(vec![protocol::BuildPlugin {\n+        name: \"deno\".into(),\n+        on_start: false,\n+        on_end: false,\n+        on_resolve: (vec![protocol::OnResolveSetupOptions {\n+          id: 0,\n+          filter: \".*\".into(),\n+          namespace: \"\".into(),\n+        }]),\n+        on_load: vec![protocol::OnLoadSetupOptions {\n+          id: 0,\n+          filter: \".*\".into(),\n+          namespace: \"\".into(),\n+        }],\n+      }]),\n+    })\n+    .await\n+    .unwrap();\n+\n+  if response.errors.len() > 0 {\n+    for error in &response.errors {\n+      eprintln!(\n+        \"{}: {}\",\n+        deno_terminal::colors::red(\"bundler error\"),\n+        format_message(error)\n+      );\n+    }\n+  }\n+\n+  if response.warnings.len() > 0 {\n+    for warning in &response.warnings {\n+      eprintln!(\n+        \"{}: {}\",\n+        deno_terminal::colors::yellow(\"bundler warning\"),\n+        format_message(warning)\n+      );\n+    }\n+  }\n+\n+  if let Some(stdout) = response.write_to_stdout {\n+    println!(\"{}\", String::from_utf8_lossy(&stdout));\n+  } else if response.errors.len() == 0 {\n+    if bundle_flags.output_dir.is_none()\n+      && std::env::var(\"NO_DENO_BUNDLE_HACK\").is_err()\n+    {\n+      // TODO(nathanwhit): MASSIVE HACK",
        "comment_created_at": "2025-05-28T20:05:05+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Maybe move it to a helper function and add some comments on the purpose of this hack?\r\n\r\nAre there tests that cover it?",
        "pr_file_module": null
      },
      {
        "comment_id": "2116444852",
        "repo_full_name": "denoland/deno",
        "pr_number": 29470,
        "pr_file": "cli/tools/bundle/mod.rs",
        "discussion_id": "2112658173",
        "commented_code": "@@ -0,0 +1,879 @@\n+use std::path::Path;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::sync::Arc;\n+\n+use deno_ast::ModuleSpecifier;\n+use deno_cache_dir::GlobalOrLocalHttpCache;\n+use deno_config::deno_json::TsTypeLib;\n+use deno_core::anyhow;\n+use deno_core::error::AnyError;\n+use deno_core::resolve_url_or_path;\n+use deno_core::url::Url;\n+use deno_core::ModuleLoader;\n+use deno_error::JsError;\n+use deno_graph::Position;\n+use deno_lib::worker::ModuleLoaderFactory;\n+use deno_npm::npm_rc::ResolvedNpmRc;\n+use deno_npm::registry::NpmRegistryApi;\n+use deno_npm_cache::TarballCache;\n+use deno_resolver::npm::managed::ResolvePkgFolderFromDenoModuleError;\n+use deno_resolver::workspace::WorkspaceNpmPatchPackages;\n+use deno_runtime::deno_permissions::PermissionsContainer;\n+use deno_semver::npm::NpmPackageReqReference;\n+use deno_semver::package::PackageNv;\n+use esbuild_rs::protocol;\n+use esbuild_rs::EsbuildFlagsBuilder;\n+use esbuild_rs::EsbuildService;\n+use indexmap::IndexMap;\n+use node_resolver::errors::PackageSubpathResolveError;\n+use node_resolver::NodeResolutionKind;\n+use node_resolver::ResolutionMode;\n+use sys_traits::EnvCurrentDir;\n+\n+use crate::args::BundleFlags;\n+use crate::args::BundleFormat;\n+use crate::args::Flags;\n+use crate::args::PackageHandling;\n+use crate::cache::DenoDir;\n+use crate::factory::CliFactory;\n+use crate::graph_container::MainModuleGraphContainer;\n+use crate::graph_container::ModuleGraphContainer;\n+use crate::graph_container::ModuleGraphUpdatePermit;\n+use crate::module_loader::ModuleLoadPreparer;\n+use crate::module_loader::PrepareModuleLoadOptions;\n+use crate::node::CliNodeResolver;\n+use crate::npm::CliNpmCache;\n+use crate::npm::CliNpmCacheHttpClient;\n+use crate::npm::CliNpmRegistryInfoProvider;\n+use crate::npm::CliNpmResolver;\n+use crate::resolver::CliNpmReqResolver;\n+use crate::resolver::CliResolver;\n+use crate::sys::CliSys;\n+\n+const ESBUILD_VERSION: &str = \"0.25.5\";\n+\n+pub async fn ensure_esbuild(\n+  deno_dir: &DenoDir,\n+  npmrc: &ResolvedNpmRc,\n+  npm_registry_info: &Arc<CliNpmRegistryInfoProvider>,\n+  workspace_patch_packages: &Arc<WorkspaceNpmPatchPackages>,\n+  tarball_cache: &Arc<TarballCache<CliNpmCacheHttpClient, CliSys>>,\n+  npm_cache: &CliNpmCache,\n+  target: &str,\n+) -> Result<PathBuf, AnyError> {\n+  let esbuild_path = deno_dir\n+    .dl_folder_path()\n+    .join(format!(\"esbuild-{}\", ESBUILD_VERSION))\n+    .join(format!(\"esbuild-{}\", target));\n+\n+  if esbuild_path.exists() {\n+    return Ok(esbuild_path);\n+  }\n+  let pkg_name = format!(\"@esbuild/{}\", target);\n+  let nv =\n+    PackageNv::from_str(&format!(\"{}@{}\", pkg_name, ESBUILD_VERSION)).unwrap();\n+  let api = npm_registry_info.as_npm_registry_api();\n+  let info = api.package_info(&pkg_name).await?;\n+  let version_info = info.version_info(&nv, &workspace_patch_packages.0)?;\n+  if let Some(dist) = &version_info.dist {\n+    let registry_url = npmrc.get_registry_url(&nv.name);\n+    let package_folder =\n+      npm_cache.package_folder_for_nv_and_url(&nv, registry_url);\n+    let existed = package_folder.exists();\n+\n+    if !existed {\n+      tarball_cache.ensure_package(&nv, &dist).await?;\n+    }\n+\n+    let path = package_folder.join(\"bin/esbuild\");\n+\n+    std::fs::create_dir_all(esbuild_path.parent().unwrap())?;\n+    std::fs::copy(&path, &esbuild_path)?;\n+\n+    if !existed {\n+      std::fs::remove_dir_all(&package_folder)?;\n+    }\n+    return Ok(esbuild_path);\n+  }\n+  anyhow::bail!(\"esbuild not found\");\n+}\n+\n+pub async fn bundle(\n+  flags: Arc<Flags>,\n+  mut bundle_flags: BundleFlags,\n+) -> Result<(), AnyError> {\n+  let factory = CliFactory::from_flags(flags);\n+\n+  let installer_factory = factory.npm_installer_factory()?;\n+  let npmrc = factory.npmrc()?;\n+  let deno_dir = factory.deno_dir()?;\n+  let resolver_factory = factory.resolver_factory()?;\n+  let workspace_factory = resolver_factory.workspace_factory();\n+  let npm_registry_info = installer_factory.registry_info_provider()?;\n+  let esbuild_path = ensure_esbuild(\n+    &deno_dir,\n+    &npmrc,\n+    npm_registry_info,\n+    workspace_factory.workspace_npm_patch_packages()?,\n+    installer_factory.tarball_cache()?,\n+    factory.npm_cache()?,\n+    \"darwin-arm64\",\n+  )\n+  .await?;\n+  let resolver = factory.resolver().await?.clone();\n+  let module_load_preparer = factory.module_load_preparer().await?.clone();\n+  let root_permissions = factory.root_permissions_container()?;\n+  let npm_resolver = factory.npm_resolver().await?.clone();\n+  let node_resolver = factory.node_resolver().await?.clone();\n+  let cli_options = factory.cli_options()?;\n+  let module_loader = factory\n+    .create_module_loader_factory()\n+    .await?\n+    .create_for_main(root_permissions.clone())\n+    .module_loader;\n+  let sys = factory.sys();\n+  let init_cwd = cli_options.initial_cwd().canonicalize()?;\n+\n+  let plugin_handler = Arc::new(DenoPluginHandler {\n+    resolver: resolver.clone(),\n+    module_load_preparer,\n+    module_graph_container: factory\n+      .main_module_graph_container()\n+      .await?\n+      .clone(),\n+    permissions: root_permissions.clone(),\n+    npm_req_resolver: factory.npm_req_resolver()?.clone(),\n+    npm_resolver: npm_resolver.clone(),\n+    node_resolver: node_resolver.clone(),\n+    http_cache: factory.http_cache()?.clone(),\n+    module_loader: module_loader.clone(),\n+  });\n+  let start = std::time::Instant::now();\n+\n+  let entrypoint = bundle_flags\n+    .entrypoints\n+    .first()\n+    .iter()\n+    .map(|e| resolve_url_or_path(e, &init_cwd).unwrap())\n+    .collect::<Vec<_>>();\n+  let resolved = {\n+    let mut resolved = vec![];\n+    let init_cwd_url = Url::from_directory_path(&init_cwd).unwrap();\n+    for e in &entrypoint {\n+      let r = resolver\n+        .resolve(\n+          e.as_str(),\n+          &init_cwd_url,\n+          Position::new(0, 0),\n+          ResolutionMode::Import,\n+          NodeResolutionKind::Execution,\n+        )\n+        .unwrap();\n+      resolved.push(r);\n+    }\n+    resolved\n+  };\n+\n+  let roots = resolved\n+    .into_iter()\n+    .map(|url| {\n+      if let Ok(v) = NpmPackageReqReference::from_specifier(&url) {\n+        let referrer =\n+          ModuleSpecifier::from_directory_path(sys.env_current_dir().unwrap())\n+            .unwrap()\n+            .join(\"package.json\")\n+            .unwrap();\n+        let package_folder = npm_resolver\n+          .resolve_pkg_folder_from_deno_module_req(v.req(), &referrer)\n+          .unwrap();\n+        let main_module = node_resolver\n+          .resolve_binary_export(&package_folder, v.sub_path())\n+          .unwrap();\n+        Url::from_file_path(&main_module).unwrap()\n+      } else {\n+        url\n+      }\n+    })\n+    .collect::<Vec<_>>();\n+  let _ = plugin_handler.prepare_module_load(&roots).await;\n+  let esbuild =\n+    EsbuildService::new(esbuild_path, ESBUILD_VERSION, plugin_handler.clone())\n+      .await\n+      .unwrap();\n+  let client = esbuild.client().clone();\n+\n+  {\n+    tokio::spawn(async move {\n+      loop {\n+        tokio::select! {\n+            res = esbuild.wait_for_exit() => {\n+                eprintln!(\"esbuild exited: {:?}\", res);\n+                break;\n+            }\n+        }\n+      }\n+\n+      Ok::<(), AnyError>(())\n+    });\n+  }\n+\n+  bundle_flags.external.push(\"*.node\".into());\n+\n+  let mut builder = EsbuildFlagsBuilder::default();\n+  builder\n+    .bundle(bundle_flags.bundle)\n+    .minify(bundle_flags.minify)\n+    .splitting(bundle_flags.code_splitting)\n+    .external(bundle_flags.external.clone())\n+    .format(match bundle_flags.format {\n+      BundleFormat::Esm => esbuild_rs::Format::Esm,\n+      BundleFormat::Cjs => esbuild_rs::Format::Cjs,\n+      BundleFormat::Iife => esbuild_rs::Format::Iife,\n+    })\n+    .packages(match bundle_flags.packages {\n+      PackageHandling::External => esbuild_rs::PackagesHandling::External,\n+      PackageHandling::Bundle => esbuild_rs::PackagesHandling::Bundle,\n+    });\n+  if let Some(outdir) = bundle_flags.output_dir.clone() {\n+    builder.outdir(outdir);\n+  } else {\n+    builder.outfile(\n+      bundle_flags\n+        .output_path\n+        .clone()\n+        .unwrap_or_else(|| \"./dist/bundled.js\".to_string()),\n+    );\n+  }\n+  let flags = builder.build().unwrap();\n+\n+  let entries = roots.into_iter().map(|e| (\"\".into(), e.into())).collect();\n+\n+  let response = client\n+    .send_build_request(protocol::BuildRequest {\n+      entries,\n+      key: 0,\n+      flags: flags.to_flags(),\n+      write: true,\n+      stdin_contents: None.into(),\n+      stdin_resolve_dir: None.into(),\n+      abs_working_dir: init_cwd.to_string_lossy().to_string(),\n+      context: false,\n+      mangle_cache: None.into(),\n+      node_paths: vec![],\n+      plugins: Some(vec![protocol::BuildPlugin {\n+        name: \"deno\".into(),\n+        on_start: false,\n+        on_end: false,\n+        on_resolve: (vec![protocol::OnResolveSetupOptions {\n+          id: 0,\n+          filter: \".*\".into(),\n+          namespace: \"\".into(),\n+        }]),\n+        on_load: vec![protocol::OnLoadSetupOptions {\n+          id: 0,\n+          filter: \".*\".into(),\n+          namespace: \"\".into(),\n+        }],\n+      }]),\n+    })\n+    .await\n+    .unwrap();\n+\n+  if response.errors.len() > 0 {\n+    for error in &response.errors {\n+      eprintln!(\n+        \"{}: {}\",\n+        deno_terminal::colors::red(\"bundler error\"),\n+        format_message(error)\n+      );\n+    }\n+  }\n+\n+  if response.warnings.len() > 0 {\n+    for warning in &response.warnings {\n+      eprintln!(\n+        \"{}: {}\",\n+        deno_terminal::colors::yellow(\"bundler warning\"),\n+        format_message(warning)\n+      );\n+    }\n+  }\n+\n+  if let Some(stdout) = response.write_to_stdout {\n+    println!(\"{}\", String::from_utf8_lossy(&stdout));\n+  } else if response.errors.len() == 0 {\n+    if bundle_flags.output_dir.is_none()\n+      && std::env::var(\"NO_DENO_BUNDLE_HACK\").is_err()\n+    {\n+      // TODO(nathanwhit): MASSIVE HACK",
        "comment_created_at": "2025-05-30T18:41:37+00:00",
        "comment_author": "nathanwhit",
        "comment_body": "Extracted it out and added a test + comments",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2112798882",
    "pr_number": 29327,
    "pr_file": "runtime/permissions/lib.rs",
    "created_at": "2025-05-28T21:39:14+00:00",
    "commented_code": "pub deny_write: Option<Vec<String>>,\n   pub allow_import: Option<Vec<String>>,\n   pub prompt: bool,\n+  pub unstable_subdomain_wildcards: bool,",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2112798882",
        "repo_full_name": "denoland/deno",
        "pr_number": 29327,
        "pr_file": "runtime/permissions/lib.rs",
        "discussion_id": "2112798882",
        "commented_code": "@@ -2117,6 +2193,7 @@ pub struct PermissionsOptions {\n   pub deny_write: Option<Vec<String>>,\n   pub allow_import: Option<Vec<String>>,\n   pub prompt: bool,\n+  pub unstable_subdomain_wildcards: bool,",
        "comment_created_at": "2025-05-28T21:39:14+00:00",
        "comment_author": "dsherret",
        "comment_body": "Instead of this being here and on `Permissions`. I think it should be a constructor parameter to `RuntimePermissionDescriptorParser`? That way the value isn't being passed around horizontally through the code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2112812169",
        "repo_full_name": "denoland/deno",
        "pr_number": 29327,
        "pr_file": "runtime/permissions/lib.rs",
        "discussion_id": "2112798882",
        "commented_code": "@@ -2117,6 +2193,7 @@ pub struct PermissionsOptions {\n   pub deny_write: Option<Vec<String>>,\n   pub allow_import: Option<Vec<String>>,\n   pub prompt: bool,\n+  pub unstable_subdomain_wildcards: bool,",
        "comment_created_at": "2025-05-28T21:51:48+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "I agree with David",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2089779622",
    "pr_number": 29299,
    "pr_file": "cli/npm/installer/common/deno_task_executor.rs",
    "created_at": "2025-05-14T21:26:07+00:00",
    "commented_code": "+// Copyright 2018-2025 the Deno authors. MIT license.\n+\n+use std::borrow::Cow;\n+use std::collections::HashSet;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+\n+use deno_core::error::AnyError;\n+use deno_npm::resolution::NpmResolutionSnapshot;\n+use deno_npm::NpmResolutionPackage;\n+use deno_resolver::npm::ManagedNpmResolverRc;\n+use deno_runtime::deno_io::FromRawIoHandle;\n+use deno_task_shell::KillSignal;\n+\n+use super::bin_entries::BinEntries;\n+use super::lifecycle_scripts::is_broken_default_install_script;\n+use super::lifecycle_scripts::LifecycleScriptsExecutor;\n+use super::lifecycle_scripts::LifecycleScriptsExecutorOptions;\n+use super::lifecycle_scripts::PackageWithScript;\n+use super::lifecycle_scripts::LIFECYCLE_SCRIPTS_RUNNING_ENV_VAR;\n+use super::CachedNpmPackageExtraInfoProvider;\n+use super::ExpectedExtraInfo;\n+use crate::sys::CliSys;\n+use crate::task_runner::TaskStdio;\n+use crate::util::progress_bar::ProgressMessagePrompt;\n+\n+#[derive(Debug, thiserror::Error, deno_error::JsError)]\n+pub enum DenoTaskLifecycleScriptsError {\n+  #[class(inherit)]\n+  #[error(transparent)]\n+  Io(#[from] std::io::Error),\n+  #[class(inherit)]\n+  #[error(transparent)]\n+  BinEntries(#[from] super::bin_entries::BinEntriesError),\n+  #[class(inherit)]\n+  #[error(\n+    \"failed to create npm process state tempfile for running lifecycle scripts\"\n+  )]\n+  CreateNpmProcessState(#[source] std::io::Error),\n+  #[class(generic)]\n+  #[error(transparent)]\n+  Task(AnyError),\n+  #[class(generic)]\n+  #[error(\"failed to run scripts for packages: {}\", .0.join(\", \"))]\n+  RunScripts(Vec<String>),\n+}\n+\n+pub struct DenoTaskLifeCycleScriptsExecutor {\n+  npm_resolver: ManagedNpmResolverRc<CliSys>,\n+}\n+\n+#[async_trait::async_trait(?Send)]\n+impl LifecycleScriptsExecutor for DenoTaskLifeCycleScriptsExecutor {\n+  async fn execute(\n+    &self,\n+    options: LifecycleScriptsExecutorOptions<'_>,\n+  ) -> Result<(), AnyError> {\n+    let mut failed_packages = Vec::new();\n+    let mut bin_entries = BinEntries::new();\n+    // get custom commands for each bin available in the node_modules dir (essentially\n+    // the scripts that are in `node_modules/.bin`)\n+    let base = self\n+      .resolve_baseline_custom_commands(\n+        options.extra_info_provider,\n+        &mut bin_entries,\n+        options.snapshot,\n+        options.system_packages,\n+      )\n+      .await;\n+\n+    // we don't run with signals forwarded because once signals\n+    // are setup then they're process wide.\n+    let kill_signal = KillSignal::default();\n+    let _drop_signal = kill_signal.clone().drop_guard();\n+\n+    let mut env_vars = crate::task_runner::real_env_vars();\n+    // so the subprocess can detect that it is running as part of a lifecycle script,\n+    // and avoid trying to set up node_modules again\n+    env_vars.insert(LIFECYCLE_SCRIPTS_RUNNING_ENV_VAR.into(), \"1\".into());\n+    // we want to pass the current state of npm resolution down to the deno subprocess\n+    // (that may be running as part of the script). we do this with an inherited temp file\n+    //\n+    // SAFETY: we are sharing a single temp file across all of the scripts. the file position\n+    // will be shared among these, which is okay since we run only one script at a time.\n+    // However, if we concurrently run scripts in the future we will\n+    // have to have multiple temp files.\n+    let temp_file_fd = deno_runtime::deno_process::npm_process_state_tempfile(\n+      options.process_state.as_bytes(),\n+    )\n+    .map_err(DenoTaskLifecycleScriptsError::CreateNpmProcessState)?;\n+    // SAFETY: fd/handle is valid\n+    let _temp_file = unsafe { std::fs::File::from_raw_io_handle(temp_file_fd) }; // make sure the file gets closed\n+    env_vars.insert(\n+      deno_runtime::deno_process::NPM_RESOLUTION_STATE_FD_ENV_VAR_NAME.into(),\n+      (temp_file_fd as usize).to_string().into(),\n+    );\n+    for PackageWithScript {\n+      package,\n+      scripts,\n+      package_folder,\n+    } in options.packages_with_scripts\n+    {\n+      // add custom commands for binaries from the package's dependencies. this will take precedence over the\n+      // baseline commands, so if the package relies on a bin that conflicts with one higher in the dependency tree, the\n+      // correct bin will be used.\n+      let custom_commands = self\n+        .resolve_custom_commands_from_deps(\n+          options.extra_info_provider,\n+          base.clone(),\n+          package,\n+          options.snapshot,\n+        )\n+        .await;\n+      for script_name in [\"preinstall\", \"install\", \"postinstall\"] {\n+        if let Some(script) = scripts.get(script_name) {\n+          if script_name == \"install\"\n+            && is_broken_default_install_script(script, package_folder)\n+          {\n+            continue;\n+          }\n+          let _guard = options.progress_bar.update_with_prompt(\n+            ProgressMessagePrompt::Initialize,\n+            &format!(\"{}: running '{script_name}' script\", package.id.nv),\n+          );",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2089779622",
        "repo_full_name": "denoland/deno",
        "pr_number": 29299,
        "pr_file": "cli/npm/installer/common/deno_task_executor.rs",
        "discussion_id": "2089779622",
        "commented_code": "@@ -0,0 +1,337 @@\n+// Copyright 2018-2025 the Deno authors. MIT license.\n+\n+use std::borrow::Cow;\n+use std::collections::HashSet;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+\n+use deno_core::error::AnyError;\n+use deno_npm::resolution::NpmResolutionSnapshot;\n+use deno_npm::NpmResolutionPackage;\n+use deno_resolver::npm::ManagedNpmResolverRc;\n+use deno_runtime::deno_io::FromRawIoHandle;\n+use deno_task_shell::KillSignal;\n+\n+use super::bin_entries::BinEntries;\n+use super::lifecycle_scripts::is_broken_default_install_script;\n+use super::lifecycle_scripts::LifecycleScriptsExecutor;\n+use super::lifecycle_scripts::LifecycleScriptsExecutorOptions;\n+use super::lifecycle_scripts::PackageWithScript;\n+use super::lifecycle_scripts::LIFECYCLE_SCRIPTS_RUNNING_ENV_VAR;\n+use super::CachedNpmPackageExtraInfoProvider;\n+use super::ExpectedExtraInfo;\n+use crate::sys::CliSys;\n+use crate::task_runner::TaskStdio;\n+use crate::util::progress_bar::ProgressMessagePrompt;\n+\n+#[derive(Debug, thiserror::Error, deno_error::JsError)]\n+pub enum DenoTaskLifecycleScriptsError {\n+  #[class(inherit)]\n+  #[error(transparent)]\n+  Io(#[from] std::io::Error),\n+  #[class(inherit)]\n+  #[error(transparent)]\n+  BinEntries(#[from] super::bin_entries::BinEntriesError),\n+  #[class(inherit)]\n+  #[error(\n+    \"failed to create npm process state tempfile for running lifecycle scripts\"\n+  )]\n+  CreateNpmProcessState(#[source] std::io::Error),\n+  #[class(generic)]\n+  #[error(transparent)]\n+  Task(AnyError),\n+  #[class(generic)]\n+  #[error(\"failed to run scripts for packages: {}\", .0.join(\", \"))]\n+  RunScripts(Vec<String>),\n+}\n+\n+pub struct DenoTaskLifeCycleScriptsExecutor {\n+  npm_resolver: ManagedNpmResolverRc<CliSys>,\n+}\n+\n+#[async_trait::async_trait(?Send)]\n+impl LifecycleScriptsExecutor for DenoTaskLifeCycleScriptsExecutor {\n+  async fn execute(\n+    &self,\n+    options: LifecycleScriptsExecutorOptions<'_>,\n+  ) -> Result<(), AnyError> {\n+    let mut failed_packages = Vec::new();\n+    let mut bin_entries = BinEntries::new();\n+    // get custom commands for each bin available in the node_modules dir (essentially\n+    // the scripts that are in `node_modules/.bin`)\n+    let base = self\n+      .resolve_baseline_custom_commands(\n+        options.extra_info_provider,\n+        &mut bin_entries,\n+        options.snapshot,\n+        options.system_packages,\n+      )\n+      .await;\n+\n+    // we don't run with signals forwarded because once signals\n+    // are setup then they're process wide.\n+    let kill_signal = KillSignal::default();\n+    let _drop_signal = kill_signal.clone().drop_guard();\n+\n+    let mut env_vars = crate::task_runner::real_env_vars();\n+    // so the subprocess can detect that it is running as part of a lifecycle script,\n+    // and avoid trying to set up node_modules again\n+    env_vars.insert(LIFECYCLE_SCRIPTS_RUNNING_ENV_VAR.into(), \"1\".into());\n+    // we want to pass the current state of npm resolution down to the deno subprocess\n+    // (that may be running as part of the script). we do this with an inherited temp file\n+    //\n+    // SAFETY: we are sharing a single temp file across all of the scripts. the file position\n+    // will be shared among these, which is okay since we run only one script at a time.\n+    // However, if we concurrently run scripts in the future we will\n+    // have to have multiple temp files.\n+    let temp_file_fd = deno_runtime::deno_process::npm_process_state_tempfile(\n+      options.process_state.as_bytes(),\n+    )\n+    .map_err(DenoTaskLifecycleScriptsError::CreateNpmProcessState)?;\n+    // SAFETY: fd/handle is valid\n+    let _temp_file = unsafe { std::fs::File::from_raw_io_handle(temp_file_fd) }; // make sure the file gets closed\n+    env_vars.insert(\n+      deno_runtime::deno_process::NPM_RESOLUTION_STATE_FD_ENV_VAR_NAME.into(),\n+      (temp_file_fd as usize).to_string().into(),\n+    );\n+    for PackageWithScript {\n+      package,\n+      scripts,\n+      package_folder,\n+    } in options.packages_with_scripts\n+    {\n+      // add custom commands for binaries from the package's dependencies. this will take precedence over the\n+      // baseline commands, so if the package relies on a bin that conflicts with one higher in the dependency tree, the\n+      // correct bin will be used.\n+      let custom_commands = self\n+        .resolve_custom_commands_from_deps(\n+          options.extra_info_provider,\n+          base.clone(),\n+          package,\n+          options.snapshot,\n+        )\n+        .await;\n+      for script_name in [\"preinstall\", \"install\", \"postinstall\"] {\n+        if let Some(script) = scripts.get(script_name) {\n+          if script_name == \"install\"\n+            && is_broken_default_install_script(script, package_folder)\n+          {\n+            continue;\n+          }\n+          let _guard = options.progress_bar.update_with_prompt(\n+            ProgressMessagePrompt::Initialize,\n+            &format!(\"{}: running '{script_name}' script\", package.id.nv),\n+          );",
        "comment_created_at": "2025-05-14T21:26:07+00:00",
        "comment_author": "dsherret",
        "comment_body": "We'll need to figure out how to extract out the progress bar stuff from here before extracting this to a new crate.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2085435327",
    "pr_number": 29249,
    "pr_file": "cli/tools/jupyter/install.rs",
    "created_at": "2025-05-12T20:41:03+00:00",
    "commented_code": "Ok(())\n }\n \n-pub fn install() -> Result<(), AnyError> {\n-  let user_data_dir = user_data_dir()?;\n-  let kernel_dir = user_data_dir.join(\"kernels\").join(\"deno\");\n+pub fn install(\n+  maybe_name: Option<&str>,\n+  maybe_display_name: Option<&str>,\n+  force: bool,\n+) -> Result<(), AnyError> {\n+  let user_data_dir = if let Ok(env_var) = std::env::var(TEST_ENV_VAR_NAME) {\n+    PathBuf::from(env_var)",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2085435327",
        "repo_full_name": "denoland/deno",
        "pr_number": 29249,
        "pr_file": "cli/tools/jupyter/install.rs",
        "discussion_id": "2085435327",
        "commented_code": "@@ -39,29 +59,73 @@ fn install_icon(\n   Ok(())\n }\n \n-pub fn install() -> Result<(), AnyError> {\n-  let user_data_dir = user_data_dir()?;\n-  let kernel_dir = user_data_dir.join(\"kernels\").join(\"deno\");\n+pub fn install(\n+  maybe_name: Option<&str>,\n+  maybe_display_name: Option<&str>,\n+  force: bool,\n+) -> Result<(), AnyError> {\n+  let user_data_dir = if let Ok(env_var) = std::env::var(TEST_ENV_VAR_NAME) {\n+    PathBuf::from(env_var)",
        "comment_created_at": "2025-05-12T20:41:03+00:00",
        "comment_author": "dsherret",
        "comment_body": "```suggestion\r\n  let user_data_dir = if let Some(env_var) = std::env::var_os(TEST_ENV_VAR_NAME) {\r\n    PathBuf::from(env_var)\r\n```\r\n\r\nDeja-vu. Should this code be extracted out to a reusable function?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2067436135",
    "pr_number": 28424,
    "pr_file": "cli/tools/clean.rs",
    "created_at": "2025-04-29T21:11:21+00:00",
    "commented_code": "Ok(())\n }\n \n+#[derive(Clone, Debug, Default)]\n+struct PathNode {\n+  exact: bool,\n+  children: BTreeMap<OsString, usize>,\n+}\n+#[derive(Debug)]\n+struct PathTrie {\n+  root: usize,\n+  nodes: Vec<PathNode>,\n+  rewrites: Vec<(PathBuf, PathBuf)>,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+enum Found {\n+  Match,\n+  Prefix,\n+}",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2067436135",
        "repo_full_name": "denoland/deno",
        "pr_number": 28424,
        "pr_file": "cli/tools/clean.rs",
        "discussion_id": "2067436135",
        "commented_code": "@@ -69,6 +92,502 @@ pub fn clean(flags: Arc<Flags>) -> Result<(), AnyError> {\n   Ok(())\n }\n \n+#[derive(Clone, Debug, Default)]\n+struct PathNode {\n+  exact: bool,\n+  children: BTreeMap<OsString, usize>,\n+}\n+#[derive(Debug)]\n+struct PathTrie {\n+  root: usize,\n+  nodes: Vec<PathNode>,\n+  rewrites: Vec<(PathBuf, PathBuf)>,\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+enum Found {\n+  Match,\n+  Prefix,\n+}",
        "comment_created_at": "2025-04-29T21:11:21+00:00",
        "comment_author": "dsherret",
        "comment_body": "Nitpick: Maybe move this about PathTree so that the PathTrie struct w/ impl is beside each other?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2066794944",
    "pr_number": 29091,
    "pr_file": "runtime/ops/mod.rs",
    "created_at": "2025-04-29T15:14:02+00:00",
    "commented_code": "pub mod web_worker;\n pub mod worker_host;\n \n+use std::sync::Arc;\n+\n use deno_core::OpState;\n+use deno_features::FeatureChecker;\n \n /// Helper for checking unstable features. Used for sync ops.\n pub fn check_unstable(state: &OpState, feature: &str, api_name: &str) {\n-  state.feature_checker.check_or_exit(feature, api_name);\n+  state\n+    .borrow::<Arc<FeatureChecker>>()",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2066794944",
        "repo_full_name": "denoland/deno",
        "pr_number": 29091,
        "pr_file": "runtime/ops/mod.rs",
        "discussion_id": "2066794944",
        "commented_code": "@@ -9,11 +9,16 @@ pub mod tty;\n pub mod web_worker;\n pub mod worker_host;\n \n+use std::sync::Arc;\n+\n use deno_core::OpState;\n+use deno_features::FeatureChecker;\n \n /// Helper for checking unstable features. Used for sync ops.\n pub fn check_unstable(state: &OpState, feature: &str, api_name: &str) {\n-  state.feature_checker.check_or_exit(feature, api_name);\n+  state\n+    .borrow::<Arc<FeatureChecker>>()",
        "comment_created_at": "2025-04-29T15:14:02+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "I'm wondering if we should bury `Arc` inside `FeatureChecker`. Seems like an implementation detail. Feel free to do it in a follow up",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2051108030",
    "pr_number": 28964,
    "pr_file": "cli/npm/mod.rs",
    "created_at": "2025-04-18T20:51:40+00:00",
    "commented_code": "pub type CliByonmNpmResolverCreateOptions =\n   ByonmNpmResolverCreateOptions<CliSys>;\n \n-pub struct NpmPackageInfoApiAdapter(pub Arc<dyn NpmRegistryApi + Send + Sync>);\n+pub struct NpmPackageInfoApiAdapter(\n+  pub Arc<dyn NpmRegistryApi + Send + Sync>,\n+  pub Arc<WorkspaceNpmPatchPackages>,\n+);",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2051108030",
        "repo_full_name": "denoland/deno",
        "pr_number": 28964,
        "pr_file": "cli/npm/mod.rs",
        "discussion_id": "2051108030",
        "commented_code": "@@ -56,7 +55,74 @@ pub type CliNpmResolverCreateOptions =\n pub type CliByonmNpmResolverCreateOptions =\n   ByonmNpmResolverCreateOptions<CliSys>;\n \n-pub struct NpmPackageInfoApiAdapter(pub Arc<dyn NpmRegistryApi + Send + Sync>);\n+pub struct NpmPackageInfoApiAdapter(\n+  pub Arc<dyn NpmRegistryApi + Send + Sync>,\n+  pub Arc<WorkspaceNpmPatchPackages>,\n+);",
        "comment_created_at": "2025-04-18T20:51:40+00:00",
        "comment_author": "dsherret",
        "comment_body": "Nitpick: maybe use named properties at this point? (especially because it's public)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1959858215",
    "pr_number": 28168,
    "pr_file": "ext/node/ops/sqlite/statement.rs",
    "created_at": "2025-02-18T14:26:07+00:00",
    "commented_code": "Ok(arr)\n   }\n \n+  fn iterate<'a>(\n+    &self,\n+    scope: &mut v8::HandleScope<'a>,\n+    #[varargs] params: Option<&v8::FunctionCallbackArguments>,\n+  ) -> Result<v8::Local<'a, v8::Object>, SqliteError> {\n+    macro_rules! v8_static_strings {",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1959858215",
        "repo_full_name": "denoland/deno",
        "pr_number": 28168,
        "pr_file": "ext/node/ops/sqlite/statement.rs",
        "discussion_id": "1959858215",
        "commented_code": "@@ -369,6 +371,143 @@ impl StatementSync {\n     Ok(arr)\n   }\n \n+  fn iterate<'a>(\n+    &self,\n+    scope: &mut v8::HandleScope<'a>,\n+    #[varargs] params: Option<&v8::FunctionCallbackArguments>,\n+  ) -> Result<v8::Local<'a, v8::Object>, SqliteError> {\n+    macro_rules! v8_static_strings {",
        "comment_created_at": "2025-02-18T14:26:07+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "We should just export this from `deno_core` - this is the third place we're redefining this macro",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1878851838",
    "pr_number": 27009,
    "pr_file": "cli/args/mod.rs",
    "created_at": "2024-12-10T21:02:33+00:00",
    "commented_code": "import_map_specifier: Option<Option<ModuleSpecifier>>,\n }\n \n+/// Overrides for the options below that when set will\n+/// use these values over the values derived from the\n+/// CLI flags or config file.\n+#[derive(Debug, Clone)]\n+pub struct ScopeOptions {\n+  pub scope: Option<Arc<ModuleSpecifier>>,\n+  pub all_scopes: Arc<BTreeSet<Arc<ModuleSpecifier>>>,\n+}\n+\n /// Holds the resolved options of many sources used by subcommands\n /// and provides some helper function for creating common objects.\n pub struct CliOptions {\n   // the source of the options is a detail the rest of the\n   // application need not concern itself with, so keep these private\n-  flags: Arc<Flags>,\n+  pub flags: Arc<Flags>,",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1878851838",
        "repo_full_name": "denoland/deno",
        "pr_number": 27009,
        "pr_file": "cli/args/mod.rs",
        "discussion_id": "1878851838",
        "commented_code": "@@ -796,12 +797,21 @@ struct CliOptionOverrides {\n   import_map_specifier: Option<Option<ModuleSpecifier>>,\n }\n \n+/// Overrides for the options below that when set will\n+/// use these values over the values derived from the\n+/// CLI flags or config file.\n+#[derive(Debug, Clone)]\n+pub struct ScopeOptions {\n+  pub scope: Option<Arc<ModuleSpecifier>>,\n+  pub all_scopes: Arc<BTreeSet<Arc<ModuleSpecifier>>>,\n+}\n+\n /// Holds the resolved options of many sources used by subcommands\n /// and provides some helper function for creating common objects.\n pub struct CliOptions {\n   // the source of the options is a detail the rest of the\n   // application need not concern itself with, so keep these private\n-  flags: Arc<Flags>,\n+  pub flags: Arc<Flags>,",
        "comment_created_at": "2024-12-10T21:02:33+00:00",
        "comment_author": "dsherret",
        "comment_body": "Can you make this private again? See the comment above (basically when we previously had this exposed bugs would happen where people rely on this instead of also doing stuff like looking at the configuration file)",
        "pr_file_module": null
      }
    ]
  }
]