[
  {
    "discussion_id": "2065942765",
    "pr_number": 28929,
    "pr_file": "cli/rt/run.rs",
    "created_at": "2025-04-29T09:41:55+00:00",
    "commented_code": "WorkerExecutionMode::Run,\n     permissions,\n     main_module,\n+    None,",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2065942765",
        "repo_full_name": "denoland/deno",
        "pr_number": 28929,
        "pr_file": "cli/rt/run.rs",
        "discussion_id": "2065942765",
        "commented_code": "@@ -1007,6 +1008,7 @@ pub async fn run(\n     WorkerExecutionMode::Run,\n     permissions,\n     main_module,\n+    None,",
        "comment_created_at": "2025-04-29T09:41:55+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Yeah, I really think we should add specialized API to avoid all these `Default::default()` and rogue `None`s throughout the codebase",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2064861392",
    "pr_number": 29014,
    "pr_file": "cli/tools/fmt.rs",
    "created_at": "2025-04-28T22:04:14+00:00",
    "commented_code": "})\n }\n \n+/// A function for formatting embedded code blocks in JavaScript and TypeScript.\n+fn create_external_formatter_for_typescript(\n+  unstable_options: &UnstableFmtOptions,\n+) -> impl Fn(\n+  MediaType,\n+  String,\n+  &dprint_plugin_typescript::configuration::Configuration,\n+) -> Option<String> {\n+  let unstable_sql = unstable_options.sql;\n+  move |media_type, text, config| {\n+    match media_type {\n+      MediaType::Css => format_embedded_css(&text, config),\n+      MediaType::Html => format_embedded_html(&text, config),\n+      MediaType::Sql => {\n+        if unstable_sql {\n+          format_embedded_sql(&text, config)\n+        } else {\n+          None\n+        }\n+      }\n+      // dprint-plugin-typescript only detects css, html, and sql for now\n+      _ => unreachable!(),",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2064861392",
        "repo_full_name": "denoland/deno",
        "pr_number": 29014,
        "pr_file": "cli/tools/fmt.rs",
        "discussion_id": "2064861392",
        "commented_code": "@@ -521,6 +535,138 @@ pub fn format_html(\n   })\n }\n \n+/// A function for formatting embedded code blocks in JavaScript and TypeScript.\n+fn create_external_formatter_for_typescript(\n+  unstable_options: &UnstableFmtOptions,\n+) -> impl Fn(\n+  MediaType,\n+  String,\n+  &dprint_plugin_typescript::configuration::Configuration,\n+) -> Option<String> {\n+  let unstable_sql = unstable_options.sql;\n+  move |media_type, text, config| {\n+    match media_type {\n+      MediaType::Css => format_embedded_css(&text, config),\n+      MediaType::Html => format_embedded_html(&text, config),\n+      MediaType::Sql => {\n+        if unstable_sql {\n+          format_embedded_sql(&text, config)\n+        } else {\n+          None\n+        }\n+      }\n+      // dprint-plugin-typescript only detects css, html, and sql for now\n+      _ => unreachable!(),",
        "comment_created_at": "2025-04-28T22:04:14+00:00",
        "comment_author": "dsherret",
        "comment_body": "Maybe just return `None`? dprint-plugin-typescript could change in the future and that would break this code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2066148079",
        "repo_full_name": "denoland/deno",
        "pr_number": 29014,
        "pr_file": "cli/tools/fmt.rs",
        "discussion_id": "2064861392",
        "commented_code": "@@ -521,6 +535,138 @@ pub fn format_html(\n   })\n }\n \n+/// A function for formatting embedded code blocks in JavaScript and TypeScript.\n+fn create_external_formatter_for_typescript(\n+  unstable_options: &UnstableFmtOptions,\n+) -> impl Fn(\n+  MediaType,\n+  String,\n+  &dprint_plugin_typescript::configuration::Configuration,\n+) -> Option<String> {\n+  let unstable_sql = unstable_options.sql;\n+  move |media_type, text, config| {\n+    match media_type {\n+      MediaType::Css => format_embedded_css(&text, config),\n+      MediaType::Html => format_embedded_html(&text, config),\n+      MediaType::Sql => {\n+        if unstable_sql {\n+          format_embedded_sql(&text, config)\n+        } else {\n+          None\n+        }\n+      }\n+      // dprint-plugin-typescript only detects css, html, and sql for now\n+      _ => unreachable!(),",
        "comment_created_at": "2025-04-29T11:47:23+00:00",
        "comment_author": "kt3k",
        "comment_body": "Makes sense",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1959449899",
    "pr_number": 27789,
    "pr_file": "ext/net/ops.rs",
    "created_at": "2025-02-18T10:16:54+00:00",
    "commented_code": "pub async fn op_net_accept_tcp(\n   state: Rc<RefCell<OpState>>,\n   #[smi] rid: ResourceId,\n-) -> Result<(ResourceId, IpAddr, IpAddr), NetError> {\n+) -> Result<(ResourceId, IpAddr, IpAddr, Fd), NetError> {",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1959449899",
        "repo_full_name": "denoland/deno",
        "pr_number": 27789,
        "pr_file": "ext/net/ops.rs",
        "discussion_id": "1959449899",
        "commented_code": "@@ -165,7 +169,7 @@ pub(crate) fn accept_err(e: std::io::Error) -> NetError {\n pub async fn op_net_accept_tcp(\n   state: Rc<RefCell<OpState>>,\n   #[smi] rid: ResourceId,\n-) -> Result<(ResourceId, IpAddr, IpAddr), NetError> {\n+) -> Result<(ResourceId, IpAddr, IpAddr, Fd), NetError> {",
        "comment_created_at": "2025-02-18T10:16:54+00:00",
        "comment_author": "kt3k",
        "comment_body": "If Fd is not available on windows, maybe it's better to do:\r\n\r\n```suggestion\r\n) -> Result<(ResourceId, IpAddr, IpAddr, Option<Fd>), NetError> {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1937966394",
    "pr_number": 27203,
    "pr_file": "cli/tools/lint/linter.rs",
    "created_at": "2025-01-31T20:48:07+00:00",
    "commented_code": "deno_ast::apply_text_changes(text_info.text_str(), quick_fixes);\n   Some(new_text)\n }\n+\n+fn run_plugins(\n+  plugin_runner: Arc<Mutex<PluginHostProxy>>,\n+  parsed_source: ParsedSource,\n+  file_path: PathBuf,\n+  maybe_token: Option<CancellationToken>,\n+) -> Result<ExternalLinterResult, AnyError> {\n+  let source_text_info = parsed_source.text_info_lazy().clone();\n+  let plugin_info = plugin_runner\n+    .lock()\n+    .get_plugin_rules()\n+    .into_iter()\n+    .map(Cow::from)\n+    .collect();\n+\n+  #[allow(clippy::await_holding_lock)]\n+  let fut = async move {\n+    let mut plugin_runner = plugin_runner.lock();\n+    let serialized_ast = plugin_runner.serialize_ast(parsed_source)?;\n+\n+    plugins::run_rules_for_ast(\n+      &mut plugin_runner,\n+      &file_path,\n+      serialized_ast,\n+      source_text_info,\n+      maybe_token,\n+    )\n+    .await\n+  }\n+  .boxed_local();\n+\n+  let plugin_diagnostics = tokio_util::create_and_run_current_thread(fut)?;\n+\n+  Ok(ExternalLinterResult {\n+    diagnostics: plugin_diagnostics,\n+    rules: plugin_info,\n+  })\n+}\n+\n+struct ExternalLinterContainer {\n+  cb: Option<ExternalLinterCb>,\n+  error: Option<Arc<Mutex<Option<AnyError>>>>,\n+}\n+\n+impl ExternalLinterContainer {\n+  pub fn new(\n+    maybe_plugin_runner: Option<Arc<Mutex<PluginHostProxy>>>,\n+    maybe_token: Option<CancellationToken>,\n+  ) -> Self {\n+    let mut s = Self {\n+      cb: None,\n+      error: None,\n+    };\n+    if let Some(plugin_runner) = maybe_plugin_runner {\n+      s.error = Some(Arc::new(Mutex::new(None)));\n+      let error_ = s.error.clone();\n+      let cb = Arc::new(move |parsed_source: ParsedSource| {\n+        let token_ = maybe_token.clone();\n+        // TODO: clean this up\n+        let file_path = parsed_source.specifier().to_file_path().unwrap();",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1937966394",
        "repo_full_name": "denoland/deno",
        "pr_number": 27203,
        "pr_file": "cli/tools/lint/linter.rs",
        "discussion_id": "1937966394",
        "commented_code": "@@ -258,3 +317,87 @@ fn apply_lint_fixes(\n     deno_ast::apply_text_changes(text_info.text_str(), quick_fixes);\n   Some(new_text)\n }\n+\n+fn run_plugins(\n+  plugin_runner: Arc<Mutex<PluginHostProxy>>,\n+  parsed_source: ParsedSource,\n+  file_path: PathBuf,\n+  maybe_token: Option<CancellationToken>,\n+) -> Result<ExternalLinterResult, AnyError> {\n+  let source_text_info = parsed_source.text_info_lazy().clone();\n+  let plugin_info = plugin_runner\n+    .lock()\n+    .get_plugin_rules()\n+    .into_iter()\n+    .map(Cow::from)\n+    .collect();\n+\n+  #[allow(clippy::await_holding_lock)]\n+  let fut = async move {\n+    let mut plugin_runner = plugin_runner.lock();\n+    let serialized_ast = plugin_runner.serialize_ast(parsed_source)?;\n+\n+    plugins::run_rules_for_ast(\n+      &mut plugin_runner,\n+      &file_path,\n+      serialized_ast,\n+      source_text_info,\n+      maybe_token,\n+    )\n+    .await\n+  }\n+  .boxed_local();\n+\n+  let plugin_diagnostics = tokio_util::create_and_run_current_thread(fut)?;\n+\n+  Ok(ExternalLinterResult {\n+    diagnostics: plugin_diagnostics,\n+    rules: plugin_info,\n+  })\n+}\n+\n+struct ExternalLinterContainer {\n+  cb: Option<ExternalLinterCb>,\n+  error: Option<Arc<Mutex<Option<AnyError>>>>,\n+}\n+\n+impl ExternalLinterContainer {\n+  pub fn new(\n+    maybe_plugin_runner: Option<Arc<Mutex<PluginHostProxy>>>,\n+    maybe_token: Option<CancellationToken>,\n+  ) -> Self {\n+    let mut s = Self {\n+      cb: None,\n+      error: None,\n+    };\n+    if let Some(plugin_runner) = maybe_plugin_runner {\n+      s.error = Some(Arc::new(Mutex::new(None)));\n+      let error_ = s.error.clone();\n+      let cb = Arc::new(move |parsed_source: ParsedSource| {\n+        let token_ = maybe_token.clone();\n+        // TODO: clean this up\n+        let file_path = parsed_source.specifier().to_file_path().unwrap();",
        "comment_created_at": "2025-01-31T20:48:07+00:00",
        "comment_author": "dsherret",
        "comment_body": "Prefer `deno_path_utils::url_to_file_path` and maybe handle these errors?",
        "pr_file_module": null
      },
      {
        "comment_id": "1938027637",
        "repo_full_name": "denoland/deno",
        "pr_number": 27203,
        "pr_file": "cli/tools/lint/linter.rs",
        "discussion_id": "1937966394",
        "commented_code": "@@ -258,3 +317,87 @@ fn apply_lint_fixes(\n     deno_ast::apply_text_changes(text_info.text_str(), quick_fixes);\n   Some(new_text)\n }\n+\n+fn run_plugins(\n+  plugin_runner: Arc<Mutex<PluginHostProxy>>,\n+  parsed_source: ParsedSource,\n+  file_path: PathBuf,\n+  maybe_token: Option<CancellationToken>,\n+) -> Result<ExternalLinterResult, AnyError> {\n+  let source_text_info = parsed_source.text_info_lazy().clone();\n+  let plugin_info = plugin_runner\n+    .lock()\n+    .get_plugin_rules()\n+    .into_iter()\n+    .map(Cow::from)\n+    .collect();\n+\n+  #[allow(clippy::await_holding_lock)]\n+  let fut = async move {\n+    let mut plugin_runner = plugin_runner.lock();\n+    let serialized_ast = plugin_runner.serialize_ast(parsed_source)?;\n+\n+    plugins::run_rules_for_ast(\n+      &mut plugin_runner,\n+      &file_path,\n+      serialized_ast,\n+      source_text_info,\n+      maybe_token,\n+    )\n+    .await\n+  }\n+  .boxed_local();\n+\n+  let plugin_diagnostics = tokio_util::create_and_run_current_thread(fut)?;\n+\n+  Ok(ExternalLinterResult {\n+    diagnostics: plugin_diagnostics,\n+    rules: plugin_info,\n+  })\n+}\n+\n+struct ExternalLinterContainer {\n+  cb: Option<ExternalLinterCb>,\n+  error: Option<Arc<Mutex<Option<AnyError>>>>,\n+}\n+\n+impl ExternalLinterContainer {\n+  pub fn new(\n+    maybe_plugin_runner: Option<Arc<Mutex<PluginHostProxy>>>,\n+    maybe_token: Option<CancellationToken>,\n+  ) -> Self {\n+    let mut s = Self {\n+      cb: None,\n+      error: None,\n+    };\n+    if let Some(plugin_runner) = maybe_plugin_runner {\n+      s.error = Some(Arc::new(Mutex::new(None)));\n+      let error_ = s.error.clone();\n+      let cb = Arc::new(move |parsed_source: ParsedSource| {\n+        let token_ = maybe_token.clone();\n+        // TODO: clean this up\n+        let file_path = parsed_source.specifier().to_file_path().unwrap();",
        "comment_created_at": "2025-01-31T21:59:26+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "Good point! It will always be a path, so probably error is unreachable, but I'll handle that",
        "pr_file_module": null
      }
    ]
  }
]