[
  {
    "discussion_id": "2172612100",
    "pr_number": 29923,
    "pr_file": "cli/args/mod.rs",
    "created_at": "2025-06-27T18:15:22+00:00",
    "commented_code": "let maybe_node_channel_fd = std::env::var(\"NODE_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n-      std::env::remove_var(\"NODE_CHANNEL_FD\");\n+      // TODO: Audit that the environment access only happens in single-threaded code.",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2172612100",
        "repo_full_name": "denoland/deno",
        "pr_number": 29923,
        "pr_file": "cli/args/mod.rs",
        "discussion_id": "2172612100",
        "commented_code": "@@ -470,7 +470,11 @@ impl CliOptions {\n     let maybe_node_channel_fd = std::env::var(\"NODE_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n-      std::env::remove_var(\"NODE_CHANNEL_FD\");\n+      // TODO: Audit that the environment access only happens in single-threaded code.",
        "comment_created_at": "2025-06-27T18:15:22+00:00",
        "comment_author": "dsherret",
        "comment_body": "Yeah. Let's remove these.",
        "pr_file_module": null
      },
      {
        "comment_id": "2172617154",
        "repo_full_name": "denoland/deno",
        "pr_number": 29923,
        "pr_file": "cli/args/mod.rs",
        "discussion_id": "2172612100",
        "commented_code": "@@ -470,7 +470,11 @@ impl CliOptions {\n     let maybe_node_channel_fd = std::env::var(\"NODE_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n-      std::env::remove_var(\"NODE_CHANNEL_FD\");\n+      // TODO: Audit that the environment access only happens in single-threaded code.",
        "comment_created_at": "2025-06-27T18:16:55+00:00",
        "comment_author": "dsherret",
        "comment_body": "Is there a helper function we could introduce to ensure we always do this safely?",
        "pr_file_module": null
      },
      {
        "comment_id": "2172643038",
        "repo_full_name": "denoland/deno",
        "pr_number": 29923,
        "pr_file": "cli/args/mod.rs",
        "discussion_id": "2172612100",
        "commented_code": "@@ -470,7 +470,11 @@ impl CliOptions {\n     let maybe_node_channel_fd = std::env::var(\"NODE_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n-      std::env::remove_var(\"NODE_CHANNEL_FD\");\n+      // TODO: Audit that the environment access only happens in single-threaded code.",
        "comment_created_at": "2025-06-27T18:30:28+00:00",
        "comment_author": "nathanwhit",
        "comment_body": "there's no real way to do it safely https://doc.rust-lang.org/std/env/fn.set_var.html\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2180837968",
        "repo_full_name": "denoland/deno",
        "pr_number": 29923,
        "pr_file": "cli/args/mod.rs",
        "discussion_id": "2172612100",
        "commented_code": "@@ -470,7 +470,11 @@ impl CliOptions {\n     let maybe_node_channel_fd = std::env::var(\"NODE_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n-      std::env::remove_var(\"NODE_CHANNEL_FD\");\n+      // TODO: Audit that the environment access only happens in single-threaded code.",
        "comment_created_at": "2025-07-02T19:37:45+00:00",
        "comment_author": "dsherret",
        "comment_body": "I mean, something like have it panic if not done from the same thread or we just put a lock over all the usages on non-windows platforms?",
        "pr_file_module": null
      },
      {
        "comment_id": "2180855017",
        "repo_full_name": "denoland/deno",
        "pr_number": 29923,
        "pr_file": "cli/args/mod.rs",
        "discussion_id": "2172612100",
        "commented_code": "@@ -470,7 +470,11 @@ impl CliOptions {\n     let maybe_node_channel_fd = std::env::var(\"NODE_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n-      std::env::remove_var(\"NODE_CHANNEL_FD\");\n+      // TODO: Audit that the environment access only happens in single-threaded code.",
        "comment_created_at": "2025-07-02T19:49:06+00:00",
        "comment_author": "nathanwhit",
        "comment_body": "There's an internal lock in the standard library, so as long as you're going through std you're fine. (from the docs):\r\n\r\n> The exact requirement is: you must ensure that there are no other threads concurrently writing or reading(!) the environment through functions or global variables other than the ones in this module.\r\n\r\nThe issue is if any other code (probably native code) accesses the environment from a different thread. Stuff in libc for instance can do getenv/setenv calls as part of another call, and if that happens on another thread it can be UB. \r\n\r\nSo basically if anything calls into any c/c++ code (including libc) from any other thread, and then the c/c++ code accesses the environment, it could cause a data race",
        "pr_file_module": null
      },
      {
        "comment_id": "2180857235",
        "repo_full_name": "denoland/deno",
        "pr_number": 29923,
        "pr_file": "cli/args/mod.rs",
        "discussion_id": "2172612100",
        "commented_code": "@@ -470,7 +470,11 @@ impl CliOptions {\n     let maybe_node_channel_fd = std::env::var(\"NODE_CHANNEL_FD\").ok();\n     if let Some(node_channel_fd) = maybe_node_channel_fd {\n       // Remove so that child processes don't inherit this environment variable.\n-      std::env::remove_var(\"NODE_CHANNEL_FD\");\n+      // TODO: Audit that the environment access only happens in single-threaded code.",
        "comment_created_at": "2025-07-02T19:50:39+00:00",
        "comment_author": "nathanwhit",
        "comment_body": "Put all together, that's why the docs say it's basically impossible to avoid unless you just don't modify the env (which isn't an option for us):\r\n> Even functions from the Rust standard library may read the environment without going through this module, e.g. for DNS lookups from [std::net::ToSocketAddrs](https://doc.rust-lang.org/std/net/trait.ToSocketAddrs.html). No stable guarantee is made about which functions may read from the environment in future versions of a library. All this makes it not practically possible for you to guarantee that no other thread will read the environment, so the only safe option is to not use set_var or remove_var in multi-threaded programs at all.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2129196603",
    "pr_number": 29623,
    "pr_file": "resolvers/npm_installer/flag.rs",
    "created_at": "2025-06-05T16:04:56+00:00",
    "commented_code": "// at the whims of whatever is occurring on the runtime thread.\n                 let sys = sys.clone();\n                 deno_unsync::spawn_blocking({\n-                  let finished_flag = finished_flag.clone();\n-                  let last_updated_path = last_updated_path.clone();\n-                  move || {\n-                    let mut i = 0;\n-                    while !finished_flag.is_raised() {\n-                      i += 1;\n-                      let _ignore =\n-                        sys.fs_write(&last_updated_path, i.to_string());\n-                      sys.thread_sleep(Duration::from_millis(\n-                        poll_file_update_ms,\n-                      ));\n+                  let poll_file = poll_file.clone();\n+                  move || loop {\n+                    sys\n+                      .thread_sleep(Duration::from_millis(poll_file_update_ms));",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2129196603",
        "repo_full_name": "denoland/deno",
        "pr_number": 29623,
        "pr_file": "resolvers/npm_installer/flag.rs",
        "discussion_id": "2129196603",
        "commented_code": "@@ -105,25 +137,21 @@ mod inner {\n                 // at the whims of whatever is occurring on the runtime thread.\n                 let sys = sys.clone();\n                 deno_unsync::spawn_blocking({\n-                  let finished_flag = finished_flag.clone();\n-                  let last_updated_path = last_updated_path.clone();\n-                  move || {\n-                    let mut i = 0;\n-                    while !finished_flag.is_raised() {\n-                      i += 1;\n-                      let _ignore =\n-                        sys.fs_write(&last_updated_path, i.to_string());\n-                      sys.thread_sleep(Duration::from_millis(\n-                        poll_file_update_ms,\n-                      ));\n+                  let poll_file = poll_file.clone();\n+                  move || loop {\n+                    sys\n+                      .thread_sleep(Duration::from_millis(poll_file_update_ms));",
        "comment_created_at": "2025-06-05T16:04:56+00:00",
        "comment_author": "dsherret",
        "comment_body": "I kind of feel like we should be using a conditional variable here in order to kill the thread more quickly in case this is hanging shutdown, but this is probably fine.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1655679828",
    "pr_number": 24250,
    "pr_file": "cli/ops/jupyter.rs",
    "created_at": "2024-06-27T00:42:23+00:00",
    "commented_code": "},\n );\n \n+pub struct CommChannel {\n+  pub target_name: String,\n+  pub sender: broadcast::Sender<(CommMsg, Vec<Bytes>)>,\n+  pub receiver: broadcast::Receiver<(CommMsg, Vec<Bytes>)>,\n+}\n+\n+#[derive(Clone, Default)]\n+pub struct CommContainer(pub Arc<PlMutex<HashMap<String, CommChannel>>>);\n+\n+impl CommContainer {\n+  pub fn create(\n+    &mut self,\n+    comm_id: &str,\n+    target_name: &str,\n+    // For pulling off the metadata and buffers\n+    _msg: Option<&JupyterMessage>,\n+  ) {\n+    let mut container = self.0.lock();\n+\n+    // We will not replace existing comms\n+    if container.contains_key(comm_id) {\n+      return;\n+    }\n+\n+    let (tx, rx) = broadcast::channel(16);\n+    let comm_channel = CommChannel {\n+      target_name: target_name.to_string(),\n+      sender: tx,\n+      receiver: rx,\n+    };\n+\n+    container.insert(comm_id.to_string(), comm_channel);\n+  }\n+\n+  pub fn comms(&self) -> HashMap<CommId, CommInfo> {\n+    let container = self.0.lock();\n+\n+    container\n+      .iter()\n+      .map(|(comm_id, comm)| {\n+        (\n+          CommId(comm_id.to_string()),\n+          CommInfo {\n+            target_name: comm.target_name.clone(),\n+          },\n+        )\n+      })\n+      .collect()\n+  }\n+}\n+\n+#[op2(fast)]\n+pub fn op_jupyter_comm_open(\n+  state: &mut OpState,\n+  #[string] comm_id: String,\n+  #[string] target_name: String,\n+) {\n+  let container = state.borrow_mut::<CommContainer>();\n+  container.create(&comm_id, &target_name, None);\n+  eprintln!(\"created comm {} {}\", comm_id, target_name);\n+}\n+\n+#[op2(async)]\n+#[serde]\n+pub async fn op_jupyter_comm_recv(\n+  state: Rc<RefCell<OpState>>,\n+  #[string] comm_id: String,\n+) -> (serde_json::Value, Vec<ToJsBuffer>) {\n+  let mut receiver = {\n+    let state = state.borrow();\n+    let container = state.borrow::<CommContainer>();\n+    let container = container.0.lock();\n+    let maybe_comm = container.get(&comm_id);\n+    let Some(comm) = maybe_comm else {\n+      return (serde_json::Value::Null, vec![]);\n+    };\n+    comm.receiver.resubscribe()",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1655679828",
        "repo_full_name": "denoland/deno",
        "pr_number": 24250,
        "pr_file": "cli/ops/jupyter.rs",
        "discussion_id": "1655679828",
        "commented_code": "@@ -32,6 +43,97 @@ deno_core::extension!(deno_jupyter,\n   },\n );\n \n+pub struct CommChannel {\n+  pub target_name: String,\n+  pub sender: broadcast::Sender<(CommMsg, Vec<Bytes>)>,\n+  pub receiver: broadcast::Receiver<(CommMsg, Vec<Bytes>)>,\n+}\n+\n+#[derive(Clone, Default)]\n+pub struct CommContainer(pub Arc<PlMutex<HashMap<String, CommChannel>>>);\n+\n+impl CommContainer {\n+  pub fn create(\n+    &mut self,\n+    comm_id: &str,\n+    target_name: &str,\n+    // For pulling off the metadata and buffers\n+    _msg: Option<&JupyterMessage>,\n+  ) {\n+    let mut container = self.0.lock();\n+\n+    // We will not replace existing comms\n+    if container.contains_key(comm_id) {\n+      return;\n+    }\n+\n+    let (tx, rx) = broadcast::channel(16);\n+    let comm_channel = CommChannel {\n+      target_name: target_name.to_string(),\n+      sender: tx,\n+      receiver: rx,\n+    };\n+\n+    container.insert(comm_id.to_string(), comm_channel);\n+  }\n+\n+  pub fn comms(&self) -> HashMap<CommId, CommInfo> {\n+    let container = self.0.lock();\n+\n+    container\n+      .iter()\n+      .map(|(comm_id, comm)| {\n+        (\n+          CommId(comm_id.to_string()),\n+          CommInfo {\n+            target_name: comm.target_name.clone(),\n+          },\n+        )\n+      })\n+      .collect()\n+  }\n+}\n+\n+#[op2(fast)]\n+pub fn op_jupyter_comm_open(\n+  state: &mut OpState,\n+  #[string] comm_id: String,\n+  #[string] target_name: String,\n+) {\n+  let container = state.borrow_mut::<CommContainer>();\n+  container.create(&comm_id, &target_name, None);\n+  eprintln!(\"created comm {} {}\", comm_id, target_name);\n+}\n+\n+#[op2(async)]\n+#[serde]\n+pub async fn op_jupyter_comm_recv(\n+  state: Rc<RefCell<OpState>>,\n+  #[string] comm_id: String,\n+) -> (serde_json::Value, Vec<ToJsBuffer>) {\n+  let mut receiver = {\n+    let state = state.borrow();\n+    let container = state.borrow::<CommContainer>();\n+    let container = container.0.lock();\n+    let maybe_comm = container.get(&comm_id);\n+    let Some(comm) = maybe_comm else {\n+      return (serde_json::Value::Null, vec![]);\n+    };\n+    comm.receiver.resubscribe()",
        "comment_created_at": "2024-06-27T00:42:23+00:00",
        "comment_author": "bartlomieju",
        "comment_body": "@manzt @rgbkrk if we go with `EventListener` approach for a comm then we can expect more than one consumer of the \"comm\". That means we need to use `tokio::sync::broadcast` channel which is buffered. We can go with a rather big number for the buffer like 1024 or 65536. If we expect only a single consumer then we could use an `mpsc` channel that is unbounded. Which one should we go with?",
        "pr_file_module": null
      },
      {
        "comment_id": "1655692912",
        "repo_full_name": "denoland/deno",
        "pr_number": 24250,
        "pr_file": "cli/ops/jupyter.rs",
        "discussion_id": "1655679828",
        "commented_code": "@@ -32,6 +43,97 @@ deno_core::extension!(deno_jupyter,\n   },\n );\n \n+pub struct CommChannel {\n+  pub target_name: String,\n+  pub sender: broadcast::Sender<(CommMsg, Vec<Bytes>)>,\n+  pub receiver: broadcast::Receiver<(CommMsg, Vec<Bytes>)>,\n+}\n+\n+#[derive(Clone, Default)]\n+pub struct CommContainer(pub Arc<PlMutex<HashMap<String, CommChannel>>>);\n+\n+impl CommContainer {\n+  pub fn create(\n+    &mut self,\n+    comm_id: &str,\n+    target_name: &str,\n+    // For pulling off the metadata and buffers\n+    _msg: Option<&JupyterMessage>,\n+  ) {\n+    let mut container = self.0.lock();\n+\n+    // We will not replace existing comms\n+    if container.contains_key(comm_id) {\n+      return;\n+    }\n+\n+    let (tx, rx) = broadcast::channel(16);\n+    let comm_channel = CommChannel {\n+      target_name: target_name.to_string(),\n+      sender: tx,\n+      receiver: rx,\n+    };\n+\n+    container.insert(comm_id.to_string(), comm_channel);\n+  }\n+\n+  pub fn comms(&self) -> HashMap<CommId, CommInfo> {\n+    let container = self.0.lock();\n+\n+    container\n+      .iter()\n+      .map(|(comm_id, comm)| {\n+        (\n+          CommId(comm_id.to_string()),\n+          CommInfo {\n+            target_name: comm.target_name.clone(),\n+          },\n+        )\n+      })\n+      .collect()\n+  }\n+}\n+\n+#[op2(fast)]\n+pub fn op_jupyter_comm_open(\n+  state: &mut OpState,\n+  #[string] comm_id: String,\n+  #[string] target_name: String,\n+) {\n+  let container = state.borrow_mut::<CommContainer>();\n+  container.create(&comm_id, &target_name, None);\n+  eprintln!(\"created comm {} {}\", comm_id, target_name);\n+}\n+\n+#[op2(async)]\n+#[serde]\n+pub async fn op_jupyter_comm_recv(\n+  state: Rc<RefCell<OpState>>,\n+  #[string] comm_id: String,\n+) -> (serde_json::Value, Vec<ToJsBuffer>) {\n+  let mut receiver = {\n+    let state = state.borrow();\n+    let container = state.borrow::<CommContainer>();\n+    let container = container.0.lock();\n+    let maybe_comm = container.get(&comm_id);\n+    let Some(comm) = maybe_comm else {\n+      return (serde_json::Value::Null, vec![]);\n+    };\n+    comm.receiver.resubscribe()",
        "comment_created_at": "2024-06-27T01:05:17+00:00",
        "comment_author": "manzt",
        "comment_body": "For widgets, I think it will basically only be one comm listener. There is new comm created for each new widget instance.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2040632349",
    "pr_number": 28769,
    "pr_file": "cli/util/sync/async_flag.rs",
    "created_at": "2025-04-12T10:56:12+00:00",
    "commented_code": "impl AsyncFlag {\n   pub fn raise(&self) {\n-    self.0.close();\n-  }\n-\n-  pub fn is_raised(&self) -> bool {\n-    self.0.is_closed()\n+    self.0.add_permits(1);\n   }\n \n   pub async fn wait_raised(&self) {\n-    self.0.acquire().await.unwrap_err();\n+    drop(self.0.acquire().await);\n   }\n }",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "2040632349",
        "repo_full_name": "denoland/deno",
        "pr_number": 28769,
        "pr_file": "cli/util/sync/async_flag.rs",
        "discussion_id": "2040632349",
        "commented_code": "@@ -15,14 +15,10 @@ impl Default for AsyncFlag {\n \n impl AsyncFlag {\n   pub fn raise(&self) {\n-    self.0.close();\n-  }\n-\n-  pub fn is_raised(&self) -> bool {\n-    self.0.is_closed()\n+    self.0.add_permits(1);\n   }\n \n   pub async fn wait_raised(&self) {\n-    self.0.acquire().await.unwrap_err();\n+    drop(self.0.acquire().await);\n   }\n }",
        "comment_created_at": "2025-04-12T10:56:12+00:00",
        "comment_author": "nayeemrmn",
        "comment_body": "`init_flag` handling was wrong. New requests queued just after it was raised would skip the queue of unblocked tasks. So we now preserve the semaphore throughout standard operation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2040632814",
        "repo_full_name": "denoland/deno",
        "pr_number": 28769,
        "pr_file": "cli/util/sync/async_flag.rs",
        "discussion_id": "2040632349",
        "commented_code": "@@ -15,14 +15,10 @@ impl Default for AsyncFlag {\n \n impl AsyncFlag {\n   pub fn raise(&self) {\n-    self.0.close();\n-  }\n-\n-  pub fn is_raised(&self) -> bool {\n-    self.0.is_closed()\n+    self.0.add_permits(1);\n   }\n \n   pub async fn wait_raised(&self) {\n-    self.0.acquire().await.unwrap_err();\n+    drop(self.0.acquire().await);\n   }\n }",
        "comment_created_at": "2025-04-12T10:58:19+00:00",
        "comment_author": "nayeemrmn",
        "comment_body": "It was especially visible with notebooks due to the timing but this probably fixes some other flakes e.g. I'll take another look at #21770 later.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1952399963",
    "pr_number": 28035,
    "pr_file": "cli/lsp/language_server.rs",
    "created_at": "2025-02-12T10:40:49+00:00",
    "commented_code": "init_flag: AsyncFlag,",
    "repo_full_name": "denoland/deno",
    "discussion_comments": [
      {
        "comment_id": "1952399963",
        "repo_full_name": "denoland/deno",
        "pr_number": 28035,
        "pr_file": "cli/lsp/language_server.rs",
        "discussion_id": "1952399963",
        "commented_code": "@@ -139,9 +139,6 @@ pub struct LanguageServer {\n   init_flag: AsyncFlag,",
        "comment_created_at": "2025-02-12T10:40:49+00:00",
        "comment_author": "dsherret",
        "comment_body": "@nayeemrmn do you think we could move the init_flag and shutdown_flag into our tower-lsp fork? Might help simplify things up here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1952507013",
        "repo_full_name": "denoland/deno",
        "pr_number": 28035,
        "pr_file": "cli/lsp/language_server.rs",
        "discussion_id": "1952399963",
        "commented_code": "@@ -139,9 +139,6 @@ pub struct LanguageServer {\n   init_flag: AsyncFlag,",
        "comment_created_at": "2025-02-12T11:54:28+00:00",
        "comment_author": "nayeemrmn",
        "comment_body": "`shutdown_flag` is a workaround for a tower lsp bug, so yeah we should just fix that #20700.\r\n\r\nhttps://github.com/denoland/deno/blob/d29f9f99dd51ea1cac5cf28dc1444e0f416e6957/cli/lsp/mod.rs#L79-L90\r\n\r\n`init_flag` I realised yesterday is buggy, if you type up a storm before it resolves the notification handlers will unblock out of order. So we might need to move that too with a proper queue implementation?",
        "pr_file_module": null
      }
    ]
  }
]