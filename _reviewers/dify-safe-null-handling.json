[
  {
    "discussion_id": "2312544673",
    "pr_number": 23827,
    "pr_file": "api/controllers/service_api/app/completion.py",
    "created_at": "2025-08-31T16:44:43+00:00",
    "commented_code": "raise NotChatAppError()\n \n         args = chat_parser.parse_args()\n+        # Add workflow_alias support\n+        if \"workflow_alias\" not in args:\n+            args[\"workflow_alias\"] = None",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2312544673",
        "repo_full_name": "langgenius/dify",
        "pr_number": 23827,
        "pr_file": "api/controllers/service_api/app/completion.py",
        "discussion_id": "2312544673",
        "commented_code": "@@ -188,6 +193,11 @@ def post(self, app_model: App, end_user: EndUser):\n             raise NotChatAppError()\n \n         args = chat_parser.parse_args()\n+        # Add workflow_alias support\n+        if \"workflow_alias\" not in args:\n+            args[\"workflow_alias\"] = None",
        "comment_created_at": "2025-08-31T16:44:43+00:00",
        "comment_author": "laipz8200",
        "comment_body": "Using `default` in argparser would be better. Also, to avoid using `None`, use `\"\"` when no alias is specified.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2304169609",
    "pr_number": 24653,
    "pr_file": "api/extensions/ext_redis.py",
    "created_at": "2025-08-27T14:42:54+00:00",
    "commented_code": "try:\n                 return func(*args, **kwargs)\n             except RedisError as e:\n-                logger.warning(\"Redis operation failed in %s: %s\", func.__name__, str(e), exc_info=True)\n+                func_name = getattr(func, \"__name__\", \"Unknown\")",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2304169609",
        "repo_full_name": "langgenius/dify",
        "pr_number": 24653,
        "pr_file": "api/extensions/ext_redis.py",
        "discussion_id": "2304169609",
        "commented_code": "@@ -260,7 +260,8 @@ def wrapper(*args, **kwargs):\n             try:\n                 return func(*args, **kwargs)\n             except RedisError as e:\n-                logger.warning(\"Redis operation failed in %s: %s\", func.__name__, str(e), exc_info=True)\n+                func_name = getattr(func, \"__name__\", \"Unknown\")",
        "comment_created_at": "2025-08-27T14:42:54+00:00",
        "comment_author": "asukaminato0721",
        "comment_body": "how about\r\n\r\n```py\r\nfunc_name = func.__name__ or \"Unknown\"\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2304206259",
        "repo_full_name": "langgenius/dify",
        "pr_number": 24653,
        "pr_file": "api/extensions/ext_redis.py",
        "discussion_id": "2304169609",
        "commented_code": "@@ -260,7 +260,8 @@ def wrapper(*args, **kwargs):\n             try:\n                 return func(*args, **kwargs)\n             except RedisError as e:\n-                logger.warning(\"Redis operation failed in %s: %s\", func.__name__, str(e), exc_info=True)\n+                func_name = getattr(func, \"__name__\", \"Unknown\")",
        "comment_created_at": "2025-08-27T14:51:10+00:00",
        "comment_author": "bowenliang123",
        "comment_body": "It's `func.__name__` where violates the rule of unresolved attr. And we have to walk around it.\r\n\r\n```\r\nerror[unresolved-attribute]: Type `(...) -> Unknown` has no attribute `__name__`                                                                                        \r\n   --> extensions/ext_redis.py:263:68\r\n    |\r\n261 |                 return func(*args, **kwargs)\r\n262 |             except RedisError as e:\r\n263 |                 logger.warning(\"Redis operation failed in %s: %s\", func.__name__, str(e), exc_info=True)\r\n    |                                                                    ^^^^^^^^^^^^^\r\n264 |                 return default_return\r\n    |\r\ninfo: rule `unresolved-attribute` is enabled by default\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2280724307",
    "pr_number": 24026,
    "pr_file": "api/tests/test_containers_integration_tests/services/test_feature_service.py",
    "created_at": "2025-08-17T05:08:08+00:00",
    "commented_code": "+from unittest.mock import patch\n+\n+import pytest\n+from faker import Faker\n+\n+from services.feature_service import FeatureModel, FeatureService, KnowledgeRateLimitModel, SystemFeatureModel\n+\n+\n+class TestFeatureService:\n+    \"\"\"Integration tests for FeatureService using testcontainers.\"\"\"\n+\n+    @pytest.fixture\n+    def mock_external_service_dependencies(self):\n+        \"\"\"Mock setup for external service dependencies.\"\"\"\n+        with (\n+            patch(\"services.feature_service.BillingService\") as mock_billing_service,\n+            patch(\"services.feature_service.EnterpriseService\") as mock_enterprise_service,\n+        ):\n+            # Setup default mock returns for BillingService\n+            mock_billing_service.get_info.return_value = {\n+                \"enabled\": True,\n+                \"subscription\": {\"plan\": \"pro\", \"interval\": \"monthly\", \"education\": True},\n+                \"members\": {\"size\": 5, \"limit\": 10},\n+                \"apps\": {\"size\": 3, \"limit\": 20},\n+                \"vector_space\": {\"size\": 2, \"limit\": 10},\n+                \"documents_upload_quota\": {\"size\": 15, \"limit\": 100},\n+                \"annotation_quota_limit\": {\"size\": 8, \"limit\": 50},\n+                \"docs_processing\": \"enhanced\",\n+                \"can_replace_logo\": True,\n+                \"model_load_balancing_enabled\": True,\n+                \"knowledge_rate_limit\": {\"limit\": 100},\n+            }\n+\n+            mock_billing_service.get_knowledge_rate_limit.return_value = {\"limit\": 100, \"subscription_plan\": \"pro\"}\n+\n+            # Setup default mock returns for EnterpriseService\n+            mock_enterprise_service.get_workspace_info.return_value = {\n+                \"WorkspaceMembers\": {\"used\": 5, \"limit\": 10, \"enabled\": True}\n+            }\n+\n+            mock_enterprise_service.get_info.return_value = {\n+                \"SSOEnforcedForSignin\": True,\n+                \"SSOEnforcedForSigninProtocol\": \"saml\",\n+                \"EnableEmailCodeLogin\": True,\n+                \"EnableEmailPasswordLogin\": False,\n+                \"IsAllowRegister\": False,\n+                \"IsAllowCreateWorkspace\": False,\n+                \"Branding\": {\n+                    \"applicationTitle\": \"Test Enterprise\",\n+                    \"loginPageLogo\": \"https://example.com/logo.png\",\n+                    \"workspaceLogo\": \"https://example.com/workspace.png\",\n+                    \"favicon\": \"https://example.com/favicon.ico\",\n+                },\n+                \"WebAppAuth\": {\"allowSso\": True, \"allowEmailCodeLogin\": True, \"allowEmailPasswordLogin\": False},\n+                \"SSOEnforcedForWebProtocol\": \"oidc\",\n+                \"License\": {\n+                    \"status\": \"active\",\n+                    \"expiredAt\": \"2025-12-31\",\n+                    \"workspaces\": {\"enabled\": True, \"limit\": 5, \"used\": 2},\n+                },\n+                \"PluginInstallationPermission\": {\n+                    \"pluginInstallationScope\": \"official_only\",\n+                    \"restrictToMarketplaceOnly\": True,\n+                },\n+            }\n+\n+            yield {\n+                \"billing_service\": mock_billing_service,\n+                \"enterprise_service\": mock_enterprise_service,\n+            }\n+\n+    def _create_test_tenant_id(self):\n+        \"\"\"Helper method to create a test tenant ID.\"\"\"\n+        fake = Faker()\n+        return fake.uuid4()\n+\n+    def test_get_features_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful feature retrieval with billing and enterprise enabled.\n+\n+        This test verifies:\n+        - Proper feature model creation with all required fields\n+        - Correct integration with billing service\n+        - Proper enterprise workspace information handling\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config mocking\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = True\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = True\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing features\n+            assert result.billing.enabled is True\n+            assert result.billing.subscription.plan == \"pro\"\n+            assert result.billing.subscription.interval == \"monthly\"\n+            assert result.education.activated is True\n+\n+            # Verify member limitations\n+            assert result.members.size == 5\n+            assert result.members.limit == 10\n+\n+            # Verify app limitations\n+            assert result.apps.size == 3\n+            assert result.apps.limit == 20\n+\n+            # Verify vector space limitations\n+            assert result.vector_space.size == 2\n+            assert result.vector_space.limit == 10\n+\n+            # Verify document upload quota\n+            assert result.documents_upload_quota.size == 15\n+            assert result.documents_upload_quota.limit == 100\n+\n+            # Verify annotation quota\n+            assert result.annotation_quota_limit.size == 8\n+            assert result.annotation_quota_limit.limit == 50\n+\n+            # Verify other features\n+            assert result.docs_processing == \"enhanced\"\n+            assert result.can_replace_logo is True\n+            assert result.model_load_balancing_enabled is True\n+            assert result.knowledge_rate_limit == 100\n+\n+            # Verify enterprise features\n+            assert result.workspace_members.enabled is True\n+            assert result.workspace_members.size == 5\n+            assert result.workspace_members.limit == 10\n+\n+            # Verify webapp copyright is enabled for non-sandbox plans\n+            assert result.webapp_copyright_enabled is True\n+            assert result.is_allow_transfer_workspace is True\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"billing_service\"].get_info.assert_called_once_with(tenant_id)\n+            mock_external_service_dependencies[\"enterprise_service\"].get_workspace_info.assert_called_once_with(\n+                tenant_id\n+            )\n+\n+    def test_get_features_sandbox_plan(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval for sandbox plan with specific limitations.\n+\n+        This test verifies:\n+        - Proper handling of sandbox plan limitations\n+        - Correct webapp copyright settings for sandbox\n+        - Transfer workspace restrictions for sandbox plans\n+        - Proper billing service integration\n+        \"\"\"\n+        # Arrange: Setup sandbox plan mock with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = False\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = False\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            # Set mock return value inside the patch context\n+            mock_external_service_dependencies[\"billing_service\"].get_info.return_value = {\n+                \"enabled\": True,\n+                \"subscription\": {\"plan\": \"sandbox\", \"interval\": \"monthly\", \"education\": False},\n+                \"members\": {\"size\": 1, \"limit\": 3},\n+                \"apps\": {\"size\": 1, \"limit\": 5},\n+                \"vector_space\": {\"size\": 1, \"limit\": 2},\n+                \"documents_upload_quota\": {\"size\": 5, \"limit\": 20},\n+                \"annotation_quota_limit\": {\"size\": 2, \"limit\": 10},\n+                \"docs_processing\": \"standard\",\n+                \"can_replace_logo\": False,\n+                \"model_load_balancing_enabled\": False,\n+                \"knowledge_rate_limit\": {\"limit\": 10},\n+            }\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+        # Assert: Verify sandbox-specific limitations\n+        assert result.billing.subscription.plan == \"sandbox\"\n+        assert result.education.activated is False\n+\n+        # Verify sandbox limitations\n+        assert result.members.size == 1\n+        assert result.members.limit == 3\n+        assert result.apps.size == 1\n+        assert result.apps.limit == 5\n+        assert result.vector_space.size == 1\n+        assert result.vector_space.limit == 2\n+        assert result.documents_upload_quota.size == 5\n+        assert result.documents_upload_quota.limit == 20\n+        assert result.annotation_quota_limit.size == 2\n+        assert result.annotation_quota_limit.limit == 10\n+\n+        # Verify sandbox-specific restrictions\n+        assert result.webapp_copyright_enabled is False\n+        assert result.is_allow_transfer_workspace is False\n+        assert result.can_replace_logo is False\n+        assert result.model_load_balancing_enabled is False\n+        assert result.docs_processing == \"standard\"\n+        assert result.knowledge_rate_limit == 10\n+\n+        # Verify mock interactions\n+        mock_external_service_dependencies[\"billing_service\"].get_info.assert_called_once_with(tenant_id)\n+\n+    def test_get_knowledge_rate_limit_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful knowledge rate limit retrieval with billing enabled.\n+\n+        This test verifies:\n+        - Proper knowledge rate limit model creation\n+        - Correct integration with billing service\n+        - Proper rate limit configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_knowledge_rate_limit(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, KnowledgeRateLimitModel)\n+\n+            # Verify rate limit configuration\n+            assert result.enabled is True\n+            assert result.limit == 100\n+            assert result.subscription_plan == \"pro\"\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"billing_service\"].get_knowledge_rate_limit.assert_called_once_with(\n+                tenant_id\n+            )\n+\n+    def test_get_system_features_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful system features retrieval with enterprise and marketplace enabled.\n+\n+        This test verifies:\n+        - Proper system feature model creation\n+        - Correct integration with enterprise service\n+        - Proper marketplace configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.MARKETPLACE_ENABLED = True\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = True\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = False\n+            mock_config.ALLOW_REGISTER = False\n+            mock_config.ALLOW_CREATE_WORKSPACE = False\n+            mock_config.MAIL_TYPE = \"smtp\"\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 100\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+        # Assert: Verify the expected outcomes\n+        assert result is not None\n+        assert isinstance(result, SystemFeatureModel)\n+\n+        # Verify enterprise features\n+        assert result.branding.enabled is True\n+        assert result.webapp_auth.enabled is True\n+        assert result.enable_change_email is False\n+\n+        # Verify SSO configuration\n+        assert result.sso_enforced_for_signin is True\n+        assert result.sso_enforced_for_signin_protocol == \"saml\"\n+\n+        # Verify authentication settings\n+        assert result.enable_email_code_login is True\n+        assert result.enable_email_password_login is False\n+        assert result.is_allow_register is False\n+        assert result.is_allow_create_workspace is False\n+\n+        # Verify branding configuration\n+        assert result.branding.application_title == \"Test Enterprise\"\n+        assert result.branding.login_page_logo == \"https://example.com/logo.png\"\n+        assert result.branding.workspace_logo == \"https://example.com/workspace.png\"\n+        assert result.branding.favicon == \"https://example.com/favicon.ico\"\n+\n+        # Verify webapp auth configuration\n+        assert result.webapp_auth.allow_sso is True\n+        assert result.webapp_auth.allow_email_code_login is True\n+        assert result.webapp_auth.allow_email_password_login is False\n+        assert result.webapp_auth.sso_config.protocol == \"oidc\"\n+\n+        # Verify license configuration\n+        assert result.license.status.value == \"active\"\n+        assert result.license.expired_at == \"2025-12-31\"\n+        assert result.license.workspaces.enabled is True\n+        assert result.license.workspaces.limit == 5\n+        assert result.license.workspaces.size == 2\n+\n+        # Verify plugin installation permission\n+        assert result.plugin_installation_permission.plugin_installation_scope == \"official_only\"\n+        assert result.plugin_installation_permission.restrict_to_marketplace_only is True\n+\n+        # Verify marketplace configuration\n+        assert result.enable_marketplace is True\n+\n+        # Verify mock interactions\n+        mock_external_service_dependencies[\"enterprise_service\"].get_info.assert_called_once()\n+\n+    def test_get_system_features_basic_config(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test system features retrieval with basic configuration (no enterprise).\n+\n+        This test verifies:\n+        - Proper system feature model creation without enterprise\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup basic config mock (no enterprise)\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.MARKETPLACE_ENABLED = False\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = True\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = False\n+            mock_config.ALLOW_REGISTER = True\n+            mock_config.ALLOW_CREATE_WORKSPACE = True\n+            mock_config.MAIL_TYPE = \"smtp\"\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 100\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, SystemFeatureModel)\n+\n+            # Verify basic configuration\n+            assert result.branding.enabled is False\n+            assert result.webapp_auth.enabled is False\n+            assert result.enable_change_email is True\n+\n+            # Verify authentication settings from config\n+            assert result.enable_email_code_login is True\n+            assert result.enable_email_password_login is True\n+            assert result.enable_social_oauth_login is False\n+            assert result.is_allow_register is True\n+            assert result.is_allow_create_workspace is True\n+            assert result.is_email_setup is True\n+\n+            # Verify marketplace configuration\n+            assert result.enable_marketplace is False\n+\n+            # Verify plugin package size (uses default value from dify_config)\n+            assert result.max_plugin_package_size == 15728640\n+\n+    def test_get_features_billing_disabled(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval when billing is disabled.\n+\n+        This test verifies:\n+        - Proper feature model creation without billing\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup billing disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = True\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = True\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing is disabled\n+            assert result.billing.enabled is False\n+\n+            # Verify environment-based features\n+            assert result.can_replace_logo is True\n+            assert result.model_load_balancing_enabled is True\n+            assert result.dataset_operator_enabled is True\n+            assert result.education.enabled is True\n+\n+            # Verify default limitations\n+            assert result.members.size == 0\n+            assert result.members.limit == 1\n+            assert result.apps.size == 0\n+            assert result.apps.limit == 10\n+            assert result.vector_space.size == 0\n+            assert result.vector_space.limit == 5\n+            assert result.documents_upload_quota.size == 0\n+            assert result.documents_upload_quota.limit == 50\n+            assert result.annotation_quota_limit.size == 0\n+            assert result.annotation_quota_limit.limit == 10\n+            assert result.knowledge_rate_limit == 10\n+            assert result.docs_processing == \"standard\"\n+\n+            # Verify no enterprise features\n+            assert result.workspace_members.enabled is False\n+            assert result.webapp_copyright_enabled is False\n+\n+    def test_get_knowledge_rate_limit_billing_disabled(\n+        self, db_session_with_containers, mock_external_service_dependencies\n+    ):\n+        \"\"\"\n+        Test knowledge rate limit retrieval when billing is disabled.\n+\n+        This test verifies:\n+        - Proper knowledge rate limit model creation without billing\n+        - Default rate limit configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup billing disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_knowledge_rate_limit(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, KnowledgeRateLimitModel)\n+\n+            # Verify default configuration\n+            assert result.enabled is False\n+            assert result.limit == 10\n+            assert result.subscription_plan == \"\"  # Empty string when billing is disabled\n+\n+            # Verify no billing service calls\n+            mock_external_service_dependencies[\"billing_service\"].get_knowledge_rate_limit.assert_not_called()\n+\n+    def test_get_features_enterprise_only(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval with enterprise enabled but billing disabled.\n+\n+        This test verifies:\n+        - Proper feature model creation with enterprise only\n+        - Correct enterprise service integration\n+        - Proper workspace member handling\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup enterprise only mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.CAN_REPLACE_LOGO = False\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = False\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing is disabled\n+            assert result.billing.enabled is False\n+\n+            # Verify enterprise features\n+            assert result.webapp_copyright_enabled is True\n+\n+            # Verify workspace members from enterprise\n+            assert result.workspace_members.enabled is True\n+            assert result.workspace_members.size == 5\n+            assert result.workspace_members.limit == 10\n+\n+            # Verify environment-based features\n+            assert result.can_replace_logo is False\n+            assert result.model_load_balancing_enabled is False\n+            assert result.dataset_operator_enabled is False\n+            assert result.education.enabled is False\n+\n+            # Verify default limitations\n+            assert result.members.size == 0\n+            assert result.members.limit == 1\n+            assert result.apps.size == 0\n+            assert result.apps.limit == 10\n+            assert result.vector_space.size == 0\n+            assert result.vector_space.limit == 5\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"enterprise_service\"].get_workspace_info.assert_called_once_with(\n+                tenant_id\n+            )\n+            mock_external_service_dependencies[\"billing_service\"].get_info.assert_not_called()\n+\n+    def test_get_system_features_enterprise_disabled(\n+        self, db_session_with_containers, mock_external_service_dependencies\n+    ):\n+        \"\"\"\n+        Test system features retrieval when enterprise is disabled.\n+\n+        This test verifies:\n+        - Proper system feature model creation without enterprise\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup enterprise disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.MARKETPLACE_ENABLED = True\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = False\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = True\n+            mock_config.ALLOW_REGISTER = False\n+            mock_config.ALLOW_CREATE_WORKSPACE = False\n+            mock_config.MAIL_TYPE = None\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 50\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, SystemFeatureModel)\n+\n+            # Verify enterprise features are disabled\n+            assert result.branding.enabled is False\n+            assert result.webapp_auth.enabled is False\n+            assert result.enable_change_email is True\n+\n+            # Verify authentication settings from config\n+            assert result.enable_email_code_login is False\n+            assert result.enable_email_password_login is True\n+            assert result.enable_social_oauth_login is True\n+            assert result.is_allow_register is False\n+            assert result.is_allow_create_workspace is False\n+            assert result.is_email_setup is False\n+\n+            # Verify marketplace configuration\n+            assert result.enable_marketplace is True\n+\n+            # Verify plugin package size (uses default value from dify_config)\n+            assert result.max_plugin_package_size == 15728640\n+\n+            # Verify default license status\n+            assert result.license.status.value == \"none\"\n+            assert result.license.expired_at == \"\"\n+            assert result.license.workspaces.enabled is False\n+\n+            # Verify no enterprise service calls\n+            mock_external_service_dependencies[\"enterprise_service\"].get_info.assert_not_called()\n+\n+    def test_get_features_no_tenant_id(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval without tenant ID (billing disabled).\n+\n+        This test verifies:\n+        - Proper feature model creation without tenant ID\n+        - Correct handling when billing is disabled\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup no tenant ID scenario\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(\"\")",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2280724307",
        "repo_full_name": "langgenius/dify",
        "pr_number": 24026,
        "pr_file": "api/tests/test_containers_integration_tests/services/test_feature_service.py",
        "discussion_id": "2280724307",
        "commented_code": "@@ -0,0 +1,1785 @@\n+from unittest.mock import patch\n+\n+import pytest\n+from faker import Faker\n+\n+from services.feature_service import FeatureModel, FeatureService, KnowledgeRateLimitModel, SystemFeatureModel\n+\n+\n+class TestFeatureService:\n+    \"\"\"Integration tests for FeatureService using testcontainers.\"\"\"\n+\n+    @pytest.fixture\n+    def mock_external_service_dependencies(self):\n+        \"\"\"Mock setup for external service dependencies.\"\"\"\n+        with (\n+            patch(\"services.feature_service.BillingService\") as mock_billing_service,\n+            patch(\"services.feature_service.EnterpriseService\") as mock_enterprise_service,\n+        ):\n+            # Setup default mock returns for BillingService\n+            mock_billing_service.get_info.return_value = {\n+                \"enabled\": True,\n+                \"subscription\": {\"plan\": \"pro\", \"interval\": \"monthly\", \"education\": True},\n+                \"members\": {\"size\": 5, \"limit\": 10},\n+                \"apps\": {\"size\": 3, \"limit\": 20},\n+                \"vector_space\": {\"size\": 2, \"limit\": 10},\n+                \"documents_upload_quota\": {\"size\": 15, \"limit\": 100},\n+                \"annotation_quota_limit\": {\"size\": 8, \"limit\": 50},\n+                \"docs_processing\": \"enhanced\",\n+                \"can_replace_logo\": True,\n+                \"model_load_balancing_enabled\": True,\n+                \"knowledge_rate_limit\": {\"limit\": 100},\n+            }\n+\n+            mock_billing_service.get_knowledge_rate_limit.return_value = {\"limit\": 100, \"subscription_plan\": \"pro\"}\n+\n+            # Setup default mock returns for EnterpriseService\n+            mock_enterprise_service.get_workspace_info.return_value = {\n+                \"WorkspaceMembers\": {\"used\": 5, \"limit\": 10, \"enabled\": True}\n+            }\n+\n+            mock_enterprise_service.get_info.return_value = {\n+                \"SSOEnforcedForSignin\": True,\n+                \"SSOEnforcedForSigninProtocol\": \"saml\",\n+                \"EnableEmailCodeLogin\": True,\n+                \"EnableEmailPasswordLogin\": False,\n+                \"IsAllowRegister\": False,\n+                \"IsAllowCreateWorkspace\": False,\n+                \"Branding\": {\n+                    \"applicationTitle\": \"Test Enterprise\",\n+                    \"loginPageLogo\": \"https://example.com/logo.png\",\n+                    \"workspaceLogo\": \"https://example.com/workspace.png\",\n+                    \"favicon\": \"https://example.com/favicon.ico\",\n+                },\n+                \"WebAppAuth\": {\"allowSso\": True, \"allowEmailCodeLogin\": True, \"allowEmailPasswordLogin\": False},\n+                \"SSOEnforcedForWebProtocol\": \"oidc\",\n+                \"License\": {\n+                    \"status\": \"active\",\n+                    \"expiredAt\": \"2025-12-31\",\n+                    \"workspaces\": {\"enabled\": True, \"limit\": 5, \"used\": 2},\n+                },\n+                \"PluginInstallationPermission\": {\n+                    \"pluginInstallationScope\": \"official_only\",\n+                    \"restrictToMarketplaceOnly\": True,\n+                },\n+            }\n+\n+            yield {\n+                \"billing_service\": mock_billing_service,\n+                \"enterprise_service\": mock_enterprise_service,\n+            }\n+\n+    def _create_test_tenant_id(self):\n+        \"\"\"Helper method to create a test tenant ID.\"\"\"\n+        fake = Faker()\n+        return fake.uuid4()\n+\n+    def test_get_features_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful feature retrieval with billing and enterprise enabled.\n+\n+        This test verifies:\n+        - Proper feature model creation with all required fields\n+        - Correct integration with billing service\n+        - Proper enterprise workspace information handling\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config mocking\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = True\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = True\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing features\n+            assert result.billing.enabled is True\n+            assert result.billing.subscription.plan == \"pro\"\n+            assert result.billing.subscription.interval == \"monthly\"\n+            assert result.education.activated is True\n+\n+            # Verify member limitations\n+            assert result.members.size == 5\n+            assert result.members.limit == 10\n+\n+            # Verify app limitations\n+            assert result.apps.size == 3\n+            assert result.apps.limit == 20\n+\n+            # Verify vector space limitations\n+            assert result.vector_space.size == 2\n+            assert result.vector_space.limit == 10\n+\n+            # Verify document upload quota\n+            assert result.documents_upload_quota.size == 15\n+            assert result.documents_upload_quota.limit == 100\n+\n+            # Verify annotation quota\n+            assert result.annotation_quota_limit.size == 8\n+            assert result.annotation_quota_limit.limit == 50\n+\n+            # Verify other features\n+            assert result.docs_processing == \"enhanced\"\n+            assert result.can_replace_logo is True\n+            assert result.model_load_balancing_enabled is True\n+            assert result.knowledge_rate_limit == 100\n+\n+            # Verify enterprise features\n+            assert result.workspace_members.enabled is True\n+            assert result.workspace_members.size == 5\n+            assert result.workspace_members.limit == 10\n+\n+            # Verify webapp copyright is enabled for non-sandbox plans\n+            assert result.webapp_copyright_enabled is True\n+            assert result.is_allow_transfer_workspace is True\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"billing_service\"].get_info.assert_called_once_with(tenant_id)\n+            mock_external_service_dependencies[\"enterprise_service\"].get_workspace_info.assert_called_once_with(\n+                tenant_id\n+            )\n+\n+    def test_get_features_sandbox_plan(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval for sandbox plan with specific limitations.\n+\n+        This test verifies:\n+        - Proper handling of sandbox plan limitations\n+        - Correct webapp copyright settings for sandbox\n+        - Transfer workspace restrictions for sandbox plans\n+        - Proper billing service integration\n+        \"\"\"\n+        # Arrange: Setup sandbox plan mock with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = False\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = False\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            # Set mock return value inside the patch context\n+            mock_external_service_dependencies[\"billing_service\"].get_info.return_value = {\n+                \"enabled\": True,\n+                \"subscription\": {\"plan\": \"sandbox\", \"interval\": \"monthly\", \"education\": False},\n+                \"members\": {\"size\": 1, \"limit\": 3},\n+                \"apps\": {\"size\": 1, \"limit\": 5},\n+                \"vector_space\": {\"size\": 1, \"limit\": 2},\n+                \"documents_upload_quota\": {\"size\": 5, \"limit\": 20},\n+                \"annotation_quota_limit\": {\"size\": 2, \"limit\": 10},\n+                \"docs_processing\": \"standard\",\n+                \"can_replace_logo\": False,\n+                \"model_load_balancing_enabled\": False,\n+                \"knowledge_rate_limit\": {\"limit\": 10},\n+            }\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+        # Assert: Verify sandbox-specific limitations\n+        assert result.billing.subscription.plan == \"sandbox\"\n+        assert result.education.activated is False\n+\n+        # Verify sandbox limitations\n+        assert result.members.size == 1\n+        assert result.members.limit == 3\n+        assert result.apps.size == 1\n+        assert result.apps.limit == 5\n+        assert result.vector_space.size == 1\n+        assert result.vector_space.limit == 2\n+        assert result.documents_upload_quota.size == 5\n+        assert result.documents_upload_quota.limit == 20\n+        assert result.annotation_quota_limit.size == 2\n+        assert result.annotation_quota_limit.limit == 10\n+\n+        # Verify sandbox-specific restrictions\n+        assert result.webapp_copyright_enabled is False\n+        assert result.is_allow_transfer_workspace is False\n+        assert result.can_replace_logo is False\n+        assert result.model_load_balancing_enabled is False\n+        assert result.docs_processing == \"standard\"\n+        assert result.knowledge_rate_limit == 10\n+\n+        # Verify mock interactions\n+        mock_external_service_dependencies[\"billing_service\"].get_info.assert_called_once_with(tenant_id)\n+\n+    def test_get_knowledge_rate_limit_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful knowledge rate limit retrieval with billing enabled.\n+\n+        This test verifies:\n+        - Proper knowledge rate limit model creation\n+        - Correct integration with billing service\n+        - Proper rate limit configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_knowledge_rate_limit(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, KnowledgeRateLimitModel)\n+\n+            # Verify rate limit configuration\n+            assert result.enabled is True\n+            assert result.limit == 100\n+            assert result.subscription_plan == \"pro\"\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"billing_service\"].get_knowledge_rate_limit.assert_called_once_with(\n+                tenant_id\n+            )\n+\n+    def test_get_system_features_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful system features retrieval with enterprise and marketplace enabled.\n+\n+        This test verifies:\n+        - Proper system feature model creation\n+        - Correct integration with enterprise service\n+        - Proper marketplace configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.MARKETPLACE_ENABLED = True\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = True\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = False\n+            mock_config.ALLOW_REGISTER = False\n+            mock_config.ALLOW_CREATE_WORKSPACE = False\n+            mock_config.MAIL_TYPE = \"smtp\"\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 100\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+        # Assert: Verify the expected outcomes\n+        assert result is not None\n+        assert isinstance(result, SystemFeatureModel)\n+\n+        # Verify enterprise features\n+        assert result.branding.enabled is True\n+        assert result.webapp_auth.enabled is True\n+        assert result.enable_change_email is False\n+\n+        # Verify SSO configuration\n+        assert result.sso_enforced_for_signin is True\n+        assert result.sso_enforced_for_signin_protocol == \"saml\"\n+\n+        # Verify authentication settings\n+        assert result.enable_email_code_login is True\n+        assert result.enable_email_password_login is False\n+        assert result.is_allow_register is False\n+        assert result.is_allow_create_workspace is False\n+\n+        # Verify branding configuration\n+        assert result.branding.application_title == \"Test Enterprise\"\n+        assert result.branding.login_page_logo == \"https://example.com/logo.png\"\n+        assert result.branding.workspace_logo == \"https://example.com/workspace.png\"\n+        assert result.branding.favicon == \"https://example.com/favicon.ico\"\n+\n+        # Verify webapp auth configuration\n+        assert result.webapp_auth.allow_sso is True\n+        assert result.webapp_auth.allow_email_code_login is True\n+        assert result.webapp_auth.allow_email_password_login is False\n+        assert result.webapp_auth.sso_config.protocol == \"oidc\"\n+\n+        # Verify license configuration\n+        assert result.license.status.value == \"active\"\n+        assert result.license.expired_at == \"2025-12-31\"\n+        assert result.license.workspaces.enabled is True\n+        assert result.license.workspaces.limit == 5\n+        assert result.license.workspaces.size == 2\n+\n+        # Verify plugin installation permission\n+        assert result.plugin_installation_permission.plugin_installation_scope == \"official_only\"\n+        assert result.plugin_installation_permission.restrict_to_marketplace_only is True\n+\n+        # Verify marketplace configuration\n+        assert result.enable_marketplace is True\n+\n+        # Verify mock interactions\n+        mock_external_service_dependencies[\"enterprise_service\"].get_info.assert_called_once()\n+\n+    def test_get_system_features_basic_config(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test system features retrieval with basic configuration (no enterprise).\n+\n+        This test verifies:\n+        - Proper system feature model creation without enterprise\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup basic config mock (no enterprise)\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.MARKETPLACE_ENABLED = False\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = True\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = False\n+            mock_config.ALLOW_REGISTER = True\n+            mock_config.ALLOW_CREATE_WORKSPACE = True\n+            mock_config.MAIL_TYPE = \"smtp\"\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 100\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, SystemFeatureModel)\n+\n+            # Verify basic configuration\n+            assert result.branding.enabled is False\n+            assert result.webapp_auth.enabled is False\n+            assert result.enable_change_email is True\n+\n+            # Verify authentication settings from config\n+            assert result.enable_email_code_login is True\n+            assert result.enable_email_password_login is True\n+            assert result.enable_social_oauth_login is False\n+            assert result.is_allow_register is True\n+            assert result.is_allow_create_workspace is True\n+            assert result.is_email_setup is True\n+\n+            # Verify marketplace configuration\n+            assert result.enable_marketplace is False\n+\n+            # Verify plugin package size (uses default value from dify_config)\n+            assert result.max_plugin_package_size == 15728640\n+\n+    def test_get_features_billing_disabled(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval when billing is disabled.\n+\n+        This test verifies:\n+        - Proper feature model creation without billing\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup billing disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = True\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = True\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing is disabled\n+            assert result.billing.enabled is False\n+\n+            # Verify environment-based features\n+            assert result.can_replace_logo is True\n+            assert result.model_load_balancing_enabled is True\n+            assert result.dataset_operator_enabled is True\n+            assert result.education.enabled is True\n+\n+            # Verify default limitations\n+            assert result.members.size == 0\n+            assert result.members.limit == 1\n+            assert result.apps.size == 0\n+            assert result.apps.limit == 10\n+            assert result.vector_space.size == 0\n+            assert result.vector_space.limit == 5\n+            assert result.documents_upload_quota.size == 0\n+            assert result.documents_upload_quota.limit == 50\n+            assert result.annotation_quota_limit.size == 0\n+            assert result.annotation_quota_limit.limit == 10\n+            assert result.knowledge_rate_limit == 10\n+            assert result.docs_processing == \"standard\"\n+\n+            # Verify no enterprise features\n+            assert result.workspace_members.enabled is False\n+            assert result.webapp_copyright_enabled is False\n+\n+    def test_get_knowledge_rate_limit_billing_disabled(\n+        self, db_session_with_containers, mock_external_service_dependencies\n+    ):\n+        \"\"\"\n+        Test knowledge rate limit retrieval when billing is disabled.\n+\n+        This test verifies:\n+        - Proper knowledge rate limit model creation without billing\n+        - Default rate limit configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup billing disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_knowledge_rate_limit(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, KnowledgeRateLimitModel)\n+\n+            # Verify default configuration\n+            assert result.enabled is False\n+            assert result.limit == 10\n+            assert result.subscription_plan == \"\"  # Empty string when billing is disabled\n+\n+            # Verify no billing service calls\n+            mock_external_service_dependencies[\"billing_service\"].get_knowledge_rate_limit.assert_not_called()\n+\n+    def test_get_features_enterprise_only(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval with enterprise enabled but billing disabled.\n+\n+        This test verifies:\n+        - Proper feature model creation with enterprise only\n+        - Correct enterprise service integration\n+        - Proper workspace member handling\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup enterprise only mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.CAN_REPLACE_LOGO = False\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = False\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing is disabled\n+            assert result.billing.enabled is False\n+\n+            # Verify enterprise features\n+            assert result.webapp_copyright_enabled is True\n+\n+            # Verify workspace members from enterprise\n+            assert result.workspace_members.enabled is True\n+            assert result.workspace_members.size == 5\n+            assert result.workspace_members.limit == 10\n+\n+            # Verify environment-based features\n+            assert result.can_replace_logo is False\n+            assert result.model_load_balancing_enabled is False\n+            assert result.dataset_operator_enabled is False\n+            assert result.education.enabled is False\n+\n+            # Verify default limitations\n+            assert result.members.size == 0\n+            assert result.members.limit == 1\n+            assert result.apps.size == 0\n+            assert result.apps.limit == 10\n+            assert result.vector_space.size == 0\n+            assert result.vector_space.limit == 5\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"enterprise_service\"].get_workspace_info.assert_called_once_with(\n+                tenant_id\n+            )\n+            mock_external_service_dependencies[\"billing_service\"].get_info.assert_not_called()\n+\n+    def test_get_system_features_enterprise_disabled(\n+        self, db_session_with_containers, mock_external_service_dependencies\n+    ):\n+        \"\"\"\n+        Test system features retrieval when enterprise is disabled.\n+\n+        This test verifies:\n+        - Proper system feature model creation without enterprise\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup enterprise disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.MARKETPLACE_ENABLED = True\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = False\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = True\n+            mock_config.ALLOW_REGISTER = False\n+            mock_config.ALLOW_CREATE_WORKSPACE = False\n+            mock_config.MAIL_TYPE = None\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 50\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, SystemFeatureModel)\n+\n+            # Verify enterprise features are disabled\n+            assert result.branding.enabled is False\n+            assert result.webapp_auth.enabled is False\n+            assert result.enable_change_email is True\n+\n+            # Verify authentication settings from config\n+            assert result.enable_email_code_login is False\n+            assert result.enable_email_password_login is True\n+            assert result.enable_social_oauth_login is True\n+            assert result.is_allow_register is False\n+            assert result.is_allow_create_workspace is False\n+            assert result.is_email_setup is False\n+\n+            # Verify marketplace configuration\n+            assert result.enable_marketplace is True\n+\n+            # Verify plugin package size (uses default value from dify_config)\n+            assert result.max_plugin_package_size == 15728640\n+\n+            # Verify default license status\n+            assert result.license.status.value == \"none\"\n+            assert result.license.expired_at == \"\"\n+            assert result.license.workspaces.enabled is False\n+\n+            # Verify no enterprise service calls\n+            mock_external_service_dependencies[\"enterprise_service\"].get_info.assert_not_called()\n+\n+    def test_get_features_no_tenant_id(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval without tenant ID (billing disabled).\n+\n+        This test verifies:\n+        - Proper feature model creation without tenant ID\n+        - Correct handling when billing is disabled\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup no tenant ID scenario\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(\"\")",
        "comment_created_at": "2025-08-17T05:08:08+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": "It seems unusual that `FeatureService.get_features` allows empty `tenant_id`. Looking at the implementation, when `tenant_id` is empty, the method skips billing-related feature checks, which could lead to incorrect behavior.\n\nI have skimmed the current usage of `FeatureService.get_features`, and I believe that `tenant_id` should not be `None` or `\"\"` when `FeatureService.get_features` is called. It should be considered a programming error if it does so.\n\nI suggest changing the current implementation to raise an `AssertionError` when `tenant_id` is empty or `None` (or just use `assert tenant_id`), and updating the test case `test_get_features_no_tenant_id` to validate that `AssertionError` is raised when called with empty or `None` values.\n\n(Ideally, we should raise `ValueError` for these kinds of errors. However, `ValueError` is caught and converted to HTTP 400 errors in `api/libs/external_api.py`, which would complicate the debugging process for such programming errors. So instead I suggest using `assert` or raising `AssertionError` to better reflect that this is a programming error.)\n\nIf there are legitimate use cases for calling this method without a `tenant_id`, then the documentation of `FeatureService.get_features` should state this behavior explicitly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2280726798",
        "repo_full_name": "langgenius/dify",
        "pr_number": 24026,
        "pr_file": "api/tests/test_containers_integration_tests/services/test_feature_service.py",
        "discussion_id": "2280724307",
        "commented_code": "@@ -0,0 +1,1785 @@\n+from unittest.mock import patch\n+\n+import pytest\n+from faker import Faker\n+\n+from services.feature_service import FeatureModel, FeatureService, KnowledgeRateLimitModel, SystemFeatureModel\n+\n+\n+class TestFeatureService:\n+    \"\"\"Integration tests for FeatureService using testcontainers.\"\"\"\n+\n+    @pytest.fixture\n+    def mock_external_service_dependencies(self):\n+        \"\"\"Mock setup for external service dependencies.\"\"\"\n+        with (\n+            patch(\"services.feature_service.BillingService\") as mock_billing_service,\n+            patch(\"services.feature_service.EnterpriseService\") as mock_enterprise_service,\n+        ):\n+            # Setup default mock returns for BillingService\n+            mock_billing_service.get_info.return_value = {\n+                \"enabled\": True,\n+                \"subscription\": {\"plan\": \"pro\", \"interval\": \"monthly\", \"education\": True},\n+                \"members\": {\"size\": 5, \"limit\": 10},\n+                \"apps\": {\"size\": 3, \"limit\": 20},\n+                \"vector_space\": {\"size\": 2, \"limit\": 10},\n+                \"documents_upload_quota\": {\"size\": 15, \"limit\": 100},\n+                \"annotation_quota_limit\": {\"size\": 8, \"limit\": 50},\n+                \"docs_processing\": \"enhanced\",\n+                \"can_replace_logo\": True,\n+                \"model_load_balancing_enabled\": True,\n+                \"knowledge_rate_limit\": {\"limit\": 100},\n+            }\n+\n+            mock_billing_service.get_knowledge_rate_limit.return_value = {\"limit\": 100, \"subscription_plan\": \"pro\"}\n+\n+            # Setup default mock returns for EnterpriseService\n+            mock_enterprise_service.get_workspace_info.return_value = {\n+                \"WorkspaceMembers\": {\"used\": 5, \"limit\": 10, \"enabled\": True}\n+            }\n+\n+            mock_enterprise_service.get_info.return_value = {\n+                \"SSOEnforcedForSignin\": True,\n+                \"SSOEnforcedForSigninProtocol\": \"saml\",\n+                \"EnableEmailCodeLogin\": True,\n+                \"EnableEmailPasswordLogin\": False,\n+                \"IsAllowRegister\": False,\n+                \"IsAllowCreateWorkspace\": False,\n+                \"Branding\": {\n+                    \"applicationTitle\": \"Test Enterprise\",\n+                    \"loginPageLogo\": \"https://example.com/logo.png\",\n+                    \"workspaceLogo\": \"https://example.com/workspace.png\",\n+                    \"favicon\": \"https://example.com/favicon.ico\",\n+                },\n+                \"WebAppAuth\": {\"allowSso\": True, \"allowEmailCodeLogin\": True, \"allowEmailPasswordLogin\": False},\n+                \"SSOEnforcedForWebProtocol\": \"oidc\",\n+                \"License\": {\n+                    \"status\": \"active\",\n+                    \"expiredAt\": \"2025-12-31\",\n+                    \"workspaces\": {\"enabled\": True, \"limit\": 5, \"used\": 2},\n+                },\n+                \"PluginInstallationPermission\": {\n+                    \"pluginInstallationScope\": \"official_only\",\n+                    \"restrictToMarketplaceOnly\": True,\n+                },\n+            }\n+\n+            yield {\n+                \"billing_service\": mock_billing_service,\n+                \"enterprise_service\": mock_enterprise_service,\n+            }\n+\n+    def _create_test_tenant_id(self):\n+        \"\"\"Helper method to create a test tenant ID.\"\"\"\n+        fake = Faker()\n+        return fake.uuid4()\n+\n+    def test_get_features_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful feature retrieval with billing and enterprise enabled.\n+\n+        This test verifies:\n+        - Proper feature model creation with all required fields\n+        - Correct integration with billing service\n+        - Proper enterprise workspace information handling\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config mocking\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = True\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = True\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing features\n+            assert result.billing.enabled is True\n+            assert result.billing.subscription.plan == \"pro\"\n+            assert result.billing.subscription.interval == \"monthly\"\n+            assert result.education.activated is True\n+\n+            # Verify member limitations\n+            assert result.members.size == 5\n+            assert result.members.limit == 10\n+\n+            # Verify app limitations\n+            assert result.apps.size == 3\n+            assert result.apps.limit == 20\n+\n+            # Verify vector space limitations\n+            assert result.vector_space.size == 2\n+            assert result.vector_space.limit == 10\n+\n+            # Verify document upload quota\n+            assert result.documents_upload_quota.size == 15\n+            assert result.documents_upload_quota.limit == 100\n+\n+            # Verify annotation quota\n+            assert result.annotation_quota_limit.size == 8\n+            assert result.annotation_quota_limit.limit == 50\n+\n+            # Verify other features\n+            assert result.docs_processing == \"enhanced\"\n+            assert result.can_replace_logo is True\n+            assert result.model_load_balancing_enabled is True\n+            assert result.knowledge_rate_limit == 100\n+\n+            # Verify enterprise features\n+            assert result.workspace_members.enabled is True\n+            assert result.workspace_members.size == 5\n+            assert result.workspace_members.limit == 10\n+\n+            # Verify webapp copyright is enabled for non-sandbox plans\n+            assert result.webapp_copyright_enabled is True\n+            assert result.is_allow_transfer_workspace is True\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"billing_service\"].get_info.assert_called_once_with(tenant_id)\n+            mock_external_service_dependencies[\"enterprise_service\"].get_workspace_info.assert_called_once_with(\n+                tenant_id\n+            )\n+\n+    def test_get_features_sandbox_plan(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval for sandbox plan with specific limitations.\n+\n+        This test verifies:\n+        - Proper handling of sandbox plan limitations\n+        - Correct webapp copyright settings for sandbox\n+        - Transfer workspace restrictions for sandbox plans\n+        - Proper billing service integration\n+        \"\"\"\n+        # Arrange: Setup sandbox plan mock with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = False\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = False\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            # Set mock return value inside the patch context\n+            mock_external_service_dependencies[\"billing_service\"].get_info.return_value = {\n+                \"enabled\": True,\n+                \"subscription\": {\"plan\": \"sandbox\", \"interval\": \"monthly\", \"education\": False},\n+                \"members\": {\"size\": 1, \"limit\": 3},\n+                \"apps\": {\"size\": 1, \"limit\": 5},\n+                \"vector_space\": {\"size\": 1, \"limit\": 2},\n+                \"documents_upload_quota\": {\"size\": 5, \"limit\": 20},\n+                \"annotation_quota_limit\": {\"size\": 2, \"limit\": 10},\n+                \"docs_processing\": \"standard\",\n+                \"can_replace_logo\": False,\n+                \"model_load_balancing_enabled\": False,\n+                \"knowledge_rate_limit\": {\"limit\": 10},\n+            }\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+        # Assert: Verify sandbox-specific limitations\n+        assert result.billing.subscription.plan == \"sandbox\"\n+        assert result.education.activated is False\n+\n+        # Verify sandbox limitations\n+        assert result.members.size == 1\n+        assert result.members.limit == 3\n+        assert result.apps.size == 1\n+        assert result.apps.limit == 5\n+        assert result.vector_space.size == 1\n+        assert result.vector_space.limit == 2\n+        assert result.documents_upload_quota.size == 5\n+        assert result.documents_upload_quota.limit == 20\n+        assert result.annotation_quota_limit.size == 2\n+        assert result.annotation_quota_limit.limit == 10\n+\n+        # Verify sandbox-specific restrictions\n+        assert result.webapp_copyright_enabled is False\n+        assert result.is_allow_transfer_workspace is False\n+        assert result.can_replace_logo is False\n+        assert result.model_load_balancing_enabled is False\n+        assert result.docs_processing == \"standard\"\n+        assert result.knowledge_rate_limit == 10\n+\n+        # Verify mock interactions\n+        mock_external_service_dependencies[\"billing_service\"].get_info.assert_called_once_with(tenant_id)\n+\n+    def test_get_knowledge_rate_limit_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful knowledge rate limit retrieval with billing enabled.\n+\n+        This test verifies:\n+        - Proper knowledge rate limit model creation\n+        - Correct integration with billing service\n+        - Proper rate limit configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_knowledge_rate_limit(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, KnowledgeRateLimitModel)\n+\n+            # Verify rate limit configuration\n+            assert result.enabled is True\n+            assert result.limit == 100\n+            assert result.subscription_plan == \"pro\"\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"billing_service\"].get_knowledge_rate_limit.assert_called_once_with(\n+                tenant_id\n+            )\n+\n+    def test_get_system_features_success(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test successful system features retrieval with enterprise and marketplace enabled.\n+\n+        This test verifies:\n+        - Proper system feature model creation\n+        - Correct integration with enterprise service\n+        - Proper marketplace configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup test data with proper config\n+        tenant_id = self._create_test_tenant_id()\n+\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.MARKETPLACE_ENABLED = True\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = True\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = False\n+            mock_config.ALLOW_REGISTER = False\n+            mock_config.ALLOW_CREATE_WORKSPACE = False\n+            mock_config.MAIL_TYPE = \"smtp\"\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 100\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+        # Assert: Verify the expected outcomes\n+        assert result is not None\n+        assert isinstance(result, SystemFeatureModel)\n+\n+        # Verify enterprise features\n+        assert result.branding.enabled is True\n+        assert result.webapp_auth.enabled is True\n+        assert result.enable_change_email is False\n+\n+        # Verify SSO configuration\n+        assert result.sso_enforced_for_signin is True\n+        assert result.sso_enforced_for_signin_protocol == \"saml\"\n+\n+        # Verify authentication settings\n+        assert result.enable_email_code_login is True\n+        assert result.enable_email_password_login is False\n+        assert result.is_allow_register is False\n+        assert result.is_allow_create_workspace is False\n+\n+        # Verify branding configuration\n+        assert result.branding.application_title == \"Test Enterprise\"\n+        assert result.branding.login_page_logo == \"https://example.com/logo.png\"\n+        assert result.branding.workspace_logo == \"https://example.com/workspace.png\"\n+        assert result.branding.favicon == \"https://example.com/favicon.ico\"\n+\n+        # Verify webapp auth configuration\n+        assert result.webapp_auth.allow_sso is True\n+        assert result.webapp_auth.allow_email_code_login is True\n+        assert result.webapp_auth.allow_email_password_login is False\n+        assert result.webapp_auth.sso_config.protocol == \"oidc\"\n+\n+        # Verify license configuration\n+        assert result.license.status.value == \"active\"\n+        assert result.license.expired_at == \"2025-12-31\"\n+        assert result.license.workspaces.enabled is True\n+        assert result.license.workspaces.limit == 5\n+        assert result.license.workspaces.size == 2\n+\n+        # Verify plugin installation permission\n+        assert result.plugin_installation_permission.plugin_installation_scope == \"official_only\"\n+        assert result.plugin_installation_permission.restrict_to_marketplace_only is True\n+\n+        # Verify marketplace configuration\n+        assert result.enable_marketplace is True\n+\n+        # Verify mock interactions\n+        mock_external_service_dependencies[\"enterprise_service\"].get_info.assert_called_once()\n+\n+    def test_get_system_features_basic_config(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test system features retrieval with basic configuration (no enterprise).\n+\n+        This test verifies:\n+        - Proper system feature model creation without enterprise\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup basic config mock (no enterprise)\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.MARKETPLACE_ENABLED = False\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = True\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = False\n+            mock_config.ALLOW_REGISTER = True\n+            mock_config.ALLOW_CREATE_WORKSPACE = True\n+            mock_config.MAIL_TYPE = \"smtp\"\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 100\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, SystemFeatureModel)\n+\n+            # Verify basic configuration\n+            assert result.branding.enabled is False\n+            assert result.webapp_auth.enabled is False\n+            assert result.enable_change_email is True\n+\n+            # Verify authentication settings from config\n+            assert result.enable_email_code_login is True\n+            assert result.enable_email_password_login is True\n+            assert result.enable_social_oauth_login is False\n+            assert result.is_allow_register is True\n+            assert result.is_allow_create_workspace is True\n+            assert result.is_email_setup is True\n+\n+            # Verify marketplace configuration\n+            assert result.enable_marketplace is False\n+\n+            # Verify plugin package size (uses default value from dify_config)\n+            assert result.max_plugin_package_size == 15728640\n+\n+    def test_get_features_billing_disabled(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval when billing is disabled.\n+\n+        This test verifies:\n+        - Proper feature model creation without billing\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup billing disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = True\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = True\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing is disabled\n+            assert result.billing.enabled is False\n+\n+            # Verify environment-based features\n+            assert result.can_replace_logo is True\n+            assert result.model_load_balancing_enabled is True\n+            assert result.dataset_operator_enabled is True\n+            assert result.education.enabled is True\n+\n+            # Verify default limitations\n+            assert result.members.size == 0\n+            assert result.members.limit == 1\n+            assert result.apps.size == 0\n+            assert result.apps.limit == 10\n+            assert result.vector_space.size == 0\n+            assert result.vector_space.limit == 5\n+            assert result.documents_upload_quota.size == 0\n+            assert result.documents_upload_quota.limit == 50\n+            assert result.annotation_quota_limit.size == 0\n+            assert result.annotation_quota_limit.limit == 10\n+            assert result.knowledge_rate_limit == 10\n+            assert result.docs_processing == \"standard\"\n+\n+            # Verify no enterprise features\n+            assert result.workspace_members.enabled is False\n+            assert result.webapp_copyright_enabled is False\n+\n+    def test_get_knowledge_rate_limit_billing_disabled(\n+        self, db_session_with_containers, mock_external_service_dependencies\n+    ):\n+        \"\"\"\n+        Test knowledge rate limit retrieval when billing is disabled.\n+\n+        This test verifies:\n+        - Proper knowledge rate limit model creation without billing\n+        - Default rate limit configuration\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup billing disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_knowledge_rate_limit(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, KnowledgeRateLimitModel)\n+\n+            # Verify default configuration\n+            assert result.enabled is False\n+            assert result.limit == 10\n+            assert result.subscription_plan == \"\"  # Empty string when billing is disabled\n+\n+            # Verify no billing service calls\n+            mock_external_service_dependencies[\"billing_service\"].get_knowledge_rate_limit.assert_not_called()\n+\n+    def test_get_features_enterprise_only(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval with enterprise enabled but billing disabled.\n+\n+        This test verifies:\n+        - Proper feature model creation with enterprise only\n+        - Correct enterprise service integration\n+        - Proper workspace member handling\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup enterprise only mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = False\n+            mock_config.ENTERPRISE_ENABLED = True\n+            mock_config.CAN_REPLACE_LOGO = False\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = False\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            tenant_id = self._create_test_tenant_id()\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(tenant_id)\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, FeatureModel)\n+\n+            # Verify billing is disabled\n+            assert result.billing.enabled is False\n+\n+            # Verify enterprise features\n+            assert result.webapp_copyright_enabled is True\n+\n+            # Verify workspace members from enterprise\n+            assert result.workspace_members.enabled is True\n+            assert result.workspace_members.size == 5\n+            assert result.workspace_members.limit == 10\n+\n+            # Verify environment-based features\n+            assert result.can_replace_logo is False\n+            assert result.model_load_balancing_enabled is False\n+            assert result.dataset_operator_enabled is False\n+            assert result.education.enabled is False\n+\n+            # Verify default limitations\n+            assert result.members.size == 0\n+            assert result.members.limit == 1\n+            assert result.apps.size == 0\n+            assert result.apps.limit == 10\n+            assert result.vector_space.size == 0\n+            assert result.vector_space.limit == 5\n+\n+            # Verify mock interactions\n+            mock_external_service_dependencies[\"enterprise_service\"].get_workspace_info.assert_called_once_with(\n+                tenant_id\n+            )\n+            mock_external_service_dependencies[\"billing_service\"].get_info.assert_not_called()\n+\n+    def test_get_system_features_enterprise_disabled(\n+        self, db_session_with_containers, mock_external_service_dependencies\n+    ):\n+        \"\"\"\n+        Test system features retrieval when enterprise is disabled.\n+\n+        This test verifies:\n+        - Proper system feature model creation without enterprise\n+        - Correct environment variable handling\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup enterprise disabled mock\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.MARKETPLACE_ENABLED = True\n+            mock_config.ENABLE_EMAIL_CODE_LOGIN = False\n+            mock_config.ENABLE_EMAIL_PASSWORD_LOGIN = True\n+            mock_config.ENABLE_SOCIAL_OAUTH_LOGIN = True\n+            mock_config.ALLOW_REGISTER = False\n+            mock_config.ALLOW_CREATE_WORKSPACE = False\n+            mock_config.MAIL_TYPE = None\n+            mock_config.PLUGIN_MAX_PACKAGE_SIZE = 50\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_system_features()\n+\n+            # Assert: Verify the expected outcomes\n+            assert result is not None\n+            assert isinstance(result, SystemFeatureModel)\n+\n+            # Verify enterprise features are disabled\n+            assert result.branding.enabled is False\n+            assert result.webapp_auth.enabled is False\n+            assert result.enable_change_email is True\n+\n+            # Verify authentication settings from config\n+            assert result.enable_email_code_login is False\n+            assert result.enable_email_password_login is True\n+            assert result.enable_social_oauth_login is True\n+            assert result.is_allow_register is False\n+            assert result.is_allow_create_workspace is False\n+            assert result.is_email_setup is False\n+\n+            # Verify marketplace configuration\n+            assert result.enable_marketplace is True\n+\n+            # Verify plugin package size (uses default value from dify_config)\n+            assert result.max_plugin_package_size == 15728640\n+\n+            # Verify default license status\n+            assert result.license.status.value == \"none\"\n+            assert result.license.expired_at == \"\"\n+            assert result.license.workspaces.enabled is False\n+\n+            # Verify no enterprise service calls\n+            mock_external_service_dependencies[\"enterprise_service\"].get_info.assert_not_called()\n+\n+    def test_get_features_no_tenant_id(self, db_session_with_containers, mock_external_service_dependencies):\n+        \"\"\"\n+        Test feature retrieval without tenant ID (billing disabled).\n+\n+        This test verifies:\n+        - Proper feature model creation without tenant ID\n+        - Correct handling when billing is disabled\n+        - Default configuration values\n+        - Return value correctness and structure\n+        \"\"\"\n+        # Arrange: Setup no tenant ID scenario\n+        with patch(\"services.feature_service.dify_config\") as mock_config:\n+            mock_config.BILLING_ENABLED = True\n+            mock_config.ENTERPRISE_ENABLED = False\n+            mock_config.CAN_REPLACE_LOGO = True\n+            mock_config.MODEL_LB_ENABLED = False\n+            mock_config.DATASET_OPERATOR_ENABLED = True\n+            mock_config.EDUCATION_ENABLED = False\n+\n+            # Act: Execute the method under test\n+            result = FeatureService.get_features(\"\")",
        "comment_created_at": "2025-08-17T05:20:06+00:00",
        "comment_author": "NeatGuyCoding",
        "comment_body": "Seems reasonable",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2097405967",
    "pr_number": 19980,
    "pr_file": "api/extensions/ext_login.py",
    "created_at": "2025-05-20T08:53:36+00:00",
    "commented_code": "@login_manager.request_loader\n def load_user_from_request(request_from_flask_login):\n     \"\"\"Load user based on the request.\"\"\"\n-    if request.blueprint not in {\"console\", \"inner_api\"}:\n-        return None\n-    # Check if the user_id contains a dot, indicating the old format\n     auth_header = request.headers.get(\"Authorization\", \"\")\n-    if not auth_header:\n-        auth_token = request.args.get(\"_token\")\n-        if not auth_token:\n-            raise Unauthorized(\"Invalid Authorization token.\")\n-    else:\n+    if auth_header:\n         if \" \" not in auth_header:\n             raise Unauthorized(\"Invalid Authorization header format. Expected 'Bearer <api-key>' format.\")\n-        auth_scheme, auth_token = auth_header.split(None, 1)\n+        auth_scheme, auth_token = auth_header.split(maxsplit=1)\n         auth_scheme = auth_scheme.lower()\n         if auth_scheme != \"bearer\":\n             raise Unauthorized(\"Invalid Authorization header format. Expected 'Bearer <api-key>' format.\")\n+    else:\n+        auth_token = request.args.get(\"_token\")\n \n-    decoded = PassportService().verify(auth_token)\n-    user_id = decoded.get(\"user_id\")\n+    if request.blueprint in {\"console\", \"inner_api\"}:\n+        if not auth_token:\n+            raise Unauthorized(\"Invalid Authorization token.\")\n+        decoded = PassportService().verify(auth_token)\n+        user_id = decoded.get(\"user_id\")\n \n-    logged_in_account = AccountService.load_logged_in_account(account_id=user_id)\n-    return logged_in_account\n+        logged_in_account = AccountService.load_logged_in_account(account_id=user_id)",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2097405967",
        "repo_full_name": "langgenius/dify",
        "pr_number": 19980,
        "pr_file": "api/extensions/ext_login.py",
        "discussion_id": "2097405967",
        "commented_code": "@@ -17,34 +20,41 @@\n @login_manager.request_loader\n def load_user_from_request(request_from_flask_login):\n     \"\"\"Load user based on the request.\"\"\"\n-    if request.blueprint not in {\"console\", \"inner_api\"}:\n-        return None\n-    # Check if the user_id contains a dot, indicating the old format\n     auth_header = request.headers.get(\"Authorization\", \"\")\n-    if not auth_header:\n-        auth_token = request.args.get(\"_token\")\n-        if not auth_token:\n-            raise Unauthorized(\"Invalid Authorization token.\")\n-    else:\n+    if auth_header:\n         if \" \" not in auth_header:\n             raise Unauthorized(\"Invalid Authorization header format. Expected 'Bearer <api-key>' format.\")\n-        auth_scheme, auth_token = auth_header.split(None, 1)\n+        auth_scheme, auth_token = auth_header.split(maxsplit=1)\n         auth_scheme = auth_scheme.lower()\n         if auth_scheme != \"bearer\":\n             raise Unauthorized(\"Invalid Authorization header format. Expected 'Bearer <api-key>' format.\")\n+    else:\n+        auth_token = request.args.get(\"_token\")\n \n-    decoded = PassportService().verify(auth_token)\n-    user_id = decoded.get(\"user_id\")\n+    if request.blueprint in {\"console\", \"inner_api\"}:\n+        if not auth_token:\n+            raise Unauthorized(\"Invalid Authorization token.\")\n+        decoded = PassportService().verify(auth_token)\n+        user_id = decoded.get(\"user_id\")\n \n-    logged_in_account = AccountService.load_logged_in_account(account_id=user_id)\n-    return logged_in_account\n+        logged_in_account = AccountService.load_logged_in_account(account_id=user_id)",
        "comment_created_at": "2025-05-20T08:53:36+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": "I'm wondering if we should check the emptiness of `user_id` here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2018518019",
    "pr_number": 15049,
    "pr_file": "api/configs/middleware/__init__.py",
    "created_at": "2025-03-28T11:46:42+00:00",
    "commented_code": "RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default_factory=lambda: NonNegativeInt(str(os.cpu_count())),",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2018518019",
        "repo_full_name": "langgenius/dify",
        "pr_number": 15049,
        "pr_file": "api/configs/middleware/__init__.py",
        "discussion_id": "2018518019",
        "commented_code": "@@ -171,7 +171,7 @@ def SQLALCHEMY_DATABASE_URI(self) -> str:\n \n     RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default_factory=lambda: NonNegativeInt(str(os.cpu_count())),",
        "comment_created_at": "2025-03-28T11:46:42+00:00",
        "comment_author": "Viicos",
        "comment_body": "`NonNegativeInt` is defined as an annotated form:\r\n\r\n```python\r\nNonNegativeInt = Annotated[int, annotated_types.Ge(0)]\r\n```\r\n\r\nSo in theory this shouldn't be necessary?",
        "pr_file_module": null
      },
      {
        "comment_id": "2027131326",
        "repo_full_name": "langgenius/dify",
        "pr_number": 15049,
        "pr_file": "api/configs/middleware/__init__.py",
        "discussion_id": "2018518019",
        "commented_code": "@@ -171,7 +171,7 @@ def SQLALCHEMY_DATABASE_URI(self) -> str:\n \n     RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default_factory=lambda: NonNegativeInt(str(os.cpu_count())),",
        "comment_created_at": "2025-04-03T14:27:32+00:00",
        "comment_author": "bowenliang123",
        "comment_body": "Yes, but all the changes are minimum required changes for passing the type checks.",
        "pr_file_module": null
      },
      {
        "comment_id": "2027219483",
        "repo_full_name": "langgenius/dify",
        "pr_number": 15049,
        "pr_file": "api/configs/middleware/__init__.py",
        "discussion_id": "2018518019",
        "commented_code": "@@ -171,7 +171,7 @@ def SQLALCHEMY_DATABASE_URI(self) -> str:\n \n     RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default_factory=lambda: NonNegativeInt(str(os.cpu_count())),",
        "comment_created_at": "2025-04-03T15:08:31+00:00",
        "comment_author": "bowenliang123",
        "comment_body": "Oh, I checked again the errors from pymy. Changed to use `default=os.cpu_count() or 4,` in this case. The violation does not come from type wrapper , but form the optional None from `os_count()` instead. Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2046314321",
    "pr_number": 15049,
    "pr_file": "api/configs/middleware/__init__.py",
    "created_at": "2025-04-16T07:48:52+00:00",
    "commented_code": "RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default=os.cpu_count() or 8,",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2046314321",
        "repo_full_name": "langgenius/dify",
        "pr_number": 15049,
        "pr_file": "api/configs/middleware/__init__.py",
        "discussion_id": "2046314321",
        "commented_code": "@@ -171,7 +171,7 @@ def SQLALCHEMY_DATABASE_URI(self) -> str:\n \n     RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default=os.cpu_count() or 8,",
        "comment_created_at": "2025-04-16T07:48:52+00:00",
        "comment_author": "laipz8200",
        "comment_body": "why use 8 here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2046403385",
        "repo_full_name": "langgenius/dify",
        "pr_number": 15049,
        "pr_file": "api/configs/middleware/__init__.py",
        "discussion_id": "2046314321",
        "commented_code": "@@ -171,7 +171,7 @@ def SQLALCHEMY_DATABASE_URI(self) -> str:\n \n     RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default=os.cpu_count() or 8,",
        "comment_created_at": "2025-04-16T08:37:42+00:00",
        "comment_author": "bowenliang123",
        "comment_body": "The `os.cpu_count()` returns `Optional[int]` which violates `mypy` type checks for NonNegativeInt. Adding an default int to pass the checks. In general most cases , `os.cpu_count()` does return valid int and it woun't fall to the default value.\r\n\r\n```\r\nconfigs/middleware/__init__.py:172: error: Incompatible types in assignment (expression has type \"int | None\", variable has type \"int\")  [assignment]\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2048877348",
        "repo_full_name": "langgenius/dify",
        "pr_number": 15049,
        "pr_file": "api/configs/middleware/__init__.py",
        "discussion_id": "2046314321",
        "commented_code": "@@ -171,7 +171,7 @@ def SQLALCHEMY_DATABASE_URI(self) -> str:\n \n     RETRIEVAL_SERVICE_EXECUTORS: NonNegativeInt = Field(\n         description=\"Number of processes for the retrieval service, default to CPU cores.\",\n-        default=os.cpu_count(),\n+        default=os.cpu_count() or 8,",
        "comment_created_at": "2025-04-17T12:52:33+00:00",
        "comment_author": "bowenliang123",
        "comment_body": "Changed the default value to 1. Solved.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983999037",
    "pr_number": 14271,
    "pr_file": "api/services/workflow_app_service.py",
    "created_at": "2025-03-06T20:20:36+00:00",
    "commented_code": "import uuid\n+from datetime import datetime\n \n-from flask_sqlalchemy.pagination import Pagination\n-from sqlalchemy import and_, or_\n+from sqlalchemy import and_, func, or_, select\n+from sqlalchemy.orm import Session\n \n-from extensions.ext_database import db\n from models import App, EndUser, WorkflowAppLog, WorkflowRun\n from models.enums import CreatedByRole\n from models.workflow import WorkflowRunStatus\n \n \n class WorkflowAppService:\n-    def get_paginate_workflow_app_logs(self, app_model: App, args: dict) -> Pagination:\n+    def get_paginate_workflow_app_logs(\n+        self,\n+        *,\n+        session: Session,\n+        app_model: App,\n+        keyword: str | None = None,\n+        status: WorkflowRunStatus | None = None,\n+        created_at_before: datetime | None = None,\n+        created_at_after: datetime | None = None,\n+        page: int = 1,\n+        limit: int = 20,\n+    ) -> dict:\n         \"\"\"\n-        Get paginate workflow app logs\n-        :param app: app model\n-        :param args: request args\n-        :return:\n+        Get paginate workflow app logs using SQLAlchemy 2.0 style\n+        :param session: SQLAlchemy session\n+        :param app_model: app model\n+        :param keyword: search keyword\n+        :param status: filter by status\n+        :param created_at_before: filter logs created before this timestamp\n+        :param created_at_after: filter logs created after this timestamp\n+        :param page: page number\n+        :param limit: items per page\n+        :return: Pagination object\n         \"\"\"\n-        query = db.select(WorkflowAppLog).where(\n+        # Build base statement using SQLAlchemy 2.0 style\n+        stmt = select(WorkflowAppLog).where(\n             WorkflowAppLog.tenant_id == app_model.tenant_id, WorkflowAppLog.app_id == app_model.id\n         )\n \n-        status = WorkflowRunStatus.value_of(args.get(\"status\", \"\")) if args.get(\"status\") else None\n-        keyword = args[\"keyword\"]\n         if keyword or status:\n-            query = query.join(WorkflowRun, WorkflowRun.id == WorkflowAppLog.workflow_run_id)\n+            stmt = stmt.join(WorkflowRun, WorkflowRun.id == WorkflowAppLog.workflow_run_id)\n \n         if keyword:\n             keyword_like_val = f\"%{keyword[:30].encode('unicode_escape').decode('utf-8')}%\".replace(r\"\\u\", r\"\\\\u\")",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "1983999037",
        "repo_full_name": "langgenius/dify",
        "pr_number": 14271,
        "pr_file": "api/services/workflow_app_service.py",
        "discussion_id": "1983999037",
        "commented_code": "@@ -1,30 +1,46 @@\n import uuid\n+from datetime import datetime\n \n-from flask_sqlalchemy.pagination import Pagination\n-from sqlalchemy import and_, or_\n+from sqlalchemy import and_, func, or_, select\n+from sqlalchemy.orm import Session\n \n-from extensions.ext_database import db\n from models import App, EndUser, WorkflowAppLog, WorkflowRun\n from models.enums import CreatedByRole\n from models.workflow import WorkflowRunStatus\n \n \n class WorkflowAppService:\n-    def get_paginate_workflow_app_logs(self, app_model: App, args: dict) -> Pagination:\n+    def get_paginate_workflow_app_logs(\n+        self,\n+        *,\n+        session: Session,\n+        app_model: App,\n+        keyword: str | None = None,\n+        status: WorkflowRunStatus | None = None,\n+        created_at_before: datetime | None = None,\n+        created_at_after: datetime | None = None,\n+        page: int = 1,\n+        limit: int = 20,\n+    ) -> dict:\n         \"\"\"\n-        Get paginate workflow app logs\n-        :param app: app model\n-        :param args: request args\n-        :return:\n+        Get paginate workflow app logs using SQLAlchemy 2.0 style\n+        :param session: SQLAlchemy session\n+        :param app_model: app model\n+        :param keyword: search keyword\n+        :param status: filter by status\n+        :param created_at_before: filter logs created before this timestamp\n+        :param created_at_after: filter logs created after this timestamp\n+        :param page: page number\n+        :param limit: items per page\n+        :return: Pagination object\n         \"\"\"\n-        query = db.select(WorkflowAppLog).where(\n+        # Build base statement using SQLAlchemy 2.0 style\n+        stmt = select(WorkflowAppLog).where(\n             WorkflowAppLog.tenant_id == app_model.tenant_id, WorkflowAppLog.app_id == app_model.id\n         )\n \n-        status = WorkflowRunStatus.value_of(args.get(\"status\", \"\")) if args.get(\"status\") else None\n-        keyword = args[\"keyword\"]\n         if keyword or status:\n-            query = query.join(WorkflowRun, WorkflowRun.id == WorkflowAppLog.workflow_run_id)\n+            stmt = stmt.join(WorkflowRun, WorkflowRun.id == WorkflowAppLog.workflow_run_id)\n \n         if keyword:\n             keyword_like_val = f\"%{keyword[:30].encode('unicode_escape').decode('utf-8')}%\".replace(r\"\\u\", r\"\\\\u\")",
        "comment_created_at": "2025-03-06T20:20:36+00:00",
        "comment_author": "aiswaryasankarwork",
        "comment_body": "The `keyword` parameter is used without checking if it exists, which could raise a `KeyError` when accessing `keyword[:30]` if `keyword` is `None`.\n<!-- suggestion_start -->\n\n<details>\n<summary><strong>\ud83d\udcdd Committable Code Suggestion</strong></summary>\n\n> \u203c\ufe0f Ensure you review the code suggestion before committing it to the branch. Make sure it replaces the highlighted code, contains no missing lines, and has no issues with indentation. \n\n\n```suggestion\n        if keyword and isinstance(keyword, str):\n            keyword_like_val = f\"%{keyword[:30].encode('unicode_escape').decode('utf-8')}%\".replace(r\"\\u\", r\"\\\\u\")\n```\n</details>\n<!-- suggestion_end -->\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1986657524",
        "repo_full_name": "langgenius/dify",
        "pr_number": 14271,
        "pr_file": "api/services/workflow_app_service.py",
        "discussion_id": "1983999037",
        "commented_code": "@@ -1,30 +1,46 @@\n import uuid\n+from datetime import datetime\n \n-from flask_sqlalchemy.pagination import Pagination\n-from sqlalchemy import and_, or_\n+from sqlalchemy import and_, func, or_, select\n+from sqlalchemy.orm import Session\n \n-from extensions.ext_database import db\n from models import App, EndUser, WorkflowAppLog, WorkflowRun\n from models.enums import CreatedByRole\n from models.workflow import WorkflowRunStatus\n \n \n class WorkflowAppService:\n-    def get_paginate_workflow_app_logs(self, app_model: App, args: dict) -> Pagination:\n+    def get_paginate_workflow_app_logs(\n+        self,\n+        *,\n+        session: Session,\n+        app_model: App,\n+        keyword: str | None = None,\n+        status: WorkflowRunStatus | None = None,\n+        created_at_before: datetime | None = None,\n+        created_at_after: datetime | None = None,\n+        page: int = 1,\n+        limit: int = 20,\n+    ) -> dict:\n         \"\"\"\n-        Get paginate workflow app logs\n-        :param app: app model\n-        :param args: request args\n-        :return:\n+        Get paginate workflow app logs using SQLAlchemy 2.0 style\n+        :param session: SQLAlchemy session\n+        :param app_model: app model\n+        :param keyword: search keyword\n+        :param status: filter by status\n+        :param created_at_before: filter logs created before this timestamp\n+        :param created_at_after: filter logs created after this timestamp\n+        :param page: page number\n+        :param limit: items per page\n+        :return: Pagination object\n         \"\"\"\n-        query = db.select(WorkflowAppLog).where(\n+        # Build base statement using SQLAlchemy 2.0 style\n+        stmt = select(WorkflowAppLog).where(\n             WorkflowAppLog.tenant_id == app_model.tenant_id, WorkflowAppLog.app_id == app_model.id\n         )\n \n-        status = WorkflowRunStatus.value_of(args.get(\"status\", \"\")) if args.get(\"status\") else None\n-        keyword = args[\"keyword\"]\n         if keyword or status:\n-            query = query.join(WorkflowRun, WorkflowRun.id == WorkflowAppLog.workflow_run_id)\n+            stmt = stmt.join(WorkflowRun, WorkflowRun.id == WorkflowAppLog.workflow_run_id)\n \n         if keyword:\n             keyword_like_val = f\"%{keyword[:30].encode('unicode_escape').decode('utf-8')}%\".replace(r\"\\u\", r\"\\\\u\")",
        "comment_created_at": "2025-03-10T06:02:33+00:00",
        "comment_author": "JzoNgKVO",
        "comment_body": "The above situation will not occur in existing UI interactions. Thanks for your review.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1863165236",
    "pr_number": 11212,
    "pr_file": "api/core/tools/tool/tool.py",
    "created_at": "2024-11-29T08:52:20+00:00",
    "commented_code": "\"\"\"\n         return ToolInvokeMessage(type=ToolInvokeMessage.MessageType.TEXT, message=text, save_as=save_as)\n \n-    def create_blob_message(self, blob: bytes, meta: Optional[dict] = None, save_as: str = \"\") -> ToolInvokeMessage:\n+    def create_blob_message(self, blob: bytes, meta: dict = {}, save_as: str = \"\") -> ToolInvokeMessage:",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "1863165236",
        "repo_full_name": "langgenius/dify",
        "pr_number": 11212,
        "pr_file": "api/core/tools/tool/tool.py",
        "discussion_id": "1863165236",
        "commented_code": "@@ -317,7 +317,7 @@ def create_text_message(self, text: str, save_as: str = \"\") -> ToolInvokeMessage\n         \"\"\"\n         return ToolInvokeMessage(type=ToolInvokeMessage.MessageType.TEXT, message=text, save_as=save_as)\n \n-    def create_blob_message(self, blob: bytes, meta: Optional[dict] = None, save_as: str = \"\") -> ToolInvokeMessage:\n+    def create_blob_message(self, blob: bytes, meta: dict = {}, save_as: str = \"\") -> ToolInvokeMessage:",
        "comment_created_at": "2024-11-29T08:52:20+00:00",
        "comment_author": "laipz8200",
        "comment_body": "Please avoid using this way, we can add this check in the function body:\r\n\r\n```python\r\nmeta = meta or {}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1849412272",
    "pr_number": 10877,
    "pr_file": "api/core/tools/provider/builtin/rapidapi/tools/google_news.py",
    "created_at": "2024-11-20T02:25:05+00:00",
    "commented_code": "+from typing import Any, Union\n+\n+import requests\n+from core.tools.entities.tool_entities import ToolInvokeMessage\n+from core.tools.errors import ToolInvokeError, ToolProviderCredentialValidationError\n+from core.tools.tool.builtin_tool import BuiltinTool\n+\n+\n+class GooglenewsTool(BuiltinTool):\n+    def _invoke(\n+            self,\n+            user_id: str,\n+            tool_parameters: dict[str, Any],\n+    ) -> Union[ToolInvokeMessage, list[ToolInvokeMessage]]:\n+        \"\"\"\n+        invoke tools\n+        \"\"\"\n+        key = self.runtime.credentials.get(\"x-rapidapi-key\",\"\")\n+        host = self.runtime.credentials.get(\"x-rapidapi-host\",\"\")\n+        if not key or key is None or host is None or not host:",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "1849412272",
        "repo_full_name": "langgenius/dify",
        "pr_number": 10877,
        "pr_file": "api/core/tools/provider/builtin/rapidapi/tools/google_news.py",
        "discussion_id": "1849412272",
        "commented_code": "@@ -0,0 +1,36 @@\n+from typing import Any, Union\n+\n+import requests\n+from core.tools.entities.tool_entities import ToolInvokeMessage\n+from core.tools.errors import ToolInvokeError, ToolProviderCredentialValidationError\n+from core.tools.tool.builtin_tool import BuiltinTool\n+\n+\n+class GooglenewsTool(BuiltinTool):\n+    def _invoke(\n+            self,\n+            user_id: str,\n+            tool_parameters: dict[str, Any],\n+    ) -> Union[ToolInvokeMessage, list[ToolInvokeMessage]]:\n+        \"\"\"\n+        invoke tools\n+        \"\"\"\n+        key = self.runtime.credentials.get(\"x-rapidapi-key\",\"\")\n+        host = self.runtime.credentials.get(\"x-rapidapi-host\",\"\")\n+        if not key or key is None or host is None or not host:",
        "comment_created_at": "2024-11-20T02:25:05+00:00",
        "comment_author": "yihong0618",
        "comment_body": "better:\r\n```python\r\nif not key or not host:\r\n```\r\nor\r\n```\r\nif not all([key, host])\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1849428099",
        "repo_full_name": "langgenius/dify",
        "pr_number": 10877,
        "pr_file": "api/core/tools/provider/builtin/rapidapi/tools/google_news.py",
        "discussion_id": "1849412272",
        "commented_code": "@@ -0,0 +1,36 @@\n+from typing import Any, Union\n+\n+import requests\n+from core.tools.entities.tool_entities import ToolInvokeMessage\n+from core.tools.errors import ToolInvokeError, ToolProviderCredentialValidationError\n+from core.tools.tool.builtin_tool import BuiltinTool\n+\n+\n+class GooglenewsTool(BuiltinTool):\n+    def _invoke(\n+            self,\n+            user_id: str,\n+            tool_parameters: dict[str, Any],\n+    ) -> Union[ToolInvokeMessage, list[ToolInvokeMessage]]:\n+        \"\"\"\n+        invoke tools\n+        \"\"\"\n+        key = self.runtime.credentials.get(\"x-rapidapi-key\",\"\")\n+        host = self.runtime.credentials.get(\"x-rapidapi-host\",\"\")\n+        if not key or key is None or host is None or not host:",
        "comment_created_at": "2024-11-20T02:50:47+00:00",
        "comment_author": "Tuyohai",
        "comment_body": "Thanks for concise advice!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1849547313",
    "pr_number": 10883,
    "pr_file": "api/services/app_service.py",
    "created_at": "2024-11-20T05:17:30+00:00",
    "commented_code": "model_config: AppModelConfig = app.app_model_config\n             agent_mode = model_config.agent_mode_dict\n             # decrypt agent tool parameters if it's secret-input\n-            for tool in agent_mode.get(\"tools\") or []:\n+            for tool in agent_mode.get(\"tools\", []):",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "1849547313",
        "repo_full_name": "langgenius/dify",
        "pr_number": 10883,
        "pr_file": "api/services/app_service.py",
        "discussion_id": "1849547313",
        "commented_code": "@@ -158,7 +158,7 @@ def get_app(self, app: App) -> App:\n             model_config: AppModelConfig = app.app_model_config\n             agent_mode = model_config.agent_mode_dict\n             # decrypt agent tool parameters if it's secret-input\n-            for tool in agent_mode.get(\"tools\") or []:\n+            for tool in agent_mode.get(\"tools\", []):",
        "comment_created_at": "2024-11-20T05:17:30+00:00",
        "comment_author": "laipz8200",
        "comment_body": "If a dict could originate from a Text or JSON field in the database, now might not be the best time to use the `dict.get(key, default)` pattern.",
        "pr_file_module": null
      },
      {
        "comment_id": "1849558067",
        "repo_full_name": "langgenius/dify",
        "pr_number": 10883,
        "pr_file": "api/services/app_service.py",
        "discussion_id": "1849547313",
        "commented_code": "@@ -158,7 +158,7 @@ def get_app(self, app: App) -> App:\n             model_config: AppModelConfig = app.app_model_config\n             agent_mode = model_config.agent_mode_dict\n             # decrypt agent tool parameters if it's secret-input\n-            for tool in agent_mode.get(\"tools\") or []:\n+            for tool in agent_mode.get(\"tools\", []):",
        "comment_created_at": "2024-11-20T05:32:27+00:00",
        "comment_author": "yihong0618",
        "comment_body": "cool will change that",
        "pr_file_module": null
      }
    ]
  }
]