[
  {
    "discussion_id": "2277467075",
    "pr_number": 23827,
    "pr_file": "api/services/workflow_alias_service.py",
    "created_at": "2025-08-14T18:48:56+00:00",
    "commented_code": "+import logging\n+from typing import TYPE_CHECKING, Optional, Union\n+from uuid import uuid4\n+\n+from sqlalchemy import and_, func, select\n+from sqlalchemy.orm import Session\n+\n+if TYPE_CHECKING:\n+    from sqlalchemy.orm import scoped_session\n+\n+from models import Workflow, WorkflowAlias\n+from models.workflow_alias import AliasType\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class WorkflowAliasService:\n+    def create_alias(",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2277467075",
        "repo_full_name": "langgenius/dify",
        "pr_number": 23827,
        "pr_file": "api/services/workflow_alias_service.py",
        "discussion_id": "2277467075",
        "commented_code": "@@ -0,0 +1,119 @@\n+import logging\n+from typing import TYPE_CHECKING, Optional, Union\n+from uuid import uuid4\n+\n+from sqlalchemy import and_, func, select\n+from sqlalchemy.orm import Session\n+\n+if TYPE_CHECKING:\n+    from sqlalchemy.orm import scoped_session\n+\n+from models import Workflow, WorkflowAlias\n+from models.workflow_alias import AliasType\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class WorkflowAliasService:\n+    def create_alias(",
        "comment_created_at": "2025-08-14T18:48:56+00:00",
        "comment_author": "laipz8200",
        "comment_body": "`create_or_update` is better.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293017675",
    "pr_number": 23700,
    "pr_file": "api/services/workflow_run_service.py",
    "created_at": "2025-08-22T07:59:34+00:00",
    "commented_code": "self,\n         app_model: App,\n         run_id: str,\n-        user: Account | EndUser,\n+        user: Optional[Account | EndUser] = None,\n     ) -> Sequence[WorkflowNodeExecutionModel]:\n         \"\"\"\n         Get workflow run node execution list\n+\n+        :param app_model: app model\n+        :param run_id: workflow run id\n+        :param user: optional user for tenant validation, if None uses app_model.tenant_id",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2293017675",
        "repo_full_name": "langgenius/dify",
        "pr_number": 23700,
        "pr_file": "api/services/workflow_run_service.py",
        "discussion_id": "2293017675",
        "commented_code": "@@ -97,10 +97,14 @@ def get_workflow_run_node_executions(\n         self,\n         app_model: App,\n         run_id: str,\n-        user: Account | EndUser,\n+        user: Optional[Account | EndUser] = None,\n     ) -> Sequence[WorkflowNodeExecutionModel]:\n         \"\"\"\n         Get workflow run node execution list\n+\n+        :param app_model: app model\n+        :param run_id: workflow run id\n+        :param user: optional user for tenant validation, if None uses app_model.tenant_id",
        "comment_created_at": "2025-08-22T07:59:34+00:00",
        "comment_author": "laipz8200",
        "comment_body": "Maybe it's better to change this parameter to `tenant_id`",
        "pr_file_module": null
      },
      {
        "comment_id": "2293057675",
        "repo_full_name": "langgenius/dify",
        "pr_number": 23700,
        "pr_file": "api/services/workflow_run_service.py",
        "discussion_id": "2293017675",
        "commented_code": "@@ -97,10 +97,14 @@ def get_workflow_run_node_executions(\n         self,\n         app_model: App,\n         run_id: str,\n-        user: Account | EndUser,\n+        user: Optional[Account | EndUser] = None,\n     ) -> Sequence[WorkflowNodeExecutionModel]:\n         \"\"\"\n         Get workflow run node execution list\n+\n+        :param app_model: app model\n+        :param run_id: workflow run id\n+        :param user: optional user for tenant validation, if None uses app_model.tenant_id",
        "comment_created_at": "2025-08-22T08:19:33+00:00",
        "comment_author": "JAVA-LW",
        "comment_body": "You are right, I'll make some modifications",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2338592435",
    "pr_number": 25518,
    "pr_file": "api/models/account.py",
    "created_at": "2025-09-11T05:09:49+00:00",
    "commented_code": "@property\n     def is_editor(self):\n+        # TODO: Rename this property to `has_editing_permission`.",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2338592435",
        "repo_full_name": "langgenius/dify",
        "pr_number": 25518,
        "pr_file": "api/models/account.py",
        "discussion_id": "2338592435",
        "commented_code": "@@ -188,6 +188,16 @@ def is_admin(self):\n \n     @property\n     def is_editor(self):\n+        # TODO: Rename this property to `has_editing_permission`.",
        "comment_created_at": "2025-09-11T05:09:49+00:00",
        "comment_author": "Nov1c444",
        "comment_body": "Would it be better to write it this way?\r\n```python\r\nfrom typing_extensions import deprecated\r\n\r\n\r\n@deprecated(reason=\"Use has_editing_permission instead.\")\r\n@property\r\ndef is_editor(self):\r\n    return self.has_editing_permission\r\n\r\n\r\n@property\r\ndef has_editing_permission(self):\r\n    return TenantAccountRole.is_editing_role(self.role)\r\n\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2338654525",
        "repo_full_name": "langgenius/dify",
        "pr_number": 25518,
        "pr_file": "api/models/account.py",
        "discussion_id": "2338592435",
        "commented_code": "@@ -188,6 +188,16 @@ def is_admin(self):\n \n     @property\n     def is_editor(self):\n+        # TODO: Rename this property to `has_editing_permission`.",
        "comment_created_at": "2025-09-11T05:40:20+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": "Sounds good.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2262159449",
    "pr_number": 23605,
    "pr_file": "api/controllers/console/workspace/tool_providers.py",
    "created_at": "2025-08-08T07:28:08+00:00",
    "commented_code": "parser.add_argument(\"icon_type\", type=str, required=True, nullable=False, location=\"json\")\n         parser.add_argument(\"icon_background\", type=str, required=False, nullable=True, location=\"json\", default=\"\")\n         parser.add_argument(\"server_identifier\", type=str, required=True, nullable=False, location=\"json\")\n+        parser.add_argument(\"timeout\", type=float, required=False, nullable=False, location=\"json\", default=30)\n+        parser.add_argument(\n+            \"sse_read_timeout\", type=float, required=False, nullable=False, location=\"json\", default=300",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2262159449",
        "repo_full_name": "langgenius/dify",
        "pr_number": 23605,
        "pr_file": "api/controllers/console/workspace/tool_providers.py",
        "discussion_id": "2262159449",
        "commented_code": "@@ -862,6 +862,10 @@ def post(self):\n         parser.add_argument(\"icon_type\", type=str, required=True, nullable=False, location=\"json\")\n         parser.add_argument(\"icon_background\", type=str, required=False, nullable=True, location=\"json\", default=\"\")\n         parser.add_argument(\"server_identifier\", type=str, required=True, nullable=False, location=\"json\")\n+        parser.add_argument(\"timeout\", type=float, required=False, nullable=False, location=\"json\", default=30)\n+        parser.add_argument(\n+            \"sse_read_timeout\", type=float, required=False, nullable=False, location=\"json\", default=300",
        "comment_created_at": "2025-08-08T07:28:08+00:00",
        "comment_author": "Nov1c444",
        "comment_body": "Maybe timeout_seconds is a better naming choice.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2262345117",
        "repo_full_name": "langgenius/dify",
        "pr_number": 23605,
        "pr_file": "api/controllers/console/workspace/tool_providers.py",
        "discussion_id": "2262159449",
        "commented_code": "@@ -862,6 +862,10 @@ def post(self):\n         parser.add_argument(\"icon_type\", type=str, required=True, nullable=False, location=\"json\")\n         parser.add_argument(\"icon_background\", type=str, required=False, nullable=True, location=\"json\", default=\"\")\n         parser.add_argument(\"server_identifier\", type=str, required=True, nullable=False, location=\"json\")\n+        parser.add_argument(\"timeout\", type=float, required=False, nullable=False, location=\"json\", default=30)\n+        parser.add_argument(\n+            \"sse_read_timeout\", type=float, required=False, nullable=False, location=\"json\", default=300",
        "comment_created_at": "2025-08-08T08:51:58+00:00",
        "comment_author": "IthacaDream",
        "comment_body": "> Maybe timeout_seconds is a better naming choice.\r\n\r\nI think either is fine. If you insist, I will make the changes.  However, it should be noted that other places all called `\u201ctime\u201d`, especially in previous `MCPClient` 's definition. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149505140",
    "pr_number": 21061,
    "pr_file": "api/core/helper/flask_context.py",
    "created_at": "2025-06-16T09:38:25+00:00",
    "commented_code": "+import contextvars\n+from collections.abc import Iterator\n+from contextlib import contextmanager\n+from typing import TypeVar\n+\n+from flask import Flask, g, has_request_context\n+\n+T = TypeVar(\"T\")\n+\n+\n+@contextmanager\n+def flask_context_manager(",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2149505140",
        "repo_full_name": "langgenius/dify",
        "pr_number": 21061,
        "pr_file": "api/core/helper/flask_context.py",
        "discussion_id": "2149505140",
        "commented_code": "@@ -0,0 +1,65 @@\n+import contextvars\n+from collections.abc import Iterator\n+from contextlib import contextmanager\n+from typing import TypeVar\n+\n+from flask import Flask, g, has_request_context\n+\n+T = TypeVar(\"T\")\n+\n+\n+@contextmanager\n+def flask_context_manager(",
        "comment_created_at": "2025-06-16T09:38:25+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": " I think it would be better to rename this function to `preserve_flask_contexts`. This name more clearly conveys the function's primary purpose of preserving Flask application context and user state across context boundaries.\r\n\r\nBesides,  I strongly recommend adding comprehensive tests for this utility.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086287312",
    "pr_number": 19430,
    "pr_file": "api/core/repositories/sqlalchemy_workflow_node_execution_repository.py",
    "created_at": "2025-05-13T08:52:25+00:00",
    "commented_code": "f\"Invalid session_factory type {type(session_factory).__name__}; expected sessionmaker or Engine\"\n             )\n \n+        # Extract tenant_id from user\n+        tenant_id: str | None = user.tenant_id if isinstance(user, EndUser) else user.current_tenant_id\n+        if not tenant_id:\n+            raise ValueError(\"User must have a tenant_id or current_tenant_id\")\n         self._tenant_id = tenant_id\n+\n+        # Store app context\n         self._app_id = app_id\n \n-    def save(self, execution: WorkflowNodeExecution) -> None:\n+        # Extract user context\n+        self._triggered_from = triggered_from\n+        self._created_by = user.id",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2086287312",
        "repo_full_name": "langgenius/dify",
        "pr_number": 19430,
        "pr_file": "api/core/repositories/sqlalchemy_workflow_node_execution_repository.py",
        "discussion_id": "2086287312",
        "commented_code": "@@ -44,38 +66,155 @@ def __init__(self, session_factory: sessionmaker | Engine, tenant_id: str, app_i\n                 f\"Invalid session_factory type {type(session_factory).__name__}; expected sessionmaker or Engine\"\n             )\n \n+        # Extract tenant_id from user\n+        tenant_id: str | None = user.tenant_id if isinstance(user, EndUser) else user.current_tenant_id\n+        if not tenant_id:\n+            raise ValueError(\"User must have a tenant_id or current_tenant_id\")\n         self._tenant_id = tenant_id\n+\n+        # Store app context\n         self._app_id = app_id\n \n-    def save(self, execution: WorkflowNodeExecution) -> None:\n+        # Extract user context\n+        self._triggered_from = triggered_from\n+        self._created_by = user.id",
        "comment_created_at": "2025-05-13T08:52:25+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": "I recommend renaming `_created_by` to `_creator_user_id` for clarity.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2086287996",
    "pr_number": 19430,
    "pr_file": "api/core/repositories/sqlalchemy_workflow_node_execution_repository.py",
    "created_at": "2025-05-13T08:52:46+00:00",
    "commented_code": "f\"Invalid session_factory type {type(session_factory).__name__}; expected sessionmaker or Engine\"\n             )\n \n+        # Extract tenant_id from user\n+        tenant_id: str | None = user.tenant_id if isinstance(user, EndUser) else user.current_tenant_id\n+        if not tenant_id:\n+            raise ValueError(\"User must have a tenant_id or current_tenant_id\")\n         self._tenant_id = tenant_id\n+\n+        # Store app context\n         self._app_id = app_id\n \n-    def save(self, execution: WorkflowNodeExecution) -> None:\n+        # Extract user context\n+        self._triggered_from = triggered_from\n+        self._created_by = user.id\n+\n+        # Determine user role based on user type\n+        self._created_by_role = CreatedByRole.ACCOUNT if isinstance(user, Account) else CreatedByRole.END_USER",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2086287996",
        "repo_full_name": "langgenius/dify",
        "pr_number": 19430,
        "pr_file": "api/core/repositories/sqlalchemy_workflow_node_execution_repository.py",
        "discussion_id": "2086287996",
        "commented_code": "@@ -44,38 +66,155 @@ def __init__(self, session_factory: sessionmaker | Engine, tenant_id: str, app_i\n                 f\"Invalid session_factory type {type(session_factory).__name__}; expected sessionmaker or Engine\"\n             )\n \n+        # Extract tenant_id from user\n+        tenant_id: str | None = user.tenant_id if isinstance(user, EndUser) else user.current_tenant_id\n+        if not tenant_id:\n+            raise ValueError(\"User must have a tenant_id or current_tenant_id\")\n         self._tenant_id = tenant_id\n+\n+        # Store app context\n         self._app_id = app_id\n \n-    def save(self, execution: WorkflowNodeExecution) -> None:\n+        # Extract user context\n+        self._triggered_from = triggered_from\n+        self._created_by = user.id\n+\n+        # Determine user role based on user type\n+        self._created_by_role = CreatedByRole.ACCOUNT if isinstance(user, Account) else CreatedByRole.END_USER",
        "comment_created_at": "2025-05-13T08:52:46+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": "I recommend renaming `_created_by_role` to `_creator_user_role` for clarity.",
        "pr_file_module": null
      },
      {
        "comment_id": "2088194842",
        "repo_full_name": "langgenius/dify",
        "pr_number": 19430,
        "pr_file": "api/core/repositories/sqlalchemy_workflow_node_execution_repository.py",
        "discussion_id": "2086287996",
        "commented_code": "@@ -44,38 +66,155 @@ def __init__(self, session_factory: sessionmaker | Engine, tenant_id: str, app_i\n                 f\"Invalid session_factory type {type(session_factory).__name__}; expected sessionmaker or Engine\"\n             )\n \n+        # Extract tenant_id from user\n+        tenant_id: str | None = user.tenant_id if isinstance(user, EndUser) else user.current_tenant_id\n+        if not tenant_id:\n+            raise ValueError(\"User must have a tenant_id or current_tenant_id\")\n         self._tenant_id = tenant_id\n+\n+        # Store app context\n         self._app_id = app_id\n \n-    def save(self, execution: WorkflowNodeExecution) -> None:\n+        # Extract user context\n+        self._triggered_from = triggered_from\n+        self._created_by = user.id\n+\n+        # Determine user role based on user type\n+        self._created_by_role = CreatedByRole.ACCOUNT if isinstance(user, Account) else CreatedByRole.END_USER",
        "comment_created_at": "2025-05-14T06:58:05+00:00",
        "comment_author": "laipz8200",
        "comment_body": "Done. I also renamed the enum.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2046311142",
    "pr_number": 18026,
    "pr_file": "api/core/repository/workflow_node_execution_repository.py",
    "created_at": "2025-04-16T07:47:52+00:00",
    "commented_code": "+from collections.abc import Sequence\n+from datetime import datetime\n+from typing import Literal, Optional, Protocol, TypedDict\n+\n+from models.workflow import WorkflowNodeExecution\n+\n+\n+class WorkflowNodeExecutionCriteria(TypedDict, total=False):\n+    \"\"\"Criteria for filtering WorkflowNodeExecution instances.\"\"\"\n+\n+    workflow_run_id: str\n+    node_execution_id: str\n+    created_at_before: datetime\n+    created_at_after: datetime\n+    status: str\n+\n+\n+class WorkflowNodeExecutionRepository(Protocol):\n+    \"\"\"\n+    Repository interface for WorkflowNodeExecution.\n+\n+    This interface defines the contract for accessing and manipulating\n+    WorkflowNodeExecution data, regardless of the underlying storage mechanism.\n+\n+    Note: Domain-specific concepts like multi-tenancy (tenant_id), application context (app_id),\n+    and trigger sources (triggered_from) should be handled at the implementation level, not in\n+    the core interface. This keeps the core domain model clean and independent of specific\n+    application domains or deployment scenarios.\n+    \"\"\"\n+\n+    def save(self, execution: WorkflowNodeExecution) -> None:\n+        \"\"\"\n+        Save a WorkflowNodeExecution instance.\n+\n+        Args:\n+            execution: The WorkflowNodeExecution instance to save\n+        \"\"\"\n+        ...\n+\n+    # Method get_by_id was removed as it's not used anywhere in the codebase\n+\n+    def get_by_node_execution_id(self, node_execution_id: str) -> Optional[WorkflowNodeExecution]:\n+        \"\"\"\n+        Retrieve a WorkflowNodeExecution by its node_execution_id.\n+\n+        Args:\n+            node_execution_id: The node execution ID\n+\n+        Returns:\n+            The WorkflowNodeExecution instance if found, None otherwise\n+        \"\"\"\n+        ...\n+\n+    def get_by_workflow_run(\n+        self,\n+        workflow_run_id: str,\n+        order_by: Optional[str] = None,\n+        order_direction: Optional[Literal[\"asc\", \"desc\"]] = None,\n+    ) -> Sequence[WorkflowNodeExecution]:\n+        \"\"\"\n+        Retrieve all WorkflowNodeExecution instances for a specific workflow run.\n+\n+        Args:\n+            workflow_run_id: The workflow run ID\n+            order_by: Optional field to order by (e.g., \"index\", \"created_at\")\n+            order_direction: Optional direction to order (\"asc\" or \"desc\")\n+\n+        Returns:\n+            A list of WorkflowNodeExecution instances\n+        \"\"\"\n+        ...\n+\n+    def get_running_executions(self, workflow_run_id: str) -> Sequence[WorkflowNodeExecution]:",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2046311142",
        "repo_full_name": "langgenius/dify",
        "pr_number": 18026,
        "pr_file": "api/core/repository/workflow_node_execution_repository.py",
        "discussion_id": "2046311142",
        "commented_code": "@@ -0,0 +1,126 @@\n+from collections.abc import Sequence\n+from datetime import datetime\n+from typing import Literal, Optional, Protocol, TypedDict\n+\n+from models.workflow import WorkflowNodeExecution\n+\n+\n+class WorkflowNodeExecutionCriteria(TypedDict, total=False):\n+    \"\"\"Criteria for filtering WorkflowNodeExecution instances.\"\"\"\n+\n+    workflow_run_id: str\n+    node_execution_id: str\n+    created_at_before: datetime\n+    created_at_after: datetime\n+    status: str\n+\n+\n+class WorkflowNodeExecutionRepository(Protocol):\n+    \"\"\"\n+    Repository interface for WorkflowNodeExecution.\n+\n+    This interface defines the contract for accessing and manipulating\n+    WorkflowNodeExecution data, regardless of the underlying storage mechanism.\n+\n+    Note: Domain-specific concepts like multi-tenancy (tenant_id), application context (app_id),\n+    and trigger sources (triggered_from) should be handled at the implementation level, not in\n+    the core interface. This keeps the core domain model clean and independent of specific\n+    application domains or deployment scenarios.\n+    \"\"\"\n+\n+    def save(self, execution: WorkflowNodeExecution) -> None:\n+        \"\"\"\n+        Save a WorkflowNodeExecution instance.\n+\n+        Args:\n+            execution: The WorkflowNodeExecution instance to save\n+        \"\"\"\n+        ...\n+\n+    # Method get_by_id was removed as it's not used anywhere in the codebase\n+\n+    def get_by_node_execution_id(self, node_execution_id: str) -> Optional[WorkflowNodeExecution]:\n+        \"\"\"\n+        Retrieve a WorkflowNodeExecution by its node_execution_id.\n+\n+        Args:\n+            node_execution_id: The node execution ID\n+\n+        Returns:\n+            The WorkflowNodeExecution instance if found, None otherwise\n+        \"\"\"\n+        ...\n+\n+    def get_by_workflow_run(\n+        self,\n+        workflow_run_id: str,\n+        order_by: Optional[str] = None,\n+        order_direction: Optional[Literal[\"asc\", \"desc\"]] = None,\n+    ) -> Sequence[WorkflowNodeExecution]:\n+        \"\"\"\n+        Retrieve all WorkflowNodeExecution instances for a specific workflow run.\n+\n+        Args:\n+            workflow_run_id: The workflow run ID\n+            order_by: Optional field to order by (e.g., \"index\", \"created_at\")\n+            order_direction: Optional direction to order (\"asc\" or \"desc\")\n+\n+        Returns:\n+            A list of WorkflowNodeExecution instances\n+        \"\"\"\n+        ...\n+\n+    def get_running_executions(self, workflow_run_id: str) -> Sequence[WorkflowNodeExecution]:",
        "comment_created_at": "2025-04-16T07:47:52+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": "I recommend renaming the `get_running_executions` method to `get_executions_by_run_id`, as this name more accurately reflects its purpose and functionality.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2046762744",
    "pr_number": 18026,
    "pr_file": "api/core/repository/workflow_node_execution_repository.py",
    "created_at": "2025-04-16T11:53:08+00:00",
    "commented_code": "+from collections.abc import Sequence\n+from dataclasses import dataclass\n+from datetime import datetime\n+from typing import Literal, Optional, Protocol, TypedDict\n+\n+from models.workflow import WorkflowNodeExecution\n+\n+\n+@dataclass\n+class OrderConfig:\n+    \"\"\"Configuration for ordering WorkflowNodeExecution instances.\"\"\"\n+\n+    order_by: list[str]\n+    order_direction: Optional[Literal[\"asc\", \"desc\"]] = None\n+\n+\n+class WorkflowNodeExecutionCriteria(TypedDict, total=False):\n+    \"\"\"Criteria for filtering WorkflowNodeExecution instances.\"\"\"\n+\n+    workflow_run_id: str\n+    node_execution_id: str\n+    created_at_before: datetime\n+    created_at_after: datetime",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "2046762744",
        "repo_full_name": "langgenius/dify",
        "pr_number": 18026,
        "pr_file": "api/core/repository/workflow_node_execution_repository.py",
        "discussion_id": "2046762744",
        "commented_code": "@@ -0,0 +1,131 @@\n+from collections.abc import Sequence\n+from dataclasses import dataclass\n+from datetime import datetime\n+from typing import Literal, Optional, Protocol, TypedDict\n+\n+from models.workflow import WorkflowNodeExecution\n+\n+\n+@dataclass\n+class OrderConfig:\n+    \"\"\"Configuration for ordering WorkflowNodeExecution instances.\"\"\"\n+\n+    order_by: list[str]\n+    order_direction: Optional[Literal[\"asc\", \"desc\"]] = None\n+\n+\n+class WorkflowNodeExecutionCriteria(TypedDict, total=False):\n+    \"\"\"Criteria for filtering WorkflowNodeExecution instances.\"\"\"\n+\n+    workflow_run_id: str\n+    node_execution_id: str\n+    created_at_before: datetime\n+    created_at_after: datetime",
        "comment_created_at": "2025-04-16T11:53:08+00:00",
        "comment_author": "QuantumGhost",
        "comment_body": "It looks like the `created_at_after` field in `WorkflowNodeExecutionCriteria` is not currently in use. \nYou might want to consider removing it to simplify the implementation.\n\nAdditionally, I believe renaming `created_at_before` to `created_at_lt` would make its purpose clearer and more concise.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1851497026",
    "pr_number": 10931,
    "pr_file": "api/core/rag/rerank/weight_rerank.py",
    "created_at": "2024-11-21T07:28:30+00:00",
    "commented_code": "unique_documents = []\n         doc_id = set()",
    "repo_full_name": "langgenius/dify",
    "discussion_comments": [
      {
        "comment_id": "1851497026",
        "repo_full_name": "langgenius/dify",
        "pr_number": 10931,
        "pr_file": "api/core/rag/rerank/weight_rerank.py",
        "discussion_id": "1851497026",
        "commented_code": "@@ -39,9 +39,8 @@ def run(\n         unique_documents = []\n         doc_id = set()",
        "comment_created_at": "2024-11-21T07:28:30+00:00",
        "comment_author": "bowenliang123",
        "comment_body": "How about change the name into `doc_ids` to prevent ambiguous usage?",
        "pr_file_module": null
      },
      {
        "comment_id": "1851506311",
        "repo_full_name": "langgenius/dify",
        "pr_number": 10931,
        "pr_file": "api/core/rag/rerank/weight_rerank.py",
        "discussion_id": "1851497026",
        "commented_code": "@@ -39,9 +39,8 @@ def run(\n         unique_documents = []\n         doc_id = set()",
        "comment_created_at": "2024-11-21T07:35:49+00:00",
        "comment_author": "AkisAya",
        "comment_body": "sure, doc_ids is better",
        "pr_file_module": null
      }
    ]
  }
]