[
  {
    "discussion_id": "2289427292",
    "pr_number": 34448,
    "pr_file": "plugins/discourse-ai/lib/embeddings/entry_point.rb",
    "created_at": "2025-08-20T22:20:25+00:00",
    "commented_code": ":discourse_ai,\n           { search: { actions: %w[discourse_ai/embeddings/embeddings#search] } },\n         )\n+\n+        plugin.register_modifier(\n+          :similar_topic_candidate_ids,\n+        ) do |plugin_candidate_ids, title, raw, guardian|\n+          plugin_candidate_ids << DiscourseAi::Embeddings::SemanticSearch.new(\n+            guardian,\n+          ).similar_topic_ids_to([title, raw].join(\"\n\n\"))\n+        end",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2289427292",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34448,
        "pr_file": "plugins/discourse-ai/lib/embeddings/entry_point.rb",
        "discussion_id": "2289427292",
        "commented_code": "@@ -72,6 +72,14 @@ def inject_into(plugin)\n           :discourse_ai,\n           { search: { actions: %w[discourse_ai/embeddings/embeddings#search] } },\n         )\n+\n+        plugin.register_modifier(\n+          :similar_topic_candidate_ids,\n+        ) do |plugin_candidate_ids, title, raw, guardian|\n+          plugin_candidate_ids << DiscourseAi::Embeddings::SemanticSearch.new(\n+            guardian,\n+          ).similar_topic_ids_to([title, raw].join(\"\\n\\n\"))\n+        end",
        "comment_created_at": "2025-08-20T22:20:25+00:00",
        "comment_author": "SamSaffron",
        "comment_body": "plugin_candidate_ids, title, raw, guardian\r\n\r\nsig is off, it should be existing_ids, args\r\n\r\nargs[:candidates] has a relation we could potentially lean on to do a bunch of filtering , that way we only return matches we know are good. (eg category exclusion etc)",
        "pr_file_module": null
      },
      {
        "comment_id": "2291976068",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34448,
        "pr_file": "plugins/discourse-ai/lib/embeddings/entry_point.rb",
        "discussion_id": "2289427292",
        "commented_code": "@@ -72,6 +72,14 @@ def inject_into(plugin)\n           :discourse_ai,\n           { search: { actions: %w[discourse_ai/embeddings/embeddings#search] } },\n         )\n+\n+        plugin.register_modifier(\n+          :similar_topic_candidate_ids,\n+        ) do |plugin_candidate_ids, title, raw, guardian|\n+          plugin_candidate_ids << DiscourseAi::Embeddings::SemanticSearch.new(\n+            guardian,\n+          ).similar_topic_ids_to([title, raw].join(\"\\n\\n\"))\n+        end",
        "comment_created_at": "2025-08-21T19:44:30+00:00",
        "comment_author": "romanrizzi",
        "comment_body": "I updated it to rely on that relation instead of applying the same permission checks again.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1122508193",
    "pr_number": 20494,
    "pr_file": "lib/topic_query.rb",
    "created_at": "2023-03-02T01:27:44+00:00",
    "commented_code": "end\n \n     if status = options[:status]\n-      case status\n-      when \"open\"\n-        result = result.where(\"NOT topics.closed AND NOT topics.archived\")\n-      when \"closed\"\n-        result = result.where(\"topics.closed\")\n-      when \"archived\"\n-        result = result.where(\"topics.archived\")\n-      when \"listed\"\n-        result = result.where(\"topics.visible\")\n-      when \"unlisted\"\n-        result = result.where(\"NOT topics.visible\")\n-      when \"deleted\"\n-        category = Category.find_by(id: options[:category])\n-        if @guardian.can_see_deleted_topics?(category)\n-          result = result.where(\"topics.deleted_at IS NOT NULL\")\n-          require_deleted_clause = false\n-        end\n-      end\n+      options[:q] ||= +\"\"\n+      options[:q] << \" status:#{status}\"",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "1122508193",
        "repo_full_name": "discourse/discourse",
        "pr_number": 20494,
        "pr_file": "lib/topic_query.rb",
        "discussion_id": "1122508193",
        "commented_code": "@@ -836,24 +838,17 @@ def default_results(options = {})\n     end\n \n     if status = options[:status]\n-      case status\n-      when \"open\"\n-        result = result.where(\"NOT topics.closed AND NOT topics.archived\")\n-      when \"closed\"\n-        result = result.where(\"topics.closed\")\n-      when \"archived\"\n-        result = result.where(\"topics.archived\")\n-      when \"listed\"\n-        result = result.where(\"topics.visible\")\n-      when \"unlisted\"\n-        result = result.where(\"NOT topics.visible\")\n-      when \"deleted\"\n-        category = Category.find_by(id: options[:category])\n-        if @guardian.can_see_deleted_topics?(category)\n-          result = result.where(\"topics.deleted_at IS NOT NULL\")\n-          require_deleted_clause = false\n-        end\n-      end\n+      options[:q] ||= +\"\"\n+      options[:q] << \" status:#{status}\"",
        "comment_created_at": "2023-03-02T01:27:44+00:00",
        "comment_author": "lis2",
        "comment_body": "status is just a start right? What do you think if we collect `:q` as an array of options or hash of options. Then later we would not need to have that regex `(([^\" \\t\\n\\x0B\\f\\r]+)?((\"[^\"]+\")?))` just loop through options",
        "pr_file_module": null
      },
      {
        "comment_id": "1123899148",
        "repo_full_name": "discourse/discourse",
        "pr_number": 20494,
        "pr_file": "lib/topic_query.rb",
        "discussion_id": "1122508193",
        "commented_code": "@@ -836,24 +838,17 @@ def default_results(options = {})\n     end\n \n     if status = options[:status]\n-      case status\n-      when \"open\"\n-        result = result.where(\"NOT topics.closed AND NOT topics.archived\")\n-      when \"closed\"\n-        result = result.where(\"topics.closed\")\n-      when \"archived\"\n-        result = result.where(\"topics.archived\")\n-      when \"listed\"\n-        result = result.where(\"topics.visible\")\n-      when \"unlisted\"\n-        result = result.where(\"NOT topics.visible\")\n-      when \"deleted\"\n-        category = Category.find_by(id: options[:category])\n-        if @guardian.can_see_deleted_topics?(category)\n-          result = result.where(\"topics.deleted_at IS NOT NULL\")\n-          require_deleted_clause = false\n-        end\n-      end\n+      options[:q] ||= +\"\"\n+      options[:q] << \" status:#{status}\"",
        "comment_created_at": "2023-03-03T00:16:19+00:00",
        "comment_author": "tgxworld",
        "comment_body": "> What do you think if we collect :q as an array of options or hash of options. \r\n\r\nCan you expand on what you mean here? Currently `q` is a param that represents a custom query language which we intend to support. Therefore, it'll look something like this in the long run: `status:closed category:todo`. We'll need some form or regexp to parse the string one way or another. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1123920269",
        "repo_full_name": "discourse/discourse",
        "pr_number": 20494,
        "pr_file": "lib/topic_query.rb",
        "discussion_id": "1122508193",
        "commented_code": "@@ -836,24 +838,17 @@ def default_results(options = {})\n     end\n \n     if status = options[:status]\n-      case status\n-      when \"open\"\n-        result = result.where(\"NOT topics.closed AND NOT topics.archived\")\n-      when \"closed\"\n-        result = result.where(\"topics.closed\")\n-      when \"archived\"\n-        result = result.where(\"topics.archived\")\n-      when \"listed\"\n-        result = result.where(\"topics.visible\")\n-      when \"unlisted\"\n-        result = result.where(\"NOT topics.visible\")\n-      when \"deleted\"\n-        category = Category.find_by(id: options[:category])\n-        if @guardian.can_see_deleted_topics?(category)\n-          result = result.where(\"topics.deleted_at IS NOT NULL\")\n-          require_deleted_clause = false\n-        end\n-      end\n+      options[:q] ||= +\"\"\n+      options[:q] << \" status:#{status}\"",
        "comment_created_at": "2023-03-03T00:44:45+00:00",
        "comment_author": "lis2",
        "comment_body": "My understanding was that options are parsed before from query language and we would have something like`options[:status]` and `options[:category]`\r\n\r\nIf yes, then instead of passing options[:q] to TopicsFilter, maybe we can pass all individual options to TopicFilter\r\nsomething like:\r\n```\r\noptions_hash = {}\r\noptions_hash[:status] = options[:status]\r\noptions_hash[:category] = options[:category]\r\n\r\n result =\r\n        TopicsFilter.new(\r\n          scope: result,\r\n          guardian: @guardian,\r\n          category_id: options[:category],\r\n        ).filter(options_hash)\r\n```\r\n\r\nNot sure if it is possible but if yes, then   TopicsFilter would be a bit clearer what are potential options",
        "pr_file_module": null
      },
      {
        "comment_id": "1123929398",
        "repo_full_name": "discourse/discourse",
        "pr_number": 20494,
        "pr_file": "lib/topic_query.rb",
        "discussion_id": "1122508193",
        "commented_code": "@@ -836,24 +838,17 @@ def default_results(options = {})\n     end\n \n     if status = options[:status]\n-      case status\n-      when \"open\"\n-        result = result.where(\"NOT topics.closed AND NOT topics.archived\")\n-      when \"closed\"\n-        result = result.where(\"topics.closed\")\n-      when \"archived\"\n-        result = result.where(\"topics.archived\")\n-      when \"listed\"\n-        result = result.where(\"topics.visible\")\n-      when \"unlisted\"\n-        result = result.where(\"NOT topics.visible\")\n-      when \"deleted\"\n-        category = Category.find_by(id: options[:category])\n-        if @guardian.can_see_deleted_topics?(category)\n-          result = result.where(\"topics.deleted_at IS NOT NULL\")\n-          require_deleted_clause = false\n-        end\n-      end\n+      options[:q] ||= +\"\"\n+      options[:q] << \" status:#{status}\"",
        "comment_created_at": "2023-03-03T01:02:49+00:00",
        "comment_author": "tgxworld",
        "comment_body": "O ic. I think what you're saying here is to separate out the responsibility of parsing the query language into another class that is different from `TopicsFilter`? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2196971070",
    "pr_number": 33559,
    "pr_file": "lib/auth/discourse_id_authenticator.rb",
    "created_at": "2025-07-10T08:25:15+00:00",
    "commented_code": "option :client_options, auth_scheme: :basic_auth\n \n     def authorize_params\n-      super.tap { _1[:intent] = \"signup\" if request.params[\"signup\"] == \"true\" }\n+      super.tap do |params|\n+        if request.params[\"signup\"] == \"true\"\n+          params[:intent] = \"signup\"\n+          params[:email] = request.params[\"email\"] if request.params[\"email\"].present?",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2196971070",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33559,
        "pr_file": "lib/auth/discourse_id_authenticator.rb",
        "discussion_id": "2196971070",
        "commented_code": "@@ -7,7 +7,12 @@ class DiscourseIdStrategy < ::OmniAuth::Strategies::OAuth2\n     option :client_options, auth_scheme: :basic_auth\n \n     def authorize_params\n-      super.tap { _1[:intent] = \"signup\" if request.params[\"signup\"] == \"true\" }\n+      super.tap do |params|\n+        if request.params[\"signup\"] == \"true\"\n+          params[:intent] = \"signup\"\n+          params[:email] = request.params[\"email\"] if request.params[\"email\"].present?",
        "comment_created_at": "2025-07-10T08:25:15+00:00",
        "comment_author": "ZogStriP",
        "comment_body": "We'll pass along the email address when we're signing up (so it can be pre-filled in the signup form)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2184260405",
    "pr_number": 33449,
    "pr_file": "spec/mailers/user_notifications_spec.rb",
    "created_at": "2025-07-04T03:47:16+00:00",
    "commented_code": "end\n   end\n \n+  describe \".notification_email\" do\n+    let!(:plugin) { Plugin::Instance.new }\n+    let(:response_by_user) { Fabricate(:user, name: \"John Doe\") }\n+    let(:category) { Fabricate(:category, name: \"India\") }\n+\n+    let(:topic) { Fabricate(:topic, category: category, title: \"Super cool topic\") }\n+\n+    let(:user) { Fabricate(:user) }\n+    let(:post) { Fabricate(:post, topic: topic, raw: \"This is My super duper cool topic\") }\n+    let(:response) do\n+      Fabricate(\n+        :basic_reply,\n+        topic: post.topic,\n+        user: response_by_user,\n+        raw: \"@#{user.username} response to post\",\n+      )\n+    end\n+    let(:notification) { Fabricate(:mentioned_notification, user: user, post: response) }\n+    let!(:modify_post) do\n+      post.cooked = \"modified post\"\n+      Proc.new do\n+        {\n+          title: \"Super cool topic\",\n+          post: post,\n+          username: \"bruce4\",\n+          from_alias: \"John Doe via Discourse\",\n+          allow_reply_by_email: true,\n+          use_site_subject: true,\n+          add_re_to_subject: nil,\n+          show_category_in_subject: true,\n+          show_tags_in_subject: true,\n+          show_group_in_subject: nil,\n+          notification_type: \"mentioned\",\n+          use_invite_template: nil,\n+          use_topic_title_subject: false,\n+          user: user,\n+        }\n+      end\n+    end",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2184260405",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33449,
        "pr_file": "spec/mailers/user_notifications_spec.rb",
        "discussion_id": "2184260405",
        "commented_code": "@@ -1453,6 +1307,71 @@ def expects_build_with(condition)\n     end\n   end\n \n+  describe \".notification_email\" do\n+    let!(:plugin) { Plugin::Instance.new }\n+    let(:response_by_user) { Fabricate(:user, name: \"John Doe\") }\n+    let(:category) { Fabricate(:category, name: \"India\") }\n+\n+    let(:topic) { Fabricate(:topic, category: category, title: \"Super cool topic\") }\n+\n+    let(:user) { Fabricate(:user) }\n+    let(:post) { Fabricate(:post, topic: topic, raw: \"This is My super duper cool topic\") }\n+    let(:response) do\n+      Fabricate(\n+        :basic_reply,\n+        topic: post.topic,\n+        user: response_by_user,\n+        raw: \"@#{user.username} response to post\",\n+      )\n+    end\n+    let(:notification) { Fabricate(:mentioned_notification, user: user, post: response) }\n+    let!(:modify_post) do\n+      post.cooked = \"modified post\"\n+      Proc.new do\n+        {\n+          title: \"Super cool topic\",\n+          post: post,\n+          username: \"bruce4\",\n+          from_alias: \"John Doe via Discourse\",\n+          allow_reply_by_email: true,\n+          use_site_subject: true,\n+          add_re_to_subject: nil,\n+          show_category_in_subject: true,\n+          show_tags_in_subject: true,\n+          show_group_in_subject: nil,\n+          notification_type: \"mentioned\",\n+          use_invite_template: nil,\n+          use_topic_title_subject: false,\n+          user: user,\n+        }\n+      end\n+    end",
        "comment_created_at": "2025-07-04T03:47:16+00:00",
        "comment_author": "tgxworld",
        "comment_body": "The proc passed to the modifier doesn't reflect how the modifier will be used by plugins. The `proc` needs to accept the `email_options` as a param and modify it. ",
        "pr_file_module": null
      }
    ]
  }
]