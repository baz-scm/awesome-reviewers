[
  {
    "discussion_id": "2127017056",
    "pr_number": 33072,
    "pr_file": "app/assets/javascripts/discourse/app/routes/signup.js",
    "created_at": "2025-06-04T16:36:02+00:00",
    "commented_code": "authComplete = false;\n \n-  beforeModel() {\n+  beforeModel({ from }) {\n+    if (from) {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2127017056",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33072,
        "pr_file": "app/assets/javascripts/discourse/app/routes/signup.js",
        "discussion_id": "2127017056",
        "commented_code": "@@ -10,7 +12,11 @@ export default class SignupRoute extends DiscourseRoute {\n \n   authComplete = false;\n \n-  beforeModel() {\n+  beforeModel({ from }) {\n+    if (from) {",
        "comment_created_at": "2025-06-04T16:36:02+00:00",
        "comment_author": "ZogStriP",
        "comment_body": "Applies the same \"store the origin url in a cookie\" behavior we do when login in, but for the signup process.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179165200",
    "pr_number": 33430,
    "pr_file": "app/assets/javascripts/admin/addon/models/color-scheme.js",
    "created_at": "2025-07-02T05:43:10+00:00",
    "commented_code": "return [`\"${this.name}\": {`, buffer.join(\",\n\"), \"}\"].join(\"\n\");\n   }\n \n+  schemeObject() {\n+    const extractColors = (property) =>\n+      Object.fromEntries(\n+        this.colors.map((color) => [color.get(\"name\"), color.get(property)])\n+      );\n+    return {\n+      dark: extractColors(\"dark_hex\"),\n+      light: extractColors(\"hex\"),\n+    };\n+  }\n+\n+  /**\n+   * @returns a JSON representation of the color scheme.\n+   */\n+  dump() {\n+    return (\n+      JSON.stringify(this.name) +",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2179165200",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33430,
        "pr_file": "app/assets/javascripts/admin/addon/models/color-scheme.js",
        "discussion_id": "2179165200",
        "commented_code": "@@ -88,6 +88,28 @@ export default class ColorScheme extends EmberObject {\n     return [`\"${this.name}\": {`, buffer.join(\",\\n\"), \"}\"].join(\"\\n\");\n   }\n \n+  schemeObject() {\n+    const extractColors = (property) =>\n+      Object.fromEntries(\n+        this.colors.map((color) => [color.get(\"name\"), color.get(property)])\n+      );\n+    return {\n+      dark: extractColors(\"dark_hex\"),\n+      light: extractColors(\"hex\"),\n+    };\n+  }\n+\n+  /**\n+   * @returns a JSON representation of the color scheme.\n+   */\n+  dump() {\n+    return (\n+      JSON.stringify(this.name) +",
        "comment_created_at": "2025-07-02T05:43:10+00:00",
        "comment_author": "Lhcfl",
        "comment_body": "The string concatenation used here is safe, but the previous one was not. Users may use double quotes `\"` or backslashes `\\` in the name, and not using stringify will break the JSON export.",
        "pr_file_module": null
      },
      {
        "comment_id": "2179806687",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33430,
        "pr_file": "app/assets/javascripts/admin/addon/models/color-scheme.js",
        "discussion_id": "2179165200",
        "commented_code": "@@ -88,6 +88,28 @@ export default class ColorScheme extends EmberObject {\n     return [`\"${this.name}\": {`, buffer.join(\",\\n\"), \"}\"].join(\"\\n\");\n   }\n \n+  schemeObject() {\n+    const extractColors = (property) =>\n+      Object.fromEntries(\n+        this.colors.map((color) => [color.get(\"name\"), color.get(property)])\n+      );\n+    return {\n+      dark: extractColors(\"dark_hex\"),\n+      light: extractColors(\"hex\"),\n+    };\n+  }\n+\n+  /**\n+   * @returns a JSON representation of the color scheme.\n+   */\n+  dump() {\n+    return (\n+      JSON.stringify(this.name) +",
        "comment_created_at": "2025-07-02T11:24:40+00:00",
        "comment_author": "OsamaSayegh",
        "comment_body": "Why do we need to do string concatenation at all? Could we do something like this:\r\n\r\n```js\r\nconst object = { name: this.name, light: { ... }, dark: { ... } };\r\nreturn JSON.stringify(object, null, 2);\r\n```\r\n?",
        "pr_file_module": null
      },
      {
        "comment_id": "2181311208",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33430,
        "pr_file": "app/assets/javascripts/admin/addon/models/color-scheme.js",
        "discussion_id": "2179165200",
        "commented_code": "@@ -88,6 +88,28 @@ export default class ColorScheme extends EmberObject {\n     return [`\"${this.name}\": {`, buffer.join(\",\\n\"), \"}\"].join(\"\\n\");\n   }\n \n+  schemeObject() {\n+    const extractColors = (property) =>\n+      Object.fromEntries(\n+        this.colors.map((color) => [color.get(\"name\"), color.get(property)])\n+      );\n+    return {\n+      dark: extractColors(\"dark_hex\"),\n+      light: extractColors(\"hex\"),\n+    };\n+  }\n+\n+  /**\n+   * @returns a JSON representation of the color scheme.\n+   */\n+  dump() {\n+    return (\n+      JSON.stringify(this.name) +",
        "comment_created_at": "2025-07-03T01:29:28+00:00",
        "comment_author": "Lhcfl",
        "comment_body": "Yes, I thought so too!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2196960188",
    "pr_number": 33559,
    "pr_file": "app/assets/javascripts/discourse/app/models/login-method.js",
    "created_at": "2025-07-10T08:20:08+00:00",
    "commented_code": "import { i18n } from \"discourse-i18n\";\n \n export default class LoginMethod extends EmberObject {\n-  static buildPostForm(url) {\n+  static buildPostForm(url, params = {}) {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2196960188",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33559,
        "pr_file": "app/assets/javascripts/discourse/app/models/login-method.js",
        "discussion_id": "2196960188",
        "commented_code": "@@ -8,7 +8,7 @@ import Site from \"discourse/models/site\";\n import { i18n } from \"discourse-i18n\";\n \n export default class LoginMethod extends EmberObject {\n-  static buildPostForm(url) {\n+  static buildPostForm(url, params = {}) {",
        "comment_created_at": "2025-07-10T08:20:08+00:00",
        "comment_author": "ZogStriP",
        "comment_body": "Pass all the `params` using the \"hidden\" form instead of using query params & the form.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2157814378",
    "pr_number": 33272,
    "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
    "created_at": "2025-06-20T00:20:37+00:00",
    "commented_code": "}\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {\n+      tag.style_type = \"icon\";\n+    }\n+\n+    VALID_HASHTAGS.set(tag.slug.toLowerCase(), tag);",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2157814378",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157814378",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {\n+      tag.style_type = \"icon\";\n+    }\n+\n+    VALID_HASHTAGS.set(tag.slug.toLowerCase(), tag);",
        "comment_created_at": "2025-06-20T00:20:37+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "I think you need to tweak this VALID_HASHTAGS storage a bit to handle hashtags of multiple different contexts. A context is the topic composer or the chat composer, in topic composer you can do `#general` by itself and it will refer to the category, in chat you can do `#general` by itself and it will refer to the channel. In the old composer, you can do this:\r\n\r\n![image](https://github.com/user-attachments/assets/62896ee2-c7c5-4505-b270-83606c952e1a)\r\n\r\nBut in the new one we get this:\r\n\r\n![image](https://github.com/user-attachments/assets/2aac9efc-6ef5-4a84-b084-ad53a0b03b17)\r\n\r\nHashtags in the format `general::channel` are called `refs`, since they contain the type and the slug of the hashtag. In the old `hashtag-cooked` elements in the composer we store both the slug and the type of the hashtag:\r\n\r\n```\r\n<a class=\"hashtag-cooked\" href=\"/chat/c/dev/300\" data-type=\"channel\" data-id=\"300\" data-slug=\"dev\" data-style-type=\"null\" tabindex=\"-1\"><svg class=\"fa d-icon d-icon-comment svg-icon hashtag-color--channel-300 svg-string\" aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\"><use href=\"#comment\"></use></svg><span>dev</span></a>\r\n```\r\n\r\nSo I think for `VALID_HASHTAGS` you will need to do the same and store the name + type, and make sure these specific refs can be rendered correctly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2158021216",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157814378",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {\n+      tag.style_type = \"icon\";\n+    }\n+\n+    VALID_HASHTAGS.set(tag.slug.toLowerCase(), tag);",
        "comment_created_at": "2025-06-20T04:34:11+00:00",
        "comment_author": "dbattersby",
        "comment_body": "Nice, I didn't realise that we used this format (`general::channel`), without it we rely on the order defined in `hashtag_configurations` to determine whether to render the channel or the category. I will make some updates to account for refs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2158210024",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157814378",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {\n+      tag.style_type = \"icon\";\n+    }\n+\n+    VALID_HASHTAGS.set(tag.slug.toLowerCase(), tag);",
        "comment_created_at": "2025-06-20T07:06:08+00:00",
        "comment_author": "dbattersby",
        "comment_body": "This was easier than expected, I just stored the ref rather than the slug which appears to solve it. Now by default `#general` would show a category and `#general::channel` would show the chat channel.",
        "pr_file_module": null
      }
    ]
  }
]