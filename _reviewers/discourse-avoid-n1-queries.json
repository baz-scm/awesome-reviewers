[
  {
    "discussion_id": "2281141940",
    "pr_number": 34350,
    "pr_file": "app/models/user.rb",
    "created_at": "2025-08-18T01:57:22+00:00",
    "commented_code": "def user_fields(field_ids = nil)\n     field_ids = (@all_user_field_ids ||= UserField.pluck(:id)) if field_ids.nil?\n \n-    field_ids.map { |fid| [fid.to_s, custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"]] }.to_h\n+    field_ids\n+      .map do |fid|\n+        value =\n+          if UserField.find_by(id: fid).field_type == \"confirm\"",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2281141940",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34350,
        "pr_file": "app/models/user.rb",
        "discussion_id": "2281141940",
        "commented_code": "@@ -1580,7 +1580,18 @@ def associated_accounts\n   def user_fields(field_ids = nil)\n     field_ids = (@all_user_field_ids ||= UserField.pluck(:id)) if field_ids.nil?\n \n-    field_ids.map { |fid| [fid.to_s, custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"]] }.to_h\n+    field_ids\n+      .map do |fid|\n+        value =\n+          if UserField.find_by(id: fid).field_type == \"confirm\"",
        "comment_created_at": "2025-08-18T01:57:22+00:00",
        "comment_author": "Drenmi",
        "comment_body": "Will this fire off one SQL query per field? \ud83e\udd14 Potentially should preload all this in one go. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2281164789",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34350,
        "pr_file": "app/models/user.rb",
        "discussion_id": "2281141940",
        "commented_code": "@@ -1580,7 +1580,18 @@ def associated_accounts\n   def user_fields(field_ids = nil)\n     field_ids = (@all_user_field_ids ||= UserField.pluck(:id)) if field_ids.nil?\n \n-    field_ids.map { |fid| [fid.to_s, custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"]] }.to_h\n+    field_ids\n+      .map do |fid|\n+        value =\n+          if UserField.find_by(id: fid).field_type == \"confirm\"",
        "comment_created_at": "2025-08-18T02:26:45+00:00",
        "comment_author": "pento",
        "comment_body": "Aye, you're right. With user field data being stored by custom fields, I'd gotten the aggressive preloading of user field data mixed up with the lack of preloading of user field definitions. \ud83d\ude01 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2281145699",
    "pr_number": 34350,
    "pr_file": "app/models/user.rb",
    "created_at": "2025-08-18T02:01:29+00:00",
    "commented_code": "def user_fields(field_ids = nil)\n     field_ids = (@all_user_field_ids ||= UserField.pluck(:id)) if field_ids.nil?\n \n-    field_ids.map { |fid| [fid.to_s, custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"]] }.to_h\n+    field_ids\n+      .map do |fid|\n+        value =\n+          if UserField.find_by(id: fid).field_type == \"confirm\"",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2281145699",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34350,
        "pr_file": "app/models/user.rb",
        "discussion_id": "2281145699",
        "commented_code": "@@ -1580,7 +1580,18 @@ def associated_accounts\n   def user_fields(field_ids = nil)\n     field_ids = (@all_user_field_ids ||= UserField.pluck(:id)) if field_ids.nil?\n \n-    field_ids.map { |fid| [fid.to_s, custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"]] }.to_h\n+    field_ids\n+      .map do |fid|\n+        value =\n+          if UserField.find_by(id: fid).field_type == \"confirm\"",
        "comment_created_at": "2025-08-18T02:01:29+00:00",
        "comment_author": "tgxworld",
        "comment_body": "`UserField.find_by` executes 1 SQL query each time it is called so we want to avoid calling that in a loop.\n\n```suggestion\n    confirm_field_ids = UserField.where(field_type: \"confirm\", id: field_ids).pluck(:id)\n\n    field_ids\n      .map do |fid|\n        value =\n          if confirm_field_ids.include?(fid)\n            !!Helpers::CUSTOM_FIELD_TRUE.include?(custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"])\n          else\n            custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"]\n          end\n\n        [fid.to_s, value]\n      end\n      .to_h\n```\n\nI didn't test the above solution locally but it should allow us to reduce the number of SQL calls made in the method.",
        "pr_file_module": null
      },
      {
        "comment_id": "2281165181",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34350,
        "pr_file": "app/models/user.rb",
        "discussion_id": "2281145699",
        "commented_code": "@@ -1580,7 +1580,18 @@ def associated_accounts\n   def user_fields(field_ids = nil)\n     field_ids = (@all_user_field_ids ||= UserField.pluck(:id)) if field_ids.nil?\n \n-    field_ids.map { |fid| [fid.to_s, custom_fields[\"#{USER_FIELD_PREFIX}#{fid}\"]] }.to_h\n+    field_ids\n+      .map do |fid|\n+        value =\n+          if UserField.find_by(id: fid).field_type == \"confirm\"",
        "comment_created_at": "2025-08-18T02:27:17+00:00",
        "comment_author": "pento",
        "comment_body": "Thanks for the idea, I've merged a fix! \ud83d\ude42 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2255618615",
    "pr_number": 33992,
    "pr_file": "plugins/discourse-assign/plugin.rb",
    "created_at": "2025-08-06T00:53:56+00:00",
    "commented_code": "add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    names.each do |name|",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2255618615",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "plugins/discourse-assign/plugin.rb",
        "discussion_id": "2255618615",
        "commented_code": "@@ -892,19 +892,69 @@ module ::DiscourseAssign\n   add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    names.each do |name|",
        "comment_created_at": "2025-08-06T00:53:56+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "IK it's probably unlikely to be a lot of these, but this will cause an N1. Maybe we can do it in a single query like this?\r\n\r\n```ruby\r\nresults = DB.query(<<~SQL, names: names)\r\n  SELECT 'user' AS type, id\r\n  FROM users\r\n  WHERE username IN (:names)\r\n  UNION ALL\r\n  SELECT 'group' AS type, id\r\n  FROM groups\r\n  WHERE name IN (:names)\r\nSQL\r\n\r\nresults.each do |row|\r\n  if row.type == \"user\"\r\n    user_ids << row.id\r\n  else\r\n    group_ids << row.id\r\n  end\r\nend\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2255876416",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "plugins/discourse-assign/plugin.rb",
        "discussion_id": "2255618615",
        "commented_code": "@@ -892,19 +892,69 @@ module ::DiscourseAssign\n   add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    names.each do |name|",
        "comment_created_at": "2025-08-06T05:09:04+00:00",
        "comment_author": "SamSaffron",
        "comment_body": "will clean it up... sure ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2256720428",
    "pr_number": 33992,
    "pr_file": "plugins/discourse-assign/plugin.rb",
    "created_at": "2025-08-06T10:28:38+00:00",
    "commented_code": "add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    found_users = User.where(username_lower: names.map(&:downcase)).pluck(:username, :id).to_h\n+    user_ids.concat(found_users.values)\n+\n+    # a bit edge casey cause we have username_lower for users but not for groups\n+    # we share a namespace though so in practice this is ok\n+    remaining_names = names - found_users.keys\n+    group_ids.concat(Group.where(name: remaining_names).pluck(:id)) if remaining_names.present?",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2256720428",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "plugins/discourse-assign/plugin.rb",
        "discussion_id": "2256720428",
        "commented_code": "@@ -892,19 +892,66 @@ module ::DiscourseAssign\n   add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    found_users = User.where(username_lower: names.map(&:downcase)).pluck(:username, :id).to_h\n+    user_ids.concat(found_users.values)\n+\n+    # a bit edge casey cause we have username_lower for users but not for groups\n+    # we share a namespace though so in practice this is ok\n+    remaining_names = names - found_users.keys\n+    group_ids.concat(Group.where(name: remaining_names).pluck(:id)) if remaining_names.present?",
        "comment_created_at": "2025-08-06T10:28:38+00:00",
        "comment_author": "CvX",
        "comment_body": "```suggestion\r\n    found_names, user_ids = User.where(username_lower: names.map(&:downcase)).pluck(:username, :id).transpose\r\n\r\n    # a bit edge casey cause we have username_lower for users but not for groups\r\n    # we share a namespace though so in practice this is ok\r\n    remaining_names = names - found_names\r\n    group_ids = []\r\n    group_ids.concat(Group.where(name: remaining_names).pluck(:id)) if remaining_names.present?\r\n```\r\n\r\nno hash/.keys/.values, one concat less",
        "pr_file_module": null
      }
    ]
  }
]