[
  {
    "discussion_id": "2234676646",
    "pr_number": 33876,
    "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation.gjs",
    "created_at": "2025-07-28T04:46:03+00:00",
    "commented_code": "this._allowEnterSubmit = !value;\n   }\n \n+  @action\n+  setupEventListeners() {\n+    if (!this.inputElement) {\n+      throw new Error(\"DiscoveryFilterNavigation requires an inputElement.\");\n+    }\n+    this.inputElement.addEventListener(\"focus\", this.handleInputFocus);\n+    this.inputElement.addEventListener(\"blur\", this.handleInputBlur);\n+    this.inputElement.addEventListener(\"keydown\", this.handleKeyDownTips);\n+    this.inputElement.addEventListener(\"input\", this.handleInput);\n+  }\n+\n+  @action\n+  onRegisterApi(api) {\n+    this.dMenu = api;\n+    if (this.inputElement) {\n+      this.dMenu.trigger = this.inputElement;\n+      this.dMenu.detachedTrigger = true;\n+    }\n+  }\n+\n+  @action\n+  handleInput() {\n+    this.updateResults(this.inputElement.value);\n+  }\n+\n+  updateResults(value) {\n+    this.newQueryString = value;\n+    this.selectedIndex = -1;\n+\n+    const words = value.split(/\\s+/);\n+    const lastWord = words.at(-1);\n+    const colonIndex = lastWord.indexOf(\":\");\n+\n+    if (colonIndex > 0) {\n+      const prefix = this.extractPrefix(lastWord);\n+      const filterName = lastWord.substring(\n+        prefix.length,\n+        colonIndex + prefix.length\n+      );\n+      const valueText = lastWord.substring(colonIndex + 1);\n+\n+      const tip = this.args.tips.find((t) => {\n+        const tipFilterName = t.name.replace(/^[-=]/, \"\").split(\":\")[0];\n+        return tipFilterName === filterName && t.type;\n+      });\n+\n+      if (tip?.type) {\n+        this.activeFilter = filterName;\n+        this.handlePlaceholderSearch(filterName, valueText, tip, prefix);\n+      } else {\n+        this.activeFilter = null;\n+        this.searchResults = [];\n+      }\n+    } else {\n+      this.activeFilter = null;\n+      this.searchResults = [];\n+    }\n+  }\n+\n+  @action\n+  handleInputFocus() {\n+    this.showTips = true;\n+    this.selectedIndex = -1;\n+    this.dMenu?.show();\n+  }\n+\n+  @action\n+  handleInputBlur() {\n+    if (this.handleBlurTimer) {\n+      cancel(this.handleBlurTimer);\n+    }\n+    this.handleBlurTimer = later(() => this.hideTipsIfNeeded(), 200);\n+  }\n+\n+  hideTipsIfNeeded() {\n+    this.handleBlurTimer = null;\n+    if (document.activeElement !== this.inputElement && this.showTips) {\n+      this.hideTips();\n+    }\n+  }\n+\n+  @action\n+  handleKeyDownTips(event) {\n+    if (!this.showTips || this.currentItems.length === 0) {\n+      return;\n+    }\n+\n+    switch (event.key) {\n+      case \"ArrowDown\":\n+        event.preventDefault();\n+        this.selectedIndex =\n+          this.selectedIndex === -1\n+            ? 0\n+            : (this.selectedIndex + 1) % this.currentItems.length;\n+        break;\n+      case \"ArrowUp\":\n+        event.preventDefault();\n+        this.selectedIndex =\n+          this.selectedIndex === -1\n+            ? this.currentItems.length - 1\n+            : (this.selectedIndex - 1 + this.currentItems.length) %\n+              this.currentItems.length;\n+        break;\n+      case \"Tab\":\n+        event.preventDefault();\n+        event.stopPropagation();\n+        this.selectItem(\n+          this.currentItems[this.selectedIndex === -1 ? 0 : this.selectedIndex]\n+        );\n+        break;\n+      case \"Enter\":\n+        if (this.selectedIndex >= 0) {\n+          event.preventDefault();\n+          event.stopPropagation();\n+          event.stopImmediatePropagation();\n+          this.selectItem(this.currentItems[this.selectedIndex]);\n+        }\n+        break;\n+      case \"Escape\":\n+        this.hideTips();\n+        break;\n+    }\n+  }\n+\n+  hideTips() {\n+    this.showTips = false;\n+    this.dMenu?.close();\n+    this.blockEnterSubmit(false);\n+  }\n+\n+  get filteredTips() {\n+    if (!this.args.tips) {\n+      return [];\n+    }\n+\n+    const words = this.currentInputValue.split(/\\s+/);\n+    const lastWord = words.at(-1).toLowerCase();\n+\n+    if (this.activeFilter && this.searchResults.length > 0) {\n+      return this.searchResults;\n+    }\n+\n+    const colonIndex = lastWord.indexOf(\":\");\n+    const prefix = this.extractPrefix(lastWord) || \"\";\n+\n+    if (colonIndex > 0) {\n+      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n+      const valueText = lastWord.substring(colonIndex + 1);\n+      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n+      if (tip?.type && valueText !== undefined) {\n+        this.handlePlaceholderSearch(filterName, valueText, tip, prefix);\n+        return this.searchResults.length > 0 ? this.searchResults : [];\n+      }\n+    }\n+\n+    if (!this.currentInputValue || lastWord === \"\") {\n+      return this.args.tips\n+        .filter((tip) => tip.priority)\n+        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n+        .slice(0, MAX_RESULTS);\n+    }\n+\n+    const tips = [];\n+    this.args.tips.forEach((tip) => {\n+      if (tips.length >= MAX_RESULTS) {\n+        return;\n+      }\n+      const tipName = tip.name;\n+      const searchTerm = lastWord.substring(prefix.length);\n+\n+      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n+        return;\n+      }\n+\n+      const prefixMatch =\n+        searchTerm === \"\" &&\n+        prefix &&\n+        tipName.prefixes &&\n+        tipName.prefixes.find((p) => p.name === prefix);\n+\n+      if (prefixMatch || tipName.indexOf(searchTerm) > -1) {\n+        this.pushPrefixTips(tip, tips, null, prefix);\n+        if (!prefix) {\n+          tips.push(tip);\n+        }\n+      } else if (tip.alias && tip.alias.indexOf(searchTerm) > -1) {\n+        this.pushPrefixTips(tip, tips, tip.alias, prefix);\n+        tips.push({ ...tip, name: tip.alias });\n+      }\n+    });\n+\n+    return tips.sort((a, b) => {\n+      const aName = a.name;\n+      const bName = b.name;\n+      const aStartsWith = aName.startsWith(lastWord);\n+      const bStartsWith = bName.startsWith(lastWord);\n+      if (aStartsWith && !bStartsWith) {\n+        return -1;\n+      }\n+      if (!aStartsWith && bStartsWith) {\n+        return 1;\n+      }\n+      if (aStartsWith && bStartsWith && aName.length !== bName.length) {\n+        return aName.length - bName.length;\n+      }\n+      return aName.localeCompare(bName);\n+    });\n+  }\n+\n+  pushPrefixTips(tip, tips, alias = null, currentPrefix = null) {\n+    if (tip.prefixes && tip.prefixes.length > 0) {\n+      tip.prefixes.forEach((prefix) => {\n+        if (currentPrefix && !prefix.name.startsWith(currentPrefix)) {\n+          return;\n+        }\n+        tips.push({\n+          ...tip,\n+          name: `${prefix.name}${alias || tip.name}`,\n+          description: prefix.description || tip.description,\n+          isPlaceholderCompletion: true,\n+        });\n+      });\n+    }\n+  }\n+\n+  extractPrefix(word) {\n+    const match = word.match(/^(-=|=-|-|=)/);\n+    return match ? match[0] : \"\";\n+  }\n+\n+  @action\n+  handlePlaceholderSearch(filterName, valueText, tip, prefix = \"\") {\n+    this.activeFilter = filterName;\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n+    }\n+    this.searchTimer = discourseDebounce(\n+      this,\n+      this._performPlaceholderSearch,\n+      filterName,\n+      valueText,\n+      tip,\n+      prefix,\n+      300\n+    );",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2234676646",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33876,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation.gjs",
        "discussion_id": "2234676646",
        "commented_code": "@@ -81,6 +124,462 @@ export default class DiscoveryFilterNavigation extends Component {\n     this._allowEnterSubmit = !value;\n   }\n \n+  @action\n+  setupEventListeners() {\n+    if (!this.inputElement) {\n+      throw new Error(\"DiscoveryFilterNavigation requires an inputElement.\");\n+    }\n+    this.inputElement.addEventListener(\"focus\", this.handleInputFocus);\n+    this.inputElement.addEventListener(\"blur\", this.handleInputBlur);\n+    this.inputElement.addEventListener(\"keydown\", this.handleKeyDownTips);\n+    this.inputElement.addEventListener(\"input\", this.handleInput);\n+  }\n+\n+  @action\n+  onRegisterApi(api) {\n+    this.dMenu = api;\n+    if (this.inputElement) {\n+      this.dMenu.trigger = this.inputElement;\n+      this.dMenu.detachedTrigger = true;\n+    }\n+  }\n+\n+  @action\n+  handleInput() {\n+    this.updateResults(this.inputElement.value);\n+  }\n+\n+  updateResults(value) {\n+    this.newQueryString = value;\n+    this.selectedIndex = -1;\n+\n+    const words = value.split(/\\s+/);\n+    const lastWord = words.at(-1);\n+    const colonIndex = lastWord.indexOf(\":\");\n+\n+    if (colonIndex > 0) {\n+      const prefix = this.extractPrefix(lastWord);\n+      const filterName = lastWord.substring(\n+        prefix.length,\n+        colonIndex + prefix.length\n+      );\n+      const valueText = lastWord.substring(colonIndex + 1);\n+\n+      const tip = this.args.tips.find((t) => {\n+        const tipFilterName = t.name.replace(/^[-=]/, \"\").split(\":\")[0];\n+        return tipFilterName === filterName && t.type;\n+      });\n+\n+      if (tip?.type) {\n+        this.activeFilter = filterName;\n+        this.handlePlaceholderSearch(filterName, valueText, tip, prefix);\n+      } else {\n+        this.activeFilter = null;\n+        this.searchResults = [];\n+      }\n+    } else {\n+      this.activeFilter = null;\n+      this.searchResults = [];\n+    }\n+  }\n+\n+  @action\n+  handleInputFocus() {\n+    this.showTips = true;\n+    this.selectedIndex = -1;\n+    this.dMenu?.show();\n+  }\n+\n+  @action\n+  handleInputBlur() {\n+    if (this.handleBlurTimer) {\n+      cancel(this.handleBlurTimer);\n+    }\n+    this.handleBlurTimer = later(() => this.hideTipsIfNeeded(), 200);\n+  }\n+\n+  hideTipsIfNeeded() {\n+    this.handleBlurTimer = null;\n+    if (document.activeElement !== this.inputElement && this.showTips) {\n+      this.hideTips();\n+    }\n+  }\n+\n+  @action\n+  handleKeyDownTips(event) {\n+    if (!this.showTips || this.currentItems.length === 0) {\n+      return;\n+    }\n+\n+    switch (event.key) {\n+      case \"ArrowDown\":\n+        event.preventDefault();\n+        this.selectedIndex =\n+          this.selectedIndex === -1\n+            ? 0\n+            : (this.selectedIndex + 1) % this.currentItems.length;\n+        break;\n+      case \"ArrowUp\":\n+        event.preventDefault();\n+        this.selectedIndex =\n+          this.selectedIndex === -1\n+            ? this.currentItems.length - 1\n+            : (this.selectedIndex - 1 + this.currentItems.length) %\n+              this.currentItems.length;\n+        break;\n+      case \"Tab\":\n+        event.preventDefault();\n+        event.stopPropagation();\n+        this.selectItem(\n+          this.currentItems[this.selectedIndex === -1 ? 0 : this.selectedIndex]\n+        );\n+        break;\n+      case \"Enter\":\n+        if (this.selectedIndex >= 0) {\n+          event.preventDefault();\n+          event.stopPropagation();\n+          event.stopImmediatePropagation();\n+          this.selectItem(this.currentItems[this.selectedIndex]);\n+        }\n+        break;\n+      case \"Escape\":\n+        this.hideTips();\n+        break;\n+    }\n+  }\n+\n+  hideTips() {\n+    this.showTips = false;\n+    this.dMenu?.close();\n+    this.blockEnterSubmit(false);\n+  }\n+\n+  get filteredTips() {\n+    if (!this.args.tips) {\n+      return [];\n+    }\n+\n+    const words = this.currentInputValue.split(/\\s+/);\n+    const lastWord = words.at(-1).toLowerCase();\n+\n+    if (this.activeFilter && this.searchResults.length > 0) {\n+      return this.searchResults;\n+    }\n+\n+    const colonIndex = lastWord.indexOf(\":\");\n+    const prefix = this.extractPrefix(lastWord) || \"\";\n+\n+    if (colonIndex > 0) {\n+      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n+      const valueText = lastWord.substring(colonIndex + 1);\n+      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n+      if (tip?.type && valueText !== undefined) {\n+        this.handlePlaceholderSearch(filterName, valueText, tip, prefix);\n+        return this.searchResults.length > 0 ? this.searchResults : [];\n+      }\n+    }\n+\n+    if (!this.currentInputValue || lastWord === \"\") {\n+      return this.args.tips\n+        .filter((tip) => tip.priority)\n+        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n+        .slice(0, MAX_RESULTS);\n+    }\n+\n+    const tips = [];\n+    this.args.tips.forEach((tip) => {\n+      if (tips.length >= MAX_RESULTS) {\n+        return;\n+      }\n+      const tipName = tip.name;\n+      const searchTerm = lastWord.substring(prefix.length);\n+\n+      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n+        return;\n+      }\n+\n+      const prefixMatch =\n+        searchTerm === \"\" &&\n+        prefix &&\n+        tipName.prefixes &&\n+        tipName.prefixes.find((p) => p.name === prefix);\n+\n+      if (prefixMatch || tipName.indexOf(searchTerm) > -1) {\n+        this.pushPrefixTips(tip, tips, null, prefix);\n+        if (!prefix) {\n+          tips.push(tip);\n+        }\n+      } else if (tip.alias && tip.alias.indexOf(searchTerm) > -1) {\n+        this.pushPrefixTips(tip, tips, tip.alias, prefix);\n+        tips.push({ ...tip, name: tip.alias });\n+      }\n+    });\n+\n+    return tips.sort((a, b) => {\n+      const aName = a.name;\n+      const bName = b.name;\n+      const aStartsWith = aName.startsWith(lastWord);\n+      const bStartsWith = bName.startsWith(lastWord);\n+      if (aStartsWith && !bStartsWith) {\n+        return -1;\n+      }\n+      if (!aStartsWith && bStartsWith) {\n+        return 1;\n+      }\n+      if (aStartsWith && bStartsWith && aName.length !== bName.length) {\n+        return aName.length - bName.length;\n+      }\n+      return aName.localeCompare(bName);\n+    });\n+  }\n+\n+  pushPrefixTips(tip, tips, alias = null, currentPrefix = null) {\n+    if (tip.prefixes && tip.prefixes.length > 0) {\n+      tip.prefixes.forEach((prefix) => {\n+        if (currentPrefix && !prefix.name.startsWith(currentPrefix)) {\n+          return;\n+        }\n+        tips.push({\n+          ...tip,\n+          name: `${prefix.name}${alias || tip.name}`,\n+          description: prefix.description || tip.description,\n+          isPlaceholderCompletion: true,\n+        });\n+      });\n+    }\n+  }\n+\n+  extractPrefix(word) {\n+    const match = word.match(/^(-=|=-|-|=)/);\n+    return match ? match[0] : \"\";\n+  }\n+\n+  @action\n+  handlePlaceholderSearch(filterName, valueText, tip, prefix = \"\") {\n+    this.activeFilter = filterName;\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n+    }\n+    this.searchTimer = discourseDebounce(\n+      this,\n+      this._performPlaceholderSearch,\n+      filterName,\n+      valueText,\n+      tip,\n+      prefix,\n+      300\n+    );",
        "comment_created_at": "2025-07-28T04:46:03+00:00",
        "comment_author": "jjaffeux",
        "comment_body": "This is not debounced. Cancelling a debounce handler before calling it, defeats the purpose of it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2059355321",
    "pr_number": 32422,
    "pr_file": "app/assets/javascripts/discourse/app/components/discovery/accessible-discovery-heading.gjs",
    "created_at": "2025-04-24T23:01:38+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { cached } from \"@glimmer/tracking\";\n+import { i18n } from \"discourse-i18n\";\n+\n+export default class AccessibleDiscoveryHeading extends Component {\n+  @cached",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2059355321",
        "repo_full_name": "discourse/discourse",
        "pr_number": 32422,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/accessible-discovery-heading.gjs",
        "discussion_id": "2059355321",
        "commented_code": "@@ -0,0 +1,98 @@\n+import Component from \"@glimmer/component\";\n+import { cached } from \"@glimmer/tracking\";\n+import { i18n } from \"discourse-i18n\";\n+\n+export default class AccessibleDiscoveryHeading extends Component {\n+  @cached",
        "comment_created_at": "2025-04-24T23:01:38+00:00",
        "comment_author": "keegangeorge",
        "comment_body": "Is `@cached` necessary here? I believe there are some negative performance implications on using `@cached` in Octane over a native getter.\r\n\r\nsee internal: `/t/149819`",
        "pr_file_module": null
      },
      {
        "comment_id": "2060704269",
        "repo_full_name": "discourse/discourse",
        "pr_number": 32422,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/accessible-discovery-heading.gjs",
        "discussion_id": "2059355321",
        "commented_code": "@@ -0,0 +1,98 @@\n+import Component from \"@glimmer/component\";\n+import { cached } from \"@glimmer/tracking\";\n+import { i18n } from \"discourse-i18n\";\n+\n+export default class AccessibleDiscoveryHeading extends Component {\n+  @cached",
        "comment_created_at": "2025-04-25T18:26:57+00:00",
        "comment_author": "awesomerobot",
        "comment_body": "ooh yes I read that and completely forgot, removed! ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143744876",
    "pr_number": 33082,
    "pr_file": "app/assets/javascripts/discourse/app/components/translation.gjs",
    "created_at": "2025-06-12T22:14:55+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { action } from \"@ember/object\";\n+import { getOwner } from \"@ember/owner\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import curryComponent from \"ember-curry-component\";\n+import TranslationPlaceholder from \"discourse/components/translation-placeholder\";\n+import uniqueId from \"discourse/helpers/unique-id\";\n+import { isProduction } from \"discourse/lib/environment\";\n+import I18n, { i18n, I18nMissingInterpolationArgument } from \"discourse-i18n\";\n+\n+/**\n+ * Provides the ability to interpolate both strings and components into translatable strings.\n+ * This component allows for complex i18n scenarios where you need to embed interactive\n+ * components within translated text.\n+ *\n+ * If you don't require this functionality, use the standard i18n() function.\n+ *\n+ * @component Translation\n+ *\n+ * @template Usage example:\n+ * ```gjs\n+ * // Translation key: \"some.translation.key\" = \"Welcome, %{username}! The date is %{shortdate}!\"\n+ * <Translation\n+ *   @scope=\"some.translation.key\"\n+ *   @options={{hash shortdate=shortDate}}\n+ * >\n+ *   <:placeholders as |Placeholder|>\n+ *     <Placeholder @name=\"username\">\n+ *       <UserLink @user={{user}}>{{user.username}}</UserLink>\n+ *     </Placeholder>\n+ *   </:placeholders>\n+ * </Translation>\n+ * ```\n+ *\n+ * @param {String} scope - The i18n translation key to use\n+ * @param {Object} [options] - Hash of options to pass to the i18n function for string interpolation\n+ */\n+export default class Translation extends Component {\n+  /**\n+   * A map of placeholder keys to their unique identifiers.\n+   *\n+   * @type {Map<String, String>}\n+   */\n+  _placeholderKeys = new Map();\n+\n+  /**\n+   * A map of placeholder keys to their corresponding DOM elements.\n+   *\n+   * @type {Map<String, HTMLElement>}\n+   */\n+  _placeholderElements = new Map();\n+\n+  /**\n+   * A map of placeholder keys to their appearance in the translation string.\n+   *\n+   * @type {Map<String, String>}\n+   */\n+  _placeholderAppearance = new Map();\n+\n+  /**\n+   * Tracks which placeholders have been rendered.\n+   *\n+   * @type {Array<String>}\n+   */\n+  _renderedPlaceholders = [];\n+\n+  /**\n+   * Processes the translation string and returns an array of text segments and\n+   * placeholder elements that can be rendered in the template.\n+   *\n+   * @returns {Array<String|HTMLElement>} Array of text segments and placeholder elements\n+   */\n+  get textAndPlaceholders() {\n+    const optionsArg = this.args.options || {};\n+\n+    // Find all of the placeholders in the string we're looking at.\n+    const message = I18n.findTranslationWithFallback(this.args.scope, {\n+      ...optionsArg,\n+    });\n+    this._placeholderAppearance = I18n.findPlaceholders(message);\n+\n+    // We only need to keep the placeholders that aren't being handled by those passed in @options.\n+    Object.keys(optionsArg).forEach((stringPlaceholder) =>\n+      this._placeholderAppearance.delete(stringPlaceholder)\n+    );\n+\n+    this._placeholderAppearance.forEach((_, placeholderName) => {\n+      this._placeholderKeys.set(\n+        placeholderName,\n+        `__PLACEHOLDER__${placeholderName}__${uniqueId()}__`\n+      );\n+      this._placeholderElements.set(\n+        placeholderName,\n+        document.createElement(\"span\")\n+      );\n+    });\n+\n+    const text = i18n(this.args.scope, {\n+      ...Object.fromEntries(this._placeholderKeys),\n+      ...optionsArg,\n+    });\n+\n+    if (text === I18n.missingTranslation(this.args.scope)) {\n+      return [text];\n+    }\n+\n+    // Bail early if there were no placeholders we need to handle.\n+    if (this._placeholderAppearance.size === 0) {\n+      if (isProduction()) {\n+        return [text];\n+      } else {\n+        throw new Error(\n+          \"The <Translation> component shouldn't be used for strings that don't insert components. Use `i18n()` instead.\"\n+        );\n+      }\n+    }\n+\n+    const parts = [];\n+    let currentIndex = 0;\n+    const placeholderRegex = /__PLACEHOLDER__([^_]+)__[^_]+__/g;\n+    let match;\n+\n+    while ((match = placeholderRegex.exec(text)) !== null) {\n+      // Add text before placeholder if exists\n+      if (match.index > currentIndex) {\n+        parts.push(text.slice(currentIndex, match.index));\n+      }\n+\n+      // Add the placeholder element, but only if the placeholder string we found matches\n+      // the uniqueId we generated earlier for that placeholder.\n+      if (this._placeholderKeys.get(match[1]) === match[0]) {\n+        parts.push(this._placeholderElements.get(match[1]));\n+      }\n+\n+      currentIndex = match.index + match[0].length;\n+    }\n+\n+    // Add remaining text if any\n+    if (currentIndex < text.length) {\n+      parts.push(text.slice(currentIndex));\n+    }\n+\n+    return parts;\n+  }\n+\n+  /**\n+   * Creates a curried TranslationPlaceholder component for a specific placeholder.\n+   * This allows the placeholder component to be passed to the template's named block\n+   * with the placeholder name already bound.\n+   *\n+   * @param {String} placeholder - The name of the placeholder to create a component for\n+   * @returns {Component} A curried TranslationPlaceholder component with the placeholder name bound\n+   */\n+  @action\n+  placeholderElement(placeholder) {\n+    return curryComponent(\n+      TranslationPlaceholder,\n+      { placeholder, markAsRendered: this.markAsRendered },\n+      getOwner(this)\n+    );\n+  }\n+\n+  /**\n+   * Marks a placeholder as having been rendered with content.\n+   * Called by the TranslationPlaceholder component when it renders.\n+   *\n+   * @param {String} name - The name of the placeholder that has been rendered\n+   */\n+  @action\n+  markAsRendered(name) {\n+    this._renderedPlaceholders.push(name);\n+  }\n+\n+  /**\n+   * Checks for any placeholders that were expected but not provided in the template, then\n+   * inserts a warning message where that placeholder was supposed to be.\n+   */\n+  @action\n+  checkPlaceholders() {\n+    let missing = [];\n+    for (const [name, element] of this._placeholderElements) {\n+      if (!this._renderedPlaceholders.includes(name)) {\n+        const message = `[missing ${this._placeholderAppearance.get(\n+          name\n+        )} placeholder]`;\n+        element.innerText = message;\n+        missing.push(message);\n+      }\n+    }\n+\n+    if (!isProduction() && missing.length > 0) {\n+      throw new I18nMissingInterpolationArgument(\n+        `${this.args.scope}: ${missing.join(\", \")}`\n+      );\n+    }\n+  }\n+\n+  <template>\n+    {{#each this.textAndPlaceholders as |segment|}}\n+      {{segment}}\n+    {{/each}}\n+\n+    {{#each-in\n+      this._placeholderElements\n+      as |placeholderKey placeholderElement|\n+    }}\n+      {{#in-element placeholderElement}}\n+        {{yield (this.placeholderElement placeholderKey) to=\"placeholders\"}}\n+      {{/in-element}}\n+    {{/each-in}}",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2143744876",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33082,
        "pr_file": "app/assets/javascripts/discourse/app/components/translation.gjs",
        "discussion_id": "2143744876",
        "commented_code": "@@ -0,0 +1,213 @@\n+import Component from \"@glimmer/component\";\n+import { action } from \"@ember/object\";\n+import { getOwner } from \"@ember/owner\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import curryComponent from \"ember-curry-component\";\n+import TranslationPlaceholder from \"discourse/components/translation-placeholder\";\n+import uniqueId from \"discourse/helpers/unique-id\";\n+import { isProduction } from \"discourse/lib/environment\";\n+import I18n, { i18n, I18nMissingInterpolationArgument } from \"discourse-i18n\";\n+\n+/**\n+ * Provides the ability to interpolate both strings and components into translatable strings.\n+ * This component allows for complex i18n scenarios where you need to embed interactive\n+ * components within translated text.\n+ *\n+ * If you don't require this functionality, use the standard i18n() function.\n+ *\n+ * @component Translation\n+ *\n+ * @template Usage example:\n+ * ```gjs\n+ * // Translation key: \"some.translation.key\" = \"Welcome, %{username}! The date is %{shortdate}!\"\n+ * <Translation\n+ *   @scope=\"some.translation.key\"\n+ *   @options={{hash shortdate=shortDate}}\n+ * >\n+ *   <:placeholders as |Placeholder|>\n+ *     <Placeholder @name=\"username\">\n+ *       <UserLink @user={{user}}>{{user.username}}</UserLink>\n+ *     </Placeholder>\n+ *   </:placeholders>\n+ * </Translation>\n+ * ```\n+ *\n+ * @param {String} scope - The i18n translation key to use\n+ * @param {Object} [options] - Hash of options to pass to the i18n function for string interpolation\n+ */\n+export default class Translation extends Component {\n+  /**\n+   * A map of placeholder keys to their unique identifiers.\n+   *\n+   * @type {Map<String, String>}\n+   */\n+  _placeholderKeys = new Map();\n+\n+  /**\n+   * A map of placeholder keys to their corresponding DOM elements.\n+   *\n+   * @type {Map<String, HTMLElement>}\n+   */\n+  _placeholderElements = new Map();\n+\n+  /**\n+   * A map of placeholder keys to their appearance in the translation string.\n+   *\n+   * @type {Map<String, String>}\n+   */\n+  _placeholderAppearance = new Map();\n+\n+  /**\n+   * Tracks which placeholders have been rendered.\n+   *\n+   * @type {Array<String>}\n+   */\n+  _renderedPlaceholders = [];\n+\n+  /**\n+   * Processes the translation string and returns an array of text segments and\n+   * placeholder elements that can be rendered in the template.\n+   *\n+   * @returns {Array<String|HTMLElement>} Array of text segments and placeholder elements\n+   */\n+  get textAndPlaceholders() {\n+    const optionsArg = this.args.options || {};\n+\n+    // Find all of the placeholders in the string we're looking at.\n+    const message = I18n.findTranslationWithFallback(this.args.scope, {\n+      ...optionsArg,\n+    });\n+    this._placeholderAppearance = I18n.findPlaceholders(message);\n+\n+    // We only need to keep the placeholders that aren't being handled by those passed in @options.\n+    Object.keys(optionsArg).forEach((stringPlaceholder) =>\n+      this._placeholderAppearance.delete(stringPlaceholder)\n+    );\n+\n+    this._placeholderAppearance.forEach((_, placeholderName) => {\n+      this._placeholderKeys.set(\n+        placeholderName,\n+        `__PLACEHOLDER__${placeholderName}__${uniqueId()}__`\n+      );\n+      this._placeholderElements.set(\n+        placeholderName,\n+        document.createElement(\"span\")\n+      );\n+    });\n+\n+    const text = i18n(this.args.scope, {\n+      ...Object.fromEntries(this._placeholderKeys),\n+      ...optionsArg,\n+    });\n+\n+    if (text === I18n.missingTranslation(this.args.scope)) {\n+      return [text];\n+    }\n+\n+    // Bail early if there were no placeholders we need to handle.\n+    if (this._placeholderAppearance.size === 0) {\n+      if (isProduction()) {\n+        return [text];\n+      } else {\n+        throw new Error(\n+          \"The <Translation> component shouldn't be used for strings that don't insert components. Use `i18n()` instead.\"\n+        );\n+      }\n+    }\n+\n+    const parts = [];\n+    let currentIndex = 0;\n+    const placeholderRegex = /__PLACEHOLDER__([^_]+)__[^_]+__/g;\n+    let match;\n+\n+    while ((match = placeholderRegex.exec(text)) !== null) {\n+      // Add text before placeholder if exists\n+      if (match.index > currentIndex) {\n+        parts.push(text.slice(currentIndex, match.index));\n+      }\n+\n+      // Add the placeholder element, but only if the placeholder string we found matches\n+      // the uniqueId we generated earlier for that placeholder.\n+      if (this._placeholderKeys.get(match[1]) === match[0]) {\n+        parts.push(this._placeholderElements.get(match[1]));\n+      }\n+\n+      currentIndex = match.index + match[0].length;\n+    }\n+\n+    // Add remaining text if any\n+    if (currentIndex < text.length) {\n+      parts.push(text.slice(currentIndex));\n+    }\n+\n+    return parts;\n+  }\n+\n+  /**\n+   * Creates a curried TranslationPlaceholder component for a specific placeholder.\n+   * This allows the placeholder component to be passed to the template's named block\n+   * with the placeholder name already bound.\n+   *\n+   * @param {String} placeholder - The name of the placeholder to create a component for\n+   * @returns {Component} A curried TranslationPlaceholder component with the placeholder name bound\n+   */\n+  @action\n+  placeholderElement(placeholder) {\n+    return curryComponent(\n+      TranslationPlaceholder,\n+      { placeholder, markAsRendered: this.markAsRendered },\n+      getOwner(this)\n+    );\n+  }\n+\n+  /**\n+   * Marks a placeholder as having been rendered with content.\n+   * Called by the TranslationPlaceholder component when it renders.\n+   *\n+   * @param {String} name - The name of the placeholder that has been rendered\n+   */\n+  @action\n+  markAsRendered(name) {\n+    this._renderedPlaceholders.push(name);\n+  }\n+\n+  /**\n+   * Checks for any placeholders that were expected but not provided in the template, then\n+   * inserts a warning message where that placeholder was supposed to be.\n+   */\n+  @action\n+  checkPlaceholders() {\n+    let missing = [];\n+    for (const [name, element] of this._placeholderElements) {\n+      if (!this._renderedPlaceholders.includes(name)) {\n+        const message = `[missing ${this._placeholderAppearance.get(\n+          name\n+        )} placeholder]`;\n+        element.innerText = message;\n+        missing.push(message);\n+      }\n+    }\n+\n+    if (!isProduction() && missing.length > 0) {\n+      throw new I18nMissingInterpolationArgument(\n+        `${this.args.scope}: ${missing.join(\", \")}`\n+      );\n+    }\n+  }\n+\n+  <template>\n+    {{#each this.textAndPlaceholders as |segment|}}\n+      {{segment}}\n+    {{/each}}\n+\n+    {{#each-in\n+      this._placeholderElements\n+      as |placeholderKey placeholderElement|\n+    }}\n+      {{#in-element placeholderElement}}\n+        {{yield (this.placeholderElement placeholderKey) to=\"placeholders\"}}\n+      {{/in-element}}\n+    {{/each-in}}",
        "comment_created_at": "2025-06-12T22:14:55+00:00",
        "comment_author": "davidtaylorhq",
        "comment_body": "This means that you're rendering every Placeholder in every position. So if there are 5 placeholders in the translation, you're gonna be rendering 25 copies of `TranslationPlaceholder` (most of which wouldn't actually render anything visible).\r\n\r\nI think it would be cleaner to flip things around. So you `yield` once, and you make the `TranslationPlaceholder` component take care of the `{{#in-element}}`. So something like\r\n\r\n\r\n```gjs\r\nget curriedPlaceholderComponent(){\r\n  return curryComponent(\r\n      TranslationPlaceholder,\r\n      { placeholder, markAsRendered: this.markAsRendered, elements: this._placeholderElements },\r\n      getOwner(this)\r\n    );\r\n}\r\n\r\n<template>\r\n   ...\r\n   \r\n   {{yield this.curriedPlaceholderComponent}}\r\n</template>\r\n```\r\n\r\nAnd then `TranslationPlaceholder` would do something like\r\n\r\n```gjs\r\n<template>\r\n  {{#in-element (get @elements @name)}}\r\n    {{yield}}\r\n  {{/in-element}}\r\n</template>\r\n```\r\n\r\nThat way, if there are 5 placeholders, only 5 components will be initialized & rendered.",
        "pr_file_module": null
      }
    ]
  }
]