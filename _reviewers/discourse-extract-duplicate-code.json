[
  {
    "discussion_id": "2286868701",
    "pr_number": 34400,
    "pr_file": "lib/topics_filter.rb",
    "created_at": "2025-08-20T03:09:34+00:00",
    "commented_code": "filter_by_topic_range(column_name: \"topics.views\", min:, max:)\n   end\n \n+  # users:a,b => any of a or b participated in the topic\n+  # users:a+b => both a and b participated in the topic\n+  def filter_users(values:)\n+    values.each do |value|\n+      if value.include?(\"+\")\n+        usernames = value.split(\"+\")\n+        require_all = true\n+        if value.include?(\",\")\n+          # no mix and match\n+          @scope = @scope.none\n+          next\n+        end\n+      else\n+        usernames = value.split(\",\")\n+        require_all = false\n+        if value.include?(\"+\")\n+          # no mix and match\n+          @scope = @scope.none\n+          next\n+        end\n+      end\n+\n+      usernames = usernames.map(&:downcase).reject(&:blank?)\n+\n+      if usernames.empty?\n+        @scope = @scope.none\n+        next\n+      end\n+\n+      user_ids = User.where(staged: false).where(\"username_lower IN (?)\", usernames).pluck(:id)\n+\n+      if user_ids.empty?\n+        @scope = @scope.none\n+        next\n+      end\n+\n+      if require_all\n+        if user_ids.length < usernames.length\n+          @scope = @scope.none\n+          next\n+        end\n+\n+        # A possible alternative is to select the topics with the users with the least posts\n+        # then expand to all of the rest of the users, this can limit the scanning\n+        user_ids.each_with_index { |uid, idx| @scope = @scope.where(<<~SQL) }\n+            EXISTS (\n+              SELECT 1\n+              FROM posts p#{idx}\n+              WHERE p#{idx}.topic_id = topics.id AND p#{idx}.user_id = #{uid}\n+              LIMIT 1\n+            )\n+          SQL\n+      else\n+        @scope = @scope.where(<<~SQL, user_ids: user_ids)\n+              topics.id IN (\n+                SELECT DISTINCT p.topic_id\n+                FROM posts p\n+                WHERE p.user_id IN (:user_ids)\n+              )\n+            SQL\n+      end\n+    end\n+  end\n+\n+  # group:staff,moderators => any of the groups have participation\n+  # group:staff+moderators => both groups have participation\n+  def filter_groups(values:)\n+    values.each do |value|",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2286868701",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34400,
        "pr_file": "lib/topics_filter.rb",
        "discussion_id": "2286868701",
        "commented_code": "@@ -388,6 +419,138 @@ def filter_by_number_of_views(min: nil, max: nil)\n     filter_by_topic_range(column_name: \"topics.views\", min:, max:)\n   end\n \n+  # users:a,b => any of a or b participated in the topic\n+  # users:a+b => both a and b participated in the topic\n+  def filter_users(values:)\n+    values.each do |value|\n+      if value.include?(\"+\")\n+        usernames = value.split(\"+\")\n+        require_all = true\n+        if value.include?(\",\")\n+          # no mix and match\n+          @scope = @scope.none\n+          next\n+        end\n+      else\n+        usernames = value.split(\",\")\n+        require_all = false\n+        if value.include?(\"+\")\n+          # no mix and match\n+          @scope = @scope.none\n+          next\n+        end\n+      end\n+\n+      usernames = usernames.map(&:downcase).reject(&:blank?)\n+\n+      if usernames.empty?\n+        @scope = @scope.none\n+        next\n+      end\n+\n+      user_ids = User.where(staged: false).where(\"username_lower IN (?)\", usernames).pluck(:id)\n+\n+      if user_ids.empty?\n+        @scope = @scope.none\n+        next\n+      end\n+\n+      if require_all\n+        if user_ids.length < usernames.length\n+          @scope = @scope.none\n+          next\n+        end\n+\n+        # A possible alternative is to select the topics with the users with the least posts\n+        # then expand to all of the rest of the users, this can limit the scanning\n+        user_ids.each_with_index { |uid, idx| @scope = @scope.where(<<~SQL) }\n+            EXISTS (\n+              SELECT 1\n+              FROM posts p#{idx}\n+              WHERE p#{idx}.topic_id = topics.id AND p#{idx}.user_id = #{uid}\n+              LIMIT 1\n+            )\n+          SQL\n+      else\n+        @scope = @scope.where(<<~SQL, user_ids: user_ids)\n+              topics.id IN (\n+                SELECT DISTINCT p.topic_id\n+                FROM posts p\n+                WHERE p.user_id IN (:user_ids)\n+              )\n+            SQL\n+      end\n+    end\n+  end\n+\n+  # group:staff,moderators => any of the groups have participation\n+  # group:staff+moderators => both groups have participation\n+  def filter_groups(values:)\n+    values.each do |value|",
        "comment_created_at": "2025-08-20T03:09:34+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "I think this `values.each` code could be split out into a `calculate_all_or_any_scope` method or something, since it does the exact same thing for groups and users",
        "pr_file_module": null
      },
      {
        "comment_id": "2287007350",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34400,
        "pr_file": "lib/topics_filter.rb",
        "discussion_id": "2286868701",
        "commented_code": "@@ -388,6 +419,138 @@ def filter_by_number_of_views(min: nil, max: nil)\n     filter_by_topic_range(column_name: \"topics.views\", min:, max:)\n   end\n \n+  # users:a,b => any of a or b participated in the topic\n+  # users:a+b => both a and b participated in the topic\n+  def filter_users(values:)\n+    values.each do |value|\n+      if value.include?(\"+\")\n+        usernames = value.split(\"+\")\n+        require_all = true\n+        if value.include?(\",\")\n+          # no mix and match\n+          @scope = @scope.none\n+          next\n+        end\n+      else\n+        usernames = value.split(\",\")\n+        require_all = false\n+        if value.include?(\"+\")\n+          # no mix and match\n+          @scope = @scope.none\n+          next\n+        end\n+      end\n+\n+      usernames = usernames.map(&:downcase).reject(&:blank?)\n+\n+      if usernames.empty?\n+        @scope = @scope.none\n+        next\n+      end\n+\n+      user_ids = User.where(staged: false).where(\"username_lower IN (?)\", usernames).pluck(:id)\n+\n+      if user_ids.empty?\n+        @scope = @scope.none\n+        next\n+      end\n+\n+      if require_all\n+        if user_ids.length < usernames.length\n+          @scope = @scope.none\n+          next\n+        end\n+\n+        # A possible alternative is to select the topics with the users with the least posts\n+        # then expand to all of the rest of the users, this can limit the scanning\n+        user_ids.each_with_index { |uid, idx| @scope = @scope.where(<<~SQL) }\n+            EXISTS (\n+              SELECT 1\n+              FROM posts p#{idx}\n+              WHERE p#{idx}.topic_id = topics.id AND p#{idx}.user_id = #{uid}\n+              LIMIT 1\n+            )\n+          SQL\n+      else\n+        @scope = @scope.where(<<~SQL, user_ids: user_ids)\n+              topics.id IN (\n+                SELECT DISTINCT p.topic_id\n+                FROM posts p\n+                WHERE p.user_id IN (:user_ids)\n+              )\n+            SQL\n+      end\n+    end\n+  end\n+\n+  # group:staff,moderators => any of the groups have participation\n+  # group:staff+moderators => both groups have participation\n+  def filter_groups(values:)\n+    values.each do |value|",
        "comment_created_at": "2025-08-20T05:18:10+00:00",
        "comment_author": "SamSaffron",
        "comment_body": "hmm having a look ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2281189141",
    "pr_number": 34368,
    "pr_file": "plugins/poll/lib/post_extension.rb",
    "created_at": "2025-08-18T02:54:09+00:00",
    "commented_code": "post = self\n \n         ::Poll.transaction do\n-          polls.values.each { |poll| DiscoursePoll::Poll.create!(post.id, poll) }\n+          dynamic_map = post.custom_fields[DiscoursePoll::DYNAMIC_POLLS]\n+          dynamic_map =",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2281189141",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34368,
        "pr_file": "plugins/poll/lib/post_extension.rb",
        "discussion_id": "2281189141",
        "commented_code": "@@ -16,8 +16,29 @@ module PostExtension\n         post = self\n \n         ::Poll.transaction do\n-          polls.values.each { |poll| DiscoursePoll::Poll.create!(post.id, poll) }\n+          dynamic_map = post.custom_fields[DiscoursePoll::DYNAMIC_POLLS]\n+          dynamic_map =",
        "comment_created_at": "2025-08-18T02:54:09+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "We are repeating this same poll Hash/JSON boilerplate here...can we add something like `Poll.dynamic_map(post)` that just gives the right thing for here and the `PollUpdater`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178875662",
    "pr_number": 33092,
    "pr_file": "app/services/video_conversion/aws_media_convert_adapter.rb",
    "created_at": "2025-07-02T02:44:07+00:00",
    "commented_code": "+# frozen_string_literal: true\n+require \"aws-sdk-mediaconvert\"\n+\n+module VideoConversion\n+  class AwsMediaConvertAdapter < BaseAdapter\n+    def convert\n+      return false unless valid_settings?\n+\n+      begin\n+        new_sha1 = SecureRandom.hex(20)\n+        output_path = \"optimized/videos/#{new_sha1}\"\n+\n+        # Extract the path from the URL\n+        # The URL format is: //bucket.s3.dualstack.region.amazonaws.com/path/to/file\n+        # or: //bucket.s3.region.amazonaws.com/path/to/file\n+        url = @upload.url.sub(%r{^//}, \"\") # Remove leading //\n+\n+        # Split on the first / to separate the domain from the path\n+        domain, path = url.split(\"/\", 2)\n+\n+        # Verify the domain contains our bucket\n+        unless domain&.include?(SiteSetting.s3_upload_bucket)\n+          raise Discourse::InvalidParameters.new(\n+                  \"Upload URL domain does not contain expected bucket name: #{SiteSetting.s3_upload_bucket}\",\n+                )\n+        end\n+\n+        input_path = \"s3://#{SiteSetting.s3_upload_bucket}/#{path}\"\n+        settings = build_conversion_settings(input_path, output_path)\n+\n+        begin\n+          response =\n+            mediaconvert_client.create_job(\n+              role: SiteSetting.mediaconvert_role_arn,\n+              settings: settings,\n+              status_update_interval: \"SECONDS_10\",\n+              user_metadata: {\n+                \"upload_id\" => @upload.id.to_s,\n+                \"new_sha1\" => new_sha1,\n+                \"output_path\" => output_path,\n+              },\n+            )\n+\n+          # Enqueue status check job\n+          Jobs.enqueue_in(\n+            30.seconds,\n+            :check_video_conversion_status,\n+            upload_id: @upload.id,\n+            job_id: response.job.id,\n+            new_sha1: new_sha1,\n+            output_path: output_path,\n+            original_filename: @upload.original_filename,\n+            user_id: @upload.user_id,\n+            adapter_type: \"aws_mediaconvert\",\n+          )\n+\n+          true # Return true on success\n+        rescue Aws::MediaConvert::Errors::ServiceError => e\n+          Rails.logger.error(\n+            \"MediaConvert job creation failed for upload #{@upload.id}. \" \\\n+              \"Error: #{e.class.name} - #{e.message}\" \\\n+              \"#{e.respond_to?(:code) ? \" (Code: #{e.code})\" : \"\"}\" \\\n+              \"#{e.respond_to?(:context) ? \" (Request ID: #{e.context.request_id})\" : \"\"}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"MediaConvert job creation failed\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        rescue => e\n+          Rails.logger.error(\n+            \"Unexpected error creating MediaConvert job for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"Unexpected error in MediaConvert job creation\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        end\n+      rescue Discourse::InvalidParameters => e\n+        Rails.logger.error(\"Invalid parameters for upload #{@upload.id}: #{e.message}\")\n+        false\n+      rescue => e\n+        Rails.logger.error(\n+          \"Unexpected error in video conversion for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Unexpected error in video conversion\",\n+          env: {\n+            upload_id: @upload.id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    def check_status(job_id)\n+      response = mediaconvert_client.get_job(id: job_id)\n+\n+      case response.job.status\n+      when \"COMPLETE\"\n+        :complete\n+      when \"ERROR\"\n+        Rails.logger.error(\"MediaConvert job #{job_id} failed\")\n+        :error\n+      when \"SUBMITTED\", \"PROGRESSING\"\n+        :pending\n+      else\n+        Rails.logger.warn(\n+          \"Unexpected MediaConvert job status for job #{job_id}: #{response.job.status}\",\n+        )\n+        :error\n+      end\n+    end\n+\n+    def handle_completion(job_id, output_path, new_sha1)\n+      s3_store = FileStore::S3Store.new\n+      path = \"#{output_path}.mp4\"\n+      object = s3_store.object_from_path(path)\n+\n+      return false unless object&.exists?\n+\n+      begin\n+        optimized_video =\n+          create_optimized_video_record(\n+            output_path,\n+            new_sha1,\n+            object.size,\n+            \"//#{s3_store.s3_bucket}.s3.dualstack.#{SiteSetting.s3_region}.amazonaws.com/#{path}\",\n+          )\n+\n+        if optimized_video\n+          update_posts_with_optimized_video\n+          true\n+        else\n+          Rails.logger.error(\"Failed to create OptimizedVideo record for upload #{@upload.id}\")\n+          false\n+        end\n+      rescue => e\n+        Rails.logger.error(\n+          \"Error processing video completion for upload #{@upload.id}: #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Error in video processing completion\",\n+          env: {\n+            upload_id: @upload.id,\n+            job_id: job_id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    private\n+\n+    def valid_settings?\n+      SiteSetting.video_conversion_enabled && SiteSetting.mediaconvert_role_arn.present? &&\n+        SiteSetting.mediaconvert_endpoint.present?\n+    end\n+\n+    def mediaconvert_client\n+      @mediaconvert_client ||=\n+        begin\n+          # For some reason the endpoint is not visible in the aws console UI so we need to get it from the API\n+          if SiteSetting.mediaconvert_endpoint.blank?",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2178875662",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/services/video_conversion/aws_media_convert_adapter.rb",
        "discussion_id": "2178875662",
        "commented_code": "@@ -0,0 +1,267 @@\n+# frozen_string_literal: true\n+require \"aws-sdk-mediaconvert\"\n+\n+module VideoConversion\n+  class AwsMediaConvertAdapter < BaseAdapter\n+    def convert\n+      return false unless valid_settings?\n+\n+      begin\n+        new_sha1 = SecureRandom.hex(20)\n+        output_path = \"optimized/videos/#{new_sha1}\"\n+\n+        # Extract the path from the URL\n+        # The URL format is: //bucket.s3.dualstack.region.amazonaws.com/path/to/file\n+        # or: //bucket.s3.region.amazonaws.com/path/to/file\n+        url = @upload.url.sub(%r{^//}, \"\") # Remove leading //\n+\n+        # Split on the first / to separate the domain from the path\n+        domain, path = url.split(\"/\", 2)\n+\n+        # Verify the domain contains our bucket\n+        unless domain&.include?(SiteSetting.s3_upload_bucket)\n+          raise Discourse::InvalidParameters.new(\n+                  \"Upload URL domain does not contain expected bucket name: #{SiteSetting.s3_upload_bucket}\",\n+                )\n+        end\n+\n+        input_path = \"s3://#{SiteSetting.s3_upload_bucket}/#{path}\"\n+        settings = build_conversion_settings(input_path, output_path)\n+\n+        begin\n+          response =\n+            mediaconvert_client.create_job(\n+              role: SiteSetting.mediaconvert_role_arn,\n+              settings: settings,\n+              status_update_interval: \"SECONDS_10\",\n+              user_metadata: {\n+                \"upload_id\" => @upload.id.to_s,\n+                \"new_sha1\" => new_sha1,\n+                \"output_path\" => output_path,\n+              },\n+            )\n+\n+          # Enqueue status check job\n+          Jobs.enqueue_in(\n+            30.seconds,\n+            :check_video_conversion_status,\n+            upload_id: @upload.id,\n+            job_id: response.job.id,\n+            new_sha1: new_sha1,\n+            output_path: output_path,\n+            original_filename: @upload.original_filename,\n+            user_id: @upload.user_id,\n+            adapter_type: \"aws_mediaconvert\",\n+          )\n+\n+          true # Return true on success\n+        rescue Aws::MediaConvert::Errors::ServiceError => e\n+          Rails.logger.error(\n+            \"MediaConvert job creation failed for upload #{@upload.id}. \" \\\n+              \"Error: #{e.class.name} - #{e.message}\" \\\n+              \"#{e.respond_to?(:code) ? \" (Code: #{e.code})\" : \"\"}\" \\\n+              \"#{e.respond_to?(:context) ? \" (Request ID: #{e.context.request_id})\" : \"\"}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"MediaConvert job creation failed\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        rescue => e\n+          Rails.logger.error(\n+            \"Unexpected error creating MediaConvert job for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"Unexpected error in MediaConvert job creation\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        end\n+      rescue Discourse::InvalidParameters => e\n+        Rails.logger.error(\"Invalid parameters for upload #{@upload.id}: #{e.message}\")\n+        false\n+      rescue => e\n+        Rails.logger.error(\n+          \"Unexpected error in video conversion for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Unexpected error in video conversion\",\n+          env: {\n+            upload_id: @upload.id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    def check_status(job_id)\n+      response = mediaconvert_client.get_job(id: job_id)\n+\n+      case response.job.status\n+      when \"COMPLETE\"\n+        :complete\n+      when \"ERROR\"\n+        Rails.logger.error(\"MediaConvert job #{job_id} failed\")\n+        :error\n+      when \"SUBMITTED\", \"PROGRESSING\"\n+        :pending\n+      else\n+        Rails.logger.warn(\n+          \"Unexpected MediaConvert job status for job #{job_id}: #{response.job.status}\",\n+        )\n+        :error\n+      end\n+    end\n+\n+    def handle_completion(job_id, output_path, new_sha1)\n+      s3_store = FileStore::S3Store.new\n+      path = \"#{output_path}.mp4\"\n+      object = s3_store.object_from_path(path)\n+\n+      return false unless object&.exists?\n+\n+      begin\n+        optimized_video =\n+          create_optimized_video_record(\n+            output_path,\n+            new_sha1,\n+            object.size,\n+            \"//#{s3_store.s3_bucket}.s3.dualstack.#{SiteSetting.s3_region}.amazonaws.com/#{path}\",\n+          )\n+\n+        if optimized_video\n+          update_posts_with_optimized_video\n+          true\n+        else\n+          Rails.logger.error(\"Failed to create OptimizedVideo record for upload #{@upload.id}\")\n+          false\n+        end\n+      rescue => e\n+        Rails.logger.error(\n+          \"Error processing video completion for upload #{@upload.id}: #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Error in video processing completion\",\n+          env: {\n+            upload_id: @upload.id,\n+            job_id: job_id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    private\n+\n+    def valid_settings?\n+      SiteSetting.video_conversion_enabled && SiteSetting.mediaconvert_role_arn.present? &&\n+        SiteSetting.mediaconvert_endpoint.present?\n+    end\n+\n+    def mediaconvert_client\n+      @mediaconvert_client ||=\n+        begin\n+          # For some reason the endpoint is not visible in the aws console UI so we need to get it from the API\n+          if SiteSetting.mediaconvert_endpoint.blank?",
        "comment_created_at": "2025-07-02T02:44:07+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "Wouldn't this not get hit if `!valid_settings?` when calling `convert`?\n\nAlso this does feel a little repetitive, can we just declare the `client ` once with ` Aws::MediaConvert::Client.new`, then after the endpoint is fetched can we do something like `client.endpoint = SiteSetting.mediaconvert_endpoint` ? Or is that not possible?\n\nIf not then maybe a `build_client` method called from here would cut down on repetition:\n\n```ruby\nbuild_client(endpoint: nil)\n  Aws::MediaConvert::Client.new(\n    region: SiteSetting.s3_region,\n     credentials:\n              Aws::Credentials.new(SiteSetting.s3_access_key_id, SiteSetting.s3_secret_access_key),\n      endpoint: endpoint\n  )\nend\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2193327206",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/services/video_conversion/aws_media_convert_adapter.rb",
        "discussion_id": "2178875662",
        "commented_code": "@@ -0,0 +1,267 @@\n+# frozen_string_literal: true\n+require \"aws-sdk-mediaconvert\"\n+\n+module VideoConversion\n+  class AwsMediaConvertAdapter < BaseAdapter\n+    def convert\n+      return false unless valid_settings?\n+\n+      begin\n+        new_sha1 = SecureRandom.hex(20)\n+        output_path = \"optimized/videos/#{new_sha1}\"\n+\n+        # Extract the path from the URL\n+        # The URL format is: //bucket.s3.dualstack.region.amazonaws.com/path/to/file\n+        # or: //bucket.s3.region.amazonaws.com/path/to/file\n+        url = @upload.url.sub(%r{^//}, \"\") # Remove leading //\n+\n+        # Split on the first / to separate the domain from the path\n+        domain, path = url.split(\"/\", 2)\n+\n+        # Verify the domain contains our bucket\n+        unless domain&.include?(SiteSetting.s3_upload_bucket)\n+          raise Discourse::InvalidParameters.new(\n+                  \"Upload URL domain does not contain expected bucket name: #{SiteSetting.s3_upload_bucket}\",\n+                )\n+        end\n+\n+        input_path = \"s3://#{SiteSetting.s3_upload_bucket}/#{path}\"\n+        settings = build_conversion_settings(input_path, output_path)\n+\n+        begin\n+          response =\n+            mediaconvert_client.create_job(\n+              role: SiteSetting.mediaconvert_role_arn,\n+              settings: settings,\n+              status_update_interval: \"SECONDS_10\",\n+              user_metadata: {\n+                \"upload_id\" => @upload.id.to_s,\n+                \"new_sha1\" => new_sha1,\n+                \"output_path\" => output_path,\n+              },\n+            )\n+\n+          # Enqueue status check job\n+          Jobs.enqueue_in(\n+            30.seconds,\n+            :check_video_conversion_status,\n+            upload_id: @upload.id,\n+            job_id: response.job.id,\n+            new_sha1: new_sha1,\n+            output_path: output_path,\n+            original_filename: @upload.original_filename,\n+            user_id: @upload.user_id,\n+            adapter_type: \"aws_mediaconvert\",\n+          )\n+\n+          true # Return true on success\n+        rescue Aws::MediaConvert::Errors::ServiceError => e\n+          Rails.logger.error(\n+            \"MediaConvert job creation failed for upload #{@upload.id}. \" \\\n+              \"Error: #{e.class.name} - #{e.message}\" \\\n+              \"#{e.respond_to?(:code) ? \" (Code: #{e.code})\" : \"\"}\" \\\n+              \"#{e.respond_to?(:context) ? \" (Request ID: #{e.context.request_id})\" : \"\"}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"MediaConvert job creation failed\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        rescue => e\n+          Rails.logger.error(\n+            \"Unexpected error creating MediaConvert job for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"Unexpected error in MediaConvert job creation\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        end\n+      rescue Discourse::InvalidParameters => e\n+        Rails.logger.error(\"Invalid parameters for upload #{@upload.id}: #{e.message}\")\n+        false\n+      rescue => e\n+        Rails.logger.error(\n+          \"Unexpected error in video conversion for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Unexpected error in video conversion\",\n+          env: {\n+            upload_id: @upload.id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    def check_status(job_id)\n+      response = mediaconvert_client.get_job(id: job_id)\n+\n+      case response.job.status\n+      when \"COMPLETE\"\n+        :complete\n+      when \"ERROR\"\n+        Rails.logger.error(\"MediaConvert job #{job_id} failed\")\n+        :error\n+      when \"SUBMITTED\", \"PROGRESSING\"\n+        :pending\n+      else\n+        Rails.logger.warn(\n+          \"Unexpected MediaConvert job status for job #{job_id}: #{response.job.status}\",\n+        )\n+        :error\n+      end\n+    end\n+\n+    def handle_completion(job_id, output_path, new_sha1)\n+      s3_store = FileStore::S3Store.new\n+      path = \"#{output_path}.mp4\"\n+      object = s3_store.object_from_path(path)\n+\n+      return false unless object&.exists?\n+\n+      begin\n+        optimized_video =\n+          create_optimized_video_record(\n+            output_path,\n+            new_sha1,\n+            object.size,\n+            \"//#{s3_store.s3_bucket}.s3.dualstack.#{SiteSetting.s3_region}.amazonaws.com/#{path}\",\n+          )\n+\n+        if optimized_video\n+          update_posts_with_optimized_video\n+          true\n+        else\n+          Rails.logger.error(\"Failed to create OptimizedVideo record for upload #{@upload.id}\")\n+          false\n+        end\n+      rescue => e\n+        Rails.logger.error(\n+          \"Error processing video completion for upload #{@upload.id}: #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Error in video processing completion\",\n+          env: {\n+            upload_id: @upload.id,\n+            job_id: job_id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    private\n+\n+    def valid_settings?\n+      SiteSetting.video_conversion_enabled && SiteSetting.mediaconvert_role_arn.present? &&\n+        SiteSetting.mediaconvert_endpoint.present?\n+    end\n+\n+    def mediaconvert_client\n+      @mediaconvert_client ||=\n+        begin\n+          # For some reason the endpoint is not visible in the aws console UI so we need to get it from the API\n+          if SiteSetting.mediaconvert_endpoint.blank?",
        "comment_created_at": "2025-07-08T19:50:15+00:00",
        "comment_author": "blake-discourse",
        "comment_body": "good catch about valid_settings, I think I made this refactor after I already set my endpoint so it wasn't an issue, will fix.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224271346",
    "pr_number": 33092,
    "pr_file": "app/services/video_conversion/aws_media_convert_adapter.rb",
    "created_at": "2025-07-23T03:49:28+00:00",
    "commented_code": "+# frozen_string_literal: true\n+require \"aws-sdk-mediaconvert\"\n+\n+module VideoConversion\n+  class AwsMediaConvertAdapter < BaseAdapter\n+    ADAPTER_NAME = \"aws_mediaconvert\"\n+\n+    def convert\n+      return false if !valid_settings?\n+\n+      begin\n+        new_sha1 = SecureRandom.hex(20)\n+        output_path = \"original/1X/#{new_sha1}\"",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2224271346",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/services/video_conversion/aws_media_convert_adapter.rb",
        "discussion_id": "2224271346",
        "commented_code": "@@ -0,0 +1,266 @@\n+# frozen_string_literal: true\n+require \"aws-sdk-mediaconvert\"\n+\n+module VideoConversion\n+  class AwsMediaConvertAdapter < BaseAdapter\n+    ADAPTER_NAME = \"aws_mediaconvert\"\n+\n+    def convert\n+      return false if !valid_settings?\n+\n+      begin\n+        new_sha1 = SecureRandom.hex(20)\n+        output_path = \"original/1X/#{new_sha1}\"",
        "comment_created_at": "2025-07-23T03:49:28+00:00",
        "comment_author": "tgxworld",
        "comment_body": "It seems like we have some logic to derive the path for uploads in `FileStore::BaseStore`\n\nhttps://github.com/discourse/discourse/blob/ebf709f80109e3d738a35e70371881bbb615ffe6/lib/file_store/base_store.rb#L157\n\nGenerally, I'm wondering if we can lean on the logic in `UploadCreator` here instead instead of duplicating some of the logic in this adapter.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188796012",
    "pr_number": 33381,
    "pr_file": "spec/system/composer/prosemirror_editor_spec.rb",
    "created_at": "2025-07-07T01:31:37+00:00",
    "commented_code": ")\n     end\n   end\n+\n+  describe \"image toolbar\" do\n+    it \"shows image toolbar when image is selected\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      expect(rich).to have_css(\".composer-image-node img\")\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      expect(page).to have_css(\"[data-identifier='composer-image-toolbar']\")\n+      expect(page).to have_css(\".composer-image-toolbar__zoom-out\")\n+      expect(page).to have_css(\".composer-image-toolbar__zoom-in\")\n+      expect(page).to have_css(\".composer-image-toolbar__trash\")\n+    end\n+\n+    it \"allows scaling image down and up via toolbar\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      find(\".composer-image-toolbar__zoom-out\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"75\")\n+\n+      find(\".composer-image-toolbar__zoom-out\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"50\")\n+\n+      find(\".composer-image-toolbar__zoom-in\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"75\")\n+\n+      find(\".composer-image-toolbar__zoom-in\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"100\")\n+    end\n+\n+    it \"allows removing image via toolbar\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+\n+      composer.type_content(\"Before \")\n+      cdp.copy_test_image\n+      cdp.paste\n+      composer.type_content(\" After\")\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      find(\".composer-image-toolbar__trash\").click\n+\n+      expect(rich).to have_no_css(\".composer-image-node img\")\n+      expect(rich).to have_content(\"Before  After\")\n+    end\n+\n+    it \"hides toolbar when clicking outside image\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      expect(page).to have_css(\"[data-identifier='composer-image-toolbar']\")\n+\n+      rich.find(\"p\").click\n+\n+      expect(page).to have_no_css(\"[data-identifier='composer-image-toolbar']\")\n+    end\n+  end\n+\n+  describe \"image alt text display and editing\" do\n+    it \"shows alt text input when image is selected\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      rich.find(\".composer-image-node img\").click",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2188796012",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33381,
        "pr_file": "spec/system/composer/prosemirror_editor_spec.rb",
        "discussion_id": "2188796012",
        "commented_code": "@@ -1140,4 +1140,148 @@ def body(title)\n       )\n     end\n   end\n+\n+  describe \"image toolbar\" do\n+    it \"shows image toolbar when image is selected\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      expect(rich).to have_css(\".composer-image-node img\")\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      expect(page).to have_css(\"[data-identifier='composer-image-toolbar']\")\n+      expect(page).to have_css(\".composer-image-toolbar__zoom-out\")\n+      expect(page).to have_css(\".composer-image-toolbar__zoom-in\")\n+      expect(page).to have_css(\".composer-image-toolbar__trash\")\n+    end\n+\n+    it \"allows scaling image down and up via toolbar\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      find(\".composer-image-toolbar__zoom-out\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"75\")\n+\n+      find(\".composer-image-toolbar__zoom-out\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"50\")\n+\n+      find(\".composer-image-toolbar__zoom-in\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"75\")\n+\n+      find(\".composer-image-toolbar__zoom-in\").click\n+\n+      expect(rich.find(\".composer-image-node img\")[\"data-scale\"]).to eq(\"100\")\n+    end\n+\n+    it \"allows removing image via toolbar\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+\n+      composer.type_content(\"Before \")\n+      cdp.copy_test_image\n+      cdp.paste\n+      composer.type_content(\" After\")\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      find(\".composer-image-toolbar__trash\").click\n+\n+      expect(rich).to have_no_css(\".composer-image-node img\")\n+      expect(rich).to have_content(\"Before  After\")\n+    end\n+\n+    it \"hides toolbar when clicking outside image\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      rich.find(\".composer-image-node img\").click\n+\n+      expect(page).to have_css(\"[data-identifier='composer-image-toolbar']\")\n+\n+      rich.find(\"p\").click\n+\n+      expect(page).to have_no_css(\"[data-identifier='composer-image-toolbar']\")\n+    end\n+  end\n+\n+  describe \"image alt text display and editing\" do\n+    it \"shows alt text input when image is selected\" do\n+      cdp.allow_clipboard\n+      open_composer_and_toggle_rich_editor\n+      cdp.copy_test_image\n+      cdp.paste\n+\n+      rich.find(\".composer-image-node img\").click",
        "comment_created_at": "2025-07-07T01:31:37+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "These lines are repeated a ton in this test, maybe could move them into `prepare_image_node` method?",
        "pr_file_module": null
      }
    ]
  }
]