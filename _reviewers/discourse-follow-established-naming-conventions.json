[
  {
    "discussion_id": "2284083764",
    "pr_number": 33737,
    "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
    "created_at": "2025-08-19T05:17:44+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2284083764",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33737,
        "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
        "discussion_id": "2284083764",
        "commented_code": "@@ -0,0 +1,377 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {",
        "comment_created_at": "2025-08-19T05:17:44+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n  #buildGroupedEvents(detail) {\r\n```\r\n\r\nShould use native private, dev-xp wants this now not the fake `_` one",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284085785",
    "pr_number": 33737,
    "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
    "created_at": "2025-08-19T05:19:25+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {\n+    const event = this._buildEvent(detail);\n+    const holidayCalendarTopicId = parseInt(\n+      this.siteSettings.holiday_calendar_topic_id,\n+      10\n+    );\n+    const text = detail.message.split(\"\n\").filter((e) => e);\n+\n+    if (\n+      text.length &&\n+      this.args.post.topic_id &&\n+      holidayCalendarTopicId !== this.args.post.topic_id\n+    ) {\n+      event.title = text[0];\n+      event.extendedProps.description = text.slice(1).join(\" \");\n+    } else {\n+      const color = stringToColor(detail.username);\n+      event.title = detail.username;\n+      event.backgroundColor = colorToHex(color);\n+      event.textColor = contrastColor(color);\n+    }\n+\n+    let popupText = detail.message.slice(0, 100);\n+    if (detail.message.length > 100) {\n+      popupText += \"\u2026\";\n+    }\n+    event.extendedProps.htmlContent = htmlSafe(escapeExpression(popupText));\n+    event.title = event.title.replace(/<img[^>]*>/g, \"\");\n+    event.participantCount = 1;\n+\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    }\n+\n+    return event;\n+  }\n+\n+  _modifyDatesForTimezoneOffset(from, to, timezoneOffset) {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2284085785",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33737,
        "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
        "discussion_id": "2284085785",
        "commented_code": "@@ -0,0 +1,377 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {\n+    const event = this._buildEvent(detail);\n+    const holidayCalendarTopicId = parseInt(\n+      this.siteSettings.holiday_calendar_topic_id,\n+      10\n+    );\n+    const text = detail.message.split(\"\\n\").filter((e) => e);\n+\n+    if (\n+      text.length &&\n+      this.args.post.topic_id &&\n+      holidayCalendarTopicId !== this.args.post.topic_id\n+    ) {\n+      event.title = text[0];\n+      event.extendedProps.description = text.slice(1).join(\" \");\n+    } else {\n+      const color = stringToColor(detail.username);\n+      event.title = detail.username;\n+      event.backgroundColor = colorToHex(color);\n+      event.textColor = contrastColor(color);\n+    }\n+\n+    let popupText = detail.message.slice(0, 100);\n+    if (detail.message.length > 100) {\n+      popupText += \"\u2026\";\n+    }\n+    event.extendedProps.htmlContent = htmlSafe(escapeExpression(popupText));\n+    event.title = event.title.replace(/<img[^>]*>/g, \"\");\n+    event.participantCount = 1;\n+\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    }\n+\n+    return event;\n+  }\n+\n+  _modifyDatesForTimezoneOffset(from, to, timezoneOffset) {",
        "comment_created_at": "2025-08-19T05:19:25+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n  #modifyDatesForTimezoneOffset(from, to, timezoneOffset) {\r\n```\r\n\r\nShould use native private, dev-xp wants this now not the fake `_` one",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284086098",
    "pr_number": 33737,
    "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
    "created_at": "2025-08-19T05:19:39+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {\n+    const event = this._buildEvent(detail);\n+    const holidayCalendarTopicId = parseInt(\n+      this.siteSettings.holiday_calendar_topic_id,\n+      10\n+    );\n+    const text = detail.message.split(\"\n\").filter((e) => e);\n+\n+    if (\n+      text.length &&\n+      this.args.post.topic_id &&\n+      holidayCalendarTopicId !== this.args.post.topic_id\n+    ) {\n+      event.title = text[0];\n+      event.extendedProps.description = text.slice(1).join(\" \");\n+    } else {\n+      const color = stringToColor(detail.username);\n+      event.title = detail.username;\n+      event.backgroundColor = colorToHex(color);\n+      event.textColor = contrastColor(color);\n+    }\n+\n+    let popupText = detail.message.slice(0, 100);\n+    if (detail.message.length > 100) {\n+      popupText += \"\u2026\";\n+    }\n+    event.extendedProps.htmlContent = htmlSafe(escapeExpression(popupText));\n+    event.title = event.title.replace(/<img[^>]*>/g, \"\");\n+    event.participantCount = 1;\n+\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    }\n+\n+    return event;\n+  }\n+\n+  _modifyDatesForTimezoneOffset(from, to, timezoneOffset) {\n+    if (timezoneOffset > 0) {\n+      if (to.isValid()) {\n+        to.add(1, \"day\");\n+      } else {\n+        to = from.clone().add(1, \"day\");\n+      }\n+    } else if (timezoneOffset < 0) {\n+      if (!to.isValid()) {\n+        to = from.clone();\n+      }\n+      from.subtract(1, \"day\");\n+    }\n+  }\n+\n+  _findAverageTimezone(eventTimezones) {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2284086098",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33737,
        "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
        "discussion_id": "2284086098",
        "commented_code": "@@ -0,0 +1,377 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {\n+    const event = this._buildEvent(detail);\n+    const holidayCalendarTopicId = parseInt(\n+      this.siteSettings.holiday_calendar_topic_id,\n+      10\n+    );\n+    const text = detail.message.split(\"\\n\").filter((e) => e);\n+\n+    if (\n+      text.length &&\n+      this.args.post.topic_id &&\n+      holidayCalendarTopicId !== this.args.post.topic_id\n+    ) {\n+      event.title = text[0];\n+      event.extendedProps.description = text.slice(1).join(\" \");\n+    } else {\n+      const color = stringToColor(detail.username);\n+      event.title = detail.username;\n+      event.backgroundColor = colorToHex(color);\n+      event.textColor = contrastColor(color);\n+    }\n+\n+    let popupText = detail.message.slice(0, 100);\n+    if (detail.message.length > 100) {\n+      popupText += \"\u2026\";\n+    }\n+    event.extendedProps.htmlContent = htmlSafe(escapeExpression(popupText));\n+    event.title = event.title.replace(/<img[^>]*>/g, \"\");\n+    event.participantCount = 1;\n+\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    }\n+\n+    return event;\n+  }\n+\n+  _modifyDatesForTimezoneOffset(from, to, timezoneOffset) {\n+    if (timezoneOffset > 0) {\n+      if (to.isValid()) {\n+        to.add(1, \"day\");\n+      } else {\n+        to = from.clone().add(1, \"day\");\n+      }\n+    } else if (timezoneOffset < 0) {\n+      if (!to.isValid()) {\n+        to = from.clone();\n+      }\n+      from.subtract(1, \"day\");\n+    }\n+  }\n+\n+  _findAverageTimezone(eventTimezones) {",
        "comment_created_at": "2025-08-19T05:19:39+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n  #findAverageTimezone(eventTimezones) {\r\n```\r\n\r\nShould use native private, dev-xp wants this now not the fake `_` one",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2285837435",
    "pr_number": 34351,
    "pr_file": "app/assets/javascripts/admin/addon/components/admin-config-areas/color-palettes.gjs",
    "created_at": "2025-08-19T17:01:01+00:00",
    "commented_code": "@service router;\n   @service modal;\n \n-  get baseColorPalettes() {\n-    return this.args.palettes.filter((palette) => palette.is_base);\n-  }\n-\n   @action\n   newColorPalette() {\n     this.modal.show(ColorSchemeSelectBaseModal, {\n       model: {\n-        baseColorSchemes: this.baseColorPalettes,\n+        colorSchemes: this.args.palettes,\n         newColorSchemeWithBase: this.newColorPaletteWithBase,\n       },\n     });\n   }\n \n   @action\n   async newColorPaletteWithBase(baseKey) {\n-    const base = this.baseColorPalettes.find(\n-      (palette) => palette.base_scheme_id === baseKey\n-    );\n+    const base = this.args.palettes.findBy(\"id\", baseKey);",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2285837435",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34351,
        "pr_file": "app/assets/javascripts/admin/addon/components/admin-config-areas/color-palettes.gjs",
        "discussion_id": "2285837435",
        "commented_code": "@@ -13,31 +13,28 @@ export default class AdminConfigAreasColorPalettes extends Component {\n   @service router;\n   @service modal;\n \n-  get baseColorPalettes() {\n-    return this.args.palettes.filter((palette) => palette.is_base);\n-  }\n-\n   @action\n   newColorPalette() {\n     this.modal.show(ColorSchemeSelectBaseModal, {\n       model: {\n-        baseColorSchemes: this.baseColorPalettes,\n+        colorSchemes: this.args.palettes,\n         newColorSchemeWithBase: this.newColorPaletteWithBase,\n       },\n     });\n   }\n \n   @action\n   async newColorPaletteWithBase(baseKey) {\n-    const base = this.baseColorPalettes.find(\n-      (palette) => palette.base_scheme_id === baseKey\n-    );\n+    const base = this.args.palettes.findBy(\"id\", baseKey);",
        "comment_created_at": "2025-08-19T17:01:01+00:00",
        "comment_author": "OsamaSayegh",
        "comment_body": "These array prototype extension methods (`findBy`, `mapBy` etc.) are deprecated and will be removed soon from Ember. We should stick to `find()`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2246422406",
    "pr_number": 33944,
    "pr_file": "app/assets/javascripts/discourse/app/components/post.gjs",
    "created_at": "2025-07-31T21:32:34+00:00",
    "commented_code": "data-user-id={{@post.user_id}}\n               {{this.addEventListeners this.customEventListeners}}\n             >\n-              {{#if this.hasRepliesAbove}}\n-                <div class=\"post__row row\">\n-                  <section\n-                    id={{concat \"embedded-posts__top--\" @post.post_number}}\n-                    class=\"post__embedded-posts post__embedded-posts--top post__body embedded-posts top topic-body\"\n-                  >\n-                    <DButton\n-                      class=\"post__collapse-button post__collapse-button-down collapse-down\"\n-                      @action={{this.toggleReplyAbove}}\n-                      @icon=\"chevron-down\"\n-                      @title=\"post.collapse\"\n-                    />\n-                    {{#each this.repliesAbove.value key=\"id\" as |reply|}}\n-                      <PostEmbedded\n-                        @post={{reply}}\n-                        @above={{true}}\n-                        @highlightTerm={{@highlightTerm}}\n-                        @streamElement={{@streamElement}}\n+              <PluginOutlet\n+                @name=\"in-post-article\"",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2246422406",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33944,
        "pr_file": "app/assets/javascripts/discourse/app/components/post.gjs",
        "discussion_id": "2246422406",
        "commented_code": "@@ -437,212 +440,224 @@ export default class Post extends Component {\n               data-user-id={{@post.user_id}}\n               {{this.addEventListeners this.customEventListeners}}\n             >\n-              {{#if this.hasRepliesAbove}}\n-                <div class=\"post__row row\">\n-                  <section\n-                    id={{concat \"embedded-posts__top--\" @post.post_number}}\n-                    class=\"post__embedded-posts post__embedded-posts--top post__body embedded-posts top topic-body\"\n-                  >\n-                    <DButton\n-                      class=\"post__collapse-button post__collapse-button-down collapse-down\"\n-                      @action={{this.toggleReplyAbove}}\n-                      @icon=\"chevron-down\"\n-                      @title=\"post.collapse\"\n-                    />\n-                    {{#each this.repliesAbove.value key=\"id\" as |reply|}}\n-                      <PostEmbedded\n-                        @post={{reply}}\n-                        @above={{true}}\n-                        @highlightTerm={{@highlightTerm}}\n-                        @streamElement={{@streamElement}}\n+              <PluginOutlet\n+                @name=\"in-post-article\"",
        "comment_created_at": "2025-07-31T21:32:34+00:00",
        "comment_author": "megothss",
        "comment_body": "```suggestion\r\n                @name=\"post-article-content\"\r\n```\r\n\r\nTo keep the pattern that all the plugin outlet names start with `post-`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179772436",
    "pr_number": 33430,
    "pr_file": "app/assets/javascripts/admin/addon/components/admin-config-areas/color-palette.gjs",
    "created_at": "2025-07-02T11:06:00+00:00",
    "commented_code": "this.editorMode = newMode;\n   }\n \n+  @action\n+  async copy_to_clipboard() {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2179772436",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33430,
        "pr_file": "app/assets/javascripts/admin/addon/components/admin-config-areas/color-palette.gjs",
        "discussion_id": "2179772436",
        "commented_code": "@@ -125,6 +126,28 @@ export default class AdminConfigAreasColorPalette extends Component {\n     this.editorMode = newMode;\n   }\n \n+  @action\n+  async copy_to_clipboard() {",
        "comment_created_at": "2025-07-02T11:06:00+00:00",
        "comment_author": "OsamaSayegh",
        "comment_body": "We use camelCase for JS code.",
        "pr_file_module": null
      },
      {
        "comment_id": "2181311468",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33430,
        "pr_file": "app/assets/javascripts/admin/addon/components/admin-config-areas/color-palette.gjs",
        "discussion_id": "2179772436",
        "commented_code": "@@ -125,6 +126,28 @@ export default class AdminConfigAreasColorPalette extends Component {\n     this.editorMode = newMode;\n   }\n \n+  @action\n+  async copy_to_clipboard() {",
        "comment_created_at": "2025-07-03T01:29:37+00:00",
        "comment_author": "Lhcfl",
        "comment_body": "Blame it on my rust experience, lol",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2142707753",
    "pr_number": 33082,
    "pr_file": "app/assets/javascripts/discourse/app/components/translation.gjs",
    "created_at": "2025-06-12T13:13:54+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { action } from \"@ember/object\";\n+import { getOwner } from \"@ember/owner\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import curryComponent from \"ember-curry-component\";\n+import TranslationPlaceholder from \"discourse/components/translation-placeholder\";\n+import uniqueId from \"discourse/helpers/unique-id\";\n+import { isProduction } from \"discourse/lib/environment\";\n+import I18n, { i18n, I18nMissingInterpolationArgument } from \"discourse-i18n\";\n+\n+/**\n+ * Provides the ability to interpolate both strings and components into translatable strings.\n+ * This component allows for complex i18n scenarios where you need to embed interactive\n+ * components within translated text.\n+ *\n+ * If you don't require this functionality, use the standard i18n() function.\n+ *\n+ * @component Translation\n+ *\n+ * @template Usage example:\n+ * ```gjs\n+ * // Translation key: \"some.translation.key\" = \"Welcome, %{username}! The date is %{shortdate}!\"\n+ * <Translation\n+ *   @scope=\"some.translation.key\"\n+ *   @options={{hash shortdate=shortDate}}\n+ * >\n+ *   <:placeholders as |Placeholder|>\n+ *     <Placeholder @name=\"username\">\n+ *       <UserLink @user={{user}}>{{user.username}}</UserLink>\n+ *     </Placeholder>\n+ *   </:placeholders>\n+ * </Translation>\n+ * ```\n+ *\n+ * @param {String} scope - The i18n translation key to use",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2142707753",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33082,
        "pr_file": "app/assets/javascripts/discourse/app/components/translation.gjs",
        "discussion_id": "2142707753",
        "commented_code": "@@ -0,0 +1,213 @@\n+import Component from \"@glimmer/component\";\n+import { action } from \"@ember/object\";\n+import { getOwner } from \"@ember/owner\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import curryComponent from \"ember-curry-component\";\n+import TranslationPlaceholder from \"discourse/components/translation-placeholder\";\n+import uniqueId from \"discourse/helpers/unique-id\";\n+import { isProduction } from \"discourse/lib/environment\";\n+import I18n, { i18n, I18nMissingInterpolationArgument } from \"discourse-i18n\";\n+\n+/**\n+ * Provides the ability to interpolate both strings and components into translatable strings.\n+ * This component allows for complex i18n scenarios where you need to embed interactive\n+ * components within translated text.\n+ *\n+ * If you don't require this functionality, use the standard i18n() function.\n+ *\n+ * @component Translation\n+ *\n+ * @template Usage example:\n+ * ```gjs\n+ * // Translation key: \"some.translation.key\" = \"Welcome, %{username}! The date is %{shortdate}!\"\n+ * <Translation\n+ *   @scope=\"some.translation.key\"\n+ *   @options={{hash shortdate=shortDate}}\n+ * >\n+ *   <:placeholders as |Placeholder|>\n+ *     <Placeholder @name=\"username\">\n+ *       <UserLink @user={{user}}>{{user.username}}</UserLink>\n+ *     </Placeholder>\n+ *   </:placeholders>\n+ * </Translation>\n+ * ```\n+ *\n+ * @param {String} scope - The i18n translation key to use",
        "comment_created_at": "2025-06-12T13:13:54+00:00",
        "comment_author": "davidtaylorhq",
        "comment_body": "Why are we calling it 'scope'? I think '@key=' would be a better match to other translation-related code in Discourse",
        "pr_file_module": null
      },
      {
        "comment_id": "2143831464",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33082,
        "pr_file": "app/assets/javascripts/discourse/app/components/translation.gjs",
        "discussion_id": "2142707753",
        "commented_code": "@@ -0,0 +1,213 @@\n+import Component from \"@glimmer/component\";\n+import { action } from \"@ember/object\";\n+import { getOwner } from \"@ember/owner\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import curryComponent from \"ember-curry-component\";\n+import TranslationPlaceholder from \"discourse/components/translation-placeholder\";\n+import uniqueId from \"discourse/helpers/unique-id\";\n+import { isProduction } from \"discourse/lib/environment\";\n+import I18n, { i18n, I18nMissingInterpolationArgument } from \"discourse-i18n\";\n+\n+/**\n+ * Provides the ability to interpolate both strings and components into translatable strings.\n+ * This component allows for complex i18n scenarios where you need to embed interactive\n+ * components within translated text.\n+ *\n+ * If you don't require this functionality, use the standard i18n() function.\n+ *\n+ * @component Translation\n+ *\n+ * @template Usage example:\n+ * ```gjs\n+ * // Translation key: \"some.translation.key\" = \"Welcome, %{username}! The date is %{shortdate}!\"\n+ * <Translation\n+ *   @scope=\"some.translation.key\"\n+ *   @options={{hash shortdate=shortDate}}\n+ * >\n+ *   <:placeholders as |Placeholder|>\n+ *     <Placeholder @name=\"username\">\n+ *       <UserLink @user={{user}}>{{user.username}}</UserLink>\n+ *     </Placeholder>\n+ *   </:placeholders>\n+ * </Translation>\n+ * ```\n+ *\n+ * @param {String} scope - The i18n translation key to use",
        "comment_created_at": "2025-06-12T23:44:23+00:00",
        "comment_author": "pento",
        "comment_body": "I called it `scope` because that's what it's called in `I18n.translate()`, but I'm happy to use `key` instead. \ud83d\ude42 ",
        "pr_file_module": null
      }
    ]
  }
]