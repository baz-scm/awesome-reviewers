[
  {
    "discussion_id": "2178803866",
    "pr_number": 33092,
    "pr_file": "app/jobs/regular/check_video_conversion_status.rb",
    "created_at": "2025-07-02T01:26:38+00:00",
    "commented_code": "+# frozen_string_literal: true\n+module Jobs\n+  class CheckVideoConversionStatus < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+\n+    def execute(args)\n+      return if args[:upload_id].blank? || args[:job_id].blank? || args[:adapter_type].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return unless upload\n+\n+      adapter =\n+        VideoConversion::AdapterFactory.get_adapter(upload, adapter_type: args[:adapter_type])\n+\n+      status = adapter.check_status(args[:job_id])\n+\n+      case status\n+      when :complete\n+        if adapter.handle_completion(args[:job_id], args[:output_path], args[:new_sha1])\n+          # Successfully completed\n+          nil\n+        else\n+          # Handle completion failed\n+          Rails.logger.error(\"Failed to handle video conversion completion\")",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2178803866",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/jobs/regular/check_video_conversion_status.rb",
        "discussion_id": "2178803866",
        "commented_code": "@@ -0,0 +1,36 @@\n+# frozen_string_literal: true\n+module Jobs\n+  class CheckVideoConversionStatus < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+\n+    def execute(args)\n+      return if args[:upload_id].blank? || args[:job_id].blank? || args[:adapter_type].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return unless upload\n+\n+      adapter =\n+        VideoConversion::AdapterFactory.get_adapter(upload, adapter_type: args[:adapter_type])\n+\n+      status = adapter.check_status(args[:job_id])\n+\n+      case status\n+      when :complete\n+        if adapter.handle_completion(args[:job_id], args[:output_path], args[:new_sha1])\n+          # Successfully completed\n+          nil\n+        else\n+          # Handle completion failed\n+          Rails.logger.error(\"Failed to handle video conversion completion\")",
        "comment_created_at": "2025-07-02T01:26:38+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\n          Rails.logger.error(\"Failed to handle video conversion completion for upload ID #{upload.id} and job ID #{args[:job_id]}\")\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2178804167",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/jobs/regular/check_video_conversion_status.rb",
        "discussion_id": "2178803866",
        "commented_code": "@@ -0,0 +1,36 @@\n+# frozen_string_literal: true\n+module Jobs\n+  class CheckVideoConversionStatus < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+\n+    def execute(args)\n+      return if args[:upload_id].blank? || args[:job_id].blank? || args[:adapter_type].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return unless upload\n+\n+      adapter =\n+        VideoConversion::AdapterFactory.get_adapter(upload, adapter_type: args[:adapter_type])\n+\n+      status = adapter.check_status(args[:job_id])\n+\n+      case status\n+      when :complete\n+        if adapter.handle_completion(args[:job_id], args[:output_path], args[:new_sha1])\n+          # Successfully completed\n+          nil\n+        else\n+          # Handle completion failed\n+          Rails.logger.error(\"Failed to handle video conversion completion\")",
        "comment_created_at": "2025-07-02T01:27:03+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "Should we requeue some amount of times on error? Or will it never pass if this happens?",
        "pr_file_module": null
      },
      {
        "comment_id": "2190979351",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/jobs/regular/check_video_conversion_status.rb",
        "discussion_id": "2178803866",
        "commented_code": "@@ -0,0 +1,36 @@\n+# frozen_string_literal: true\n+module Jobs\n+  class CheckVideoConversionStatus < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+\n+    def execute(args)\n+      return if args[:upload_id].blank? || args[:job_id].blank? || args[:adapter_type].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return unless upload\n+\n+      adapter =\n+        VideoConversion::AdapterFactory.get_adapter(upload, adapter_type: args[:adapter_type])\n+\n+      status = adapter.check_status(args[:job_id])\n+\n+      case status\n+      when :complete\n+        if adapter.handle_completion(args[:job_id], args[:output_path], args[:new_sha1])\n+          # Successfully completed\n+          nil\n+        else\n+          # Handle completion failed\n+          Rails.logger.error(\"Failed to handle video conversion completion\")",
        "comment_created_at": "2025-07-07T20:42:58+00:00",
        "comment_author": "blake-discourse",
        "comment_body": "I'm going to say let's not requeue at the moment. Not until we see we are getting errors and if they can be solved by requeuing ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178861105",
    "pr_number": 33092,
    "pr_file": "app/models/optimized_video.rb",
    "created_at": "2025-07-02T02:28:13+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+class OptimizedVideo < ActiveRecord::Base\n+  include HasUrl\n+  belongs_to :upload\n+\n+  def self.create_for(upload, filename, user_id, options = {})\n+    return if upload.blank?\n+\n+    optimized_video =\n+      OptimizedVideo.new(\n+        upload_id: upload.id,\n+        sha1: options[:sha1],\n+        extension: options[:extension] || File.extname(filename),\n+        url: options[:url],\n+        filesize: options[:filesize],\n+      )\n+\n+    if optimized_video.save\n+      optimized_video\n+    else\n+      Rails.logger.error(\n+        \"Failed to create optimized video: #{optimized_video.errors.full_messages.join(\", \")}\",",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2178861105",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/models/optimized_video.rb",
        "discussion_id": "2178861105",
        "commented_code": "@@ -0,0 +1,43 @@\n+# frozen_string_literal: true\n+\n+class OptimizedVideo < ActiveRecord::Base\n+  include HasUrl\n+  belongs_to :upload\n+\n+  def self.create_for(upload, filename, user_id, options = {})\n+    return if upload.blank?\n+\n+    optimized_video =\n+      OptimizedVideo.new(\n+        upload_id: upload.id,\n+        sha1: options[:sha1],\n+        extension: options[:extension] || File.extname(filename),\n+        url: options[:url],\n+        filesize: options[:filesize],\n+      )\n+\n+    if optimized_video.save\n+      optimized_video\n+    else\n+      Rails.logger.error(\n+        \"Failed to create optimized video: #{optimized_video.errors.full_messages.join(\", \")}\",",
        "comment_created_at": "2025-07-02T02:28:13+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\n        \"Failed to create optimized video for upload ID #{upload.id}: #{optimized_video.errors.full_messages.join(\", \")}\",\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178906695",
    "pr_number": 33092,
    "pr_file": "app/services/video_conversion/aws_media_convert_adapter.rb",
    "created_at": "2025-07-02T03:05:12+00:00",
    "commented_code": "+# frozen_string_literal: true\n+require \"aws-sdk-mediaconvert\"\n+\n+module VideoConversion\n+  class AwsMediaConvertAdapter < BaseAdapter\n+    def convert\n+      return false unless valid_settings?\n+\n+      begin\n+        new_sha1 = SecureRandom.hex(20)\n+        output_path = \"optimized/videos/#{new_sha1}\"\n+\n+        # Extract the path from the URL\n+        # The URL format is: //bucket.s3.dualstack.region.amazonaws.com/path/to/file\n+        # or: //bucket.s3.region.amazonaws.com/path/to/file\n+        url = @upload.url.sub(%r{^//}, \"\") # Remove leading //\n+\n+        # Split on the first / to separate the domain from the path\n+        domain, path = url.split(\"/\", 2)\n+\n+        # Verify the domain contains our bucket\n+        unless domain&.include?(SiteSetting.s3_upload_bucket)\n+          raise Discourse::InvalidParameters.new(\n+                  \"Upload URL domain does not contain expected bucket name: #{SiteSetting.s3_upload_bucket}\",\n+                )\n+        end\n+\n+        input_path = \"s3://#{SiteSetting.s3_upload_bucket}/#{path}\"\n+        settings = build_conversion_settings(input_path, output_path)\n+\n+        begin\n+          response =\n+            mediaconvert_client.create_job(\n+              role: SiteSetting.mediaconvert_role_arn,\n+              settings: settings,\n+              status_update_interval: \"SECONDS_10\",\n+              user_metadata: {\n+                \"upload_id\" => @upload.id.to_s,\n+                \"new_sha1\" => new_sha1,\n+                \"output_path\" => output_path,\n+              },\n+            )\n+\n+          # Enqueue status check job\n+          Jobs.enqueue_in(\n+            30.seconds,\n+            :check_video_conversion_status,\n+            upload_id: @upload.id,\n+            job_id: response.job.id,\n+            new_sha1: new_sha1,\n+            output_path: output_path,\n+            original_filename: @upload.original_filename,\n+            user_id: @upload.user_id,\n+            adapter_type: \"aws_mediaconvert\",\n+          )\n+\n+          true # Return true on success\n+        rescue Aws::MediaConvert::Errors::ServiceError => e\n+          Rails.logger.error(\n+            \"MediaConvert job creation failed for upload #{@upload.id}. \" \\\n+              \"Error: #{e.class.name} - #{e.message}\" \\\n+              \"#{e.respond_to?(:code) ? \" (Code: #{e.code})\" : \"\"}\" \\\n+              \"#{e.respond_to?(:context) ? \" (Request ID: #{e.context.request_id})\" : \"\"}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"MediaConvert job creation failed\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        rescue => e\n+          Rails.logger.error(\n+            \"Unexpected error creating MediaConvert job for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"Unexpected error in MediaConvert job creation\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        end\n+      rescue Discourse::InvalidParameters => e\n+        Rails.logger.error(\"Invalid parameters for upload #{@upload.id}: #{e.message}\")\n+        false\n+      rescue => e\n+        Rails.logger.error(\n+          \"Unexpected error in video conversion for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Unexpected error in video conversion\",\n+          env: {\n+            upload_id: @upload.id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    def check_status(job_id)\n+      response = mediaconvert_client.get_job(id: job_id)\n+\n+      case response.job.status\n+      when \"COMPLETE\"\n+        :complete\n+      when \"ERROR\"\n+        Rails.logger.error(\"MediaConvert job #{job_id} failed\")\n+        :error\n+      when \"SUBMITTED\", \"PROGRESSING\"\n+        :pending\n+      else\n+        Rails.logger.warn(\n+          \"Unexpected MediaConvert job status for job #{job_id}: #{response.job.status}\",\n+        )\n+        :error\n+      end\n+    end\n+\n+    def handle_completion(job_id, output_path, new_sha1)\n+      s3_store = FileStore::S3Store.new\n+      path = \"#{output_path}.mp4\"\n+      object = s3_store.object_from_path(path)\n+\n+      return false unless object&.exists?\n+\n+      begin\n+        optimized_video =\n+          create_optimized_video_record(\n+            output_path,\n+            new_sha1,\n+            object.size,\n+            \"//#{s3_store.s3_bucket}.s3.dualstack.#{SiteSetting.s3_region}.amazonaws.com/#{path}\",\n+          )\n+\n+        if optimized_video\n+          update_posts_with_optimized_video\n+          true\n+        else\n+          Rails.logger.error(\"Failed to create OptimizedVideo record for upload #{@upload.id}\")\n+          false\n+        end\n+      rescue => e\n+        Rails.logger.error(\n+          \"Error processing video completion for upload #{@upload.id}: #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Error in video processing completion\",\n+          env: {\n+            upload_id: @upload.id,\n+            job_id: job_id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    private\n+\n+    def valid_settings?\n+      SiteSetting.video_conversion_enabled && SiteSetting.mediaconvert_role_arn.present? &&\n+        SiteSetting.mediaconvert_endpoint.present?\n+    end\n+\n+    def mediaconvert_client\n+      @mediaconvert_client ||=\n+        begin\n+          # For some reason the endpoint is not visible in the aws console UI so we need to get it from the API\n+          if SiteSetting.mediaconvert_endpoint.blank?\n+            client =\n+              Aws::MediaConvert::Client.new(\n+                region: SiteSetting.s3_region,\n+                credentials:\n+                  Aws::Credentials.new(\n+                    SiteSetting.s3_access_key_id,\n+                    SiteSetting.s3_secret_access_key,\n+                  ),\n+              )\n+            resp = client.describe_endpoints",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2178906695",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/services/video_conversion/aws_media_convert_adapter.rb",
        "discussion_id": "2178906695",
        "commented_code": "@@ -0,0 +1,267 @@\n+# frozen_string_literal: true\n+require \"aws-sdk-mediaconvert\"\n+\n+module VideoConversion\n+  class AwsMediaConvertAdapter < BaseAdapter\n+    def convert\n+      return false unless valid_settings?\n+\n+      begin\n+        new_sha1 = SecureRandom.hex(20)\n+        output_path = \"optimized/videos/#{new_sha1}\"\n+\n+        # Extract the path from the URL\n+        # The URL format is: //bucket.s3.dualstack.region.amazonaws.com/path/to/file\n+        # or: //bucket.s3.region.amazonaws.com/path/to/file\n+        url = @upload.url.sub(%r{^//}, \"\") # Remove leading //\n+\n+        # Split on the first / to separate the domain from the path\n+        domain, path = url.split(\"/\", 2)\n+\n+        # Verify the domain contains our bucket\n+        unless domain&.include?(SiteSetting.s3_upload_bucket)\n+          raise Discourse::InvalidParameters.new(\n+                  \"Upload URL domain does not contain expected bucket name: #{SiteSetting.s3_upload_bucket}\",\n+                )\n+        end\n+\n+        input_path = \"s3://#{SiteSetting.s3_upload_bucket}/#{path}\"\n+        settings = build_conversion_settings(input_path, output_path)\n+\n+        begin\n+          response =\n+            mediaconvert_client.create_job(\n+              role: SiteSetting.mediaconvert_role_arn,\n+              settings: settings,\n+              status_update_interval: \"SECONDS_10\",\n+              user_metadata: {\n+                \"upload_id\" => @upload.id.to_s,\n+                \"new_sha1\" => new_sha1,\n+                \"output_path\" => output_path,\n+              },\n+            )\n+\n+          # Enqueue status check job\n+          Jobs.enqueue_in(\n+            30.seconds,\n+            :check_video_conversion_status,\n+            upload_id: @upload.id,\n+            job_id: response.job.id,\n+            new_sha1: new_sha1,\n+            output_path: output_path,\n+            original_filename: @upload.original_filename,\n+            user_id: @upload.user_id,\n+            adapter_type: \"aws_mediaconvert\",\n+          )\n+\n+          true # Return true on success\n+        rescue Aws::MediaConvert::Errors::ServiceError => e\n+          Rails.logger.error(\n+            \"MediaConvert job creation failed for upload #{@upload.id}. \" \\\n+              \"Error: #{e.class.name} - #{e.message}\" \\\n+              \"#{e.respond_to?(:code) ? \" (Code: #{e.code})\" : \"\"}\" \\\n+              \"#{e.respond_to?(:context) ? \" (Request ID: #{e.context.request_id})\" : \"\"}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"MediaConvert job creation failed\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        rescue => e\n+          Rails.logger.error(\n+            \"Unexpected error creating MediaConvert job for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+          )\n+          Discourse.warn_exception(\n+            e,\n+            message: \"Unexpected error in MediaConvert job creation\",\n+            env: {\n+              upload_id: @upload.id,\n+            },\n+          )\n+          false\n+        end\n+      rescue Discourse::InvalidParameters => e\n+        Rails.logger.error(\"Invalid parameters for upload #{@upload.id}: #{e.message}\")\n+        false\n+      rescue => e\n+        Rails.logger.error(\n+          \"Unexpected error in video conversion for upload #{@upload.id}: #{e.class.name} - #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Unexpected error in video conversion\",\n+          env: {\n+            upload_id: @upload.id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    def check_status(job_id)\n+      response = mediaconvert_client.get_job(id: job_id)\n+\n+      case response.job.status\n+      when \"COMPLETE\"\n+        :complete\n+      when \"ERROR\"\n+        Rails.logger.error(\"MediaConvert job #{job_id} failed\")\n+        :error\n+      when \"SUBMITTED\", \"PROGRESSING\"\n+        :pending\n+      else\n+        Rails.logger.warn(\n+          \"Unexpected MediaConvert job status for job #{job_id}: #{response.job.status}\",\n+        )\n+        :error\n+      end\n+    end\n+\n+    def handle_completion(job_id, output_path, new_sha1)\n+      s3_store = FileStore::S3Store.new\n+      path = \"#{output_path}.mp4\"\n+      object = s3_store.object_from_path(path)\n+\n+      return false unless object&.exists?\n+\n+      begin\n+        optimized_video =\n+          create_optimized_video_record(\n+            output_path,\n+            new_sha1,\n+            object.size,\n+            \"//#{s3_store.s3_bucket}.s3.dualstack.#{SiteSetting.s3_region}.amazonaws.com/#{path}\",\n+          )\n+\n+        if optimized_video\n+          update_posts_with_optimized_video\n+          true\n+        else\n+          Rails.logger.error(\"Failed to create OptimizedVideo record for upload #{@upload.id}\")\n+          false\n+        end\n+      rescue => e\n+        Rails.logger.error(\n+          \"Error processing video completion for upload #{@upload.id}: #{e.message}\",\n+        )\n+        Discourse.warn_exception(\n+          e,\n+          message: \"Error in video processing completion\",\n+          env: {\n+            upload_id: @upload.id,\n+            job_id: job_id,\n+          },\n+        )\n+        false\n+      end\n+    end\n+\n+    private\n+\n+    def valid_settings?\n+      SiteSetting.video_conversion_enabled && SiteSetting.mediaconvert_role_arn.present? &&\n+        SiteSetting.mediaconvert_endpoint.present?\n+    end\n+\n+    def mediaconvert_client\n+      @mediaconvert_client ||=\n+        begin\n+          # For some reason the endpoint is not visible in the aws console UI so we need to get it from the API\n+          if SiteSetting.mediaconvert_endpoint.blank?\n+            client =\n+              Aws::MediaConvert::Client.new(\n+                region: SiteSetting.s3_region,\n+                credentials:\n+                  Aws::Credentials.new(\n+                    SiteSetting.s3_access_key_id,\n+                    SiteSetting.s3_secret_access_key,\n+                  ),\n+              )\n+            resp = client.describe_endpoints",
        "comment_created_at": "2025-07-02T03:05:12+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "Is it possible this could fail with an error? If so we should handle it.\n\nIt would be good if we could do this as soon as you enabled the site setting, but I don't think we have a good mechanism for that \ud83e\udd14 Otherwise this could silently fail and the conversion would never work, and admins wouldn't know.\n\nOne possible thing to do is  make an admin problem check that checks if this exists with the current settings, and if not tell admins they have to fix up the keys/permissions and so on",
        "pr_file_module": null
      }
    ]
  }
]