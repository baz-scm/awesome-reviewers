[
  {
    "discussion_id": "2281237453",
    "pr_number": 34213,
    "pr_file": "app/controllers/admin/impersonate_controller.rb",
    "created_at": "2025-08-18T03:49:30+00:00",
    "commented_code": "# log impersonate\n     StaffActionLogger.new(current_user).log_impersonate(user)\n \n-    # Log on as the user\n-    log_on_user(user, impersonate: true)\n+    if SiteSetting.experimental_impersonation\n+      raise Discourse::InvalidAccess if current_user.is_impersonating\n+\n+      start_impersonating_user(user)\n+    else\n+      # Log on as the user\n+      log_on_user(user, impersonate: true)\n+    end\n+\n+    render body: nil\n+  end\n+\n+  def destroy\n+    raise Discourse::NotFound if !SiteSetting.experimental_impersonation\n+    raise Discourse::InvalidAccess if !current_user.is_impersonating\n+\n+    stop_impersonating_user",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2281237453",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34213,
        "pr_file": "app/controllers/admin/impersonate_controller.rb",
        "discussion_id": "2281237453",
        "commented_code": "@@ -12,8 +14,23 @@ def create\n     # log impersonate\n     StaffActionLogger.new(current_user).log_impersonate(user)\n \n-    # Log on as the user\n-    log_on_user(user, impersonate: true)\n+    if SiteSetting.experimental_impersonation\n+      raise Discourse::InvalidAccess if current_user.is_impersonating\n+\n+      start_impersonating_user(user)\n+    else\n+      # Log on as the user\n+      log_on_user(user, impersonate: true)\n+    end\n+\n+    render body: nil\n+  end\n+\n+  def destroy\n+    raise Discourse::NotFound if !SiteSetting.experimental_impersonation\n+    raise Discourse::InvalidAccess if !current_user.is_impersonating\n+\n+    stop_impersonating_user",
        "comment_created_at": "2025-08-18T03:49:30+00:00",
        "comment_author": "tgxworld",
        "comment_body": "I think it is also useful to log when user impersonation stops as well to help provide a more complete paper trail if we ever have to analyze staff action logs. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178800525",
    "pr_number": 33092,
    "pr_file": "app/jobs/regular/check_video_conversion_status.rb",
    "created_at": "2025-07-02T01:22:07+00:00",
    "commented_code": "+# frozen_string_literal: true\n+module Jobs\n+  class CheckVideoConversionStatus < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+\n+    def execute(args)\n+      return if args[:upload_id].blank? || args[:job_id].blank? || args[:adapter_type].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return unless upload\n+\n+      adapter =\n+        VideoConversion::AdapterFactory.get_adapter(upload, adapter_type: args[:adapter_type])\n+\n+      status = adapter.check_status(args[:job_id])\n+\n+      case status\n+      when :complete\n+        if adapter.handle_completion(args[:job_id], args[:output_path], args[:new_sha1])\n+          # Successfully completed\n+          nil",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2178800525",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/jobs/regular/check_video_conversion_status.rb",
        "discussion_id": "2178800525",
        "commented_code": "@@ -0,0 +1,36 @@\n+# frozen_string_literal: true\n+module Jobs\n+  class CheckVideoConversionStatus < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+\n+    def execute(args)\n+      return if args[:upload_id].blank? || args[:job_id].blank? || args[:adapter_type].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return unless upload\n+\n+      adapter =\n+        VideoConversion::AdapterFactory.get_adapter(upload, adapter_type: args[:adapter_type])\n+\n+      status = adapter.check_status(args[:job_id])\n+\n+      case status\n+      when :complete\n+        if adapter.handle_completion(args[:job_id], args[:output_path], args[:new_sha1])\n+          # Successfully completed\n+          nil",
        "comment_created_at": "2025-07-02T01:22:07+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\n          Rails.logger.info(\"Completed video conversion for upload ID #{upload.id} and job ID #{args[:job_id]}\")\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178805089",
    "pr_number": 33092,
    "pr_file": "app/jobs/regular/convert_video.rb",
    "created_at": "2025-07-02T01:28:03+00:00",
    "commented_code": "+# frozen_string_literal: true\n+module Jobs\n+  class ConvertVideo < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+    MAX_RETRIES = 5\n+    RETRY_DELAY = 30.seconds\n+\n+    def execute(args)\n+      return if args[:upload_id].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return if upload.blank?\n+\n+      return if OptimizedVideo.exists?(upload_id: upload.id)\n+\n+      if upload.url.blank?\n+        retry_count = args[:retry_count].to_i\n+        if retry_count < MAX_RETRIES\n+          Jobs.enqueue_in(RETRY_DELAY, :convert_video, args.merge(retry_count: retry_count + 1))\n+          return\n+        else\n+          Rails.logger.error(\"Upload #{upload.id} URL remained blank after #{MAX_RETRIES} retries\")",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2178805089",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/jobs/regular/convert_video.rb",
        "discussion_id": "2178805089",
        "commented_code": "@@ -0,0 +1,32 @@\n+# frozen_string_literal: true\n+module Jobs\n+  class ConvertVideo < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+    MAX_RETRIES = 5\n+    RETRY_DELAY = 30.seconds\n+\n+    def execute(args)\n+      return if args[:upload_id].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return if upload.blank?\n+\n+      return if OptimizedVideo.exists?(upload_id: upload.id)\n+\n+      if upload.url.blank?\n+        retry_count = args[:retry_count].to_i\n+        if retry_count < MAX_RETRIES\n+          Jobs.enqueue_in(RETRY_DELAY, :convert_video, args.merge(retry_count: retry_count + 1))\n+          return\n+        else\n+          Rails.logger.error(\"Upload #{upload.id} URL remained blank after #{MAX_RETRIES} retries\")",
        "comment_created_at": "2025-07-02T01:28:03+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\n          Rails.logger.error(\"Upload #{upload.id} URL remained blank after #{MAX_RETRIES} retries when optimizing video\")\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2220277422",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33092,
        "pr_file": "app/jobs/regular/convert_video.rb",
        "discussion_id": "2178805089",
        "commented_code": "@@ -0,0 +1,32 @@\n+# frozen_string_literal: true\n+module Jobs\n+  class ConvertVideo < ::Jobs::Base\n+    sidekiq_options queue: \"low\", concurrency: 5\n+    MAX_RETRIES = 5\n+    RETRY_DELAY = 30.seconds\n+\n+    def execute(args)\n+      return if args[:upload_id].blank?\n+\n+      upload = Upload.find_by(id: args[:upload_id])\n+      return if upload.blank?\n+\n+      return if OptimizedVideo.exists?(upload_id: upload.id)\n+\n+      if upload.url.blank?\n+        retry_count = args[:retry_count].to_i\n+        if retry_count < MAX_RETRIES\n+          Jobs.enqueue_in(RETRY_DELAY, :convert_video, args.merge(retry_count: retry_count + 1))\n+          return\n+        else\n+          Rails.logger.error(\"Upload #{upload.id} URL remained blank after #{MAX_RETRIES} retries\")",
        "comment_created_at": "2025-07-21T20:41:48+00:00",
        "comment_author": "pmusaraj",
        "comment_body": "Suggested change makes sense to me. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143740813",
    "pr_number": 33019,
    "pr_file": "migrations/lib/importer/steps/badges.rb",
    "created_at": "2025-06-12T22:10:30+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Badges < ::Migrations::Importer::CopyStep\n+    DEFAULT_ICON = \"certificate\"\n+    DUPLICATE_SUFFIX = \"_1\"\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM badges\"\n+    requires_set :existing_ids, \"SELECT id FROM badges\"\n+    requires_set :existing_names, \"SELECT name FROM badges\"\n+    requires_set :existing_badge_grouping_ids, \"SELECT id FROM badge_groupings\"\n+    requires_set :existing_badge_type_ids, \"SELECT id FROM badge_types\"\n+\n+    column_names %i[\n+                   id\n+                   name\n+                   description\n+                   badge_type_id\n+                   created_at\n+                   updated_at\n+                   allow_title\n+                   multiple_grant\n+                   icon\n+                   listable\n+                   target_posts\n+                   query\n+                   enabled\n+                   auto_revoke\n+                   badge_grouping_id\n+                   trigger\n+                   show_posts\n+                   long_description\n+                   image_upload_id\n+                   show_in_post_header\n+                 ]\n+\n+    store_mapped_ids true\n+\n+    total_rows_query <<~SQL, MappingType::BADGES\n+      SELECT COUNT(*)\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::BADGES\n+      SELECT b.*\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+      GROUP BY b.original_id\n+      ORDER BY b.ROWID\n+    SQL\n+\n+    private\n+\n+    def transform_row(row)\n+      if row[:existing_id].present?\n+        row[:id] = if row[:existing_id].match?(/\\A\\d+\\z/)\n+          id = row[:existing_id].to_i\n+          id if @existing_ids.include?(id)\n+        else\n+          @ids_by_name[row[:existing_id]]\n+        end\n+\n+        return nil if row[:id].present?\n+      end\n+\n+      badge_name = row[:name].dup\n+      row[:name] = @existing_names.add?(badge_name) ? badge_name : deduplicate_name(badge_name)\n+\n+      row[:allow_title] ||= false\n+      row[:multiple_grant] ||= false\n+      row[:show_posts] ||= false\n+      row[:show_in_post_header] ||= false\n+      row[:target_posts] ||= false\n+      row[:auto_revoke] = true if row[:auto_revoke].nil?\n+      row[:enabled] = true if row[:enabled].nil?\n+      row[:listable] = true if row[:listable].nil?\n+\n+      row[:icon] = DEFAULT_ICON if row[:icon].blank?\n+      row[:trigger] = Badge::Trigger::None unless valid_trigger?(row[:trigger])\n+\n+      # TODO: Update these if/when we add import steps for badge groupings and badge types\n+      #       Current implementation expects the converter to set final values\n+      row[:badge_grouping_id] = ensure_related_id(\n+        row[:badge_grouping_id],\n+        @existing_badge_grouping_ids,\n+        BadgeGrouping::Other,\n+      )\n+      row[:badge_type_id] = ensure_related_id(\n+        row[:badge_type_id],\n+        @existing_badge_type_ids,\n+        BadgeType::Silver,\n+      )\n+\n+      # TODO: Probably validate the imported query, maybe in some other step\n+      row[:query] = nil if !SiteSetting.enable_badge_sql? && row[:query].present?",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2143740813",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33019,
        "pr_file": "migrations/lib/importer/steps/badges.rb",
        "discussion_id": "2143740813",
        "commented_code": "@@ -0,0 +1,123 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Badges < ::Migrations::Importer::CopyStep\n+    DEFAULT_ICON = \"certificate\"\n+    DUPLICATE_SUFFIX = \"_1\"\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM badges\"\n+    requires_set :existing_ids, \"SELECT id FROM badges\"\n+    requires_set :existing_names, \"SELECT name FROM badges\"\n+    requires_set :existing_badge_grouping_ids, \"SELECT id FROM badge_groupings\"\n+    requires_set :existing_badge_type_ids, \"SELECT id FROM badge_types\"\n+\n+    column_names %i[\n+                   id\n+                   name\n+                   description\n+                   badge_type_id\n+                   created_at\n+                   updated_at\n+                   allow_title\n+                   multiple_grant\n+                   icon\n+                   listable\n+                   target_posts\n+                   query\n+                   enabled\n+                   auto_revoke\n+                   badge_grouping_id\n+                   trigger\n+                   show_posts\n+                   long_description\n+                   image_upload_id\n+                   show_in_post_header\n+                 ]\n+\n+    store_mapped_ids true\n+\n+    total_rows_query <<~SQL, MappingType::BADGES\n+      SELECT COUNT(*)\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::BADGES\n+      SELECT b.*\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+      GROUP BY b.original_id\n+      ORDER BY b.ROWID\n+    SQL\n+\n+    private\n+\n+    def transform_row(row)\n+      if row[:existing_id].present?\n+        row[:id] = if row[:existing_id].match?(/\\A\\d+\\z/)\n+          id = row[:existing_id].to_i\n+          id if @existing_ids.include?(id)\n+        else\n+          @ids_by_name[row[:existing_id]]\n+        end\n+\n+        return nil if row[:id].present?\n+      end\n+\n+      badge_name = row[:name].dup\n+      row[:name] = @existing_names.add?(badge_name) ? badge_name : deduplicate_name(badge_name)\n+\n+      row[:allow_title] ||= false\n+      row[:multiple_grant] ||= false\n+      row[:show_posts] ||= false\n+      row[:show_in_post_header] ||= false\n+      row[:target_posts] ||= false\n+      row[:auto_revoke] = true if row[:auto_revoke].nil?\n+      row[:enabled] = true if row[:enabled].nil?\n+      row[:listable] = true if row[:listable].nil?\n+\n+      row[:icon] = DEFAULT_ICON if row[:icon].blank?\n+      row[:trigger] = Badge::Trigger::None unless valid_trigger?(row[:trigger])\n+\n+      # TODO: Update these if/when we add import steps for badge groupings and badge types\n+      #       Current implementation expects the converter to set final values\n+      row[:badge_grouping_id] = ensure_related_id(\n+        row[:badge_grouping_id],\n+        @existing_badge_grouping_ids,\n+        BadgeGrouping::Other,\n+      )\n+      row[:badge_type_id] = ensure_related_id(\n+        row[:badge_type_id],\n+        @existing_badge_type_ids,\n+        BadgeType::Silver,\n+      )\n+\n+      # TODO: Probably validate the imported query, maybe in some other step\n+      row[:query] = nil if !SiteSetting.enable_badge_sql? && row[:query].present?",
        "comment_created_at": "2025-06-12T22:10:30+00:00",
        "comment_author": "gschlager",
        "comment_body": "Silently removing the badge query isn't a good idea. We need to implement a logging mechanism for warnings, similar to what we do in converters. It's fine to do it like this until we have it, but please add a TODO to change this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2161602799",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33019,
        "pr_file": "migrations/lib/importer/steps/badges.rb",
        "discussion_id": "2143740813",
        "commented_code": "@@ -0,0 +1,123 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Badges < ::Migrations::Importer::CopyStep\n+    DEFAULT_ICON = \"certificate\"\n+    DUPLICATE_SUFFIX = \"_1\"\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM badges\"\n+    requires_set :existing_ids, \"SELECT id FROM badges\"\n+    requires_set :existing_names, \"SELECT name FROM badges\"\n+    requires_set :existing_badge_grouping_ids, \"SELECT id FROM badge_groupings\"\n+    requires_set :existing_badge_type_ids, \"SELECT id FROM badge_types\"\n+\n+    column_names %i[\n+                   id\n+                   name\n+                   description\n+                   badge_type_id\n+                   created_at\n+                   updated_at\n+                   allow_title\n+                   multiple_grant\n+                   icon\n+                   listable\n+                   target_posts\n+                   query\n+                   enabled\n+                   auto_revoke\n+                   badge_grouping_id\n+                   trigger\n+                   show_posts\n+                   long_description\n+                   image_upload_id\n+                   show_in_post_header\n+                 ]\n+\n+    store_mapped_ids true\n+\n+    total_rows_query <<~SQL, MappingType::BADGES\n+      SELECT COUNT(*)\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::BADGES\n+      SELECT b.*\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+      GROUP BY b.original_id\n+      ORDER BY b.ROWID\n+    SQL\n+\n+    private\n+\n+    def transform_row(row)\n+      if row[:existing_id].present?\n+        row[:id] = if row[:existing_id].match?(/\\A\\d+\\z/)\n+          id = row[:existing_id].to_i\n+          id if @existing_ids.include?(id)\n+        else\n+          @ids_by_name[row[:existing_id]]\n+        end\n+\n+        return nil if row[:id].present?\n+      end\n+\n+      badge_name = row[:name].dup\n+      row[:name] = @existing_names.add?(badge_name) ? badge_name : deduplicate_name(badge_name)\n+\n+      row[:allow_title] ||= false\n+      row[:multiple_grant] ||= false\n+      row[:show_posts] ||= false\n+      row[:show_in_post_header] ||= false\n+      row[:target_posts] ||= false\n+      row[:auto_revoke] = true if row[:auto_revoke].nil?\n+      row[:enabled] = true if row[:enabled].nil?\n+      row[:listable] = true if row[:listable].nil?\n+\n+      row[:icon] = DEFAULT_ICON if row[:icon].blank?\n+      row[:trigger] = Badge::Trigger::None unless valid_trigger?(row[:trigger])\n+\n+      # TODO: Update these if/when we add import steps for badge groupings and badge types\n+      #       Current implementation expects the converter to set final values\n+      row[:badge_grouping_id] = ensure_related_id(\n+        row[:badge_grouping_id],\n+        @existing_badge_grouping_ids,\n+        BadgeGrouping::Other,\n+      )\n+      row[:badge_type_id] = ensure_related_id(\n+        row[:badge_type_id],\n+        @existing_badge_type_ids,\n+        BadgeType::Silver,\n+      )\n+\n+      # TODO: Probably validate the imported query, maybe in some other step\n+      row[:query] = nil if !SiteSetting.enable_badge_sql? && row[:query].present?",
        "comment_created_at": "2025-06-23T13:10:30+00:00",
        "comment_author": "s3lase",
        "comment_body": "Sure, for now, I\u2019ve updated it to at least log with puts",
        "pr_file_module": null
      }
    ]
  }
]