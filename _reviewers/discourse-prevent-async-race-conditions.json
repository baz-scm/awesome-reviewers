[
  {
    "discussion_id": "2255812397",
    "pr_number": 33665,
    "pr_file": "app/assets/javascripts/admin/addon/components/site-setting.gjs",
    "created_at": "2025-08-06T04:09:25+00:00",
    "commented_code": "return this.setting.staffLogFilter;\n   }\n \n+  get canUpdate() {\n+    if (!this.status || this.status === \"completed\") {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2255812397",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33665,
        "pr_file": "app/assets/javascripts/admin/addon/components/site-setting.gjs",
        "discussion_id": "2255812397",
        "commented_code": "@@ -226,6 +264,14 @@ export default class SiteSettingComponent extends Component {\n     return this.setting.staffLogFilter;\n   }\n \n+  get canUpdate() {\n+    if (!this.status || this.status === \"completed\") {",
        "comment_created_at": "2025-08-06T04:09:25+00:00",
        "comment_author": "tgxworld",
        "comment_body": "If I reload the page, wouldn't the component show up as not having any `status` and thus be marked as updatable until I receive a new messageBus message since a new messageBus subscription by default only subscribes to the latest messages.",
        "pr_file_module": null
      },
      {
        "comment_id": "2258489997",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33665,
        "pr_file": "app/assets/javascripts/admin/addon/components/site-setting.gjs",
        "discussion_id": "2255812397",
        "commented_code": "@@ -226,6 +264,14 @@ export default class SiteSettingComponent extends Component {\n     return this.setting.staffLogFilter;\n   }\n \n+  get canUpdate() {\n+    if (!this.status || this.status === \"completed\") {",
        "comment_created_at": "2025-08-06T23:06:07+00:00",
        "comment_author": "jdmartinez1062",
        "comment_body": "I am not sure how big of an issue this would be since the job should update periodically on the completion status at every batch (50k records). Having said this, it is possible to try to update the setting again, which would make it so that the user could potentially enqueue more jobs. I could try to check if the job is running and throw an error, as Sam suggested previously.",
        "pr_file_module": null
      },
      {
        "comment_id": "2265563859",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33665,
        "pr_file": "app/assets/javascripts/admin/addon/components/site-setting.gjs",
        "discussion_id": "2255812397",
        "commented_code": "@@ -226,6 +264,14 @@ export default class SiteSettingComponent extends Component {\n     return this.setting.staffLogFilter;\n   }\n \n+  get canUpdate() {\n+    if (!this.status || this.status === \"completed\") {",
        "comment_created_at": "2025-08-11T02:24:48+00:00",
        "comment_author": "tgxworld",
        "comment_body": "I guess we can ignore this for now since the background job only has a cluster concurrency of 1. There is the risk that the original job may fail though and the new job runs before the old job. However, I think we have already decided to accept the risk for now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2268632440",
    "pr_number": 33992,
    "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation-menu.gjs",
    "created_at": "2025-08-12T05:37:46+00:00",
    "commented_code": "</template>;\n \n /**\n- * This component provides an input field and parsing logic for filter\n- * queries. Every time the input changes, we recalculate the list of\n- * filter tips that match the current input value.\n- *\n- * We start from an initial list of tips provided by the server\n- * (see TopicsFilter.option_info) which are reduced to a list of \"high priority/top-level\"\n- * filters if there is no user input value.\n+ * FilterNavigationMenu - A simpler UI component for filter input and suggestions\n  *\n- * Once the user starts typing, we parse the input value to determine\n- * the last word and its prefix (if any). If the last word contains a colon,\n- * we treat it as a filter name and look for matching tips via the FilterSuggestions service.\n- * For example after \"category:\" is typed we show a list of categories the user\n- * has access to.\n+ * This component manages:\n+ * - User input field\n+ * - Keyboard navigation\n+ * - Dropdown menu display\n+ * - Selection handling\n  *\n- * Each filter tip can have prefixes (like \"-\", \"=\", and \"-=\") that modify the filter behavior,\n- * as well as delimiters (like \",\") that allow for multiple values.\n+ * The actual suggestion generation is delegated to FilterSuggestions\n  */\n export default class FilterNavigationMenu extends Component {\n   @service menu;\n   @service site;\n \n-  @resettableTracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked suggestions = [];\n+  @tracked activeFilter = null;\n+  @tracked selectedIndex = -1;\n+\n+  lastSuggestionInput = \"\";\n+  suggestionRequestId = 0;\n \n-  filterSuggessionResults = [];\n-  activeFilter = null;\n   trackedMenuListData = new TrackedObject({\n-    filteredTips: this.filteredTips,\n+    suggestions: [],\n     selectedIndex: null,\n     selectItem: this.selectItem,\n   });\n \n-  @tracked _selectedIndex = -1;\n-\n-  get selectedIndex() {\n-    return this._selectedIndex;\n-  }\n-\n-  set selectedIndex(value) {\n-    this._selectedIndex = value;\n-    this.trackedMenuListData.selectedIndex = value;\n-  }\n-\n-  clearSelection() {\n-    this.selectedIndex = -1;\n-  }\n+  searchTimer = null;\n+  inputElement = null;\n+  dMenuInstance = null;\n \n   get nothingSelected() {\n     return this.selectedIndex === -1;\n   }\n \n-  get filteredTips() {\n-    if (!this.args.tips) {\n-      return [];\n-    }\n-\n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1).toLowerCase();\n-\n-    // If we're already filtering by a type like \"category:\" that has suggestions,\n-    // we want to only show those suggestions.\n-    if (this.activeFilter && this.filterSuggessionResults.length > 0) {\n-      return this.filterSuggessionResults;\n-    }\n-\n-    // We are filtering by a type here like \"category:\", \"tag:\", etc.\n-    // since the last word contains a colon.\n-    const colonIndex = lastWord.indexOf(\":\");\n-    const prefix = this.#extractPrefix(lastWord) || \"\";\n-    if (colonIndex > 0) {\n-      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n-      const valueText = lastWord.substring(colonIndex + 1);\n-      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n-\n-      if (tip?.type && valueText !== undefined) {\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-        return this.filterSuggessionResults.length > 0\n-          ? this.filterSuggessionResults\n-          : [];\n-      }\n-    }\n+  @action\n+  storeInputElement(element) {\n+    this.inputElement = element;\n+  }\n \n-    // Get a list of the \"top-level\" filters that have a priority of 1,\n-    // such as category:, created-after:, tags:, etc.\n-    if (!this.currentInputValue || lastWord === \"\") {\n-      return this.args.tips\n-        .filter((tip) => tip.priority)\n-        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n-        .slice(0, MAX_RESULTS);\n+  @action\n+  async updateSuggestions() {\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n     }\n-\n-    return this.filterAllTips(lastWord, prefix);\n+    this.searchTimer = discourseDebounce(this, this.fetchSuggestions, 300);\n   }\n \n-  /**\n-   * Filters all available tips based on a search term from the user input\n-   *\n-   * This method searches through the complete list of filter tips and finds matches based on:\n-   * 1. Direct name matches with the search term\n-   * 2. Matches against tip aliases\n-   * 3. Support for prefixed tips (like \"-\", \"=\", \"-=\")\n-   *\n-   * Results are sorted to prioritize exact matches first and are limited to MAX_RESULTS\n-   *\n-   * @param {string} lastWord - The last word in the input string (what user is currently typing)\n-   * @param {string} prefix - Any detected prefix modifier like \"-\", \"=\", or \"-=\"\n-   * @returns {Array} - Array of matching tip objects for display in the menu\n-   */\n-  filterAllTips(lastWord, prefix) {\n-    const tips = [];\n-    this.args.tips.forEach((tip) => {\n-      if (tips.length >= MAX_RESULTS) {\n-        return;\n-      }\n-      const tipName = tip.name;\n-      const searchTerm = lastWord.substring(prefix.length);\n-\n-      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n-        return;\n-      }\n+  async fetchSuggestions() {\n+    const input = this.currentInputValue || \"\";\n+    const requestId = ++this.suggestionRequestId;",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2268632440",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation-menu.gjs",
        "discussion_id": "2268632440",
        "commented_code": "@@ -52,324 +49,161 @@ const FilterNavigationMenuList = <template>\n </template>;\n \n /**\n- * This component provides an input field and parsing logic for filter\n- * queries. Every time the input changes, we recalculate the list of\n- * filter tips that match the current input value.\n- *\n- * We start from an initial list of tips provided by the server\n- * (see TopicsFilter.option_info) which are reduced to a list of \"high priority/top-level\"\n- * filters if there is no user input value.\n+ * FilterNavigationMenu - A simpler UI component for filter input and suggestions\n  *\n- * Once the user starts typing, we parse the input value to determine\n- * the last word and its prefix (if any). If the last word contains a colon,\n- * we treat it as a filter name and look for matching tips via the FilterSuggestions service.\n- * For example after \"category:\" is typed we show a list of categories the user\n- * has access to.\n+ * This component manages:\n+ * - User input field\n+ * - Keyboard navigation\n+ * - Dropdown menu display\n+ * - Selection handling\n  *\n- * Each filter tip can have prefixes (like \"-\", \"=\", and \"-=\") that modify the filter behavior,\n- * as well as delimiters (like \",\") that allow for multiple values.\n+ * The actual suggestion generation is delegated to FilterSuggestions\n  */\n export default class FilterNavigationMenu extends Component {\n   @service menu;\n   @service site;\n \n-  @resettableTracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked suggestions = [];\n+  @tracked activeFilter = null;\n+  @tracked selectedIndex = -1;\n+\n+  lastSuggestionInput = \"\";\n+  suggestionRequestId = 0;\n \n-  filterSuggessionResults = [];\n-  activeFilter = null;\n   trackedMenuListData = new TrackedObject({\n-    filteredTips: this.filteredTips,\n+    suggestions: [],\n     selectedIndex: null,\n     selectItem: this.selectItem,\n   });\n \n-  @tracked _selectedIndex = -1;\n-\n-  get selectedIndex() {\n-    return this._selectedIndex;\n-  }\n-\n-  set selectedIndex(value) {\n-    this._selectedIndex = value;\n-    this.trackedMenuListData.selectedIndex = value;\n-  }\n-\n-  clearSelection() {\n-    this.selectedIndex = -1;\n-  }\n+  searchTimer = null;\n+  inputElement = null;\n+  dMenuInstance = null;\n \n   get nothingSelected() {\n     return this.selectedIndex === -1;\n   }\n \n-  get filteredTips() {\n-    if (!this.args.tips) {\n-      return [];\n-    }\n-\n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1).toLowerCase();\n-\n-    // If we're already filtering by a type like \"category:\" that has suggestions,\n-    // we want to only show those suggestions.\n-    if (this.activeFilter && this.filterSuggessionResults.length > 0) {\n-      return this.filterSuggessionResults;\n-    }\n-\n-    // We are filtering by a type here like \"category:\", \"tag:\", etc.\n-    // since the last word contains a colon.\n-    const colonIndex = lastWord.indexOf(\":\");\n-    const prefix = this.#extractPrefix(lastWord) || \"\";\n-    if (colonIndex > 0) {\n-      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n-      const valueText = lastWord.substring(colonIndex + 1);\n-      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n-\n-      if (tip?.type && valueText !== undefined) {\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-        return this.filterSuggessionResults.length > 0\n-          ? this.filterSuggessionResults\n-          : [];\n-      }\n-    }\n+  @action\n+  storeInputElement(element) {\n+    this.inputElement = element;\n+  }\n \n-    // Get a list of the \"top-level\" filters that have a priority of 1,\n-    // such as category:, created-after:, tags:, etc.\n-    if (!this.currentInputValue || lastWord === \"\") {\n-      return this.args.tips\n-        .filter((tip) => tip.priority)\n-        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n-        .slice(0, MAX_RESULTS);\n+  @action\n+  async updateSuggestions() {\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n     }\n-\n-    return this.filterAllTips(lastWord, prefix);\n+    this.searchTimer = discourseDebounce(this, this.fetchSuggestions, 300);\n   }\n \n-  /**\n-   * Filters all available tips based on a search term from the user input\n-   *\n-   * This method searches through the complete list of filter tips and finds matches based on:\n-   * 1. Direct name matches with the search term\n-   * 2. Matches against tip aliases\n-   * 3. Support for prefixed tips (like \"-\", \"=\", \"-=\")\n-   *\n-   * Results are sorted to prioritize exact matches first and are limited to MAX_RESULTS\n-   *\n-   * @param {string} lastWord - The last word in the input string (what user is currently typing)\n-   * @param {string} prefix - Any detected prefix modifier like \"-\", \"=\", or \"-=\"\n-   * @returns {Array} - Array of matching tip objects for display in the menu\n-   */\n-  filterAllTips(lastWord, prefix) {\n-    const tips = [];\n-    this.args.tips.forEach((tip) => {\n-      if (tips.length >= MAX_RESULTS) {\n-        return;\n-      }\n-      const tipName = tip.name;\n-      const searchTerm = lastWord.substring(prefix.length);\n-\n-      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n-        return;\n-      }\n+  async fetchSuggestions() {\n+    const input = this.currentInputValue || \"\";\n+    const requestId = ++this.suggestionRequestId;",
        "comment_created_at": "2025-08-12T05:37:46+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "I'm not sure why this request ID stuff is needed, the debounce should handle this, or at least that was my understanding of it",
        "pr_file_module": null
      },
      {
        "comment_id": "2268747588",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation-menu.gjs",
        "discussion_id": "2268632440",
        "commented_code": "@@ -52,324 +49,161 @@ const FilterNavigationMenuList = <template>\n </template>;\n \n /**\n- * This component provides an input field and parsing logic for filter\n- * queries. Every time the input changes, we recalculate the list of\n- * filter tips that match the current input value.\n- *\n- * We start from an initial list of tips provided by the server\n- * (see TopicsFilter.option_info) which are reduced to a list of \"high priority/top-level\"\n- * filters if there is no user input value.\n+ * FilterNavigationMenu - A simpler UI component for filter input and suggestions\n  *\n- * Once the user starts typing, we parse the input value to determine\n- * the last word and its prefix (if any). If the last word contains a colon,\n- * we treat it as a filter name and look for matching tips via the FilterSuggestions service.\n- * For example after \"category:\" is typed we show a list of categories the user\n- * has access to.\n+ * This component manages:\n+ * - User input field\n+ * - Keyboard navigation\n+ * - Dropdown menu display\n+ * - Selection handling\n  *\n- * Each filter tip can have prefixes (like \"-\", \"=\", and \"-=\") that modify the filter behavior,\n- * as well as delimiters (like \",\") that allow for multiple values.\n+ * The actual suggestion generation is delegated to FilterSuggestions\n  */\n export default class FilterNavigationMenu extends Component {\n   @service menu;\n   @service site;\n \n-  @resettableTracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked suggestions = [];\n+  @tracked activeFilter = null;\n+  @tracked selectedIndex = -1;\n+\n+  lastSuggestionInput = \"\";\n+  suggestionRequestId = 0;\n \n-  filterSuggessionResults = [];\n-  activeFilter = null;\n   trackedMenuListData = new TrackedObject({\n-    filteredTips: this.filteredTips,\n+    suggestions: [],\n     selectedIndex: null,\n     selectItem: this.selectItem,\n   });\n \n-  @tracked _selectedIndex = -1;\n-\n-  get selectedIndex() {\n-    return this._selectedIndex;\n-  }\n-\n-  set selectedIndex(value) {\n-    this._selectedIndex = value;\n-    this.trackedMenuListData.selectedIndex = value;\n-  }\n-\n-  clearSelection() {\n-    this.selectedIndex = -1;\n-  }\n+  searchTimer = null;\n+  inputElement = null;\n+  dMenuInstance = null;\n \n   get nothingSelected() {\n     return this.selectedIndex === -1;\n   }\n \n-  get filteredTips() {\n-    if (!this.args.tips) {\n-      return [];\n-    }\n-\n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1).toLowerCase();\n-\n-    // If we're already filtering by a type like \"category:\" that has suggestions,\n-    // we want to only show those suggestions.\n-    if (this.activeFilter && this.filterSuggessionResults.length > 0) {\n-      return this.filterSuggessionResults;\n-    }\n-\n-    // We are filtering by a type here like \"category:\", \"tag:\", etc.\n-    // since the last word contains a colon.\n-    const colonIndex = lastWord.indexOf(\":\");\n-    const prefix = this.#extractPrefix(lastWord) || \"\";\n-    if (colonIndex > 0) {\n-      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n-      const valueText = lastWord.substring(colonIndex + 1);\n-      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n-\n-      if (tip?.type && valueText !== undefined) {\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-        return this.filterSuggessionResults.length > 0\n-          ? this.filterSuggessionResults\n-          : [];\n-      }\n-    }\n+  @action\n+  storeInputElement(element) {\n+    this.inputElement = element;\n+  }\n \n-    // Get a list of the \"top-level\" filters that have a priority of 1,\n-    // such as category:, created-after:, tags:, etc.\n-    if (!this.currentInputValue || lastWord === \"\") {\n-      return this.args.tips\n-        .filter((tip) => tip.priority)\n-        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n-        .slice(0, MAX_RESULTS);\n+  @action\n+  async updateSuggestions() {\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n     }\n-\n-    return this.filterAllTips(lastWord, prefix);\n+    this.searchTimer = discourseDebounce(this, this.fetchSuggestions, 300);\n   }\n \n-  /**\n-   * Filters all available tips based on a search term from the user input\n-   *\n-   * This method searches through the complete list of filter tips and finds matches based on:\n-   * 1. Direct name matches with the search term\n-   * 2. Matches against tip aliases\n-   * 3. Support for prefixed tips (like \"-\", \"=\", \"-=\")\n-   *\n-   * Results are sorted to prioritize exact matches first and are limited to MAX_RESULTS\n-   *\n-   * @param {string} lastWord - The last word in the input string (what user is currently typing)\n-   * @param {string} prefix - Any detected prefix modifier like \"-\", \"=\", or \"-=\"\n-   * @returns {Array} - Array of matching tip objects for display in the menu\n-   */\n-  filterAllTips(lastWord, prefix) {\n-    const tips = [];\n-    this.args.tips.forEach((tip) => {\n-      if (tips.length >= MAX_RESULTS) {\n-        return;\n-      }\n-      const tipName = tip.name;\n-      const searchTerm = lastWord.substring(prefix.length);\n-\n-      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n-        return;\n-      }\n+  async fetchSuggestions() {\n+    const input = this.currentInputValue || \"\";\n+    const requestId = ++this.suggestionRequestId;",
        "comment_created_at": "2025-08-12T06:36:11+00:00",
        "comment_author": "SamSaffron",
        "comment_body": "it does not, I had a bug where when you type quickly and then hit TAB it would complete the wrong thing, the requestId stuff ensures we never complete the wrong thing. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2271884001",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation-menu.gjs",
        "discussion_id": "2268632440",
        "commented_code": "@@ -52,324 +49,161 @@ const FilterNavigationMenuList = <template>\n </template>;\n \n /**\n- * This component provides an input field and parsing logic for filter\n- * queries. Every time the input changes, we recalculate the list of\n- * filter tips that match the current input value.\n- *\n- * We start from an initial list of tips provided by the server\n- * (see TopicsFilter.option_info) which are reduced to a list of \"high priority/top-level\"\n- * filters if there is no user input value.\n+ * FilterNavigationMenu - A simpler UI component for filter input and suggestions\n  *\n- * Once the user starts typing, we parse the input value to determine\n- * the last word and its prefix (if any). If the last word contains a colon,\n- * we treat it as a filter name and look for matching tips via the FilterSuggestions service.\n- * For example after \"category:\" is typed we show a list of categories the user\n- * has access to.\n+ * This component manages:\n+ * - User input field\n+ * - Keyboard navigation\n+ * - Dropdown menu display\n+ * - Selection handling\n  *\n- * Each filter tip can have prefixes (like \"-\", \"=\", and \"-=\") that modify the filter behavior,\n- * as well as delimiters (like \",\") that allow for multiple values.\n+ * The actual suggestion generation is delegated to FilterSuggestions\n  */\n export default class FilterNavigationMenu extends Component {\n   @service menu;\n   @service site;\n \n-  @resettableTracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked suggestions = [];\n+  @tracked activeFilter = null;\n+  @tracked selectedIndex = -1;\n+\n+  lastSuggestionInput = \"\";\n+  suggestionRequestId = 0;\n \n-  filterSuggessionResults = [];\n-  activeFilter = null;\n   trackedMenuListData = new TrackedObject({\n-    filteredTips: this.filteredTips,\n+    suggestions: [],\n     selectedIndex: null,\n     selectItem: this.selectItem,\n   });\n \n-  @tracked _selectedIndex = -1;\n-\n-  get selectedIndex() {\n-    return this._selectedIndex;\n-  }\n-\n-  set selectedIndex(value) {\n-    this._selectedIndex = value;\n-    this.trackedMenuListData.selectedIndex = value;\n-  }\n-\n-  clearSelection() {\n-    this.selectedIndex = -1;\n-  }\n+  searchTimer = null;\n+  inputElement = null;\n+  dMenuInstance = null;\n \n   get nothingSelected() {\n     return this.selectedIndex === -1;\n   }\n \n-  get filteredTips() {\n-    if (!this.args.tips) {\n-      return [];\n-    }\n-\n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1).toLowerCase();\n-\n-    // If we're already filtering by a type like \"category:\" that has suggestions,\n-    // we want to only show those suggestions.\n-    if (this.activeFilter && this.filterSuggessionResults.length > 0) {\n-      return this.filterSuggessionResults;\n-    }\n-\n-    // We are filtering by a type here like \"category:\", \"tag:\", etc.\n-    // since the last word contains a colon.\n-    const colonIndex = lastWord.indexOf(\":\");\n-    const prefix = this.#extractPrefix(lastWord) || \"\";\n-    if (colonIndex > 0) {\n-      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n-      const valueText = lastWord.substring(colonIndex + 1);\n-      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n-\n-      if (tip?.type && valueText !== undefined) {\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-        return this.filterSuggessionResults.length > 0\n-          ? this.filterSuggessionResults\n-          : [];\n-      }\n-    }\n+  @action\n+  storeInputElement(element) {\n+    this.inputElement = element;\n+  }\n \n-    // Get a list of the \"top-level\" filters that have a priority of 1,\n-    // such as category:, created-after:, tags:, etc.\n-    if (!this.currentInputValue || lastWord === \"\") {\n-      return this.args.tips\n-        .filter((tip) => tip.priority)\n-        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n-        .slice(0, MAX_RESULTS);\n+  @action\n+  async updateSuggestions() {\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n     }\n-\n-    return this.filterAllTips(lastWord, prefix);\n+    this.searchTimer = discourseDebounce(this, this.fetchSuggestions, 300);\n   }\n \n-  /**\n-   * Filters all available tips based on a search term from the user input\n-   *\n-   * This method searches through the complete list of filter tips and finds matches based on:\n-   * 1. Direct name matches with the search term\n-   * 2. Matches against tip aliases\n-   * 3. Support for prefixed tips (like \"-\", \"=\", \"-=\")\n-   *\n-   * Results are sorted to prioritize exact matches first and are limited to MAX_RESULTS\n-   *\n-   * @param {string} lastWord - The last word in the input string (what user is currently typing)\n-   * @param {string} prefix - Any detected prefix modifier like \"-\", \"=\", or \"-=\"\n-   * @returns {Array} - Array of matching tip objects for display in the menu\n-   */\n-  filterAllTips(lastWord, prefix) {\n-    const tips = [];\n-    this.args.tips.forEach((tip) => {\n-      if (tips.length >= MAX_RESULTS) {\n-        return;\n-      }\n-      const tipName = tip.name;\n-      const searchTerm = lastWord.substring(prefix.length);\n-\n-      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n-        return;\n-      }\n+  async fetchSuggestions() {\n+    const input = this.currentInputValue || \"\";\n+    const requestId = ++this.suggestionRequestId;",
        "comment_created_at": "2025-08-13T01:48:07+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "I'm just not sure because I haven't seen this pattern elsewhere in the codebase. I guess leave it for this PR, and we can ask CVX for a followup...I'm pretty sure the best way would be to use `AbortController` instead, and pass an instance of it to the suggester",
        "pr_file_module": null
      }
    ]
  }
]