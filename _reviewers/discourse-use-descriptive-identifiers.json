[
  {
    "discussion_id": "2294191236",
    "pr_number": 34491,
    "pr_file": "migrations/lib/importer/copy_step.rb",
    "created_at": "2025-08-22T16:40:09+00:00",
    "commented_code": "def execute\n       super\n       with_progressbar(total_count) { copy_data }\n+      after_copy_data",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2294191236",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34491,
        "pr_file": "migrations/lib/importer/copy_step.rb",
        "discussion_id": "2294191236",
        "commented_code": "@@ -67,6 +67,7 @@ def initialize(intermediate_db, discourse_db, shared_data)\n     def execute\n       super\n       with_progressbar(total_count) { copy_data }\n+      after_copy_data",
        "comment_created_at": "2025-08-22T16:40:09+00:00",
        "comment_author": "s3lase",
        "comment_body": "I\u2019m wondering if we should also add a `before_copy_data` hook. Right now, most pre-copy actions are handled by extending `execute`. If we\u2019re introducing a dedicated hook for post-copy hook (which feels more intuitive), should we also add one for pre-copy actions to stay consistent?\n\nThe main reason I haven\u2019t added it yet is, I'm concerned about the extra empty method dispatch overhead this would introduce in `CopyStep` for all steps. I know it's negligible compared to everything else but if we can avoid it why not?\n\nAnother consideration is naming. Should the hook be tightly tied to the `copy_data` method, or would a more generic name make sense?",
        "pr_file_module": null
      },
      {
        "comment_id": "2294614769",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34491,
        "pr_file": "migrations/lib/importer/copy_step.rb",
        "discussion_id": "2294191236",
        "commented_code": "@@ -67,6 +67,7 @@ def initialize(intermediate_db, discourse_db, shared_data)\n     def execute\n       super\n       with_progressbar(total_count) { copy_data }\n+      after_copy_data",
        "comment_created_at": "2025-08-22T20:04:51+00:00",
        "comment_author": "gschlager",
        "comment_body": "I wouldn't worry about an empty method, as it's only called once per step. Now that I think about it, yes, generic names would be better. Maybe simply call them `before` and `after`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288740302",
    "pr_number": 33984,
    "pr_file": "migrations/lib/importer/steps/tag_synonyms.rb",
    "created_at": "2025-08-20T16:41:48+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class TagSynonyms < Base::Tags\n+    depends_on :tags\n+\n+    requires_set :existing_synonym_tag_ids, \"SELECT id FROM tags WHERE target_tag_id IS NOT NULL\"\n+\n+    total_rows_query <<~SQL, MappingType::TAGS\n+      SELECT COUNT(*)\n+      FROM tag_synonyms\n+        JOIN mapped.ids mapped_target_tag\n+          ON tag_synonyms.target_tag_id = mapped_target_tag.original_id\n+             AND mapped_target_tag.type = ?1\n+        LEFT JOIN mapped.ids mapped_synonym_tag\n+          ON tag_synonyms.synonym_tag_id = mapped_synonym_tag.original_id\n+             AND mapped_synonym_tag.type = ?1\n+      WHERE mapped_synonym_tag.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::TAGS\n+      SELECT tags.*,\n+             tag_synonyms.target_tag_id     AS original_target_tag_id,\n+             mapped_target_tag.discourse_id AS discourse_target_tag_id\n+      FROM tags\n+           JOIN tag_synonyms ON tags.original_id = tag_synonyms.synonym_tag_id\n+           JOIN mapped.ids mapped_target_tag\n+             ON tag_synonyms.target_tag_id = mapped_target_tag.original_id\n+                AND mapped_target_tag.type = ?1\n+           LEFT JOIN mapped.ids mapped_synonym_tag\n+             ON tags.original_id = mapped_synonym_tag.original_id\n+                AND mapped_synonym_tag.type = ?1\n+      WHERE mapped_synonym_tag.original_id IS NULL\n+      ORDER BY tags.original_id\n+    SQL\n+\n+    def load_validation_caches\n+      @synonym_target_tag_ids = Set.new\n+      @synonym_tag_ids = Set.new\n+\n+      @intermediate_db\n+        .query_array(\"SELECT synonym_tag_id, target_tag_id FROM tag_synonyms\")\n+        .each do |synonym_id, target_id|\n+          @synonym_tag_ids.add(synonym_id)\n+          @synonym_target_tag_ids.add(target_id)\n+        end\n+    end\n+\n+    def apply_transforms(row)\n+      original_id = row[:original_id]\n+      name = row[:name]\n+\n+      if @synonym_target_tag_ids.include?(original_id)\n+        puts \"    Tag '#{name}' cannot become a synonym because it already has synonyms\"\n+\n+        return nil\n+      end",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2288740302",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33984,
        "pr_file": "migrations/lib/importer/steps/tag_synonyms.rb",
        "discussion_id": "2288740302",
        "commented_code": "@@ -0,0 +1,79 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class TagSynonyms < Base::Tags\n+    depends_on :tags\n+\n+    requires_set :existing_synonym_tag_ids, \"SELECT id FROM tags WHERE target_tag_id IS NOT NULL\"\n+\n+    total_rows_query <<~SQL, MappingType::TAGS\n+      SELECT COUNT(*)\n+      FROM tag_synonyms\n+        JOIN mapped.ids mapped_target_tag\n+          ON tag_synonyms.target_tag_id = mapped_target_tag.original_id\n+             AND mapped_target_tag.type = ?1\n+        LEFT JOIN mapped.ids mapped_synonym_tag\n+          ON tag_synonyms.synonym_tag_id = mapped_synonym_tag.original_id\n+             AND mapped_synonym_tag.type = ?1\n+      WHERE mapped_synonym_tag.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::TAGS\n+      SELECT tags.*,\n+             tag_synonyms.target_tag_id     AS original_target_tag_id,\n+             mapped_target_tag.discourse_id AS discourse_target_tag_id\n+      FROM tags\n+           JOIN tag_synonyms ON tags.original_id = tag_synonyms.synonym_tag_id\n+           JOIN mapped.ids mapped_target_tag\n+             ON tag_synonyms.target_tag_id = mapped_target_tag.original_id\n+                AND mapped_target_tag.type = ?1\n+           LEFT JOIN mapped.ids mapped_synonym_tag\n+             ON tags.original_id = mapped_synonym_tag.original_id\n+                AND mapped_synonym_tag.type = ?1\n+      WHERE mapped_synonym_tag.original_id IS NULL\n+      ORDER BY tags.original_id\n+    SQL\n+\n+    def load_validation_caches\n+      @synonym_target_tag_ids = Set.new\n+      @synonym_tag_ids = Set.new\n+\n+      @intermediate_db\n+        .query_array(\"SELECT synonym_tag_id, target_tag_id FROM tag_synonyms\")\n+        .each do |synonym_id, target_id|\n+          @synonym_tag_ids.add(synonym_id)\n+          @synonym_target_tag_ids.add(target_id)\n+        end\n+    end\n+\n+    def apply_transforms(row)\n+      original_id = row[:original_id]\n+      name = row[:name]\n+\n+      if @synonym_target_tag_ids.include?(original_id)\n+        puts \"    Tag '#{name}' cannot become a synonym because it already has synonyms\"\n+\n+        return nil\n+      end",
        "comment_created_at": "2025-08-20T16:41:48+00:00",
        "comment_author": "gschlager",
        "comment_body": "I find this check and the error message difficult to understand at a quick glance. I think we could improve it by either using a different variable name or changing the error message.\n\n1. Variable Name: Maybe `@tags_with_synonyms` or `@tags_that_are_synonym_targets`?\n2. Error Message\n    * \"Tag '#{name}' cannot become a synonym because it is already the target of one or more synonyms\"\n    * Or: \"Tag '#{name}' is already a synonym target and cannot itself become a synonym\"\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2271335721",
    "pr_number": 34187,
    "pr_file": "app/models/concerns/reports/associated_accounts_by_provider.rb",
    "created_at": "2025-08-12T21:36:18+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Reports::AssociatedAccountsByProvider\n+  extend ActiveSupport::Concern\n+\n+  class_methods do\n+    def report_associated_accounts_by_provider(report)\n+      report.data = []\n+      report.modes = [Report::MODES[:table]]\n+\n+      report.dates_filtering = false\n+\n+      report.labels = [\n+        { property: :x, title: I18n.t(\"reports.associated_accounts_by_provider.labels.provider\") },",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2271335721",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34187,
        "pr_file": "app/models/concerns/reports/associated_accounts_by_provider.rb",
        "discussion_id": "2271335721",
        "commented_code": "@@ -0,0 +1,71 @@\n+# frozen_string_literal: true\n+\n+module Reports::AssociatedAccountsByProvider\n+  extend ActiveSupport::Concern\n+\n+  class_methods do\n+    def report_associated_accounts_by_provider(report)\n+      report.data = []\n+      report.modes = [Report::MODES[:table]]\n+\n+      report.dates_filtering = false\n+\n+      report.labels = [\n+        { property: :x, title: I18n.t(\"reports.associated_accounts_by_provider.labels.provider\") },",
        "comment_created_at": "2025-08-12T21:36:18+00:00",
        "comment_author": "brrusselburg",
        "comment_body": "any reason why you went with x/y for the property names?",
        "pr_file_module": null
      },
      {
        "comment_id": "2271392475",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34187,
        "pr_file": "app/models/concerns/reports/associated_accounts_by_provider.rb",
        "discussion_id": "2271335721",
        "commented_code": "@@ -0,0 +1,71 @@\n+# frozen_string_literal: true\n+\n+module Reports::AssociatedAccountsByProvider\n+  extend ActiveSupport::Concern\n+\n+  class_methods do\n+    def report_associated_accounts_by_provider(report)\n+      report.data = []\n+      report.modes = [Report::MODES[:table]]\n+\n+      report.dates_filtering = false\n+\n+      report.labels = [\n+        { property: :x, title: I18n.t(\"reports.associated_accounts_by_provider.labels.provider\") },",
        "comment_created_at": "2025-08-12T22:00:33+00:00",
        "comment_author": "pmusaraj",
        "comment_body": "Good catch, no reason, in fact, it's better to be clearer. Updated the names, thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2255612698",
    "pr_number": 33992,
    "pr_file": "plugins/discourse-assign/plugin.rb",
    "created_at": "2025-08-06T00:49:06+00:00",
    "commented_code": "add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    names.each do |name|\n+      if user_id = User.find_by_username(name)&.id\n+        user_ids << user_id\n+      elsif group_id = Group.find_by(name: name)&.id\n+        group_ids << group_id\n+      end\n+    end\n+\n+    conditions = []\n+    params = []\n+\n+    if user_ids.present?\n+      conditions << \"a.assigned_to_id IN (?) AND a.assigned_to_type = 'User' AND a.active\"\n+      params << user_ids\n+    end\n+\n+    if group_ids.present?\n+      conditions << \"a.assigned_to_id IN (?) AND a.assigned_to_type = 'Group' AND a.active\"\n+      params << group_ids\n+    end\n+\n+    if conditions.present?\n+      sql_conditions = conditions.join(\" OR \")\n+      scope.where(\n+        \"topics.id IN (SELECT a.topic_id FROM assignments a WHERE #{sql_conditions})\",\n+        *params,",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2255612698",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "plugins/discourse-assign/plugin.rb",
        "discussion_id": "2255612698",
        "commented_code": "@@ -892,19 +892,69 @@ module ::DiscourseAssign\n   add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    names.each do |name|\n+      if user_id = User.find_by_username(name)&.id\n+        user_ids << user_id\n+      elsif group_id = Group.find_by(name: name)&.id\n+        group_ids << group_id\n+      end\n+    end\n+\n+    conditions = []\n+    params = []\n+\n+    if user_ids.present?\n+      conditions << \"a.assigned_to_id IN (?) AND a.assigned_to_type = 'User' AND a.active\"\n+      params << user_ids\n+    end\n+\n+    if group_ids.present?\n+      conditions << \"a.assigned_to_id IN (?) AND a.assigned_to_type = 'Group' AND a.active\"\n+      params << group_ids\n+    end\n+\n+    if conditions.present?\n+      sql_conditions = conditions.join(\" OR \")\n+      scope.where(\n+        \"topics.id IN (SELECT a.topic_id FROM assignments a WHERE #{sql_conditions})\",\n+        *params,",
        "comment_created_at": "2025-08-06T00:49:06+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "Using the `?` placeholders and arrays for the params feels like of dangerous here...if things were rearranged a bit this could introduce some subtle bugs. IMO change this and the above to use `:group_ids` and `:user_ids` to make this clearer and more intentional",
        "pr_file_module": null
      },
      {
        "comment_id": "2255875962",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "plugins/discourse-assign/plugin.rb",
        "discussion_id": "2255612698",
        "commented_code": "@@ -892,19 +892,69 @@ module ::DiscourseAssign\n   add_filter_custom_filter(\"assigned\") do |scope, filter_values, guardian|\n     next if !guardian.can_assign? || filter_values.blank?\n \n-    user_or_group_name = filter_values.compact.first\n+    # Handle multiple comma-separated values (user1,group1,user2)\n+    names =\n+      filter_values.compact.flat_map { |value| value.to_s.split(\",\") }.map(&:strip).reject(&:blank?)\n \n-    next if user_or_group_name.blank?\n+    next if names.blank?\n \n-    if user_id = User.find_by_username(user_or_group_name)&.id\n-      scope.where(<<~SQL, user_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'User' AND a.active)\n-      SQL\n-    elsif group_id = Group.find_by(name: user_or_group_name)&.id\n-      scope.where(<<~SQL, group_id)\n-        topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.assigned_to_id = ? AND a.assigned_to_type = 'Group' AND a.active)\n-      SQL\n+    if names.include?(\"nobody\")\n+      next scope.where(\"topics.id NOT IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    if names.include?(\"*\")\n+      next scope.where(\"topics.id IN (SELECT a.topic_id FROM assignments a WHERE a.active)\")\n+    end\n+\n+    user_ids = []\n+    group_ids = []\n+\n+    names.each do |name|\n+      if user_id = User.find_by_username(name)&.id\n+        user_ids << user_id\n+      elsif group_id = Group.find_by(name: name)&.id\n+        group_ids << group_id\n+      end\n+    end\n+\n+    conditions = []\n+    params = []\n+\n+    if user_ids.present?\n+      conditions << \"a.assigned_to_id IN (?) AND a.assigned_to_type = 'User' AND a.active\"\n+      params << user_ids\n+    end\n+\n+    if group_ids.present?\n+      conditions << \"a.assigned_to_id IN (?) AND a.assigned_to_type = 'Group' AND a.active\"\n+      params << group_ids\n+    end\n+\n+    if conditions.present?\n+      sql_conditions = conditions.join(\" OR \")\n+      scope.where(\n+        \"topics.id IN (SELECT a.topic_id FROM assignments a WHERE #{sql_conditions})\",\n+        *params,",
        "comment_created_at": "2025-08-06T05:08:37+00:00",
        "comment_author": "SamSaffron",
        "comment_body": "sure will change it ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2254944585",
    "pr_number": 33072,
    "pr_file": "app/controllers/application_controller.rb",
    "created_at": "2025-08-05T17:37:18+00:00",
    "commented_code": "raise Discourse::InvalidAccess.new unless SiteSetting.wizard_enabled?\n   end\n \n+  # Keep in sync with `NO_COOKIE` in `app/assets/javascripts/discourse/app/lib/utilities.js`",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2254944585",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33072,
        "pr_file": "app/controllers/application_controller.rb",
        "discussion_id": "2254944585",
        "commented_code": "@@ -732,8 +732,15 @@ def ensure_wizard_enabled\n     raise Discourse::InvalidAccess.new unless SiteSetting.wizard_enabled?\n   end\n \n+  # Keep in sync with `NO_COOKIE` in `app/assets/javascripts/discourse/app/lib/utilities.js`",
        "comment_created_at": "2025-08-05T17:37:18+00:00",
        "comment_author": "pmusaraj",
        "comment_body": "Super nitpick, but I would rename the constant here and in `utilities.js` to `NO_DESTINATION_COOKIE`, for clarity. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2255150825",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33072,
        "pr_file": "app/controllers/application_controller.rb",
        "discussion_id": "2254944585",
        "commented_code": "@@ -732,8 +732,15 @@ def ensure_wizard_enabled\n     raise Discourse::InvalidAccess.new unless SiteSetting.wizard_enabled?\n   end\n \n+  # Keep in sync with `NO_COOKIE` in `app/assets/javascripts/discourse/app/lib/utilities.js`",
        "comment_created_at": "2025-08-05T19:26:27+00:00",
        "comment_author": "ZogStriP",
        "comment_body": "Will do \ud83d\udc4d ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2241366742",
    "pr_number": 33926,
    "pr_file": "app/models/topic.rb",
    "created_at": "2025-07-30T01:57:18+00:00",
    "commented_code": "def reset_bumped_at(post_id = nil)\n     post =\n-      (\n+      if post_id.is_a?(Post)",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2241366742",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33926,
        "pr_file": "app/models/topic.rb",
        "discussion_id": "2241366742",
        "commented_code": "@@ -1924,7 +1924,9 @@ def is_category_topic?\n \n   def reset_bumped_at(post_id = nil)\n     post =\n-      (\n+      if post_id.is_a?(Post)",
        "comment_created_at": "2025-07-30T01:57:18+00:00",
        "comment_author": "tgxworld",
        "comment_body": "```suggestion\n      if post_or_post_id.is_a?(Post)\n```\n\nWe usually name the argument something like the above to make it clear that the argument can both be an instance of `Post` or `Post#id`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2241370850",
    "pr_number": 33926,
    "pr_file": "app/models/topic.rb",
    "created_at": "2025-07-30T02:02:10+00:00",
    "commented_code": "def reset_bumped_at(post_id = nil)",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2241370850",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33926,
        "pr_file": "app/models/topic.rb",
        "discussion_id": "2241370850",
        "commented_code": "@@ -1924,7 +1924,9 @@ def is_category_topic?\n \n   def reset_bumped_at(post_id = nil)",
        "comment_created_at": "2025-07-30T02:02:10+00:00",
        "comment_author": "Lhcfl",
        "comment_body": "```suggestion\r\n  def reset_bumped_at(post_or_post_id = nil)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2230271689",
    "pr_number": 33850,
    "pr_file": "lib/validators/form_template_yaml_validator.rb",
    "created_at": "2025-07-25T06:34:20+00:00",
    "commented_code": "check_ids(record, field, existing_ids)\n         check_descriptions_html(record, field)\n       end\n+\n+      check_tag_groups(record, yaml.map { |f| f[\"tag_group\"] }.compact.map(&:downcase).uniq)",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2230271689",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33850,
        "pr_file": "lib/validators/form_template_yaml_validator.rb",
        "discussion_id": "2230271689",
        "commented_code": "@@ -31,6 +31,8 @@ def validate(record)\n         check_ids(record, field, existing_ids)\n         check_descriptions_html(record, field)\n       end\n+\n+      check_tag_groups(record, yaml.map { |f| f[\"tag_group\"] }.compact.map(&:downcase).uniq)",
        "comment_created_at": "2025-07-25T06:34:20+00:00",
        "comment_author": "tgxworld",
        "comment_body": "```suggestion\n      check_tag_groups(record, yaml.map { |f| f[\"tag_group\"] })\n```\n\nI feel like `.compact.map(&:downcase).uniq` should be done in `check_tag_groups`. Otherwise, it isn't clear that the `tag_group_names` argument expects an array of tag group names that have been compacted and downcased.",
        "pr_file_module": null
      },
      {
        "comment_id": "2230637229",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33850,
        "pr_file": "lib/validators/form_template_yaml_validator.rb",
        "discussion_id": "2230271689",
        "commented_code": "@@ -31,6 +31,8 @@ def validate(record)\n         check_ids(record, field, existing_ids)\n         check_descriptions_html(record, field)\n       end\n+\n+      check_tag_groups(record, yaml.map { |f| f[\"tag_group\"] }.compact.map(&:downcase).uniq)",
        "comment_created_at": "2025-07-25T09:32:58+00:00",
        "comment_author": "Lhcfl",
        "comment_body": "good idea! resolved this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2077537592",
    "pr_number": 32561,
    "pr_file": "script/bulk_import/generic_bulk.rb",
    "created_at": "2025-05-07T12:41:15+00:00",
    "commented_code": "import_category_tag_groups\n     import_category_permissions\n     import_category_users\n+    import_category_moderation_groups\n+    update_read_restricted_flags",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2077537592",
        "repo_full_name": "discourse/discourse",
        "pr_number": 32561,
        "pr_file": "script/bulk_import/generic_bulk.rb",
        "discussion_id": "2077537592",
        "commented_code": "@@ -77,6 +77,8 @@ def execute\n     import_category_tag_groups\n     import_category_permissions\n     import_category_users\n+    import_category_moderation_groups\n+    update_read_restricted_flags",
        "comment_created_at": "2025-05-07T12:41:15+00:00",
        "comment_author": "s3lase",
        "comment_body": "Tiny nit, for clarity, could the method name explicitly mention category, even though it's colocated? Maybe `update_category_read_restricted`?. Makes it more obvious at first glance and consistent with other similar steps",
        "pr_file_module": null
      },
      {
        "comment_id": "2112002062",
        "repo_full_name": "discourse/discourse",
        "pr_number": 32561,
        "pr_file": "script/bulk_import/generic_bulk.rb",
        "discussion_id": "2077537592",
        "commented_code": "@@ -77,6 +77,8 @@ def execute\n     import_category_tag_groups\n     import_category_permissions\n     import_category_users\n+    import_category_moderation_groups\n+    update_read_restricted_flags",
        "comment_created_at": "2025-05-28T14:00:39+00:00",
        "comment_author": "RubenOussoren",
        "comment_body": "No worries, updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2165232106",
    "pr_number": 33067,
    "pr_file": "migrations/lib/importer/steps/categories.rb",
    "created_at": "2025-06-25T01:08:09+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Categories < ::Migrations::Importer::CopyStep\n+    DEFAULT_COLOR = \"0088CC\"\n+    DEFAULT_LIST_FILTER = \"all\"\n+    DEFAULT_TOP_PERIOD = \"all\"\n+    DEFAULT_MINIMUM_REQUIRED_TAGS = 0\n+    DEFAULT_STYLE_TYPE = \"square\"\n+    DEFAULT_SUBCATEGORY_LIST_STYLE = \"rows_with_featured_topics\"\n+    DEFAULT_TEXT_COLOR = \"FFFFFF\"\n+    MAX_NAME_LENGTH = 50\n+\n+    depends_on :users, :uploads\n+    store_mapped_ids true\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM categories\"\n+    requires_set :existing_ids, \"SELECT id FROM categories\"\n+    requires_set :existing_category_names, <<~SQL\n+      SELECT COALESCE(parent_category_id::text, '') || '-' || LOWER(name) FROM categories\n+    SQL\n+    requires_set :existing_slugs, <<~SQL\n+      SELECT\n+        COALESCE(parent_category_id::text, '') || ':' || LOWER(slug)\n+      FROM categories\n+      WHERE slug <> ''\n+    SQL\n+\n+    column_names %i[\n+                   id\n+                   all_topics_wiki\n+                   allow_badges\n+                   allow_global_tags\n+                   allow_unlimited_owner_edits_on_first_post\n+                   auto_close_based_on_last_post\n+                   auto_close_hours\n+                   color\n+                   created_at\n+                   updated_at\n+                   default_list_filter\n+                   default_slow_mode_seconds\n+                   default_top_period\n+                   default_view\n+                   description\n+                   email_in\n+                   email_in_allow_strangers\n+                   emoji\n+                   icon\n+                   mailinglist_mirror\n+                   minimum_required_tags\n+                   name\n+                   name_lower\n+                   navigate_to_first_post_after_read\n+                   num_featured_topics\n+                   parent_category_id\n+                   position\n+                   read_only_banner\n+                   read_restricted\n+                   show_subcategory_list\n+                   slug\n+                   sort_ascending\n+                   sort_order\n+                   style_type\n+                   subcategory_list_style\n+                   text_color\n+                   topic_featured_link_allowed\n+                   topic_template\n+                   uploaded_background_dark_id\n+                   uploaded_background_id\n+                   uploaded_logo_dark_id\n+                   uploaded_logo_id\n+                   user_id\n+                 ]\n+\n+    total_rows_query <<~SQL, MappingType::CATEGORIES\n+      SELECT COUNT(*)\n+      FROM categories c\n+          LEFT JOIN mapped.ids mapped_category\n+            ON c.original_id = mapped_category.original_id AND mapped_category.type = ?\n+      WHERE mapped_category.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::CATEGORIES, MappingType::USERS, MappingType::UPLOADS\n+      WITH\n+          RECURSIVE\n+          tree AS (\n+                    SELECT c.*, 0 AS level\n+                      FROM categories c\n+                    WHERE c.parent_category_id IS NULL\n+                    UNION ALL\n+                    SELECT c.*, tree.level + 1 AS level\n+                      FROM categories c,\n+                          tree\n+                    WHERE c.parent_category_id = tree.original_id\n+                  )\n+      SELECT t.*,\n+            COALESCE(t.position,\n+                      ROW_NUMBER() OVER (\n+                        PARTITION BY parent_category_id\n+                        ORDER BY parent_category_id NULLS FIRST, name\n+                        )\n+                    ) AS position,\n+            mapped_user.discourse_id      AS mapped_user_id,\n+            mapped_bg.discourse_id        AS mapped_uploaded_background_id,\n+            mapped_bg_dark.discourse_id   AS mapped_uploaded_background_dark_id,\n+            mapped_logo.discourse_id      AS mapped_uploaded_logo_id,\n+            mapped_logo_dark.discourse_id AS mapped_uploaded_logo_dark_id\n+      FROM tree t\n+           LEFT JOIN mapped.ids mapped_category",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2165232106",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33067,
        "pr_file": "migrations/lib/importer/steps/categories.rb",
        "discussion_id": "2165232106",
        "commented_code": "@@ -0,0 +1,251 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Categories < ::Migrations::Importer::CopyStep\n+    DEFAULT_COLOR = \"0088CC\"\n+    DEFAULT_LIST_FILTER = \"all\"\n+    DEFAULT_TOP_PERIOD = \"all\"\n+    DEFAULT_MINIMUM_REQUIRED_TAGS = 0\n+    DEFAULT_STYLE_TYPE = \"square\"\n+    DEFAULT_SUBCATEGORY_LIST_STYLE = \"rows_with_featured_topics\"\n+    DEFAULT_TEXT_COLOR = \"FFFFFF\"\n+    MAX_NAME_LENGTH = 50\n+\n+    depends_on :users, :uploads\n+    store_mapped_ids true\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM categories\"\n+    requires_set :existing_ids, \"SELECT id FROM categories\"\n+    requires_set :existing_category_names, <<~SQL\n+      SELECT COALESCE(parent_category_id::text, '') || '-' || LOWER(name) FROM categories\n+    SQL\n+    requires_set :existing_slugs, <<~SQL\n+      SELECT\n+        COALESCE(parent_category_id::text, '') || ':' || LOWER(slug)\n+      FROM categories\n+      WHERE slug <> ''\n+    SQL\n+\n+    column_names %i[\n+                   id\n+                   all_topics_wiki\n+                   allow_badges\n+                   allow_global_tags\n+                   allow_unlimited_owner_edits_on_first_post\n+                   auto_close_based_on_last_post\n+                   auto_close_hours\n+                   color\n+                   created_at\n+                   updated_at\n+                   default_list_filter\n+                   default_slow_mode_seconds\n+                   default_top_period\n+                   default_view\n+                   description\n+                   email_in\n+                   email_in_allow_strangers\n+                   emoji\n+                   icon\n+                   mailinglist_mirror\n+                   minimum_required_tags\n+                   name\n+                   name_lower\n+                   navigate_to_first_post_after_read\n+                   num_featured_topics\n+                   parent_category_id\n+                   position\n+                   read_only_banner\n+                   read_restricted\n+                   show_subcategory_list\n+                   slug\n+                   sort_ascending\n+                   sort_order\n+                   style_type\n+                   subcategory_list_style\n+                   text_color\n+                   topic_featured_link_allowed\n+                   topic_template\n+                   uploaded_background_dark_id\n+                   uploaded_background_id\n+                   uploaded_logo_dark_id\n+                   uploaded_logo_id\n+                   user_id\n+                 ]\n+\n+    total_rows_query <<~SQL, MappingType::CATEGORIES\n+      SELECT COUNT(*)\n+      FROM categories c\n+          LEFT JOIN mapped.ids mapped_category\n+            ON c.original_id = mapped_category.original_id AND mapped_category.type = ?\n+      WHERE mapped_category.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::CATEGORIES, MappingType::USERS, MappingType::UPLOADS\n+      WITH\n+          RECURSIVE\n+          tree AS (\n+                    SELECT c.*, 0 AS level\n+                      FROM categories c\n+                    WHERE c.parent_category_id IS NULL\n+                    UNION ALL\n+                    SELECT c.*, tree.level + 1 AS level\n+                      FROM categories c,\n+                          tree\n+                    WHERE c.parent_category_id = tree.original_id\n+                  )\n+      SELECT t.*,\n+            COALESCE(t.position,\n+                      ROW_NUMBER() OVER (\n+                        PARTITION BY parent_category_id\n+                        ORDER BY parent_category_id NULLS FIRST, name\n+                        )\n+                    ) AS position,\n+            mapped_user.discourse_id      AS mapped_user_id,\n+            mapped_bg.discourse_id        AS mapped_uploaded_background_id,\n+            mapped_bg_dark.discourse_id   AS mapped_uploaded_background_dark_id,\n+            mapped_logo.discourse_id      AS mapped_uploaded_logo_id,\n+            mapped_logo_dark.discourse_id AS mapped_uploaded_logo_dark_id\n+      FROM tree t\n+           LEFT JOIN mapped.ids mapped_category",
        "comment_created_at": "2025-06-25T01:08:09+00:00",
        "comment_author": "gschlager",
        "comment_body": "I like the usage of longer aliases here. Makes it much more readable. I'll copy that into other steps. :+1: ",
        "pr_file_module": null
      },
      {
        "comment_id": "2166472417",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33067,
        "pr_file": "migrations/lib/importer/steps/categories.rb",
        "discussion_id": "2165232106",
        "commented_code": "@@ -0,0 +1,251 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Categories < ::Migrations::Importer::CopyStep\n+    DEFAULT_COLOR = \"0088CC\"\n+    DEFAULT_LIST_FILTER = \"all\"\n+    DEFAULT_TOP_PERIOD = \"all\"\n+    DEFAULT_MINIMUM_REQUIRED_TAGS = 0\n+    DEFAULT_STYLE_TYPE = \"square\"\n+    DEFAULT_SUBCATEGORY_LIST_STYLE = \"rows_with_featured_topics\"\n+    DEFAULT_TEXT_COLOR = \"FFFFFF\"\n+    MAX_NAME_LENGTH = 50\n+\n+    depends_on :users, :uploads\n+    store_mapped_ids true\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM categories\"\n+    requires_set :existing_ids, \"SELECT id FROM categories\"\n+    requires_set :existing_category_names, <<~SQL\n+      SELECT COALESCE(parent_category_id::text, '') || '-' || LOWER(name) FROM categories\n+    SQL\n+    requires_set :existing_slugs, <<~SQL\n+      SELECT\n+        COALESCE(parent_category_id::text, '') || ':' || LOWER(slug)\n+      FROM categories\n+      WHERE slug <> ''\n+    SQL\n+\n+    column_names %i[\n+                   id\n+                   all_topics_wiki\n+                   allow_badges\n+                   allow_global_tags\n+                   allow_unlimited_owner_edits_on_first_post\n+                   auto_close_based_on_last_post\n+                   auto_close_hours\n+                   color\n+                   created_at\n+                   updated_at\n+                   default_list_filter\n+                   default_slow_mode_seconds\n+                   default_top_period\n+                   default_view\n+                   description\n+                   email_in\n+                   email_in_allow_strangers\n+                   emoji\n+                   icon\n+                   mailinglist_mirror\n+                   minimum_required_tags\n+                   name\n+                   name_lower\n+                   navigate_to_first_post_after_read\n+                   num_featured_topics\n+                   parent_category_id\n+                   position\n+                   read_only_banner\n+                   read_restricted\n+                   show_subcategory_list\n+                   slug\n+                   sort_ascending\n+                   sort_order\n+                   style_type\n+                   subcategory_list_style\n+                   text_color\n+                   topic_featured_link_allowed\n+                   topic_template\n+                   uploaded_background_dark_id\n+                   uploaded_background_id\n+                   uploaded_logo_dark_id\n+                   uploaded_logo_id\n+                   user_id\n+                 ]\n+\n+    total_rows_query <<~SQL, MappingType::CATEGORIES\n+      SELECT COUNT(*)\n+      FROM categories c\n+          LEFT JOIN mapped.ids mapped_category\n+            ON c.original_id = mapped_category.original_id AND mapped_category.type = ?\n+      WHERE mapped_category.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::CATEGORIES, MappingType::USERS, MappingType::UPLOADS\n+      WITH\n+          RECURSIVE\n+          tree AS (\n+                    SELECT c.*, 0 AS level\n+                      FROM categories c\n+                    WHERE c.parent_category_id IS NULL\n+                    UNION ALL\n+                    SELECT c.*, tree.level + 1 AS level\n+                      FROM categories c,\n+                          tree\n+                    WHERE c.parent_category_id = tree.original_id\n+                  )\n+      SELECT t.*,\n+            COALESCE(t.position,\n+                      ROW_NUMBER() OVER (\n+                        PARTITION BY parent_category_id\n+                        ORDER BY parent_category_id NULLS FIRST, name\n+                        )\n+                    ) AS position,\n+            mapped_user.discourse_id      AS mapped_user_id,\n+            mapped_bg.discourse_id        AS mapped_uploaded_background_id,\n+            mapped_bg_dark.discourse_id   AS mapped_uploaded_background_dark_id,\n+            mapped_logo.discourse_id      AS mapped_uploaded_logo_id,\n+            mapped_logo_dark.discourse_id AS mapped_uploaded_logo_dark_id\n+      FROM tree t\n+           LEFT JOIN mapped.ids mapped_category",
        "comment_created_at": "2025-06-25T11:21:05+00:00",
        "comment_author": "s3lase",
        "comment_body": "Yes, I started with shorter ones, but that quickly got out of hand given the number of joins. We can refine these and agree on a consistent pattern going forward.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167701687",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33067,
        "pr_file": "migrations/lib/importer/steps/categories.rb",
        "discussion_id": "2165232106",
        "commented_code": "@@ -0,0 +1,251 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Categories < ::Migrations::Importer::CopyStep\n+    DEFAULT_COLOR = \"0088CC\"\n+    DEFAULT_LIST_FILTER = \"all\"\n+    DEFAULT_TOP_PERIOD = \"all\"\n+    DEFAULT_MINIMUM_REQUIRED_TAGS = 0\n+    DEFAULT_STYLE_TYPE = \"square\"\n+    DEFAULT_SUBCATEGORY_LIST_STYLE = \"rows_with_featured_topics\"\n+    DEFAULT_TEXT_COLOR = \"FFFFFF\"\n+    MAX_NAME_LENGTH = 50\n+\n+    depends_on :users, :uploads\n+    store_mapped_ids true\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM categories\"\n+    requires_set :existing_ids, \"SELECT id FROM categories\"\n+    requires_set :existing_category_names, <<~SQL\n+      SELECT COALESCE(parent_category_id::text, '') || '-' || LOWER(name) FROM categories\n+    SQL\n+    requires_set :existing_slugs, <<~SQL\n+      SELECT\n+        COALESCE(parent_category_id::text, '') || ':' || LOWER(slug)\n+      FROM categories\n+      WHERE slug <> ''\n+    SQL\n+\n+    column_names %i[\n+                   id\n+                   all_topics_wiki\n+                   allow_badges\n+                   allow_global_tags\n+                   allow_unlimited_owner_edits_on_first_post\n+                   auto_close_based_on_last_post\n+                   auto_close_hours\n+                   color\n+                   created_at\n+                   updated_at\n+                   default_list_filter\n+                   default_slow_mode_seconds\n+                   default_top_period\n+                   default_view\n+                   description\n+                   email_in\n+                   email_in_allow_strangers\n+                   emoji\n+                   icon\n+                   mailinglist_mirror\n+                   minimum_required_tags\n+                   name\n+                   name_lower\n+                   navigate_to_first_post_after_read\n+                   num_featured_topics\n+                   parent_category_id\n+                   position\n+                   read_only_banner\n+                   read_restricted\n+                   show_subcategory_list\n+                   slug\n+                   sort_ascending\n+                   sort_order\n+                   style_type\n+                   subcategory_list_style\n+                   text_color\n+                   topic_featured_link_allowed\n+                   topic_template\n+                   uploaded_background_dark_id\n+                   uploaded_background_id\n+                   uploaded_logo_dark_id\n+                   uploaded_logo_id\n+                   user_id\n+                 ]\n+\n+    total_rows_query <<~SQL, MappingType::CATEGORIES\n+      SELECT COUNT(*)\n+      FROM categories c\n+          LEFT JOIN mapped.ids mapped_category\n+            ON c.original_id = mapped_category.original_id AND mapped_category.type = ?\n+      WHERE mapped_category.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::CATEGORIES, MappingType::USERS, MappingType::UPLOADS\n+      WITH\n+          RECURSIVE\n+          tree AS (\n+                    SELECT c.*, 0 AS level\n+                      FROM categories c\n+                    WHERE c.parent_category_id IS NULL\n+                    UNION ALL\n+                    SELECT c.*, tree.level + 1 AS level\n+                      FROM categories c,\n+                          tree\n+                    WHERE c.parent_category_id = tree.original_id\n+                  )\n+      SELECT t.*,\n+            COALESCE(t.position,\n+                      ROW_NUMBER() OVER (\n+                        PARTITION BY parent_category_id\n+                        ORDER BY parent_category_id NULLS FIRST, name\n+                        )\n+                    ) AS position,\n+            mapped_user.discourse_id      AS mapped_user_id,\n+            mapped_bg.discourse_id        AS mapped_uploaded_background_id,\n+            mapped_bg_dark.discourse_id   AS mapped_uploaded_background_dark_id,\n+            mapped_logo.discourse_id      AS mapped_uploaded_logo_id,\n+            mapped_logo_dark.discourse_id AS mapped_uploaded_logo_dark_id\n+      FROM tree t\n+           LEFT JOIN mapped.ids mapped_category",
        "comment_created_at": "2025-06-25T21:52:37+00:00",
        "comment_author": "gschlager",
        "comment_body": "I'd go with `mapped_categories` to fit in with table names being plural, but that's the only change I'd make. I like the pattern of having clear, readable aliases. Heck, I even experimented with not giving aliases to the IntermediateDB tables. So, `users` instead of `u`. I like it so far.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167909504",
    "pr_number": 33353,
    "pr_file": "spec/lib/search_spec.rb",
    "created_at": "2025-06-26T01:25:50+00:00",
    "commented_code": "expect(results.posts).to contain_exactly(regular_post)\n     end\n   end\n+\n+  it \"can order by read\" do",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2167909504",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33353,
        "pr_file": "spec/lib/search_spec.rb",
        "discussion_id": "2167909504",
        "commented_code": "@@ -3135,4 +3135,30 @@ def indexed_post(*args)\n       expect(results.posts).to contain_exactly(regular_post)\n     end\n   end\n+\n+  it \"can order by read\" do",
        "comment_created_at": "2025-06-26T01:25:50+00:00",
        "comment_author": "tgxworld",
        "comment_body": "```suggestion\r\n  it \"orders posts by the timestamp of the user's last visit to each post's topic\" do\r\n```\r\n\r\nSuggestion to make it clearer since just saying `read` leaves room for interpretation. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2143734916",
    "pr_number": 33019,
    "pr_file": "migrations/lib/importer/steps/badges.rb",
    "created_at": "2025-06-12T22:03:59+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Badges < ::Migrations::Importer::CopyStep\n+    DEFAULT_ICON = \"certificate\"\n+    DUPLICATE_SUFFIX = \"_1\"\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM badges\"\n+    requires_set :existing_ids, \"SELECT id FROM badges\"\n+    requires_set :existing_names, \"SELECT name FROM badges\"\n+    requires_set :existing_badge_grouping_ids, \"SELECT id FROM badge_groupings\"\n+    requires_set :existing_badge_type_ids, \"SELECT id FROM badge_types\"\n+\n+    column_names %i[\n+                   id\n+                   name\n+                   description\n+                   badge_type_id\n+                   created_at\n+                   updated_at\n+                   allow_title\n+                   multiple_grant\n+                   icon\n+                   listable\n+                   target_posts\n+                   query\n+                   enabled\n+                   auto_revoke\n+                   badge_grouping_id\n+                   trigger\n+                   show_posts\n+                   long_description\n+                   image_upload_id\n+                   show_in_post_header\n+                 ]\n+\n+    store_mapped_ids true\n+\n+    total_rows_query <<~SQL, MappingType::BADGES\n+      SELECT COUNT(*)\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::BADGES\n+      SELECT b.*\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+      GROUP BY b.original_id\n+      ORDER BY b.ROWID\n+    SQL\n+\n+    private\n+\n+    def transform_row(row)\n+      if row[:existing_id].present?\n+        row[:id] = if row[:existing_id].match?(/\\A\\d+\\z/)\n+          id = row[:existing_id].to_i\n+          id if @existing_ids.include?(id)\n+        else\n+          @ids_by_name[row[:existing_id]]\n+        end\n+\n+        return nil if row[:id].present?\n+      end\n+\n+      badge_name = row[:name].dup\n+      row[:name] = @existing_names.add?(badge_name) ? badge_name : deduplicate_name(badge_name)\n+\n+      row[:allow_title] ||= false\n+      row[:multiple_grant] ||= false\n+      row[:show_posts] ||= false\n+      row[:show_in_post_header] ||= false\n+      row[:target_posts] ||= false\n+      row[:auto_revoke] = true if row[:auto_revoke].nil?\n+      row[:enabled] = true if row[:enabled].nil?\n+      row[:listable] = true if row[:listable].nil?\n+\n+      row[:icon] = DEFAULT_ICON if row[:icon].blank?\n+      row[:trigger] = Badge::Trigger::None unless valid_trigger?(row[:trigger])\n+\n+      # TODO: Update these if/when we add import steps for badge groupings and badge types\n+      #       Current implementation expects the converter to set final values\n+      row[:badge_grouping_id] = ensure_related_id(\n+        row[:badge_grouping_id],\n+        @existing_badge_grouping_ids,\n+        BadgeGrouping::Other,\n+      )\n+      row[:badge_type_id] = ensure_related_id(\n+        row[:badge_type_id],\n+        @existing_badge_type_ids,\n+        BadgeType::Silver,\n+      )\n+\n+      # TODO: Probably validate the imported query, maybe in some other step\n+      row[:query] = nil if !SiteSetting.enable_badge_sql? && row[:query].present?\n+\n+      # TODO: Resolve and include image_upload_id once have an uploads step\n+\n+      super\n+    end\n+\n+    def deduplicate_name(name)\n+      new_name = name + DUPLICATE_SUFFIX\n+      new_name.next! until @existing_names.add?(new_name)\n+\n+      new_name\n+    end\n+\n+    def ensure_related_id(value, allowed_set, default_value)\n+      allowed_set.include?(value) ? value : default_value\n+    end",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2143734916",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33019,
        "pr_file": "migrations/lib/importer/steps/badges.rb",
        "discussion_id": "2143734916",
        "commented_code": "@@ -0,0 +1,123 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Badges < ::Migrations::Importer::CopyStep\n+    DEFAULT_ICON = \"certificate\"\n+    DUPLICATE_SUFFIX = \"_1\"\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM badges\"\n+    requires_set :existing_ids, \"SELECT id FROM badges\"\n+    requires_set :existing_names, \"SELECT name FROM badges\"\n+    requires_set :existing_badge_grouping_ids, \"SELECT id FROM badge_groupings\"\n+    requires_set :existing_badge_type_ids, \"SELECT id FROM badge_types\"\n+\n+    column_names %i[\n+                   id\n+                   name\n+                   description\n+                   badge_type_id\n+                   created_at\n+                   updated_at\n+                   allow_title\n+                   multiple_grant\n+                   icon\n+                   listable\n+                   target_posts\n+                   query\n+                   enabled\n+                   auto_revoke\n+                   badge_grouping_id\n+                   trigger\n+                   show_posts\n+                   long_description\n+                   image_upload_id\n+                   show_in_post_header\n+                 ]\n+\n+    store_mapped_ids true\n+\n+    total_rows_query <<~SQL, MappingType::BADGES\n+      SELECT COUNT(*)\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::BADGES\n+      SELECT b.*\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+      GROUP BY b.original_id\n+      ORDER BY b.ROWID\n+    SQL\n+\n+    private\n+\n+    def transform_row(row)\n+      if row[:existing_id].present?\n+        row[:id] = if row[:existing_id].match?(/\\A\\d+\\z/)\n+          id = row[:existing_id].to_i\n+          id if @existing_ids.include?(id)\n+        else\n+          @ids_by_name[row[:existing_id]]\n+        end\n+\n+        return nil if row[:id].present?\n+      end\n+\n+      badge_name = row[:name].dup\n+      row[:name] = @existing_names.add?(badge_name) ? badge_name : deduplicate_name(badge_name)\n+\n+      row[:allow_title] ||= false\n+      row[:multiple_grant] ||= false\n+      row[:show_posts] ||= false\n+      row[:show_in_post_header] ||= false\n+      row[:target_posts] ||= false\n+      row[:auto_revoke] = true if row[:auto_revoke].nil?\n+      row[:enabled] = true if row[:enabled].nil?\n+      row[:listable] = true if row[:listable].nil?\n+\n+      row[:icon] = DEFAULT_ICON if row[:icon].blank?\n+      row[:trigger] = Badge::Trigger::None unless valid_trigger?(row[:trigger])\n+\n+      # TODO: Update these if/when we add import steps for badge groupings and badge types\n+      #       Current implementation expects the converter to set final values\n+      row[:badge_grouping_id] = ensure_related_id(\n+        row[:badge_grouping_id],\n+        @existing_badge_grouping_ids,\n+        BadgeGrouping::Other,\n+      )\n+      row[:badge_type_id] = ensure_related_id(\n+        row[:badge_type_id],\n+        @existing_badge_type_ids,\n+        BadgeType::Silver,\n+      )\n+\n+      # TODO: Probably validate the imported query, maybe in some other step\n+      row[:query] = nil if !SiteSetting.enable_badge_sql? && row[:query].present?\n+\n+      # TODO: Resolve and include image_upload_id once have an uploads step\n+\n+      super\n+    end\n+\n+    def deduplicate_name(name)\n+      new_name = name + DUPLICATE_SUFFIX\n+      new_name.next! until @existing_names.add?(new_name)\n+\n+      new_name\n+    end\n+\n+    def ensure_related_id(value, allowed_set, default_value)\n+      allowed_set.include?(value) ? value : default_value\n+    end",
        "comment_created_at": "2025-06-12T22:03:59+00:00",
        "comment_author": "gschlager",
        "comment_body": "This looks like a method we might want to reuse in other steps as well. We should consider moving it to `Step` or a helper.\r\n\r\nAlso, I wonder if we should rename that method and use keyword arguments to improve clarity, since the method takes 3 similar arguments.\r\n\r\n```suggestion\r\n    def ensure_valid_value(value:, allowed_set:, default_value:)\r\n      allowed_set.include?(value) ? value : default_value\r\n    end\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2161577080",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33019,
        "pr_file": "migrations/lib/importer/steps/badges.rb",
        "discussion_id": "2143734916",
        "commented_code": "@@ -0,0 +1,123 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps\n+  class Badges < ::Migrations::Importer::CopyStep\n+    DEFAULT_ICON = \"certificate\"\n+    DUPLICATE_SUFFIX = \"_1\"\n+\n+    requires_mapping :ids_by_name, \"SELECT name, id FROM badges\"\n+    requires_set :existing_ids, \"SELECT id FROM badges\"\n+    requires_set :existing_names, \"SELECT name FROM badges\"\n+    requires_set :existing_badge_grouping_ids, \"SELECT id FROM badge_groupings\"\n+    requires_set :existing_badge_type_ids, \"SELECT id FROM badge_types\"\n+\n+    column_names %i[\n+                   id\n+                   name\n+                   description\n+                   badge_type_id\n+                   created_at\n+                   updated_at\n+                   allow_title\n+                   multiple_grant\n+                   icon\n+                   listable\n+                   target_posts\n+                   query\n+                   enabled\n+                   auto_revoke\n+                   badge_grouping_id\n+                   trigger\n+                   show_posts\n+                   long_description\n+                   image_upload_id\n+                   show_in_post_header\n+                 ]\n+\n+    store_mapped_ids true\n+\n+    total_rows_query <<~SQL, MappingType::BADGES\n+      SELECT COUNT(*)\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+    SQL\n+\n+    rows_query <<~SQL, MappingType::BADGES\n+      SELECT b.*\n+      FROM badges b\n+           LEFT JOIN mapped.ids mi ON b.original_id = mi.original_id AND mi.type = ?\n+      WHERE mi.original_id IS NULL\n+      GROUP BY b.original_id\n+      ORDER BY b.ROWID\n+    SQL\n+\n+    private\n+\n+    def transform_row(row)\n+      if row[:existing_id].present?\n+        row[:id] = if row[:existing_id].match?(/\\A\\d+\\z/)\n+          id = row[:existing_id].to_i\n+          id if @existing_ids.include?(id)\n+        else\n+          @ids_by_name[row[:existing_id]]\n+        end\n+\n+        return nil if row[:id].present?\n+      end\n+\n+      badge_name = row[:name].dup\n+      row[:name] = @existing_names.add?(badge_name) ? badge_name : deduplicate_name(badge_name)\n+\n+      row[:allow_title] ||= false\n+      row[:multiple_grant] ||= false\n+      row[:show_posts] ||= false\n+      row[:show_in_post_header] ||= false\n+      row[:target_posts] ||= false\n+      row[:auto_revoke] = true if row[:auto_revoke].nil?\n+      row[:enabled] = true if row[:enabled].nil?\n+      row[:listable] = true if row[:listable].nil?\n+\n+      row[:icon] = DEFAULT_ICON if row[:icon].blank?\n+      row[:trigger] = Badge::Trigger::None unless valid_trigger?(row[:trigger])\n+\n+      # TODO: Update these if/when we add import steps for badge groupings and badge types\n+      #       Current implementation expects the converter to set final values\n+      row[:badge_grouping_id] = ensure_related_id(\n+        row[:badge_grouping_id],\n+        @existing_badge_grouping_ids,\n+        BadgeGrouping::Other,\n+      )\n+      row[:badge_type_id] = ensure_related_id(\n+        row[:badge_type_id],\n+        @existing_badge_type_ids,\n+        BadgeType::Silver,\n+      )\n+\n+      # TODO: Probably validate the imported query, maybe in some other step\n+      row[:query] = nil if !SiteSetting.enable_badge_sql? && row[:query].present?\n+\n+      # TODO: Resolve and include image_upload_id once have an uploads step\n+\n+      super\n+    end\n+\n+    def deduplicate_name(name)\n+      new_name = name + DUPLICATE_SUFFIX\n+      new_name.next! until @existing_names.add?(new_name)\n+\n+      new_name\n+    end\n+\n+    def ensure_related_id(value, allowed_set, default_value)\n+      allowed_set.include?(value) ? value : default_value\n+    end",
        "comment_created_at": "2025-06-23T13:01:54+00:00",
        "comment_author": "s3lase",
        "comment_body": "I've moved this `CopyStep`, closer to where row fetching and transformation is being done",
        "pr_file_module": null
      }
    ]
  }
]