[
  {
    "discussion_id": "2221720237",
    "pr_number": 33734,
    "pr_file": "app/assets/javascripts/discourse-markdown-it/src/features/mentions.js",
    "created_at": "2025-07-22T08:37:15+00:00",
    "commented_code": "helper.registerPlugin((md) => {\n     const rule = {\n-      matcher: mentionRegex(md.options.discourse.features.unicodeUsernames),\n+      matcher: mentionRegex(\n+        md.options.discourse.limitedSiteSettings.unicodeUsernames",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2221720237",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33734,
        "pr_file": "app/assets/javascripts/discourse-markdown-it/src/features/mentions.js",
        "discussion_id": "2221720237",
        "commented_code": "@@ -27,7 +27,9 @@ export function setup(helper) {\n \n   helper.registerPlugin((md) => {\n     const rule = {\n-      matcher: mentionRegex(md.options.discourse.features.unicodeUsernames),\n+      matcher: mentionRegex(\n+        md.options.discourse.limitedSiteSettings.unicodeUsernames",
        "comment_created_at": "2025-07-22T08:37:15+00:00",
        "comment_author": "dbattersby",
        "comment_body": "Not exactly sure why but on opening composer, the value was always false even when the site setting was true. Using the limited site settings is a workaround to get the correct value so we can properly load existing drafts and support unicode.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2238463779",
    "pr_number": 33734,
    "pr_file": "app/assets/javascripts/discourse-markdown-it/src/features/mentions.js",
    "created_at": "2025-07-29T04:33:48+00:00",
    "commented_code": "helper.registerPlugin((md) => {\n     const rule = {\n-      matcher: mentionRegex(md.options.discourse.features.unicodeUsernames),\n+      matcher: mentionRegex(md.options.discourse.unicodeUsernames),",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2238463779",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33734,
        "pr_file": "app/assets/javascripts/discourse-markdown-it/src/features/mentions.js",
        "discussion_id": "2238463779",
        "commented_code": "@@ -27,7 +27,7 @@ export function setup(helper) {\n \n   helper.registerPlugin((md) => {\n     const rule = {\n-      matcher: mentionRegex(md.options.discourse.features.unicodeUsernames),\n+      matcher: mentionRegex(md.options.discourse.unicodeUsernames),",
        "comment_created_at": "2025-07-29T04:33:48+00:00",
        "comment_author": "dbattersby",
        "comment_body": "When using rich text mode this approach using `registerOptions` (above) to pass the site setting was unreliable, sometimes it would show the correct site setting value and other times it wouldn't. Assigning the value from markdown-it options makes it work consistently.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2157801435",
    "pr_number": 33272,
    "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
    "created_at": "2025-06-20T00:02:35+00:00",
    "commented_code": "}\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2157801435",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157801435",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },",
        "comment_created_at": "2025-06-20T00:02:35+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "You should look up this order configuration with the `site` service:\r\n\r\nhttps://github.com/discourse/discourse/blob/1c97488d207c68f70c67a1adaf16af22b639114b/app/assets/javascripts/discourse/app/components/composer-editor.gjs#L507-L507",
        "pr_file_module": null
      },
      {
        "comment_id": "2158022800",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157801435",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },",
        "comment_created_at": "2025-06-20T04:35:53+00:00",
        "comment_author": "dbattersby",
        "comment_body": "I hard coded these temporarily but forgot to go back and replace, will update.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2157801924",
    "pr_number": 33272,
    "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
    "created_at": "2025-06-20T00:03:40+00:00",
    "commented_code": "}\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2157801924",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157801924",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {",
        "comment_created_at": "2025-06-20T00:03:40+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "Instead of hardcoding this chat stuff in the client, you should update `ChannelHashtagDataSource` to set the `style_type` to `icon`\r\n\r\nhttps://github.com/discourse/discourse/blob/1c97488d207c68f70c67a1adaf16af22b639114b/plugins/chat/lib/chat/channel_hashtag_data_source.rb#L26-L26",
        "pr_file_module": null
      },
      {
        "comment_id": "2158024115",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157801924",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {",
        "comment_created_at": "2025-06-20T04:37:59+00:00",
        "comment_author": "dbattersby",
        "comment_body": "Yeah this was a temporary workaround, I should have left a comment there. We never needed the style type in chat channels before but I am planning to handle this in a separate DEV pr.",
        "pr_file_module": null
      },
      {
        "comment_id": "2158065920",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157801924",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {",
        "comment_created_at": "2025-06-20T05:13:19+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "IMO it's no big deal to just do it in the same PR :) It won't affect any other hashtag stuff by adding it, and the chat data source reflects reality better too. You could also set `style_type` for the tag hastag data source in the same way",
        "pr_file_module": null
      },
      {
        "comment_id": "2158207716",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33272,
        "pr_file": "app/assets/javascripts/discourse/app/static/prosemirror/extensions/hashtag.js",
        "discussion_id": "2157801924",
        "commented_code": "@@ -82,6 +100,115 @@ const extension = {\n       }\n     },\n   },\n+  plugins({ pmState: { Plugin, PluginKey } }) {\n+    const key = new PluginKey(\"hashtag\");\n+\n+    return new Plugin({\n+      key,\n+      view() {\n+        return {\n+          update(view) {\n+            this.processHashtags(view);\n+          },\n+          processHashtags(view) {\n+            const hashtagNames = [];\n+            const hashtagNodes = [];\n+\n+            view.state.doc.descendants((node, pos) => {\n+              if (\n+                node.type.name !== \"hashtag\" ||\n+                node.attrs.processed ||\n+                !node.attrs.valid\n+              ) {\n+                return;\n+              }\n+\n+              const name = node.attrs.name;\n+              hashtagNodes.push({ name, node, pos });\n+              hashtagNames.push(name);\n+            });\n+\n+            if (!hashtagNodes.length) {\n+              return;\n+            }\n+\n+            // process in reverse to avoid issues with position shifts\n+            hashtagNodes.sort((a, b) => b.pos - a.pos);\n+\n+            const updateHashtags = async () => {\n+              await fetchHashtags(hashtagNames);\n+\n+              for (const hashtagNode of hashtagNodes) {\n+                const { name, node, pos } = hashtagNode;\n+                const validHashtag = VALID_HASHTAGS.get(name.toLowerCase());\n+\n+                // check if node still exists at this position before updating\n+                if (view.state.doc.nodeAt(pos)?.type !== node.type) {\n+                  continue;\n+                }\n+\n+                view.dispatch(\n+                  view.state.tr.setNodeMarkup(pos, null, {\n+                    ...node.attrs,\n+                    processed: true,\n+                    valid: !!validHashtag,\n+                  })\n+                );\n+\n+                const domNode = view.nodeDOM(pos);\n+                if (!validHashtag || !domNode) {\n+                  continue;\n+                }\n+\n+                // decorate valid hashtags based on their type\n+                const tagText = validHashtag?.text || name;\n+                const hashtagTypeClass =\n+                  getHashtagTypeClasses()[validHashtag?.type];\n+\n+                let hashtagIconHTML = hashtagTypeClass\n+                  .generateIconHTML(validHashtag)\n+                  .trim();\n+\n+                domNode.innerHTML = `${hashtagIconHTML}${tagText}`;\n+              }\n+            };\n+\n+            updateHashtags();\n+          },\n+        };\n+      },\n+    });\n+  },\n };\n \n+async function fetchHashtags(hashtags) {\n+  const slugs = hashtags.filter(\n+    (tag) => !VALID_HASHTAGS.has(tag) && !INVALID_HASHTAGS.has(tag)\n+  );\n+\n+  if (!slugs.length) {\n+    return;\n+  }\n+\n+  const response = await ajax(\"/hashtags\", {\n+    data: { slugs, order: [\"category\", \"channel\", \"tag\"] },\n+  });\n+\n+  const validTags = Object.values(response || {})\n+    .flat()\n+    .filter(Boolean);\n+\n+  validTags.forEach((tag) => {\n+    if (tag.type === \"channel\") {",
        "comment_created_at": "2025-06-20T07:04:30+00:00",
        "comment_author": "dbattersby",
        "comment_body": "All good, I've done merged it from a separate PR and pulled in the changes from main in this pr. Yeah probably adding the same for tags is worth doing too.",
        "pr_file_module": null
      }
    ]
  }
]