[
  {
    "discussion_id": "2284083172",
    "pr_number": 33737,
    "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
    "created_at": "2025-08-19T05:17:17+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2284083172",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33737,
        "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
        "discussion_id": "2284083172",
        "commented_code": "@@ -0,0 +1,377 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;",
        "comment_created_at": "2025-08-19T05:17:17+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n      return d.hours() || d.minutes() || d.seconds();\r\n```\r\n\r\nIf you don't want to do this fine, but I think you could do this since if any of them are not 0 this will be true...would be nice if moment had a `hasTime()` function or something",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284084776",
    "pr_number": 33737,
    "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
    "created_at": "2025-08-19T05:18:34+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {\n+    const event = this._buildEvent(detail);\n+    const holidayCalendarTopicId = parseInt(\n+      this.siteSettings.holiday_calendar_topic_id,\n+      10\n+    );\n+    const text = detail.message.split(\"\n\").filter((e) => e);",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2284084776",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33737,
        "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
        "discussion_id": "2284084776",
        "commented_code": "@@ -0,0 +1,377 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {\n+    const event = this._buildEvent(detail);\n+    const holidayCalendarTopicId = parseInt(\n+      this.siteSettings.holiday_calendar_topic_id,\n+      10\n+    );\n+    const text = detail.message.split(\"\\n\").filter((e) => e);",
        "comment_created_at": "2025-08-19T05:18:34+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n    const text = detail.message.split(\"\\n\").filter(Boolean);\r\n```\r\n\r\n?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2289981609",
    "pr_number": 34455,
    "pr_file": "app/assets/javascripts/discourse/app/components/form-template-field/wrapper.gjs",
    "created_at": "2025-08-21T06:28:06+00:00",
    "commented_code": "return this._loadTemplate(templateContent);\n   }\n \n+  // child components expect an onChange function\n+  get onChange() {\n+    if (this.args.onChange) {\n+      return this.args.onChange;\n+    } else {\n+      return () => {};\n+    }",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2289981609",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34455,
        "pr_file": "app/assets/javascripts/discourse/app/components/form-template-field/wrapper.gjs",
        "discussion_id": "2289981609",
        "commented_code": "@@ -88,6 +87,15 @@ export default class FormTemplateFieldWrapper extends Component {\n     return this._loadTemplate(templateContent);\n   }\n \n+  // child components expect an onChange function\n+  get onChange() {\n+    if (this.args.onChange) {\n+      return this.args.onChange;\n+    } else {\n+      return () => {};\n+    }",
        "comment_created_at": "2025-08-21T06:28:06+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n    return this.args.onChange || () => {};\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2278721684",
    "pr_number": 34351,
    "pr_file": "app/assets/javascripts/admin/addon/components/admin-config-areas/color-palettes.gjs",
    "created_at": "2025-08-15T09:58:18+00:00",
    "commented_code": "@service router;\n   @service modal;\n \n-  get baseColorPalettes() {\n-    return this.args.palettes.filter((palette) => palette.is_base);\n+  get allColorPalettes() {\n+    return this.args.palettes.map((palette) => {\n+      if (palette.id === null) {\n+        palette.id = palette.base_scheme_id;\n+      }\n+      return palette;\n+    });",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2278721684",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34351,
        "pr_file": "app/assets/javascripts/admin/addon/components/admin-config-areas/color-palettes.gjs",
        "discussion_id": "2278721684",
        "commented_code": "@@ -13,29 +13,42 @@ export default class AdminConfigAreasColorPalettes extends Component {\n   @service router;\n   @service modal;\n \n-  get baseColorPalettes() {\n-    return this.args.palettes.filter((palette) => palette.is_base);\n+  get allColorPalettes() {\n+    return this.args.palettes.map((palette) => {\n+      if (palette.id === null) {\n+        palette.id = palette.base_scheme_id;\n+      }\n+      return palette;\n+    });",
        "comment_created_at": "2025-08-15T09:58:18+00:00",
        "comment_author": "CvX",
        "comment_body": "```suggestion\r\n    return this.args.palettes.map((palette) => ({\r\n      ...palette,\r\n      id: palette.id ?? palette.base_scheme_id;\r\n    });\r\n```\r\n\r\nthis prevents mutation of state in a getter (unless mutation is desired then it should be done wherever the state/arg comes from)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2268643740",
    "pr_number": 33992,
    "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation-menu.gjs",
    "created_at": "2025-08-12T05:41:53+00:00",
    "commented_code": "</template>;\n \n /**\n- * This component provides an input field and parsing logic for filter\n- * queries. Every time the input changes, we recalculate the list of\n- * filter tips that match the current input value.\n- *\n- * We start from an initial list of tips provided by the server\n- * (see TopicsFilter.option_info) which are reduced to a list of \"high priority/top-level\"\n- * filters if there is no user input value.\n+ * FilterNavigationMenu - A simpler UI component for filter input and suggestions\n  *\n- * Once the user starts typing, we parse the input value to determine\n- * the last word and its prefix (if any). If the last word contains a colon,\n- * we treat it as a filter name and look for matching tips via the FilterSuggestions service.\n- * For example after \"category:\" is typed we show a list of categories the user\n- * has access to.\n+ * This component manages:\n+ * - User input field\n+ * - Keyboard navigation\n+ * - Dropdown menu display\n+ * - Selection handling\n  *\n- * Each filter tip can have prefixes (like \"-\", \"=\", and \"-=\") that modify the filter behavior,\n- * as well as delimiters (like \",\") that allow for multiple values.\n+ * The actual suggestion generation is delegated to FilterSuggestions\n  */\n export default class FilterNavigationMenu extends Component {\n   @service menu;\n   @service site;\n \n-  @resettableTracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked suggestions = [];\n+  @tracked activeFilter = null;\n+  @tracked selectedIndex = -1;\n+\n+  lastSuggestionInput = \"\";\n+  suggestionRequestId = 0;\n \n-  filterSuggessionResults = [];\n-  activeFilter = null;\n   trackedMenuListData = new TrackedObject({\n-    filteredTips: this.filteredTips,\n+    suggestions: [],\n     selectedIndex: null,\n     selectItem: this.selectItem,\n   });\n \n-  @tracked _selectedIndex = -1;\n-\n-  get selectedIndex() {\n-    return this._selectedIndex;\n-  }\n-\n-  set selectedIndex(value) {\n-    this._selectedIndex = value;\n-    this.trackedMenuListData.selectedIndex = value;\n-  }\n-\n-  clearSelection() {\n-    this.selectedIndex = -1;\n-  }\n+  searchTimer = null;\n+  inputElement = null;\n+  dMenuInstance = null;\n \n   get nothingSelected() {\n     return this.selectedIndex === -1;\n   }\n \n-  get filteredTips() {\n-    if (!this.args.tips) {\n-      return [];\n-    }\n-\n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1).toLowerCase();\n-\n-    // If we're already filtering by a type like \"category:\" that has suggestions,\n-    // we want to only show those suggestions.\n-    if (this.activeFilter && this.filterSuggessionResults.length > 0) {\n-      return this.filterSuggessionResults;\n-    }\n-\n-    // We are filtering by a type here like \"category:\", \"tag:\", etc.\n-    // since the last word contains a colon.\n-    const colonIndex = lastWord.indexOf(\":\");\n-    const prefix = this.#extractPrefix(lastWord) || \"\";\n-    if (colonIndex > 0) {\n-      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n-      const valueText = lastWord.substring(colonIndex + 1);\n-      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n-\n-      if (tip?.type && valueText !== undefined) {\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-        return this.filterSuggessionResults.length > 0\n-          ? this.filterSuggessionResults\n-          : [];\n-      }\n-    }\n+  @action\n+  storeInputElement(element) {\n+    this.inputElement = element;\n+  }\n \n-    // Get a list of the \"top-level\" filters that have a priority of 1,\n-    // such as category:, created-after:, tags:, etc.\n-    if (!this.currentInputValue || lastWord === \"\") {\n-      return this.args.tips\n-        .filter((tip) => tip.priority)\n-        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n-        .slice(0, MAX_RESULTS);\n+  @action\n+  async updateSuggestions() {\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n     }\n-\n-    return this.filterAllTips(lastWord, prefix);\n+    this.searchTimer = discourseDebounce(this, this.fetchSuggestions, 300);\n   }\n \n-  /**\n-   * Filters all available tips based on a search term from the user input\n-   *\n-   * This method searches through the complete list of filter tips and finds matches based on:\n-   * 1. Direct name matches with the search term\n-   * 2. Matches against tip aliases\n-   * 3. Support for prefixed tips (like \"-\", \"=\", \"-=\")\n-   *\n-   * Results are sorted to prioritize exact matches first and are limited to MAX_RESULTS\n-   *\n-   * @param {string} lastWord - The last word in the input string (what user is currently typing)\n-   * @param {string} prefix - Any detected prefix modifier like \"-\", \"=\", or \"-=\"\n-   * @returns {Array} - Array of matching tip objects for display in the menu\n-   */\n-  filterAllTips(lastWord, prefix) {\n-    const tips = [];\n-    this.args.tips.forEach((tip) => {\n-      if (tips.length >= MAX_RESULTS) {\n-        return;\n-      }\n-      const tipName = tip.name;\n-      const searchTerm = lastWord.substring(prefix.length);\n-\n-      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n-        return;\n-      }\n+  async fetchSuggestions() {\n+    const input = this.currentInputValue || \"\";\n+    const requestId = ++this.suggestionRequestId;\n \n-      const prefixMatch =\n-        searchTerm === \"\" &&\n-        prefix &&\n-        tipName.prefixes &&\n-        tipName.prefixes.find((p) => p.name === prefix);\n-\n-      if (prefixMatch || tipName.indexOf(searchTerm) > -1) {\n-        this.#pushPrefixTips(tip, tips, null, prefix);\n-        if (!prefix) {\n-          tips.push(tip);\n+    try {\n+      const result = await FilterSuggestions.getSuggestions(\n+        input,\n+        this.args.tips,\n+        {\n+          site: this.site,\n         }\n-      } else if (tip.alias && tip.alias.indexOf(searchTerm) > -1) {\n-        this.#pushPrefixTips(tip, tips, tip.alias, prefix);\n-        tips.push({ ...tip, name: tip.alias });\n-      }\n-    });\n+      );\n \n-    return tips.sort((a, b) => {\n-      const aName = a.name.toLowerCase();\n-      const bName = b.name.toLowerCase();\n-      const aStartsWith = aName.startsWith(lastWord.toLowerCase());\n-      const bStartsWith = bName.startsWith(lastWord.toLowerCase());\n-      if (aStartsWith && !bStartsWith) {\n-        return -1;\n-      }\n-      if (!aStartsWith && bStartsWith) {\n-        return 1;\n-      }\n-      if (aStartsWith && bStartsWith && aName.length !== bName.length) {\n-        return aName.length - bName.length;\n+      // Drop stale responses or results for outdated input\n+      if (\n+        requestId !== this.suggestionRequestId ||\n+        this.currentInputValue !== input\n+      ) {\n+        return;\n       }\n-      return aName.localeCompare(bName);\n-    });\n-  }\n \n-  /**\n-   * Updates the component state based on the current input value\n-   *\n-   * Unlike the filteredTips getter which just returns the current suggestions,\n-   * this method actively parses the input and updates internal state:\n-   *\n-   * - Resets selection state\n-   * - Sets or clears the activeFilter based on detected filter types\n-   * - Triggers filter-specific suggestion searches when appropriate\n-   * - Updates the reactive state to ensure UI reflects current filter state\n-   *\n-   * This method should be called after actions that modify the input value\n-   * to ensure the component's internal state is synchronized with the input.\n-   */\n-  updateResults() {\n-    this.clearSelection();\n+      this.suggestions = result.suggestions || [];\n+      this.activeFilter = result.activeFilter;\n+      this.trackedMenuListData.suggestions = this.suggestions;\n+      this.trackedMenuListData.selectedIndex = this.selectedIndex;\n+      this.selectedIndex = -1;\n+      this.lastSuggestionInput = input;\n \n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1);\n-    const colonIndex = lastWord.indexOf(\":\");\n-\n-    if (colonIndex > 0) {\n-      const prefix = this.#extractPrefix(lastWord);\n-      const filterName = lastWord.substring(\n-        prefix.length,\n-        colonIndex + prefix.length\n-      );\n-      const valueText = lastWord.substring(colonIndex + 1);\n-\n-      const tip = this.args.tips.find((t) => {\n-        const tipFilterName = t.name.replace(/^[-=]/, \"\").split(\":\")[0];\n-        return tipFilterName === filterName && t.type;\n-      });\n-\n-      if (tip?.type) {\n-        this.activeFilter = filterName;\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-      } else {\n-        this.activeFilter = null;\n-        this.filterSuggessionResults = [];\n+      if (this.dMenuInstance) {\n+        if (!this.suggestions.length) {\n+          this.dMenuInstance.close();\n+        } else {\n+          this.dMenuInstance.show();\n+        }\n       }\n-    } else {\n-      this.activeFilter = null;\n-      this.filterSuggessionResults = [];\n+    } catch {\n+      // ignore fetch errors (rate limits, etc)\n     }\n-\n-    this.trackedMenuListData.filteredTips = this.filteredTips;\n   }\n \n-  #pushPrefixTips(tip, tips, alias = null, currentPrefix = null) {\n-    if (tip.prefixes && tip.prefixes.length > 0) {\n-      tip.prefixes.forEach((prefix) => {\n-        if (currentPrefix && !prefix.name.startsWith(currentPrefix)) {\n-          return;\n-        }\n-        tips.push({\n-          ...tip,\n-          name: `${prefix.name}${alias || tip.name}`,\n-          description: prefix.description || tip.description,\n-          isSuggestion: true,\n-        });\n-      });\n+  async ensureFreshSuggestions() {\n+    if (this.lastSuggestionInput === (this.currentInputValue || \"\")) {\n+      return;\n     }\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n+      this.searchTimer = null;\n+    }\n+    await this.fetchSuggestions();\n   }\n \n-  #extractPrefix(word) {\n-    const match = word.match(/^(-=|=-|-|=)/);\n-    return match ? match[0] : \"\";\n-  }\n-\n-  @action\n-  storeInputElement(element) {\n-    this.inputElement = element;\n-  }\n-\n-  @action\n-  handleFilterSuggestionSearch(filterName, valueText, tip, prefix = \"\") {\n-    this.activeFilter = filterName;\n-    this.searchTimer = discourseDebounce(\n-      this,\n-      this.#performFilterSuggestionSearch,\n-      filterName,\n-      valueText,\n-      tip,\n-      prefix,\n-      300\n-    );\n-  }\n-\n-  /**\n-   * Handles selection of a filter tip item from the dropdown menu.\n-   * See TopicsFilter.option_info for the structure of the item\n-   * on the server.\n-   *\n-   * @param {Object} item - A filter tip object from the initial list or from the filter suggestions\n-   * @param {string} item.name - The name of the filter (e.g. \"category:\", \"tag:\")\n-   * @param {string} [item.alias] - Alternative name for the filter (e.g. \"categories:\")\n-   * @param {string} [item.description] - Human-readable description of the filter\n-   * @param {number} [item.priority] - Priority value for sorting (higher appears first)\n-   * @param {string} [item.type] - Type of filter for suggestions (category, tag, username, date, number)\n-   * @param {Array<Object>} [item.delimiters] - Delimiter options for multiple values\n-   * @param {Array<Object>} [item.prefixes] - Prefix modifiers for this filter (-, =, -=)\n-   * @param {boolean} [item.isSuggestion] - Whether this is a suggestion for a specific filter value\n-   */\n   @action\n-  selectItem(item) {\n-    // Split up the string from the text input into words.\n+  async selectItem(item) {\n     const words = this.currentInputValue.split(/\\s+/);\n+    let newValue;\n \n-    // If we are selecting an item that was suggested based on the initial\n-    // word selected (e.g. after picking a \"category:\" the user selects a\n-    // category from the list), we replace the last word with the selected item.\n     if (item.isSuggestion) {\n+      // Replace the last word with the selected suggestion\n       words[words.length - 1] = item.name;\n-      let updatedInputValue = words.join(\" \");\n+      newValue = words.join(\" \");\n+\n+      // Add space unless it's a filter that takes delimiters\n       if (\n-        !updatedInputValue.endsWith(\":\") &&\n+        !newValue.endsWith(\":\") &&\n         (!item.delimiters || item.delimiters.length < 2)\n       ) {\n-        updatedInputValue += \" \";\n+        newValue += \" \";\n       }\n-      this.updateInput(updatedInputValue);\n     } else {\n-      // Otherwise if the user is selecting a filter from the initial tips,\n-      // we add a colon to the end of it as needed, and fire off the\n-      // suggestion search based on the filter type.\n-      const lastWord = words.at(-1);\n-      const prefix = this.#extractPrefix(lastWord);\n-      const supportsPrefix = item.prefixes && item.prefixes.length > 0;\n-      const filterName =\n-        supportsPrefix && prefix ? `${prefix}${item.name}` : item.name;\n-\n-      words[words.length - 1] = filterName;\n-      if (!filterName.endsWith(\":\") && !item.delimiters?.length) {\n+      // Selecting a filter tip - add it to the input\n+      words[words.length - 1] = item.name;\n+\n+      // Don't add space if this filter uses delimiters\n+      if (!item.name.endsWith(\":\") && !item.delimiters?.length) {\n         words[words.length - 1] += \" \";\n       }\n \n-      const updatedInputValue = words.join(\" \");\n-      this.updateInput(updatedInputValue);\n-\n-      const baseFilterName = item.name.replace(/^[-=]/, \"\").split(\":\")[0];\n-      if (item.type) {\n-        this.activeFilter = baseFilterName;\n-        this.handleFilterSuggestionSearch(baseFilterName, \"\", item, prefix);\n-      }\n+      newValue = words.join(\" \");\n     }\n \n-    this.clearSelection();\n-    this.inputElement.focus();\n+    await this.updateInput(newValue);\n+    this.inputElement?.focus();\n   }\n \n   @action\n-  updateInput(updatedInputValue, refreshQuery = false) {\n-    this.currentInputValue = updatedInputValue;\n-    this.args.onChange(updatedInputValue, refreshQuery);\n-    this.trackedMenuListData.filteredTips = this.filteredTips;\n-    this.updateResults();\n+  async updateInput(value, submitQuery = false) {\n+    value = value || \"\";",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2268643740",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33992,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation-menu.gjs",
        "discussion_id": "2268643740",
        "commented_code": "@@ -52,324 +49,161 @@ const FilterNavigationMenuList = <template>\n </template>;\n \n /**\n- * This component provides an input field and parsing logic for filter\n- * queries. Every time the input changes, we recalculate the list of\n- * filter tips that match the current input value.\n- *\n- * We start from an initial list of tips provided by the server\n- * (see TopicsFilter.option_info) which are reduced to a list of \"high priority/top-level\"\n- * filters if there is no user input value.\n+ * FilterNavigationMenu - A simpler UI component for filter input and suggestions\n  *\n- * Once the user starts typing, we parse the input value to determine\n- * the last word and its prefix (if any). If the last word contains a colon,\n- * we treat it as a filter name and look for matching tips via the FilterSuggestions service.\n- * For example after \"category:\" is typed we show a list of categories the user\n- * has access to.\n+ * This component manages:\n+ * - User input field\n+ * - Keyboard navigation\n+ * - Dropdown menu display\n+ * - Selection handling\n  *\n- * Each filter tip can have prefixes (like \"-\", \"=\", and \"-=\") that modify the filter behavior,\n- * as well as delimiters (like \",\") that allow for multiple values.\n+ * The actual suggestion generation is delegated to FilterSuggestions\n  */\n export default class FilterNavigationMenu extends Component {\n   @service menu;\n   @service site;\n \n-  @resettableTracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked currentInputValue = this.args.initialInputValue || \"\";\n+  @tracked suggestions = [];\n+  @tracked activeFilter = null;\n+  @tracked selectedIndex = -1;\n+\n+  lastSuggestionInput = \"\";\n+  suggestionRequestId = 0;\n \n-  filterSuggessionResults = [];\n-  activeFilter = null;\n   trackedMenuListData = new TrackedObject({\n-    filteredTips: this.filteredTips,\n+    suggestions: [],\n     selectedIndex: null,\n     selectItem: this.selectItem,\n   });\n \n-  @tracked _selectedIndex = -1;\n-\n-  get selectedIndex() {\n-    return this._selectedIndex;\n-  }\n-\n-  set selectedIndex(value) {\n-    this._selectedIndex = value;\n-    this.trackedMenuListData.selectedIndex = value;\n-  }\n-\n-  clearSelection() {\n-    this.selectedIndex = -1;\n-  }\n+  searchTimer = null;\n+  inputElement = null;\n+  dMenuInstance = null;\n \n   get nothingSelected() {\n     return this.selectedIndex === -1;\n   }\n \n-  get filteredTips() {\n-    if (!this.args.tips) {\n-      return [];\n-    }\n-\n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1).toLowerCase();\n-\n-    // If we're already filtering by a type like \"category:\" that has suggestions,\n-    // we want to only show those suggestions.\n-    if (this.activeFilter && this.filterSuggessionResults.length > 0) {\n-      return this.filterSuggessionResults;\n-    }\n-\n-    // We are filtering by a type here like \"category:\", \"tag:\", etc.\n-    // since the last word contains a colon.\n-    const colonIndex = lastWord.indexOf(\":\");\n-    const prefix = this.#extractPrefix(lastWord) || \"\";\n-    if (colonIndex > 0) {\n-      const filterName = lastWord.substring(prefix.length).split(\":\")[0];\n-      const valueText = lastWord.substring(colonIndex + 1);\n-      const tip = this.args.tips.find((t) => t.name === filterName + \":\");\n-\n-      if (tip?.type && valueText !== undefined) {\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-        return this.filterSuggessionResults.length > 0\n-          ? this.filterSuggessionResults\n-          : [];\n-      }\n-    }\n+  @action\n+  storeInputElement(element) {\n+    this.inputElement = element;\n+  }\n \n-    // Get a list of the \"top-level\" filters that have a priority of 1,\n-    // such as category:, created-after:, tags:, etc.\n-    if (!this.currentInputValue || lastWord === \"\") {\n-      return this.args.tips\n-        .filter((tip) => tip.priority)\n-        .sort((a, b) => (b.priority || 0) - (a.priority || 0))\n-        .slice(0, MAX_RESULTS);\n+  @action\n+  async updateSuggestions() {\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n     }\n-\n-    return this.filterAllTips(lastWord, prefix);\n+    this.searchTimer = discourseDebounce(this, this.fetchSuggestions, 300);\n   }\n \n-  /**\n-   * Filters all available tips based on a search term from the user input\n-   *\n-   * This method searches through the complete list of filter tips and finds matches based on:\n-   * 1. Direct name matches with the search term\n-   * 2. Matches against tip aliases\n-   * 3. Support for prefixed tips (like \"-\", \"=\", \"-=\")\n-   *\n-   * Results are sorted to prioritize exact matches first and are limited to MAX_RESULTS\n-   *\n-   * @param {string} lastWord - The last word in the input string (what user is currently typing)\n-   * @param {string} prefix - Any detected prefix modifier like \"-\", \"=\", or \"-=\"\n-   * @returns {Array} - Array of matching tip objects for display in the menu\n-   */\n-  filterAllTips(lastWord, prefix) {\n-    const tips = [];\n-    this.args.tips.forEach((tip) => {\n-      if (tips.length >= MAX_RESULTS) {\n-        return;\n-      }\n-      const tipName = tip.name;\n-      const searchTerm = lastWord.substring(prefix.length);\n-\n-      if (searchTerm.endsWith(\":\") && tipName === searchTerm) {\n-        return;\n-      }\n+  async fetchSuggestions() {\n+    const input = this.currentInputValue || \"\";\n+    const requestId = ++this.suggestionRequestId;\n \n-      const prefixMatch =\n-        searchTerm === \"\" &&\n-        prefix &&\n-        tipName.prefixes &&\n-        tipName.prefixes.find((p) => p.name === prefix);\n-\n-      if (prefixMatch || tipName.indexOf(searchTerm) > -1) {\n-        this.#pushPrefixTips(tip, tips, null, prefix);\n-        if (!prefix) {\n-          tips.push(tip);\n+    try {\n+      const result = await FilterSuggestions.getSuggestions(\n+        input,\n+        this.args.tips,\n+        {\n+          site: this.site,\n         }\n-      } else if (tip.alias && tip.alias.indexOf(searchTerm) > -1) {\n-        this.#pushPrefixTips(tip, tips, tip.alias, prefix);\n-        tips.push({ ...tip, name: tip.alias });\n-      }\n-    });\n+      );\n \n-    return tips.sort((a, b) => {\n-      const aName = a.name.toLowerCase();\n-      const bName = b.name.toLowerCase();\n-      const aStartsWith = aName.startsWith(lastWord.toLowerCase());\n-      const bStartsWith = bName.startsWith(lastWord.toLowerCase());\n-      if (aStartsWith && !bStartsWith) {\n-        return -1;\n-      }\n-      if (!aStartsWith && bStartsWith) {\n-        return 1;\n-      }\n-      if (aStartsWith && bStartsWith && aName.length !== bName.length) {\n-        return aName.length - bName.length;\n+      // Drop stale responses or results for outdated input\n+      if (\n+        requestId !== this.suggestionRequestId ||\n+        this.currentInputValue !== input\n+      ) {\n+        return;\n       }\n-      return aName.localeCompare(bName);\n-    });\n-  }\n \n-  /**\n-   * Updates the component state based on the current input value\n-   *\n-   * Unlike the filteredTips getter which just returns the current suggestions,\n-   * this method actively parses the input and updates internal state:\n-   *\n-   * - Resets selection state\n-   * - Sets or clears the activeFilter based on detected filter types\n-   * - Triggers filter-specific suggestion searches when appropriate\n-   * - Updates the reactive state to ensure UI reflects current filter state\n-   *\n-   * This method should be called after actions that modify the input value\n-   * to ensure the component's internal state is synchronized with the input.\n-   */\n-  updateResults() {\n-    this.clearSelection();\n+      this.suggestions = result.suggestions || [];\n+      this.activeFilter = result.activeFilter;\n+      this.trackedMenuListData.suggestions = this.suggestions;\n+      this.trackedMenuListData.selectedIndex = this.selectedIndex;\n+      this.selectedIndex = -1;\n+      this.lastSuggestionInput = input;\n \n-    const words = this.currentInputValue.split(/\\s+/);\n-    const lastWord = words.at(-1);\n-    const colonIndex = lastWord.indexOf(\":\");\n-\n-    if (colonIndex > 0) {\n-      const prefix = this.#extractPrefix(lastWord);\n-      const filterName = lastWord.substring(\n-        prefix.length,\n-        colonIndex + prefix.length\n-      );\n-      const valueText = lastWord.substring(colonIndex + 1);\n-\n-      const tip = this.args.tips.find((t) => {\n-        const tipFilterName = t.name.replace(/^[-=]/, \"\").split(\":\")[0];\n-        return tipFilterName === filterName && t.type;\n-      });\n-\n-      if (tip?.type) {\n-        this.activeFilter = filterName;\n-        this.handleFilterSuggestionSearch(filterName, valueText, tip, prefix);\n-      } else {\n-        this.activeFilter = null;\n-        this.filterSuggessionResults = [];\n+      if (this.dMenuInstance) {\n+        if (!this.suggestions.length) {\n+          this.dMenuInstance.close();\n+        } else {\n+          this.dMenuInstance.show();\n+        }\n       }\n-    } else {\n-      this.activeFilter = null;\n-      this.filterSuggessionResults = [];\n+    } catch {\n+      // ignore fetch errors (rate limits, etc)\n     }\n-\n-    this.trackedMenuListData.filteredTips = this.filteredTips;\n   }\n \n-  #pushPrefixTips(tip, tips, alias = null, currentPrefix = null) {\n-    if (tip.prefixes && tip.prefixes.length > 0) {\n-      tip.prefixes.forEach((prefix) => {\n-        if (currentPrefix && !prefix.name.startsWith(currentPrefix)) {\n-          return;\n-        }\n-        tips.push({\n-          ...tip,\n-          name: `${prefix.name}${alias || tip.name}`,\n-          description: prefix.description || tip.description,\n-          isSuggestion: true,\n-        });\n-      });\n+  async ensureFreshSuggestions() {\n+    if (this.lastSuggestionInput === (this.currentInputValue || \"\")) {\n+      return;\n     }\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n+      this.searchTimer = null;\n+    }\n+    await this.fetchSuggestions();\n   }\n \n-  #extractPrefix(word) {\n-    const match = word.match(/^(-=|=-|-|=)/);\n-    return match ? match[0] : \"\";\n-  }\n-\n-  @action\n-  storeInputElement(element) {\n-    this.inputElement = element;\n-  }\n-\n-  @action\n-  handleFilterSuggestionSearch(filterName, valueText, tip, prefix = \"\") {\n-    this.activeFilter = filterName;\n-    this.searchTimer = discourseDebounce(\n-      this,\n-      this.#performFilterSuggestionSearch,\n-      filterName,\n-      valueText,\n-      tip,\n-      prefix,\n-      300\n-    );\n-  }\n-\n-  /**\n-   * Handles selection of a filter tip item from the dropdown menu.\n-   * See TopicsFilter.option_info for the structure of the item\n-   * on the server.\n-   *\n-   * @param {Object} item - A filter tip object from the initial list or from the filter suggestions\n-   * @param {string} item.name - The name of the filter (e.g. \"category:\", \"tag:\")\n-   * @param {string} [item.alias] - Alternative name for the filter (e.g. \"categories:\")\n-   * @param {string} [item.description] - Human-readable description of the filter\n-   * @param {number} [item.priority] - Priority value for sorting (higher appears first)\n-   * @param {string} [item.type] - Type of filter for suggestions (category, tag, username, date, number)\n-   * @param {Array<Object>} [item.delimiters] - Delimiter options for multiple values\n-   * @param {Array<Object>} [item.prefixes] - Prefix modifiers for this filter (-, =, -=)\n-   * @param {boolean} [item.isSuggestion] - Whether this is a suggestion for a specific filter value\n-   */\n   @action\n-  selectItem(item) {\n-    // Split up the string from the text input into words.\n+  async selectItem(item) {\n     const words = this.currentInputValue.split(/\\s+/);\n+    let newValue;\n \n-    // If we are selecting an item that was suggested based on the initial\n-    // word selected (e.g. after picking a \"category:\" the user selects a\n-    // category from the list), we replace the last word with the selected item.\n     if (item.isSuggestion) {\n+      // Replace the last word with the selected suggestion\n       words[words.length - 1] = item.name;\n-      let updatedInputValue = words.join(\" \");\n+      newValue = words.join(\" \");\n+\n+      // Add space unless it's a filter that takes delimiters\n       if (\n-        !updatedInputValue.endsWith(\":\") &&\n+        !newValue.endsWith(\":\") &&\n         (!item.delimiters || item.delimiters.length < 2)\n       ) {\n-        updatedInputValue += \" \";\n+        newValue += \" \";\n       }\n-      this.updateInput(updatedInputValue);\n     } else {\n-      // Otherwise if the user is selecting a filter from the initial tips,\n-      // we add a colon to the end of it as needed, and fire off the\n-      // suggestion search based on the filter type.\n-      const lastWord = words.at(-1);\n-      const prefix = this.#extractPrefix(lastWord);\n-      const supportsPrefix = item.prefixes && item.prefixes.length > 0;\n-      const filterName =\n-        supportsPrefix && prefix ? `${prefix}${item.name}` : item.name;\n-\n-      words[words.length - 1] = filterName;\n-      if (!filterName.endsWith(\":\") && !item.delimiters?.length) {\n+      // Selecting a filter tip - add it to the input\n+      words[words.length - 1] = item.name;\n+\n+      // Don't add space if this filter uses delimiters\n+      if (!item.name.endsWith(\":\") && !item.delimiters?.length) {\n         words[words.length - 1] += \" \";\n       }\n \n-      const updatedInputValue = words.join(\" \");\n-      this.updateInput(updatedInputValue);\n-\n-      const baseFilterName = item.name.replace(/^[-=]/, \"\").split(\":\")[0];\n-      if (item.type) {\n-        this.activeFilter = baseFilterName;\n-        this.handleFilterSuggestionSearch(baseFilterName, \"\", item, prefix);\n-      }\n+      newValue = words.join(\" \");\n     }\n \n-    this.clearSelection();\n-    this.inputElement.focus();\n+    await this.updateInput(newValue);\n+    this.inputElement?.focus();\n   }\n \n   @action\n-  updateInput(updatedInputValue, refreshQuery = false) {\n-    this.currentInputValue = updatedInputValue;\n-    this.args.onChange(updatedInputValue, refreshQuery);\n-    this.trackedMenuListData.filteredTips = this.filteredTips;\n-    this.updateResults();\n+  async updateInput(value, submitQuery = false) {\n+    value = value || \"\";",
        "comment_created_at": "2025-08-12T05:41:53+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n    value ??= \"\"\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2245248502",
    "pr_number": 33986,
    "pr_file": "app/assets/javascripts/discourse/app/components/post/cooked-html.gjs",
    "created_at": "2025-07-31T12:30:08+00:00",
    "commented_code": ");\n   }\n \n-  #cleanupDecorations() {\n-    this.#pendingDecoratorCleanup.forEach((teardown) => teardown());\n-    this.#pendingDecoratorCleanup = [];\n+  @bind\n+  decorateBeforeAdopt(element, helper, args) {\n+    const decorators = [\n+      ...POST_COOKED_DECORATORS_BEFORE_ADOPT,\n+      ...this.extraDecorators,\n+    ];\n+\n+    if (this.shouldAddSelectionBarrier) {\n+      decorators.push(decorateSelectionBarrier);\n+    }\n+\n+    const eventName = this.isStreamElement\n+      ? \"decorate-post-cooked-element:before-adopt\"\n+      : \"decorate-non-stream-cooked-element\";\n+\n+    this.#decorate(\"beforeAdopt\", {\n+      element,\n+      helper,\n+      decorators,\n+      extraDecorators: this.extraDecorators,\n+      args,\n+      decorateCookedEvent: eventName,\n+    });\n+  }\n+\n+  @bind\n+  decorateAfterAdopt(element, helper, args) {\n+    const decorators = [\n+      ...POST_COOKED_DECORATORS_AFTER_ADOPT,\n+      ...this.extraDecoratorsAfterAdopt,\n+    ];\n+\n+    const eventName = this.isStreamElement\n+      ? \"decorate-post-cooked-element:after-adopt\"\n+      : null;\n+\n+    this.#decorate(\"afterAdopt\", {\n+      element,\n+      helper,\n+      decorators,\n+      extraDecorators: this.extraDecoratorsAfterAdopt,\n+      args,\n+      decorateCookedEvent: eventName,\n+    });\n+  }\n+\n+  /**\n+   * Safely executes a function and handles errors appropriately for testing vs production\n+   * @param {Function} fn - Function to execute\n+   * @private\n+   */\n+  #safeExecute(fn) {\n+    try {\n+      return fn();\n+    } catch (e) {\n+      if (isRailsTesting() || isTesting()) {\n+        throw e;\n+      } else {\n+        // eslint-disable-next-line no-console\n+        console.error(e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Gets or creates decorator state for a given decorator function\n+   * @param {Function} decorator - The decorator function to get state for\n+   * @returns {TrackedMap} The decorator's state storage\n+   * @private\n+   */\n+  #getDecoratorState(decorator) {\n+    if (this.#decoratorState.has(decorator)) {\n+      return this.#decoratorState.get(decorator);\n+    }\n+\n+    // Create new state storage for this decorator\n+    const decoratorState = new TrackedMap();\n+    this.#decoratorState.set(decorator, decoratorState);\n+    return decoratorState;\n+  }\n+\n+  /**\n+   * Creates the context object passed to decorator functions\n+   * @param {HTMLElement} element - The DOM element being decorated\n+   * @param {Object} helper - Helper object containing utility functions\n+   * @param {Object} args - Arguments passed to the decorator\n+   * @param {TrackedMap} decoratorState - State storage for the decorator\n+   * @param {Array<Function>} extraDecorators - Additional decorator functions\n+   * @returns {Object} The decorator context object\n+   * @private\n+   */\n+  #createDecoratorContext(\n+    element,\n+    helper,\n+    args,\n+    decoratorState,\n+    extraDecorators\n+  ) {\n+    const owner = getOwner(this);\n+\n+    return {\n+      cooked: this.cooked,\n+      createDetachedElement: this.#createDetachedElement,\n+      currentUser: this.currentUser,\n+      decoratorState,\n+      extraDecorators: this.extraDecorators,\n+      helper,\n+      highlightTerm: args.highlightTerm,\n+      ignoredUsers: args.ignoredUsers,\n+      isIgnored: args.isIgnored,\n+      owner,\n+      post: this.args.post,\n+      renderGlimmer: helper.renderGlimmer,\n+      renderNestedPostCookedHtml: this.#renderNestedPostCookedHtml(helper, {\n+        args,\n+        decoratorState,\n+        decorators: extraDecorators,\n+        isStreamElement: this.isStreamElement,\n+        owner,\n+      }),\n+      streamElement: this.isStreamElement,\n+    };\n+  }\n+\n+  /**\n+   * Stores cleanup function for a decoration phase\n+   * @param {string} phase - The decoration phase ('beforeAdopt' or 'afterAdopt')\n+   * @param {Function} cleanupFn - The cleanup function to store\n+   * @private\n+   */\n+  #storeCleanupFunction(phase, cleanupFn) {\n+    if (!this.#pendingCleanup[phase]) {\n+      this.#pendingCleanup[phase] = [];\n+    }",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2245248502",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33986,
        "pr_file": "app/assets/javascripts/discourse/app/components/post/cooked-html.gjs",
        "discussion_id": "2245248502",
        "commented_code": "@@ -184,13 +84,273 @@ export default class PostCookedHtml extends Component {\n     );\n   }\n \n-  #cleanupDecorations() {\n-    this.#pendingDecoratorCleanup.forEach((teardown) => teardown());\n-    this.#pendingDecoratorCleanup = [];\n+  @bind\n+  decorateBeforeAdopt(element, helper, args) {\n+    const decorators = [\n+      ...POST_COOKED_DECORATORS_BEFORE_ADOPT,\n+      ...this.extraDecorators,\n+    ];\n+\n+    if (this.shouldAddSelectionBarrier) {\n+      decorators.push(decorateSelectionBarrier);\n+    }\n+\n+    const eventName = this.isStreamElement\n+      ? \"decorate-post-cooked-element:before-adopt\"\n+      : \"decorate-non-stream-cooked-element\";\n+\n+    this.#decorate(\"beforeAdopt\", {\n+      element,\n+      helper,\n+      decorators,\n+      extraDecorators: this.extraDecorators,\n+      args,\n+      decorateCookedEvent: eventName,\n+    });\n+  }\n+\n+  @bind\n+  decorateAfterAdopt(element, helper, args) {\n+    const decorators = [\n+      ...POST_COOKED_DECORATORS_AFTER_ADOPT,\n+      ...this.extraDecoratorsAfterAdopt,\n+    ];\n+\n+    const eventName = this.isStreamElement\n+      ? \"decorate-post-cooked-element:after-adopt\"\n+      : null;\n+\n+    this.#decorate(\"afterAdopt\", {\n+      element,\n+      helper,\n+      decorators,\n+      extraDecorators: this.extraDecoratorsAfterAdopt,\n+      args,\n+      decorateCookedEvent: eventName,\n+    });\n+  }\n+\n+  /**\n+   * Safely executes a function and handles errors appropriately for testing vs production\n+   * @param {Function} fn - Function to execute\n+   * @private\n+   */\n+  #safeExecute(fn) {\n+    try {\n+      return fn();\n+    } catch (e) {\n+      if (isRailsTesting() || isTesting()) {\n+        throw e;\n+      } else {\n+        // eslint-disable-next-line no-console\n+        console.error(e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Gets or creates decorator state for a given decorator function\n+   * @param {Function} decorator - The decorator function to get state for\n+   * @returns {TrackedMap} The decorator's state storage\n+   * @private\n+   */\n+  #getDecoratorState(decorator) {\n+    if (this.#decoratorState.has(decorator)) {\n+      return this.#decoratorState.get(decorator);\n+    }\n+\n+    // Create new state storage for this decorator\n+    const decoratorState = new TrackedMap();\n+    this.#decoratorState.set(decorator, decoratorState);\n+    return decoratorState;\n+  }\n+\n+  /**\n+   * Creates the context object passed to decorator functions\n+   * @param {HTMLElement} element - The DOM element being decorated\n+   * @param {Object} helper - Helper object containing utility functions\n+   * @param {Object} args - Arguments passed to the decorator\n+   * @param {TrackedMap} decoratorState - State storage for the decorator\n+   * @param {Array<Function>} extraDecorators - Additional decorator functions\n+   * @returns {Object} The decorator context object\n+   * @private\n+   */\n+  #createDecoratorContext(\n+    element,\n+    helper,\n+    args,\n+    decoratorState,\n+    extraDecorators\n+  ) {\n+    const owner = getOwner(this);\n+\n+    return {\n+      cooked: this.cooked,\n+      createDetachedElement: this.#createDetachedElement,\n+      currentUser: this.currentUser,\n+      decoratorState,\n+      extraDecorators: this.extraDecorators,\n+      helper,\n+      highlightTerm: args.highlightTerm,\n+      ignoredUsers: args.ignoredUsers,\n+      isIgnored: args.isIgnored,\n+      owner,\n+      post: this.args.post,\n+      renderGlimmer: helper.renderGlimmer,\n+      renderNestedPostCookedHtml: this.#renderNestedPostCookedHtml(helper, {\n+        args,\n+        decoratorState,\n+        decorators: extraDecorators,\n+        isStreamElement: this.isStreamElement,\n+        owner,\n+      }),\n+      streamElement: this.isStreamElement,\n+    };\n+  }\n+\n+  /**\n+   * Stores cleanup function for a decoration phase\n+   * @param {string} phase - The decoration phase ('beforeAdopt' or 'afterAdopt')\n+   * @param {Function} cleanupFn - The cleanup function to store\n+   * @private\n+   */\n+  #storeCleanupFunction(phase, cleanupFn) {\n+    if (!this.#pendingCleanup[phase]) {\n+      this.#pendingCleanup[phase] = [];\n+    }",
        "comment_created_at": "2025-07-31T12:30:08+00:00",
        "comment_author": "CvX",
        "comment_body": "```suggestion\r\n    this.#pendingCleanup[phase] ||= [];\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234682486",
    "pr_number": 33876,
    "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation.gjs",
    "created_at": "2025-07-28T04:49:06+00:00",
    "commented_code": "this._allowEnterSubmit = !value;\n   }\n \n+  @action\n+  setupEventListeners() {\n+    if (!this.inputElement) {\n+      throw new Error(\"DiscoveryFilterNavigation requires an inputElement.\");\n+    }\n+    this.inputElement.addEventListener(\"focus\", this.handleInputFocus);\n+    this.inputElement.addEventListener(\"blur\", this.handleInputBlur);\n+    this.inputElement.addEventListener(\"keydown\", this.handleKeyDownTips);\n+    this.inputElement.addEventListener(\"input\", this.handleInput);\n+  }\n+\n+  @action\n+  onRegisterApi(api) {\n+    this.dMenu = api;\n+    if (this.inputElement) {\n+      this.dMenu.trigger = this.inputElement;\n+      this.dMenu.detachedTrigger = true;\n+    }\n+  }\n+\n+  @action\n+  handleInput() {\n+    this.updateResults(this.inputElement.value);\n+  }\n+\n+  updateResults(value) {\n+    this.newQueryString = value;\n+    this.selectedIndex = -1;\n+\n+    const words = value.split(/\\s+/);\n+    const lastWord = words.at(-1);\n+    const colonIndex = lastWord.indexOf(\":\");\n+\n+    if (colonIndex > 0) {\n+      const prefix = this.extractPrefix(lastWord);\n+      const filterName = lastWord.substring(\n+        prefix.length,\n+        colonIndex + prefix.length\n+      );\n+      const valueText = lastWord.substring(colonIndex + 1);\n+\n+      const tip = this.args.tips.find((t) => {\n+        const tipFilterName = t.name.replace(/^[-=]/, \"\").split(\":\")[0];\n+        return tipFilterName === filterName && t.type;\n+      });\n+\n+      if (tip?.type) {\n+        this.activeFilter = filterName;\n+        this.handlePlaceholderSearch(filterName, valueText, tip, prefix);\n+      } else {\n+        this.activeFilter = null;\n+        this.searchResults = [];\n+      }\n+    } else {\n+      this.activeFilter = null;\n+      this.searchResults = [];\n+    }\n+  }\n+\n+  @action\n+  handleInputFocus() {\n+    this.showTips = true;\n+    this.selectedIndex = -1;\n+    this.dMenu?.show();\n+  }\n+\n+  @action\n+  handleInputBlur() {\n+    if (this.handleBlurTimer) {\n+      cancel(this.handleBlurTimer);\n+    }",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2234682486",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33876,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-navigation.gjs",
        "discussion_id": "2234682486",
        "commented_code": "@@ -81,6 +124,462 @@ export default class DiscoveryFilterNavigation extends Component {\n     this._allowEnterSubmit = !value;\n   }\n \n+  @action\n+  setupEventListeners() {\n+    if (!this.inputElement) {\n+      throw new Error(\"DiscoveryFilterNavigation requires an inputElement.\");\n+    }\n+    this.inputElement.addEventListener(\"focus\", this.handleInputFocus);\n+    this.inputElement.addEventListener(\"blur\", this.handleInputBlur);\n+    this.inputElement.addEventListener(\"keydown\", this.handleKeyDownTips);\n+    this.inputElement.addEventListener(\"input\", this.handleInput);\n+  }\n+\n+  @action\n+  onRegisterApi(api) {\n+    this.dMenu = api;\n+    if (this.inputElement) {\n+      this.dMenu.trigger = this.inputElement;\n+      this.dMenu.detachedTrigger = true;\n+    }\n+  }\n+\n+  @action\n+  handleInput() {\n+    this.updateResults(this.inputElement.value);\n+  }\n+\n+  updateResults(value) {\n+    this.newQueryString = value;\n+    this.selectedIndex = -1;\n+\n+    const words = value.split(/\\s+/);\n+    const lastWord = words.at(-1);\n+    const colonIndex = lastWord.indexOf(\":\");\n+\n+    if (colonIndex > 0) {\n+      const prefix = this.extractPrefix(lastWord);\n+      const filterName = lastWord.substring(\n+        prefix.length,\n+        colonIndex + prefix.length\n+      );\n+      const valueText = lastWord.substring(colonIndex + 1);\n+\n+      const tip = this.args.tips.find((t) => {\n+        const tipFilterName = t.name.replace(/^[-=]/, \"\").split(\":\")[0];\n+        return tipFilterName === filterName && t.type;\n+      });\n+\n+      if (tip?.type) {\n+        this.activeFilter = filterName;\n+        this.handlePlaceholderSearch(filterName, valueText, tip, prefix);\n+      } else {\n+        this.activeFilter = null;\n+        this.searchResults = [];\n+      }\n+    } else {\n+      this.activeFilter = null;\n+      this.searchResults = [];\n+    }\n+  }\n+\n+  @action\n+  handleInputFocus() {\n+    this.showTips = true;\n+    this.selectedIndex = -1;\n+    this.dMenu?.show();\n+  }\n+\n+  @action\n+  handleInputBlur() {\n+    if (this.handleBlurTimer) {\n+      cancel(this.handleBlurTimer);\n+    }",
        "comment_created_at": "2025-07-28T04:49:06+00:00",
        "comment_author": "jjaffeux",
        "comment_body": "cancel will not generate an error on undefined values, so you don't need the if here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2158773588",
    "pr_number": 33181,
    "pr_file": "app/assets/javascripts/discourse/app/components/reviewable-tags.gjs",
    "created_at": "2025-06-20T11:48:13+00:00",
    "commented_code": "import Component from \"@ember/component\";\n-import discourseTag from \"discourse/helpers/discourse-tag\";\n+import { or } from \"truth-helpers\";\n+import discourseTags from \"discourse/helpers/discourse-tags\";\n \n export default class ReviewableTags extends Component {\n   <template>\n-    {{#if this.tags}}\n+    {{#if @tags}}\n       <div class=\"list-tags\">\n-        {{#each this.tags as |t|}}{{discourseTag t}}{{/each}}\n+        {{discourseTags (or @topic null) tags=@tags}}",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2158773588",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33181,
        "pr_file": "app/assets/javascripts/discourse/app/components/reviewable-tags.gjs",
        "discussion_id": "2158773588",
        "commented_code": "@@ -1,11 +1,12 @@\n import Component from \"@ember/component\";\n-import discourseTag from \"discourse/helpers/discourse-tag\";\n+import { or } from \"truth-helpers\";\n+import discourseTags from \"discourse/helpers/discourse-tags\";\n \n export default class ReviewableTags extends Component {\n   <template>\n-    {{#if this.tags}}\n+    {{#if @tags}}\n       <div class=\"list-tags\">\n-        {{#each this.tags as |t|}}{{discourseTag t}}{{/each}}\n+        {{discourseTags (or @topic null) tags=@tags}}",
        "comment_created_at": "2025-06-20T11:48:13+00:00",
        "comment_author": "CvX",
        "comment_body": "`(or @topic null)` isn't necessary, is it? (`discourseTags` helper will probably work the same with `undefined` as it does with `null`)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154817404",
    "pr_number": 33200,
    "pr_file": "app/assets/javascripts/discourse/app/components/post/cooked-html.gjs",
    "created_at": "2025-06-18T14:49:40+00:00",
    "commented_code": "[...POST_COOKED_DECORATORS, ...this.extraDecorators].forEach(\n       (decorator) => {\n         try {\n-          if (!this.#decoratorState.has(decorator)) {\n-            this.#decoratorState.set(decorator, {});\n+          let decoratorState;\n+\n+          if (this.#cloakedState[decorator] !== undefined) {\n+            decoratorState = this.#cloakedState[decorator];\n+          } else {\n+            decoratorState = new TrackedObject();\n+            this.#cloakedState[decorator] = decoratorState;\n           }",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2154817404",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33200,
        "pr_file": "app/assets/javascripts/discourse/app/components/post/cooked-html.gjs",
        "discussion_id": "2154817404",
        "commented_code": "@@ -49,11 +50,40 @@ export default class PostCookedHtml extends Component {\n     [...POST_COOKED_DECORATORS, ...this.extraDecorators].forEach(\n       (decorator) => {\n         try {\n-          if (!this.#decoratorState.has(decorator)) {\n-            this.#decoratorState.set(decorator, {});\n+          let decoratorState;\n+\n+          if (this.#cloakedState[decorator] !== undefined) {\n+            decoratorState = this.#cloakedState[decorator];\n+          } else {\n+            decoratorState = new TrackedObject();\n+            this.#cloakedState[decorator] = decoratorState;\n           }",
        "comment_created_at": "2025-06-18T14:49:40+00:00",
        "comment_author": "davidtaylorhq",
        "comment_body": "```suggestion\r\n          const decoratorState = this.#cloakedState[decorator] ??= new TrackedObject();\r\n```",
        "pr_file_module": null
      }
    ]
  }
]