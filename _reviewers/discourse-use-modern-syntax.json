[
  {
    "discussion_id": "2284079441",
    "pr_number": 33737,
    "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
    "created_at": "2025-08-19T05:14:16+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2284079441",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33737,
        "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
        "discussion_id": "2284079441",
        "commented_code": "@@ -0,0 +1,377 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {",
        "comment_created_at": "2025-08-19T05:14:16+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n  #buildEventObject(from, to) {\r\n```\r\n\r\nShould use native private, dev-xp wants this now not the fake `_` one",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2284084303",
    "pr_number": 33737,
    "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
    "created_at": "2025-08-19T05:18:10+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2284084303",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33737,
        "pr_file": "plugins/discourse-calendar/assets/javascripts/discourse/components/post-calendar.gjs",
        "discussion_id": "2284084303",
        "commented_code": "@@ -0,0 +1,377 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import willDestroy from \"@ember/render-modifiers/modifiers/will-destroy\";\n+import { service } from \"@ember/service\";\n+import { htmlSafe } from \"@ember/template\";\n+import { popupAjaxError } from \"discourse/lib/ajax-error\";\n+import getURL from \"discourse/lib/get-url\";\n+import { escapeExpression } from \"discourse/lib/utilities\";\n+import Topic from \"discourse/models/topic\";\n+import { colorToHex, contrastColor, stringToColor } from \"../lib/colors\";\n+import FullCalendar from \"./full-calendar\";\n+\n+export default class PostCalendar extends Component {\n+  @service currentUser;\n+  @service siteSettings;\n+  @service capabilities;\n+  @service postCalendar;\n+  @service router;\n+  @service store;\n+\n+  @tracked post = this.args.post;\n+\n+  @action\n+  registerPostCalendar() {\n+    this.postCalendar.registerComponent(this);\n+  }\n+\n+  @action\n+  teardownPostCalendar() {\n+    this.postCalendar.teardownComponent();\n+  }\n+\n+  @action\n+  onEventClick(info) {\n+    if (info.event.extendedProps.postUrl) {\n+      this.router.transitionTo(info.event.extendedProps.postUrl);\n+    }\n+  }\n+\n+  @action\n+  async refresh() {\n+    try {\n+      const post = await this.store.find(\"post\", this.post.id);\n+      const topic_json = await Topic.find(post.topic_id, {});\n+      const topic = Topic.create(topic_json);\n+      post.set(\"topic\", topic);\n+      this.post = post;\n+    } catch (error) {\n+      popupAjaxError(error);\n+    }\n+  }\n+\n+  get isStatic() {\n+    return this.args.options.calendarType === \"static\";\n+  }\n+\n+  get isFullDay() {\n+    return this.args.options.calendarFullDay === \"true\";\n+  }\n+\n+  get timezone() {\n+    let defaultTimezone = this.args.options.calendarDefaultTimezone;\n+    const isValidDefaultTimezone = !!moment.tz.zone(\n+      this.calendarDefaultTimezone\n+    );\n+\n+    if (!isValidDefaultTimezone) {\n+      defaultTimezone = null;\n+    }\n+\n+    return defaultTimezone || this.currentUser?.timezone || moment.tz.guess();\n+  }\n+\n+  get events() {\n+    const events = [];\n+\n+    if (this.isStatic) {\n+      events.push(...(this.args.staticEvents ?? []));\n+    } else {\n+      events.push(...(this.dynamicEvents ?? []));\n+    }\n+\n+    return events;\n+  }\n+\n+  get dynamicEvents() {\n+    const events = [];\n+    const groupedEvents = [];\n+\n+    (this.post.calendar_details || []).forEach((detail) => {\n+      switch (detail.type) {\n+        case \"grouped\":\n+          if (this.isFullDay && detail.timezone) {\n+            detail.from = moment\n+              .tz(detail.from, detail.timezone)\n+              .format(\"YYYY-MM-DD\");\n+          }\n+          groupedEvents.push(detail);\n+          break;\n+        case \"standalone\":\n+          if (this.isFullDay && detail.timezone) {\n+            const eventDetail = { ...detail };\n+            let from = moment.tz(detail.from, detail.timezone);\n+            let to = moment.tz(detail.to, detail.timezone);\n+            eventDetail.from = from.format(\"YYYY-MM-DD\");\n+            eventDetail.to = to.format(\"YYYY-MM-DD\");\n+            events.push(this._buildStandaloneEvent(eventDetail));\n+          } else {\n+            events.push(this._buildStandaloneEvent(detail));\n+          }\n+          break;\n+      }\n+    });\n+\n+    const formattedGroupedEvents = {};\n+    groupedEvents.forEach((groupedEvent) => {\n+      const minDate = this.isFullDay\n+        ? moment(groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.from).utc().startOf(\"day\").toISOString();\n+      const maxDate = this.isFullDay\n+        ? moment(groupedEvent.to || groupedEvent.from).format(\"YYYY-MM-DD\")\n+        : moment(groupedEvent.to || groupedEvent.from)\n+            .utc()\n+            .endOf(\"day\")\n+            .toISOString();\n+\n+      const identifier = `${minDate}-${maxDate}`;\n+      formattedGroupedEvents[identifier] = formattedGroupedEvents[\n+        identifier\n+      ] || {\n+        from: minDate,\n+        to: maxDate || minDate,\n+        localEvents: {},\n+      };\n+\n+      formattedGroupedEvents[identifier].localEvents[groupedEvent.name] =\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name] || {\n+          users: [],\n+        };\n+\n+      formattedGroupedEvents[identifier].localEvents[\n+        groupedEvent.name\n+      ].users.push.apply(\n+        formattedGroupedEvents[identifier].localEvents[groupedEvent.name].users,\n+        groupedEvent.users\n+      );\n+    });\n+\n+    Object.keys(formattedGroupedEvents).forEach((key) => {\n+      const formattedGroupedEvent = formattedGroupedEvents[key];\n+      this._buildGroupedEvents(formattedGroupedEvent).forEach((event) => {\n+        events.push(event);\n+      });\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildEvent(detail) {\n+    const event = this._buildEventObject(\n+      detail.from\n+        ? {\n+            dateTime: moment(detail.from),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null,\n+      detail.to\n+        ? {\n+            dateTime: moment(detail.to),\n+            weeklyRecurring: detail.recurring === \"1.weeks\",\n+          }\n+        : null\n+    );\n+\n+    event.extendedProps = {};\n+    if (detail.post_url) {\n+      event.extendedProps.postUrl = getURL(detail.post_url);\n+    } else if (detail.post_number) {\n+      event.extendedProps.postNumber = detail.post_number;\n+    } else {\n+      event.classNames = [\"holiday\"];\n+    }\n+\n+    if (detail.timezoneOffset) {\n+      event.extendedProps.timezoneOffset = detail.timezoneOffset;\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildEventObject(from, to) {\n+    const hasTimeSpecified = (d) => {\n+      if (!d) {\n+        return false;\n+      }\n+      return d.hours() !== 0 || d.minutes() !== 0 || d.seconds() !== 0;\n+    };\n+\n+    const hasTime =\n+      hasTimeSpecified(to?.dateTime) || hasTimeSpecified(from?.dateTime);\n+    const dateFormat = hasTime ? \"YYYY-MM-DD HH:mm:ssZ\" : \"YYYY-MM-DD\";\n+\n+    let event = {\n+      start: from.dateTime.format(dateFormat),\n+      allDay: false,\n+    };\n+\n+    if (to) {\n+      if (hasTime) {\n+        event.end = to.dateTime.format(dateFormat);\n+      } else {\n+        event.end = to.dateTime.add(1, \"days\").format(dateFormat);\n+        event.allDay = true;\n+      }\n+    } else {\n+      event.allDay = true;\n+    }\n+\n+    if (from.weeklyRecurring) {\n+      event.startTime = {\n+        hours: from.dateTime.hours(),\n+        minutes: from.dateTime.minutes(),\n+        seconds: from.dateTime.seconds(),\n+      };\n+      event.daysOfWeek = [from.dateTime.day()];\n+    }\n+\n+    return event;\n+  }\n+\n+  _buildGroupedEvents(detail) {\n+    const events = [];\n+    const groupedEventData = [detail];\n+\n+    groupedEventData.forEach((eventData) => {\n+      let htmlContent = \"\";\n+      let users = [];\n+      let localEventNames = [];\n+\n+      Object.keys(eventData.localEvents)\n+        .sort()\n+        .forEach((key) => {\n+          const localEvent = eventData.localEvents[key];\n+          htmlContent += `<b>${key}</b>: ${localEvent.users\n+            .map((u) => u.username)\n+            .sort()\n+            .join(\", \")}<br>`;\n+          users = users.concat(localEvent.users);\n+          localEventNames.push(key);\n+        });\n+\n+      const event = this._buildEvent(eventData);\n+      event.classNames = [\"grouped-event\"];\n+\n+      if (users.length > 2) {\n+        event.title = `(${users.length}) ${localEventNames[0]}`;\n+      } else if (users.length === 1) {\n+        event.title = users[0].username;\n+      } else {\n+        event.title = !this.capabilities.viewport.sm\n+          ? `(${users.length}) ${localEventNames[0]}`\n+          : `(${users.length}) ` + users.map((u) => u.username).join(\", \");\n+      }\n+\n+      if (localEventNames.length > 1) {\n+        event.extendedProps.htmlContent = htmlContent;\n+      } else {\n+        if (users.length > 1) {\n+          event.extendedProps.htmlContent = htmlContent;\n+        } else {\n+          event.extendedProps.htmlContent = localEventNames[0];\n+        }\n+      }\n+\n+      event.participantCount = users.length;\n+      events.push(event);\n+    });\n+\n+    return events;\n+  }\n+\n+  _buildStandaloneEvent(detail) {",
        "comment_created_at": "2025-08-19T05:18:10+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "```suggestion\r\n  #buildStandaloneEvent(detail) {\r\n```\r\n\r\nShould use native private, dev-xp wants this now not the fake `_` one",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2281544180",
    "pr_number": 34352,
    "pr_file": "plugins/discourse-subscriptions/assets/javascripts/discourse/templates/admin/plugins-discourse-subscriptions-products-show-plans-show.gjs",
    "created_at": "2025-08-18T07:36:03+00:00",
    "commented_code": "</label>\n \n           {{#if @controller.planFieldDisabled}}\n-            <Input disabled={{true}} @value={{@controller.selectedInterval}} />\n+            <input\n+              disabled={{true}}",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2281544180",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34352,
        "pr_file": "plugins/discourse-subscriptions/assets/javascripts/discourse/templates/admin/plugins-discourse-subscriptions-products-show-plans-show.gjs",
        "discussion_id": "2281544180",
        "commented_code": "@@ -115,7 +129,11 @@ export default RouteTemplate(\n           </label>\n \n           {{#if @controller.planFieldDisabled}}\n-            <Input disabled={{true}} @value={{@controller.selectedInterval}} />\n+            <input\n+              disabled={{true}}",
        "comment_created_at": "2025-08-18T07:36:03+00:00",
        "comment_author": "CvX",
        "comment_body": "those can/should be updated to the \"proper\" boolean attribute syntax:\r\n\r\n```suggestion\r\n              disabled\r\n```\r\n\r\nThis syntax worked already with the `Input` component. Most of those were just leftovers from old code that went through multiple semi-automated refactors (or just cargo-culted from those places into new code \ud83d\ude03)\r\n\r\nthis can be done in another PR if you want, then you could replace **all of it** at once \ud83d\ude03 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2273453999",
    "pr_number": 34289,
    "pr_file": "app/assets/javascripts/admin/addon/components/color-input.gjs",
    "created_at": "2025-08-13T13:20:25+00:00",
    "commented_code": "this.set(\"hexValue\", event.target.value.replace(\"#\", \"\"));\n   }\n \n+  @action\n+  handleBlur() {\n+    if (this.onBlur) {\n+      this.onBlur(this.normalize(this.hexValue));\n+    }",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2273453999",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34289,
        "pr_file": "app/assets/javascripts/admin/addon/components/color-input.gjs",
        "discussion_id": "2273453999",
        "commented_code": "@@ -54,6 +59,13 @@ export default class ColorInput extends Component {\n     this.set(\"hexValue\", event.target.value.replace(\"#\", \"\"));\n   }\n \n+  @action\n+  handleBlur() {\n+    if (this.onBlur) {\n+      this.onBlur(this.normalize(this.hexValue));\n+    }",
        "comment_created_at": "2025-08-13T13:20:25+00:00",
        "comment_author": "CvX",
        "comment_body": "\ud83c\udfcc\ufe0f\u200d\u2642\ufe0f \r\n```suggestion\r\n    this.onBlur?.(this.normalize(this.hexValue));\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2218076374",
    "pr_number": 33614,
    "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-tips.gjs",
    "created_at": "2025-07-21T02:14:40+00:00",
    "commented_code": "+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { fn } from \"@ember/helper\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import { cancel, debounce, later } from \"@ember/runloop\";\n+import { service } from \"@ember/service\";\n+import { and, eq } from \"truth-helpers\";\n+import DButton from \"discourse/components/d-button\";\n+import concatClass from \"discourse/helpers/concat-class\";\n+import { ajax } from \"discourse/lib/ajax\";\n+import { i18n } from \"discourse-i18n\";\n+\n+const MAX_RESULTS = 20;\n+\n+export default class FilterTips extends Component {\n+  @service currentUser;\n+  @service site;\n+\n+  @tracked showTips = false;\n+  @tracked currentInputValue = \"\";\n+  @tracked searchResults = [];\n+\n+  activeFilter = null;\n+  searchTimer = null;\n+  handleBlurTimer = null;\n+\n+  @tracked _selectedIndex = -1;\n+\n+  willDestroy() {\n+    super.willDestroy(...arguments);\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n+      this.searchTimer = null;\n+    }\n+\n+    if (this.handleBlurTimer) {\n+      cancel(this.handleBlurTimer);\n+      this.handleBlurTimer = null;\n+    }\n+    if (this.inputElement) {\n+      this.inputElement.removeEventListener(\"focus\", this.handleInputFocus);\n+      this.inputElement.removeEventListener(\"blur\", this.handleInputBlur);\n+      this.inputElement.removeEventListener(\"keydown\", this.handleKeyDown);\n+      this.inputElement.removeEventListener(\"input\", this.handleInput);\n+    }\n+  }\n+\n+  get selectedIndex() {\n+    return this._selectedIndex;\n+  }\n+\n+  set selectedIndex(value) {\n+    this._selectedIndex = value;\n+    this.args.blockEnterSubmit(value !== -1);\n+  }\n+\n+  get currentItems() {\n+    return this.filteredTips;\n+  }\n+\n+  get filteredTips() {\n+    if (!this.args.tips) {\n+      return [];\n+    }\n+\n+    const words = this.currentInputValue.split(/\\s+/);\n+    const lastWord = words[words.length - 1].toLowerCase();",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2218076374",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33614,
        "pr_file": "app/assets/javascripts/discourse/app/components/discovery/filter-tips.gjs",
        "discussion_id": "2218076374",
        "commented_code": "@@ -0,0 +1,552 @@\n+import Component from \"@glimmer/component\";\n+import { tracked } from \"@glimmer/tracking\";\n+import { fn } from \"@ember/helper\";\n+import { action } from \"@ember/object\";\n+import didInsert from \"@ember/render-modifiers/modifiers/did-insert\";\n+import { cancel, debounce, later } from \"@ember/runloop\";\n+import { service } from \"@ember/service\";\n+import { and, eq } from \"truth-helpers\";\n+import DButton from \"discourse/components/d-button\";\n+import concatClass from \"discourse/helpers/concat-class\";\n+import { ajax } from \"discourse/lib/ajax\";\n+import { i18n } from \"discourse-i18n\";\n+\n+const MAX_RESULTS = 20;\n+\n+export default class FilterTips extends Component {\n+  @service currentUser;\n+  @service site;\n+\n+  @tracked showTips = false;\n+  @tracked currentInputValue = \"\";\n+  @tracked searchResults = [];\n+\n+  activeFilter = null;\n+  searchTimer = null;\n+  handleBlurTimer = null;\n+\n+  @tracked _selectedIndex = -1;\n+\n+  willDestroy() {\n+    super.willDestroy(...arguments);\n+    if (this.searchTimer) {\n+      cancel(this.searchTimer);\n+      this.searchTimer = null;\n+    }\n+\n+    if (this.handleBlurTimer) {\n+      cancel(this.handleBlurTimer);\n+      this.handleBlurTimer = null;\n+    }\n+    if (this.inputElement) {\n+      this.inputElement.removeEventListener(\"focus\", this.handleInputFocus);\n+      this.inputElement.removeEventListener(\"blur\", this.handleInputBlur);\n+      this.inputElement.removeEventListener(\"keydown\", this.handleKeyDown);\n+      this.inputElement.removeEventListener(\"input\", this.handleInput);\n+    }\n+  }\n+\n+  get selectedIndex() {\n+    return this._selectedIndex;\n+  }\n+\n+  set selectedIndex(value) {\n+    this._selectedIndex = value;\n+    this.args.blockEnterSubmit(value !== -1);\n+  }\n+\n+  get currentItems() {\n+    return this.filteredTips;\n+  }\n+\n+  get filteredTips() {\n+    if (!this.args.tips) {\n+      return [];\n+    }\n+\n+    const words = this.currentInputValue.split(/\\s+/);\n+    const lastWord = words[words.length - 1].toLowerCase();",
        "comment_created_at": "2025-07-21T02:14:40+00:00",
        "comment_author": "martin-brennan",
        "comment_body": "In JS land you can now do this fanciness like ruby :) \r\n\r\n```suggestion\r\n    const lastWord = words.at(-1).toLowerCase();\r\n```",
        "pr_file_module": null
      }
    ]
  }
]