[
  {
    "discussion_id": "2286119224",
    "pr_number": 33984,
    "pr_file": "migrations/lib/importer/steps/base/tags.rb",
    "created_at": "2025-08-19T19:14:35+00:00",
    "commented_code": "+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps::Base\n+  class Tags < ::Migrations::Importer::CopyStep\n+    include ::HasSanitizableFields\n+\n+    MAX_DESCRIPTION_LENGTH = 1000\n+    RESERVED_TAGS = Tag::RESERVED_TAGS.to_set.freeze\n+\n+    class << self\n+      def inherited(klass)\n+        super\n+\n+        klass.requires_mapping :existing_tag_by_name, \"SELECT LOWER(name), id FROM tags\"\n+        klass.table_name :tags\n+        klass.column_names %i[id name description target_tag_id created_at updated_at]\n+        klass.store_mapped_ids true\n+      end\n+    end\n+\n+    def execute\n+      max_tag_length = @intermediate_db.query_value(\"SELECT MAX(LENGTH(name)) FROM tags\") || 0\n+      SiteSetting.max_tag_length = max_tag_length if SiteSetting.max_tag_length < max_tag_length\n+\n+      load_validation_caches\n+\n+      super\n+    end\n+\n+    def load_validation_caches\n+      # Override in subclasses if needed\n+    end\n+\n+    def apply_transforms(row)\n+      # Override in subclasses if needed\n+      row\n+    end\n+\n+    private\n+\n+    def transform_row(row)\n+      cleaned_name = DiscourseTagging.clean_tag(row[:name])\n+      name_lower = cleaned_name.downcase\n+      existing_id = row[:id] = @existing_tag_by_name[name_lower]\n+\n+      return nil if existing_id\n+\n+      if !existing_id && RESERVED_TAGS.include?(name_lower)\n+        puts \"    Tag '#{cleaned_name}' is reserved\"\n+\n+        return nil\n+      end\n+\n+      row[:name] = cleaned_name\n+      row[:description] = sanitize_field(row[:description])[0...MAX_DESCRIPTION_LENGTH] if row[\n+        :description\n+      ]",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2286119224",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33984,
        "pr_file": "migrations/lib/importer/steps/base/tags.rb",
        "discussion_id": "2286119224",
        "commented_code": "@@ -0,0 +1,64 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps::Base\n+  class Tags < ::Migrations::Importer::CopyStep\n+    include ::HasSanitizableFields\n+\n+    MAX_DESCRIPTION_LENGTH = 1000\n+    RESERVED_TAGS = Tag::RESERVED_TAGS.to_set.freeze\n+\n+    class << self\n+      def inherited(klass)\n+        super\n+\n+        klass.requires_mapping :existing_tag_by_name, \"SELECT LOWER(name), id FROM tags\"\n+        klass.table_name :tags\n+        klass.column_names %i[id name description target_tag_id created_at updated_at]\n+        klass.store_mapped_ids true\n+      end\n+    end\n+\n+    def execute\n+      max_tag_length = @intermediate_db.query_value(\"SELECT MAX(LENGTH(name)) FROM tags\") || 0\n+      SiteSetting.max_tag_length = max_tag_length if SiteSetting.max_tag_length < max_tag_length\n+\n+      load_validation_caches\n+\n+      super\n+    end\n+\n+    def load_validation_caches\n+      # Override in subclasses if needed\n+    end\n+\n+    def apply_transforms(row)\n+      # Override in subclasses if needed\n+      row\n+    end\n+\n+    private\n+\n+    def transform_row(row)\n+      cleaned_name = DiscourseTagging.clean_tag(row[:name])\n+      name_lower = cleaned_name.downcase\n+      existing_id = row[:id] = @existing_tag_by_name[name_lower]\n+\n+      return nil if existing_id\n+\n+      if !existing_id && RESERVED_TAGS.include?(name_lower)\n+        puts \"    Tag '#{cleaned_name}' is reserved\"\n+\n+        return nil\n+      end\n+\n+      row[:name] = cleaned_name\n+      row[:description] = sanitize_field(row[:description])[0...MAX_DESCRIPTION_LENGTH] if row[\n+        :description\n+      ]",
        "comment_created_at": "2025-08-19T19:14:35+00:00",
        "comment_author": "gschlager",
        "comment_body": "Nitpick: `sanitize_field` is null-safe, so you could make it easier to read by using this.\n\n```suggestion\n      row[:description] = sanitize_field(row[:description])&.slice(0, MAX_DESCRIPTION_LENGTH)\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2290714734",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33984,
        "pr_file": "migrations/lib/importer/steps/base/tags.rb",
        "discussion_id": "2286119224",
        "commented_code": "@@ -0,0 +1,64 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps::Base\n+  class Tags < ::Migrations::Importer::CopyStep\n+    include ::HasSanitizableFields\n+\n+    MAX_DESCRIPTION_LENGTH = 1000\n+    RESERVED_TAGS = Tag::RESERVED_TAGS.to_set.freeze\n+\n+    class << self\n+      def inherited(klass)\n+        super\n+\n+        klass.requires_mapping :existing_tag_by_name, \"SELECT LOWER(name), id FROM tags\"\n+        klass.table_name :tags\n+        klass.column_names %i[id name description target_tag_id created_at updated_at]\n+        klass.store_mapped_ids true\n+      end\n+    end\n+\n+    def execute\n+      max_tag_length = @intermediate_db.query_value(\"SELECT MAX(LENGTH(name)) FROM tags\") || 0\n+      SiteSetting.max_tag_length = max_tag_length if SiteSetting.max_tag_length < max_tag_length\n+\n+      load_validation_caches\n+\n+      super\n+    end\n+\n+    def load_validation_caches\n+      # Override in subclasses if needed\n+    end\n+\n+    def apply_transforms(row)\n+      # Override in subclasses if needed\n+      row\n+    end\n+\n+    private\n+\n+    def transform_row(row)\n+      cleaned_name = DiscourseTagging.clean_tag(row[:name])\n+      name_lower = cleaned_name.downcase\n+      existing_id = row[:id] = @existing_tag_by_name[name_lower]\n+\n+      return nil if existing_id\n+\n+      if !existing_id && RESERVED_TAGS.include?(name_lower)\n+        puts \"    Tag '#{cleaned_name}' is reserved\"\n+\n+        return nil\n+      end\n+\n+      row[:name] = cleaned_name\n+      row[:description] = sanitize_field(row[:description])[0...MAX_DESCRIPTION_LENGTH] if row[\n+        :description\n+      ]",
        "comment_created_at": "2025-08-21T11:15:31+00:00",
        "comment_author": "s3lase",
        "comment_body": "Sure! I noticed you switched the slicing operation to slice`(0, MAX_DESCRIPTION_LENGTH)`. I realized slicing with a range `([0...MAX_DESCRIPTION_LENGTH])` was slower and  that `[0, MAX_DESCRIPTION_LENGTH]`  is even a tiny bit faster than `slice(0, MAX_DESCRIPTION_LENGTH)`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2291975589",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33984,
        "pr_file": "migrations/lib/importer/steps/base/tags.rb",
        "discussion_id": "2286119224",
        "commented_code": "@@ -0,0 +1,64 @@\n+# frozen_string_literal: true\n+\n+module Migrations::Importer::Steps::Base\n+  class Tags < ::Migrations::Importer::CopyStep\n+    include ::HasSanitizableFields\n+\n+    MAX_DESCRIPTION_LENGTH = 1000\n+    RESERVED_TAGS = Tag::RESERVED_TAGS.to_set.freeze\n+\n+    class << self\n+      def inherited(klass)\n+        super\n+\n+        klass.requires_mapping :existing_tag_by_name, \"SELECT LOWER(name), id FROM tags\"\n+        klass.table_name :tags\n+        klass.column_names %i[id name description target_tag_id created_at updated_at]\n+        klass.store_mapped_ids true\n+      end\n+    end\n+\n+    def execute\n+      max_tag_length = @intermediate_db.query_value(\"SELECT MAX(LENGTH(name)) FROM tags\") || 0\n+      SiteSetting.max_tag_length = max_tag_length if SiteSetting.max_tag_length < max_tag_length\n+\n+      load_validation_caches\n+\n+      super\n+    end\n+\n+    def load_validation_caches\n+      # Override in subclasses if needed\n+    end\n+\n+    def apply_transforms(row)\n+      # Override in subclasses if needed\n+      row\n+    end\n+\n+    private\n+\n+    def transform_row(row)\n+      cleaned_name = DiscourseTagging.clean_tag(row[:name])\n+      name_lower = cleaned_name.downcase\n+      existing_id = row[:id] = @existing_tag_by_name[name_lower]\n+\n+      return nil if existing_id\n+\n+      if !existing_id && RESERVED_TAGS.include?(name_lower)\n+        puts \"    Tag '#{cleaned_name}' is reserved\"\n+\n+        return nil\n+      end\n+\n+      row[:name] = cleaned_name\n+      row[:description] = sanitize_field(row[:description])[0...MAX_DESCRIPTION_LENGTH] if row[\n+        :description\n+      ]",
        "comment_created_at": "2025-08-21T19:44:11+00:00",
        "comment_author": "gschlager",
        "comment_body": "`slice` and `[]` should have the same performance, but `slice` can be used with the `&.` operator. That's why I chose it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2157982799",
    "pr_number": 33283,
    "pr_file": "app/serializers/flag_serializer.rb",
    "created_at": "2025-06-20T03:42:53+00:00",
    "commented_code": "end\n \n   def is_used\n-    @options[:used_flag_ids].include?(object.id)\n+    @options[:used_flag_ids]&.include?(object.id) || object.used?",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2157982799",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33283,
        "pr_file": "app/serializers/flag_serializer.rb",
        "discussion_id": "2157982799",
        "commented_code": "@@ -42,7 +42,7 @@ def is_flag\n   end\n \n   def is_used\n-    @options[:used_flag_ids].include?(object.id)\n+    @options[:used_flag_ids]&.include?(object.id) || object.used?",
        "comment_created_at": "2025-06-20T03:42:53+00:00",
        "comment_author": "tgxworld",
        "comment_body": "serializers should continue to work even if custom options are not passed in.",
        "pr_file_module": null
      }
    ]
  }
]