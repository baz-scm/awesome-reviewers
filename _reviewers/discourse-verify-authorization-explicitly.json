[
  {
    "discussion_id": "2281244803",
    "pr_number": 34213,
    "pr_file": "app/models/user_auth_token.rb",
    "created_at": "2025-08-18T03:59:20+00:00",
    "commented_code": ")\n   end\n \n+  def user\n+    impersonated_user || super\n+  end\n+\n+  def impersonated_user\n+    return if impersonated_user_id.blank?\n+    return if impersonation_expires_at.blank? || impersonation_expires_at.past?\n+\n+    User.find_by(id: impersonated_user_id).tap { |u| u.is_impersonating = true }",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2281244803",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34213,
        "pr_file": "app/models/user_auth_token.rb",
        "discussion_id": "2281244803",
        "commented_code": "@@ -26,6 +26,17 @@ class UserAuthToken < ActiveRecord::Base\n     )\n   end\n \n+  def user\n+    impersonated_user || super\n+  end\n+\n+  def impersonated_user\n+    return if impersonated_user_id.blank?\n+    return if impersonation_expires_at.blank? || impersonation_expires_at.past?\n+\n+    User.find_by(id: impersonated_user_id).tap { |u| u.is_impersonating = true }",
        "comment_created_at": "2025-08-18T03:59:20+00:00",
        "comment_author": "tgxworld",
        "comment_body": "I do wonder if we should also add the `can_impersonate` guardian check here since there is technically a 15 mins window where the user associated to `impersonated_user_id` can be made an admin or is marked as a developer.",
        "pr_file_module": null
      },
      {
        "comment_id": "2281627195",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34213,
        "pr_file": "app/models/user_auth_token.rb",
        "discussion_id": "2281244803",
        "commented_code": "@@ -26,6 +26,17 @@ class UserAuthToken < ActiveRecord::Base\n     )\n   end\n \n+  def user\n+    impersonated_user || super\n+  end\n+\n+  def impersonated_user\n+    return if impersonated_user_id.blank?\n+    return if impersonation_expires_at.blank? || impersonation_expires_at.past?\n+\n+    User.find_by(id: impersonated_user_id).tap { |u| u.is_impersonating = true }",
        "comment_created_at": "2025-08-18T08:12:47+00:00",
        "comment_author": "Drenmi",
        "comment_body": "There's actually a lot of edge cases that exist both with the old and new implementation, e.g. what happens if the impersonated user is suspended. Maybe adding the check here would be a good catch-all.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2286959347",
    "pr_number": 34213,
    "pr_file": "spec/requests/admin/impersonate_controller_spec.rb",
    "created_at": "2025-08-20T04:37:18+00:00",
    "commented_code": "end\n     end\n   end\n+\n+  describe \"#destroy\" do\n+    before { sign_in(admin) }",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2286959347",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34213,
        "pr_file": "spec/requests/admin/impersonate_controller_spec.rb",
        "discussion_id": "2286959347",
        "commented_code": "@@ -106,4 +118,34 @@\n       end\n     end\n   end\n+\n+  describe \"#destroy\" do\n+    before { sign_in(admin) }",
        "comment_created_at": "2025-08-20T04:37:18+00:00",
        "comment_author": "tgxworld",
        "comment_body": "We technically don't need to use an admin user because the controller action bypasses the `ensure_admin` before action. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2287154480",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34213,
        "pr_file": "spec/requests/admin/impersonate_controller_spec.rb",
        "discussion_id": "2286959347",
        "commented_code": "@@ -106,4 +118,34 @@\n       end\n     end\n   end\n+\n+  describe \"#destroy\" do\n+    before { sign_in(admin) }",
        "comment_created_at": "2025-08-20T06:47:36+00:00",
        "comment_author": "Drenmi",
        "comment_body": "One test will fail, because we need a `current_user` instance where we can stub `is_impersonating` to pass the routing constraint.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2283383479",
    "pr_number": 34391,
    "pr_file": "plugins/discourse-ai/lib/ai_moderation/spam_scanner.rb",
    "created_at": "2025-08-18T20:25:13+00:00",
    "commented_code": "return if !should_scan_post?(post)\n         return if scanned_max_times?(post)\n \n+        editor = post.last_editor\n+        return if editor && (editor.staff? || editor.bot?)",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2283383479",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34391,
        "pr_file": "plugins/discourse-ai/lib/ai_moderation/spam_scanner.rb",
        "discussion_id": "2283383479",
        "commented_code": "@@ -83,6 +83,9 @@ def self.edited_post(post)\n         return if !should_scan_post?(post)\n         return if scanned_max_times?(post)\n \n+        editor = post.last_editor\n+        return if editor && (editor.staff? || editor.bot?)",
        "comment_created_at": "2025-08-18T20:25:13+00:00",
        "comment_author": "pmusaraj",
        "comment_body": "The `bot` edit skip makes sense because the spam scanner would be invoked after every bot edit, yes? Curious which other bot users edit posts. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2283453416",
        "repo_full_name": "discourse/discourse",
        "pr_number": 34391,
        "pr_file": "plugins/discourse-ai/lib/ai_moderation/spam_scanner.rb",
        "discussion_id": "2283383479",
        "commented_code": "@@ -83,6 +83,9 @@ def self.edited_post(post)\n         return if !should_scan_post?(post)\n         return if scanned_max_times?(post)\n \n+        editor = post.last_editor\n+        return if editor && (editor.staff? || editor.bot?)",
        "comment_created_at": "2025-08-18T20:59:33+00:00",
        "comment_author": "romanrizzi",
        "comment_body": "It's only invoked if a bot changes the post's content or topic title. I assumed it was safe to trust bot edits, but happy to remove if not.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1122531511",
    "pr_number": 20494,
    "pr_file": "spec/requests/list_controller_spec.rb",
    "created_at": "2023-03-02T02:18:34+00:00",
    "commented_code": "expect(parsed[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(welcome_topic.id)\n     end\n   end\n+\n+  describe \"#filter\" do\n+    it \"should respond with 403 response code for an anonymous user\" do",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "1122531511",
        "repo_full_name": "discourse/discourse",
        "pr_number": 20494,
        "pr_file": "spec/requests/list_controller_spec.rb",
        "discussion_id": "1122531511",
        "commented_code": "@@ -1084,4 +1084,21 @@\n       expect(parsed[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(welcome_topic.id)\n     end\n   end\n+\n+  describe \"#filter\" do\n+    it \"should respond with 403 response code for an anonymous user\" do",
        "comment_created_at": "2023-03-02T02:18:34+00:00",
        "comment_author": "lis2",
        "comment_body": "To fully test that 403 is because anonymous - should we set SiteSetting.experimental_topics_filter to true?",
        "pr_file_module": null
      },
      {
        "comment_id": "1123899254",
        "repo_full_name": "discourse/discourse",
        "pr_number": 20494,
        "pr_file": "spec/requests/list_controller_spec.rb",
        "discussion_id": "1122531511",
        "commented_code": "@@ -1084,4 +1084,21 @@\n       expect(parsed[\"topic_list\"][\"topics\"].first[\"id\"]).to eq(welcome_topic.id)\n     end\n   end\n+\n+  describe \"#filter\" do\n+    it \"should respond with 403 response code for an anonymous user\" do",
        "comment_created_at": "2023-03-03T00:16:34+00:00",
        "comment_author": "tgxworld",
        "comment_body": "Good point :+1: Let me add that. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2230278282",
    "pr_number": 33853,
    "pr_file": "plugins/discourse-ai/spec/system/ai_bot/homepage_spec.rb",
    "created_at": "2025-07-25T06:38:49+00:00",
    "commented_code": "expect(sidebar).to have_section_link(pm.title)\n         end\n \n+        it \"allows navigating to a specific LLM and persona\" do\n+          # url encode name\n+          persona_name = CGI.escape(persona.name)\n+          llm_name = CGI.escape(claude_2_dup.display_name)\n+          visit \"/discourse-ai/ai-bot/conversations?persona=#{persona_name}&llm=#{llm_name}\"\n+\n+          expect(ai_pm_homepage.persona_selector).to have_selected_name(persona.name)\n+          expect(ai_pm_homepage.llm_selector).to have_selected_name(claude_2_dup.display_name)",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2230278282",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33853,
        "pr_file": "plugins/discourse-ai/spec/system/ai_bot/homepage_spec.rb",
        "discussion_id": "2230278282",
        "commented_code": "@@ -246,6 +246,30 @@\n           expect(sidebar).to have_section_link(pm.title)\n         end\n \n+        it \"allows navigating to a specific LLM and persona\" do\n+          # url encode name\n+          persona_name = CGI.escape(persona.name)\n+          llm_name = CGI.escape(claude_2_dup.display_name)\n+          visit \"/discourse-ai/ai-bot/conversations?persona=#{persona_name}&llm=#{llm_name}\"\n+\n+          expect(ai_pm_homepage.persona_selector).to have_selected_name(persona.name)\n+          expect(ai_pm_homepage.llm_selector).to have_selected_name(claude_2_dup.display_name)",
        "comment_created_at": "2025-07-25T06:38:49+00:00",
        "comment_author": "nattsw",
        "comment_body": "Please confirm ... \r\n- an invalid query param (e.g. bad/updated persona name) will fail safely?\r\n- unauthorized user will not gain access",
        "pr_file_module": null
      },
      {
        "comment_id": "2230288642",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33853,
        "pr_file": "plugins/discourse-ai/spec/system/ai_bot/homepage_spec.rb",
        "discussion_id": "2230278282",
        "commented_code": "@@ -246,6 +246,30 @@\n           expect(sidebar).to have_section_link(pm.title)\n         end\n \n+        it \"allows navigating to a specific LLM and persona\" do\n+          # url encode name\n+          persona_name = CGI.escape(persona.name)\n+          llm_name = CGI.escape(claude_2_dup.display_name)\n+          visit \"/discourse-ai/ai-bot/conversations?persona=#{persona_name}&llm=#{llm_name}\"\n+\n+          expect(ai_pm_homepage.persona_selector).to have_selected_name(persona.name)\n+          expect(ai_pm_homepage.llm_selector).to have_selected_name(claude_2_dup.display_name)",
        "comment_created_at": "2025-07-25T06:45:24+00:00",
        "comment_author": "SamSaffron",
        "comment_body": "Yeah it is not trusted should demo in a test ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2192863222",
    "pr_number": 33521,
    "pr_file": "app/controllers/session_controller.rb",
    "created_at": "2025-07-08T15:40:46+00:00",
    "commented_code": "def email_login\n     token = params[:token]\n-    matched_token = EmailToken.confirmable(token, scope: EmailToken.scopes[:email_login])\n-    user = matched_token&.user\n+    user = EmailToken.confirmable(token, scope: EmailToken.scopes[:email_login])&.user\n \n     check_local_login_allowed(user: user, check_login_via_email: true)\n-\n     rate_limit_second_factor!(user)\n \n     if user.present? && !authenticate_second_factor(user).ok\n       return render(json: @second_factor_failure_payload)\n     end\n \n     if user = EmailToken.confirm(token, scope: EmailToken.scopes[:email_login])\n+      if @staff_writes_only_mode\n+        raise Discourse::ReadOnly unless user.staff?\n+      elsif @readonly_mode\n+        raise Discourse::ReadOnly unless user.admin?\n+      end",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2192863222",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33521,
        "pr_file": "app/controllers/session_controller.rb",
        "discussion_id": "2192863222",
        "commented_code": "@@ -446,24 +446,27 @@ def email_login_info\n \n   def email_login\n     token = params[:token]\n-    matched_token = EmailToken.confirmable(token, scope: EmailToken.scopes[:email_login])\n-    user = matched_token&.user\n+    user = EmailToken.confirmable(token, scope: EmailToken.scopes[:email_login])&.user\n \n     check_local_login_allowed(user: user, check_login_via_email: true)\n-\n     rate_limit_second_factor!(user)\n \n     if user.present? && !authenticate_second_factor(user).ok\n       return render(json: @second_factor_failure_payload)\n     end\n \n     if user = EmailToken.confirm(token, scope: EmailToken.scopes[:email_login])\n+      if @staff_writes_only_mode\n+        raise Discourse::ReadOnly unless user.staff?\n+      elsif @readonly_mode\n+        raise Discourse::ReadOnly unless user.admin?\n+      end",
        "comment_created_at": "2025-07-08T15:40:46+00:00",
        "comment_author": "ZogStriP",
        "comment_body": "This is another part of the \"fix\", which allows only staff members when the site is in \"staff writes only\" mode and only allow admins then the site is in \"readonly\" mode.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2165427488",
    "pr_number": 33313,
    "pr_file": "lib/guardian/user_guardian.rb",
    "created_at": "2025-06-25T02:38:24+00:00",
    "commented_code": "def can_change_tracking_preferences?(user)\n     (SiteSetting.allow_changing_staged_user_tracking || !user.staged) && can_edit_user?(user)\n   end\n+\n+  def can_create_theme?(admin)\n+    # this modifier is used to further restrict theme creation, it's not\n+    # possible to use this modifier to open up theme creation permissions (e.g.\n+    # to non-admins)\n+    DiscoursePluginRegistry.apply_modifier(:user_guardian_can_create_theme, true, admin, self)",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2165427488",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33313,
        "pr_file": "lib/guardian/user_guardian.rb",
        "discussion_id": "2165427488",
        "commented_code": "@@ -224,4 +224,11 @@ def can_delete_user_associated_accounts?(user)\n   def can_change_tracking_preferences?(user)\n     (SiteSetting.allow_changing_staged_user_tracking || !user.staged) && can_edit_user?(user)\n   end\n+\n+  def can_create_theme?(admin)\n+    # this modifier is used to further restrict theme creation, it's not\n+    # possible to use this modifier to open up theme creation permissions (e.g.\n+    # to non-admins)\n+    DiscoursePluginRegistry.apply_modifier(:user_guardian_can_create_theme, true, admin, self)",
        "comment_created_at": "2025-06-25T02:38:24+00:00",
        "comment_author": "tgxworld",
        "comment_body": "```suggestion\r\n  def can_create_theme?(user)\r\n    return false if !user.admin?\r\n    # this modifier is used to further restrict theme creation, it's not\r\n    # possible to use this modifier to open up theme creation permissions (e.g.\r\n    # to non-admins)\r\n    DiscoursePluginRegistry.apply_modifier(:user_guardian_can_create_theme, true, user, self)\r\n```\r\n\r\nI think it is better to ensure this method will always return `false` for a non admin user.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167910120",
    "pr_number": 33353,
    "pr_file": "spec/lib/search_spec.rb",
    "created_at": "2025-06-26T01:26:39+00:00",
    "commented_code": "expect(results.posts).to contain_exactly(regular_post)\n     end\n   end\n+\n+  it \"can order by read\" do\n+    user = Fabricate(:user)\n+\n+    post2 = nil\n+    freeze_time 2.hours.ago do\n+      post2 = Fabricate(:post, raw: \"Read order term\")\n+      TopicUser.update_last_read(user, post2.topic.id, post2.post_number, 1, 0)\n+    end\n+\n+    post1 = nil\n+    freeze_time 1.hour.ago do\n+      post1 = Fabricate(:post, raw: \"Read order term\")\n+      TopicUser.update_last_read(user, post1.topic.id, post1.post_number, 1, 0)\n+    end\n+\n+    _unread_post = Fabricate(:post, raw: \"Read order term\")\n+\n+    result = Search.execute(\"Read order term order:read\", guardian: Guardian.new(user))\n+    expect(result.posts.map(&:id)).to eq([post1.id, post2.id])",
    "repo_full_name": "discourse/discourse",
    "discussion_comments": [
      {
        "comment_id": "2167910120",
        "repo_full_name": "discourse/discourse",
        "pr_number": 33353,
        "pr_file": "spec/lib/search_spec.rb",
        "discussion_id": "2167910120",
        "commented_code": "@@ -3135,4 +3135,30 @@ def indexed_post(*args)\n       expect(results.posts).to contain_exactly(regular_post)\n     end\n   end\n+\n+  it \"can order by read\" do\n+    user = Fabricate(:user)\n+\n+    post2 = nil\n+    freeze_time 2.hours.ago do\n+      post2 = Fabricate(:post, raw: \"Read order term\")\n+      TopicUser.update_last_read(user, post2.topic.id, post2.post_number, 1, 0)\n+    end\n+\n+    post1 = nil\n+    freeze_time 1.hour.ago do\n+      post1 = Fabricate(:post, raw: \"Read order term\")\n+      TopicUser.update_last_read(user, post1.topic.id, post1.post_number, 1, 0)\n+    end\n+\n+    _unread_post = Fabricate(:post, raw: \"Read order term\")\n+\n+    result = Search.execute(\"Read order term order:read\", guardian: Guardian.new(user))\n+    expect(result.posts.map(&:id)).to eq([post1.id, post2.id])",
        "comment_created_at": "2025-06-26T01:26:39+00:00",
        "comment_author": "tgxworld",
        "comment_body": "I think it'll also be useful to assert that `order:read` does not apply to an anonymous user.",
        "pr_file_module": null
      }
    ]
  }
]