[
  {
    "discussion_id": "223232033",
    "pr_number": 18,
    "pr_file": "filetree/tree.go",
    "created_at": "2018-10-07T23:10:16+00:00",
    "commented_code": "return tree\n }\n \n+type renderParams struct{\n+\tnode *FileNode\n+\tspaces []bool\n+\tchildSpaces []bool\n+\tshowCollapsed bool\n+\tisLast bool\n+}\n+\n+func (tree *FileTree) renderStringTreeBetween(startRow, stopRow int, showAttributes bool) string {\n+\t// generate a list of nodes to render\n+\tvar params []renderParams = make([]renderParams,0)\n+\tvar result string\n+\n+\t// visit from the front of the list\n+\tvar paramsToVisit = []renderParams{ renderParams{node: tree.Root, spaces: []bool{}, showCollapsed: false, isLast: false} }\n+\tfor currentRow := 0; len(paramsToVisit) > 0 && currentRow <= stopRow; currentRow++ {\n+\t\t// pop the first node\n+\t\tvar currentParams renderParams\n+\t\tcurrentParams, paramsToVisit = paramsToVisit[0], paramsToVisit[1:]\n+\n+\t\t// take note of the next nodes to visit later\n+\t\tvar keys []string\n+\t\tfor key := range currentParams.node.Children {\n+\t\t\tkeys = append(keys, key)\n+\t\t}\n+\t\tsort.Strings(keys)\n+\n+\t\tvar childParams = make([]renderParams,0)\n+\t\tfor idx, name := range keys {\n+\t\t\tchild := currentParams.node.Children[name]\n+\t\t\t// don't visit this node...\n+\t\t\tif child.Data.ViewInfo.Hidden || currentParams.node.Data.ViewInfo.Collapsed {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// visit this node...\n+\t\t\tisLast := idx == (len(currentParams.node.Children) - 1)\n+\t\t\tshowCollapsed := child.Data.ViewInfo.Collapsed && len(child.Children) > 0\n+\n+\t\t\t// completely copy the reference slice\n+\t\t\tchildSpaces := make([]bool, len(currentParams.childSpaces))\n+\t\t\tcopy(childSpaces, currentParams.childSpaces)\n+\n+\t\t\tif len(child.Children) > 0 && !child.Data.ViewInfo.Collapsed {\n+\t\t\t\tchildSpaces = append(childSpaces, isLast)\n+\t\t\t}\n+\n+\t\t\tchildParams = append(childParams, renderParams{\n+\t\t\t\tnode: child,\n+\t\t\t\tspaces: currentParams.childSpaces,\n+\t\t\t\tchildSpaces: childSpaces,\n+\t\t\t\tshowCollapsed: showCollapsed,\n+\t\t\t\tisLast: isLast,\n+\t\t\t})\n+\t\t}\n+\t\t// keep the child nodes to visit later\n+\t\tparamsToVisit = append(childParams, paramsToVisit...)\n+\n+\t\t// never process the root node",
    "repo_full_name": "wagoodman/dive",
    "discussion_comments": [
      {
        "comment_id": "223232033",
        "repo_full_name": "wagoodman/dive",
        "pr_number": 18,
        "pr_file": "filetree/tree.go",
        "discussion_id": "223232033",
        "commented_code": "@@ -35,8 +36,95 @@ func NewFileTree() (tree *FileTree) {\n \treturn tree\n }\n \n+type renderParams struct{\n+\tnode *FileNode\n+\tspaces []bool\n+\tchildSpaces []bool\n+\tshowCollapsed bool\n+\tisLast bool\n+}\n+\n+func (tree *FileTree) renderStringTreeBetween(startRow, stopRow int, showAttributes bool) string {\n+\t// generate a list of nodes to render\n+\tvar params []renderParams = make([]renderParams,0)\n+\tvar result string\n+\n+\t// visit from the front of the list\n+\tvar paramsToVisit = []renderParams{ renderParams{node: tree.Root, spaces: []bool{}, showCollapsed: false, isLast: false} }\n+\tfor currentRow := 0; len(paramsToVisit) > 0 && currentRow <= stopRow; currentRow++ {\n+\t\t// pop the first node\n+\t\tvar currentParams renderParams\n+\t\tcurrentParams, paramsToVisit = paramsToVisit[0], paramsToVisit[1:]\n+\n+\t\t// take note of the next nodes to visit later\n+\t\tvar keys []string\n+\t\tfor key := range currentParams.node.Children {\n+\t\t\tkeys = append(keys, key)\n+\t\t}\n+\t\tsort.Strings(keys)\n+\n+\t\tvar childParams = make([]renderParams,0)\n+\t\tfor idx, name := range keys {\n+\t\t\tchild := currentParams.node.Children[name]\n+\t\t\t// don't visit this node...\n+\t\t\tif child.Data.ViewInfo.Hidden || currentParams.node.Data.ViewInfo.Collapsed {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// visit this node...\n+\t\t\tisLast := idx == (len(currentParams.node.Children) - 1)\n+\t\t\tshowCollapsed := child.Data.ViewInfo.Collapsed && len(child.Children) > 0\n+\n+\t\t\t// completely copy the reference slice\n+\t\t\tchildSpaces := make([]bool, len(currentParams.childSpaces))\n+\t\t\tcopy(childSpaces, currentParams.childSpaces)\n+\n+\t\t\tif len(child.Children) > 0 && !child.Data.ViewInfo.Collapsed {\n+\t\t\t\tchildSpaces = append(childSpaces, isLast)\n+\t\t\t}\n+\n+\t\t\tchildParams = append(childParams, renderParams{\n+\t\t\t\tnode: child,\n+\t\t\t\tspaces: currentParams.childSpaces,\n+\t\t\t\tchildSpaces: childSpaces,\n+\t\t\t\tshowCollapsed: showCollapsed,\n+\t\t\t\tisLast: isLast,\n+\t\t\t})\n+\t\t}\n+\t\t// keep the child nodes to visit later\n+\t\tparamsToVisit = append(childParams, paramsToVisit...)\n+\n+\t\t// never process the root node",
        "comment_created_at": "2018-10-07T23:10:16+00:00",
        "comment_author": "willmurphyscode",
        "comment_body": "I don't understand why you never process the root. Does this mean that the line `/` in the file system never shoes up in the output?",
        "pr_file_module": null
      },
      {
        "comment_id": "223232991",
        "repo_full_name": "wagoodman/dive",
        "pr_number": 18,
        "pr_file": "filetree/tree.go",
        "discussion_id": "223232033",
        "commented_code": "@@ -35,8 +36,95 @@ func NewFileTree() (tree *FileTree) {\n \treturn tree\n }\n \n+type renderParams struct{\n+\tnode *FileNode\n+\tspaces []bool\n+\tchildSpaces []bool\n+\tshowCollapsed bool\n+\tisLast bool\n+}\n+\n+func (tree *FileTree) renderStringTreeBetween(startRow, stopRow int, showAttributes bool) string {\n+\t// generate a list of nodes to render\n+\tvar params []renderParams = make([]renderParams,0)\n+\tvar result string\n+\n+\t// visit from the front of the list\n+\tvar paramsToVisit = []renderParams{ renderParams{node: tree.Root, spaces: []bool{}, showCollapsed: false, isLast: false} }\n+\tfor currentRow := 0; len(paramsToVisit) > 0 && currentRow <= stopRow; currentRow++ {\n+\t\t// pop the first node\n+\t\tvar currentParams renderParams\n+\t\tcurrentParams, paramsToVisit = paramsToVisit[0], paramsToVisit[1:]\n+\n+\t\t// take note of the next nodes to visit later\n+\t\tvar keys []string\n+\t\tfor key := range currentParams.node.Children {\n+\t\t\tkeys = append(keys, key)\n+\t\t}\n+\t\tsort.Strings(keys)\n+\n+\t\tvar childParams = make([]renderParams,0)\n+\t\tfor idx, name := range keys {\n+\t\t\tchild := currentParams.node.Children[name]\n+\t\t\t// don't visit this node...\n+\t\t\tif child.Data.ViewInfo.Hidden || currentParams.node.Data.ViewInfo.Collapsed {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// visit this node...\n+\t\t\tisLast := idx == (len(currentParams.node.Children) - 1)\n+\t\t\tshowCollapsed := child.Data.ViewInfo.Collapsed && len(child.Children) > 0\n+\n+\t\t\t// completely copy the reference slice\n+\t\t\tchildSpaces := make([]bool, len(currentParams.childSpaces))\n+\t\t\tcopy(childSpaces, currentParams.childSpaces)\n+\n+\t\t\tif len(child.Children) > 0 && !child.Data.ViewInfo.Collapsed {\n+\t\t\t\tchildSpaces = append(childSpaces, isLast)\n+\t\t\t}\n+\n+\t\t\tchildParams = append(childParams, renderParams{\n+\t\t\t\tnode: child,\n+\t\t\t\tspaces: currentParams.childSpaces,\n+\t\t\t\tchildSpaces: childSpaces,\n+\t\t\t\tshowCollapsed: showCollapsed,\n+\t\t\t\tisLast: isLast,\n+\t\t\t})\n+\t\t}\n+\t\t// keep the child nodes to visit later\n+\t\tparamsToVisit = append(childParams, paramsToVisit...)\n+\n+\t\t// never process the root node",
        "comment_created_at": "2018-10-07T23:38:40+00:00",
        "comment_author": "wagoodman",
        "comment_body": "Indeed, this is so the root dir never shows up in the filetree and we also don't have any information on it. The tar you get from the docker save command has the contents of what in the images root dir, but no info on `/` itself. I couldn't see a reason to include it in the tree other than to hide all files... so I left it out.\r\n\r\nHowever, from a data structure point of view keeping a single root node simplifies how you traverse the tree (instead of having multiple root nodes you have one, and the children are the \"real\" start to the tree).\r\n\r\nDownside is preventing weird one-off bugs :/",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "223186871",
    "pr_number": 17,
    "pr_file": "filetree/tree.go",
    "created_at": "2018-10-06T16:20:15+00:00",
    "commented_code": "type FileTree struct {\n \tRoot *FileNode\n \tSize int\n+\tFileSize int64",
    "repo_full_name": "wagoodman/dive",
    "discussion_comments": [
      {
        "comment_id": "223186871",
        "repo_full_name": "wagoodman/dive",
        "pr_number": 17,
        "pr_file": "filetree/tree.go",
        "discussion_id": "223186871",
        "commented_code": "@@ -20,6 +20,7 @@ const (\n type FileTree struct {\n \tRoot *FileNode\n \tSize int\n+\tFileSize int64",
        "comment_created_at": "2018-10-06T16:20:15+00:00",
        "comment_author": "willmurphyscode",
        "comment_body": "Should we use `uint64` here? The value can't be negative...",
        "pr_file_module": null
      },
      {
        "comment_id": "223186996",
        "repo_full_name": "wagoodman/dive",
        "pr_number": 17,
        "pr_file": "filetree/tree.go",
        "discussion_id": "223186871",
        "commented_code": "@@ -20,6 +20,7 @@ const (\n type FileTree struct {\n \tRoot *FileNode\n \tSize int\n+\tFileSize int64",
        "comment_created_at": "2018-10-06T16:24:38+00:00",
        "comment_author": "wagoodman",
        "comment_body": ":+1: ",
        "pr_file_module": null
      }
    ]
  }
]