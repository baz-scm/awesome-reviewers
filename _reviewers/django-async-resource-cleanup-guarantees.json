[
  {
    "discussion_id": "2116916765",
    "pr_number": 18408,
    "pr_file": "django/db/__init__.py",
    "created_at": "2025-05-31T00:35:47+00:00",
    "commented_code": "]\n \n connections = ConnectionHandler()\n+async_connections = AsyncConnectionHandler()\n+\n+\n+class new_connection:\n+    \"\"\"\n+    Asynchronous context manager to instantiate new async connections.\n+\n+    \"\"\"\n+\n+    def __init__(self, using=DEFAULT_DB_ALIAS):\n+        self.using = using\n+\n+    async def __aenter__(self):\n+        conn = connections.create_connection(self.using)\n+        if conn.features.supports_async is False:\n+            raise NotSupportedError(\n+                \"The database backend does not support asynchronous execution.\"\n+            )\n+\n+        self.force_rollback = False\n+        if async_connections.empty is True:\n+            if async_connections._from_testcase is True:\n+                self.force_rollback = True\n+        self.conn = conn\n+\n+        async_connections.add_connection(self.using, self.conn)\n+\n+        await self.conn.aensure_connection()\n+        if self.force_rollback is True:\n+            await self.conn.aset_autocommit(False)\n+\n+        return self.conn\n+\n+    async def __aexit__(self, exc_type, exc_value, traceback):",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2116916765",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/__init__.py",
        "discussion_id": "2116916765",
        "commented_code": "@@ -36,6 +37,50 @@\n ]\n \n connections = ConnectionHandler()\n+async_connections = AsyncConnectionHandler()\n+\n+\n+class new_connection:\n+    \"\"\"\n+    Asynchronous context manager to instantiate new async connections.\n+\n+    \"\"\"\n+\n+    def __init__(self, using=DEFAULT_DB_ALIAS):\n+        self.using = using\n+\n+    async def __aenter__(self):\n+        conn = connections.create_connection(self.using)\n+        if conn.features.supports_async is False:\n+            raise NotSupportedError(\n+                \"The database backend does not support asynchronous execution.\"\n+            )\n+\n+        self.force_rollback = False\n+        if async_connections.empty is True:\n+            if async_connections._from_testcase is True:\n+                self.force_rollback = True\n+        self.conn = conn\n+\n+        async_connections.add_connection(self.using, self.conn)\n+\n+        await self.conn.aensure_connection()\n+        if self.force_rollback is True:\n+            await self.conn.aset_autocommit(False)\n+\n+        return self.conn\n+\n+    async def __aexit__(self, exc_type, exc_value, traceback):",
        "comment_created_at": "2025-05-31T00:35:47+00:00",
        "comment_author": "Arfey",
        "comment_body": "I think I’ve found an issue with an async context manager — everything works fine until an `asyncio.CancelledError` is raised.\r\n\r\nHere's a short example to reproduce it.\r\n\r\n```python\r\nimport asyncio\r\n\r\nclass AsyncResource:\r\n    async def __aenter__(self):\r\n        print(\"Enter context\")\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc, tb):\r\n        print(\"Exiting context: start\")\r\n        await asyncio.sleep(2)\r\n        print(\"Exiting context: end\")\r\n\r\n\r\nasync def task_that_uses_resource():\r\n    async with AsyncResource():\r\n        await asyncio.sleep(1)\r\n\r\n\r\nasync def main():\r\n    task = asyncio.create_task(task_that_uses_resource())\r\n\r\n    # Let the task run a bit and then cancel it\r\n    await asyncio.sleep(1.5)\r\n    print(\"Cancelling the task...\")\r\n    task.cancel()\r\n\r\n    try:\r\n        await task\r\n    except asyncio.CancelledError:\r\n        print(\"Task was cancelled!\")\r\n\r\n\r\nasyncio.run(main())\r\n```\r\n\r\nresults\r\n\r\n```\r\nEnter context\r\nExiting context: start\r\nCancelling the task...\r\nTask was cancelled!\r\n```\r\n\r\nIt’s clear why we don’t see `Exiting context: end`, but I’m not sure how to fix it quickly. This problem can lead to a leak of connections and incorrect nesting of connections due to `pop_connection`.\r\n\r\nI'm trying to do something like that\r\n\r\n```python\r\n# use sync context manager instead\r\n@contextmanager\r\ndef independent_connection(self):\r\n    active_connection = self.all(initialized_only=True)\r\n\r\n    try:\r\n        for conn in active_connection:\r\n            del self[conn.alias]\r\n        yield\r\n    finally:\r\n        # run async code in a separate coroutine without await\r\n        asyncio.create_task(self.close_all())\r\n        for conn in active_connection:\r\n            self[conn.alias] = conn\r\n```\r\n\r\nBut it still doesn't cover every case. @fcurella, any thoughts on how we can to tackle this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2126988032",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/__init__.py",
        "discussion_id": "2116916765",
        "commented_code": "@@ -36,6 +37,50 @@\n ]\n \n connections = ConnectionHandler()\n+async_connections = AsyncConnectionHandler()\n+\n+\n+class new_connection:\n+    \"\"\"\n+    Asynchronous context manager to instantiate new async connections.\n+\n+    \"\"\"\n+\n+    def __init__(self, using=DEFAULT_DB_ALIAS):\n+        self.using = using\n+\n+    async def __aenter__(self):\n+        conn = connections.create_connection(self.using)\n+        if conn.features.supports_async is False:\n+            raise NotSupportedError(\n+                \"The database backend does not support asynchronous execution.\"\n+            )\n+\n+        self.force_rollback = False\n+        if async_connections.empty is True:\n+            if async_connections._from_testcase is True:\n+                self.force_rollback = True\n+        self.conn = conn\n+\n+        async_connections.add_connection(self.using, self.conn)\n+\n+        await self.conn.aensure_connection()\n+        if self.force_rollback is True:\n+            await self.conn.aset_autocommit(False)\n+\n+        return self.conn\n+\n+    async def __aexit__(self, exc_type, exc_value, traceback):",
        "comment_created_at": "2025-06-04T16:19:14+00:00",
        "comment_author": "fcurella",
        "comment_body": "I wonder if [shielding](https://docs.python.org/3/library/asyncio-task.html#shielding-from-cancellation) the exit logic would fix it? something like:\r\n\r\n```python\r\nfrom asyncio import shield\r\n\r\n\r\nclass new_connection:\r\n\r\n    ...\r\n\r\n    async def __aexit__(self, exc_type, exc_value, traceback):\r\n        await shield(self._aexit(exc_type, exc_value, traceback))\r\n\r\n    async def _aexit(self, exc_type, exc_value, traceback):\r\n        autocommit = await self.conn.aget_autocommit()\r\n        if autocommit is False:\r\n            if exc_type is None and self.force_rollback is False:\r\n                await self.conn.acommit()\r\n            else:\r\n                await self.conn.arollback()\r\n        await self.conn.aclose()\r\n\r\n        await async_connections.pop_connection(self.using)\r\n```\r\n\r\nCould you write a test case to expose the bug?",
        "pr_file_module": null
      },
      {
        "comment_id": "2127517054",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/__init__.py",
        "discussion_id": "2116916765",
        "commented_code": "@@ -36,6 +37,50 @@\n ]\n \n connections = ConnectionHandler()\n+async_connections = AsyncConnectionHandler()\n+\n+\n+class new_connection:\n+    \"\"\"\n+    Asynchronous context manager to instantiate new async connections.\n+\n+    \"\"\"\n+\n+    def __init__(self, using=DEFAULT_DB_ALIAS):\n+        self.using = using\n+\n+    async def __aenter__(self):\n+        conn = connections.create_connection(self.using)\n+        if conn.features.supports_async is False:\n+            raise NotSupportedError(\n+                \"The database backend does not support asynchronous execution.\"\n+            )\n+\n+        self.force_rollback = False\n+        if async_connections.empty is True:\n+            if async_connections._from_testcase is True:\n+                self.force_rollback = True\n+        self.conn = conn\n+\n+        async_connections.add_connection(self.using, self.conn)\n+\n+        await self.conn.aensure_connection()\n+        if self.force_rollback is True:\n+            await self.conn.aset_autocommit(False)\n+\n+        return self.conn\n+\n+    async def __aexit__(self, exc_type, exc_value, traceback):",
        "comment_created_at": "2025-06-04T22:01:25+00:00",
        "comment_author": "Arfey",
        "comment_body": "I'm not entirely sure. Shielding seems to help with closing the connection, but I'm concerned it might not fix issues with broken nested ordering caused by pop_connection.\r\n\r\nI'll try to write a unit test when I have some free time.",
        "pr_file_module": null
      },
      {
        "comment_id": "2130888250",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/__init__.py",
        "discussion_id": "2116916765",
        "commented_code": "@@ -36,6 +37,50 @@\n ]\n \n connections = ConnectionHandler()\n+async_connections = AsyncConnectionHandler()\n+\n+\n+class new_connection:\n+    \"\"\"\n+    Asynchronous context manager to instantiate new async connections.\n+\n+    \"\"\"\n+\n+    def __init__(self, using=DEFAULT_DB_ALIAS):\n+        self.using = using\n+\n+    async def __aenter__(self):\n+        conn = connections.create_connection(self.using)\n+        if conn.features.supports_async is False:\n+            raise NotSupportedError(\n+                \"The database backend does not support asynchronous execution.\"\n+            )\n+\n+        self.force_rollback = False\n+        if async_connections.empty is True:\n+            if async_connections._from_testcase is True:\n+                self.force_rollback = True\n+        self.conn = conn\n+\n+        async_connections.add_connection(self.using, self.conn)\n+\n+        await self.conn.aensure_connection()\n+        if self.force_rollback is True:\n+            await self.conn.aset_autocommit(False)\n+\n+        return self.conn\n+\n+    async def __aexit__(self, exc_type, exc_value, traceback):",
        "comment_created_at": "2025-06-05T23:22:13+00:00",
        "comment_author": "Arfey",
        "comment_body": "```python\r\nimport asyncio\r\n\r\nfrom django.db import new_connection, async_connections, DEFAULT_DB_ALIAS\r\nfrom django.test import TransactionTestCase, skipUnlessDBFeature\r\n\r\n\r\n\r\n@skipUnlessDBFeature(\"supports_async\")\r\nclass NestedConnectionTest(TransactionTestCase):\r\n\r\n    available_apps = [\"async\"]\r\n\r\n    async def test_nesting_error1(self):\r\n        async def aget_autocommit_new():\r\n            raise asyncio.CancelledError\r\n\r\n        async with new_connection() as conn1:\r\n            assert async_connections.count == 1\r\n            main_connection = async_connections.get_connection(DEFAULT_DB_ALIAS)\r\n\r\n            aget_autocommit_old = conn1.aget_autocommit\r\n            try:\r\n                async with new_connection() as conn2:\r\n                    assert async_connections.count == 2\r\n                    conn2.aget_autocommit = aget_autocommit_new\r\n            except:\r\n                pass\r\n\r\n            conn1.aget_autocommit = aget_autocommit_old\r\n\r\n            assert main_connection == async_connections.get_connection(DEFAULT_DB_ALIAS)\r\n            assert async_connections.count == 1\r\n\r\n```\r\n\r\nThis test contains monkey_patch, but it's clearly demonstrating the root of the problems. Is it helpful for you?\r\n\r\n```\r\n======================================================================\r\nFAIL: test_nesting_error1 (async.test_async_connections.NestedConnectionTest.test_nesting_error1)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"/Users/m.havelya/work/django/env/lib/python3.13/site-packages/asgiref/sync.py\", line 325, in __call__\r\n    return call_result.result()\r\n           ~~~~~~~~~~~~~~~~~~^^\r\n  File \"/opt/homebrew/Cellar/python@3.13/3.13.1/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py\", line 449, in result\r\n    return self.__get_result()\r\n           ~~~~~~~~~~~~~~~~~^^\r\n  File \"/opt/homebrew/Cellar/python@3.13/3.13.1/Frameworks/Python.framework/Versions/3.13/lib/python3.13/concurrent/futures/_base.py\", line 401, in __get_result\r\n    raise self._exception\r\n  File \"/Users/m.havelya/work/django/env/lib/python3.13/site-packages/asgiref/sync.py\", line 365, in main_wrap\r\n    result = await awaitable\r\n             ^^^^^^^^^^^^^^^\r\n  File \"/Users/m.havelya/work/django/tests/async/test_async_connections.py\", line 31, in test_nesting_error1\r\n    assert main_connection == async_connections.get_connection(DEFAULT_DB_ALIAS)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nAssertionError\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2132307338",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/__init__.py",
        "discussion_id": "2116916765",
        "commented_code": "@@ -36,6 +37,50 @@\n ]\n \n connections = ConnectionHandler()\n+async_connections = AsyncConnectionHandler()\n+\n+\n+class new_connection:\n+    \"\"\"\n+    Asynchronous context manager to instantiate new async connections.\n+\n+    \"\"\"\n+\n+    def __init__(self, using=DEFAULT_DB_ALIAS):\n+        self.using = using\n+\n+    async def __aenter__(self):\n+        conn = connections.create_connection(self.using)\n+        if conn.features.supports_async is False:\n+            raise NotSupportedError(\n+                \"The database backend does not support asynchronous execution.\"\n+            )\n+\n+        self.force_rollback = False\n+        if async_connections.empty is True:\n+            if async_connections._from_testcase is True:\n+                self.force_rollback = True\n+        self.conn = conn\n+\n+        async_connections.add_connection(self.using, self.conn)\n+\n+        await self.conn.aensure_connection()\n+        if self.force_rollback is True:\n+            await self.conn.aset_autocommit(False)\n+\n+        return self.conn\n+\n+    async def __aexit__(self, exc_type, exc_value, traceback):",
        "comment_created_at": "2025-06-06T14:29:09+00:00",
        "comment_author": "fcurella",
        "comment_body": "Thank you, that's really helpful!\r\n\r\nWe could wrap the `__exit__` in a `try ... finally` block:\r\n\r\n```python\r\n    async def __aexit__(self, exc_type, exc_value, traceback):\r\n        try:\r\n            autocommit = await self.conn.aget_autocommit()\r\n            if autocommit is False:\r\n                if exc_type is None and self.force_rollback is False:\r\n                    await self.conn.acommit()\r\n                else:\r\n                    await self.conn.arollback()\r\n        finally:\r\n            await self.conn.aclose()\r\n            await async_connections.pop_connection(self.using)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2133072618",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/__init__.py",
        "discussion_id": "2116916765",
        "commented_code": "@@ -36,6 +37,50 @@\n ]\n \n connections = ConnectionHandler()\n+async_connections = AsyncConnectionHandler()\n+\n+\n+class new_connection:\n+    \"\"\"\n+    Asynchronous context manager to instantiate new async connections.\n+\n+    \"\"\"\n+\n+    def __init__(self, using=DEFAULT_DB_ALIAS):\n+        self.using = using\n+\n+    async def __aenter__(self):\n+        conn = connections.create_connection(self.using)\n+        if conn.features.supports_async is False:\n+            raise NotSupportedError(\n+                \"The database backend does not support asynchronous execution.\"\n+            )\n+\n+        self.force_rollback = False\n+        if async_connections.empty is True:\n+            if async_connections._from_testcase is True:\n+                self.force_rollback = True\n+        self.conn = conn\n+\n+        async_connections.add_connection(self.using, self.conn)\n+\n+        await self.conn.aensure_connection()\n+        if self.force_rollback is True:\n+            await self.conn.aset_autocommit(False)\n+\n+        return self.conn\n+\n+    async def __aexit__(self, exc_type, exc_value, traceback):",
        "comment_created_at": "2025-06-06T23:30:02+00:00",
        "comment_author": "Arfey",
        "comment_body": "We can get this problem during `aclose` call as well",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1815985368",
    "pr_number": 18408,
    "pr_file": "django/db/backends/utils.py",
    "created_at": "2024-10-25T04:39:51+00:00",
    "commented_code": "return self.cursor.executemany(sql, param_list)\n \n \n+class AsyncCursorCtx:\n+    \"\"\"\n+    Asynchronous context manager to hold an async cursor.\n+    \"\"\"\n+\n+    def __init__(self, db, name=None):\n+        self.db = db\n+        self.name = name\n+        self.wrap_database_errors = self.db.wrap_database_errors\n+\n+    async def __aenter__(self):\n+        await self.db.aclose_if_health_check_failed()\n+        await self.db.aensure_connection()\n+        self.wrap_database_errors.__enter__()\n+        return self.db._aprepare_cursor(self.db.create_async_cursor(self.name))\n+\n+    async def __aexit__(self, type, value, traceback):\n+        self.wrap_database_errors.__exit__(type, value, traceback)\n+\n+\n+class AsyncCursorWrapper(CursorWrapper):\n+    async def _execute(self, sql, params, *ignored_wrapper_args):\n+        # Raise a warning during app initialization (stored_app_configs is only\n+        # ever set during testing).\n+        if not apps.ready and not apps.stored_app_configs:\n+            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n+        self.db.validate_no_broken_transaction()\n+        with self.db.wrap_database_errors:\n+            if params is None:\n+                # params default might be backend specific.\n+                return await self.cursor.execute(sql)\n+            else:\n+                return await self.cursor.execute(sql, params)\n+\n+    async def _execute_with_wrappers(self, sql, params, many, executor):\n+        context = {\"connection\": self.db, \"cursor\": self}\n+        for wrapper in reversed(self.db.execute_wrappers):\n+            executor = functools.partial(wrapper, executor)\n+        return await executor(sql, params, many, context)\n+\n+    async def execute(self, sql, params=None):",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1815985368",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/backends/utils.py",
        "discussion_id": "1815985368",
        "commented_code": "@@ -114,6 +114,75 @@ def _executemany(self, sql, param_list, *ignored_wrapper_args):\n             return self.cursor.executemany(sql, param_list)\n \n \n+class AsyncCursorCtx:\n+    \"\"\"\n+    Asynchronous context manager to hold an async cursor.\n+    \"\"\"\n+\n+    def __init__(self, db, name=None):\n+        self.db = db\n+        self.name = name\n+        self.wrap_database_errors = self.db.wrap_database_errors\n+\n+    async def __aenter__(self):\n+        await self.db.aclose_if_health_check_failed()\n+        await self.db.aensure_connection()\n+        self.wrap_database_errors.__enter__()\n+        return self.db._aprepare_cursor(self.db.create_async_cursor(self.name))\n+\n+    async def __aexit__(self, type, value, traceback):\n+        self.wrap_database_errors.__exit__(type, value, traceback)\n+\n+\n+class AsyncCursorWrapper(CursorWrapper):\n+    async def _execute(self, sql, params, *ignored_wrapper_args):\n+        # Raise a warning during app initialization (stored_app_configs is only\n+        # ever set during testing).\n+        if not apps.ready and not apps.stored_app_configs:\n+            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n+        self.db.validate_no_broken_transaction()\n+        with self.db.wrap_database_errors:\n+            if params is None:\n+                # params default might be backend specific.\n+                return await self.cursor.execute(sql)\n+            else:\n+                return await self.cursor.execute(sql, params)\n+\n+    async def _execute_with_wrappers(self, sql, params, many, executor):\n+        context = {\"connection\": self.db, \"cursor\": self}\n+        for wrapper in reversed(self.db.execute_wrappers):\n+            executor = functools.partial(wrapper, executor)\n+        return await executor(sql, params, many, context)\n+\n+    async def execute(self, sql, params=None):",
        "comment_created_at": "2024-10-25T04:39:51+00:00",
        "comment_author": "rtpg",
        "comment_body": "Same comment as below, I really think we should avoid having async-arity-different subclassing here. \r\n\r\nIt's much easier to debug mistaken method calls if the functions are different (if not you end up with \"coroutine is not a list\"-style errors _way later_ down the stack).\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1815985811",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/backends/utils.py",
        "discussion_id": "1815985368",
        "commented_code": "@@ -114,6 +114,75 @@ def _executemany(self, sql, param_list, *ignored_wrapper_args):\n             return self.cursor.executemany(sql, param_list)\n \n \n+class AsyncCursorCtx:\n+    \"\"\"\n+    Asynchronous context manager to hold an async cursor.\n+    \"\"\"\n+\n+    def __init__(self, db, name=None):\n+        self.db = db\n+        self.name = name\n+        self.wrap_database_errors = self.db.wrap_database_errors\n+\n+    async def __aenter__(self):\n+        await self.db.aclose_if_health_check_failed()\n+        await self.db.aensure_connection()\n+        self.wrap_database_errors.__enter__()\n+        return self.db._aprepare_cursor(self.db.create_async_cursor(self.name))\n+\n+    async def __aexit__(self, type, value, traceback):\n+        self.wrap_database_errors.__exit__(type, value, traceback)\n+\n+\n+class AsyncCursorWrapper(CursorWrapper):\n+    async def _execute(self, sql, params, *ignored_wrapper_args):\n+        # Raise a warning during app initialization (stored_app_configs is only\n+        # ever set during testing).\n+        if not apps.ready and not apps.stored_app_configs:\n+            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n+        self.db.validate_no_broken_transaction()\n+        with self.db.wrap_database_errors:\n+            if params is None:\n+                # params default might be backend specific.\n+                return await self.cursor.execute(sql)\n+            else:\n+                return await self.cursor.execute(sql, params)\n+\n+    async def _execute_with_wrappers(self, sql, params, many, executor):\n+        context = {\"connection\": self.db, \"cursor\": self}\n+        for wrapper in reversed(self.db.execute_wrappers):\n+            executor = functools.partial(wrapper, executor)\n+        return await executor(sql, params, many, context)\n+\n+    async def execute(self, sql, params=None):",
        "comment_created_at": "2024-10-25T04:40:37+00:00",
        "comment_author": "rtpg",
        "comment_body": "There's some messiness because the underlying cursor uses a method called `execute`. One thing I regret not doing in my branch is just wrapping the async cursor in a way that _doesn't_ proxy to the underlying cursor. Had to waste a lot of time chasing down incorrect calls",
        "pr_file_module": null
      },
      {
        "comment_id": "1816902457",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/backends/utils.py",
        "discussion_id": "1815985368",
        "commented_code": "@@ -114,6 +114,75 @@ def _executemany(self, sql, param_list, *ignored_wrapper_args):\n             return self.cursor.executemany(sql, param_list)\n \n \n+class AsyncCursorCtx:\n+    \"\"\"\n+    Asynchronous context manager to hold an async cursor.\n+    \"\"\"\n+\n+    def __init__(self, db, name=None):\n+        self.db = db\n+        self.name = name\n+        self.wrap_database_errors = self.db.wrap_database_errors\n+\n+    async def __aenter__(self):\n+        await self.db.aclose_if_health_check_failed()\n+        await self.db.aensure_connection()\n+        self.wrap_database_errors.__enter__()\n+        return self.db._aprepare_cursor(self.db.create_async_cursor(self.name))\n+\n+    async def __aexit__(self, type, value, traceback):\n+        self.wrap_database_errors.__exit__(type, value, traceback)\n+\n+\n+class AsyncCursorWrapper(CursorWrapper):\n+    async def _execute(self, sql, params, *ignored_wrapper_args):\n+        # Raise a warning during app initialization (stored_app_configs is only\n+        # ever set during testing).\n+        if not apps.ready and not apps.stored_app_configs:\n+            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n+        self.db.validate_no_broken_transaction()\n+        with self.db.wrap_database_errors:\n+            if params is None:\n+                # params default might be backend specific.\n+                return await self.cursor.execute(sql)\n+            else:\n+                return await self.cursor.execute(sql, params)\n+\n+    async def _execute_with_wrappers(self, sql, params, many, executor):\n+        context = {\"connection\": self.db, \"cursor\": self}\n+        for wrapper in reversed(self.db.execute_wrappers):\n+            executor = functools.partial(wrapper, executor)\n+        return await executor(sql, params, many, context)\n+\n+    async def execute(self, sql, params=None):",
        "comment_created_at": "2024-10-25T15:14:52+00:00",
        "comment_author": "fcurella",
        "comment_body": "In that case, since there's no name conflict anymore, should we have one `Cursor` class with both `.execute()` and `.aexecute()`",
        "pr_file_module": null
      },
      {
        "comment_id": "1828727195",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/backends/utils.py",
        "discussion_id": "1815985368",
        "commented_code": "@@ -114,6 +114,75 @@ def _executemany(self, sql, param_list, *ignored_wrapper_args):\n             return self.cursor.executemany(sql, param_list)\n \n \n+class AsyncCursorCtx:\n+    \"\"\"\n+    Asynchronous context manager to hold an async cursor.\n+    \"\"\"\n+\n+    def __init__(self, db, name=None):\n+        self.db = db\n+        self.name = name\n+        self.wrap_database_errors = self.db.wrap_database_errors\n+\n+    async def __aenter__(self):\n+        await self.db.aclose_if_health_check_failed()\n+        await self.db.aensure_connection()\n+        self.wrap_database_errors.__enter__()\n+        return self.db._aprepare_cursor(self.db.create_async_cursor(self.name))\n+\n+    async def __aexit__(self, type, value, traceback):\n+        self.wrap_database_errors.__exit__(type, value, traceback)\n+\n+\n+class AsyncCursorWrapper(CursorWrapper):\n+    async def _execute(self, sql, params, *ignored_wrapper_args):\n+        # Raise a warning during app initialization (stored_app_configs is only\n+        # ever set during testing).\n+        if not apps.ready and not apps.stored_app_configs:\n+            warnings.warn(self.APPS_NOT_READY_WARNING_MSG, category=RuntimeWarning)\n+        self.db.validate_no_broken_transaction()\n+        with self.db.wrap_database_errors:\n+            if params is None:\n+                # params default might be backend specific.\n+                return await self.cursor.execute(sql)\n+            else:\n+                return await self.cursor.execute(sql, params)\n+\n+    async def _execute_with_wrappers(self, sql, params, many, executor):\n+        context = {\"connection\": self.db, \"cursor\": self}\n+        for wrapper in reversed(self.db.execute_wrappers):\n+            executor = functools.partial(wrapper, executor)\n+        return await executor(sql, params, many, context)\n+\n+    async def execute(self, sql, params=None):",
        "comment_created_at": "2024-11-05T05:01:05+00:00",
        "comment_author": "rtpg",
        "comment_body": "I _feel_ like that's not an issue, where `execute` goes through `async_to_sync`. But I don't feel strongly either way. It feels to me like in general a sync cursor would be taken for sync flows and an async cursor would be taken for async flows and so it _might_ be a mistake to have `AsyncCursor.execute`? But OTOH I don't believe it's _wrong_ to implement `execute` with `async_to_sync`. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2046624262",
    "pr_number": 18408,
    "pr_file": "django/db/utils.py",
    "created_at": "2025-04-16T10:24:58+00:00",
    "commented_code": "return backend.DatabaseWrapper(db, alias)\n \n \n+class AsyncAlias:\n+    \"\"\"\n+    A Context-aware list of connections.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self._connections = Local()\n+        setattr(self._connections, \"_stack\", [])\n+\n+    @property\n+    def connections(self):\n+        return getattr(self._connections, \"_stack\", [])\n+\n+    def __len__(self):\n+        return len(self.connections)\n+\n+    def __iter__(self):\n+        return iter(self.connections)\n+\n+    def __str__(self):\n+        return \", \".join([str(id(conn)) for conn in self.connections])\n+\n+    def __repr__(self):\n+        return f\"<{self.__class__.__name__}: {len(self.connections)} connections>\"\n+\n+    def add_connection(self, connection):\n+        setattr(self._connections, \"_stack\", self.connections + [connection])\n+\n+    def pop(self):\n+        conns = self.connections\n+        conns.pop()\n+        setattr(self._connections, \"_stack\", conns)\n+\n+\n+class AsyncConnectionHandler:\n+    \"\"\"\n+    Context-aware class to store async connections, mapped by alias name.\n+    \"\"\"",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2046624262",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/utils.py",
        "discussion_id": "2046624262",
        "commented_code": "@@ -197,6 +199,89 @@ def create_connection(self, alias):\n         return backend.DatabaseWrapper(db, alias)\n \n \n+class AsyncAlias:\n+    \"\"\"\n+    A Context-aware list of connections.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self._connections = Local()\n+        setattr(self._connections, \"_stack\", [])\n+\n+    @property\n+    def connections(self):\n+        return getattr(self._connections, \"_stack\", [])\n+\n+    def __len__(self):\n+        return len(self.connections)\n+\n+    def __iter__(self):\n+        return iter(self.connections)\n+\n+    def __str__(self):\n+        return \", \".join([str(id(conn)) for conn in self.connections])\n+\n+    def __repr__(self):\n+        return f\"<{self.__class__.__name__}: {len(self.connections)} connections>\"\n+\n+    def add_connection(self, connection):\n+        setattr(self._connections, \"_stack\", self.connections + [connection])\n+\n+    def pop(self):\n+        conns = self.connections\n+        conns.pop()\n+        setattr(self._connections, \"_stack\", conns)\n+\n+\n+class AsyncConnectionHandler:\n+    \"\"\"\n+    Context-aware class to store async connections, mapped by alias name.\n+    \"\"\"",
        "comment_created_at": "2025-04-16T10:24:58+00:00",
        "comment_author": "Arfey",
        "comment_body": "This solution perfectly covers existing requirements. But besides that, we have side effects. I'll try to explain below\r\n\r\n`example #1`\r\n```python\r\nasync def get_authors(pattern):\r\n    # Create a new context to call concurrently\r\n    async with db.new_connections():\r\n        return [\r\n            author.name\r\n            async for author in Authors.objects.filter(name__icontains=pattern)\r\n        ]\r\n\r\nasync def get_books(pattern):\r\n    # Create a new context to call concurrently\r\n    async with db.new_connections():\r\n        return [\r\n            book.title\r\n            async for book in Book.objects.filter(name__icontains=pattern)\r\n        ]\r\n\r\nasync def my_view(request):\r\n    # Query authors and books concurrently\r\n    task_authors = asyncio.create_task(get_authors(\"an\"))\r\n    task_books = asyncio.create_task(get_books(\"di\"))\r\n    return render(\r\n        request,\r\n        \"template.html\",\r\n        {\r\n            \"books\": await task_books,\r\n            \"authors\": await task_authors,\r\n        },\r\n    )\r\n```\r\n\r\nit will work perfectly.\r\n\r\n`example #2`\r\n\r\n```python\r\nasync def my_view(request):\r\n    task_authors = get_authors(\"an\")\r\n    task_books = get_books(\"di\")\r\n    return render(\r\n        request,\r\n        \"template.html\",\r\n        {\r\n            \"books\": await task_books,\r\n            \"authors\": await task_authors,\r\n        },\r\n    )\r\n```\r\n\r\nit still works but looks odd coz we don't have any reason to create a new connection for each sequential request. Anyway, we can do it.\r\n\r\n`example #3`\r\n\r\n```python\r\n\r\nasync def get_authors(pattern):\r\n    # without new connection\r\n    return [\r\n        author.name\r\n        async for author in Authors.objects.filter(name__icontains=pattern)\r\n    ]\r\n\r\nasync def get_books(pattern):\r\n    # create new connection and put it on stack\r\n    async with db.new_connections():\r\n        return [\r\n            book.title\r\n            async for book in Book.objects.filter(name__icontains=pattern)\r\n        ]\r\n        # delete connection from the stack\r\n\r\n    # delete parent connection from the stack\r\n    await async_connections['default'].close()\r\n\r\nasync def my_view(request):\r\n    async with db.new_connections():\r\n        # Query authors and books concurrently\r\n        task_authors = asyncio.create_task(get_authors(\"an\"))\r\n        task_books = asyncio.create_task(get_books(\"di\"))\r\n\r\n        return render(\r\n            request,\r\n            \"template.html\",\r\n            {\r\n                \"books\": await task_books,\r\n                \"authors\": await task_authors,\r\n            },\r\n        )\r\n```\r\n\r\nso I have full access to the parent connections (connection stack) and can do everything what I want with it.\r\n\r\nI am not a big fan of `db.new_connections` 😂 so about my \"very important\" view\r\n\r\nget rid of `db.new_connections` and use decorator instead\r\n\r\n```python\r\ndef concurrent_async_db(func):\r\n    if not inspect.iscoroutinefunction(func):\r\n        raise TypeError(\"Function decorated with @concurrent_async_db must be an async function\")\r\n\r\n    async def concurrent(*args, **kwargs):\r\n        # Clean up or isolate DB connection state before calling the real function\r\n        # or something like this async_connections.refresh()\r\n        async_connections['default'] = None\r\n        return await func(*args, **kwargs)\r\n\r\n    @wraps(func)\r\n    def wrapper(*args, **kwargs):\r\n        # we use asyncio.create_task coz without it, the concurrent connection doesn't have any sense\r\n        return asyncio.create_task(concurrent(*args, **kwargs))\r\n\r\n    return wrapper\r\n\r\n@concurrent_async_db\r\nasync def get_authors(pattern):\r\n    return [\r\n        author.name\r\n        async for author in Authors.objects.filter(name__icontains=pattern)\r\n    ]\r\n```\r\n\r\nadv\r\n\r\n- we don't have cases as, for `example #2` coz we don't create a connection explicit\r\n- we don't have access to the parent connections ",
        "pr_file_module": null
      },
      {
        "comment_id": "2073493038",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/utils.py",
        "discussion_id": "2046624262",
        "commented_code": "@@ -197,6 +199,89 @@ def create_connection(self, alias):\n         return backend.DatabaseWrapper(db, alias)\n \n \n+class AsyncAlias:\n+    \"\"\"\n+    A Context-aware list of connections.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self._connections = Local()\n+        setattr(self._connections, \"_stack\", [])\n+\n+    @property\n+    def connections(self):\n+        return getattr(self._connections, \"_stack\", [])\n+\n+    def __len__(self):\n+        return len(self.connections)\n+\n+    def __iter__(self):\n+        return iter(self.connections)\n+\n+    def __str__(self):\n+        return \", \".join([str(id(conn)) for conn in self.connections])\n+\n+    def __repr__(self):\n+        return f\"<{self.__class__.__name__}: {len(self.connections)} connections>\"\n+\n+    def add_connection(self, connection):\n+        setattr(self._connections, \"_stack\", self.connections + [connection])\n+\n+    def pop(self):\n+        conns = self.connections\n+        conns.pop()\n+        setattr(self._connections, \"_stack\", conns)\n+\n+\n+class AsyncConnectionHandler:\n+    \"\"\"\n+    Context-aware class to store async connections, mapped by alias name.\n+    \"\"\"",
        "comment_created_at": "2025-05-05T13:52:06+00:00",
        "comment_author": "fcurella",
        "comment_body": "Given this view:\r\n\r\n```python\r\nasync def my_view(request):\r\n    async with db.new_connections():\r\n        # Query authors and books concurrently\r\n        task_authors = asyncio.create_task(get_authors(\"an\"))\r\n        task_books = asyncio.create_task(get_books(\"di\"))\r\n\r\n        return render(\r\n            request,\r\n            \"template.html\",\r\n            {\r\n                \"books\": await task_books,\r\n                \"authors\": await task_authors,\r\n            },\r\n        )\r\n```\r\n\r\nI think the user should expect the two queries to happen sequentially. The code `await`s for `task_books`, then `await`s again for `task_authors`. That's why the keyword is called `await` :)  \"Async\" does not mean \"in parallel\".\r\n\r\nWe could _also_ have a `concurrent_async_db`, but I think it should be a later addition.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2076591455",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "django/db/utils.py",
        "discussion_id": "2046624262",
        "commented_code": "@@ -197,6 +199,89 @@ def create_connection(self, alias):\n         return backend.DatabaseWrapper(db, alias)\n \n \n+class AsyncAlias:\n+    \"\"\"\n+    A Context-aware list of connections.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self._connections = Local()\n+        setattr(self._connections, \"_stack\", [])\n+\n+    @property\n+    def connections(self):\n+        return getattr(self._connections, \"_stack\", [])\n+\n+    def __len__(self):\n+        return len(self.connections)\n+\n+    def __iter__(self):\n+        return iter(self.connections)\n+\n+    def __str__(self):\n+        return \", \".join([str(id(conn)) for conn in self.connections])\n+\n+    def __repr__(self):\n+        return f\"<{self.__class__.__name__}: {len(self.connections)} connections>\"\n+\n+    def add_connection(self, connection):\n+        setattr(self._connections, \"_stack\", self.connections + [connection])\n+\n+    def pop(self):\n+        conns = self.connections\n+        conns.pop()\n+        setattr(self._connections, \"_stack\", conns)\n+\n+\n+class AsyncConnectionHandler:\n+    \"\"\"\n+    Context-aware class to store async connections, mapped by alias name.\n+    \"\"\"",
        "comment_created_at": "2025-05-07T00:48:31+00:00",
        "comment_author": "Arfey",
        "comment_body": "Sure, the current example works as expected. The problem is that with the existing requirement (I am talking about db.new_connections()), we generate a lot of problems (which I described above), and our end users have to keep in mind all of that to write code without side effects 😔\r\n\r\nIf our end goal is to give the ability to run queries in parallel, then we have other approaches that don't have the current problems\r\n\r\nps: I really really hate creating an explicit connection 😅",
        "pr_file_module": null
      }
    ]
  }
]