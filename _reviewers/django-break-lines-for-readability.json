[
  {
    "discussion_id": "2180578618",
    "pr_number": 19145,
    "pr_file": "django/utils/deprecation.py",
    "created_at": "2025-07-02T17:10:22+00:00",
    "commented_code": "return new_class\n \n \n+def deprecate_posargs(deprecation_warning, remappable_names, /):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the ``*``\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    The decorator takes two arguments: a RemovedInDjangoXXWarning warning\n+    category and a list of parameter names that have been changed from\n+    positional-or-keyword to keyword-only, in their original positional order.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    After the deprecation period, remove the decorator (but keep the ``*``)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new *positional*\n+    parameters or change the remaining ones. For example, this attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new *keyword-only* parameters and to re-order\n+    the existing ones, so long as the list passed to @deprecate_posargs is kept\n+    in the original order. This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    message_template_singular = (\n+        \"Passing positional argument {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change it to a keyword arg.\"\n+    )\n+    message_template_plural = (\n+        \"Passing positional arguments {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change them to keyword args.\"\n+    )\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in remappable_names\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() remappable_names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_remappable_args = len(remappable_names)\n+        max_positional_args = num_positional_params + num_remappable_args\n+\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+            class_name = local_name.replace(\".__init__\", \"\")\n+            func_name = class_name\n+\n+        def remap_deprecated_args(args, kwargs):\n+            \"\"\"\n+            Move deprecated positional args to kwargs and issue a warning.\n+            Returns updated (args, kwargs).\n+            \"\"\"\n+            num_positional_args = len(args)\n+            if num_positional_args > max_positional_args:\n+                raise TypeError(\n+                    f\"{func_name}() takes\"\n+                    f\" at most {max_positional_args} positional argument(s)\"\n+                    f\" (including {num_remappable_args} deprecated)\"\n+                    f\" but {num_positional_args} were given.\"",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2180578618",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2180578618",
        "commented_code": "@@ -83,6 +85,187 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(deprecation_warning, remappable_names, /):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the ``*``\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    The decorator takes two arguments: a RemovedInDjangoXXWarning warning\n+    category and a list of parameter names that have been changed from\n+    positional-or-keyword to keyword-only, in their original positional order.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    After the deprecation period, remove the decorator (but keep the ``*``)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new *positional*\n+    parameters or change the remaining ones. For example, this attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new *keyword-only* parameters and to re-order\n+    the existing ones, so long as the list passed to @deprecate_posargs is kept\n+    in the original order. This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    message_template_singular = (\n+        \"Passing positional argument {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change it to a keyword arg.\"\n+    )\n+    message_template_plural = (\n+        \"Passing positional arguments {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change them to keyword args.\"\n+    )\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in remappable_names\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() remappable_names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_remappable_args = len(remappable_names)\n+        max_positional_args = num_positional_params + num_remappable_args\n+\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+            class_name = local_name.replace(\".__init__\", \"\")\n+            func_name = class_name\n+\n+        def remap_deprecated_args(args, kwargs):\n+            \"\"\"\n+            Move deprecated positional args to kwargs and issue a warning.\n+            Returns updated (args, kwargs).\n+            \"\"\"\n+            num_positional_args = len(args)\n+            if num_positional_args > max_positional_args:\n+                raise TypeError(\n+                    f\"{func_name}() takes\"\n+                    f\" at most {max_positional_args} positional argument(s)\"\n+                    f\" (including {num_remappable_args} deprecated)\"\n+                    f\" but {num_positional_args} were given.\"",
        "comment_created_at": "2025-07-02T17:10:22+00:00",
        "comment_author": "nessita",
        "comment_body": "Let's try to use as much as from the 80cols limit as possible?\r\n```suggestion\r\n                    f\"{func_name}() takes at most {max_positional_args} \"\r\n                    f\"positional argument(s) (including {num_remappable_args} \"\r\n                    f\"deprecated) but {num_positional_args} were given.\"\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2193629216",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2180578618",
        "commented_code": "@@ -83,6 +85,187 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(deprecation_warning, remappable_names, /):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the ``*``\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    The decorator takes two arguments: a RemovedInDjangoXXWarning warning\n+    category and a list of parameter names that have been changed from\n+    positional-or-keyword to keyword-only, in their original positional order.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    After the deprecation period, remove the decorator (but keep the ``*``)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new *positional*\n+    parameters or change the remaining ones. For example, this attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new *keyword-only* parameters and to re-order\n+    the existing ones, so long as the list passed to @deprecate_posargs is kept\n+    in the original order. This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    message_template_singular = (\n+        \"Passing positional argument {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change it to a keyword arg.\"\n+    )\n+    message_template_plural = (\n+        \"Passing positional arguments {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change them to keyword args.\"\n+    )\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in remappable_names\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() remappable_names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_remappable_args = len(remappable_names)\n+        max_positional_args = num_positional_params + num_remappable_args\n+\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+            class_name = local_name.replace(\".__init__\", \"\")\n+            func_name = class_name\n+\n+        def remap_deprecated_args(args, kwargs):\n+            \"\"\"\n+            Move deprecated positional args to kwargs and issue a warning.\n+            Returns updated (args, kwargs).\n+            \"\"\"\n+            num_positional_args = len(args)\n+            if num_positional_args > max_positional_args:\n+                raise TypeError(\n+                    f\"{func_name}() takes\"\n+                    f\" at most {max_positional_args} positional argument(s)\"\n+                    f\" (including {num_remappable_args} deprecated)\"\n+                    f\" but {num_positional_args} were given.\"",
        "comment_created_at": "2025-07-08T23:40:23+00:00",
        "comment_author": "medmunds",
        "comment_body": "OK. (This used to be called \"breaking lines at natural places,\" and I guess now has been branded [semantic line breaks](https://sembr.org/). Also some [Python discussion](https://discuss.python.org/t/semantic-line-breaks/13874/1).)\r\n\r\nI try put the space at the beginning of the continuation line to make it clear it's a continuation, like indenting code. (Also, people sometimes accidentally trim spaces at the end of lines, even inside strings, and especially spaces after punctuation.)\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1849473477",
    "pr_number": 18769,
    "pr_file": "django/core/management/commands/listurls.py",
    "created_at": "2024-11-20T03:59:14+00:00",
    "commented_code": "+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1849473477",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T03:59:14+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Also you'll likely be asked to wrap the genexp in a list comprehension when doing a `join()` as it's more performant\u2026  I don't have the link handy but felix knows what I'm talking about (he's the one who asks for it).\r\n\r\nHaving said that, this is a command & not a hot path so probably doesn't matter and there may be a preference for readability.",
        "pr_file_module": null
      },
      {
        "comment_id": "1849837973",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T08:30:02+00:00",
        "comment_author": "ulgens",
        "comment_body": "Readability does matter but I couldn't catch what you meant. Instead of referring to other people and their thoughts, it would be nicer if you can just add a suggestion.",
        "pr_file_module": null
      },
      {
        "comment_id": "1849875707",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T08:54:01+00:00",
        "comment_author": "shangxiao",
        "comment_body": "@ulgens Can you keep your tone friendly & respectful please?  I get that it can be hard to have other people review your code as it feels like someone just loading on the criticisms\u2026 I've been trying hard to make my feedback as friendly as possible but the responses I feel like I'm getting from you are just a tad too \"I know better than you\" type of tone \ud83e\udd37\r\n\r\nIf you like we can jump on Discord to resolve this amicably \ud83d\udc4d \u263a\ufe0f",
        "pr_file_module": null
      },
      {
        "comment_id": "1849913396",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T09:14:39+00:00",
        "comment_author": "ulgens",
        "comment_body": "@shangxiao I'm not sure where this is coming from but I assure you, there is no \"I know better than you\" attitude in my response. \r\n\r\nAgain, if you can explain your comment better by giving an example, that would be nice of you. Otherwise I'm not sure how to act on a comment that I don't understand.",
        "pr_file_module": null
      },
      {
        "comment_id": "1850481563",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T15:04:17+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "I can understand why @shangxiao is frustrated.\r\nSome of these comments are dismissive and resolving comments before an agreement is also dismissive.\r\nThis feels disrespectful to the time that folks give to review a PR. \r\n\r\nAlso note that @shangxiao  is a member of the triage and review team and an active contributor to Django - these are not fly-by comments but based off experience contributing to this project.\r\n\r\nPart of the reason a suggestion hasn't been given here is it's not clear if we should make this update or not.\r\n\"felix\" is @felixxm and I would like him to weigh in here :+1: ",
        "pr_file_module": null
      },
      {
        "comment_id": "1850491776",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T15:10:00+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Ok fair enough just remember though some of us aren't paid members and reviewing is a volunteer thing so we all just need to play nice & be pleasant.\r\n\r\nI don't have the link that felix (Mariusz) usually refers to but by \"wrap the genexp in a list comprehension\" I mean this \ud83d\udc47\r\n\r\n```suggestion\r\n        formatted_str.write(\"-+-\".join([\"-\" * width for width in widths]))\r\n```\r\n\r\nBut yeah as I previously mentioned this isn't a hot path was more just making reference to it so you're aware \ud83d\udc4d \r\n\r\nEdit: oh yeah and I forgot to mention it only applies for `join()` \ud83e\udd2d",
        "pr_file_module": null
      },
      {
        "comment_id": "1850539721",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T15:32:20+00:00",
        "comment_author": "ulgens",
        "comment_body": "@shangxiao Almost none of us are paid members, so I believe we all agree that being nice is the key \ud83c\udf7b  That being said, I was only asking for an actionable insight and I'm still surprised how it came to this, but I'll be more careful while responding to incoming comments.\r\n\r\nAbout the list comprehension comment, thanks for the example. I'm still missing the benefit it provides, but if that's some styling/linting expectation, I'll apply that.",
        "pr_file_module": null
      },
      {
        "comment_id": "1850765441",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-20T18:01:56+00:00",
        "comment_author": "nessita",
        "comment_body": "For further reference, I believe this is what @shangxiao refers to:\r\nhttps://github.com/django/django/pull/16873#issuecomment-1554421115\r\n\r\nCopying from that comment:\r\n> list comprehension is preferable here as str.join() converts to list internally anyway. It is better performance to provide a list up front.\r\n\r\nhttps://stackoverflow.com/questions/9060653/list-comprehension-without-in-python/9061024#9061024\r\n\r\nadamchainz/flake8-comprehensions#156",
        "pr_file_module": null
      },
      {
        "comment_id": "1852461484",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849473477",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))\n+\n+        formatted_str.write(\" | \".join(header_parts))\n+        formatted_str.write(\"\\n\")\n+\n+        # Header - content separator\n+        formatted_str.write(\"-+-\".join(\"-\" * width for width in widths))",
        "comment_created_at": "2024-11-21T16:23:02+00:00",
        "comment_author": "ulgens",
        "comment_body": "@nessita Thanks for the resources. It seems the overall discussion wasn't finalized and there is open question about the tradeoff it requires: https://github.com/adamchainz/flake8-comprehensions/issues/156#issuecomment-2459089173 \r\n\r\nIn either case, I don't think the performance difference matters enough to have a detailed discussion about this change:\r\n\r\n```bash\r\n> python -m timeit '\"\".join(str(n) for n in range(20))'\r\n200000 loops, best of 5: 1.56 usec per loop\r\n\r\n> python -m timeit '\"\".join([str(n) for n in range(20)])'\r\n200000 loops, best of 5: 1.19 usec per loop\r\n```\r\n\r\nThe difference between these two is 0.37 milliseconds.\r\n\r\nI applied the list comprehension to two different places this case applies. I hope that's okay with everyone.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2115735888",
    "pr_number": 19507,
    "pr_file": "django/http/request.py",
    "created_at": "2025-05-30T11:24:35+00:00",
    "commented_code": "@property\n     def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+        return self.main_type == \"*\" and self.sub_type == \"*\" and not self.params\n+\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)\n+        return params\n \n     def match(self, other):\n-        if self.is_all_types:\n-            return True\n         other = MediaType(other)\n-        return self.main_type == other.main_type and self.sub_type in {\n-            \"*\",\n-            other.sub_type,\n-        }\n+\n+        return (\n+            self.main_type in [other.main_type, \"*\"]\n+            and self.sub_type\n+            in [\n+                \"*\",\n+                other.sub_type,\n+            ]\n+            and ((self.params == other.params) if other.params else True)\n+        )",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2115735888",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2115735888",
        "commented_code": "@@ -707,21 +707,31 @@ def __repr__(self):\n \n     @property\n     def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+        return self.main_type == \"*\" and self.sub_type == \"*\" and not self.params\n+\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)\n+        return params\n \n     def match(self, other):\n-        if self.is_all_types:\n-            return True\n         other = MediaType(other)\n-        return self.main_type == other.main_type and self.sub_type in {\n-            \"*\",\n-            other.sub_type,\n-        }\n+\n+        return (\n+            self.main_type in [other.main_type, \"*\"]\n+            and self.sub_type\n+            in [\n+                \"*\",\n+                other.sub_type,\n+            ]\n+            and ((self.params == other.params) if other.params else True)\n+        )",
        "comment_created_at": "2025-05-30T11:24:35+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Black forced the trailing comma after `other.sub_type` and it's kept it there after this modification.\r\n\r\nI usually like to (re)remove the trailing comma it imposes in order to make it more readable.\r\n\r\nBlack should be happy with this:\r\n```suggestion\r\n        return (\r\n            self.main_type in [other.main_type, \"*\"]\r\n            and self.sub_type in [\"*\", other.sub_type]\r\n            and ((self.params == other.params) if other.params else True)\r\n        )\r\n```\r\n\r\nI find that more readable because you have 1 test per line.\r\n\r\nI disagree with this \"we're not allowed to take out commas that Black had previously put in\" stance that I've seen others here impose and having it sacrifice readability.  My position is that it's ok to affect Black with such operations when it helps with readability & maintainability \ud83e\udd37 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2115774997",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2115735888",
        "commented_code": "@@ -707,21 +707,31 @@ def __repr__(self):\n \n     @property\n     def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+        return self.main_type == \"*\" and self.sub_type == \"*\" and not self.params\n+\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)\n+        return params\n \n     def match(self, other):\n-        if self.is_all_types:\n-            return True\n         other = MediaType(other)\n-        return self.main_type == other.main_type and self.sub_type in {\n-            \"*\",\n-            other.sub_type,\n-        }\n+\n+        return (\n+            self.main_type in [other.main_type, \"*\"]\n+            and self.sub_type\n+            in [\n+                \"*\",\n+                other.sub_type,\n+            ]\n+            and ((self.params == other.params) if other.params else True)\n+        )",
        "comment_created_at": "2025-05-30T11:41:57+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "Oh I definitely agree - this is much nicer to read.",
        "pr_file_module": null
      }
    ]
  }
]