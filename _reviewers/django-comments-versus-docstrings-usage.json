[
  {
    "discussion_id": "2180619210",
    "pr_number": 19145,
    "pr_file": "django/utils/deprecation.py",
    "created_at": "2025-07-02T17:33:58+00:00",
    "commented_code": "return new_class\n \n \n+def deprecate_posargs(deprecation_warning, remappable_names, /):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the ``*``\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    The decorator takes two arguments: a RemovedInDjangoXXWarning warning\n+    category and a list of parameter names that have been changed from\n+    positional-or-keyword to keyword-only, in their original positional order.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    After the deprecation period, remove the decorator (but keep the ``*``)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new *positional*\n+    parameters or change the remaining ones. For example, this attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new *keyword-only* parameters and to re-order\n+    the existing ones, so long as the list passed to @deprecate_posargs is kept\n+    in the original order. This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    message_template_singular = (\n+        \"Passing positional argument {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change it to a keyword arg.\"\n+    )\n+    message_template_plural = (\n+        \"Passing positional arguments {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change them to keyword args.\"\n+    )\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in remappable_names\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() remappable_names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_remappable_args = len(remappable_names)\n+        max_positional_args = num_positional_params + num_remappable_args\n+\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+            class_name = local_name.replace(\".__init__\", \"\")\n+            func_name = class_name\n+\n+        def remap_deprecated_args(args, kwargs):\n+            \"\"\"\n+            Move deprecated positional args to kwargs and issue a warning.\n+            Returns updated (args, kwargs).\n+            \"\"\"\n+            num_positional_args = len(args)\n+            if num_positional_args > max_positional_args:\n+                raise TypeError(\n+                    f\"{func_name}() takes\"\n+                    f\" at most {max_positional_args} positional argument(s)\"\n+                    f\" (including {num_remappable_args} deprecated)\"\n+                    f\" but {num_positional_args} were given.\"\n+                )\n+\n+            # Identify which of the potentially _remappable_ params\n+            # are actually being _remapped_ in this particular call.\n+            remapped_names = remappable_names[\n+                : num_positional_args - num_positional_params\n+            ]\n+            conflicts = set(remapped_names) & set(kwargs)\n+            if conflicts:\n+                # Report duplicate param names in original parameter order.\n+                conflicts_str = \", \".join(\n+                    f\"'{name}'\" for name in remapped_names if name in conflicts\n+                )\n+                raise TypeError(\n+                    f\"{func_name}() got both deprecated positional and keyword\"\n+                    f\" argument values for {conflicts_str}.\"\n+                )\n+\n+            # Do the remapping.\n+            remapped_kwargs = dict(zip(remapped_names, args[num_positional_params:]))\n+            remaining_args = args[:num_positional_params]\n+            updated_kwargs = kwargs | remapped_kwargs\n+\n+            # Issue the deprecation warning.\n+            message_template = (\n+                message_template_singular\n+                if len(remapped_names) == 1\n+                else message_template_plural\n+            )\n+            message = message_template.format(\n+                remapped_names=\", \".join(f\"'{name}'\" for name in remapped_names),\n+                func_name=func_name,\n+            )\n+            warnings.warn(message, deprecation_warning, stacklevel=3)",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2180619210",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2180619210",
        "commented_code": "@@ -83,6 +85,187 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(deprecation_warning, remappable_names, /):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the ``*``\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    The decorator takes two arguments: a RemovedInDjangoXXWarning warning\n+    category and a list of parameter names that have been changed from\n+    positional-or-keyword to keyword-only, in their original positional order.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    After the deprecation period, remove the decorator (but keep the ``*``)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new *positional*\n+    parameters or change the remaining ones. For example, this attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new *keyword-only* parameters and to re-order\n+    the existing ones, so long as the list passed to @deprecate_posargs is kept\n+    in the original order. This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    message_template_singular = (\n+        \"Passing positional argument {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change it to a keyword arg.\"\n+    )\n+    message_template_plural = (\n+        \"Passing positional arguments {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change them to keyword args.\"\n+    )\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in remappable_names\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() remappable_names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_remappable_args = len(remappable_names)\n+        max_positional_args = num_positional_params + num_remappable_args\n+\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+            class_name = local_name.replace(\".__init__\", \"\")\n+            func_name = class_name\n+\n+        def remap_deprecated_args(args, kwargs):\n+            \"\"\"\n+            Move deprecated positional args to kwargs and issue a warning.\n+            Returns updated (args, kwargs).\n+            \"\"\"\n+            num_positional_args = len(args)\n+            if num_positional_args > max_positional_args:\n+                raise TypeError(\n+                    f\"{func_name}() takes\"\n+                    f\" at most {max_positional_args} positional argument(s)\"\n+                    f\" (including {num_remappable_args} deprecated)\"\n+                    f\" but {num_positional_args} were given.\"\n+                )\n+\n+            # Identify which of the potentially _remappable_ params\n+            # are actually being _remapped_ in this particular call.\n+            remapped_names = remappable_names[\n+                : num_positional_args - num_positional_params\n+            ]\n+            conflicts = set(remapped_names) & set(kwargs)\n+            if conflicts:\n+                # Report duplicate param names in original parameter order.\n+                conflicts_str = \", \".join(\n+                    f\"'{name}'\" for name in remapped_names if name in conflicts\n+                )\n+                raise TypeError(\n+                    f\"{func_name}() got both deprecated positional and keyword\"\n+                    f\" argument values for {conflicts_str}.\"\n+                )\n+\n+            # Do the remapping.\n+            remapped_kwargs = dict(zip(remapped_names, args[num_positional_params:]))\n+            remaining_args = args[:num_positional_params]\n+            updated_kwargs = kwargs | remapped_kwargs\n+\n+            # Issue the deprecation warning.\n+            message_template = (\n+                message_template_singular\n+                if len(remapped_names) == 1\n+                else message_template_plural\n+            )\n+            message = message_template.format(\n+                remapped_names=\", \".join(f\"'{name}'\" for name in remapped_names),\n+                func_name=func_name,\n+            )\n+            warnings.warn(message, deprecation_warning, stacklevel=3)",
        "comment_created_at": "2025-07-02T17:33:58+00:00",
        "comment_author": "nessita",
        "comment_body": "Following ticket-35667 and comments from @charettes like [this one](https://github.com/django/django/pull/19187#discussion_r2175056745), could we change this to use `skip_file_prefixes=(os.path.dirname(django.__file__),` instead of `stacklevel=3`? So:\r\n\r\n```suggestion\r\n            warnings.warn(\r\n                message,\r\n                deprecation_warning,\r\n                skip_file_prefixes=(os.path.dirname(django.__file__),),\r\n            )\r\n```\r\n\r\nThen, ideally, tests should be adjusted to assert over the deprecation's reported filename, as documented in https://docs.djangoproject.com/en/5.2/internals/contributing/writing-code/submitting-patches/#deprecating-a-feature:\r\n\r\n```python\r\ndef test_foo_deprecation_warning(self):\r\n    msg = \"Expected deprecation message\"\r\n    with self.assertWarnsMessage(RemovedInDjangoXXWarning, msg) as ctx:\r\n        # invoke deprecated behavior\r\n        ...\r\n    self.assertEqual(ctx.filename, __file__)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2193638652",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2180619210",
        "commented_code": "@@ -83,6 +85,187 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(deprecation_warning, remappable_names, /):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the ``*``\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    The decorator takes two arguments: a RemovedInDjangoXXWarning warning\n+    category and a list of parameter names that have been changed from\n+    positional-or-keyword to keyword-only, in their original positional order.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    After the deprecation period, remove the decorator (but keep the ``*``)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new *positional*\n+    parameters or change the remaining ones. For example, this attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new *keyword-only* parameters and to re-order\n+    the existing ones, so long as the list passed to @deprecate_posargs is kept\n+    in the original order. This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, [\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    message_template_singular = (\n+        \"Passing positional argument {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change it to a keyword arg.\"\n+    )\n+    message_template_plural = (\n+        \"Passing positional arguments {remapped_names} to {func_name}()\"\n+        \" is deprecated. Change them to keyword args.\"\n+    )\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in remappable_names\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() remappable_names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_remappable_args = len(remappable_names)\n+        max_positional_args = num_positional_params + num_remappable_args\n+\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+            class_name = local_name.replace(\".__init__\", \"\")\n+            func_name = class_name\n+\n+        def remap_deprecated_args(args, kwargs):\n+            \"\"\"\n+            Move deprecated positional args to kwargs and issue a warning.\n+            Returns updated (args, kwargs).\n+            \"\"\"\n+            num_positional_args = len(args)\n+            if num_positional_args > max_positional_args:\n+                raise TypeError(\n+                    f\"{func_name}() takes\"\n+                    f\" at most {max_positional_args} positional argument(s)\"\n+                    f\" (including {num_remappable_args} deprecated)\"\n+                    f\" but {num_positional_args} were given.\"\n+                )\n+\n+            # Identify which of the potentially _remappable_ params\n+            # are actually being _remapped_ in this particular call.\n+            remapped_names = remappable_names[\n+                : num_positional_args - num_positional_params\n+            ]\n+            conflicts = set(remapped_names) & set(kwargs)\n+            if conflicts:\n+                # Report duplicate param names in original parameter order.\n+                conflicts_str = \", \".join(\n+                    f\"'{name}'\" for name in remapped_names if name in conflicts\n+                )\n+                raise TypeError(\n+                    f\"{func_name}() got both deprecated positional and keyword\"\n+                    f\" argument values for {conflicts_str}.\"\n+                )\n+\n+            # Do the remapping.\n+            remapped_kwargs = dict(zip(remapped_names, args[num_positional_params:]))\n+            remaining_args = args[:num_positional_params]\n+            updated_kwargs = kwargs | remapped_kwargs\n+\n+            # Issue the deprecation warning.\n+            message_template = (\n+                message_template_singular\n+                if len(remapped_names) == 1\n+                else message_template_plural\n+            )\n+            message = message_template.format(\n+                remapped_names=\", \".join(f\"'{name}'\" for name in remapped_names),\n+                func_name=func_name,\n+            )\n+            warnings.warn(message, deprecation_warning, stacklevel=3)",
        "comment_created_at": "2025-07-08T23:52:31+00:00",
        "comment_author": "medmunds",
        "comment_body": "> `skip_file_prefixes`\r\n\r\nOh, nice, TIL.\r\n\r\nThe test is already there (currently called test_warning_stacklevel; I'll rename it), and passes both before and after changing stacklevel to skip_file_prefixes.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2145678498",
    "pr_number": 19555,
    "pr_file": "django/db/models/expressions.py",
    "created_at": "2025-06-13T17:46:55+00:00",
    "commented_code": "def set_source_expressions(self, exprs):\n         self.condition, self.result = exprs\n \n+    def resolve_expression(\n+        self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False\n+    ):\n+        \"\"\"\n+        Ensure condition is always resolved with for_save=False since it's used\n+        as a filter, not as an update value.\n+        \"\"\"",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2145678498",
        "repo_full_name": "django/django",
        "pr_number": 19555,
        "pr_file": "django/db/models/expressions.py",
        "discussion_id": "2145678498",
        "commented_code": "@@ -1620,6 +1620,20 @@ def get_source_expressions(self):\n     def set_source_expressions(self, exprs):\n         self.condition, self.result = exprs\n \n+    def resolve_expression(\n+        self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False\n+    ):\n+        \"\"\"\n+        Ensure condition is always resolved with for_save=False since it's used\n+        as a filter, not as an update value.\n+        \"\"\"",
        "comment_created_at": "2025-06-13T17:46:55+00:00",
        "comment_author": "charettes",
        "comment_body": "I think the comment is valuable but I'm not sure it's worth _obscuring_ the inherited `__doc__` string with it. Any thoughts about using `#` instead of a string literal so it doesn't get picked up?\r\n\r\n```suggestion\r\n        # Ensure condition is always resolved with for_save=False since it's used\r\n        # as a filter, not as an update value.\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2145801984",
        "repo_full_name": "django/django",
        "pr_number": 19555,
        "pr_file": "django/db/models/expressions.py",
        "discussion_id": "2145678498",
        "commented_code": "@@ -1620,6 +1620,20 @@ def get_source_expressions(self):\n     def set_source_expressions(self, exprs):\n         self.condition, self.result = exprs\n \n+    def resolve_expression(\n+        self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False\n+    ):\n+        \"\"\"\n+        Ensure condition is always resolved with for_save=False since it's used\n+        as a filter, not as an update value.\n+        \"\"\"",
        "comment_created_at": "2025-06-13T18:26:16+00:00",
        "comment_author": "cliff688",
        "comment_body": "Done \ud83d\udc4d\ud83c\udffe Also shortened the comment a bit",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1852376470",
    "pr_number": 18823,
    "pr_file": "tests/postgres_tests/test_search.py",
    "created_at": "2024-11-21T15:39:59+00:00",
    "commented_code": "transcript.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1852376470",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "tests/postgres_tests/test_search.py",
        "discussion_id": "1852376470",
        "commented_code": "@@ -6,13 +6,15 @@\n transcript.",
        "comment_created_at": "2024-11-21T15:39:59+00:00",
        "comment_author": "pauloxnet",
        "comment_body": "In this field I would remove empty lines and use docstring instead of comments to put valuable information.",
        "pr_file_module": null
      },
      {
        "comment_id": "1852675784",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "tests/postgres_tests/test_search.py",
        "discussion_id": "1852376470",
        "commented_code": "@@ -6,13 +6,15 @@\n transcript.",
        "comment_created_at": "2024-11-21T18:44:00+00:00",
        "comment_author": "GappleBee",
        "comment_body": "Thanks for simplifying the code (again), though I'm not sure about the empty lines being removed. Also, is this not already a docstring @pauloxnet ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1852821522",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "tests/postgres_tests/test_search.py",
        "discussion_id": "1852376470",
        "commented_code": "@@ -6,13 +6,15 @@\n transcript.",
        "comment_created_at": "2024-11-21T20:21:00+00:00",
        "comment_author": "pauloxnet",
        "comment_body": "Yes, your choice about empty lines.\r\n\r\nRelated to docstring I was referring to the whole file where I see some comments with valuable information that maybe you can transform as a docstring.",
        "pr_file_module": null
      },
      {
        "comment_id": "1854780433",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "tests/postgres_tests/test_search.py",
        "discussion_id": "1852376470",
        "commented_code": "@@ -6,13 +6,15 @@\n transcript.",
        "comment_created_at": "2024-11-22T22:03:30+00:00",
        "comment_author": "GappleBee",
        "comment_body": "```diff\r\n--- old.py\t2024-11-22 21:59:29.805397587 +0000\r\n+++ new.py\t2024-11-22 21:59:29.062897589 +0000\r\n@@ -1,6 +1,8 @@\r\n def test_advanced_invert(self):\r\n-    # Test inverting a query that uses a cominbation of & and |\r\n-    # Should return the opposite of test_advanced\r\n+    \"\"\"\r\n+    Test inverting a query that uses a cominbation of & and |\r\n+    Should return the opposite of test_advanced\r\n+    \"\"\"\r\n     searched = Line.objects.annotate(search=SearchVector(\"dialogue\")).filter(\r\n         search=SearchQuery(\r\n             ~(Lexeme(\"shall\") & Lexeme(\"use\") & Lexeme(\"larger\") | Lexeme(\"nostrils\"))\r\n```\r\n\r\nahh, I see, like these comments @pauloxnet ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1854781210",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "tests/postgres_tests/test_search.py",
        "discussion_id": "1852376470",
        "commented_code": "@@ -6,13 +6,15 @@\n transcript.",
        "comment_created_at": "2024-11-22T22:04:48+00:00",
        "comment_author": "pauloxnet",
        "comment_body": "Exactly \ud83d\udc4d\ud83c\udffb",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1847651022",
    "pr_number": 18769,
    "pr_file": "django/core/management/commands/listurls.py",
    "created_at": "2024-11-19T05:09:27+00:00",
    "commented_code": "+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1847651022",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-19T05:09:27+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Typically \"what\" comments are discouraged \ud83d\udc4d \r\n\r\nEdit: same goes for all the rest of the what comments in this PR :)",
        "pr_file_module": null
      },
      {
        "comment_id": "1847959325",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-19T09:17:55+00:00",
        "comment_author": "ulgens",
        "comment_body": "I'm not sure what counts as typical for similar cases, but in my experience, they provide great value as visual anchors and reduce the mental load when they are relevant and concise.",
        "pr_file_module": null
      },
      {
        "comment_id": "1848065596",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-19T10:23:12+00:00",
        "comment_author": "shangxiao",
        "comment_body": "I'll tell you what if you find your commenting style _prolifically present in the way you do it in this PR_ anywhere in the Django codebase (there are the occasional what comments) I'll gladly eat my words \ud83e\udd23 but it's highly likely that you'll be asked to remove them hence \"typically\". I don't have the final say that's up to the Django fellows...\r\n\r\nIn my experience what comments are just visual noise that end up diverging and become misleading or just outright incorrect.\r\n\r\nBut don't take my word for it: https://blog.codinghorror.com/code-tells-you-how-comments-tell-you-why/",
        "pr_file_module": null
      },
      {
        "comment_id": "1848087731",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-19T10:35:27+00:00",
        "comment_author": "ulgens",
        "comment_body": "@shangxiao Thanks for the details. I'll remove them if the consensus is not to have them, but I don't think that what that blog post describes applies here. Repeating the code in plan English is different from summarizing a code block by a short title. I was going for the second case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1848104808",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-19T10:47:04+00:00",
        "comment_author": "shangxiao",
        "comment_body": ">I was going for the second case.\r\n\r\nI argue this PR is not even the second case ;)",
        "pr_file_module": null
      },
      {
        "comment_id": "1848179387",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-19T11:32:20+00:00",
        "comment_author": "ulgens",
        "comment_body": "Thanks for the opinion.",
        "pr_file_module": null
      },
      {
        "comment_id": "1850453659",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-20T14:49:00+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "> I'll remove them if the consensus is not to have them\r\n\r\nPlease do not mark comments as resolved if there has been no agreement as it is difficult for other reviewers to reply.\r\n\r\nI agree these comments should be removed as the argument names and help text are descriptive enough and we do not add such comments for usages of `parser.add_argument` \r\n\r\nI would remove a lot of the comments in this PR",
        "pr_file_module": null
      },
      {
        "comment_id": "1852478608",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1847651022",
        "commented_code": "@@ -0,0 +1,275 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting",
        "comment_created_at": "2024-11-21T16:33:40+00:00",
        "comment_author": "ulgens",
        "comment_body": "I removed the comments from the `parser.add_argument()` blocks. I also tried removing the other seemingly redundant comments, but I think the code is better without them. Let me know if there are any other comments you think should be removed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2096771818",
    "pr_number": 19484,
    "pr_file": "tests/model_options/test_meta_caching.py",
    "created_at": "2025-05-20T02:57:17+00:00",
    "commented_code": "+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"model_options\")\n+class ForwardPropertiesCachingTests(SimpleTestCase):\n+    \"\"\"Tests FORWARD_PROPERTIES for Django's model metadata caching system.\"\"\"\n+\n+    def test_forward_properties_initialization(self):\n+        \"\"\"Test that FORWARD_PROPERTIES are properly initialized.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Verify that none of the FORWARD_PROPERTIES are in the __dict__ initially\n+        for prop in TestModel._meta.FORWARD_PROPERTIES:\n+            with self.subTest(property=prop):\n+                self.assertNotIn(prop, TestModel._meta.__dict__)\n+\n+    def test_forward_properties_access(self):\n+        \"\"\"Test that accessing a FORWARD_PROPERTY caches it in the __dict__.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Access each property and verify it's cached\n+        for prop in TestModel._meta.FORWARD_PROPERTIES:\n+            if hasattr(TestModel._meta, prop):\n+                with self.subTest(property=prop):\n+                    # Access the property to trigger caching\n+                    getattr(TestModel._meta, prop)\n+                    # Verify it's now in the __dict__\n+                    self.assertIn(prop, TestModel._meta.__dict__)\n+\n+    def test_expire_cache_forward_properties(self):\n+        \"\"\"Test that _expire_cache properly clears FORWARD_PROPERTIES.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        meta = TestModel._meta\n+\n+        # First, access some properties to cache them\n+        _ = meta.fields\n+        _ = meta.managers\n+\n+        # Verify they're cached\n+        self.assertIn(\"fields\", meta.__dict__)\n+        self.assertIn(\"managers\", meta.__dict__)\n+\n+        # Now expire the cache\n+        meta._expire_cache(forward=True, reverse=False)\n+\n+        # Verify the properties are no longer cached\n+        self.assertNotIn(\"fields\", meta.__dict__)\n+        self.assertNotIn(\"managers\", meta.__dict__)\n+\n+    def test_expire_cache_selective(self):\n+        \"\"\"Test that _expire_cache can selectively clear caches.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            parent = models.ForeignKey(\n+                \"self\", on_delete=models.CASCADE, null=True, related_name=\"children\"\n+            )\n+\n+        meta = TestModel._meta\n+\n+        # Access properties from both FORWARD_PROPERTIES and REVERSE_PROPERTIES\n+        _ = meta.fields  # forward\n+\n+        # Check if related_objects exists before accessing\n+        has_related_objects = hasattr(meta, \"related_objects\")\n+        if has_related_objects:\n+            _ = meta.related_objects\n+\n+        # Verify they're cached\n+        self.assertIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertIn(\"related_objects\", meta.__dict__)\n+\n+        # Selectively expire forward cache\n+        meta._expire_cache(forward=True, reverse=False)\n+\n+        # Verify forward properties are cleared but reverse properties remain\n+        self.assertNotIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertIn(\"related_objects\", meta.__dict__)\n+\n+        # Reaccess forward properties\n+        _ = meta.fields\n+        self.assertIn(\"fields\", meta.__dict__)\n+\n+        # Selectively expire reverse cache\n+        meta._expire_cache(forward=False, reverse=True)\n+\n+        # Verify forward properties remain but reverse properties are cleared\n+        self.assertIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertNotIn(\"related_objects\", meta.__dict__)\n+\n+    def test_model_inheritance_caching(self):\n+        \"\"\"Test that model inheritance properly handles property caching.\"\"\"",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2096771818",
        "repo_full_name": "django/django",
        "pr_number": 19484,
        "pr_file": "tests/model_options/test_meta_caching.py",
        "discussion_id": "2096771818",
        "commented_code": "@@ -0,0 +1,216 @@\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"model_options\")\n+class ForwardPropertiesCachingTests(SimpleTestCase):\n+    \"\"\"Tests FORWARD_PROPERTIES for Django's model metadata caching system.\"\"\"\n+\n+    def test_forward_properties_initialization(self):\n+        \"\"\"Test that FORWARD_PROPERTIES are properly initialized.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Verify that none of the FORWARD_PROPERTIES are in the __dict__ initially\n+        for prop in TestModel._meta.FORWARD_PROPERTIES:\n+            with self.subTest(property=prop):\n+                self.assertNotIn(prop, TestModel._meta.__dict__)\n+\n+    def test_forward_properties_access(self):\n+        \"\"\"Test that accessing a FORWARD_PROPERTY caches it in the __dict__.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Access each property and verify it's cached\n+        for prop in TestModel._meta.FORWARD_PROPERTIES:\n+            if hasattr(TestModel._meta, prop):\n+                with self.subTest(property=prop):\n+                    # Access the property to trigger caching\n+                    getattr(TestModel._meta, prop)\n+                    # Verify it's now in the __dict__\n+                    self.assertIn(prop, TestModel._meta.__dict__)\n+\n+    def test_expire_cache_forward_properties(self):\n+        \"\"\"Test that _expire_cache properly clears FORWARD_PROPERTIES.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        meta = TestModel._meta\n+\n+        # First, access some properties to cache them\n+        _ = meta.fields\n+        _ = meta.managers\n+\n+        # Verify they're cached\n+        self.assertIn(\"fields\", meta.__dict__)\n+        self.assertIn(\"managers\", meta.__dict__)\n+\n+        # Now expire the cache\n+        meta._expire_cache(forward=True, reverse=False)\n+\n+        # Verify the properties are no longer cached\n+        self.assertNotIn(\"fields\", meta.__dict__)\n+        self.assertNotIn(\"managers\", meta.__dict__)\n+\n+    def test_expire_cache_selective(self):\n+        \"\"\"Test that _expire_cache can selectively clear caches.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            parent = models.ForeignKey(\n+                \"self\", on_delete=models.CASCADE, null=True, related_name=\"children\"\n+            )\n+\n+        meta = TestModel._meta\n+\n+        # Access properties from both FORWARD_PROPERTIES and REVERSE_PROPERTIES\n+        _ = meta.fields  # forward\n+\n+        # Check if related_objects exists before accessing\n+        has_related_objects = hasattr(meta, \"related_objects\")\n+        if has_related_objects:\n+            _ = meta.related_objects\n+\n+        # Verify they're cached\n+        self.assertIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertIn(\"related_objects\", meta.__dict__)\n+\n+        # Selectively expire forward cache\n+        meta._expire_cache(forward=True, reverse=False)\n+\n+        # Verify forward properties are cleared but reverse properties remain\n+        self.assertNotIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertIn(\"related_objects\", meta.__dict__)\n+\n+        # Reaccess forward properties\n+        _ = meta.fields\n+        self.assertIn(\"fields\", meta.__dict__)\n+\n+        # Selectively expire reverse cache\n+        meta._expire_cache(forward=False, reverse=True)\n+\n+        # Verify forward properties remain but reverse properties are cleared\n+        self.assertIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertNotIn(\"related_objects\", meta.__dict__)\n+\n+    def test_model_inheritance_caching(self):\n+        \"\"\"Test that model inheritance properly handles property caching.\"\"\"",
        "comment_created_at": "2025-05-20T02:57:17+00:00",
        "comment_author": "jacobtylerwalls",
        "comment_body": "When docstrings communicate the same information as the test name (and the test name is sufficiently descriptive), we just chop them.",
        "pr_file_module": null
      },
      {
        "comment_id": "2097603307",
        "repo_full_name": "django/django",
        "pr_number": 19484,
        "pr_file": "tests/model_options/test_meta_caching.py",
        "discussion_id": "2096771818",
        "commented_code": "@@ -0,0 +1,216 @@\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"model_options\")\n+class ForwardPropertiesCachingTests(SimpleTestCase):\n+    \"\"\"Tests FORWARD_PROPERTIES for Django's model metadata caching system.\"\"\"\n+\n+    def test_forward_properties_initialization(self):\n+        \"\"\"Test that FORWARD_PROPERTIES are properly initialized.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Verify that none of the FORWARD_PROPERTIES are in the __dict__ initially\n+        for prop in TestModel._meta.FORWARD_PROPERTIES:\n+            with self.subTest(property=prop):\n+                self.assertNotIn(prop, TestModel._meta.__dict__)\n+\n+    def test_forward_properties_access(self):\n+        \"\"\"Test that accessing a FORWARD_PROPERTY caches it in the __dict__.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Access each property and verify it's cached\n+        for prop in TestModel._meta.FORWARD_PROPERTIES:\n+            if hasattr(TestModel._meta, prop):\n+                with self.subTest(property=prop):\n+                    # Access the property to trigger caching\n+                    getattr(TestModel._meta, prop)\n+                    # Verify it's now in the __dict__\n+                    self.assertIn(prop, TestModel._meta.__dict__)\n+\n+    def test_expire_cache_forward_properties(self):\n+        \"\"\"Test that _expire_cache properly clears FORWARD_PROPERTIES.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        meta = TestModel._meta\n+\n+        # First, access some properties to cache them\n+        _ = meta.fields\n+        _ = meta.managers\n+\n+        # Verify they're cached\n+        self.assertIn(\"fields\", meta.__dict__)\n+        self.assertIn(\"managers\", meta.__dict__)\n+\n+        # Now expire the cache\n+        meta._expire_cache(forward=True, reverse=False)\n+\n+        # Verify the properties are no longer cached\n+        self.assertNotIn(\"fields\", meta.__dict__)\n+        self.assertNotIn(\"managers\", meta.__dict__)\n+\n+    def test_expire_cache_selective(self):\n+        \"\"\"Test that _expire_cache can selectively clear caches.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+            parent = models.ForeignKey(\n+                \"self\", on_delete=models.CASCADE, null=True, related_name=\"children\"\n+            )\n+\n+        meta = TestModel._meta\n+\n+        # Access properties from both FORWARD_PROPERTIES and REVERSE_PROPERTIES\n+        _ = meta.fields  # forward\n+\n+        # Check if related_objects exists before accessing\n+        has_related_objects = hasattr(meta, \"related_objects\")\n+        if has_related_objects:\n+            _ = meta.related_objects\n+\n+        # Verify they're cached\n+        self.assertIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertIn(\"related_objects\", meta.__dict__)\n+\n+        # Selectively expire forward cache\n+        meta._expire_cache(forward=True, reverse=False)\n+\n+        # Verify forward properties are cleared but reverse properties remain\n+        self.assertNotIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertIn(\"related_objects\", meta.__dict__)\n+\n+        # Reaccess forward properties\n+        _ = meta.fields\n+        self.assertIn(\"fields\", meta.__dict__)\n+\n+        # Selectively expire reverse cache\n+        meta._expire_cache(forward=False, reverse=True)\n+\n+        # Verify forward properties remain but reverse properties are cleared\n+        self.assertIn(\"fields\", meta.__dict__)\n+        if has_related_objects:\n+            self.assertNotIn(\"related_objects\", meta.__dict__)\n+\n+    def test_model_inheritance_caching(self):\n+        \"\"\"Test that model inheritance properly handles property caching.\"\"\"",
        "comment_created_at": "2025-05-20T10:25:24+00:00",
        "comment_author": "jrsenthil-kumar2312",
        "comment_body": "Got it. Shall remove those unnecessary docstrings.",
        "pr_file_module": null
      }
    ]
  }
]