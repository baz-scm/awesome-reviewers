[
  {
    "discussion_id": "2160246058",
    "pr_number": 19580,
    "pr_file": "django/db/models/fields/__init__.py",
    "created_at": "2025-06-22T07:14:28+00:00",
    "commented_code": "something else than None, then the returned value is used when saving\n         the new instance.\n         \"\"\"\n-        if self.default:\n+        if self.default and self.default is not NOT_PROVIDED:",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2160246058",
        "repo_full_name": "django/django",
        "pr_number": 19580,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2160246058",
        "commented_code": "@@ -751,7 +751,7 @@ def get_pk_value_on_save(self, instance):\n         something else than None, then the returned value is used when saving\n         the new instance.\n         \"\"\"\n-        if self.default:\n+        if self.default and self.default is not NOT_PROVIDED:",
        "comment_created_at": "2025-06-22T07:14:28+00:00",
        "comment_author": "shangxiao",
        "comment_body": "I've got dejavu here, I feel like there was some previous discussion or work around `NOT_PROVIDED` here that I'm missing? \ud83e\udd14\r\n\r\nIf this is indeed something that needs to be patched I wonder whether there's a more direct test that could be written and along with it a separate ticket? \ud83e\udd14",
        "pr_file_module": null
      },
      {
        "comment_id": "2161450519",
        "repo_full_name": "django/django",
        "pr_number": 19580,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2160246058",
        "commented_code": "@@ -751,7 +751,7 @@ def get_pk_value_on_save(self, instance):\n         something else than None, then the returned value is used when saving\n         the new instance.\n         \"\"\"\n-        if self.default:\n+        if self.default and self.default is not NOT_PROVIDED:",
        "comment_created_at": "2025-06-23T12:01:44+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "Perhaps\r\n```suggestion\r\n        if self.has_default():\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1437037789",
    "pr_number": 16851,
    "pr_file": "django/db/backends/base/schema.py",
    "created_at": "2023-12-27T13:19:27+00:00",
    "commented_code": "new_name=self.quote_name(new_name),\n         )\n \n+    def _create_on_delete_sql(self, model, field):\n+        on_delete = getattr(field.remote_field, \"on_delete\", None)",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1437037789",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/schema.py",
        "discussion_id": "1437037789",
        "commented_code": "@@ -1579,6 +1582,12 @@ def _rename_index_sql(self, model, old_name, new_name):\n             new_name=self.quote_name(new_name),\n         )\n \n+    def _create_on_delete_sql(self, model, field):\n+        on_delete = getattr(field.remote_field, \"on_delete\", None)",
        "comment_created_at": "2023-12-27T13:19:27+00:00",
        "comment_author": "felixxm",
        "comment_body": "`on_delete` is required, do we need to use `getattr()`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1493807849",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/schema.py",
        "discussion_id": "1437037789",
        "commented_code": "@@ -1579,6 +1582,12 @@ def _rename_index_sql(self, model, old_name, new_name):\n             new_name=self.quote_name(new_name),\n         )\n \n+    def _create_on_delete_sql(self, model, field):\n+        on_delete = getattr(field.remote_field, \"on_delete\", None)",
        "comment_created_at": "2024-02-18T17:09:06+00:00",
        "comment_author": "Akash-Kumar-Sen",
        "comment_body": "Sometimes `field.remote_field` can be `None`, getting the following error when tried without `getattr`\r\n```\r\nERROR: test_remove_constraints_capital_letters (schema.tests.SchemaTests)\r\n#23065 - Constraint names must be quoted if they contain capital letters.\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"/usr/lib/python3.10/unittest/case.py\", line 59, in testPartExecutor\r\n    yield\r\n  File \"/usr/lib/python3.10/unittest/case.py\", line 591, in run\r\n    self._callTestMethod(testMethod)\r\n  File \"/usr/lib/python3.10/unittest/case.py\", line 549, in _callTestMethod\r\n    method()\r\n  File \"/home/akash/Djangocon/django/tests/schema/tests.py\", line 4474, in test_remove_constraints_capital_letters\r\n    \"on_delete_db\": editor._create_on_delete_sql(model, field),\r\n  File \"/home/akash/Djangocon/django/django/db/backends/base/schema.py\", line 1590, in _create_on_delete_sql\r\n    on_delete = field.remote_field.on_delete\r\nAttributeError: 'NoneType' object has no attribute 'on_delete'\r\n\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2128926282",
    "pr_number": 19503,
    "pr_file": "tests/queries/test_bulk_update.py",
    "created_at": "2025-06-05T13:56:43+00:00",
    "commented_code": "JSONFieldNullable.objects.filter(json_field__has_key=\"c\"), objs\n         )\n \n+    @skipUnlessDBFeature(\"supports_json_field\")\n+    def test_json_field_sql_null_value(self):\n+        \"\"\"\n+        Setting a JSONField to None results in SQL NULL.\n+        \"\"\"\n+        obj = JSONFieldNullable.objects.create(json_field={})\n+        obj.json_field = None\n+        JSONFieldNullable.objects.bulk_update([obj], fields=[\"json_field\"])\n+        obj.refresh_from_db()\n+        sql_null_qs = JSONFieldNullable.objects.filter(json_field__isnull=True)\n+        self.assertSequenceEqual(sql_null_qs, [obj])\n+\n+    @skipUnlessDBFeature(\"supports_json_field\")\n+    def test_json_field_json_null_value(self):\n+        \"\"\"\n+        Setting a JSONField to Value(None, output_field=JSONField()) results\n+        in a JSON null.\n+        \"\"\"\n+        obj = JSONFieldNullable.objects.create(json_field={})\n+        obj.json_field = Value(None, output_field=JSONField())\n+        JSONFieldNullable.objects.bulk_update([obj], fields=[\"json_field\"])\n+        obj.refresh_from_db()\n+        json_null_qs = JSONFieldNullable.objects.filter(\n+            json_field=Value(None, output_field=JSONField())",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2128926282",
        "repo_full_name": "django/django",
        "pr_number": 19503,
        "pr_file": "tests/queries/test_bulk_update.py",
        "discussion_id": "2128926282",
        "commented_code": "@@ -300,6 +300,33 @@ def test_json_field(self):\n             JSONFieldNullable.objects.filter(json_field__has_key=\"c\"), objs\n         )\n \n+    @skipUnlessDBFeature(\"supports_json_field\")\n+    def test_json_field_sql_null_value(self):\n+        \"\"\"\n+        Setting a JSONField to None results in SQL NULL.\n+        \"\"\"\n+        obj = JSONFieldNullable.objects.create(json_field={})\n+        obj.json_field = None\n+        JSONFieldNullable.objects.bulk_update([obj], fields=[\"json_field\"])\n+        obj.refresh_from_db()\n+        sql_null_qs = JSONFieldNullable.objects.filter(json_field__isnull=True)\n+        self.assertSequenceEqual(sql_null_qs, [obj])\n+\n+    @skipUnlessDBFeature(\"supports_json_field\")\n+    def test_json_field_json_null_value(self):\n+        \"\"\"\n+        Setting a JSONField to Value(None, output_field=JSONField()) results\n+        in a JSON null.\n+        \"\"\"\n+        obj = JSONFieldNullable.objects.create(json_field={})\n+        obj.json_field = Value(None, output_field=JSONField())\n+        JSONFieldNullable.objects.bulk_update([obj], fields=[\"json_field\"])\n+        obj.refresh_from_db()\n+        json_null_qs = JSONFieldNullable.objects.filter(\n+            json_field=Value(None, output_field=JSONField())",
        "comment_created_at": "2025-06-05T13:56:43+00:00",
        "comment_author": "charettes",
        "comment_body": "I _think_ this should work with\r\n\r\n```suggestion\r\n            json_field=None\r\n```\r\n\r\nas we differentiate `None` handling between saving and querying (yeah it's weird)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1917509162",
    "pr_number": 19012,
    "pr_file": "django/db/models/query.py",
    "created_at": "2025-01-16T00:34:06+00:00",
    "commented_code": "self._for_write = True\n         fields = [f for f in opts.concrete_fields if not f.generated]\n         objs = list(objs)\n+\n+        # Handle order_with_respect_to if present\n+        if order_wrt := self.model._meta.order_with_respect_to:\n+            get_filter_kwargs_for_object = order_wrt.get_filter_kwargs_for_object\n+            attnames = list(get_filter_kwargs_for_object(objs[0]).keys())\n+\n+            grouped_objects = {}\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, 'id') else value\n+                    for value in filter_kwargs.values()\n+                )\n+                grouped_objects.setdefault(group_key, []).append(obj)\n+\n+            filters = []\n+            for group_key in grouped_objects:\n+                filters.append(dict(zip(attnames, group_key)))\n+\n+            max_orders = (\n+                self.model._base_manager.using(self.db)\n+                .filter(reduce(operator.or_, (Q(**f) for f in filters)))",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1917509162",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "django/db/models/query.py",
        "discussion_id": "1917509162",
        "commented_code": "@@ -799,7 +800,52 @@ def bulk_create(\n         self._for_write = True\n         fields = [f for f in opts.concrete_fields if not f.generated]\n         objs = list(objs)\n+\n+        # Handle order_with_respect_to if present\n+        if order_wrt := self.model._meta.order_with_respect_to:\n+            get_filter_kwargs_for_object = order_wrt.get_filter_kwargs_for_object\n+            attnames = list(get_filter_kwargs_for_object(objs[0]).keys())\n+\n+            grouped_objects = {}\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, 'id') else value\n+                    for value in filter_kwargs.values()\n+                )\n+                grouped_objects.setdefault(group_key, []).append(obj)\n+\n+            filters = []\n+            for group_key in grouped_objects:\n+                filters.append(dict(zip(attnames, group_key)))\n+\n+            max_orders = (\n+                self.model._base_manager.using(self.db)\n+                .filter(reduce(operator.or_, (Q(**f) for f in filters)))",
        "comment_created_at": "2025-01-16T00:34:06+00:00",
        "comment_author": "charettes",
        "comment_body": "Reduce will fail if `filters` is an empty sequence. That means we likely want to gate the `if order_wrt := self.model._meta.order_with_respect_to:` with `if objs and (order_wrt := self.model._meta.order_with_respect_to):",
        "pr_file_module": null
      },
      {
        "comment_id": "1924950561",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "django/db/models/query.py",
        "discussion_id": "1917509162",
        "commented_code": "@@ -799,7 +800,52 @@ def bulk_create(\n         self._for_write = True\n         fields = [f for f in opts.concrete_fields if not f.generated]\n         objs = list(objs)\n+\n+        # Handle order_with_respect_to if present\n+        if order_wrt := self.model._meta.order_with_respect_to:\n+            get_filter_kwargs_for_object = order_wrt.get_filter_kwargs_for_object\n+            attnames = list(get_filter_kwargs_for_object(objs[0]).keys())\n+\n+            grouped_objects = {}\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, 'id') else value\n+                    for value in filter_kwargs.values()\n+                )\n+                grouped_objects.setdefault(group_key, []).append(obj)\n+\n+            filters = []\n+            for group_key in grouped_objects:\n+                filters.append(dict(zip(attnames, group_key)))\n+\n+            max_orders = (\n+                self.model._base_manager.using(self.db)\n+                .filter(reduce(operator.or_, (Q(**f) for f in filters)))",
        "comment_created_at": "2025-01-22T09:04:08+00:00",
        "comment_author": "myoungjinGo-BE",
        "comment_body": "Thank you, I added the `if objs`.",
        "pr_file_module": null
      }
    ]
  }
]