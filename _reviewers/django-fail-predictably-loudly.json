[
  {
    "discussion_id": "1828889142",
    "pr_number": 18627,
    "pr_file": "docs/topics/tasks.txt",
    "created_at": "2024-11-05T07:59:14+00:00",
    "commented_code": "+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.\n+\n+Modifying tasks\n+---------------\n+\n+Before enqueueing tasks, it may be necessary to modify certain parameters of the task.\n+For example, to give it a higher priority than it would normally.\n+\n+A ``Task`` instance cannot be modified directly. Instead, a modified instance\n+can be created with the :meth:`using <django.tasks.Task.using>` method, leaving\n+the original as-is::\n+\n+    calculate_meaning_of_life.priority  # 0\n+\n+    calculate_meaning_of_life.using(priority=10).priority  # 10\n+\n+``using`` allows modifying the following attributes:\n+\n+* :attr:`priority <django.tasks.Task.priority>`\n+* :attr:`backend <django.tasks.Task.backend>`\n+* :attr:`queue_name <django.tasks.Task.queue_name>`\n+* :attr:`run_after <django.tasks.Task.run_after>`\n+\n+``run_after`` may also be provided as a :class:`timedelta <datetime.timedelta>`,\n+which is used relative to the current time (when ``using`` is called), or a\n+timezone-aware :class:`datetime <datetime.datetime>`.\n+\n+Enqueueing tasks\n+================\n+\n+To add the task to the queue store, so it will be executed, call the ``enqueue``\n+method on it::\n+\n+    result = calculate_meaning_of_life.enqueue()\n+\n+Returned is a :class:`django.tasks.TaskResult`, which can be used to retrieve\n+the result of the task once it has finished executing.\n+\n+If the task takes arguments, these can be passed as-is to ``enqueue``::\n+\n+    result = calculate_meaning_of_life.enqueue(answer=42)\n+\n+To enqueue tasks in an ``async`` context, :meth:`aenqueue <django.tasks.Task.aenqueue>`\n+is available as an ``async`` variant of ``enqueue``.\n+\n+Transactions\n+------------\n+\n+By default, tasks are enqueued after the current transaction (if there is one)\n+commits successfully (using :meth:`transaction.on_commit <django.db.transaction.on_commit>`),\n+rather than enqueueing immediately.\n+\n+This behavior can be changed by changing the :setting:`TASKS-ENQUEUE_ON_COMMIT`\n+setting for the backend, or for a specific task using the ``enqueue_on_commit``\n+parameter.\n+\n+Task results\n+============\n+\n+When enqueueing a ``Task``, you receive a :class:`django.tasks.TaskResult`,\n+however it's likely useful to retrieve the result from somewhere else (for example\n+another request or another task).\n+\n+Each ``TaskResult`` has a unique :attr:`id <django.tasks.TaskResult.id>`, which\n+can be used to identify and retrieve the result once the code which enqueued the\n+task has finished.\n+\n+The :meth:`django.tasks.Task.get_result` method can retrieve a result based on\n+its ``id``::\n+\n+    # Later, somewhere else...\n+    result = calculate_meaning_of_life.get_result(result_id)\n+\n+If the ``TaskResult`` exists, it is returned. If it doesn't exist, or isn't a\n+result for ``calculate_meaning_of_life``, :exc:`django.tasks.exceptions.ResultDoesNotExist`\n+is raised.\n+\n+To retrieve a ``TaskResult``, regardless of which kind of ``Task`` it was from,\n+use the ``get_result`` method on the API\n+\n+To retrieve results in an ``async`` context, :meth:`aget_result <django.tasks.Task.aget_result>`\n+is available as an ``async`` variant of ``get_result`` on both the backend and ``Task``.\n+\n+Some backends, such as the built in ``ImmediateBackend`` do not support ``get_result``.\n+Calling ``get_result`` on these backends will raise :exc:`NotImplementedError`.\n+\n+Updating results\n+----------------\n+\n+A ``TaskResult`` contains the status of a task's execution at the point it was\n+retrieved. If the task finishes after ``get_result`` is called, it will not update.\n+\n+To refresh the values, call the :meth:`django.tasks.TaskResult.refresh` method::\n+\n+    result.status  # RUNNING\n+\n+    result.refresh()  # or await result.arefresh()\n+\n+    result.status  # COMPLETE\n+\n+Return values\n+-------------\n+\n+If your task function returns something, it can be retrieved from the\n+:attr:`django.tasks.TaskResult.return_value` attribute::\n+\n+    result.return_value  # 42\n+\n+If the task has not finished executing, or has failed, :exc:`ValueError` is raised.\n+\n+Exceptions\n+----------\n+\n+If the task doesn't complete successfully, and instead raises an exception, either\n+as part of the task or as part of running it, the exception instance is saved\n+to the :attr:`django.tasks.TaskResult.exception` attribute::\n+\n+    assert isinstance(result.exception, ValueError)\n+\n+As part of the serialization process for exceptions, some information is lost.\n+The traceback information is reduced to a string which you can use to help\n+debugging::\n+\n+    print(result.traceback)\n+\n+If the exception could not be serialized, ``exception`` is ``None``.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1828889142",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1828889142",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.\n+\n+Modifying tasks\n+---------------\n+\n+Before enqueueing tasks, it may be necessary to modify certain parameters of the task.\n+For example, to give it a higher priority than it would normally.\n+\n+A ``Task`` instance cannot be modified directly. Instead, a modified instance\n+can be created with the :meth:`using <django.tasks.Task.using>` method, leaving\n+the original as-is::\n+\n+    calculate_meaning_of_life.priority  # 0\n+\n+    calculate_meaning_of_life.using(priority=10).priority  # 10\n+\n+``using`` allows modifying the following attributes:\n+\n+* :attr:`priority <django.tasks.Task.priority>`\n+* :attr:`backend <django.tasks.Task.backend>`\n+* :attr:`queue_name <django.tasks.Task.queue_name>`\n+* :attr:`run_after <django.tasks.Task.run_after>`\n+\n+``run_after`` may also be provided as a :class:`timedelta <datetime.timedelta>`,\n+which is used relative to the current time (when ``using`` is called), or a\n+timezone-aware :class:`datetime <datetime.datetime>`.\n+\n+Enqueueing tasks\n+================\n+\n+To add the task to the queue store, so it will be executed, call the ``enqueue``\n+method on it::\n+\n+    result = calculate_meaning_of_life.enqueue()\n+\n+Returned is a :class:`django.tasks.TaskResult`, which can be used to retrieve\n+the result of the task once it has finished executing.\n+\n+If the task takes arguments, these can be passed as-is to ``enqueue``::\n+\n+    result = calculate_meaning_of_life.enqueue(answer=42)\n+\n+To enqueue tasks in an ``async`` context, :meth:`aenqueue <django.tasks.Task.aenqueue>`\n+is available as an ``async`` variant of ``enqueue``.\n+\n+Transactions\n+------------\n+\n+By default, tasks are enqueued after the current transaction (if there is one)\n+commits successfully (using :meth:`transaction.on_commit <django.db.transaction.on_commit>`),\n+rather than enqueueing immediately.\n+\n+This behavior can be changed by changing the :setting:`TASKS-ENQUEUE_ON_COMMIT`\n+setting for the backend, or for a specific task using the ``enqueue_on_commit``\n+parameter.\n+\n+Task results\n+============\n+\n+When enqueueing a ``Task``, you receive a :class:`django.tasks.TaskResult`,\n+however it's likely useful to retrieve the result from somewhere else (for example\n+another request or another task).\n+\n+Each ``TaskResult`` has a unique :attr:`id <django.tasks.TaskResult.id>`, which\n+can be used to identify and retrieve the result once the code which enqueued the\n+task has finished.\n+\n+The :meth:`django.tasks.Task.get_result` method can retrieve a result based on\n+its ``id``::\n+\n+    # Later, somewhere else...\n+    result = calculate_meaning_of_life.get_result(result_id)\n+\n+If the ``TaskResult`` exists, it is returned. If it doesn't exist, or isn't a\n+result for ``calculate_meaning_of_life``, :exc:`django.tasks.exceptions.ResultDoesNotExist`\n+is raised.\n+\n+To retrieve a ``TaskResult``, regardless of which kind of ``Task`` it was from,\n+use the ``get_result`` method on the API\n+\n+To retrieve results in an ``async`` context, :meth:`aget_result <django.tasks.Task.aget_result>`\n+is available as an ``async`` variant of ``get_result`` on both the backend and ``Task``.\n+\n+Some backends, such as the built in ``ImmediateBackend`` do not support ``get_result``.\n+Calling ``get_result`` on these backends will raise :exc:`NotImplementedError`.\n+\n+Updating results\n+----------------\n+\n+A ``TaskResult`` contains the status of a task's execution at the point it was\n+retrieved. If the task finishes after ``get_result`` is called, it will not update.\n+\n+To refresh the values, call the :meth:`django.tasks.TaskResult.refresh` method::\n+\n+    result.status  # RUNNING\n+\n+    result.refresh()  # or await result.arefresh()\n+\n+    result.status  # COMPLETE\n+\n+Return values\n+-------------\n+\n+If your task function returns something, it can be retrieved from the\n+:attr:`django.tasks.TaskResult.return_value` attribute::\n+\n+    result.return_value  # 42\n+\n+If the task has not finished executing, or has failed, :exc:`ValueError` is raised.\n+\n+Exceptions\n+----------\n+\n+If the task doesn't complete successfully, and instead raises an exception, either\n+as part of the task or as part of running it, the exception instance is saved\n+to the :attr:`django.tasks.TaskResult.exception` attribute::\n+\n+    assert isinstance(result.exception, ValueError)\n+\n+As part of the serialization process for exceptions, some information is lost.\n+The traceback information is reduced to a string which you can use to help\n+debugging::\n+\n+    print(result.traceback)\n+\n+If the exception could not be serialized, ``exception`` is ``None``.",
        "comment_created_at": "2024-11-05T07:59:14+00:00",
        "comment_author": "rtpg",
        "comment_body": "I think in practice people will check `result.status`, but I think that `result.exception` should throw or something if you try to look at it when the result is not in a `FAILED` status",
        "pr_file_module": null
      },
      {
        "comment_id": "1850617275",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1828889142",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.\n+\n+Modifying tasks\n+---------------\n+\n+Before enqueueing tasks, it may be necessary to modify certain parameters of the task.\n+For example, to give it a higher priority than it would normally.\n+\n+A ``Task`` instance cannot be modified directly. Instead, a modified instance\n+can be created with the :meth:`using <django.tasks.Task.using>` method, leaving\n+the original as-is::\n+\n+    calculate_meaning_of_life.priority  # 0\n+\n+    calculate_meaning_of_life.using(priority=10).priority  # 10\n+\n+``using`` allows modifying the following attributes:\n+\n+* :attr:`priority <django.tasks.Task.priority>`\n+* :attr:`backend <django.tasks.Task.backend>`\n+* :attr:`queue_name <django.tasks.Task.queue_name>`\n+* :attr:`run_after <django.tasks.Task.run_after>`\n+\n+``run_after`` may also be provided as a :class:`timedelta <datetime.timedelta>`,\n+which is used relative to the current time (when ``using`` is called), or a\n+timezone-aware :class:`datetime <datetime.datetime>`.\n+\n+Enqueueing tasks\n+================\n+\n+To add the task to the queue store, so it will be executed, call the ``enqueue``\n+method on it::\n+\n+    result = calculate_meaning_of_life.enqueue()\n+\n+Returned is a :class:`django.tasks.TaskResult`, which can be used to retrieve\n+the result of the task once it has finished executing.\n+\n+If the task takes arguments, these can be passed as-is to ``enqueue``::\n+\n+    result = calculate_meaning_of_life.enqueue(answer=42)\n+\n+To enqueue tasks in an ``async`` context, :meth:`aenqueue <django.tasks.Task.aenqueue>`\n+is available as an ``async`` variant of ``enqueue``.\n+\n+Transactions\n+------------\n+\n+By default, tasks are enqueued after the current transaction (if there is one)\n+commits successfully (using :meth:`transaction.on_commit <django.db.transaction.on_commit>`),\n+rather than enqueueing immediately.\n+\n+This behavior can be changed by changing the :setting:`TASKS-ENQUEUE_ON_COMMIT`\n+setting for the backend, or for a specific task using the ``enqueue_on_commit``\n+parameter.\n+\n+Task results\n+============\n+\n+When enqueueing a ``Task``, you receive a :class:`django.tasks.TaskResult`,\n+however it's likely useful to retrieve the result from somewhere else (for example\n+another request or another task).\n+\n+Each ``TaskResult`` has a unique :attr:`id <django.tasks.TaskResult.id>`, which\n+can be used to identify and retrieve the result once the code which enqueued the\n+task has finished.\n+\n+The :meth:`django.tasks.Task.get_result` method can retrieve a result based on\n+its ``id``::\n+\n+    # Later, somewhere else...\n+    result = calculate_meaning_of_life.get_result(result_id)\n+\n+If the ``TaskResult`` exists, it is returned. If it doesn't exist, or isn't a\n+result for ``calculate_meaning_of_life``, :exc:`django.tasks.exceptions.ResultDoesNotExist`\n+is raised.\n+\n+To retrieve a ``TaskResult``, regardless of which kind of ``Task`` it was from,\n+use the ``get_result`` method on the API\n+\n+To retrieve results in an ``async`` context, :meth:`aget_result <django.tasks.Task.aget_result>`\n+is available as an ``async`` variant of ``get_result`` on both the backend and ``Task``.\n+\n+Some backends, such as the built in ``ImmediateBackend`` do not support ``get_result``.\n+Calling ``get_result`` on these backends will raise :exc:`NotImplementedError`.\n+\n+Updating results\n+----------------\n+\n+A ``TaskResult`` contains the status of a task's execution at the point it was\n+retrieved. If the task finishes after ``get_result`` is called, it will not update.\n+\n+To refresh the values, call the :meth:`django.tasks.TaskResult.refresh` method::\n+\n+    result.status  # RUNNING\n+\n+    result.refresh()  # or await result.arefresh()\n+\n+    result.status  # COMPLETE\n+\n+Return values\n+-------------\n+\n+If your task function returns something, it can be retrieved from the\n+:attr:`django.tasks.TaskResult.return_value` attribute::\n+\n+    result.return_value  # 42\n+\n+If the task has not finished executing, or has failed, :exc:`ValueError` is raised.\n+\n+Exceptions\n+----------\n+\n+If the task doesn't complete successfully, and instead raises an exception, either\n+as part of the task or as part of running it, the exception instance is saved\n+to the :attr:`django.tasks.TaskResult.exception` attribute::\n+\n+    assert isinstance(result.exception, ValueError)\n+\n+As part of the serialization process for exceptions, some information is lost.\n+The traceback information is reduced to a string which you can use to help\n+debugging::\n+\n+    print(result.traceback)\n+\n+If the exception could not be serialized, ``exception`` is ``None``.",
        "comment_created_at": "2024-11-20T16:19:46+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "Interesting idea. I'm generally not a fan of _loud_ APIs, but I think if we want to ensure people don't misuse the API, now is the time to make APIs loud.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1830864784",
    "pr_number": 18627,
    "pr_file": "docs/topics/tasks.txt",
    "created_at": "2024-11-06T11:31:57+00:00",
    "commented_code": "+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.\n+\n+Modifying tasks\n+---------------\n+\n+Before enqueueing tasks, it may be necessary to modify certain parameters of the task.\n+For example, to give it a higher priority than it would normally.\n+\n+A ``Task`` instance cannot be modified directly. Instead, a modified instance\n+can be created with the :meth:`using <django.tasks.Task.using>` method, leaving\n+the original as-is::\n+\n+    calculate_meaning_of_life.priority  # 0\n+\n+    calculate_meaning_of_life.using(priority=10).priority  # 10\n+\n+``using`` allows modifying the following attributes:\n+\n+* :attr:`priority <django.tasks.Task.priority>`\n+* :attr:`backend <django.tasks.Task.backend>`\n+* :attr:`queue_name <django.tasks.Task.queue_name>`\n+* :attr:`run_after <django.tasks.Task.run_after>`\n+\n+``run_after`` may also be provided as a :class:`timedelta <datetime.timedelta>`,\n+which is used relative to the current time (when ``using`` is called), or a",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1830864784",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1830864784",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.\n+\n+Modifying tasks\n+---------------\n+\n+Before enqueueing tasks, it may be necessary to modify certain parameters of the task.\n+For example, to give it a higher priority than it would normally.\n+\n+A ``Task`` instance cannot be modified directly. Instead, a modified instance\n+can be created with the :meth:`using <django.tasks.Task.using>` method, leaving\n+the original as-is::\n+\n+    calculate_meaning_of_life.priority  # 0\n+\n+    calculate_meaning_of_life.using(priority=10).priority  # 10\n+\n+``using`` allows modifying the following attributes:\n+\n+* :attr:`priority <django.tasks.Task.priority>`\n+* :attr:`backend <django.tasks.Task.backend>`\n+* :attr:`queue_name <django.tasks.Task.queue_name>`\n+* :attr:`run_after <django.tasks.Task.run_after>`\n+\n+``run_after`` may also be provided as a :class:`timedelta <datetime.timedelta>`,\n+which is used relative to the current time (when ``using`` is called), or a",
        "comment_created_at": "2024-11-06T11:31:57+00:00",
        "comment_author": "rtpg",
        "comment_body": "The `timedelta` functionality with `using` feels like an easy mistake in the making if it's going to be resolved at the `using` call.\r\n\r\nWould it not be possible for, when `run_after` is set to a `timedelta`, the actual delay to be resolved from when we call the `enqueue` time?\r\n\r\nOf course alternatively, there's just \"users have to do `timezone.now() + my_delta`\"",
        "pr_file_module": null
      },
      {
        "comment_id": "1850669731",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1830864784",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.\n+\n+Modifying tasks\n+---------------\n+\n+Before enqueueing tasks, it may be necessary to modify certain parameters of the task.\n+For example, to give it a higher priority than it would normally.\n+\n+A ``Task`` instance cannot be modified directly. Instead, a modified instance\n+can be created with the :meth:`using <django.tasks.Task.using>` method, leaving\n+the original as-is::\n+\n+    calculate_meaning_of_life.priority  # 0\n+\n+    calculate_meaning_of_life.using(priority=10).priority  # 10\n+\n+``using`` allows modifying the following attributes:\n+\n+* :attr:`priority <django.tasks.Task.priority>`\n+* :attr:`backend <django.tasks.Task.backend>`\n+* :attr:`queue_name <django.tasks.Task.queue_name>`\n+* :attr:`run_after <django.tasks.Task.run_after>`\n+\n+``run_after`` may also be provided as a :class:`timedelta <datetime.timedelta>`,\n+which is used relative to the current time (when ``using`` is called), or a",
        "comment_created_at": "2024-11-20T16:49:57+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "Using `timedelta` was a convenience. I agree it could be surprising, and probably wants documenting.\r\n\r\nI'll leave this comment here as to whether others think it's a useful API to have, or not worth the footgun.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161383176",
    "pr_number": 18966,
    "pr_file": "docs/topics/email.txt",
    "created_at": "2025-06-23T11:27:09+00:00",
    "commented_code": "recipients will not raise an exception. It will return ``1`` if the message\n   was sent successfully, otherwise ``0``.\n \n-* ``message()`` constructs a ``django.core.mail.SafeMIMEText`` object (a\n-  subclass of Python's :class:`~email.mime.text.MIMEText` class) or a\n-  ``django.core.mail.SafeMIMEMultipart`` object holding the message to be\n-  sent. If you ever need to extend the\n-  :class:`~django.core.mail.EmailMessage` class, you'll probably want to\n-  override this method to put the content you want into the MIME object.\n+* ``message(policy=email.policy.default)`` constructs and returns a Python\n+  :class:`email.message.EmailMessage` object using the specified policy,\n+  representing the message to be sent.\n+\n+  If you ever need to extend Django's :class:`~django.core.mail.EmailMessage`\n+  class, you'll probably want to override this method to put the content you\n+  want into Python EmailMessage object.\n+\n+  .. versionchanged:: 6.0\n+\n+      Added the ``policy`` argument and updated the method to return\n+      a modern Python :py:class:`~email.message.EmailMessage`.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2161383176",
        "repo_full_name": "django/django",
        "pr_number": 18966,
        "pr_file": "docs/topics/email.txt",
        "discussion_id": "2161383176",
        "commented_code": "@@ -362,12 +378,18 @@ The class has the following methods:\n   recipients will not raise an exception. It will return ``1`` if the message\n   was sent successfully, otherwise ``0``.\n \n-* ``message()`` constructs a ``django.core.mail.SafeMIMEText`` object (a\n-  subclass of Python's :class:`~email.mime.text.MIMEText` class) or a\n-  ``django.core.mail.SafeMIMEMultipart`` object holding the message to be\n-  sent. If you ever need to extend the\n-  :class:`~django.core.mail.EmailMessage` class, you'll probably want to\n-  override this method to put the content you want into the MIME object.\n+* ``message(policy=email.policy.default)`` constructs and returns a Python\n+  :class:`email.message.EmailMessage` object using the specified policy,\n+  representing the message to be sent.\n+\n+  If you ever need to extend Django's :class:`~django.core.mail.EmailMessage`\n+  class, you'll probably want to override this method to put the content you\n+  want into Python EmailMessage object.\n+\n+  .. versionchanged:: 6.0\n+\n+      Added the ``policy`` argument and updated the method to return\n+      a modern Python :py:class:`~email.message.EmailMessage`.",
        "comment_created_at": "2025-06-23T11:27:09+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "That the return type of a documented function has changed feels like a breaking change (especially as there is a note about overwriting this in the docs). \r\nWe might want to have a way for folks to opt-in/out to the return format (and that this opt-in/out method is deprecated). ",
        "pr_file_module": null
      },
      {
        "comment_id": "2165162614",
        "repo_full_name": "django/django",
        "pr_number": 18966,
        "pr_file": "docs/topics/email.txt",
        "discussion_id": "2161383176",
        "commented_code": "@@ -362,12 +378,18 @@ The class has the following methods:\n   recipients will not raise an exception. It will return ``1`` if the message\n   was sent successfully, otherwise ``0``.\n \n-* ``message()`` constructs a ``django.core.mail.SafeMIMEText`` object (a\n-  subclass of Python's :class:`~email.mime.text.MIMEText` class) or a\n-  ``django.core.mail.SafeMIMEMultipart`` object holding the message to be\n-  sent. If you ever need to extend the\n-  :class:`~django.core.mail.EmailMessage` class, you'll probably want to\n-  override this method to put the content you want into the MIME object.\n+* ``message(policy=email.policy.default)`` constructs and returns a Python\n+  :class:`email.message.EmailMessage` object using the specified policy,\n+  representing the message to be sent.\n+\n+  If you ever need to extend Django's :class:`~django.core.mail.EmailMessage`\n+  class, you'll probably want to override this method to put the content you\n+  want into Python EmailMessage object.\n+\n+  .. versionchanged:: 6.0\n+\n+      Added the ``policy`` argument and updated the method to return\n+      a modern Python :py:class:`~email.message.EmailMessage`.",
        "comment_created_at": "2025-06-25T00:02:17+00:00",
        "comment_author": "medmunds",
        "comment_body": "> We might want to have a way for folks to opt-in/out to the return format (and that this opt-in/out method is deprecated).\r\n\r\nHmm, the old return format is \"a `django.core.mail.SafeMIMEText` object (a subclass of Python\u2019s `MIMEText` class) or a `django.core.mail.SafeMIMEMultipart` object.\" \r\n\r\nThat is also the total extent of Django's documentation for those classes.\r\n\r\nAs part of the django-developers discussion last year, I looked into [how SafeMIMEText and SafeMIMEMultipart are being used](https://groups.google.com/g/django-developers/c/2zf9GQtjdIk/m/mKqz2OKtAAAJ#:~:text=SafeMIMEText%20and%20SafeMIMEMultipart,email.message.Message%5D) in public codebases. As the return value of EmailMessage.message(), usage was either:\r\n- For type checking\r\n- To call documented methods of Python's email.message.Message (primarily `as_bytes()`)\r\n\r\nemail.message.Message is the root class of all legacy MIME\\* classes *and* modern email.message.EmailMessage, so existing code using documented APIs should continue to work with the new return type. (Other than varying constructor args, there are no documented APIs on MIMEText or any of its base classes until you get to email.message.Message.)\r\n\r\nSo an opt-in for the old return type seems relevant only for type checking usage. There are a few approaches we could consider:\r\n- In django.core.mail, set (deprecated) SafeMIMEText = SafeMIMEMultipart = email.message.EmailMessage. This would make type checking strictly accurate for the new return type. But it would also break a lot of real world code that uses the SafeMIME classes off label (mainly to safely construct attachments to pass to EmailMessage.attach()).\r\n- Change the documented return type of EmailMessage.message() to email.message.Message in Django 6.0, and make no other changes for now. Wait until Django 7.0 to land this PR.\r\n- Add a setting or EmailMessage option that opts into/out of the old SafeMIME objects. I worry that would involve a substantial reworking of this PR to offer both code paths in parallel. (Maybe you had a better approach in mind?)\r\n- Suggest that django-stubs declare the return type of EmailMessage.message() to be email.message.Message, which is accurate both before and after this PR.\r\n\r\nSince Django doesn't officially support type checking, my preference would be the last one.",
        "pr_file_module": null
      },
      {
        "comment_id": "2165591343",
        "repo_full_name": "django/django",
        "pr_number": 18966,
        "pr_file": "docs/topics/email.txt",
        "discussion_id": "2161383176",
        "commented_code": "@@ -362,12 +378,18 @@ The class has the following methods:\n   recipients will not raise an exception. It will return ``1`` if the message\n   was sent successfully, otherwise ``0``.\n \n-* ``message()`` constructs a ``django.core.mail.SafeMIMEText`` object (a\n-  subclass of Python's :class:`~email.mime.text.MIMEText` class) or a\n-  ``django.core.mail.SafeMIMEMultipart`` object holding the message to be\n-  sent. If you ever need to extend the\n-  :class:`~django.core.mail.EmailMessage` class, you'll probably want to\n-  override this method to put the content you want into the MIME object.\n+* ``message(policy=email.policy.default)`` constructs and returns a Python\n+  :class:`email.message.EmailMessage` object using the specified policy,\n+  representing the message to be sent.\n+\n+  If you ever need to extend Django's :class:`~django.core.mail.EmailMessage`\n+  class, you'll probably want to override this method to put the content you\n+  want into Python EmailMessage object.\n+\n+  .. versionchanged:: 6.0\n+\n+      Added the ``policy`` argument and updated the method to return\n+      a modern Python :py:class:`~email.message.EmailMessage`.",
        "comment_created_at": "2025-06-25T03:42:15+00:00",
        "comment_author": "medmunds",
        "comment_body": "Ugh, sorry, here's a much shorter version of what I wanted to say:\r\n\r\nThe new return type of EmailMessage.message() supports *all* of the documented behavior of the old return type, with one exception: isinstance(SafeMIMEText) won't be true for the new return type.\r\n\r\nIn my public code search last year, I don't recall seeing any usage of isinstance() checks on  EmailMessage.message() return values. And the ways I can think to maintain isinstance() compatibility would either break a lot of code I *did* see that uses the SafeMIME classes for other (albeit undocumented) purposes, or would involve maintaining two versions of EmailMessage.message() and everything below it.\r\n\r\n(Maybe I should mention in the release notes that Python's email.message.EmailMessage supports the same API as SafeMIMEText and SafeMIMEMultipart?)",
        "pr_file_module": null
      },
      {
        "comment_id": "2169985558",
        "repo_full_name": "django/django",
        "pr_number": 18966,
        "pr_file": "docs/topics/email.txt",
        "discussion_id": "2161383176",
        "commented_code": "@@ -362,12 +378,18 @@ The class has the following methods:\n   recipients will not raise an exception. It will return ``1`` if the message\n   was sent successfully, otherwise ``0``.\n \n-* ``message()`` constructs a ``django.core.mail.SafeMIMEText`` object (a\n-  subclass of Python's :class:`~email.mime.text.MIMEText` class) or a\n-  ``django.core.mail.SafeMIMEMultipart`` object holding the message to be\n-  sent. If you ever need to extend the\n-  :class:`~django.core.mail.EmailMessage` class, you'll probably want to\n-  override this method to put the content you want into the MIME object.\n+* ``message(policy=email.policy.default)`` constructs and returns a Python\n+  :class:`email.message.EmailMessage` object using the specified policy,\n+  representing the message to be sent.\n+\n+  If you ever need to extend Django's :class:`~django.core.mail.EmailMessage`\n+  class, you'll probably want to override this method to put the content you\n+  want into Python EmailMessage object.\n+\n+  .. versionchanged:: 6.0\n+\n+      Added the ``policy`` argument and updated the method to return\n+      a modern Python :py:class:`~email.message.EmailMessage`.",
        "comment_created_at": "2025-06-26T20:51:07+00:00",
        "comment_author": "medmunds",
        "comment_body": "(I've updated the 6.0 release notes with this information.)",
        "pr_file_module": null
      }
    ]
  }
]