[
  {
    "discussion_id": "2087858362",
    "pr_number": 19459,
    "pr_file": "django/db/models/fields/tuple_lookups.py",
    "created_at": "2025-05-14T01:05:35+00:00",
    "commented_code": "return super().as_sql(compiler, connection)\n \n \n+class TupleComparisonMixin:\n+    def as_oracle(self, compiler, connection):",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2087858362",
        "repo_full_name": "django/django",
        "pr_number": 19459,
        "pr_file": "django/db/models/fields/tuple_lookups.py",
        "discussion_id": "2087858362",
        "commented_code": "@@ -129,6 +130,20 @@ def as_sql(self, compiler, connection):\n         return super().as_sql(compiler, connection)\n \n \n+class TupleComparisonMixin:\n+    def as_oracle(self, compiler, connection):",
        "comment_created_at": "2025-05-14T01:05:35+00:00",
        "comment_author": "charettes",
        "comment_body": "I think it'd be preferable to use a feature flag instead as I wouldn't be surprised if other backends are in the same boat. Maybe `supports_tuple_comparison_subquery`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1909401888",
    "pr_number": 18638,
    "pr_file": "tests/gis_tests/geoapp/test_functions.py",
    "created_at": "2025-01-09T20:36:41+00:00",
    "commented_code": ")\n         self.assertSequenceEqual(City.objects.filter(point__isempty=True), [empty])\n \n+    @skipUnlessDBFeature(\"has_IsEmpty_function\")\n+    def test_isempty_null_geometry(self):\n+        null_geometry = Town.objects.create(name=\"Nowhere\", point=None)\n+        Town.objects.create(name=\"Somewhere\", point=Point(6.825, 47.1, srid=4326))\n+        if connection.ops.spatialite:",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1909401888",
        "repo_full_name": "django/django",
        "pr_number": 18638,
        "pr_file": "tests/gis_tests/geoapp/test_functions.py",
        "discussion_id": "1909401888",
        "commented_code": "@@ -424,6 +432,29 @@ def test_isempty(self):\n         )\n         self.assertSequenceEqual(City.objects.filter(point__isempty=True), [empty])\n \n+    @skipUnlessDBFeature(\"has_IsEmpty_function\")\n+    def test_isempty_null_geometry(self):\n+        null_geometry = Town.objects.create(name=\"Nowhere\", point=None)\n+        Town.objects.create(name=\"Somewhere\", point=Point(6.825, 47.1, srid=4326))\n+        if connection.ops.spatialite:",
        "comment_created_at": "2025-01-09T20:36:41+00:00",
        "comment_author": "nessita",
        "comment_body": "I was wondering if instead of doing `if connection.ops.spatialite` we shouldn't add a new feature flag `empty_geometry_is_null` and check for that here? It feels a bit cleaner to not check for a specific backend.\r\n\r\n@claudep @felixxm Do you have an opinion on the new flag? is it a bit overkill?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1928990853",
    "pr_number": 19097,
    "pr_file": "tests/db_functions/json/test_json_array.py",
    "created_at": "2025-01-24T17:01:59+00:00",
    "commented_code": ")\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1928990853",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:01:59+00:00",
        "comment_author": "charettes",
        "comment_body": "I think we should keep a feature flag for this as other backends might be in the same boat and we'd want to raise `NotSupportedError` when it's the case.",
        "pr_file_module": null
      },
      {
        "comment_id": "1928993052",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:03:51+00:00",
        "comment_author": "john-parton",
        "comment_body": "I assume you mean 3rd party backends? Or backends we might add in the future?\r\n\r\nBoth?",
        "pr_file_module": null
      },
      {
        "comment_id": "1928994754",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:05:22+00:00",
        "comment_author": "charettes",
        "comment_body": "yes, third party backends heavily rely on feature flags to denote what they support and don't. It's also just better practice to use feature flags for these as it makes adding and remove support (e.g. assuming we find a problem on Oracle post-release) less invasive and vendor specific.",
        "pr_file_module": null
      },
      {
        "comment_id": "1928996833",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:07:20+00:00",
        "comment_author": "john-parton",
        "comment_body": "Makes sense. I don't want to bikeshed to much on what the specific feature flag should be called. I was trying to avoid that discussion completely, tbh.\r\n\r\nTwo candidates:\r\n\r\n* `supports_json_absent_on_null`\r\n* `supports_json_array_absent_on_null`\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1928999215",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:09:24+00:00",
        "comment_author": "charettes",
        "comment_body": "Do any backends support `ABSENT ON NULL` on `JSON_ARRAY` but not other JSON functions such as `JSON_ARRAYAGG`, and `JSON_OBJECT`? If not `supports_json_absent_on_null` seems like the best candidate.",
        "pr_file_module": null
      },
      {
        "comment_id": "1929004560",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:14:09+00:00",
        "comment_author": "john-parton",
        "comment_body": "I think it would depend on whether a workaround is _possible_.\r\n\r\nWithout exhaustively going through all the database backends, it might not be possible to sanely implement the functionality using whatever database-specific concatenation features are available.\r\n\r\nI think this is going to be vary in difficulty depending on the backend.",
        "pr_file_module": null
      },
      {
        "comment_id": "1929005608",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:15:07+00:00",
        "comment_author": "john-parton",
        "comment_body": "So for instance, if a workaround isn't possible for JSON_OBJECT using MySQL, and we just have one shared feature flag, then we'll be in a bit of a mismatched situation if we want to implement `absent_on_null` for JsonObject.",
        "pr_file_module": null
      },
      {
        "comment_id": "1929006827",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:16:14+00:00",
        "comment_author": "charettes",
        "comment_body": "That would be to backends to figure out then and request distinct `supports_json_[type]_absent_on_null` feature flags if they run into this problem.\r\n\r\nOtherwise they'd implement their own `as_vendor` methods and enable the flag.\r\n\r\nTo `supports_json_absent_on_null` seems like a reasonable start.",
        "pr_file_module": null
      },
      {
        "comment_id": "1929008099",
        "repo_full_name": "django/django",
        "pr_number": 19097,
        "pr_file": "tests/db_functions/json/test_json_array.py",
        "discussion_id": "1928990853",
        "commented_code": "@@ -107,6 +108,51 @@ def test_order_by_nested_key(self):\n         )\n         self.assertQuerySetEqual(qs, Author.objects.order_by(\"-alias\"))\n \n+    def test_null_on_null(self):\n+        obj = Author.objects.annotate(\n+            arr=JSONArray(F(\"goes_by\"), absent_on_null=False)\n+        ).first()\n+\n+        self.assertEqual(obj.arr, [None])\n+\n+    @unittest.skipUnless(\n+        connection.vendor == \"sqlite\",\n+        \"SQLite does not support ABSENT ON NULL.\",\n+    )\n+    def test_absent_on_null_not_supported(self):\n+        msg = \"SQLite does not support ABSENT ON NULL.\"\n+        with self.assertRaisesMessage(NotSupportedError, msg):\n+            Author.objects.annotate(\n+                arr=JSONArray(F(\"goes_by\"), absent_on_null=True)\n+            ).first()\n+\n+\n+@unittest.skipIf(\n+    connection.vendor == \"sqlite\",\n+    \"SQLite does not support ABSENT ON NULL.\",\n+)",
        "comment_created_at": "2025-01-24T17:17:18+00:00",
        "comment_author": "john-parton",
        "comment_body": "That's a sane position, I think. I'll refactor.",
        "pr_file_module": null
      }
    ]
  }
]