[
  {
    "discussion_id": "2166985292",
    "pr_number": 19145,
    "pr_file": "django/utils/deprecation.py",
    "created_at": "2025-06-25T15:15:23+00:00",
    "commented_code": "return new_class\n \n \n+def deprecate_posargs(category, *, moved):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the `*`\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    `moved` must be a list of the formerly positional-or-keyword parameters\n+    that are now keyword-only, in their original positional order.\n+\n+    After the deprecation period, remove the decorator (but keep the `*`)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new _positional_\n+    parameters or change the remaining (un-moved) ones. This attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new _keyword-only_ parameters and to re-order\n+    the existing ones (so long as `moved` remains in the original order).\n+    This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in moved\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() `moved` names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_moveable_args = len(moved)\n+        max_positional_args = num_positional_params + num_moveable_args\n+\n+        param_names = list(params.keys())\n+\n+        # The deprecation message logic needs to know if func is a bound method.\n+        # Because decorators always receive plain, unbound functions, the class\n+        # information is not available here. (inspect.ismethod(func) will always\n+        # return False, and func.__self__ will never be set.) This only affects\n+        # message construction, not argument mapping logic, so it's fine to just\n+        # look for the customary bound parameter names.\n+        num_bound_params = 1 if param_names[0] in (\"self\", \"cls\") else 0\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            try:\n+                local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+                class_name = local_name.replace(\".__init__\", \"\")\n+            except (AttributeError, IndexError, TypeError):\n+                # __init__ outside a class or other oddity. The __name__ is fine.\n+                pass\n+            else:\n+                func_name = class_name\n+\n+        if num_positional_params > num_bound_params:\n+            # Clarify that only \"some\" (not all) positional arguments are affected.\n+            message_template = (\n+                \"Use of some positional arguments is deprecated.\"",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2166985292",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2166985292",
        "commented_code": "@@ -83,6 +85,204 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(category, *, moved):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the `*`\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    `moved` must be a list of the formerly positional-or-keyword parameters\n+    that are now keyword-only, in their original positional order.\n+\n+    After the deprecation period, remove the decorator (but keep the `*`)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new _positional_\n+    parameters or change the remaining (un-moved) ones. This attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new _keyword-only_ parameters and to re-order\n+    the existing ones (so long as `moved` remains in the original order).\n+    This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in moved\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() `moved` names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_moveable_args = len(moved)\n+        max_positional_args = num_positional_params + num_moveable_args\n+\n+        param_names = list(params.keys())\n+\n+        # The deprecation message logic needs to know if func is a bound method.\n+        # Because decorators always receive plain, unbound functions, the class\n+        # information is not available here. (inspect.ismethod(func) will always\n+        # return False, and func.__self__ will never be set.) This only affects\n+        # message construction, not argument mapping logic, so it's fine to just\n+        # look for the customary bound parameter names.\n+        num_bound_params = 1 if param_names[0] in (\"self\", \"cls\") else 0\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            try:\n+                local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+                class_name = local_name.replace(\".__init__\", \"\")\n+            except (AttributeError, IndexError, TypeError):\n+                # __init__ outside a class or other oddity. The __name__ is fine.\n+                pass\n+            else:\n+                func_name = class_name\n+\n+        if num_positional_params > num_bound_params:\n+            # Clarify that only \"some\" (not all) positional arguments are affected.\n+            message_template = (\n+                \"Use of some positional arguments is deprecated.\"",
        "comment_created_at": "2025-06-25T15:15:23+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "Similar to previous format. I suppose something like `\"Passing positional arguments (arg1, arg2) to {func_name}() is deprecated.\"` might work here. Doesn't have to be specific to point out what they have wrong\r\n\r\nNote that looking at our previous deprecations, I don't think we have ever not made everything keyword only",
        "pr_file_module": null
      },
      {
        "comment_id": "2167302580",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2166985292",
        "commented_code": "@@ -83,6 +85,204 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(category, *, moved):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the `*`\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    `moved` must be a list of the formerly positional-or-keyword parameters\n+    that are now keyword-only, in their original positional order.\n+\n+    After the deprecation period, remove the decorator (but keep the `*`)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new _positional_\n+    parameters or change the remaining (un-moved) ones. This attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new _keyword-only_ parameters and to re-order\n+    the existing ones (so long as `moved` remains in the original order).\n+    This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in moved\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() `moved` names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_moveable_args = len(moved)\n+        max_positional_args = num_positional_params + num_moveable_args\n+\n+        param_names = list(params.keys())\n+\n+        # The deprecation message logic needs to know if func is a bound method.\n+        # Because decorators always receive plain, unbound functions, the class\n+        # information is not available here. (inspect.ismethod(func) will always\n+        # return False, and func.__self__ will never be set.) This only affects\n+        # message construction, not argument mapping logic, so it's fine to just\n+        # look for the customary bound parameter names.\n+        num_bound_params = 1 if param_names[0] in (\"self\", \"cls\") else 0\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            try:\n+                local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+                class_name = local_name.replace(\".__init__\", \"\")\n+            except (AttributeError, IndexError, TypeError):\n+                # __init__ outside a class or other oddity. The __name__ is fine.\n+                pass\n+            else:\n+                func_name = class_name\n+\n+        if num_positional_params > num_bound_params:\n+            # Clarify that only \"some\" (not all) positional arguments are affected.\n+            message_template = (\n+                \"Use of some positional arguments is deprecated.\"",
        "comment_created_at": "2025-06-25T17:59:10+00:00",
        "comment_author": "medmunds",
        "comment_body": "The django.core.mail changes will retain some positional-or-keyword params. (There's too much code in the wild that uses posargs for the initial four-ish params\u2014including a lot of Django's own tests.)\r\n\r\nCommit 3665c68 in #19186 shows the decorator in use, and might be helpful for thinking about the messaging.\r\n\r\nI think it's useful to list the specific param names that are affected in the user's code (rather all possible affected names).\r\n\r\nI agree showing the proposed change isn't all that helpful. (And it might actually be confusing.) I think we should still mention \"keyword args\" to clarify that the *feature* isn't deprecated, only the syntax for using it has changed.\r\n\r\n```python\r\nsend_mail(\"subject\", \"body\", \"from@example.com\", \r\n          [\"to@example.com\"], True, \"user\", \"password\")\r\n\r\nemail = EmailMessage(\"subject\", \"body\", \"from@example.com\", \r\n                     [\"to@example.com\"], [\"bcc@example.com\"])\r\n```\r\n\r\nMy suggested wording:\r\n> Passing positional arguments fail_silently, auth_user, auth_password to send_mail() is deprecated. Change them to keyword args.\r\n> \r\n> Passing positional argument bcc to EmailMessage() is deprecated. Change it to a keyword arg.`\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2168291739",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2166985292",
        "commented_code": "@@ -83,6 +85,204 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(category, *, moved):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the `*`\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    `moved` must be a list of the formerly positional-or-keyword parameters\n+    that are now keyword-only, in their original positional order.\n+\n+    After the deprecation period, remove the decorator (but keep the `*`)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new _positional_\n+    parameters or change the remaining (un-moved) ones. This attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new _keyword-only_ parameters and to re-order\n+    the existing ones (so long as `moved` remains in the original order).\n+    This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in moved\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() `moved` names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_moveable_args = len(moved)\n+        max_positional_args = num_positional_params + num_moveable_args\n+\n+        param_names = list(params.keys())\n+\n+        # The deprecation message logic needs to know if func is a bound method.\n+        # Because decorators always receive plain, unbound functions, the class\n+        # information is not available here. (inspect.ismethod(func) will always\n+        # return False, and func.__self__ will never be set.) This only affects\n+        # message construction, not argument mapping logic, so it's fine to just\n+        # look for the customary bound parameter names.\n+        num_bound_params = 1 if param_names[0] in (\"self\", \"cls\") else 0\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            try:\n+                local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+                class_name = local_name.replace(\".__init__\", \"\")\n+            except (AttributeError, IndexError, TypeError):\n+                # __init__ outside a class or other oddity. The __name__ is fine.\n+                pass\n+            else:\n+                func_name = class_name\n+\n+        if num_positional_params > num_bound_params:\n+            # Clarify that only \"some\" (not all) positional arguments are affected.\n+            message_template = (\n+                \"Use of some positional arguments is deprecated.\"",
        "comment_created_at": "2025-06-26T06:46:58+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "Looks good to me :+1: ",
        "pr_file_module": null
      },
      {
        "comment_id": "2169799215",
        "repo_full_name": "django/django",
        "pr_number": 19145,
        "pr_file": "django/utils/deprecation.py",
        "discussion_id": "2166985292",
        "commented_code": "@@ -83,6 +85,204 @@ def __new__(cls, name, bases, attrs):\n         return new_class\n \n \n+def deprecate_posargs(category, *, moved):\n+    \"\"\"\n+    Function/method decorator to deprecate some or all positional arguments.\n+    The decorated function will map any positional arguments after the `*`\n+    to the corresponding keyword arguments and issue a deprecation warning.\n+\n+    Works on both functions and methods. To apply to a class constructor,\n+    decorate its __init__() method. To apply to a staticmethod or classmethod,\n+    use @deprecate_posargs after @staticmethod or @classmethod.\n+\n+    Example: to deprecate passing option1 or option2 as posargs, change::\n+\n+        def some_func(request, option1, option2=True):\n+            ...\n+\n+    to::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    `moved` must be a list of the formerly positional-or-keyword parameters\n+    that are now keyword-only, in their original positional order.\n+\n+    After the deprecation period, remove the decorator (but keep the `*`)::\n+\n+        def some_func(request, *, option1, option2=True):\n+            ...\n+\n+    Caution: during the deprecation period, do not add any new _positional_\n+    parameters or change the remaining (un-moved) ones. This attempt to add\n+    a new param would break code using the deprecated option posargs::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, wrong_new_param=None, *, option1, option2=True):\n+            # Broken: existing code may set wrong_new_param to option1's value.\n+            ...\n+\n+    However, it's acceptable to add new _keyword-only_ parameters and to re-order\n+    the existing ones (so long as `moved` remains in the original order).\n+    This change will work without breaking existing code::\n+\n+        @deprecate_posargs(RemovedInDjangoXXWarning, moved=[\"option1\", \"option2\"])\n+        def some_func(request, *, new_param=None, option2=True, option1):\n+            ...\n+\n+    The @deprecate_posargs decorator adds a small amount of overhead. In most cases\n+    it won't be significant, but use with care in performance-critical code paths.\n+    \"\"\"\n+\n+    def decorator(func):\n+        if isinstance(func, type):\n+            raise TypeError(\n+                \"@deprecate_posargs cannot be applied to a class.\"\n+                \" (Apply it to the __init__ method.)\"\n+            )\n+        if isinstance(func, classmethod):\n+            raise TypeError(\"Apply @classmethod before @deprecate_posargs.\")\n+        if isinstance(func, staticmethod):\n+            raise TypeError(\"Apply @staticmethod before @deprecate_posargs.\")\n+\n+        params = inspect.signature(func).parameters\n+        num_by_kind = Counter(param.kind for param in params.values())\n+\n+        if num_by_kind[inspect.Parameter.VAR_POSITIONAL] > 0:\n+            raise TypeError(\n+                \"@deprecate_posargs() cannot be used with variable positional `*args`.\"\n+            )\n+\n+        num_positional_params = (\n+            num_by_kind[inspect.Parameter.POSITIONAL_ONLY]\n+            + num_by_kind[inspect.Parameter.POSITIONAL_OR_KEYWORD]\n+        )\n+        num_keyword_only_params = num_by_kind[inspect.Parameter.KEYWORD_ONLY]\n+        if num_keyword_only_params < 1:\n+            raise TypeError(\n+                \"@deprecate_posargs() requires at least one keyword-only parameter\"\n+                \" (after a `*` entry in the parameters list).\"\n+            )\n+        if any(\n+            name not in params or params[name].kind != inspect.Parameter.KEYWORD_ONLY\n+            for name in moved\n+        ):\n+            raise TypeError(\n+                \"@deprecate_posargs() `moved` names must\"\n+                \" all be keyword-only parameters.\"\n+            )\n+\n+        num_moveable_args = len(moved)\n+        max_positional_args = num_positional_params + num_moveable_args\n+\n+        param_names = list(params.keys())\n+\n+        # The deprecation message logic needs to know if func is a bound method.\n+        # Because decorators always receive plain, unbound functions, the class\n+        # information is not available here. (inspect.ismethod(func) will always\n+        # return False, and func.__self__ will never be set.) This only affects\n+        # message construction, not argument mapping logic, so it's fine to just\n+        # look for the customary bound parameter names.\n+        num_bound_params = 1 if param_names[0] in (\"self\", \"cls\") else 0\n+        func_name = func.__name__\n+        if func_name == \"__init__\":\n+            # In the warning, show \"ClassName(...)\" rather than \"__init__(...)\".\n+            # The class isn't defined yet, but its name is in __qualname__.\n+            # Some examples: \"ClassName.__init__\", \"Nested.ClassName.__init__\",\n+            # \"MyTests.test_case.<locals>.ClassName.__init__\".\n+            try:\n+                local_name = func.__qualname__.rsplit(\"<locals>.\", 1)[-1]\n+                class_name = local_name.replace(\".__init__\", \"\")\n+            except (AttributeError, IndexError, TypeError):\n+                # __init__ outside a class or other oddity. The __name__ is fine.\n+                pass\n+            else:\n+                func_name = class_name\n+\n+        if num_positional_params > num_bound_params:\n+            # Clarify that only \"some\" (not all) positional arguments are affected.\n+            message_template = (\n+                \"Use of some positional arguments is deprecated.\"",
        "comment_created_at": "2025-06-26T19:20:01+00:00",
        "comment_author": "medmunds",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2136143466",
    "pr_number": 19529,
    "pr_file": "django/contrib/gis/gdal/prototypes/generation.py",
    "created_at": "2025-06-09T17:23:56+00:00",
    "commented_code": null,
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2136143466",
        "repo_full_name": "django/django",
        "pr_number": 19529,
        "pr_file": "django/contrib/gis/gdal/prototypes/generation.py",
        "discussion_id": "2136143466",
        "commented_code": null,
        "comment_created_at": "2025-06-09T17:23:56+00:00",
        "comment_author": "joshuadavidthomas",
        "comment_body": "One question I do have (that I obliquely referenced in the PR description) - what level of API stability should we be aiming for? \r\n\r\nShould these be renamed back to snake_case so the only change to this module would be the laziness of the function calls? Or is the rename to PascalCase for class conventions okay? Does that even really matter? Should the old snake_case names be put behind a deprecation warning?",
        "pr_file_module": null
      },
      {
        "comment_id": "2158896601",
        "repo_full_name": "django/django",
        "pr_number": 19529,
        "pr_file": "django/contrib/gis/gdal/prototypes/generation.py",
        "discussion_id": "2136143466",
        "commented_code": null,
        "comment_created_at": "2025-06-20T12:53:19+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "Good question\r\nSeems similar changes were made in 61d09e61f5747d7a70268ca8d5e770486877500b without a deprecation\r\nDid a code search on github and found maybe 2 usages of these that seemed valid (by the same person quite a long time ago). I think at the very least we should add a release note in the backwards incompatible changes",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1959666193",
    "pr_number": 19172,
    "pr_file": "django/contrib/admin/views/main.py",
    "created_at": "2025-02-18T12:36:25+00:00",
    "commented_code": "full_result_count = self.root_queryset.count()\n         else:\n             full_result_count = None\n-        can_show_all = result_count <= self.list_max_show_all\n-        multi_page = result_count > self.list_per_page\n-\n-        # Get the list of objects to display on this page.\n-        if (self.show_all and can_show_all) or not multi_page:\n-            result_list = self.queryset._clone()\n-        else:\n-            try:\n-                result_list = paginator.page(self.page_num).object_list\n-            except InvalidPage:\n-                raise IncorrectLookupParameters\n-\n-        self.result_count = result_count\n         self.show_full_result_count = self.model_admin.show_full_result_count\n         # Admin actions are shown if there is at least one entry\n         # or if entries are not counted because show_full_result_count is disabled\n         self.show_admin_actions = not self.show_full_result_count or bool(\n             full_result_count\n         )\n         self.full_result_count = full_result_count\n-        self.result_list = result_list\n-        self.can_show_all = can_show_all",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1959666193",
        "repo_full_name": "django/django",
        "pr_number": 19172,
        "pr_file": "django/contrib/admin/views/main.py",
        "discussion_id": "1959666193",
        "commented_code": "@@ -307,30 +290,16 @@ def get_results(self, request):\n             full_result_count = self.root_queryset.count()\n         else:\n             full_result_count = None\n-        can_show_all = result_count <= self.list_max_show_all\n-        multi_page = result_count > self.list_per_page\n-\n-        # Get the list of objects to display on this page.\n-        if (self.show_all and can_show_all) or not multi_page:\n-            result_list = self.queryset._clone()\n-        else:\n-            try:\n-                result_list = paginator.page(self.page_num).object_list\n-            except InvalidPage:\n-                raise IncorrectLookupParameters\n-\n-        self.result_count = result_count\n         self.show_full_result_count = self.model_admin.show_full_result_count\n         # Admin actions are shown if there is at least one entry\n         # or if entries are not counted because show_full_result_count is disabled\n         self.show_admin_actions = not self.show_full_result_count or bool(\n             full_result_count\n         )\n         self.full_result_count = full_result_count\n-        self.result_list = result_list\n-        self.can_show_all = can_show_all",
        "comment_created_at": "2025-02-18T12:36:25+00:00",
        "comment_author": "nanuxbe",
        "comment_body": "The API of `get_results` is being changed here.\r\nIf this is the final approach, I don't see an issue with the change itself but we need to deprecate this properly:\r\nie:\r\n- deprecation warning\r\n- a workaround to populate the old properties while the deprecation is active",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2130422564",
    "pr_number": 19507,
    "pr_file": "django/http/request.py",
    "created_at": "2025-06-05T21:17:19+00:00",
    "commented_code": "def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2130422564",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2130422564",
        "commented_code": "@@ -705,23 +710,45 @@ def __str__(self):\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
        "comment_created_at": "2025-06-05T21:17:19+00:00",
        "comment_author": "andersk",
        "comment_body": "This was a breaking change for user code that was using `media_type.params.get(\"q\")` (e.g., [Zulip](https://github.com/zulip/zulip/blob/b6f111cc0c9c5958a0f8b3d35245f7b6581c027d/zerver/views/upload.py#L204)). That code can now be rewritten using `media_type.quality`, but only in Django \u2265 5.2. Can we restore `q` to the `params` dictionary?",
        "pr_file_module": null
      },
      {
        "comment_id": "2130631497",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2130422564",
        "commented_code": "@@ -705,23 +710,45 @@ def __str__(self):\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
        "comment_created_at": "2025-06-05T22:13:12+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "`MediaType` isn't part of the public API. The `q` param is special.\r\n\r\nCould the linked code there could be replaced with `request.get_preferred_types`? That would mitigate this. Alternatively,  a small shim of `getattr(media_quality, \"quality\", media_quality.params.get(\"q\"))`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2130810000",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2130422564",
        "commented_code": "@@ -705,23 +710,45 @@ def __str__(self):\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
        "comment_created_at": "2025-06-05T23:00:19+00:00",
        "comment_author": "andersk",
        "comment_body": "It\u2019s frustrating to have my own fixes rejected for changing non-public APIs (#18393), when they get unnecessarily broken like this even in stable patch releases. Couldn\u2019t we have done this without changing `params`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2131652695",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2130422564",
        "commented_code": "@@ -705,23 +710,45 @@ def __str__(self):\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
        "comment_created_at": "2025-06-06T07:17:44+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "I think this will not be too hard to do and something we can support.\r\n\r\nLooking at the RFC:\r\n\r\n> Each media-range might be followed by optional applicable media type parameters (e.g., [charset](https://httpwg.org/specs/rfc9110.html#charset)), followed by an optional \"q\" parameter for indicating a relative weight ([Section 12.4.2](https://httpwg.org/specs/rfc9110.html#quality.values)).\r\n\r\nPerhaps we should have `MediaType.params` which include `q` and `MediaType.type_params` which doesn't include `q`\r\n\r\n@andersk can you create a ticket so we don't lose any discussion in a PR?",
        "pr_file_module": null
      },
      {
        "comment_id": "2131839659",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2130422564",
        "commented_code": "@@ -705,23 +710,45 @@ def __str__(self):\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
        "comment_created_at": "2025-06-06T09:14:08+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "> Perhaps we should have MediaType.params which include q and MediaType.type_params which doesn't include q\r\n\r\nThat idea sounds great to me! Happy to get an implementation together once there's a ticket.",
        "pr_file_module": null
      },
      {
        "comment_id": "2132819284",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2130422564",
        "commented_code": "@@ -705,23 +710,45 @@ def __str__(self):\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
        "comment_created_at": "2025-06-06T19:43:43+00:00",
        "comment_author": "andersk",
        "comment_body": "Opened https://code.djangoproject.com/ticket/36446.",
        "pr_file_module": null
      },
      {
        "comment_id": "2135886973",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2130422564",
        "commented_code": "@@ -705,23 +710,45 @@ def __str__(self):\n     def __repr__(self):\n         return \"<%s: %s>\" % (self.__class__.__qualname__, self)\n \n-    @property\n-    def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)",
        "comment_created_at": "2025-06-09T14:58:20+00:00",
        "comment_author": "nessita",
        "comment_body": "I accepted the ticket and set it to be a release blocker. I have created https://github.com/django/django/pull/19548 to solve this.\r\n\r\nI chose a slightly different name for the new property: `range_params`. I think this name matches better the spec, and also \"MediaType.type_params\" felt a bit redundant.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2107815577",
    "pr_number": 19438,
    "pr_file": "django/db/models/query.py",
    "created_at": "2025-05-26T20:08:36+00:00",
    "commented_code": "else:\n             self._query.add_q(Q(*args, **kwargs))\n \n-    def complex_filter(self, filter_obj):",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2107815577",
        "repo_full_name": "django/django",
        "pr_number": 19438,
        "pr_file": "django/db/models/query.py",
        "discussion_id": "2107815577",
        "commented_code": "@@ -1513,23 +1513,6 @@ def _filter_or_exclude_inplace(self, negate, args, kwargs):\n         else:\n             self._query.add_q(Q(*args, **kwargs))\n \n-    def complex_filter(self, filter_obj):",
        "comment_created_at": "2025-05-26T20:08:36+00:00",
        "comment_author": "charettes",
        "comment_body": "Should we leave a deprecation shim around? This function has been around forever (it predated support for `Q` IIRC) so even if it's not part of the public API we should consider adding a shim.",
        "pr_file_module": null
      }
    ]
  }
]