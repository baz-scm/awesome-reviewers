[
  {
    "discussion_id": "2191308766",
    "pr_number": 17554,
    "pr_file": "django/contrib/contenttypes/fields.py",
    "created_at": "2025-07-08T01:44:59+00:00",
    "commented_code": "except ObjectDoesNotExist:\n                 pass\n         self.field.set_cached_value(instance, rel_obj)\n-        return rel_obj\n+\n+    def fetch_many(self, instances):\n+        missing_instances = [i for i in instances if not self.field.is_cached(i)]",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2191308766",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "django/contrib/contenttypes/fields.py",
        "discussion_id": "2191308766",
        "commented_code": "@@ -257,7 +267,10 @@ def __get__(self, instance, cls=None):\n             except ObjectDoesNotExist:\n                 pass\n         self.field.set_cached_value(instance, rel_obj)\n-        return rel_obj\n+\n+    def fetch_many(self, instances):\n+        missing_instances = [i for i in instances if not self.field.is_cached(i)]",
        "comment_created_at": "2025-07-08T01:44:59+00:00",
        "comment_author": "charettes",
        "comment_body": "Minor but it might be worth using a local reference for `self.field.is_cached` to avoid two attribute lookups per instance in a potentially large loop\r\n\r\n```python\r\nis_cached = self.field.is_cache\r\nmissing_instances = [i for i in instances if not is_cached(i)]\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1939280045",
    "pr_number": 18627,
    "pr_file": "django/tasks/utils.py",
    "created_at": "2025-02-03T12:14:58+00:00",
    "commented_code": "+import inspect\n+import json\n+import random\n+import time\n+from functools import wraps\n+from traceback import format_exception\n+\n+from django.utils.crypto import RANDOM_STRING_CHARS\n+\n+\n+def is_module_level_function(func):\n+    if not inspect.isfunction(func) or inspect.isbuiltin(func):\n+        return False\n+\n+    if \"<locals>\" in func.__qualname__:\n+        return False\n+\n+    return True\n+\n+\n+def json_normalize(obj):\n+    \"\"\"\n+    Round-trip encode object as JSON to normalize types.\n+    \"\"\"\n+    return json.loads(json.dumps(obj))\n+\n+\n+def retry(*, retries=3, backoff_delay=0.1):\n+    \"\"\"\n+    Retry the given code `retries` times, raising the final error.\n+\n+    `backoff_delay` can be used to add a delay between attempts.\n+    \"\"\"\n+\n+    def wrapper(f):\n+        @wraps(f)\n+        def inner_wrapper(*args, **kwargs):\n+            for attempt in range(1, retries + 1):\n+                try:\n+                    return f(*args, **kwargs)\n+                except KeyboardInterrupt:\n+                    # Let the user ctrl-C out of the program without a retry\n+                    raise\n+                except BaseException:\n+                    if attempt == retries:\n+                        raise\n+                    time.sleep(backoff_delay)\n+\n+        return inner_wrapper\n+\n+    return wrapper\n+\n+\n+def get_exception_traceback(exc):\n+    return \"\".join(format_exception(type(exc), exc, exc.__traceback__))\n+\n+\n+def get_module_path(val):\n+    return f\"{val.__module__}.{val.__qualname__}\"\n+\n+\n+def get_random_id():\n+    \"\"\"\n+    Return a random string for use as a task id.\n+\n+    Whilst 64 characters is the max, just use 32 as a sensible middle-ground.\n+\n+    This should be much faster than `get_random_string`, since",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1939280045",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "django/tasks/utils.py",
        "discussion_id": "1939280045",
        "commented_code": "@@ -0,0 +1,71 @@\n+import inspect\n+import json\n+import random\n+import time\n+from functools import wraps\n+from traceback import format_exception\n+\n+from django.utils.crypto import RANDOM_STRING_CHARS\n+\n+\n+def is_module_level_function(func):\n+    if not inspect.isfunction(func) or inspect.isbuiltin(func):\n+        return False\n+\n+    if \"<locals>\" in func.__qualname__:\n+        return False\n+\n+    return True\n+\n+\n+def json_normalize(obj):\n+    \"\"\"\n+    Round-trip encode object as JSON to normalize types.\n+    \"\"\"\n+    return json.loads(json.dumps(obj))\n+\n+\n+def retry(*, retries=3, backoff_delay=0.1):\n+    \"\"\"\n+    Retry the given code `retries` times, raising the final error.\n+\n+    `backoff_delay` can be used to add a delay between attempts.\n+    \"\"\"\n+\n+    def wrapper(f):\n+        @wraps(f)\n+        def inner_wrapper(*args, **kwargs):\n+            for attempt in range(1, retries + 1):\n+                try:\n+                    return f(*args, **kwargs)\n+                except KeyboardInterrupt:\n+                    # Let the user ctrl-C out of the program without a retry\n+                    raise\n+                except BaseException:\n+                    if attempt == retries:\n+                        raise\n+                    time.sleep(backoff_delay)\n+\n+        return inner_wrapper\n+\n+    return wrapper\n+\n+\n+def get_exception_traceback(exc):\n+    return \"\".join(format_exception(type(exc), exc, exc.__traceback__))\n+\n+\n+def get_module_path(val):\n+    return f\"{val.__module__}.{val.__qualname__}\"\n+\n+\n+def get_random_id():\n+    \"\"\"\n+    Return a random string for use as a task id.\n+\n+    Whilst 64 characters is the max, just use 32 as a sensible middle-ground.\n+\n+    This should be much faster than `get_random_string`, since",
        "comment_created_at": "2025-02-03T12:14:58+00:00",
        "comment_author": "bluetech",
        "comment_body": "I didn't measure but I'd be surprised if there's a meaningful time difference. I'd go with `get_random_string`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2172368163",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "django/tasks/utils.py",
        "discussion_id": "1939280045",
        "commented_code": "@@ -0,0 +1,71 @@\n+import inspect\n+import json\n+import random\n+import time\n+from functools import wraps\n+from traceback import format_exception\n+\n+from django.utils.crypto import RANDOM_STRING_CHARS\n+\n+\n+def is_module_level_function(func):\n+    if not inspect.isfunction(func) or inspect.isbuiltin(func):\n+        return False\n+\n+    if \"<locals>\" in func.__qualname__:\n+        return False\n+\n+    return True\n+\n+\n+def json_normalize(obj):\n+    \"\"\"\n+    Round-trip encode object as JSON to normalize types.\n+    \"\"\"\n+    return json.loads(json.dumps(obj))\n+\n+\n+def retry(*, retries=3, backoff_delay=0.1):\n+    \"\"\"\n+    Retry the given code `retries` times, raising the final error.\n+\n+    `backoff_delay` can be used to add a delay between attempts.\n+    \"\"\"\n+\n+    def wrapper(f):\n+        @wraps(f)\n+        def inner_wrapper(*args, **kwargs):\n+            for attempt in range(1, retries + 1):\n+                try:\n+                    return f(*args, **kwargs)\n+                except KeyboardInterrupt:\n+                    # Let the user ctrl-C out of the program without a retry\n+                    raise\n+                except BaseException:\n+                    if attempt == retries:\n+                        raise\n+                    time.sleep(backoff_delay)\n+\n+        return inner_wrapper\n+\n+    return wrapper\n+\n+\n+def get_exception_traceback(exc):\n+    return \"\".join(format_exception(type(exc), exc, exc.__traceback__))\n+\n+\n+def get_module_path(val):\n+    return f\"{val.__module__}.{val.__qualname__}\"\n+\n+\n+def get_random_id():\n+    \"\"\"\n+    Return a random string for use as a task id.\n+\n+    Whilst 64 characters is the max, just use 32 as a sensible middle-ground.\n+\n+    This should be much faster than `get_random_string`, since",
        "comment_created_at": "2025-06-27T16:15:25+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "```\r\nIn [4]: %timeit get_random_string(32)\r\n56.1 μs ± 2.17 μs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)\r\n\r\nIn [5]: %timeit get_random_id()\r\n2.99 μs ± 107 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)\r\n```\r\n\r\nIt's a fair bit faster, but on the scale of it really not mattering. I agree let's just use `get_random_string`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174581068",
    "pr_number": 19187,
    "pr_file": "django/db/models/sql/query.py",
    "created_at": "2025-06-30T09:00:27+00:00",
    "commented_code": "return alias or seen[None]\n \n     def check_alias(self, alias):\n+        # RemovedInDjango70Warning: When the deprecation ends, remove.\n+        if \"%\" in alias:\n+            if \"aggregate\" in {frame.function for frame in inspect.stack()}:",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2174581068",
        "repo_full_name": "django/django",
        "pr_number": 19187,
        "pr_file": "django/db/models/sql/query.py",
        "discussion_id": "2174581068",
        "commented_code": "@@ -1206,9 +1213,23 @@ def join_parent_model(self, opts, model, alias, seen):\n         return alias or seen[None]\n \n     def check_alias(self, alias):\n+        # RemovedInDjango70Warning: When the deprecation ends, remove.\n+        if \"%\" in alias:\n+            if \"aggregate\" in {frame.function for frame in inspect.stack()}:",
        "comment_created_at": "2025-06-30T09:00:27+00:00",
        "comment_author": "adamchainz",
        "comment_body": "`inspect.stack()` is slow because it materializes all stack frames into a list - nearly 1ms on my machine. Here, I think we really only care about the function name at frame N-5, right? If so, can we replace this with:\r\n\r\n```py\r\nframe = inspect.currentframe()\r\nfor _ in range(5):\r\n    try:\r\n        frame = frame.f_back\r\n    except AttributeError:\r\n        break\r\nelse:\r\n    is_aggregate = 'aggregate' in frame.function\r\ndel frame\r\n\r\nif is_aggregate:\r\n    ...\r\n```\r\n\r\nIf you agree but don't have time, I'm happy to open up a PR myself.",
        "pr_file_module": null
      },
      {
        "comment_id": "2175056745",
        "repo_full_name": "django/django",
        "pr_number": 19187,
        "pr_file": "django/db/models/sql/query.py",
        "discussion_id": "2174581068",
        "commented_code": "@@ -1206,9 +1213,23 @@ def join_parent_model(self, opts, model, alias, seen):\n         return alias or seen[None]\n \n     def check_alias(self, alias):\n+        # RemovedInDjango70Warning: When the deprecation ends, remove.\n+        if \"%\" in alias:\n+            if \"aggregate\" in {frame.function for frame in inspect.stack()}:",
        "comment_created_at": "2025-06-30T13:17:54+00:00",
        "comment_author": "charettes",
        "comment_body": "Given `main` is Python 3.12+ this seems like a good use case of `skip_file_prefixes=os.path.dirname(django.__file__)` instead to avoid the brittle `stacklevel` arithmetic.\r\n\r\nI assume `warnings.warn(skip_file_prefixes)` avoids materializing the full stack trace by itself.",
        "pr_file_module": null
      },
      {
        "comment_id": "2176115714",
        "repo_full_name": "django/django",
        "pr_number": 19187,
        "pr_file": "django/db/models/sql/query.py",
        "discussion_id": "2174581068",
        "commented_code": "@@ -1206,9 +1213,23 @@ def join_parent_model(self, opts, model, alias, seen):\n         return alias or seen[None]\n \n     def check_alias(self, alias):\n+        # RemovedInDjango70Warning: When the deprecation ends, remove.\n+        if \"%\" in alias:\n+            if \"aggregate\" in {frame.function for frame in inspect.stack()}:",
        "comment_created_at": "2025-06-30T23:01:20+00:00",
        "comment_author": "adamchainz",
        "comment_body": "Ah yes, good point!\r\n\r\nThat's also tracked in this ticket you made: https://code.djangoproject.com/ticket/35667",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2115725577",
    "pr_number": 19507,
    "pr_file": "django/http/request.py",
    "created_at": "2025-05-30T11:20:02+00:00",
    "commented_code": "@property\n     def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+        return self.main_type == \"*\" and self.sub_type == \"*\" and not self.params\n+\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)\n+        return params",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2115725577",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2115725577",
        "commented_code": "@@ -707,21 +707,31 @@ def __repr__(self):\n \n     @property\n     def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+        return self.main_type == \"*\" and self.sub_type == \"*\" and not self.params\n+\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)\n+        return params",
        "comment_created_at": "2025-05-30T11:20:02+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Would a dict comprehension be more readable (and faster?) here? 🤔",
        "pr_file_module": null
      },
      {
        "comment_id": "2115742304",
        "repo_full_name": "django/django",
        "pr_number": 19507,
        "pr_file": "django/http/request.py",
        "discussion_id": "2115725577",
        "commented_code": "@@ -707,21 +707,31 @@ def __repr__(self):\n \n     @property\n     def is_all_types(self):\n-        return self.main_type == \"*\" and self.sub_type == \"*\"\n+        return self.main_type == \"*\" and self.sub_type == \"*\" and not self.params\n+\n+    @cached_property\n+    def params(self):\n+        params = self._params.copy()\n+        params.pop(\"q\", None)\n+        return params",
        "comment_created_at": "2025-05-30T11:27:20+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "I don't think a dict comprehension would be faster than a `copy`:\r\n\r\n```pycon\r\nIn [1]: params = {\"version\": 4.0, \"q\": 1}\r\n\r\nIn [2]: %timeit p = params.copy(); p.pop(\"q\", None)\r\n\r\n110 ns ± 2.47 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)\r\n\r\nIn [3]: %timeit {k: v for k, v in params.items() if k != \"q\"}\r\n241 ns ± 1.12 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\r\n```",
        "pr_file_module": null
      }
    ]
  }
]