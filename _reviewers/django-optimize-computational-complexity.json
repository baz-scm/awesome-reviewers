[
  {
    "discussion_id": "1849471305",
    "pr_number": 18769,
    "pr_file": "django/core/management/commands/listurls.py",
    "created_at": "2024-11-20T03:54:56+00:00",
    "commented_code": "+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1849471305",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849471305",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))",
        "comment_created_at": "2024-11-20T03:54:56+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Oh this is also comprehension potential \ud83d\udd75\ufe0f\u200d\u2642\ufe0f",
        "pr_file_module": null
      },
      {
        "comment_id": "1849835405",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849471305",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))",
        "comment_created_at": "2024-11-20T08:28:08+00:00",
        "comment_author": "ulgens",
        "comment_body": "The equivalent of this code from django-extensions was using comprehension, I chose this version for better readability.",
        "pr_file_module": null
      },
      {
        "comment_id": "1895268434",
        "repo_full_name": "django/django",
        "pr_number": 18769,
        "pr_file": "django/core/management/commands/listurls.py",
        "discussion_id": "1849471305",
        "commented_code": "@@ -0,0 +1,277 @@\n+import json\n+from importlib import import_module\n+from io import StringIO\n+\n+from django.conf import settings\n+from django.contrib.admindocs.views import (\n+    extract_views_from_urlpatterns,\n+    simplify_regex,\n+)\n+from django.core.management import color\n+from django.core.management.base import BaseCommand, CommandError, CommandParser\n+from django.utils import termcolors\n+\n+FORMATS = (\n+    \"aligned\",\n+    \"table\",\n+    \"verbose\",\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+COLORLESS_FORMATS = (\n+    \"json\",\n+    \"pretty-json\",\n+)\n+\n+\n+class Command(BaseCommand):\n+    help = \"List URL patterns in the project with optional filtering by prefixes.\"\n+\n+    def __init__(self, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+        self.style.HEADER = termcolors.make_style(opts=(\"bold\",))\n+        self.style.ROUTE = termcolors.make_style(opts=(\"bold\",))\n+        self.style.VIEW_NAME = termcolors.make_style(fg=\"yellow\", opts=(\"bold\",))\n+        self.style.NAME = termcolors.make_style(fg=\"red\", opts=(\"bold\",))\n+\n+    def add_arguments(self, parser: CommandParser):\n+        super().add_arguments(parser)\n+\n+        # Sorting\n+        parser.add_argument(\n+            \"--unsorted\",\n+            \"-u\",\n+            action=\"store_true\",\n+            dest=\"unsorted\",\n+            help=\"Show URLs without sorting them alphabetically.\",\n+        )\n+\n+        # Prefix\n+        parser.add_argument(\n+            \"--prefix\",\n+            \"-p\",\n+            dest=\"prefixes\",\n+            help=\"Only list URLs with these prefixes.\",\n+            nargs=\"*\",\n+        )\n+\n+        # Format\n+        parser.add_argument(\n+            \"--format\",\n+            \"-f\",\n+            choices=FORMATS,\n+            default=\"aligned\",\n+            dest=\"format\",\n+            help=\"Formatting style of the output\",\n+        )\n+\n+    def handle(self, *args, **options):\n+        prefixes = options[\"prefixes\"]\n+        url_patterns = get_url_patterns(prefixes=prefixes)\n+\n+        if not url_patterns:\n+            raise CommandError(\"There are no URL patterns that match given prefixes\")\n+\n+        unsorted = options[\"unsorted\"]\n+        no_color = options[\"no_color\"]\n+        format = options[\"format\"]\n+\n+        # Apply sorting\n+        if not unsorted:\n+            url_patterns.sort()\n+\n+        # Apply colors\n+        self.is_color_enabled = (\n+            color.supports_color()\n+            and (not no_color)\n+            and (format not in COLORLESS_FORMATS)\n+        )\n+\n+        if self.is_color_enabled:\n+            url_patterns = self.apply_color(url_patterns=url_patterns)\n+\n+        # Apply formatting\n+        url_patterns = self.apply_format(\n+            url_patterns=url_patterns,\n+            format=format,\n+        )\n+\n+        return url_patterns\n+\n+    def apply_color(self, url_patterns):\n+        colored_url_patterns = []\n+\n+        for url_pattern in url_patterns:\n+            # Route\n+            route = url_pattern[0]\n+            route = self.style.ROUTE(route)\n+\n+            # View\n+            view = url_pattern[1]\n+            module_path, module_name = view.rsplit(\".\", 1)\n+            module_name = self.style.VIEW_NAME(module_name)\n+            view = f\"{module_path}.{module_name}\"\n+\n+            # Name\n+            name = url_pattern[2]\n+            if name:\n+                namespace, name = name.rsplit(\":\", 1) if \":\" in name else (\"\", name)\n+                name = self.style.NAME(name)\n+                name = f\"{namespace}:{name}\" if namespace else name\n+\n+            # Append to the list\n+            colored_url_patterns.append((route, view, name))\n+\n+        return colored_url_patterns\n+\n+    def apply_format(self, url_patterns, format):\n+        format_method_name = f\"format_{format.replace('-', '_')}\"\n+        format_method = getattr(self, format_method_name)\n+\n+        return format_method(url_patterns)\n+\n+    def format_table(self, url_patterns):\n+        formatted_str = StringIO()\n+\n+        widths = []\n+        margin = 2\n+        for columns in zip(*url_patterns, strict=False):\n+            widths.append(len(max(columns, key=len)) + margin)\n+\n+        # Headers\n+        headers = [\"Route\", \"View\", \"Name\"]\n+\n+        if self.is_color_enabled:\n+            headers = [self.style.HEADER(header) for header in headers]\n+\n+        header_parts = []\n+        for width, header in zip(widths, headers, strict=False):\n+            header_parts.append(header.ljust(width))",
        "comment_created_at": "2024-12-23T05:33:08+00:00",
        "comment_author": "pauloxnet",
        "comment_body": "The comprehension version can perform better, and at the same time be readable as it's a common Python pattern.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1320659050",
    "pr_number": 16851,
    "pr_file": "django/db/models/fields/related.py",
    "created_at": "2023-09-09T22:03:39+00:00",
    "commented_code": "else []\n         )\n \n+    @classmethod\n+    def _has_related_models_with_db_cascading(cls, model, on_delete):\n+        \"\"\"\n+        If the ForeignKey parent has DB cascading and the Current model has non\n+        db cascading return true\n+        \"\"\"\n+        # Optimization for the case when the model does not have non-db deletion\n+        if isinstance(on_delete, DatabaseOnDelete):\n+            return None\n+        # Fetch all the models related to the current model\n+        # In other words fetch all the ForeignKey childs.\n+        related_models = [\n+            rel.related_model\n+            for rel in model._meta.get_fields()\n+            if rel.related_model\n+            and not rel.auto_created\n+            and hasattr(rel.related_model, \"_meta\")\n+        ]\n+        for rel_model in related_models:\n+            # check through the related models\n+            # if they have DB level deletion return True\n+            # Our current model already has non_db cascade\n+            for rel in rel_model._meta.get_fields():\n+                related_on_delete = None\n+                related_remote_field = rel\n+                if isinstance(rel, OneToOneRel) and hasattr(rel, \"on_delete\"):\n+                    related_on_delete = rel.on_delete\n+                    related_remote_field = rel.remote_field\n+                elif (\n+                    isinstance(rel, ForeignKey) or isinstance(rel, OneToOneField)\n+                ) and hasattr(rel.remote_field, \"on_delete\"):\n+                    related_on_delete = rel.remote_field.on_delete\n+                if isinstance(related_on_delete, DatabaseOnDelete):\n+                    return related_remote_field",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1320659050",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/models/fields/related.py",
        "discussion_id": "1320659050",
        "commented_code": "@@ -1051,6 +1104,42 @@ def _check_unique(self, **kwargs):\n             else []\n         )\n \n+    @classmethod\n+    def _has_related_models_with_db_cascading(cls, model, on_delete):\n+        \"\"\"\n+        If the ForeignKey parent has DB cascading and the Current model has non\n+        db cascading return true\n+        \"\"\"\n+        # Optimization for the case when the model does not have non-db deletion\n+        if isinstance(on_delete, DatabaseOnDelete):\n+            return None\n+        # Fetch all the models related to the current model\n+        # In other words fetch all the ForeignKey childs.\n+        related_models = [\n+            rel.related_model\n+            for rel in model._meta.get_fields()\n+            if rel.related_model\n+            and not rel.auto_created\n+            and hasattr(rel.related_model, \"_meta\")\n+        ]\n+        for rel_model in related_models:\n+            # check through the related models\n+            # if they have DB level deletion return True\n+            # Our current model already has non_db cascade\n+            for rel in rel_model._meta.get_fields():\n+                related_on_delete = None\n+                related_remote_field = rel\n+                if isinstance(rel, OneToOneRel) and hasattr(rel, \"on_delete\"):\n+                    related_on_delete = rel.on_delete\n+                    related_remote_field = rel.remote_field\n+                elif (\n+                    isinstance(rel, ForeignKey) or isinstance(rel, OneToOneField)\n+                ) and hasattr(rel.remote_field, \"on_delete\"):\n+                    related_on_delete = rel.remote_field.on_delete\n+                if isinstance(related_on_delete, DatabaseOnDelete):\n+                    return related_remote_field",
        "comment_created_at": "2023-09-09T22:03:39+00:00",
        "comment_author": "LilyAcorn",
        "comment_body": "I think this might be a bit simpler to understand:\r\n\r\n```suggestion\r\n                if isinstance(rel, OneToOneRel) and isinstance(rel.on_delete, DatabaseOnDelete):\r\n                    return rel.remote_field\r\n                elif (\r\n                    isinstance(rel, (ForeignKey, OneToOneField))\r\n                ) and isinstance(getattr(rel.remote_field, \"on_delete\", None), DatabaseOnDelete):\r\n                    return rel\r\n```\r\n\r\nI was able to verify that `rel` always has an `on_delete` attribute if it is an instance of `OneToOneRel`, so we can do `rel.on_delete` here. I think we need the `getattr` for `rel.remote_field`, but it would be nice if we didn't. Maybe it would be enough to set `on_delete = None` in `Field.__init__`?",
        "pr_file_module": null
      },
      {
        "comment_id": "1323128427",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/models/fields/related.py",
        "discussion_id": "1320659050",
        "commented_code": "@@ -1051,6 +1104,42 @@ def _check_unique(self, **kwargs):\n             else []\n         )\n \n+    @classmethod\n+    def _has_related_models_with_db_cascading(cls, model, on_delete):\n+        \"\"\"\n+        If the ForeignKey parent has DB cascading and the Current model has non\n+        db cascading return true\n+        \"\"\"\n+        # Optimization for the case when the model does not have non-db deletion\n+        if isinstance(on_delete, DatabaseOnDelete):\n+            return None\n+        # Fetch all the models related to the current model\n+        # In other words fetch all the ForeignKey childs.\n+        related_models = [\n+            rel.related_model\n+            for rel in model._meta.get_fields()\n+            if rel.related_model\n+            and not rel.auto_created\n+            and hasattr(rel.related_model, \"_meta\")\n+        ]\n+        for rel_model in related_models:\n+            # check through the related models\n+            # if they have DB level deletion return True\n+            # Our current model already has non_db cascade\n+            for rel in rel_model._meta.get_fields():\n+                related_on_delete = None\n+                related_remote_field = rel\n+                if isinstance(rel, OneToOneRel) and hasattr(rel, \"on_delete\"):\n+                    related_on_delete = rel.on_delete\n+                    related_remote_field = rel.remote_field\n+                elif (\n+                    isinstance(rel, ForeignKey) or isinstance(rel, OneToOneField)\n+                ) and hasattr(rel.remote_field, \"on_delete\"):\n+                    related_on_delete = rel.remote_field.on_delete\n+                if isinstance(related_on_delete, DatabaseOnDelete):\n+                    return related_remote_field",
        "comment_created_at": "2023-09-12T14:25:03+00:00",
        "comment_author": "ngnpope",
        "comment_body": "You could also collapse `isinstance(rel, ForeignKey) or isinstance(rel, OneToOneField)` to `isinstance(rel, (ForeignKey, OneToOneField))` in the `elif` branch.",
        "pr_file_module": null
      },
      {
        "comment_id": "1323156409",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/models/fields/related.py",
        "discussion_id": "1320659050",
        "commented_code": "@@ -1051,6 +1104,42 @@ def _check_unique(self, **kwargs):\n             else []\n         )\n \n+    @classmethod\n+    def _has_related_models_with_db_cascading(cls, model, on_delete):\n+        \"\"\"\n+        If the ForeignKey parent has DB cascading and the Current model has non\n+        db cascading return true\n+        \"\"\"\n+        # Optimization for the case when the model does not have non-db deletion\n+        if isinstance(on_delete, DatabaseOnDelete):\n+            return None\n+        # Fetch all the models related to the current model\n+        # In other words fetch all the ForeignKey childs.\n+        related_models = [\n+            rel.related_model\n+            for rel in model._meta.get_fields()\n+            if rel.related_model\n+            and not rel.auto_created\n+            and hasattr(rel.related_model, \"_meta\")\n+        ]\n+        for rel_model in related_models:\n+            # check through the related models\n+            # if they have DB level deletion return True\n+            # Our current model already has non_db cascade\n+            for rel in rel_model._meta.get_fields():\n+                related_on_delete = None\n+                related_remote_field = rel\n+                if isinstance(rel, OneToOneRel) and hasattr(rel, \"on_delete\"):\n+                    related_on_delete = rel.on_delete\n+                    related_remote_field = rel.remote_field\n+                elif (\n+                    isinstance(rel, ForeignKey) or isinstance(rel, OneToOneField)\n+                ) and hasattr(rel.remote_field, \"on_delete\"):\n+                    related_on_delete = rel.remote_field.on_delete\n+                if isinstance(related_on_delete, DatabaseOnDelete):\n+                    return related_remote_field",
        "comment_created_at": "2023-09-12T14:44:19+00:00",
        "comment_author": "LilyAcorn",
        "comment_body": "> You could also collapse `isinstance(rel, ForeignKey) or isinstance(rel, OneToOneField)` to `isinstance(rel, (ForeignKey, OneToOneField))` in the `elif` branch.\r\n\r\nGood point! I'll edit the suggestion.",
        "pr_file_module": null
      },
      {
        "comment_id": "1327488133",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/models/fields/related.py",
        "discussion_id": "1320659050",
        "commented_code": "@@ -1051,6 +1104,42 @@ def _check_unique(self, **kwargs):\n             else []\n         )\n \n+    @classmethod\n+    def _has_related_models_with_db_cascading(cls, model, on_delete):\n+        \"\"\"\n+        If the ForeignKey parent has DB cascading and the Current model has non\n+        db cascading return true\n+        \"\"\"\n+        # Optimization for the case when the model does not have non-db deletion\n+        if isinstance(on_delete, DatabaseOnDelete):\n+            return None\n+        # Fetch all the models related to the current model\n+        # In other words fetch all the ForeignKey childs.\n+        related_models = [\n+            rel.related_model\n+            for rel in model._meta.get_fields()\n+            if rel.related_model\n+            and not rel.auto_created\n+            and hasattr(rel.related_model, \"_meta\")\n+        ]\n+        for rel_model in related_models:\n+            # check through the related models\n+            # if they have DB level deletion return True\n+            # Our current model already has non_db cascade\n+            for rel in rel_model._meta.get_fields():\n+                related_on_delete = None\n+                related_remote_field = rel\n+                if isinstance(rel, OneToOneRel) and hasattr(rel, \"on_delete\"):\n+                    related_on_delete = rel.on_delete\n+                    related_remote_field = rel.remote_field\n+                elif (\n+                    isinstance(rel, ForeignKey) or isinstance(rel, OneToOneField)\n+                ) and hasattr(rel.remote_field, \"on_delete\"):\n+                    related_on_delete = rel.remote_field.on_delete\n+                if isinstance(related_on_delete, DatabaseOnDelete):\n+                    return related_remote_field",
        "comment_created_at": "2023-09-15T15:45:28+00:00",
        "comment_author": "Akash-Kumar-Sen",
        "comment_body": "This seems logical. I would try put these suggestions on test soon.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2141904512",
    "pr_number": 19553,
    "pr_file": "django/http/request.py",
    "created_at": "2025-06-12T07:18:05+00:00",
    "commented_code": "return None\n \n         # Of the desired media types, select the one which is most desirable.\n-        return min(desired_types, key=lambda t: self.accepted_types.index(t[0]))[1]\n+        return max(desired_types, key=lambda t: t[0].quality)[1]",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2141904512",
        "repo_full_name": "django/django",
        "pr_number": 19553,
        "pr_file": "django/http/request.py",
        "discussion_id": "2141904512",
        "commented_code": "@@ -131,7 +143,7 @@ def get_preferred_type(self, media_types):\n             return None\n \n         # Of the desired media types, select the one which is most desirable.\n-        return min(desired_types, key=lambda t: self.accepted_types.index(t[0]))[1]\n+        return max(desired_types, key=lambda t: t[0].quality)[1]",
        "comment_created_at": "2025-06-12T07:18:05+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "When I revert this change the tests still pass, but I _think_ that's because these are basically logically equivalent (due to the way `self.accepted_types` is ordered) and that this is easier to read\r\n\r\nI think I would like a test for `get_preferred_type` which was failing before and passing after this commit (as `get_preferred_type` was the focus of the ticket)",
        "pr_file_module": null
      },
      {
        "comment_id": "2142162304",
        "repo_full_name": "django/django",
        "pr_number": 19553,
        "pr_file": "django/http/request.py",
        "discussion_id": "2141904512",
        "commented_code": "@@ -131,7 +143,7 @@ def get_preferred_type(self, media_types):\n             return None\n \n         # Of the desired media types, select the one which is most desirable.\n-        return min(desired_types, key=lambda t: self.accepted_types.index(t[0]))[1]\n+        return max(desired_types, key=lambda t: t[0].quality)[1]",
        "comment_created_at": "2025-06-12T09:24:07+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "I think in reality the old line is better, if only because it means the ordering is stable for entries with the same `quality` (which is quite likely). \r\n\r\nI've added a test to ensure that if the sort order is reverted (ie `accepted_types_by_precedence` is used instead), that a test fails, and that the specificity breaks ties.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1917510305",
    "pr_number": 19012,
    "pr_file": "django/db/models/query.py",
    "created_at": "2025-01-16T00:35:54+00:00",
    "commented_code": "self._for_write = True\n         fields = [f for f in opts.concrete_fields if not f.generated]\n         objs = list(objs)\n+\n+        # Handle order_with_respect_to if present\n+        if order_wrt := self.model._meta.order_with_respect_to:\n+            get_filter_kwargs_for_object = order_wrt.get_filter_kwargs_for_object\n+            attnames = list(get_filter_kwargs_for_object(objs[0]).keys())\n+\n+            grouped_objects = {}\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, 'id') else value\n+                    for value in filter_kwargs.values()\n+                )\n+                grouped_objects.setdefault(group_key, []).append(obj)\n+\n+            filters = []\n+            for group_key in grouped_objects:\n+                filters.append(dict(zip(attnames, group_key)))\n+\n+            max_orders = (\n+                self.model._base_manager.using(self.db)\n+                .filter(reduce(operator.or_, (Q(**f) for f in filters)))\n+                .values(*attnames)\n+                .annotate(_order__max=Max(\"_order\"))\n+            )\n+\n+            # Create mapping of group values to max order\n+            max_orders_map = {\n+                tuple(max_order[name] for name in attnames): max_order[\n+                    \"_order__max\"]\n+                for max_order in max_orders\n+            }\n+\n+            # Assign _order values to new objects\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, \"id\") else value\n+                    for value in filter_kwargs.values()\n+                )\n+                curr_max = max_orders_map.get(group_key, -1)\n+                max_orders_map[group_key] = curr_max + 1\n+                obj._order = curr_max + 1",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1917510305",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "django/db/models/query.py",
        "discussion_id": "1917510305",
        "commented_code": "@@ -799,7 +800,52 @@ def bulk_create(\n         self._for_write = True\n         fields = [f for f in opts.concrete_fields if not f.generated]\n         objs = list(objs)\n+\n+        # Handle order_with_respect_to if present\n+        if order_wrt := self.model._meta.order_with_respect_to:\n+            get_filter_kwargs_for_object = order_wrt.get_filter_kwargs_for_object\n+            attnames = list(get_filter_kwargs_for_object(objs[0]).keys())\n+\n+            grouped_objects = {}\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, 'id') else value\n+                    for value in filter_kwargs.values()\n+                )\n+                grouped_objects.setdefault(group_key, []).append(obj)\n+\n+            filters = []\n+            for group_key in grouped_objects:\n+                filters.append(dict(zip(attnames, group_key)))\n+\n+            max_orders = (\n+                self.model._base_manager.using(self.db)\n+                .filter(reduce(operator.or_, (Q(**f) for f in filters)))\n+                .values(*attnames)\n+                .annotate(_order__max=Max(\"_order\"))\n+            )\n+\n+            # Create mapping of group values to max order\n+            max_orders_map = {\n+                tuple(max_order[name] for name in attnames): max_order[\n+                    \"_order__max\"]\n+                for max_order in max_orders\n+            }\n+\n+            # Assign _order values to new objects\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, \"id\") else value\n+                    for value in filter_kwargs.values()\n+                )\n+                curr_max = max_orders_map.get(group_key, -1)\n+                max_orders_map[group_key] = curr_max + 1\n+                obj._order = curr_max + 1",
        "comment_created_at": "2025-01-16T00:35:54+00:00",
        "comment_author": "charettes",
        "comment_body": "There's likely a way to avoid calling `get_filter_kwargs_for_object` 2N + 1 (where `N = len(objs)`) times.",
        "pr_file_module": null
      },
      {
        "comment_id": "2072397533",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "django/db/models/query.py",
        "discussion_id": "1917510305",
        "commented_code": "@@ -799,7 +800,52 @@ def bulk_create(\n         self._for_write = True\n         fields = [f for f in opts.concrete_fields if not f.generated]\n         objs = list(objs)\n+\n+        # Handle order_with_respect_to if present\n+        if order_wrt := self.model._meta.order_with_respect_to:\n+            get_filter_kwargs_for_object = order_wrt.get_filter_kwargs_for_object\n+            attnames = list(get_filter_kwargs_for_object(objs[0]).keys())\n+\n+            grouped_objects = {}\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, 'id') else value\n+                    for value in filter_kwargs.values()\n+                )\n+                grouped_objects.setdefault(group_key, []).append(obj)\n+\n+            filters = []\n+            for group_key in grouped_objects:\n+                filters.append(dict(zip(attnames, group_key)))\n+\n+            max_orders = (\n+                self.model._base_manager.using(self.db)\n+                .filter(reduce(operator.or_, (Q(**f) for f in filters)))\n+                .values(*attnames)\n+                .annotate(_order__max=Max(\"_order\"))\n+            )\n+\n+            # Create mapping of group values to max order\n+            max_orders_map = {\n+                tuple(max_order[name] for name in attnames): max_order[\n+                    \"_order__max\"]\n+                for max_order in max_orders\n+            }\n+\n+            # Assign _order values to new objects\n+            for obj in objs:\n+                filter_kwargs = get_filter_kwargs_for_object(obj)\n+                group_key = tuple(\n+                    value.id if hasattr(value, \"id\") else value\n+                    for value in filter_kwargs.values()\n+                )\n+                curr_max = max_orders_map.get(group_key, -1)\n+                max_orders_map[group_key] = curr_max + 1\n+                obj._order = curr_max + 1",
        "comment_created_at": "2025-05-03T13:40:14+00:00",
        "comment_author": "myoungjinGo-BE",
        "comment_body": "`get_filter_kwargs_for_object` is now called exactly once per object, reducing the total calls from 2N+1 to N.\r\nSince each object needs to be grouped individually, I considered N calls to be a reasonable compromise.\r\nPlease let me know if you believe further optimization is necessary.",
        "pr_file_module": null
      }
    ]
  }
]