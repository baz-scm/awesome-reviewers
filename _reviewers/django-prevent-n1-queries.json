[
  {
    "discussion_id": "1982891282",
    "pr_number": 17554,
    "pr_file": "docs/releases/6.0.txt",
    "created_at": "2025-03-06T08:15:50+00:00",
    "commented_code": "What's new in Django 6.0\n ========================\n \n+Model field fetch modes\n+-----------------------\n+\n+The on-demand fetching behavior of model fields is now configurable with\n+:doc:`fetch modes </topics/db/fetch-modes>`. Django provides three fetch\n+modes:",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1982891282",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/releases/6.0.txt",
        "discussion_id": "1982891282",
        "commented_code": "@@ -37,6 +37,56 @@ compatible with Django 6.0.\n What's new in Django 6.0\n ========================\n \n+Model field fetch modes\n+-----------------------\n+\n+The on-demand fetching behavior of model fields is now configurable with\n+:doc:`fetch modes </topics/db/fetch-modes>`. Django provides three fetch\n+modes:",
        "comment_created_at": "2025-03-06T08:15:50+00:00",
        "comment_author": "pelme",
        "comment_body": "should we also in this first paragraph call out that the main motivation for fetch modes is to prevent N+1 queries/missing select_related/prefetch_related on foreignkeys/related fields? fetch modes does more than that (deferred fields) but I still think that would be helpful for people reading this the first time.\r\n\r\nIt is stated below but I find this an important point to get across very early \ud83d\ude42 ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983049754",
    "pr_number": 17554,
    "pr_file": "docs/topics/db/optimization.txt",
    "created_at": "2025-03-06T09:56:38+00:00",
    "commented_code": "* in view code or other layers, possibly making use of\n   :func:`~django.db.models.prefetch_related_objects` where needed.\n \n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n+\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to reduce the number\n+of queries when fetching fields on-demand for multiple instances. This can\n+mitigate a lack of :meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related` usage when it\u2019s hard\n+to predict which fields will be accessed.\n+",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1983049754",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/optimization.txt",
        "discussion_id": "1983049754",
        "commented_code": "@@ -219,6 +219,15 @@ them:\n * in view code or other layers, possibly making use of\n   :func:`~django.db.models.prefetch_related_objects` where needed.\n \n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n+\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to reduce the number\n+of queries when fetching fields on-demand for multiple instances. This can\n+mitigate a lack of :meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related` usage when it\u2019s hard\n+to predict which fields will be accessed.\n+",
        "comment_created_at": "2025-03-06T09:56:38+00:00",
        "comment_author": "pelme",
        "comment_body": "maybe this section should come before the select_related / prefetch_related section? The first thing for a beginner/newcomer when optimising relation queries should probably be to just use FETCH_PEERS. **then** you can learn about prefetch_related / select_related. ideally everyone should know about fetch modes, select related, prefetch related, and understand the tradeoffs. but for those that do not know about all of that yet, just using FETCH_PEERS is a good starting point.",
        "pr_file_module": null
      },
      {
        "comment_id": "2021093698",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/optimization.txt",
        "discussion_id": "1983049754",
        "commented_code": "@@ -219,6 +219,15 @@ them:\n * in view code or other layers, possibly making use of\n   :func:`~django.db.models.prefetch_related_objects` where needed.\n \n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n+\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to reduce the number\n+of queries when fetching fields on-demand for multiple instances. This can\n+mitigate a lack of :meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related` usage when it\u2019s hard\n+to predict which fields will be accessed.\n+",
        "comment_created_at": "2025-03-31T13:54:07+00:00",
        "comment_author": "adamchainz",
        "comment_body": "Done and I tried to emphasize that `FETCH_PEERS` should be considered first.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983309597",
    "pr_number": 17554,
    "pr_file": "docs/topics/db/fetch-modes.txt",
    "created_at": "2025-03-06T12:56:51+00:00",
    "commented_code": "+===========\n+Fetch modes\n+===========\n+\n+.. module:: django.db.models.fields.fetch_modes\n+\n+.. currentmodule:: django.db.models\n+\n+When accessing model fields that were not loaded as part of the original query,\n+Django will fetch that field\u2019s data from the database. You can customize the\n+behavior of this fetching with a **fetch mode**.\n+\n+Available modes\n+===============\n+\n+Django provides three modes:\n+",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1983309597",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/fetch-modes.txt",
        "discussion_id": "1983309597",
        "commented_code": "@@ -0,0 +1,83 @@\n+===========\n+Fetch modes\n+===========\n+\n+.. module:: django.db.models.fields.fetch_modes\n+\n+.. currentmodule:: django.db.models\n+\n+When accessing model fields that were not loaded as part of the original query,\n+Django will fetch that field\u2019s data from the database. You can customize the\n+behavior of this fetching with a **fetch mode**.\n+\n+Available modes\n+===============\n+\n+Django provides three modes:\n+",
        "comment_created_at": "2025-03-06T12:56:51+00:00",
        "comment_author": "pelme",
        "comment_body": "to make it clearer how these modes work/differ from each other, an example per mode would be very helpful.\r\n\r\nmaybe just steal the tests (which are very clear btw!)?\r\n\r\n```py\r\nwith fetch_mode(FETCH_PEERS):\r\n    a1, a2 = Article.objects.all()\r\n    a1.reporter # will fetch the reporter for both a1 and a2 with one query\r\n    a2.reporter  # this reporter will already be fetched at this point and no extra queries will be executed\r\n```\r\n\r\nand similar for FETCH_ONE and RAISES?",
        "pr_file_module": null
      },
      {
        "comment_id": "2021340052",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/fetch-modes.txt",
        "discussion_id": "1983309597",
        "commented_code": "@@ -0,0 +1,83 @@\n+===========\n+Fetch modes\n+===========\n+\n+.. module:: django.db.models.fields.fetch_modes\n+\n+.. currentmodule:: django.db.models\n+\n+When accessing model fields that were not loaded as part of the original query,\n+Django will fetch that field\u2019s data from the database. You can customize the\n+behavior of this fetching with a **fetch mode**.\n+\n+Available modes\n+===============\n+\n+Django provides three modes:\n+",
        "comment_created_at": "2025-03-31T16:09:56+00:00",
        "comment_author": "adamchainz",
        "comment_body": "I\u2019ve updated the new docs with an example that\u2019s explained for each built-in mode.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072398386",
    "pr_number": 17554,
    "pr_file": "docs/topics/db/optimization.txt",
    "created_at": "2025-05-03T13:45:08+00:00",
    "commented_code": "database lives on a separate server, where network overhead and latency also\n play a factor.\n \n-Retrieve everything at once if you know you will need it\n-========================================================\n+Retrieve related objects efficiently\n+====================================\n+\n+Generally, accessing the database multiple times to retrieve different parts\n+of a single 'set' of data is less efficient than retrieving it all in one\n+query. This is particularly important if you have a query that is executed in a\n+loop, and could therefore end up doing many database queries, when only one\n+is needed. Below are some techniques to combine queries for efficiency.\n+\n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n \n-Hitting the database multiple times for different parts of a single 'set' of\n-data that you will need all parts of is, in general, less efficient than\n-retrieving it all in one query. This is particularly important if you have a\n-query that is executed in a loop, and could therefore end up doing many database\n-queries, when only one was needed. So:\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to make on-demand\n+field access more efficient with bulk-fetching. Enable all it for all usage of\n+your models :ref:`with a custom manager <fetch-modes-custom-manager>`.\n+\n+Using this fetch mode is easier than declaring fields to fetch with\n+:meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related`, especially when it's\n+hard to predict which fields will be accessed.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2072398386",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/optimization.txt",
        "discussion_id": "2072398386",
        "commented_code": "@@ -196,28 +196,45 @@ thousands of records are returned. The penalty will be compounded if the\n database lives on a separate server, where network overhead and latency also\n play a factor.\n \n-Retrieve everything at once if you know you will need it\n-========================================================\n+Retrieve related objects efficiently\n+====================================\n+\n+Generally, accessing the database multiple times to retrieve different parts\n+of a single 'set' of data is less efficient than retrieving it all in one\n+query. This is particularly important if you have a query that is executed in a\n+loop, and could therefore end up doing many database queries, when only one\n+is needed. Below are some techniques to combine queries for efficiency.\n+\n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n \n-Hitting the database multiple times for different parts of a single 'set' of\n-data that you will need all parts of is, in general, less efficient than\n-retrieving it all in one query. This is particularly important if you have a\n-query that is executed in a loop, and could therefore end up doing many database\n-queries, when only one was needed. So:\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to make on-demand\n+field access more efficient with bulk-fetching. Enable all it for all usage of\n+your models :ref:`with a custom manager <fetch-modes-custom-manager>`.\n+\n+Using this fetch mode is easier than declaring fields to fetch with\n+:meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related`, especially when it's\n+hard to predict which fields will be accessed.",
        "comment_created_at": "2025-05-03T13:45:08+00:00",
        "comment_author": "jacobtylerwalls",
        "comment_body": "I've been puzzled before why `prefetch_related()` does nothing, but `select_related()` selects everything. We could straighten this out if we let `prefetch_related()` resolve to `fetch_mode(models.FETCH_PEERS)`, if I understand correctly?",
        "pr_file_module": null
      },
      {
        "comment_id": "2075024997",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/optimization.txt",
        "discussion_id": "2072398386",
        "commented_code": "@@ -196,28 +196,45 @@ thousands of records are returned. The penalty will be compounded if the\n database lives on a separate server, where network overhead and latency also\n play a factor.\n \n-Retrieve everything at once if you know you will need it\n-========================================================\n+Retrieve related objects efficiently\n+====================================\n+\n+Generally, accessing the database multiple times to retrieve different parts\n+of a single 'set' of data is less efficient than retrieving it all in one\n+query. This is particularly important if you have a query that is executed in a\n+loop, and could therefore end up doing many database queries, when only one\n+is needed. Below are some techniques to combine queries for efficiency.\n+\n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n \n-Hitting the database multiple times for different parts of a single 'set' of\n-data that you will need all parts of is, in general, less efficient than\n-retrieving it all in one query. This is particularly important if you have a\n-query that is executed in a loop, and could therefore end up doing many database\n-queries, when only one was needed. So:\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to make on-demand\n+field access more efficient with bulk-fetching. Enable all it for all usage of\n+your models :ref:`with a custom manager <fetch-modes-custom-manager>`.\n+\n+Using this fetch mode is easier than declaring fields to fetch with\n+:meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related`, especially when it's\n+hard to predict which fields will be accessed.",
        "comment_created_at": "2025-05-06T08:53:02+00:00",
        "comment_author": "tolomea",
        "comment_body": "that select_related() call is almost always a bad idea, it's very prone to over fetching and to doing so in a way that is fairly hostile to the database, I'd be more in favor of removing that behaviour ",
        "pr_file_module": null
      },
      {
        "comment_id": "2107185274",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/optimization.txt",
        "discussion_id": "2072398386",
        "commented_code": "@@ -196,28 +196,45 @@ thousands of records are returned. The penalty will be compounded if the\n database lives on a separate server, where network overhead and latency also\n play a factor.\n \n-Retrieve everything at once if you know you will need it\n-========================================================\n+Retrieve related objects efficiently\n+====================================\n+\n+Generally, accessing the database multiple times to retrieve different parts\n+of a single 'set' of data is less efficient than retrieving it all in one\n+query. This is particularly important if you have a query that is executed in a\n+loop, and could therefore end up doing many database queries, when only one\n+is needed. Below are some techniques to combine queries for efficiency.\n+\n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n \n-Hitting the database multiple times for different parts of a single 'set' of\n-data that you will need all parts of is, in general, less efficient than\n-retrieving it all in one query. This is particularly important if you have a\n-query that is executed in a loop, and could therefore end up doing many database\n-queries, when only one was needed. So:\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to make on-demand\n+field access more efficient with bulk-fetching. Enable all it for all usage of\n+your models :ref:`with a custom manager <fetch-modes-custom-manager>`.\n+\n+Using this fetch mode is easier than declaring fields to fetch with\n+:meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related`, especially when it's\n+hard to predict which fields will be accessed.",
        "comment_created_at": "2025-05-26T11:58:33+00:00",
        "comment_author": "adamchainz",
        "comment_body": "I lean towards removing that, too. It\u2019s worth noting that the admin allows users to use it: \r\n\r\nhttps://github.com/django/django/blob/7e4b371eb070d892e9c27eacbe140c78b7d34059/django/contrib/admin/views/main.py#L601-L602\r\n\r\nMaybe enough people rely on it that it\u2019s not worth removing though...? Seems kinda handy for rapid prototyping at least.",
        "pr_file_module": null
      },
      {
        "comment_id": "2187937689",
        "repo_full_name": "django/django",
        "pr_number": 17554,
        "pr_file": "docs/topics/db/optimization.txt",
        "discussion_id": "2072398386",
        "commented_code": "@@ -196,28 +196,45 @@ thousands of records are returned. The penalty will be compounded if the\n database lives on a separate server, where network overhead and latency also\n play a factor.\n \n-Retrieve everything at once if you know you will need it\n-========================================================\n+Retrieve related objects efficiently\n+====================================\n+\n+Generally, accessing the database multiple times to retrieve different parts\n+of a single 'set' of data is less efficient than retrieving it all in one\n+query. This is particularly important if you have a query that is executed in a\n+loop, and could therefore end up doing many database queries, when only one\n+is needed. Below are some techniques to combine queries for efficiency.\n+\n+Use the ``FETCH_PEERS`` fetch mode\n+----------------------------------\n \n-Hitting the database multiple times for different parts of a single 'set' of\n-data that you will need all parts of is, in general, less efficient than\n-retrieving it all in one query. This is particularly important if you have a\n-query that is executed in a loop, and could therefore end up doing many database\n-queries, when only one was needed. So:\n+Use the :attr:`~django.db.models.FETCH_PEERS` fetch mode to make on-demand\n+field access more efficient with bulk-fetching. Enable all it for all usage of\n+your models :ref:`with a custom manager <fetch-modes-custom-manager>`.\n+\n+Using this fetch mode is easier than declaring fields to fetch with\n+:meth:`~django.db.models.query.QuerySet.select_related` or\n+:meth:`~django.db.models.query.QuerySet.prefetch_related`, especially when it's\n+hard to predict which fields will be accessed.",
        "comment_created_at": "2025-07-06T03:21:58+00:00",
        "comment_author": "charettes",
        "comment_body": "Strong +1 to deprecating `select_related()` without a mask as a follow up that's almost always a bad idea.",
        "pr_file_module": null
      }
    ]
  }
]