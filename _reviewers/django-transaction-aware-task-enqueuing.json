[
  {
    "discussion_id": "1829233248",
    "pr_number": 18627,
    "pr_file": "docs/topics/tasks.txt",
    "created_at": "2024-11-05T12:02:05+00:00",
    "commented_code": "+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1829233248",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829233248",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.",
        "comment_created_at": "2024-11-05T12:02:05+00:00",
        "comment_author": "rtpg",
        "comment_body": "repeating something I said elsewhere, but I do think it's good to have a little example somewhere to justify this setting and why it's valuable to have it be `True`",
        "pr_file_module": null
      },
      {
        "comment_id": "1874066975",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829233248",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.",
        "comment_created_at": "2024-12-06T22:30:44+00:00",
        "comment_author": "ericholscher",
        "comment_body": "Yea, it's not obvious to me on reading this and having a general understanding of the problem why this is even a setting, and why I might want to unset it.\r\n\r\nI put a suggestion for this in the Transactions section below. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1898803184",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829233248",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.",
        "comment_created_at": "2024-12-28T04:47:04+00:00",
        "comment_author": "k4ml",
        "comment_body": "I guess this is best explain [here](https://github.com/LaunchPlatform/bq?tab=readme-ov-file#why) by bq (another postgresql task queue) project. Big advantage of using database as task queue is the possibility to insert the task within the same transaction as the main process.\r\n\r\nBut then I think this only apply when using external broker, either non-database such as redis, rabbitmq or separate database for the queue so we can't insert stuff todo and it's task within a same transaction. If using the same database we don't really need this settings as we can always insert stuff todo, insert task, commit and then the worker will see the task and work on it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1828874066",
    "pr_number": 18627,
    "pr_file": "docs/topics/tasks.txt",
    "created_at": "2024-11-05T07:47:37+00:00",
    "commented_code": "+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1828874066",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1828874066",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.",
        "comment_created_at": "2024-11-05T07:47:37+00:00",
        "comment_author": "rtpg",
        "comment_body": "```suggestion\r\nBackends determine how tasks are stored for execution, how they are executed, and how tasks can be delayed  Your backend choice will determine how these tasks are run, so please consider this when choosing what backend to use.\r\n\r\nTask backends are configured using the :setting:`TASKS` setting, and you can configure multiple backends based off of your needs.\r\n\r\nBy default the `default` backend in the :setting:`TASKS` setting is what is used for tasks.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1829253702",
    "pr_number": 18627,
    "pr_file": "docs/topics/tasks.txt",
    "created_at": "2024-11-05T12:17:41+00:00",
    "commented_code": "+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1829253702",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829253702",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
        "comment_created_at": "2024-11-05T12:17:41+00:00",
        "comment_author": "rtpg",
        "comment_body": "Is `tasks.py` going to be auto-imported as part of this work (similar to how `models` and `admin` are?)",
        "pr_file_module": null
      },
      {
        "comment_id": "1831918785",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829253702",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
        "comment_created_at": "2024-11-07T01:08:40+00:00",
        "comment_author": "rtpg",
        "comment_body": "(I think it _should_ be auto-imported, I think that's just a question of modifying `AppConfig`)",
        "pr_file_module": null
      },
      {
        "comment_id": "1835099390",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829253702",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
        "comment_created_at": "2024-11-08T21:59:50+00:00",
        "comment_author": "rtr1",
        "comment_body": "Celery already uses the `tasks.py` convention, so there are going to be many projects that already have this file present that are unrelated to `django.tasks`.\r\n\r\nI do foresee a need to get a list of all registered tasks, whether that happens by checking each installed app's `tasks.py` module for instances of `backend.task_class`, or adding a registration dictionary to the `@task` decorator. The use case would be something like scheduling a task from the admin portal, similar to how Celery Beat allows this by picking a registered task from a dropdown list.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1835619808",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829253702",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
        "comment_created_at": "2024-11-10T08:20:13+00:00",
        "comment_author": "rtpg",
        "comment_body": "This is why I think it's valuable to have the Database backend here. If we don't auto-import `tasks.py`, but are recommending that we define tasks in `tasks.py`, and someone creates a task in `tasks.py` that gets queued in a view, but would be out of the import tree for a task worker, then the background worker won't know about the task to execute it! \r\n\r\n(That is to say, unless the database worker is in fact doing something like `import_string` on a task name... which I would find to be not ideal)\r\n\r\nAnyways, big tent version of this:\r\n- How does a background worker know about a task in `tasks.py`? Do we rely on the import tree hitting all tasks?\r\n- Is the backend responsible for trawling import trees, rather than the `AppConfig`?\r\n\r\nI am OK with any result now, but I think DX-wise the long term should have some form of auto-importing if we're recommending that tasks be defined there.",
        "pr_file_module": null
      },
      {
        "comment_id": "1835757155",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829253702",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
        "comment_created_at": "2024-11-10T18:38:19+00:00",
        "comment_author": "rtr1",
        "comment_body": "I like the DX of auto-importing and it should be fine if we provide an escape hatch, should this behavior conflict with existing Celery code for some reason.\r\n\r\nCelery provides `autodiscover_tasks()` where we can do something like `autodiscover_tasks(related_name='tasks2')` to have it auto-import the `tasks2.py` module or `tasks2` package of each Django app. We can provide something similar, or a `TASKS_` setting in `settings.py` to define the module/package path to use (which defaults to `tasks`).",
        "pr_file_module": null
      },
      {
        "comment_id": "1835914423",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829253702",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
        "comment_created_at": "2024-11-11T03:36:11+00:00",
        "comment_author": "rtpg",
        "comment_body": "This can maybe be a feature for later down the road then. Don't want to increase the number of question marks if we can avoid it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1850638066",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829253702",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.\n+\n+Asynchronous support\n+--------------------\n+\n+Django has developing support for asynchronous task backends.\n+\n+``django.tasks.backends.base.BaseTaskBackend`` has async variants of all base\n+methods. By convention, the asynchronous versions of all methods are prefixed\n+with ``a``. The arguments for both variants are the same.\n+\n+Retrieving backends\n+-------------------\n+\n+Backends can be retrieved using the ``tasks`` connection handler::\n+\n+    from django.tasks import tasks\n+\n+    tasks[\"default\"]  # The default backend\n+    tasks[\"reserve\"]  # Another backend\n+\n+The \"default\" backend is available as ``default_task_backend``::\n+\n+    from django.tasks import default_task_backend\n+\n+Backend features\n+----------------\n+\n+Django's tasks framework is designed to be backend-agnostic. This means some\n+backends may not implement the same features as others, such as executing ``async``\n+functions.\n+\n+Depending on the backend configured, it may be necessary to gracefully degrade\n+functionality, or use a system check to prevent the application from starting at all.\n+\n+To facilitate this, certain features can be checked on a backend:\n+\n+* :attr:`supports_defer <django.tasks.backends.base.BaseTaskBackend.supports_defer>`:\n+  Can tasks be executed after a specific time using ``run_after``?\n+\n+* :attr:`supports_async_task <django.tasks.backends.base.BaseTaskBackend.supports_async_task>`:\n+  Can ``async`` functions (coroutines) be used as task functions?\n+\n+* :attr:`supports_get_result <django.tasks.backends.base.BaseTaskBackend.supports_get_result>`:\n+  Can a task's results be retrieved from another thread or process?\n+\n+Defining tasks\n+==============\n+\n+Tasks are defined using the :meth:`django.tasks.task` decorator on a\n+module-level function::\n+\n+    from django.tasks import task\n+\n+\n+    @task()\n+    def calculate_meaning_of_life(answer=42):\n+        return answer\n+\n+Returned in a :class:`django.tasks.Task` instance.\n+\n+.. note::\n+\n+    All arguments and return values must be JSON serializable, and round-trip\n+    as the same types.\n+\n+    This means complex types like model instances, as well as many built-in types\n+    like ``datetime`` and ``tuple`` cannot be used in tasks without additional\n+    conversion.\n+\n+The ``task`` decorator accepts a few keyword arguments to customize the task:\n+\n+* ``priority``: The priority of the task. Higher numbers will be executed sooner.\n+\n+* ``queue_name``: The name of the queue the task will be executed on\n+\n+* ``backend``: The name of the backend this task must use (as defined in\n+  :setting:`TASKS`).\n+\n+* ``enqueue_on_commit``: Whether the task is enqueued when the current transaction\n+  commits successfully, or enqueued immediately.\n+\n+These arguments correspond to attributes on the created\n+:class:`Task <django.tasks.Task>`.\n+\n+By convention, tasks should be defined in a ``tasks.py`` file, however this is\n+not enforced.",
        "comment_created_at": "2024-11-20T16:32:25+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "When a task is saved to the store, its module path is saved with it, so `import_string` is used to find it. There's no need to know about all tasks in memory.",
        "pr_file_module": null
      }
    ]
  }
]