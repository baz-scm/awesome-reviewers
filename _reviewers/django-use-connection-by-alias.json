[
  {
    "discussion_id": "2075470197",
    "pr_number": 19285,
    "pr_file": "django/db/models/fields/__init__.py",
    "created_at": "2025-05-06T13:22:53+00:00",
    "commented_code": "@property\n     def db_returning(self):\n         \"\"\"Private API intended only to be used by Django itself.\"\"\"\n-        return (\n-            self.has_db_default() and connection.features.can_return_columns_from_insert\n-        )\n+        return self.has_db_default()",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2075470197",
        "repo_full_name": "django/django",
        "pr_number": 19285,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2075470197",
        "commented_code": "@@ -932,9 +932,7 @@ def db_tablespace(self):\n     @property\n     def db_returning(self):\n         \"\"\"Private API intended only to be used by Django itself.\"\"\"\n-        return (\n-            self.has_db_default() and connection.features.can_return_columns_from_insert\n-        )\n+        return self.has_db_default()",
        "comment_created_at": "2025-05-06T13:22:53+00:00",
        "comment_author": "charettes",
        "comment_body": "As mentioned in the commit message the `connection.features.can_return_columns_from_insert` check was harmful as it prevented non-default databases usage of `RETURNING` for `Field.db_default` when the default database doesn't support `RETURNING` (e.g. a setup where the default database is MySQL but there is some usage of Postgres in other `DATABASES` entries).\r\n\r\nAs a rule of thumb any direct usage of `connection.features` (as opposed to `connections[alias].(features|ops)`) is harmful as it's not multi-engine aware.\r\n\r\nSee this example\r\n\r\nhttps://github.com/django/django/blob/dd133054cb98f77577c06d7ef1f2391a865784bc/django/db/models/fields/__init__.py#L1306-L1308\r\n\r\nor [that one](https://code.djangoproject.com/ticket/13528)\r\n\r\nhttps://github.com/django/django/blob/dd133054cb98f77577c06d7ef1f2391a865784bc/django/db/models/options.py#L234-L239",
        "pr_file_module": null
      },
      {
        "comment_id": "2147134109",
        "repo_full_name": "django/django",
        "pr_number": 19285,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2075470197",
        "commented_code": "@@ -932,9 +932,7 @@ def db_tablespace(self):\n     @property\n     def db_returning(self):\n         \"\"\"Private API intended only to be used by Django itself.\"\"\"\n-        return (\n-            self.has_db_default() and connection.features.can_return_columns_from_insert\n-        )\n+        return self.has_db_default()",
        "comment_created_at": "2025-06-14T18:43:25+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Sorry I read the commit message about 5 times to comprehend it, it may need some clarification & grammar adjustment :)\r\n\r\n> Determining if a field is db_returning based on the default connection feature\r\navailability\r\n\r\nI know it's in the diff but it helps to put `can_return_columns_from_insert` as I only made the connection after a couple of rereads...\r\n\r\n> prevent the usage of RETURNING for db_default fields in setups\r\nwhere non-default backends do support RETURNING\r\n\r\nprevents* or prevented* \u2026\u00a0it seems like a nitpick but with \"prevent\" it breaks the comprehension structure I'm forming in my head because it makes me think there's a different idea being presented.\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2147142734",
        "repo_full_name": "django/django",
        "pr_number": 19285,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2075470197",
        "commented_code": "@@ -932,9 +932,7 @@ def db_tablespace(self):\n     @property\n     def db_returning(self):\n         \"\"\"Private API intended only to be used by Django itself.\"\"\"\n-        return (\n-            self.has_db_default() and connection.features.can_return_columns_from_insert\n-        )\n+        return self.has_db_default()",
        "comment_created_at": "2025-06-14T18:48:06+00:00",
        "comment_author": "shangxiao",
        "comment_body": "oooh I get the scenario now:\r\n\r\n> (e.g. a setup where the default database is MySQL but there is some usage of Postgres in other DATABASES entries) ...\r\n> As a rule of thumb any direct usage of connection.features (as opposed to connections[alias].(features|ops)) is harmful as it's not multi-engine aware.\r\n\r\nI wasn't aware of this issue in the codebase so far & I totally agree now even though I never use multi-engine setups like this myself.  Nice find there Simon \ud83c\udfc6 \r\n\r\nI wonder if this should be documented somewhere... Where do we put all our design nuggets like this?  The trac wiki?  The documentation (somewhere in the contributing part)?  Code comments?  Should we at least add it to the commit message?",
        "pr_file_module": null
      },
      {
        "comment_id": "2147175091",
        "repo_full_name": "django/django",
        "pr_number": 19285,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2075470197",
        "commented_code": "@@ -932,9 +932,7 @@ def db_tablespace(self):\n     @property\n     def db_returning(self):\n         \"\"\"Private API intended only to be used by Django itself.\"\"\"\n-        return (\n-            self.has_db_default() and connection.features.can_return_columns_from_insert\n-        )\n+        return self.has_db_default()",
        "comment_created_at": "2025-06-14T19:10:19+00:00",
        "comment_author": "charettes",
        "comment_body": "Yeah you got it, I'm not a native speaker and it shows in cases like that \ud83d\ude48 Better commit messages are very welcome!\r\n\r\n> I wonder if this should be documented somewhere... Where do we put all our design nuggets like this? The trac wiki? The documentation (somewhere in the contributing part)? Code comments? Should we at least add it to the commit message?\r\n\r\nI'm not sure where the best place is to be honest, the contributing documentation seems a good location \ud83e\udd14  The tricky part is we don't even test mixed backend setups but it's very much a scenario for large Django projects in the wild particularly ones trying to move away from one backend to the other.\r\n\r\nThe tricky part is that in some cases a backend specific question has to be answered in a location that isn't backend specific aware (e.g. think of expression resolving), that's the reason why some direct `django.db.connection` usage have persisted over time.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2161775311",
    "pr_number": 19585,
    "pr_file": "django/db/models/fields/__init__.py",
    "created_at": "2025-06-23T14:28:40+00:00",
    "commented_code": "def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n-            *self._check_primary_key(),\n+            *self._check_primary_key(kwargs.get(\"databases\", [\"default\"])),\n         ]\n \n-    def _check_primary_key(self):\n-        if not self.primary_key:\n+    def _check_primary_key(self, databases):\n+        if not (\n+            self.primary_key\n+            or (\n+                all(\n+                    connections[db].features.supports_autofields_in_composite_pk\n+                    for db in databases\n+                )",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2161775311",
        "repo_full_name": "django/django",
        "pr_number": 19585,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2161775311",
        "commented_code": "@@ -2792,14 +2792,24 @@ def __init__(self, *args, **kwargs):\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n-            *self._check_primary_key(),\n+            *self._check_primary_key(kwargs.get(\"databases\", [\"default\"])),\n         ]\n \n-    def _check_primary_key(self):\n-        if not self.primary_key:\n+    def _check_primary_key(self, databases):\n+        if not (\n+            self.primary_key\n+            or (\n+                all(\n+                    connections[db].features.supports_autofields_in_composite_pk\n+                    for db in databases\n+                )",
        "comment_created_at": "2025-06-23T14:28:40+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Simon had recently mentioned that only checking the default connection's features was harmful in a multi-engine setup.  Is this what we want to do moving forward or just continue to use the default connection?  If so we may need to abstract this as it will catch folks out.",
        "pr_file_module": null
      },
      {
        "comment_id": "2163225871",
        "repo_full_name": "django/django",
        "pr_number": 19585,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2161775311",
        "commented_code": "@@ -2792,14 +2792,24 @@ def __init__(self, *args, **kwargs):\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n-            *self._check_primary_key(),\n+            *self._check_primary_key(kwargs.get(\"databases\", [\"default\"])),\n         ]\n \n-    def _check_primary_key(self):\n-        if not self.primary_key:\n+    def _check_primary_key(self, databases):\n+        if not (\n+            self.primary_key\n+            or (\n+                all(\n+                    connections[db].features.supports_autofields_in_composite_pk\n+                    for db in databases\n+                )",
        "comment_created_at": "2025-06-24T07:56:56+00:00",
        "comment_author": "shangxiao",
        "comment_body": "I suppose what I should instead be doing here is iterating over `connections` in full \ud83e\udd14",
        "pr_file_module": null
      },
      {
        "comment_id": "2165448936",
        "repo_full_name": "django/django",
        "pr_number": 19585,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2161775311",
        "commented_code": "@@ -2792,14 +2792,24 @@ def __init__(self, *args, **kwargs):\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n-            *self._check_primary_key(),\n+            *self._check_primary_key(kwargs.get(\"databases\", [\"default\"])),\n         ]\n \n-    def _check_primary_key(self):\n-        if not self.primary_key:\n+    def _check_primary_key(self, databases):\n+        if not (\n+            self.primary_key\n+            or (\n+                all(\n+                    connections[db].features.supports_autofields_in_composite_pk\n+                    for db in databases\n+                )",
        "comment_created_at": "2025-06-25T02:45:29+00:00",
        "comment_author": "shangxiao",
        "comment_body": "Also just wonder whether we may want to add something like this to `Field`:\r\n\r\n```\r\n    @cached_property\r\n    def part_of_pk(self):\r\n        return self.primary_key or self in getattr(self.model._meta.pk, \"pk\", [])\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2172623525",
        "repo_full_name": "django/django",
        "pr_number": 19585,
        "pr_file": "django/db/models/fields/__init__.py",
        "discussion_id": "2161775311",
        "commented_code": "@@ -2792,14 +2792,24 @@ def __init__(self, *args, **kwargs):\n     def check(self, **kwargs):\n         return [\n             *super().check(**kwargs),\n-            *self._check_primary_key(),\n+            *self._check_primary_key(kwargs.get(\"databases\", [\"default\"])),\n         ]\n \n-    def _check_primary_key(self):\n-        if not self.primary_key:\n+    def _check_primary_key(self, databases):\n+        if not (\n+            self.primary_key\n+            or (\n+                all(\n+                    connections[db].features.supports_autofields_in_composite_pk\n+                    for db in databases\n+                )",
        "comment_created_at": "2025-06-27T18:19:20+00:00",
        "comment_author": "charettes",
        "comment_body": ">  Is this what we want to do moving forward or just continue to use the default connection? If so we may need to abstract this as it will catch folks out.\r\n\r\nWe should most definitely *not* use the default connection. If not specified the check should not be performed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2002018554",
    "pr_number": 19196,
    "pr_file": "django/db/backends/mysql/features.py",
    "created_at": "2025-03-18T21:07:13+00:00",
    "commented_code": "if self.connection.mysql_is_mariadb:\n             return \"ONLY_FULL_GROUP_BY\" not in self.connection.sql_mode\n         return True\n+\n+    @cached_property\n+    def supports_any_value(self):\n+        if self.connection.mysql_is_mariadb:\n+            return False\n+        return \"ONLY_FULL_GROUP_BY\" in self.connection.sql_mode",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2002018554",
        "repo_full_name": "django/django",
        "pr_number": 19196,
        "pr_file": "django/db/backends/mysql/features.py",
        "discussion_id": "2002018554",
        "commented_code": "@@ -302,3 +293,9 @@ def allows_group_by_selected_pks(self):\n         if self.connection.mysql_is_mariadb:\n             return \"ONLY_FULL_GROUP_BY\" not in self.connection.sql_mode\n         return True\n+\n+    @cached_property\n+    def supports_any_value(self):\n+        if self.connection.mysql_is_mariadb:\n+            return False\n+        return \"ONLY_FULL_GROUP_BY\" in self.connection.sql_mode",
        "comment_created_at": "2025-03-18T21:07:13+00:00",
        "comment_author": "charettes",
        "comment_body": "Is it the case that MySQL doesn't support it when `ONLY_FULL_GROUP_BY` is disabled? I thought it was a noop in this case which means we could unconditionally allow its usage on MySQL.",
        "pr_file_module": null
      },
      {
        "comment_id": "2005965213",
        "repo_full_name": "django/django",
        "pr_number": 19196,
        "pr_file": "django/db/backends/mysql/features.py",
        "discussion_id": "2002018554",
        "commented_code": "@@ -302,3 +293,9 @@ def allows_group_by_selected_pks(self):\n         if self.connection.mysql_is_mariadb:\n             return \"ONLY_FULL_GROUP_BY\" not in self.connection.sql_mode\n         return True\n+\n+    @cached_property\n+    def supports_any_value(self):\n+        if self.connection.mysql_is_mariadb:\n+            return False\n+        return \"ONLY_FULL_GROUP_BY\" in self.connection.sql_mode",
        "comment_created_at": "2025-03-20T15:55:33+00:00",
        "comment_author": "ontowhee",
        "comment_body": "You're right, it should be supported unconditionally! I've removed the condition.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1997623238",
    "pr_number": 18823,
    "pr_file": "django/contrib/postgres/search.py",
    "created_at": "2025-03-16T13:51:59+00:00",
    "commented_code": "arg_joiner = \" <<<-> \"\n \n \n-class TrigramWordSimilarity(TrigramWordBase):\n-    function = \"WORD_SIMILARITY\"\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n \n+    def _combine(self, other, connector, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {other.__class__.__name__}.\"\n+            )\n+        return CombinedLexeme(self, connector, other)\n \n-class TrigramStrictWordSimilarity(TrigramWordBase):\n-    function = \"STRICT_WORD_SIMILARITY\"\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def bitor(self, other):\n+        return self._combine(other, self.BITOR)\n+\n+    def bitand(self, other):\n+        return self._combine(other, self.BITAND)\n+\n+    def __or__(self, other):\n+        return self.bitor(other)\n+\n+    def __and__(self, other):\n+        return self.bitand(other)\n+\n+    def __ror__(self, other):\n+        return self.bitor(other)\n+\n+    def __rand__(self, other):\n+        return self.bitand(other)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        if weight is not None and (\n+            not isinstance(weight, str) or weight.lower() not in {\"a\", \"b\", \"c\", \"d\"}\n+        ):\n+            raise ValueError(\n+                f\"Weight must be one of 'A', 'B', 'C', and 'D', got '{weight}'.\"\n+            )\n+\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def process_rhs(self, compiler, connection):\n+        escaped_value = psql_escape(self.value)\n+        if is_psycopg3:\n+            from psycopg.adapt import Dumper\n+\n+            class StringDumper(Dumper):\n+                def dump(self, obj):\n+                    return bytes(obj, \"utf-8\")\n+\n+            param = StringDumper(str).quote(escaped_value).decode()\n+        else:\n+            from psycopg2.extensions import adapt\n+\n+            param = adapt(escaped_value).getquoted().decode(\"latin-1\")",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1997623238",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1997623238",
        "commented_code": "@@ -375,9 +407,116 @@ class TrigramStrictWordDistance(TrigramWordBase):\n     arg_joiner = \" <<<-> \"\n \n \n-class TrigramWordSimilarity(TrigramWordBase):\n-    function = \"WORD_SIMILARITY\"\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n \n+    def _combine(self, other, connector, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {other.__class__.__name__}.\"\n+            )\n+        return CombinedLexeme(self, connector, other)\n \n-class TrigramStrictWordSimilarity(TrigramWordBase):\n-    function = \"STRICT_WORD_SIMILARITY\"\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def bitor(self, other):\n+        return self._combine(other, self.BITOR)\n+\n+    def bitand(self, other):\n+        return self._combine(other, self.BITAND)\n+\n+    def __or__(self, other):\n+        return self.bitor(other)\n+\n+    def __and__(self, other):\n+        return self.bitand(other)\n+\n+    def __ror__(self, other):\n+        return self.bitor(other)\n+\n+    def __rand__(self, other):\n+        return self.bitand(other)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        if weight is not None and (\n+            not isinstance(weight, str) or weight.lower() not in {\"a\", \"b\", \"c\", \"d\"}\n+        ):\n+            raise ValueError(\n+                f\"Weight must be one of 'A', 'B', 'C', and 'D', got '{weight}'.\"\n+            )\n+\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def process_rhs(self, compiler, connection):\n+        escaped_value = psql_escape(self.value)\n+        if is_psycopg3:\n+            from psycopg.adapt import Dumper\n+\n+            class StringDumper(Dumper):\n+                def dump(self, obj):\n+                    return bytes(obj, \"utf-8\")\n+\n+            param = StringDumper(str).quote(escaped_value).decode()\n+        else:\n+            from psycopg2.extensions import adapt\n+\n+            param = adapt(escaped_value).getquoted().decode(\"latin-1\")",
        "comment_created_at": "2025-03-16T13:51:59+00:00",
        "comment_author": "jacobtylerwalls",
        "comment_body": "`UnicodeEncodeError` escapes for emoji. I'm assuming that's fine, but just wondering if you think there's a place we should document this since it applies for the psycopg2 implementation only.\r\n\r\nOr, perhaps we should fail at the python level with an informative exception if a non-utf-8 char is used, since adding emoji seems to be ignored by postgres (no tests fail when I adjust the prefixes to end with emoji).",
        "pr_file_module": null
      },
      {
        "comment_id": "1999465639",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1997623238",
        "commented_code": "@@ -375,9 +407,116 @@ class TrigramStrictWordDistance(TrigramWordBase):\n     arg_joiner = \" <<<-> \"\n \n \n-class TrigramWordSimilarity(TrigramWordBase):\n-    function = \"WORD_SIMILARITY\"\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n \n+    def _combine(self, other, connector, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {other.__class__.__name__}.\"\n+            )\n+        return CombinedLexeme(self, connector, other)\n \n-class TrigramStrictWordSimilarity(TrigramWordBase):\n-    function = \"STRICT_WORD_SIMILARITY\"\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def bitor(self, other):\n+        return self._combine(other, self.BITOR)\n+\n+    def bitand(self, other):\n+        return self._combine(other, self.BITAND)\n+\n+    def __or__(self, other):\n+        return self.bitor(other)\n+\n+    def __and__(self, other):\n+        return self.bitand(other)\n+\n+    def __ror__(self, other):\n+        return self.bitor(other)\n+\n+    def __rand__(self, other):\n+        return self.bitand(other)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        if weight is not None and (\n+            not isinstance(weight, str) or weight.lower() not in {\"a\", \"b\", \"c\", \"d\"}\n+        ):\n+            raise ValueError(\n+                f\"Weight must be one of 'A', 'B', 'C', and 'D', got '{weight}'.\"\n+            )\n+\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def process_rhs(self, compiler, connection):\n+        escaped_value = psql_escape(self.value)\n+        if is_psycopg3:\n+            from psycopg.adapt import Dumper\n+\n+            class StringDumper(Dumper):\n+                def dump(self, obj):\n+                    return bytes(obj, \"utf-8\")\n+\n+            param = StringDumper(str).quote(escaped_value).decode()\n+        else:\n+            from psycopg2.extensions import adapt\n+\n+            param = adapt(escaped_value).getquoted().decode(\"latin-1\")",
        "comment_created_at": "2025-03-17T19:20:49+00:00",
        "comment_author": "GappleBee",
        "comment_body": "I'm gearing more towards an exception being raised, if we allow emojis in the string we would need to provide `adapt` with an active dummy connection (configured with an encoding which can encode emojis)",
        "pr_file_module": null
      },
      {
        "comment_id": "2008959165",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1997623238",
        "commented_code": "@@ -375,9 +407,116 @@ class TrigramStrictWordDistance(TrigramWordBase):\n     arg_joiner = \" <<<-> \"\n \n \n-class TrigramWordSimilarity(TrigramWordBase):\n-    function = \"WORD_SIMILARITY\"\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n \n+    def _combine(self, other, connector, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {other.__class__.__name__}.\"\n+            )\n+        return CombinedLexeme(self, connector, other)\n \n-class TrigramStrictWordSimilarity(TrigramWordBase):\n-    function = \"STRICT_WORD_SIMILARITY\"\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def bitor(self, other):\n+        return self._combine(other, self.BITOR)\n+\n+    def bitand(self, other):\n+        return self._combine(other, self.BITAND)\n+\n+    def __or__(self, other):\n+        return self.bitor(other)\n+\n+    def __and__(self, other):\n+        return self.bitand(other)\n+\n+    def __ror__(self, other):\n+        return self.bitor(other)\n+\n+    def __rand__(self, other):\n+        return self.bitand(other)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        if weight is not None and (\n+            not isinstance(weight, str) or weight.lower() not in {\"a\", \"b\", \"c\", \"d\"}\n+        ):\n+            raise ValueError(\n+                f\"Weight must be one of 'A', 'B', 'C', and 'D', got '{weight}'.\"\n+            )\n+\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def process_rhs(self, compiler, connection):\n+        escaped_value = psql_escape(self.value)\n+        if is_psycopg3:\n+            from psycopg.adapt import Dumper\n+\n+            class StringDumper(Dumper):\n+                def dump(self, obj):\n+                    return bytes(obj, \"utf-8\")\n+\n+            param = StringDumper(str).quote(escaped_value).decode()\n+        else:\n+            from psycopg2.extensions import adapt\n+\n+            param = adapt(escaped_value).getquoted().decode(\"latin-1\")",
        "comment_created_at": "2025-03-22T22:28:38+00:00",
        "comment_author": "GappleBee",
        "comment_body": "On second thoughts, limiting the character set to `latin-1` won't be enough to cover all possible characters supported by postgres lexemes seeing as they support a wide range of languages. ~~I think there is a way to do `utf-8` encoding (consistent with psycopg3 branch) without an active dummy connection using `QuotedString`~~ Turns out one could just set the encoding of `adapt` directly",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1251892923",
    "pr_number": 16851,
    "pr_file": "django/db/backends/base/operations.py",
    "created_at": "2023-07-04T11:21:32+00:00",
    "commented_code": "if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1251892923",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-07-04T11:21:32+00:00",
        "comment_author": "ngnpope",
        "comment_body": "What about `\"NO ACTION\"` and `\"SET DEFAULT\"`? See:\r\n\r\n- https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK\r\n- https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html\r\n- https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/constraint.html#GUID-1055EA97-BA6F-4764-A15F-1024FD5B6DFE__GUID-8E388631-3D99-4445-A2CD-A8776E8CEFC1\r\n- https://www.sqlite.org/foreignkeys.html#fk_actions\r\n\r\nLooks like Oracle is the only one that wouldn't support these. (And notably, it also doesn't look like it supports `\"RESTRICT\"`.\r\n\r\nFor `\"SET DEFAULT\"` we'd also need to ensure that `db_default` is set on the field. (Recently added to Django 5.0)",
        "pr_file_module": null
      },
      {
        "comment_id": "1274400937",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-07-26T05:42:18+00:00",
        "comment_author": "Akash-Kumar-Sen",
        "comment_body": "Thank you for the review Nick. Will try to add the `DB_SET_DEFAULT` in the next commit and add a warning message for oracle database, in that case we may redirect to django based `RESTRICT`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1278423773",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-07-29T21:18:34+00:00",
        "comment_author": "NickStefan",
        "comment_body": "In the original PR, I think we left out NO_ACTION since it's the default FK behavior--even if you don't add an `ON DELETE...` statement. It's likely equivalent to django's DO_NOTHING. It wouldn't hurt to add it for completeness, but it might also add unnecessary options that do the same thing. Seems like a style preference. \r\n\r\n~@ngnpope how sure are you about Oracle not supporting RESTRICT? Im not an oracle expert, but the language linked makes it seem like only _views_ dont support RESTRICT (but maybe tables would?).~\r\n\r\n> Restriction on ON DELETE\r\n> You cannot specify this clause for a view constraint.\r\n\r\nEDIT: ah I misread; it sounds like `ON DELETE $statement` cannot be specified for views in Oracle. There's no mention of RESTRICT. I saw \"restrictions\" and my brain thought \"restrict\" \ud83e\udd26 .\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1282740262",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-08-03T07:02:54+00:00",
        "comment_author": "ngnpope",
        "comment_body": "> In the original PR, I think we left out NO_ACTION since it's the default FK behavior--even if you don't add an ON DELETE... statement. It's likely equivalent to django's DO_NOTHING. It wouldn't hurt to add it for completeness, but it might also add unnecessary options that do the same thing. Seems like a style preference.\r\n\r\nMy concern was that `DO_NOTHING` makes no changes to the database. So if you've set, e.g. `DB_RESTRICT` and change to `DO_NOTHING` then the database would still be using `RESTRICT` because no migration would be generated? Because there is nothing to `ALTER` it to `NO ACTION`? I haven't had time to investigate this in detail - it's a hunch - but we should have tests for all transitions between database-managed and \"traditional\" `on_delete` options.\r\n\r\nThis is also why I've thought it might be cleaner to have a `db_on_delete` like we have a `db_default`... We need to get this right - not rush - as we'll be stuck with the decision.",
        "pr_file_module": null
      },
      {
        "comment_id": "1283305225",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-08-03T14:38:28+00:00",
        "comment_author": "NickStefan",
        "comment_body": "Good point on migrations. It's been a while since Ive used django.\r\n\r\nIIRC, the migrations aren't persisted as raw SQL though, right? So wouldnt changing the kwarg to DO_NOTHING possibly still *serialize* differently into the migration file than DB_CASCADE? And if it serializes differently, wont that then be able to generate new SQL for the table? I guess it's possible that wouldnt be backwards compatible though--if someone already has migrations manually adding ON DELETE CASCADE but they put DO_NOTHING in their python code...\r\n\r\nOkay, thinking about it, I guess DB_NO_ACTION makes sense \ud83d\udc4d . For further compatibility with the DBs that dont support the `NO ACTION` statement, it might just need to compile to an empty ON DELETE statement. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1283572734",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-08-03T18:30:18+00:00",
        "comment_author": "ngnpope",
        "comment_body": "Yeah, I wouldn't honestly know without trying - just have a hunch \ud83e\udd37\ud83c\udffb \r\n\r\nBest thing is to ensure that there are comprehensive tests migrating between all possible options.",
        "pr_file_module": null
      },
      {
        "comment_id": "1285356671",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-08-07T04:03:54+00:00",
        "comment_author": "felixxm",
        "comment_body": "> Best thing is to ensure that there are comprehensive tests migrating between all possible options.\r\n\r\nYes, we need migration tests.",
        "pr_file_module": null
      },
      {
        "comment_id": "1305132305",
        "repo_full_name": "django/django",
        "pr_number": 16851,
        "pr_file": "django/db/backends/base/operations.py",
        "discussion_id": "1251892923",
        "commented_code": "@@ -260,6 +260,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\"]:",
        "comment_created_at": "2023-08-25T04:46:40+00:00",
        "comment_author": "Akash-Kumar-Sen",
        "comment_body": "Added tests for migrations.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "313062032",
    "pr_number": 11652,
    "pr_file": "django/db/models/expressions.py",
    "created_at": "2019-08-12T18:21:12+00:00",
    "commented_code": "sql = 'NOT {}'.format(sql)\n         return sql, params\n \n-    def as_oracle(self, compiler, connection, template=None, **extra_context):\n+    def select_format(self, compiler, sql, params):\n         # Oracle doesn't allow EXISTS() in the SELECT list, so wrap it with a\n-        # CASE WHEN expression. Change the template since the When expression\n-        # requires a left hand side (column) to compare against.\n-        sql, params = self.as_sql(compiler, connection, template, **extra_context)\n-        sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        # CASE WHEN expression.\n+        if compiler.connection.vendor == 'oracle':",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "313062032",
        "repo_full_name": "django/django",
        "pr_number": 11652,
        "pr_file": "django/db/models/expressions.py",
        "discussion_id": "313062032",
        "commented_code": "@@ -1068,12 +1075,11 @@ def as_sql(self, compiler, connection, template=None, **extra_context):\n             sql = 'NOT {}'.format(sql)\n         return sql, params\n \n-    def as_oracle(self, compiler, connection, template=None, **extra_context):\n+    def select_format(self, compiler, sql, params):\n         # Oracle doesn't allow EXISTS() in the SELECT list, so wrap it with a\n-        # CASE WHEN expression. Change the template since the When expression\n-        # requires a left hand side (column) to compare against.\n-        sql, params = self.as_sql(compiler, connection, template, **extra_context)\n-        sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        # CASE WHEN expression.\n+        if compiler.connection.vendor == 'oracle':",
        "comment_created_at": "2019-08-12T18:21:12+00:00",
        "comment_author": "felixxm",
        "comment_body": "Maybe we could add and use here a db feature e.g. `supports_boolean_in_select_clause` (we have e.g. `supports_default_in_lead_lag` so it seems reasonable).",
        "pr_file_module": null
      },
      {
        "comment_id": "313071001",
        "repo_full_name": "django/django",
        "pr_number": 11652,
        "pr_file": "django/db/models/expressions.py",
        "discussion_id": "313062032",
        "commented_code": "@@ -1068,12 +1075,11 @@ def as_sql(self, compiler, connection, template=None, **extra_context):\n             sql = 'NOT {}'.format(sql)\n         return sql, params\n \n-    def as_oracle(self, compiler, connection, template=None, **extra_context):\n+    def select_format(self, compiler, sql, params):\n         # Oracle doesn't allow EXISTS() in the SELECT list, so wrap it with a\n-        # CASE WHEN expression. Change the template since the When expression\n-        # requires a left hand side (column) to compare against.\n-        sql, params = self.as_sql(compiler, connection, template, **extra_context)\n-        sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        # CASE WHEN expression.\n+        if compiler.connection.vendor == 'oracle':",
        "comment_created_at": "2019-08-12T18:40:37+00:00",
        "comment_author": "charettes",
        "comment_body": "@felixxm do you know if _other_ boolean expressions work in `SELECT` for Oracle?\r\n\r\ne.g. `(TABLE.COLUMN > 3) AS gt_3`?\r\n\r\nIf that's not the case then I guess this boolean flag could be used to add support for `.annotate(gt_3=Q(column__gt3))` in the future as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "313076772",
        "repo_full_name": "django/django",
        "pr_number": 11652,
        "pr_file": "django/db/models/expressions.py",
        "discussion_id": "313062032",
        "commented_code": "@@ -1068,12 +1075,11 @@ def as_sql(self, compiler, connection, template=None, **extra_context):\n             sql = 'NOT {}'.format(sql)\n         return sql, params\n \n-    def as_oracle(self, compiler, connection, template=None, **extra_context):\n+    def select_format(self, compiler, sql, params):\n         # Oracle doesn't allow EXISTS() in the SELECT list, so wrap it with a\n-        # CASE WHEN expression. Change the template since the When expression\n-        # requires a left hand side (column) to compare against.\n-        sql, params = self.as_sql(compiler, connection, template, **extra_context)\n-        sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        # CASE WHEN expression.\n+        if compiler.connection.vendor == 'oracle':",
        "comment_created_at": "2019-08-12T18:53:42+00:00",
        "comment_author": "felixxm",
        "comment_body": "No, they are not supported, because `BOOLEAN` datatype is available only in PL/SQL on Oracle, so `SELECT` clause cannot return it.",
        "pr_file_module": null
      },
      {
        "comment_id": "313084502",
        "repo_full_name": "django/django",
        "pr_number": 11652,
        "pr_file": "django/db/models/expressions.py",
        "discussion_id": "313062032",
        "commented_code": "@@ -1068,12 +1075,11 @@ def as_sql(self, compiler, connection, template=None, **extra_context):\n             sql = 'NOT {}'.format(sql)\n         return sql, params\n \n-    def as_oracle(self, compiler, connection, template=None, **extra_context):\n+    def select_format(self, compiler, sql, params):\n         # Oracle doesn't allow EXISTS() in the SELECT list, so wrap it with a\n-        # CASE WHEN expression. Change the template since the When expression\n-        # requires a left hand side (column) to compare against.\n-        sql, params = self.as_sql(compiler, connection, template, **extra_context)\n-        sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        # CASE WHEN expression.\n+        if compiler.connection.vendor == 'oracle':",
        "comment_created_at": "2019-08-12T19:12:56+00:00",
        "comment_author": "charettes",
        "comment_body": "@felixxm thanks for confirming.\r\n\r\nThen a `supports_boolean_expr_in_select_clause` flag might be more appropriate then because `supports_boolean_in_select_clause` might be confusing for `Col(output_field=BooleanField())`?",
        "pr_file_module": null
      },
      {
        "comment_id": "313085533",
        "repo_full_name": "django/django",
        "pr_number": 11652,
        "pr_file": "django/db/models/expressions.py",
        "discussion_id": "313062032",
        "commented_code": "@@ -1068,12 +1075,11 @@ def as_sql(self, compiler, connection, template=None, **extra_context):\n             sql = 'NOT {}'.format(sql)\n         return sql, params\n \n-    def as_oracle(self, compiler, connection, template=None, **extra_context):\n+    def select_format(self, compiler, sql, params):\n         # Oracle doesn't allow EXISTS() in the SELECT list, so wrap it with a\n-        # CASE WHEN expression. Change the template since the When expression\n-        # requires a left hand side (column) to compare against.\n-        sql, params = self.as_sql(compiler, connection, template, **extra_context)\n-        sql = 'CASE WHEN {} THEN 1 ELSE 0 END'.format(sql)\n+        # CASE WHEN expression.\n+        if compiler.connection.vendor == 'oracle':",
        "comment_created_at": "2019-08-12T19:15:51+00:00",
        "comment_author": "felixxm",
        "comment_body": "Agreed :+1: ",
        "pr_file_module": null
      }
    ]
  }
]