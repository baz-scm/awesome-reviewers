[
  {
    "discussion_id": "1829204534",
    "pr_number": 18627,
    "pr_file": "docs/topics/tasks.txt",
    "created_at": "2024-11-05T11:39:24+00:00",
    "commented_code": "+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1829204534",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829204534",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.",
        "comment_created_at": "2024-11-05T11:39:24+00:00",
        "comment_author": "rtpg",
        "comment_body": "took me a second to process this... I understand what is being said here, but it kind of feels like it's more a warning that should be placed on other backends/the \"enqueue on commit\" setting docs? Like \"if you don't enqueue on commit, then it's likely that the view of the data from the enqueuer and the dequeuer will differ\".\r\n\r\n```\r\nwith transaction.atomic():\r\n  thing = Thing.objects.create()\r\n  some_task.enqueue(thing_id=obj.id)\r\n  some_long_calculation()\r\n\r\n\r\ndef some_task(thing_id):\r\n   obj = Thing.objects.get(id=thing_id)  # this might not be available yet!\r\n   # if the task is run before some_long_calculation() finishes!\r\n```\r\n\r\n^ like the above is the issue, not `ImmediateBackend` running in the same transaction, right?\r\n\r\nOr are you referring to something a bit more subtle here?",
        "pr_file_module": null
      },
      {
        "comment_id": "1850625008",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829204534",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.",
        "comment_created_at": "2024-11-20T16:24:02+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "Yeah that's what it's trying to cover. It's specifically worth mentioning with `ImmediateBackend`, which is different to others, since it disguises some issues:\r\n\r\n```python\r\n@task\r\ndef my_task():\r\n    Thing.objects.get()\r\n\r\nwith transaction.atomic():\r\n    Thing.objects.create()\r\n    my_task.enqueue()\r\n```\r\n\r\nWith the above and `ENQUEUE_ON_COMMIT = False`, if `ImmediateBackend` is used, it will work, since the task is run within the same transaction. Just changing the backend to something else (eg a redis backend), it could fail, since the task could run before the transaction commits.",
        "pr_file_module": null
      },
      {
        "comment_id": "1851300175",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829204534",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.",
        "comment_created_at": "2024-11-21T04:16:15+00:00",
        "comment_author": "rtpg",
        "comment_body": "```\r\n@task\r\ndef my_task():\r\n    Thing.objects.get()\r\n\r\nwith transaction.atomic():\r\n    Thing.objects.create()\r\n    my_task.enqueue()\r\n```\r\n\r\nThe counter-example here is that with the above code and `ENQUEUE_ON_COMMIT = True`, _every backend works_, including `ImmediateBackend`. `ENQUEUE_ON_COMMIT = False` is, by default, a mistake. You have to have a pretty good reason for setting that, and it's very unlikely that task code that is in any shared code would work correctly in that environment.\r\n\r\nI would put a warning box next to the general `ENQUEUE_ON_COMMIT` documentation saying something like the following (with the code example):\r\n\r\n\r\n> by default, task enqueues happen when any existing database transaction is committed. On most backend, tasks will be run in an entirely separate process, using a different database connection. Without waiting for a commit, task workers could try to start processing before the triggering transaction is committed (or rolled back!)\r\n> \r\n> Imagine the following code example:\r\n> \r\n>  (code example here)\r\n> \r\n>. If `ENQUEUE_ON_COMMIT` is set to `False`, then it is possible for `my_task` to run before the object is committed to the database, and the task won't be able to see the created object within your transaction. In simpler cases the latency is often enough that you do not see this problem, but background tasks running before a transaction is committed (or queueing tasks despite a transaction being rolled back!) is a common bug in systems that don't code defensively around this problem. But `ENQUEUE_ON_COMMIT` being set to `True` avoids this problem.\r\n\r\n\"`ImmediateBackend` works when it shouldn't in this case\" feels less important to me than \"basically every backend won't work if this setting is set wrong\". ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1829235788",
    "pr_number": 18627,
    "pr_file": "docs/topics/tasks.txt",
    "created_at": "2024-11-05T12:04:09+00:00",
    "commented_code": "+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1829235788",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829235788",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
        "comment_created_at": "2024-11-05T12:04:09+00:00",
        "comment_author": "rtpg",
        "comment_body": "What is the impetus for this functionality? Is there some obvious issue that could occur that I'm missing?",
        "pr_file_module": null
      },
      {
        "comment_id": "1835041515",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829235788",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
        "comment_created_at": "2024-11-08T20:47:00+00:00",
        "comment_author": "rtr1",
        "comment_body": "Hello @rtpg, which part are you referring to?\r\n\r\n1.  *Restrict the queue names a task may be enqueued to*\r\n\r\n2. *By default, only the ``\"default\"`` queue is allowed*\r\n\r\n3. *Queue name validation can be disabled by setting this to an empty list.*\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1835620130",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829235788",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
        "comment_created_at": "2024-11-10T08:22:50+00:00",
        "comment_author": "rtpg",
        "comment_body": "I am referring to the setting in general. Personally, I would not use this restriction. Not because I am expecting to dynamically create queues, but just that it feels like it would be Yet Another Thing To Remember To Do when adding tasks.\r\n\r\nI don't feel strongly about this, though. If this feels like a useful safeguard to people, then it's a useful safeguard.",
        "pr_file_module": null
      },
      {
        "comment_id": "1835748268",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829235788",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
        "comment_created_at": "2024-11-10T17:43:54+00:00",
        "comment_author": "rtr1",
        "comment_body": "The use case that I\u2019ve encountered is when there are specific workers that must handle a particular task.\r\n\r\nA real world example is pulling data from branch office databases. Suppose an instance of Postgres is running inside a corporate network in New York, and another instance of Postgres is running in London. Both of those sit inside private corporate networks, not publicly accessible.\r\n\r\nTo make these ETL pipelines work, we need a worker running in New York and one in London. The `refresh_newyork_data()` task must run on the New York worker, and the `refresh_london_data()` must run on the London worker.",
        "pr_file_module": null
      },
      {
        "comment_id": "1850629198",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829235788",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
        "comment_created_at": "2024-11-20T16:26:40+00:00",
        "comment_author": "RealOrangeOne",
        "comment_body": "The reason to restrict is to avoid potential issues. If you typo a queue name, it could mean the task gets enqueued, exists, but never gets executed. This ensures only valid queue names can be enqueued. Similar to `choices` for a `CharField`",
        "pr_file_module": null
      },
      {
        "comment_id": "1850887229",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829235788",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
        "comment_created_at": "2024-11-20T19:44:13+00:00",
        "comment_author": "rtpg",
        "comment_body": "That's a convincing reason! Sounds good ",
        "pr_file_module": null
      },
      {
        "comment_id": "1874069161",
        "repo_full_name": "django/django",
        "pr_number": 18627,
        "pr_file": "docs/topics/tasks.txt",
        "discussion_id": "1829235788",
        "commented_code": "@@ -0,0 +1,337 @@\n+========================\n+Django's tasks framework\n+========================\n+\n+For a web application, there's often more than just turning HTTP requests into\n+HTTP responses. For some functionality, it may be beneficial to run code outside\n+of the request-response cycle.\n+\n+That's where background tasks come in.\n+\n+Background tasks can offload complexity outside of the request-response cycle,\n+to be run somewhere else, potentially at a later date. This keeps requests fast,\n+latency down, and improves the user's experience.\n+\n+Background task fundamentals\n+============================\n+\n+When work needs to be done in the background, Django creates a Task, which is\n+stored in the Queue Store. This task contains all of the metadata needed to\n+execute the task, as well as a unique identifier for Django to retrieve the\n+result later.\n+\n+Outside of Django, a Worker looks at the Queue Store for new Tasks to run. When\n+a new Task is added, the Worker claims the task, executes it, and saves the\n+status and result back to the Queue Store.\n+\n+.. _configuring-a-task-backend:\n+\n+Configuring a Task backend\n+==========================\n+\n+Background tasks require some work to set up.\n+\n+Different task backends have different characteristics and configuration options,\n+which may impact the performance and reliability of your application.\n+\n+Task backends are configured using the :setting:`TASKS` setting in your settings\n+file.\n+\n+.. _immediate-task-backend:\n+\n+Immediate execution\n+-------------------\n+\n+This is the default backend if another is not specified in your settings file.\n+The immediate backend runs enqueued tasks immediately, rather than in the\n+background. This allows background task functionality to be slowly added\n+to an application, before the required infrastructure is available.\n+\n+.. warning::\n+\n+    When :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>` is ``False``,\n+    the task will be executed within the same transaction it was enqueued in.\n+\n+    This may lead to unexpected behavior changes when changing backend in future.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.immediate.ImmediateBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.immediate.ImmediateBackend\"}}\n+\n+.. _dummy-task-backend:\n+\n+Dummy backend\n+-------------\n+\n+The dummy backend doesn't execute enqueued tasks at all, instead storing results\n+for later use.\n+\n+This backend is not intended for use in production - it is provided as a\n+convenience that can be used during development and testing.\n+\n+To use it, set :setting:`BACKEND <TASKS-BACKEND>` to\n+``\"django.tasks.backends.dummy.DummyBackend\"``::\n+\n+    TASKS = {\"default\": {\"BACKEND\": \"django.tasks.backends.dummy.DummyBackend\"}}\n+\n+The results for enqueued tasks can be retrieved from the backend's\n+:attr:`results <django.tasks.backends.dummy.DummyBackend.results>` attribute::\n+\n+    from django.tasks import default_task_backend\n+\n+    my_task.enqueue()\n+\n+    assert len(default_task_backend.results) == 1\n+\n+Stored results can be cleared using the\n+:meth:`clear <django.tasks.backends.dummy.DummyBackend.clear>` method::\n+\n+    default_task_backend.clear()\n+\n+    assert len(default_task_backend.results) == 0\n+\n+Using a custom backend\n+----------------------\n+\n+While Django includes support for a number of task backends out-of-the-box,\n+sometimes you might want to customize the the task backend. To use an external\n+task backend with Django, use the Python import path as the\n+:setting:`BACKEND <TASKS-BACKEND>` of the :setting:`TASKS` setting, like so::\n+\n+    TASKS = {\n+        \"default\": {\n+            \"BACKEND\": \"path.to.backend\",\n+        }\n+    }\n+\n+If you're building your own backend, you can use the standard task backends\n+as reference implementations. You'll find the code in the\n+:source:`django/tasks/backends/` directory of the Django source.\n+\n+Backend arguments\n+-----------------\n+\n+Each backend can be given additional arguments to control its behavior.\n+These arguments are provided as additional keys in the :setting:`TASKS` setting.\n+Valid arguments are as follows:\n+\n+* :setting:`ENQUEUE_ON_COMMIT <TASKS-ENQUEUE_ON_COMMIT>`: Whether a task should\n+  be enqueued at the end of the current transaction (if there\n+  is one) commits successfully, rather than enqueueing immediately. This argument\n+  defaults to ``True``.\n+\n+* :setting:`QUEUES <TASKS-QUEUES>`: Restrict the queue names a task may be\n+  enqueued to. By default, only the ``\"default\"`` queue is allowed. Queue name\n+  validation can be disabled by setting this to an empty list.",
        "comment_created_at": "2024-12-06T22:32:38+00:00",
        "comment_author": "ericholscher",
        "comment_body": "It would be useful to include this example in the docs, so people better understand why this is useful. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2071209221",
    "pr_number": 18660,
    "pr_file": "docs/ref/models/database-functions.txt",
    "created_at": "2025-05-02T07:23:25+00:00",
    "commented_code": "2015-06-15 14:30:50.000321\n     2015-06-15 14:40:02.000123\n \n+.. warning::\n+\n+    ``Trunc`` functions, at the database level, return a timezone naive value\n+    which is converted to a timezone aware value by the ORM. When you use a\n+    ``Trunc`` function in a filter you will need to remember that it is a\n+    timezone naive value. This can lead to unexpected results if you are using\n+    timezones other than UTC. Django will store date/time values in the\n+    database in the UTC timezone. The following example demonstrates what\n+    happens when using the timezone \"Europe/Berlin\" and how to adjust for this:",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2071209221",
        "repo_full_name": "django/django",
        "pr_number": 18660,
        "pr_file": "docs/ref/models/database-functions.txt",
        "discussion_id": "2071209221",
        "commented_code": "@@ -633,6 +633,37 @@ Usage example:\n     2015-06-15 14:30:50.000321\n     2015-06-15 14:40:02.000123\n \n+.. warning::\n+\n+    ``Trunc`` functions, at the database level, return a timezone naive value\n+    which is converted to a timezone aware value by the ORM. When you use a\n+    ``Trunc`` function in a filter you will need to remember that it is a\n+    timezone naive value. This can lead to unexpected results if you are using\n+    timezones other than UTC. Django will store date/time values in the\n+    database in the UTC timezone. The following example demonstrates what\n+    happens when using the timezone \"Europe/Berlin\" and how to adjust for this:",
        "comment_created_at": "2025-05-02T07:23:25+00:00",
        "comment_author": "ontowhee",
        "comment_body": "Is \"Europe/Berlin\" coming from settings.TIME_ZONE?",
        "pr_file_module": null
      },
      {
        "comment_id": "2072467523",
        "repo_full_name": "django/django",
        "pr_number": 18660,
        "pr_file": "docs/ref/models/database-functions.txt",
        "discussion_id": "2071209221",
        "commented_code": "@@ -633,6 +633,37 @@ Usage example:\n     2015-06-15 14:30:50.000321\n     2015-06-15 14:40:02.000123\n \n+.. warning::\n+\n+    ``Trunc`` functions, at the database level, return a timezone naive value\n+    which is converted to a timezone aware value by the ORM. When you use a\n+    ``Trunc`` function in a filter you will need to remember that it is a\n+    timezone naive value. This can lead to unexpected results if you are using\n+    timezones other than UTC. Django will store date/time values in the\n+    database in the UTC timezone. The following example demonstrates what\n+    happens when using the timezone \"Europe/Berlin\" and how to adjust for this:",
        "comment_created_at": "2025-05-03T21:14:35+00:00",
        "comment_author": "coolbootscoder",
        "comment_body": "Yes, I am referring to the time zone in the settings file. I selected \"Europe/Berlin\" because the ticket's reporter had used that time zone.",
        "pr_file_module": null
      }
    ]
  }
]