[
  {
    "discussion_id": "2154983893",
    "pr_number": 19393,
    "pr_file": "django/core/checks/security/base.py",
    "created_at": "2025-06-18T15:58:59+00:00",
    "commented_code": "W025 = Warning(SECRET_KEY_WARNING_MSG, id=\"security.W025\")\n \n+E026 = Error(\n+    \"The Content Security Policy setting '%s' must be a dictionary.\",\n+    id=\"security.E026\",",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2154983893",
        "repo_full_name": "django/django",
        "pr_number": 19393,
        "pr_file": "django/core/checks/security/base.py",
        "discussion_id": "2154983893",
        "commented_code": "@@ -141,6 +140,11 @@\n \n W025 = Warning(SECRET_KEY_WARNING_MSG, id=\"security.W025\")\n \n+E026 = Error(\n+    \"The Content Security Policy setting '%s' must be a dictionary.\",\n+    id=\"security.E026\",",
        "comment_created_at": "2025-06-18T15:58:59+00:00",
        "comment_author": "nessita",
        "comment_body": "I would include the received value, to ease debugging and spare the user of having to pdb or add a print/log:\r\n```suggestion\r\n    \"The Content Security Policy setting '%s' must be a dictionary (got %r instead).\",\r\n    id=\"security.E026\",\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1851127142",
    "pr_number": 18823,
    "pr_file": "django/contrib/postgres/search.py",
    "created_at": "2024-11-20T23:44:18+00:00",
    "commented_code": "from django.db.models.expressions import CombinedExpression, register_combinable_fields\n from django.db.models.functions import Cast, Coalesce\n \n+_SEARCH_SPEC_CHARS = r\"['\\0\\[\\]()|&:*!@<>\\\\]\"\n+_spec_chars_re = re.compile(_SEARCH_SPEC_CHARS)\n+multiple_spaces_re = re.compile(r\"\\s{2,}\")\n+\n+\n+def normalize_spaces(val: str):\n+    \"\"\"Converts multiple spaces to single and strips from both sides\"\"\"\n+    if not val:\n+        return None\n+    return multiple_spaces_re.sub(\" \", val.strip())\n+\n+\n+def psql_escape(query: str):\n+    # replace unsafe chars with space\n+    query = _spec_chars_re.sub(\" \", query)\n+    query = normalize_spaces(query)  # convert multiple spaces to single\n+    return query",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1851127142",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1851127142",
        "commented_code": "@@ -11,6 +13,24 @@\n from django.db.models.expressions import CombinedExpression, register_combinable_fields\n from django.db.models.functions import Cast, Coalesce\n \n+_SEARCH_SPEC_CHARS = r\"['\\0\\[\\]()|&:*!@<>\\\\]\"\n+_spec_chars_re = re.compile(_SEARCH_SPEC_CHARS)\n+multiple_spaces_re = re.compile(r\"\\s{2,}\")\n+\n+\n+def normalize_spaces(val: str):\n+    \"\"\"Converts multiple spaces to single and strips from both sides\"\"\"\n+    if not val:\n+        return None\n+    return multiple_spaces_re.sub(\" \", val.strip())\n+\n+\n+def psql_escape(query: str):\n+    # replace unsafe chars with space\n+    query = _spec_chars_re.sub(\" \", query)\n+    query = normalize_spaces(query)  # convert multiple spaces to single\n+    return query",
        "comment_created_at": "2024-11-20T23:44:18+00:00",
        "comment_author": "pauloxnet",
        "comment_body": "```suggestion\n    \"\"\"Replace unsafe chars with space and convert multiple spaces to single.\"\"\"\n    return normalize_spaces(_spec_chars_re.sub(\" \", query))\n```\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1986161989",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1851127142",
        "commented_code": "@@ -11,6 +13,24 @@\n from django.db.models.expressions import CombinedExpression, register_combinable_fields\n from django.db.models.functions import Cast, Coalesce\n \n+_SEARCH_SPEC_CHARS = r\"['\\0\\[\\]()|&:*!@<>\\\\]\"\n+_spec_chars_re = re.compile(_SEARCH_SPEC_CHARS)\n+multiple_spaces_re = re.compile(r\"\\s{2,}\")\n+\n+\n+def normalize_spaces(val: str):\n+    \"\"\"Converts multiple spaces to single and strips from both sides\"\"\"\n+    if not val:\n+        return None\n+    return multiple_spaces_re.sub(\" \", val.strip())\n+\n+\n+def psql_escape(query: str):\n+    # replace unsafe chars with space\n+    query = _spec_chars_re.sub(\" \", query)\n+    query = normalize_spaces(query)  # convert multiple spaces to single\n+    return query",
        "comment_created_at": "2025-03-08T21:53:48+00:00",
        "comment_author": "pauloxnet",
        "comment_body": "This comment seems still valid ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1958503984",
    "pr_number": 18823,
    "pr_file": "django/contrib/postgres/search.py",
    "created_at": "2025-02-17T16:25:08+00:00",
    "commented_code": "class TrigramStrictWordSimilarity(TrigramWordBase):\n     function = \"STRICT_WORD_SIMILARITY\"\n+\n+\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n+\n+    def _combine(self, other, connector, reversed, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {type(other)}.\"\n+            )\n+        if reversed:\n+            return CombinedLexeme(other, connector, self)\n+        return CombinedLexeme(self, connector, other)\n+\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def __or__(self, other):\n+        return self._combine(other, self.BITOR, False)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.BITAND, False)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def as_sql(self, compiler, connection):\n+        param = \"'%s'\" % psql_escape(self.value)\n+        template = \"%s\"\n+\n+        label = \"\"\n+        if self.prefix:\n+            label += \"*\"\n+        if self.weight:\n+            label += self.weight",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1958503984",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1958503984",
        "commented_code": "@@ -381,3 +396,91 @@ class TrigramWordSimilarity(TrigramWordBase):\n \n class TrigramStrictWordSimilarity(TrigramWordBase):\n     function = \"STRICT_WORD_SIMILARITY\"\n+\n+\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n+\n+    def _combine(self, other, connector, reversed, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {type(other)}.\"\n+            )\n+        if reversed:\n+            return CombinedLexeme(other, connector, self)\n+        return CombinedLexeme(self, connector, other)\n+\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def __or__(self, other):\n+        return self._combine(other, self.BITOR, False)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.BITAND, False)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def as_sql(self, compiler, connection):\n+        param = \"'%s'\" % psql_escape(self.value)\n+        template = \"%s\"\n+\n+        label = \"\"\n+        if self.prefix:\n+            label += \"*\"\n+        if self.weight:\n+            label += self.weight",
        "comment_created_at": "2025-02-17T16:25:08+00:00",
        "comment_author": "jacobtylerwalls",
        "comment_body": "I can create broken queries given that weight isn't sanitized. Unless we document clearly that weight should never accept raw user input, I think we need a solution.",
        "pr_file_module": null
      },
      {
        "comment_id": "1976646722",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1958503984",
        "commented_code": "@@ -381,3 +396,91 @@ class TrigramWordSimilarity(TrigramWordBase):\n \n class TrigramStrictWordSimilarity(TrigramWordBase):\n     function = \"STRICT_WORD_SIMILARITY\"\n+\n+\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n+\n+    def _combine(self, other, connector, reversed, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {type(other)}.\"\n+            )\n+        if reversed:\n+            return CombinedLexeme(other, connector, self)\n+        return CombinedLexeme(self, connector, other)\n+\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def __or__(self, other):\n+        return self._combine(other, self.BITOR, False)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.BITAND, False)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def as_sql(self, compiler, connection):\n+        param = \"'%s'\" % psql_escape(self.value)\n+        template = \"%s\"\n+\n+        label = \"\"\n+        if self.prefix:\n+            label += \"*\"\n+        if self.weight:\n+            label += self.weight",
        "comment_created_at": "2025-03-02T14:54:36+00:00",
        "comment_author": "GappleBee",
        "comment_body": "Weights can only be A, B, C, or D (case-insensitive) so we can either check this directly or check if `self.weight` has exactly one character, we can do this because this parameter is eventually passed into PostgreSQL's `to_tsquery` which will raise a `SyntaxError` if the first character in the weight is anything other than A, B, C, or D.\r\n\r\nAlso, I noticed that the weight for `SearchVector` isn't sanitised directly but is handled by PostgreSQL's `setweight` function (returns an invalid weight error if the first character is anything other than A, B, C, or D) which means you can write `weight=\"Arandom\"` and it will function the same as `weight=\"A\"` in the tests.\r\n\r\nIs this expected behaviour @jacobtylerwalls ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1976686769",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "django/contrib/postgres/search.py",
        "discussion_id": "1958503984",
        "commented_code": "@@ -381,3 +396,91 @@ class TrigramWordSimilarity(TrigramWordBase):\n \n class TrigramStrictWordSimilarity(TrigramWordBase):\n     function = \"STRICT_WORD_SIMILARITY\"\n+\n+\n+class LexemeCombinable:\n+    BITAND = \"&\"\n+    BITOR = \"|\"\n+\n+    def _combine(self, other, connector, reversed, node=None):\n+        if not isinstance(other, LexemeCombinable):\n+            raise TypeError(\n+                \"A Lexeme can only be combined with another Lexeme, \"\n+                f\"got {type(other)}.\"\n+            )\n+        if reversed:\n+            return CombinedLexeme(other, connector, self)\n+        return CombinedLexeme(self, connector, other)\n+\n+    # On Combinable, these are not implemented to reduce confusion with Q. In\n+    # this case we are actually (ab)using them to do logical combination so\n+    # it's consistent with other usage in Django.\n+    def __or__(self, other):\n+        return self._combine(other, self.BITOR, False)\n+\n+    def __and__(self, other):\n+        return self._combine(other, self.BITAND, False)\n+\n+\n+class Lexeme(LexemeCombinable, Value):\n+    _output_field = SearchQueryField()\n+\n+    def __init__(\n+        self, value, output_field=None, *, invert=False, prefix=False, weight=None\n+    ):\n+        self.prefix = prefix\n+        self.invert = invert\n+        self.weight = weight\n+        super().__init__(value, output_field=output_field)\n+\n+    def as_sql(self, compiler, connection):\n+        param = \"'%s'\" % psql_escape(self.value)\n+        template = \"%s\"\n+\n+        label = \"\"\n+        if self.prefix:\n+            label += \"*\"\n+        if self.weight:\n+            label += self.weight",
        "comment_created_at": "2025-03-02T18:22:25+00:00",
        "comment_author": "jacobtylerwalls",
        "comment_body": "Good point, I don't know if it's been discussed for SearchVector. I think it's nicer to fail at the python level with a ValueError instead of at the postgres level, but we can also let a merger weigh in.\r\n\r\n> or check if self.weight has exactly one character\r\n\r\nI would check A, B, C, D exactly, otherwise there's not much of a point if we're letting some cases fail at the postgres level anyway.",
        "pr_file_module": null
      }
    ]
  }
]