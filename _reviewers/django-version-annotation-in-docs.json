[
  {
    "discussion_id": "2177901907",
    "pr_number": 19603,
    "pr_file": "docs/ref/request-response.txt",
    "created_at": "2025-07-01T15:26:04+00:00",
    "commented_code": "Use ``samesite='None'`` (string) to explicitly state that this cookie is\n       sent with all same-site and cross-site requests.\n+    * Use ``partitioned=True`` to enable CHIPS (Cookies Having Independent\n+      Partitioned State). This allows cookies to be partitioned by top-level\n+      site, which improves privacy by preventing cross-site tracking while\n+      still allowing the cookie to work in embedded contexts like iframe.\n+      The `Partitioned`_ attribute is particularly useful for third-party\n+      services that need to maintain state in embedded contexts.\n+\n+      .. versionadded:: 6.0",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2177901907",
        "repo_full_name": "django/django",
        "pr_number": 19603,
        "pr_file": "docs/ref/request-response.txt",
        "discussion_id": "2177901907",
        "commented_code": "@@ -1026,9 +1026,18 @@ Methods\n \n       Use ``samesite='None'`` (string) to explicitly state that this cookie is\n       sent with all same-site and cross-site requests.\n+    * Use ``partitioned=True`` to enable CHIPS (Cookies Having Independent\n+      Partitioned State). This allows cookies to be partitioned by top-level\n+      site, which improves privacy by preventing cross-site tracking while\n+      still allowing the cookie to work in embedded contexts like iframe.\n+      The `Partitioned`_ attribute is particularly useful for third-party\n+      services that need to maintain state in embedded contexts.\n+\n+      .. versionadded:: 6.0",
        "comment_created_at": "2025-07-01T15:26:04+00:00",
        "comment_author": "timgraham",
        "comment_body": "This should be a versionchanged annotation. Check the style of 9a56b4b13ed92d2d5bb00d6bdb905a73bc5f2f0a.\r\n\r\nFurther, you can use that patch to check your own. For example, you're missing versionadded annotations  for the settings and a mention of them in the release notes.",
        "pr_file_module": null
      },
      {
        "comment_id": "2178247482",
        "repo_full_name": "django/django",
        "pr_number": 19603,
        "pr_file": "docs/ref/request-response.txt",
        "discussion_id": "2177901907",
        "commented_code": "@@ -1026,9 +1026,18 @@ Methods\n \n       Use ``samesite='None'`` (string) to explicitly state that this cookie is\n       sent with all same-site and cross-site requests.\n+    * Use ``partitioned=True`` to enable CHIPS (Cookies Having Independent\n+      Partitioned State). This allows cookies to be partitioned by top-level\n+      site, which improves privacy by preventing cross-site tracking while\n+      still allowing the cookie to work in embedded contexts like iframe.\n+      The `Partitioned`_ attribute is particularly useful for third-party\n+      services that need to maintain state in embedded contexts.\n+\n+      .. versionadded:: 6.0",
        "comment_created_at": "2025-07-01T18:03:13+00:00",
        "comment_author": "KentaroJay",
        "comment_body": "Thanks @timgraham! Just to get some sense in this particular case, it should be something like `.. versionchanged:: 6.1`(not `.. versionchanged:: 6.0` because I am adding a patch)?\r\n\r\nP.S. \r\n\r\nI read the [documentation](https://docs.djangoproject.com/en/dev/internals/contributing/writing-documentation/#:~:text=versionadded%20mentioned%20above.), and I guess in this case it should be `.. versionchanged:: 6.0`. Please confirm if this is true.",
        "pr_file_module": null
      },
      {
        "comment_id": "2178289877",
        "repo_full_name": "django/django",
        "pr_number": 19603,
        "pr_file": "docs/ref/request-response.txt",
        "discussion_id": "2177901907",
        "commented_code": "@@ -1026,9 +1026,18 @@ Methods\n \n       Use ``samesite='None'`` (string) to explicitly state that this cookie is\n       sent with all same-site and cross-site requests.\n+    * Use ``partitioned=True`` to enable CHIPS (Cookies Having Independent\n+      Partitioned State). This allows cookies to be partitioned by top-level\n+      site, which improves privacy by preventing cross-site tracking while\n+      still allowing the cookie to work in embedded contexts like iframe.\n+      The `Partitioned`_ attribute is particularly useful for third-party\n+      services that need to maintain state in embedded contexts.\n+\n+      .. versionadded:: 6.0",
        "comment_created_at": "2025-07-01T18:25:05+00:00",
        "comment_author": "timgraham",
        "comment_body": "Correct, patches to the main branch will target Django 6.0 until the feature freeze in mid-September.",
        "pr_file_module": null
      },
      {
        "comment_id": "2178397892",
        "repo_full_name": "django/django",
        "pr_number": 19603,
        "pr_file": "docs/ref/request-response.txt",
        "discussion_id": "2177901907",
        "commented_code": "@@ -1026,9 +1026,18 @@ Methods\n \n       Use ``samesite='None'`` (string) to explicitly state that this cookie is\n       sent with all same-site and cross-site requests.\n+    * Use ``partitioned=True`` to enable CHIPS (Cookies Having Independent\n+      Partitioned State). This allows cookies to be partitioned by top-level\n+      site, which improves privacy by preventing cross-site tracking while\n+      still allowing the cookie to work in embedded contexts like iframe.\n+      The `Partitioned`_ attribute is particularly useful for third-party\n+      services that need to maintain state in embedded contexts.\n+\n+      .. versionadded:: 6.0",
        "comment_created_at": "2025-07-01T19:40:55+00:00",
        "comment_author": "KentaroJay",
        "comment_body": "Got it! Thanks for the confirmation ðŸ‘ ",
        "pr_file_module": null
      },
      {
        "comment_id": "2178400883",
        "repo_full_name": "django/django",
        "pr_number": 19603,
        "pr_file": "docs/ref/request-response.txt",
        "discussion_id": "2177901907",
        "commented_code": "@@ -1026,9 +1026,18 @@ Methods\n \n       Use ``samesite='None'`` (string) to explicitly state that this cookie is\n       sent with all same-site and cross-site requests.\n+    * Use ``partitioned=True`` to enable CHIPS (Cookies Having Independent\n+      Partitioned State). This allows cookies to be partitioned by top-level\n+      site, which improves privacy by preventing cross-site tracking while\n+      still allowing the cookie to work in embedded contexts like iframe.\n+      The `Partitioned`_ attribute is particularly useful for third-party\n+      services that need to maintain state in embedded contexts.\n+\n+      .. versionadded:: 6.0",
        "comment_created_at": "2025-07-01T19:42:52+00:00",
        "comment_author": "KentaroJay",
        "comment_body": "I articulated changes in the release note and other doc files at [7de2573](https://github.com/django/django/pull/19603/commits/7de257312be85f53209617bbdf4f5b5d0992e836)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1958650729",
    "pr_number": 18823,
    "pr_file": "docs/ref/contrib/postgres/search.txt",
    "created_at": "2025-02-17T18:11:57+00:00",
    "commented_code": ">>> rank = SearchRank(vector, query, weights=[0.2, 0.4, 0.6, 0.8])\n     >>> Entry.objects.annotate(rank=rank).filter(rank__gte=0.3).order_by(\"-rank\")\n \n+Lexeme objects\n+==============\n+\n+Lexeme objects allow search operators to be safely used with strings from an",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1958650729",
        "repo_full_name": "django/django",
        "pr_number": 18823,
        "pr_file": "docs/ref/contrib/postgres/search.txt",
        "discussion_id": "1958650729",
        "commented_code": "@@ -276,6 +291,36 @@ floats to :class:`SearchRank` as ``weights`` in the same order above:\n     >>> rank = SearchRank(vector, query, weights=[0.2, 0.4, 0.6, 0.8])\n     >>> Entry.objects.annotate(rank=rank).filter(rank__gte=0.3).order_by(\"-rank\")\n \n+Lexeme objects\n+==============\n+\n+Lexeme objects allow search operators to be safely used with strings from an",
        "comment_created_at": "2025-02-17T18:11:57+00:00",
        "comment_author": "jacobtylerwalls",
        "comment_body": "This needs a versionadded [annotation](https://docs.djangoproject.com/en/dev/internals/contributing/writing-documentation/#:~:text=versionadded%20mentioned%20above.) and an entry in the 6.0 release notes.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2003567059",
    "pr_number": 18805,
    "pr_file": "docs/ref/templates/api.txt",
    "created_at": "2025-03-19T15:01:53+00:00",
    "commented_code": "Tags and filters from built-in libraries can be used without first calling\n       the :ttag:`{% load %}<load>` tag.\n \n+    * ``'multiline'`` controls whether multiline support is enabled in\n+      templates. For new projects this is set to ``True``, and this is the\n+      recommended setting. Multiline support in templates means that newline\n+      between ``{%`` and ``%}`` in templates is allowed.\n+\n+      It defaults to ``True``.\n+",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2003567059",
        "repo_full_name": "django/django",
        "pr_number": 18805,
        "pr_file": "docs/ref/templates/api.txt",
        "discussion_id": "2003567059",
        "commented_code": "@@ -139,6 +139,13 @@ overridden by what's passed by\n       Tags and filters from built-in libraries can be used without first calling\n       the :ttag:`{% load %}<load>` tag.\n \n+    * ``'multiline'`` controls whether multiline support is enabled in\n+      templates. For new projects this is set to ``True``, and this is the\n+      recommended setting. Multiline support in templates means that newline\n+      between ``{%`` and ``%}`` in templates is allowed.\n+\n+      It defaults to ``True``.\n+",
        "comment_created_at": "2025-03-19T15:01:53+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "This needs a versionchanged note\r\nI also think it needs a deprecated note about the default change :thinking: ",
        "pr_file_module": null
      },
      {
        "comment_id": "2005023507",
        "repo_full_name": "django/django",
        "pr_number": 18805,
        "pr_file": "docs/ref/templates/api.txt",
        "discussion_id": "2003567059",
        "commented_code": "@@ -139,6 +139,13 @@ overridden by what's passed by\n       Tags and filters from built-in libraries can be used without first calling\n       the :ttag:`{% load %}<load>` tag.\n \n+    * ``'multiline'`` controls whether multiline support is enabled in\n+      templates. For new projects this is set to ``True``, and this is the\n+      recommended setting. Multiline support in templates means that newline\n+      between ``{%`` and ``%}`` in templates is allowed.\n+\n+      It defaults to ``True``.\n+",
        "comment_created_at": "2025-03-20T08:11:11+00:00",
        "comment_author": "boxed",
        "comment_body": "Hmm.. I guess this text is wrong too. It defaults to False, but new projects get it set to True in the startproject template. I've fixed this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "421458295",
    "pr_number": 12392,
    "pr_file": "docs/ref/models/fields.txt",
    "created_at": "2020-05-07T12:17:19+00:00",
    "commented_code": "If you allow for blank values, you have to allow for null values since blank\n values are stored as null.\n \n+``JSONField``\n+-------------\n+\n+.. class:: JSONField(encoder=None, decoder=None, **options)\n+\n+.. versionadded:: 3.1\n+\n+A field for storing JSON encoded data. In Python the data is represented in its\n+Python native format: dictionaries, lists, strings, numbers, booleans and\n+``None``.\n+\n+``JSONField`` is supported on MariaDB 10.2.7+, MySQL 5.7.8+, Oracle,\n+PostgreSQL, and SQLite 3.9.0+ (with the `JSON1 extension`_ enabled).\n+\n+.. attribute:: JSONField.encoder\n+\n+    An optional :py:class:`json.JSONEncoder` subclass to serialize data types\n+    not supported by the standard JSON serializer (e.g. ``datetime.datetime``\n+    or :class:`~python:uuid.UUID`). For example, you can use the\n+    :class:`~django.core.serializers.json.DjangoJSONEncoder` class.\n+\n+    Defaults to ``json.JSONEncoder``.\n+\n+.. attribute:: JSONField.decoder\n+\n+    An optional :py:class:`json.JSONDecoder` subclass to deserialize the value\n+    retrieved from the database. The value will be in the format chosen by the\n+    custom encoder (most often a string). Your deserialization may need to\n+    account for the fact that you can't be certain of the input type. For\n+    example, you run the risk of returning a ``datetime`` that was actually a\n+    string that just happened to be in the same format chosen for\n+    ``datetime``\\s.\n+\n+    Defaults to ``json.JSONDecoder``.\n+\n+If you give the field a :attr:`~django.db.models.Field.default`, ensure it's an\n+immutable object, such as a ``str``, or a callable object that returns a fresh\n+mutable object each time, such as ``dict`` or a function. Providing a mutable\n+default object like ``default={}`` or ``default=[]`` shares the one object\n+between all model instances.\n+\n+To query ``JSONField`` in the database, see :ref:`querying-jsonfield`.\n+\n+.. admonition:: Indexing\n+\n+    :class:`~django.db.models.Index` and :attr:`.Field.db_index` both create a\n+    B-tree index, which isn't particularly helpful when querying ``JSONField``.\n+    On PostgreSQL only, you can use\n+    :class:`~django.contrib.postgres.indexes.GinIndex` that is better suited.\n+\n+.. admonition:: PostgreSQL users\n+\n+    PostgreSQL has two native JSON based data types: ``json`` and ``jsonb``.\n+    The main difference between them is how they are stored and how they can be\n+    queried. PostgreSQL's ``json`` field is stored as the original string\n+    representation of the JSON and must be decoded on the fly when queried\n+    based on keys. The ``jsonb`` field is stored based on the actual structure\n+    of the JSON which allows indexing. The trade-off is a small additional cost\n+    on writing to the ``jsonb`` field. ``JSONField`` uses ``jsonb``.\n+\n+.. admonition:: Oracle users\n+\n+    Oracle Database does not support storing JSON scalar values. Only JSON\n+    objects and arrays (represented in Python using :py:class:`dict` and\n+    :py:class:`list`) are supported.\n+\n+.. _JSON1 extension: https://www.sqlite.org/json1.html",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "421458295",
        "repo_full_name": "django/django",
        "pr_number": 12392,
        "pr_file": "docs/ref/models/fields.txt",
        "discussion_id": "421458295",
        "commented_code": "@@ -1175,6 +1175,74 @@ are converted to lowercase.\n If you allow for blank values, you have to allow for null values since blank\n values are stored as null.\n \n+``JSONField``\n+-------------\n+\n+.. class:: JSONField(encoder=None, decoder=None, **options)\n+\n+.. versionadded:: 3.1\n+\n+A field for storing JSON encoded data. In Python the data is represented in its\n+Python native format: dictionaries, lists, strings, numbers, booleans and\n+``None``.\n+\n+``JSONField`` is supported on MariaDB 10.2.7+, MySQL 5.7.8+, Oracle,\n+PostgreSQL, and SQLite 3.9.0+ (with the `JSON1 extension`_ enabled).\n+\n+.. attribute:: JSONField.encoder\n+\n+    An optional :py:class:`json.JSONEncoder` subclass to serialize data types\n+    not supported by the standard JSON serializer (e.g. ``datetime.datetime``\n+    or :class:`~python:uuid.UUID`). For example, you can use the\n+    :class:`~django.core.serializers.json.DjangoJSONEncoder` class.\n+\n+    Defaults to ``json.JSONEncoder``.\n+\n+.. attribute:: JSONField.decoder\n+\n+    An optional :py:class:`json.JSONDecoder` subclass to deserialize the value\n+    retrieved from the database. The value will be in the format chosen by the\n+    custom encoder (most often a string). Your deserialization may need to\n+    account for the fact that you can't be certain of the input type. For\n+    example, you run the risk of returning a ``datetime`` that was actually a\n+    string that just happened to be in the same format chosen for\n+    ``datetime``\\s.\n+\n+    Defaults to ``json.JSONDecoder``.\n+\n+If you give the field a :attr:`~django.db.models.Field.default`, ensure it's an\n+immutable object, such as a ``str``, or a callable object that returns a fresh\n+mutable object each time, such as ``dict`` or a function. Providing a mutable\n+default object like ``default={}`` or ``default=[]`` shares the one object\n+between all model instances.\n+\n+To query ``JSONField`` in the database, see :ref:`querying-jsonfield`.\n+\n+.. admonition:: Indexing\n+\n+    :class:`~django.db.models.Index` and :attr:`.Field.db_index` both create a\n+    B-tree index, which isn't particularly helpful when querying ``JSONField``.\n+    On PostgreSQL only, you can use\n+    :class:`~django.contrib.postgres.indexes.GinIndex` that is better suited.\n+\n+.. admonition:: PostgreSQL users\n+\n+    PostgreSQL has two native JSON based data types: ``json`` and ``jsonb``.\n+    The main difference between them is how they are stored and how they can be\n+    queried. PostgreSQL's ``json`` field is stored as the original string\n+    representation of the JSON and must be decoded on the fly when queried\n+    based on keys. The ``jsonb`` field is stored based on the actual structure\n+    of the JSON which allows indexing. The trade-off is a small additional cost\n+    on writing to the ``jsonb`` field. ``JSONField`` uses ``jsonb``.\n+\n+.. admonition:: Oracle users\n+\n+    Oracle Database does not support storing JSON scalar values. Only JSON\n+    objects and arrays (represented in Python using :py:class:`dict` and\n+    :py:class:`list`) are supported.\n+\n+.. _JSON1 extension: https://www.sqlite.org/json1.html",
        "comment_created_at": "2020-05-07T12:17:19+00:00",
        "comment_author": "laymonage",
        "comment_body": "Do you think linking to `:ref:sqlite-json1` would be more useful? Right now it's not referenced in any other part of the docs. It has the link to both the SQLite's JSON1 page and the wiki page, which I assume the latter would be what users would like more to find.",
        "pr_file_module": null
      },
      {
        "comment_id": "421933264",
        "repo_full_name": "django/django",
        "pr_number": 12392,
        "pr_file": "docs/ref/models/fields.txt",
        "discussion_id": "421458295",
        "commented_code": "@@ -1175,6 +1175,74 @@ are converted to lowercase.\n If you allow for blank values, you have to allow for null values since blank\n values are stored as null.\n \n+``JSONField``\n+-------------\n+\n+.. class:: JSONField(encoder=None, decoder=None, **options)\n+\n+.. versionadded:: 3.1\n+\n+A field for storing JSON encoded data. In Python the data is represented in its\n+Python native format: dictionaries, lists, strings, numbers, booleans and\n+``None``.\n+\n+``JSONField`` is supported on MariaDB 10.2.7+, MySQL 5.7.8+, Oracle,\n+PostgreSQL, and SQLite 3.9.0+ (with the `JSON1 extension`_ enabled).\n+\n+.. attribute:: JSONField.encoder\n+\n+    An optional :py:class:`json.JSONEncoder` subclass to serialize data types\n+    not supported by the standard JSON serializer (e.g. ``datetime.datetime``\n+    or :class:`~python:uuid.UUID`). For example, you can use the\n+    :class:`~django.core.serializers.json.DjangoJSONEncoder` class.\n+\n+    Defaults to ``json.JSONEncoder``.\n+\n+.. attribute:: JSONField.decoder\n+\n+    An optional :py:class:`json.JSONDecoder` subclass to deserialize the value\n+    retrieved from the database. The value will be in the format chosen by the\n+    custom encoder (most often a string). Your deserialization may need to\n+    account for the fact that you can't be certain of the input type. For\n+    example, you run the risk of returning a ``datetime`` that was actually a\n+    string that just happened to be in the same format chosen for\n+    ``datetime``\\s.\n+\n+    Defaults to ``json.JSONDecoder``.\n+\n+If you give the field a :attr:`~django.db.models.Field.default`, ensure it's an\n+immutable object, such as a ``str``, or a callable object that returns a fresh\n+mutable object each time, such as ``dict`` or a function. Providing a mutable\n+default object like ``default={}`` or ``default=[]`` shares the one object\n+between all model instances.\n+\n+To query ``JSONField`` in the database, see :ref:`querying-jsonfield`.\n+\n+.. admonition:: Indexing\n+\n+    :class:`~django.db.models.Index` and :attr:`.Field.db_index` both create a\n+    B-tree index, which isn't particularly helpful when querying ``JSONField``.\n+    On PostgreSQL only, you can use\n+    :class:`~django.contrib.postgres.indexes.GinIndex` that is better suited.\n+\n+.. admonition:: PostgreSQL users\n+\n+    PostgreSQL has two native JSON based data types: ``json`` and ``jsonb``.\n+    The main difference between them is how they are stored and how they can be\n+    queried. PostgreSQL's ``json`` field is stored as the original string\n+    representation of the JSON and must be decoded on the fly when queried\n+    based on keys. The ``jsonb`` field is stored based on the actual structure\n+    of the JSON which allows indexing. The trade-off is a small additional cost\n+    on writing to the ``jsonb`` field. ``JSONField`` uses ``jsonb``.\n+\n+.. admonition:: Oracle users\n+\n+    Oracle Database does not support storing JSON scalar values. Only JSON\n+    objects and arrays (represented in Python using :py:class:`dict` and\n+    :py:class:`list`) are supported.\n+\n+.. _JSON1 extension: https://www.sqlite.org/json1.html",
        "comment_created_at": "2020-05-08T04:38:17+00:00",
        "comment_author": "felixxm",
        "comment_body": "Agreed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1809775784",
    "pr_number": 18408,
    "pr_file": "docs/topics/db/sql.txt",
    "created_at": "2024-10-22T02:53:26+00:00",
    "commented_code": "finally:\n         c.close()\n \n+Async Connections and cursors\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+On backends that support async-native connections, you can request an async\n+cursor::\n+\n+    from django.db import new_connection\n+\n+    async with new_connection() as connection:\n+        async with connection.acursor() as c:\n+            await c.execute(...)",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1809775784",
        "repo_full_name": "django/django",
        "pr_number": 18408,
        "pr_file": "docs/topics/db/sql.txt",
        "discussion_id": "1809775784",
        "commented_code": "@@ -403,6 +403,19 @@ is equivalent to::\n     finally:\n         c.close()\n \n+Async Connections and cursors\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+On backends that support async-native connections, you can request an async\n+cursor::\n+\n+    from django.db import new_connection\n+\n+    async with new_connection() as connection:\n+        async with connection.acursor() as c:\n+            await c.execute(...)",
        "comment_created_at": "2024-10-22T02:53:26+00:00",
        "comment_author": "bigfootjon",
        "comment_body": "This should have a `versionadded` marker like this:\r\n\r\nhttps://github.com/django/django/blob/main/docs/ref/django-admin.txt#L952",
        "pr_file_module": null
      }
    ]
  }
]