[
  {
    "discussion_id": "1917513975",
    "pr_number": 19012,
    "pr_file": "tests/order_with_respect_to/base_tests.py",
    "created_at": "2025-01-16T00:41:49+00:00",
    "commented_code": "),\n             ):\n                 self.q1.set_answer_order([3, 1, 2, 4])\n+\n+    def test_bulk_create_with_empty_parent(self):\n+        \"\"\"\n+        bulk_create() should properly set _order when parent has no existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        answers = [\n+            self.Answer(question=question, text=f\"Answer {i}\")\n+            for i in range(3)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 3)\n+        for i, answer in enumerate(created_answers):\n+            self.assertEqual(answer._order, i)\n+\n+    def test_bulk_create_with_existing_children(self):\n+        \"\"\"\n+        bulk_create() should continue _order sequence from existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        self.Answer.objects.create(question=question, text=\"Existing 1\")\n+        self.Answer.objects.create(question=question, text=\"Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question, text=f\"New Answer {i}\")\n+            for i in range(2)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        self.assertEqual(len(created_answers), 2)\n+        self.assertEqual(created_answers[0]._order, 2)\n+        self.assertEqual(created_answers[1]._order, 3)\n+\n+    def test_bulk_create_multiple_parents(self):\n+        \"\"\"\n+        bulk_create() should maintain separate _order sequences for different parents.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        answers = [\n+            self.Answer(question=question1, text=\"Q1 Answer 1\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 1\"),\n+            self.Answer(question=question1, text=\"Q1 Answer 2\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        self.assertEqual(q1_answers[0]._order, 0)\n+        self.assertEqual(q1_answers[1]._order, 1)\n+        self.assertEqual(q2_answers[0]._order, 0)\n+        self.assertEqual(q2_answers[1]._order, 1)\n+\n+    def test_bulk_create_mixed_scenario(self):\n+        \"\"\"\n+        bulk_create() should handle a mix of parents with and without existing children.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        # Create initial answers\n+        self.Answer.objects.create(question=question1, text=\"Q1 Existing\")\n+        self.Answer.objects.create(question=question2, text=\"Q2 Existing 1\")\n+        self.Answer.objects.create(question=question2, text=\"Q2 Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question1, text=\"Q1 New 1\"),\n+            self.Answer(question=question2, text=\"Q2 New 1\"),\n+            self.Answer(question=question1, text=\"Q1 New 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        # Check continuation of _order sequence\n+        self.assertEqual(q1_answers[0]._order, 1)\n+        self.assertEqual(q1_answers[1]._order, 2)\n+        self.assertEqual(q2_answers[0]._order, 2)\n+\n+    def test_bulk_create_large_batch_ordering(self):\n+        \"\"\"\n+        bulk_create() should maintain correct ordering when creating large numbers of objects.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Large Batch Question\")\n+        answers = [\n+            self.Answer(question=question, text=f\"Answer {i}\")\n+            for i in range(1000)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 1000)\n+        # Verify order sequence\n+        prev_order = -1\n+        for answer in created_answers:\n+            self.assertTrue(answer._order > prev_order)\n+            prev_order = answer._order",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1917513975",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "tests/order_with_respect_to/base_tests.py",
        "discussion_id": "1917513975",
        "commented_code": "@@ -126,3 +126,104 @@ def db_for_write(self, model, **hints):\n                 ),\n             ):\n                 self.q1.set_answer_order([3, 1, 2, 4])\n+\n+    def test_bulk_create_with_empty_parent(self):\n+        \"\"\"\n+        bulk_create() should properly set _order when parent has no existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        answers = [\n+            self.Answer(question=question, text=f\"Answer {i}\")\n+            for i in range(3)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 3)\n+        for i, answer in enumerate(created_answers):\n+            self.assertEqual(answer._order, i)\n+\n+    def test_bulk_create_with_existing_children(self):\n+        \"\"\"\n+        bulk_create() should continue _order sequence from existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        self.Answer.objects.create(question=question, text=\"Existing 1\")\n+        self.Answer.objects.create(question=question, text=\"Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question, text=f\"New Answer {i}\")\n+            for i in range(2)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        self.assertEqual(len(created_answers), 2)\n+        self.assertEqual(created_answers[0]._order, 2)\n+        self.assertEqual(created_answers[1]._order, 3)\n+\n+    def test_bulk_create_multiple_parents(self):\n+        \"\"\"\n+        bulk_create() should maintain separate _order sequences for different parents.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        answers = [\n+            self.Answer(question=question1, text=\"Q1 Answer 1\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 1\"),\n+            self.Answer(question=question1, text=\"Q1 Answer 2\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        self.assertEqual(q1_answers[0]._order, 0)\n+        self.assertEqual(q1_answers[1]._order, 1)\n+        self.assertEqual(q2_answers[0]._order, 0)\n+        self.assertEqual(q2_answers[1]._order, 1)\n+\n+    def test_bulk_create_mixed_scenario(self):\n+        \"\"\"\n+        bulk_create() should handle a mix of parents with and without existing children.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        # Create initial answers\n+        self.Answer.objects.create(question=question1, text=\"Q1 Existing\")\n+        self.Answer.objects.create(question=question2, text=\"Q2 Existing 1\")\n+        self.Answer.objects.create(question=question2, text=\"Q2 Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question1, text=\"Q1 New 1\"),\n+            self.Answer(question=question2, text=\"Q2 New 1\"),\n+            self.Answer(question=question1, text=\"Q1 New 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        # Check continuation of _order sequence\n+        self.assertEqual(q1_answers[0]._order, 1)\n+        self.assertEqual(q1_answers[1]._order, 2)\n+        self.assertEqual(q2_answers[0]._order, 2)\n+\n+    def test_bulk_create_large_batch_ordering(self):\n+        \"\"\"\n+        bulk_create() should maintain correct ordering when creating large numbers of objects.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Large Batch Question\")\n+        answers = [\n+            self.Answer(question=question, text=f\"Answer {i}\")\n+            for i in range(1000)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 1000)\n+        # Verify order sequence\n+        prev_order = -1\n+        for answer in created_answers:\n+            self.assertTrue(answer._order > prev_order)\n+            prev_order = answer._order",
        "comment_created_at": "2025-01-16T00:41:49+00:00",
        "comment_author": "charettes",
        "comment_body": "I don't think this test is necessary as it's likely going to be slow and we don't perform any of special case when a larger number of objects are provided.",
        "pr_file_module": null
      },
      {
        "comment_id": "1924924867",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "tests/order_with_respect_to/base_tests.py",
        "discussion_id": "1917513975",
        "commented_code": "@@ -126,3 +126,104 @@ def db_for_write(self, model, **hints):\n                 ),\n             ):\n                 self.q1.set_answer_order([3, 1, 2, 4])\n+\n+    def test_bulk_create_with_empty_parent(self):\n+        \"\"\"\n+        bulk_create() should properly set _order when parent has no existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        answers = [\n+            self.Answer(question=question, text=f\"Answer {i}\")\n+            for i in range(3)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 3)\n+        for i, answer in enumerate(created_answers):\n+            self.assertEqual(answer._order, i)\n+\n+    def test_bulk_create_with_existing_children(self):\n+        \"\"\"\n+        bulk_create() should continue _order sequence from existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        self.Answer.objects.create(question=question, text=\"Existing 1\")\n+        self.Answer.objects.create(question=question, text=\"Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question, text=f\"New Answer {i}\")\n+            for i in range(2)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        self.assertEqual(len(created_answers), 2)\n+        self.assertEqual(created_answers[0]._order, 2)\n+        self.assertEqual(created_answers[1]._order, 3)\n+\n+    def test_bulk_create_multiple_parents(self):\n+        \"\"\"\n+        bulk_create() should maintain separate _order sequences for different parents.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        answers = [\n+            self.Answer(question=question1, text=\"Q1 Answer 1\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 1\"),\n+            self.Answer(question=question1, text=\"Q1 Answer 2\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        self.assertEqual(q1_answers[0]._order, 0)\n+        self.assertEqual(q1_answers[1]._order, 1)\n+        self.assertEqual(q2_answers[0]._order, 0)\n+        self.assertEqual(q2_answers[1]._order, 1)\n+\n+    def test_bulk_create_mixed_scenario(self):\n+        \"\"\"\n+        bulk_create() should handle a mix of parents with and without existing children.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        # Create initial answers\n+        self.Answer.objects.create(question=question1, text=\"Q1 Existing\")\n+        self.Answer.objects.create(question=question2, text=\"Q2 Existing 1\")\n+        self.Answer.objects.create(question=question2, text=\"Q2 Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question1, text=\"Q1 New 1\"),\n+            self.Answer(question=question2, text=\"Q2 New 1\"),\n+            self.Answer(question=question1, text=\"Q1 New 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        # Check continuation of _order sequence\n+        self.assertEqual(q1_answers[0]._order, 1)\n+        self.assertEqual(q1_answers[1]._order, 2)\n+        self.assertEqual(q2_answers[0]._order, 2)\n+\n+    def test_bulk_create_large_batch_ordering(self):\n+        \"\"\"\n+        bulk_create() should maintain correct ordering when creating large numbers of objects.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Large Batch Question\")\n+        answers = [\n+            self.Answer(question=question, text=f\"Answer {i}\")\n+            for i in range(1000)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 1000)\n+        # Verify order sequence\n+        prev_order = -1\n+        for answer in created_answers:\n+            self.assertTrue(answer._order > prev_order)\n+            prev_order = answer._order",
        "comment_created_at": "2025-01-22T08:45:59+00:00",
        "comment_author": "myoungjinGo-BE",
        "comment_body": "I agree with your point. I’ve removed the test",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2061338553",
    "pr_number": 19012,
    "pr_file": "tests/order_with_respect_to/base_tests.py",
    "created_at": "2025-04-26T14:27:06+00:00",
    "commented_code": "),\n             ):\n                 self.q1.set_answer_order([3, 1, 2, 4])\n+\n+    def test_bulk_create_with_empty_parent(self):\n+        \"\"\"\n+        bulk_create() should properly set _order when parent has no existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        answers = [self.Answer(question=question, text=f\"Answer {i}\") for i in range(3)]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 3)\n+        for i, answer in enumerate(created_answers):\n+            self.assertEqual(answer._order, i)\n+\n+    def test_bulk_create_with_existing_children(self):\n+        \"\"\"\n+        bulk_create() should continue _order sequence from existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        self.Answer.objects.create(question=question, text=\"Existing 1\")\n+        self.Answer.objects.create(question=question, text=\"Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question, text=f\"New Answer {i}\") for i in range(2)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        self.assertEqual(len(created_answers), 2)\n+        self.assertEqual(created_answers[0]._order, 2)\n+        self.assertEqual(created_answers[1]._order, 3)\n+\n+    def test_bulk_create_multiple_parents(self):\n+        \"\"\"\n+        bulk_create() should maintain separate _order sequences for different parents.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        answers = [\n+            self.Answer(question=question1, text=\"Q1 Answer 1\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 1\"),\n+            self.Answer(question=question1, text=\"Q1 Answer 2\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        q1_answers.sort(key=lambda x: x._order)\n+        q2_answers.sort(key=lambda x: x._order)\n+\n+        self.assertEqual(q1_answers[0]._order, 0)\n+        self.assertEqual(q1_answers[1]._order, 1)\n+        self.assertEqual(q2_answers[0]._order, 0)\n+        self.assertEqual(q2_answers[1]._order, 1)",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2061338553",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "tests/order_with_respect_to/base_tests.py",
        "discussion_id": "2061338553",
        "commented_code": "@@ -126,3 +126,87 @@ def db_for_write(self, model, **hints):\n                 ),\n             ):\n                 self.q1.set_answer_order([3, 1, 2, 4])\n+\n+    def test_bulk_create_with_empty_parent(self):\n+        \"\"\"\n+        bulk_create() should properly set _order when parent has no existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        answers = [self.Answer(question=question, text=f\"Answer {i}\") for i in range(3)]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 3)\n+        for i, answer in enumerate(created_answers):\n+            self.assertEqual(answer._order, i)\n+\n+    def test_bulk_create_with_existing_children(self):\n+        \"\"\"\n+        bulk_create() should continue _order sequence from existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        self.Answer.objects.create(question=question, text=\"Existing 1\")\n+        self.Answer.objects.create(question=question, text=\"Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question, text=f\"New Answer {i}\") for i in range(2)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        self.assertEqual(len(created_answers), 2)\n+        self.assertEqual(created_answers[0]._order, 2)\n+        self.assertEqual(created_answers[1]._order, 3)\n+\n+    def test_bulk_create_multiple_parents(self):\n+        \"\"\"\n+        bulk_create() should maintain separate _order sequences for different parents.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        answers = [\n+            self.Answer(question=question1, text=\"Q1 Answer 1\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 1\"),\n+            self.Answer(question=question1, text=\"Q1 Answer 2\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        q1_answers.sort(key=lambda x: x._order)\n+        q2_answers.sort(key=lambda x: x._order)\n+\n+        self.assertEqual(q1_answers[0]._order, 0)\n+        self.assertEqual(q1_answers[1]._order, 1)\n+        self.assertEqual(q2_answers[0]._order, 0)\n+        self.assertEqual(q2_answers[1]._order, 1)",
        "comment_created_at": "2025-04-26T14:27:06+00:00",
        "comment_author": "pasoulier",
        "comment_body": "Since `bulk_create` returns created objects in the same order as provided, calling `sort` might not be necessary.\r\n\r\nHave you though about unpacking directly the list comprehension into variable to avoid using the index, it could improve readability.\r\n\r\n```suggestion\r\n        created_answers = self.Answer.objects.bulk_create(answers)\r\n\r\n        q1_answer1, q1_answer2 = [a for a in created_answers if a.question == question1]\r\n        q2_answer1, q2_answer2 = [a for a in created_answers if a.question == question2]\r\n\r\n        self.assertEqual(q1_answer1._order, 0)\r\n        self.assertEqual(q1_answer2._order, 1)\r\n        self.assertEqual(q2_answer1._order, 0)\r\n        self.assertEqual(q2_answer2._order, 1)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2066934615",
        "repo_full_name": "django/django",
        "pr_number": 19012,
        "pr_file": "tests/order_with_respect_to/base_tests.py",
        "discussion_id": "2061338553",
        "commented_code": "@@ -126,3 +126,87 @@ def db_for_write(self, model, **hints):\n                 ),\n             ):\n                 self.q1.set_answer_order([3, 1, 2, 4])\n+\n+    def test_bulk_create_with_empty_parent(self):\n+        \"\"\"\n+        bulk_create() should properly set _order when parent has no existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        answers = [self.Answer(question=question, text=f\"Answer {i}\") for i in range(3)]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        self.assertEqual(len(created_answers), 3)\n+        for i, answer in enumerate(created_answers):\n+            self.assertEqual(answer._order, i)\n+\n+    def test_bulk_create_with_existing_children(self):\n+        \"\"\"\n+        bulk_create() should continue _order sequence from existing children.\n+        \"\"\"\n+        question = self.Question.objects.create(text=\"Test Question\")\n+        self.Answer.objects.create(question=question, text=\"Existing 1\")\n+        self.Answer.objects.create(question=question, text=\"Existing 2\")\n+\n+        new_answers = [\n+            self.Answer(question=question, text=f\"New Answer {i}\") for i in range(2)\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(new_answers)\n+\n+        self.assertEqual(len(created_answers), 2)\n+        self.assertEqual(created_answers[0]._order, 2)\n+        self.assertEqual(created_answers[1]._order, 3)\n+\n+    def test_bulk_create_multiple_parents(self):\n+        \"\"\"\n+        bulk_create() should maintain separate _order sequences for different parents.\n+        \"\"\"\n+        question1 = self.Question.objects.create(text=\"Question 1\")\n+        question2 = self.Question.objects.create(text=\"Question 2\")\n+\n+        answers = [\n+            self.Answer(question=question1, text=\"Q1 Answer 1\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 1\"),\n+            self.Answer(question=question1, text=\"Q1 Answer 2\"),\n+            self.Answer(question=question2, text=\"Q2 Answer 2\"),\n+        ]\n+        created_answers = self.Answer.objects.bulk_create(answers)\n+\n+        q1_answers = [a for a in created_answers if a.question == question1]\n+        q2_answers = [a for a in created_answers if a.question == question2]\n+\n+        q1_answers.sort(key=lambda x: x._order)\n+        q2_answers.sort(key=lambda x: x._order)\n+\n+        self.assertEqual(q1_answers[0]._order, 0)\n+        self.assertEqual(q1_answers[1]._order, 1)\n+        self.assertEqual(q2_answers[0]._order, 0)\n+        self.assertEqual(q2_answers[1]._order, 1)",
        "comment_created_at": "2025-04-29T16:30:28+00:00",
        "comment_author": "myoungjinGo-BE",
        "comment_body": "Thanks to your feedback, I was able to make the test code more consistent and switched to using unpacking as you suggested.\r\nIt also made me realize how important it is to write easily readable tests. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2096774343",
    "pr_number": 19484,
    "pr_file": "tests/model_options/test_meta_caching.py",
    "created_at": "2025-05-20T02:58:29+00:00",
    "commented_code": "+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"model_options\")\n+class ForwardPropertiesCachingTests(SimpleTestCase):\n+    \"\"\"Tests FORWARD_PROPERTIES for Django's model metadata caching system.\"\"\"\n+\n+    def test_forward_properties_initialization(self):\n+        \"\"\"Test that FORWARD_PROPERTIES are properly initialized.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Verify that none of the FORWARD_PROPERTIES are in the __dict__ initially",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2096774343",
        "repo_full_name": "django/django",
        "pr_number": 19484,
        "pr_file": "tests/model_options/test_meta_caching.py",
        "discussion_id": "2096774343",
        "commented_code": "@@ -0,0 +1,216 @@\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"model_options\")\n+class ForwardPropertiesCachingTests(SimpleTestCase):\n+    \"\"\"Tests FORWARD_PROPERTIES for Django's model metadata caching system.\"\"\"\n+\n+    def test_forward_properties_initialization(self):\n+        \"\"\"Test that FORWARD_PROPERTIES are properly initialized.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Verify that none of the FORWARD_PROPERTIES are in the __dict__ initially",
        "comment_created_at": "2025-05-20T02:58:29+00:00",
        "comment_author": "jacobtylerwalls",
        "comment_body": "These are the kinds of details I don't think we need to spend effort testing (`django.utils.cached_property` itself is sufficiently tested)",
        "pr_file_module": null
      },
      {
        "comment_id": "2097599203",
        "repo_full_name": "django/django",
        "pr_number": 19484,
        "pr_file": "tests/model_options/test_meta_caching.py",
        "discussion_id": "2096774343",
        "commented_code": "@@ -0,0 +1,216 @@\n+from django.db import models\n+from django.test import SimpleTestCase\n+from django.test.utils import isolate_apps\n+\n+\n+@isolate_apps(\"model_options\")\n+class ForwardPropertiesCachingTests(SimpleTestCase):\n+    \"\"\"Tests FORWARD_PROPERTIES for Django's model metadata caching system.\"\"\"\n+\n+    def test_forward_properties_initialization(self):\n+        \"\"\"Test that FORWARD_PROPERTIES are properly initialized.\"\"\"\n+\n+        class TestModel(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        # Verify that none of the FORWARD_PROPERTIES are in the __dict__ initially",
        "comment_created_at": "2025-05-20T10:23:12+00:00",
        "comment_author": "jrsenthil-kumar2312",
        "comment_body": "Sure. Still learning the code base. I will remove these tests",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2108386335",
    "pr_number": 19278,
    "pr_file": "tests/backends/sqlite/tests.py",
    "created_at": "2025-05-27T07:17:30+00:00",
    "commented_code": "self.assertFalse(constraint_checks_enabled())\n         self.assertTrue(constraint_checks_enabled())\n \n+    def test_must_check_constraints_initialization(self):\n+        \"\"\"\n+        Verify that must_check_constraints is initialized correctly\n+        \"\"\"\n+        with connection.schema_editor() as editor:\n+            # Initially, must_check_constraints should be False\n+            self.assertFalse(editor.must_check_constraints)",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2108386335",
        "repo_full_name": "django/django",
        "pr_number": 19278,
        "pr_file": "tests/backends/sqlite/tests.py",
        "discussion_id": "2108386335",
        "commented_code": "@@ -193,6 +193,52 @@ def constraint_checks_enabled():\n             self.assertFalse(constraint_checks_enabled())\n         self.assertTrue(constraint_checks_enabled())\n \n+    def test_must_check_constraints_initialization(self):\n+        \"\"\"\n+        Verify that must_check_constraints is initialized correctly\n+        \"\"\"\n+        with connection.schema_editor() as editor:\n+            # Initially, must_check_constraints should be False\n+            self.assertFalse(editor.must_check_constraints)",
        "comment_created_at": "2025-05-27T07:17:30+00:00",
        "comment_author": "smithdc1",
        "comment_body": "Please use `assertIs` to test that it is actually True/False and not something that is truthy/falsey. Both here and below. \r\n\r\n```suggestion\r\n            self.assertIs(editor.must_check_constraints, False)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1589800644",
    "pr_number": 18116,
    "pr_file": "tests/schema/tests.py",
    "created_at": "2024-05-03T23:16:42+00:00",
    "commented_code": "editor.alter_field(LocalBook, old_field, new_field, strict=True)\n         self.assertForeignKeyExists(LocalBook, \"author_id\", \"schema_author\")\n \n+    @skipUnlessDBFeature(\"supports_foreign_keys\")\n+    def test_fk_constraint_index_drop(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(Book)\n+\n+        author = Author.objects.create(name=\"Alice\")\n+        Book.objects.create(\n+            author=author,\n+            title=\"Much Ado About Foreign Keys\",\n+            pub_date=datetime.datetime.now(),\n+        )\n+\n+        old_field = Book._meta.get_field(\"author\")\n+        new_field = ForeignKey(Author, CASCADE, db_index=False)\n+        new_field.set_attributes_from_name(\"author\")\n+        with (\n+            CaptureQueriesContext(connection) as ctx,\n+            connection.schema_editor() as editor,\n+        ):\n+            editor.alter_field(Book, old_field, new_field, strict=True)\n+\n+        if connection.features.requires_fk_constraints_to_be_recreated:\n+            self.assertIs(\n+                any(\n+                    \"DROP FOREIGN KEY\" in query[\"sql\"] for query in ctx.captured_queries\n+                ),\n+                True,\n+            )",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "1589800644",
        "repo_full_name": "django/django",
        "pr_number": 18116,
        "pr_file": "tests/schema/tests.py",
        "discussion_id": "1589800644",
        "commented_code": "@@ -1745,6 +1745,47 @@ class Meta:\n             editor.alter_field(LocalBook, old_field, new_field, strict=True)\n         self.assertForeignKeyExists(LocalBook, \"author_id\", \"schema_author\")\n \n+    @skipUnlessDBFeature(\"supports_foreign_keys\")\n+    def test_fk_constraint_index_drop(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(Book)\n+\n+        author = Author.objects.create(name=\"Alice\")\n+        Book.objects.create(\n+            author=author,\n+            title=\"Much Ado About Foreign Keys\",\n+            pub_date=datetime.datetime.now(),\n+        )\n+\n+        old_field = Book._meta.get_field(\"author\")\n+        new_field = ForeignKey(Author, CASCADE, db_index=False)\n+        new_field.set_attributes_from_name(\"author\")\n+        with (\n+            CaptureQueriesContext(connection) as ctx,\n+            connection.schema_editor() as editor,\n+        ):\n+            editor.alter_field(Book, old_field, new_field, strict=True)\n+\n+        if connection.features.requires_fk_constraints_to_be_recreated:\n+            self.assertIs(\n+                any(\n+                    \"DROP FOREIGN KEY\" in query[\"sql\"] for query in ctx.captured_queries\n+                ),\n+                True,\n+            )",
        "comment_created_at": "2024-05-03T23:16:42+00:00",
        "comment_author": "LilyAcorn",
        "comment_body": "Since [`any` always returns a `bool`](https://docs.python.org/3/library/functions.html#any), I'd use the simpler to read `assertTrue`:\r\n\r\n```suggestion\r\n            self.assertTrue(\r\n                any(\r\n                    \"DROP FOREIGN KEY\" in query[\"sql\"] for query in ctx.captured_queries\r\n                )\r\n            )\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2100512938",
    "pr_number": 19488,
    "pr_file": "tests/auth_tests/test_remote_user.py",
    "created_at": "2025-05-21T14:56:04+00:00",
    "commented_code": "response = await self.async_client.get(\"/remote_user/\")\n         self.assertFalse(response.context[\"user\"].is_anonymous)\n         self.assertEqual(response.context[\"user\"].username, \"knownuser\")\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddlewareSyncOnly(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddleware(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+    async def aprocess_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+@override_settings(ROOT_URLCONF=\"auth_tests.urls\")\n+class CustomProcessRequestMiddlewareTest(TestCase):\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.\"\n+            \"CustomProcessRequestMiddlewareSyncOnly\"\n+        }\n+    )\n+    async def test_async_warns_sync_only_middleware(self):\n+        msg = (\n+            \"Support for subclasses of RemoteUserMiddleware that override \"\n+            \"process_request() without overriding aprocess_request() are \"\n+            \"deprecated.\"\n+        )\n+        with self.assertRaises(NotImplementedError):\n+            with self.assertWarnsMessage(RemovedInDjango61Warning, msg):\n+                await self.client.get(\"/remote_user/\")\n+\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.CustomProcessRequestMiddleware\"\n+        }\n+    )\n+    async def test_async_no_warning_sync_and_async_middleware(self):\n+        with self.assertRaises(NotImplementedError):\n+            await self.client.get(\"/remote_user/\")",
    "repo_full_name": "django/django",
    "discussion_comments": [
      {
        "comment_id": "2100512938",
        "repo_full_name": "django/django",
        "pr_number": 19488,
        "pr_file": "tests/auth_tests/test_remote_user.py",
        "discussion_id": "2100512938",
        "commented_code": "@@ -487,3 +488,47 @@ async def test_header_disappears_async(self):\n         response = await self.async_client.get(\"/remote_user/\")\n         self.assertFalse(response.context[\"user\"].is_anonymous)\n         self.assertEqual(response.context[\"user\"].username, \"knownuser\")\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddlewareSyncOnly(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddleware(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+    async def aprocess_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+@override_settings(ROOT_URLCONF=\"auth_tests.urls\")\n+class CustomProcessRequestMiddlewareTest(TestCase):\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.\"\n+            \"CustomProcessRequestMiddlewareSyncOnly\"\n+        }\n+    )\n+    async def test_async_warns_sync_only_middleware(self):\n+        msg = (\n+            \"Support for subclasses of RemoteUserMiddleware that override \"\n+            \"process_request() without overriding aprocess_request() are \"\n+            \"deprecated.\"\n+        )\n+        with self.assertRaises(NotImplementedError):\n+            with self.assertWarnsMessage(RemovedInDjango61Warning, msg):\n+                await self.client.get(\"/remote_user/\")\n+\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.CustomProcessRequestMiddleware\"\n+        }\n+    )\n+    async def test_async_no_warning_sync_and_async_middleware(self):\n+        with self.assertRaises(NotImplementedError):\n+            await self.client.get(\"/remote_user/\")",
        "comment_created_at": "2025-05-21T14:56:04+00:00",
        "comment_author": "nessita",
        "comment_body": "I'm not sure that these tests are testing what we think they are testing. If, with the branch as is, we fully remove the code block that adds the deprecation warning, no test fail.\r\n\r\nI started debugging why, since at first sight the deprecation warning is tested, but I found out that raising `NotImplementedError` is messing with the call chain. If we change the exception raising to be a simple return or any non failing statement, we get these test errors:\r\n\r\n```\r\n======================================================================\r\nERROR: test_async_no_warning_sync_and_async_middleware (auth_tests.test_remote_user.CustomProcessRequestMiddlewareTest.test_async_no_warning_sync_and_async_middleware)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n...\r\ntest_async_no_warning_sync_and_async_middleware\r\n    await self.client.get(\"/remote_user/\")\r\n    ^^^^^^^^^^^\r\nTypeError: object HttpResponse can't be used in 'await' expression\r\n\r\n======================================================================\r\nERROR: test_async_warns_sync_only_middleware (auth_tests.test_remote_user.CustomProcessRequestMiddlewareTest.test_async_warns_sync_only_middleware)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n...\r\ntest_async_warns_sync_only_middleware\r\n    await self.client.get(\"/remote_user/\")\r\n    ^^^^^^^\r\nTypeError: object HttpResponse can't be used in 'await' expression\r\n```\r\nThis is caused by using the sync test client with `await`. We need to use the `async_client`. Therefore, I'm proposing below potential changes for your consideration:\r\n```suggestion\r\n# RemovedInDjango61Warning.\r\nclass CustomProcessRequestMiddlewareSyncOnly(RemoteUserMiddleware):\r\n    def process_request(self, request):\r\n        return\r\n\r\n\r\n# RemovedInDjango61Warning.\r\nclass CustomProcessRequestMiddleware(RemoteUserMiddleware):\r\n    def process_request(self, request):\r\n        return\r\n\r\n    async def aprocess_request(self, request):\r\n        return\r\n\r\n\r\n# RemovedInDjango61Warning.\r\n@override_settings(ROOT_URLCONF=\"auth_tests.urls\")\r\nclass CustomProcessRequestMiddlewareTest(TestCase):\r\n    @modify_settings(\r\n        MIDDLEWARE={\r\n            \"append\": \"auth_tests.test_remote_user.\"\r\n            \"CustomProcessRequestMiddlewareSyncOnly\"\r\n        }\r\n    )\r\n    async def test_async_warns_sync_only_middleware(self):\r\n        msg = (\r\n            \"Support for subclasses of RemoteUserMiddleware that override \"\r\n            \"process_request() without overriding aprocess_request() are \"\r\n            \"deprecated.\"\r\n        )\r\n        with self.assertWarnsMessage(RemovedInDjango61Warning, msg) as ctx:\r\n            response = await self.async_client.get(\"/remote_user/\")\r\n\r\n        self.assertContains(response, \"Username is AnonymousUser\")\r\n\r\n    @modify_settings(\r\n        MIDDLEWARE={\r\n            \"append\": \"auth_tests.test_remote_user.CustomProcessRequestMiddleware\"\r\n        }\r\n    )\r\n    async def test_async_no_warning_sync_and_async_middleware(self):\r\n        response = await self.async_client.get(\"/remote_user/\")\r\n\r\n        self.assertContains(response, \"Username is AnonymousUser\")\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2101976879",
        "repo_full_name": "django/django",
        "pr_number": 19488,
        "pr_file": "tests/auth_tests/test_remote_user.py",
        "discussion_id": "2100512938",
        "commented_code": "@@ -487,3 +488,47 @@ async def test_header_disappears_async(self):\n         response = await self.async_client.get(\"/remote_user/\")\n         self.assertFalse(response.context[\"user\"].is_anonymous)\n         self.assertEqual(response.context[\"user\"].username, \"knownuser\")\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddlewareSyncOnly(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddleware(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+    async def aprocess_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+@override_settings(ROOT_URLCONF=\"auth_tests.urls\")\n+class CustomProcessRequestMiddlewareTest(TestCase):\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.\"\n+            \"CustomProcessRequestMiddlewareSyncOnly\"\n+        }\n+    )\n+    async def test_async_warns_sync_only_middleware(self):\n+        msg = (\n+            \"Support for subclasses of RemoteUserMiddleware that override \"\n+            \"process_request() without overriding aprocess_request() are \"\n+            \"deprecated.\"\n+        )\n+        with self.assertRaises(NotImplementedError):\n+            with self.assertWarnsMessage(RemovedInDjango61Warning, msg):\n+                await self.client.get(\"/remote_user/\")\n+\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.CustomProcessRequestMiddleware\"\n+        }\n+    )\n+    async def test_async_no_warning_sync_and_async_middleware(self):\n+        with self.assertRaises(NotImplementedError):\n+            await self.client.get(\"/remote_user/\")",
        "comment_created_at": "2025-05-22T08:38:13+00:00",
        "comment_author": "sarahboyce",
        "comment_body": "Thank you! I tweaked this slightly because the `NotImplementedError` was trying to prove that the `process_request` was being called (as we removed `process_request` in the regression). In the suggested update, if I updated `CustomProcessRequestMiddleware` to \r\n```python\r\nclass CustomProcessRequestMiddleware(RemoteUserMiddleware):\r\n    pass\r\n```\r\nThe test would still pass so I have added some mocking to show that we are still calling the custom logic\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2102592850",
        "repo_full_name": "django/django",
        "pr_number": 19488,
        "pr_file": "tests/auth_tests/test_remote_user.py",
        "discussion_id": "2100512938",
        "commented_code": "@@ -487,3 +488,47 @@ async def test_header_disappears_async(self):\n         response = await self.async_client.get(\"/remote_user/\")\n         self.assertFalse(response.context[\"user\"].is_anonymous)\n         self.assertEqual(response.context[\"user\"].username, \"knownuser\")\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddlewareSyncOnly(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddleware(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+    async def aprocess_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+@override_settings(ROOT_URLCONF=\"auth_tests.urls\")\n+class CustomProcessRequestMiddlewareTest(TestCase):\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.\"\n+            \"CustomProcessRequestMiddlewareSyncOnly\"\n+        }\n+    )\n+    async def test_async_warns_sync_only_middleware(self):\n+        msg = (\n+            \"Support for subclasses of RemoteUserMiddleware that override \"\n+            \"process_request() without overriding aprocess_request() are \"\n+            \"deprecated.\"\n+        )\n+        with self.assertRaises(NotImplementedError):\n+            with self.assertWarnsMessage(RemovedInDjango61Warning, msg):\n+                await self.client.get(\"/remote_user/\")\n+\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.CustomProcessRequestMiddleware\"\n+        }\n+    )\n+    async def test_async_no_warning_sync_and_async_middleware(self):\n+        with self.assertRaises(NotImplementedError):\n+            await self.client.get(\"/remote_user/\")",
        "comment_created_at": "2025-05-22T13:39:16+00:00",
        "comment_author": "nessita",
        "comment_body": "Thanks Sarah! I think it would be better to avoid using `mock` here and instead use a simpler but more straightforward approach to record the calls.\r\n\r\nBeyond personal preference, it's my understanding that Django tries hard to keep mock usage to an absolute minimum. Also, `mock` tends to introduce some practical issues such as typos in the patched method name can silently pass (e.g., `assert_not_called()` on a misspelled target), and all the patching adds a fair amount of boilerplate with extra params and decorators. IMHO that makes the tests harder to read and maintain.\r\n\r\nIt also makes the behavior being tested less obvious, since it's a bit more involved to see the actual code paths being exercised, just whether the mock was called. In contrast, tracking method calls directly with a class-level list would be simpler, easier to follow, and more robust. It also avoids relying on Python internals that are less familiar to many contributors. I think a plain class-based approach would make these tests more readable and reliable overall. For example:\r\n\r\n```python\r\n# RemovedInDjango61Warning.\r\nclass CustomProcessRequestMiddlewareSyncOnly(RemoteUserMiddleware):\r\n\r\n    calls = []\r\n\r\n    def process_request(self, request):\r\n        self.calls.append((\"process_request\", request))\r\n\r\n\r\n# RemovedInDjango61Warning.\r\nclass CustomProcessRequestMiddleware(RemoteUserMiddleware):\r\n\r\n    calls = []\r\n\r\n    def process_request(self, request):\r\n        self.calls.append((\"process_request\", request))\r\n\r\n    async def aprocess_request(self, request):\r\n        self.calls.append((\"aprocess_request\", request))\r\n\r\n\r\n# RemovedInDjango61Warning.\r\n@override_settings(ROOT_URLCONF=\"auth_tests.urls\")\r\nclass CustomProcessRequestMiddlewareTest(TestCase):\r\n    @modify_settings(\r\n        MIDDLEWARE={\r\n            \"append\": \"auth_tests.test_remote_user.\"\r\n            \"CustomProcessRequestMiddlewareSyncOnly\"\r\n        }\r\n    )\r\n    async def test_async_warns_sync_only_middleware(self):\r\n        msg = (\r\n            \"Support for subclasses of RemoteUserMiddleware that override \"\r\n            \"process_request() without overriding aprocess_request() are \"\r\n            \"deprecated.\"\r\n        )\r\n        with self.assertWarnsMessage(RemovedInDjango61Warning, msg):\r\n            response = await self.async_client.get(\"/remote_user/\")\r\n\r\n        self.assertContains(response, \"Username is AnonymousUser\")\r\n        self.assertEqual(\r\n            CustomProcessRequestMiddlewareSyncOnly.calls,\r\n            [(\"process_request\", response.asgi_request)],\r\n        )\r\n\r\n    @modify_settings(\r\n        MIDDLEWARE={\r\n            \"append\": \"auth_tests.test_remote_user.CustomProcessRequestMiddleware\"\r\n        }\r\n    )\r\n    async def test_async_no_warning_sync_and_async_middleware(self):\r\n        response = await self.async_client.get(\"/remote_user/\")\r\n\r\n        self.assertContains(response, \"Username is AnonymousUser\")\r\n        self.assertEqual(\r\n            CustomProcessRequestMiddleware.calls,\r\n            [(\"aprocess_request\", response.asgi_request)],\r\n        )\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2102599133",
        "repo_full_name": "django/django",
        "pr_number": 19488,
        "pr_file": "tests/auth_tests/test_remote_user.py",
        "discussion_id": "2100512938",
        "commented_code": "@@ -487,3 +488,47 @@ async def test_header_disappears_async(self):\n         response = await self.async_client.get(\"/remote_user/\")\n         self.assertFalse(response.context[\"user\"].is_anonymous)\n         self.assertEqual(response.context[\"user\"].username, \"knownuser\")\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddlewareSyncOnly(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+class CustomProcessRequestMiddleware(RemoteUserMiddleware):\n+    def process_request(self, request):\n+        raise NotImplementedError\n+\n+    async def aprocess_request(self, request):\n+        raise NotImplementedError\n+\n+\n+# RemovedInDjango61Warning.\n+@override_settings(ROOT_URLCONF=\"auth_tests.urls\")\n+class CustomProcessRequestMiddlewareTest(TestCase):\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.\"\n+            \"CustomProcessRequestMiddlewareSyncOnly\"\n+        }\n+    )\n+    async def test_async_warns_sync_only_middleware(self):\n+        msg = (\n+            \"Support for subclasses of RemoteUserMiddleware that override \"\n+            \"process_request() without overriding aprocess_request() are \"\n+            \"deprecated.\"\n+        )\n+        with self.assertRaises(NotImplementedError):\n+            with self.assertWarnsMessage(RemovedInDjango61Warning, msg):\n+                await self.client.get(\"/remote_user/\")\n+\n+    @modify_settings(\n+        MIDDLEWARE={\n+            \"append\": \"auth_tests.test_remote_user.CustomProcessRequestMiddleware\"\n+        }\n+    )\n+    async def test_async_no_warning_sync_and_async_middleware(self):\n+        with self.assertRaises(NotImplementedError):\n+            await self.client.get(\"/remote_user/\")",
        "comment_created_at": "2025-05-22T13:41:45+00:00",
        "comment_author": "nessita",
        "comment_body": "EDIT: I was mistaken!\r\n~~The other bit that I think is untested is the guard for emitting the deprecation warning. If we fully remove this code, no test fails:~~",
        "pr_file_module": null
      }
    ]
  }
]