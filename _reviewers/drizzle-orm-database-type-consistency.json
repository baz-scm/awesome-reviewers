[
  {
    "discussion_id": "1886807185",
    "pr_number": 3739,
    "pr_file": "drizzle-kit/src/snapshotsDiffer.ts",
    "created_at": "2024-12-16T13:20:24+00:00",
    "commented_code": "};\n };\n \n+// This is necessary to make sure that BigInt is serialized to Number\n+// at the diffSchemasOrTables function. Ohterwise, it will be serialized to BigInt\n+// and the diff will throw the following error\n+// \"TypeError: Do not know how to serialize a BigInt\"\n+\n+declare global {\n+    interface BigInt {\n+        toJSON(): Number;",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1886807185",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 3739,
        "pr_file": "drizzle-kit/src/snapshotsDiffer.ts",
        "discussion_id": "1886807185",
        "commented_code": "@@ -2686,6 +2686,19 @@ export const applyMysqlSnapshotsDiff = async (\n \t};\n };\n \n+// This is necessary to make sure that BigInt is serialized to Number\n+// at the diffSchemasOrTables function. Ohterwise, it will be serialized to BigInt\n+// and the diff will throw the following error\n+// \"TypeError: Do not know how to serialize a BigInt\"\n+\n+declare global {\n+    interface BigInt {\n+        toJSON(): Number;",
        "comment_created_at": "2024-12-16T13:20:24+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "I don't think it's a good solution. SQLite has bigint as defaults and PostgreSQL has it as well and I can see it's also not working as expected, so it's a bug we have. I think you should look into `singlestoreSerialiazer` and find `generateSingleStoreSnapshot` function. There you can see how defaults are mapped and if you see BigInt there - map to string before writing to a snapshot - https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-kit/src/serializer/singlestoreSerializer.ts#L126",
        "pr_file_module": null
      },
      {
        "comment_id": "1887215837",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 3739,
        "pr_file": "drizzle-kit/src/snapshotsDiffer.ts",
        "discussion_id": "1886807185",
        "commented_code": "@@ -2686,6 +2686,19 @@ export const applyMysqlSnapshotsDiff = async (\n \t};\n };\n \n+// This is necessary to make sure that BigInt is serialized to Number\n+// at the diffSchemasOrTables function. Ohterwise, it will be serialized to BigInt\n+// and the diff will throw the following error\n+// \"TypeError: Do not know how to serialize a BigInt\"\n+\n+declare global {\n+    interface BigInt {\n+        toJSON(): Number;",
        "comment_created_at": "2024-12-16T17:21:40+00:00",
        "comment_author": "Rodriguespn",
        "comment_body": "I decided to convert the column default value to Number if it's `typeof` BigInt and it's now working. Thank you for the suggestion.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1437129855",
    "pr_number": 1659,
    "pr_file": "drizzle-orm/src/postgres-js/driver.ts",
    "created_at": "2023-12-27T16:07:44+00:00",
    "commented_code": "client: Sql,\n \tconfig: DrizzleConfig<TSchema> = {},\n ): PostgresJsDatabase<TSchema> {\n+\tconst transparentParser = (val: any) => val;\n+\n+\t// Override postgres.js default date parsers: https://github.com/porsager/postgres/discussions/761\n+\tfor (const type of ['1184', '1082', '1083', '1114']) {",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1437129855",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1659,
        "pr_file": "drizzle-orm/src/postgres-js/driver.ts",
        "discussion_id": "1437129855",
        "commented_code": "@@ -20,6 +20,14 @@ export function drizzle<TSchema extends Record<string, unknown> = Record<string,\n \tclient: Sql,\n \tconfig: DrizzleConfig<TSchema> = {},\n ): PostgresJsDatabase<TSchema> {\n+\tconst transparentParser = (val: any) => val;\n+\n+\t// Override postgres.js default date parsers: https://github.com/porsager/postgres/discussions/761\n+\tfor (const type of ['1184', '1082', '1083', '1114']) {",
        "comment_created_at": "2023-12-27T16:07:44+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "Wouldn't adding this setter for both parsers and serializers resolve the issues without altering the mapping in the timestamp column class? It seems like it should always return string from database in this case, as long as you just using \r\n```ts \r\nconst transparentParser = (val: any) => val;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1437131975",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1659,
        "pr_file": "drizzle-orm/src/postgres-js/driver.ts",
        "discussion_id": "1437129855",
        "commented_code": "@@ -20,6 +20,14 @@ export function drizzle<TSchema extends Record<string, unknown> = Record<string,\n \tclient: Sql,\n \tconfig: DrizzleConfig<TSchema> = {},\n ): PostgresJsDatabase<TSchema> {\n+\tconst transparentParser = (val: any) => val;\n+\n+\t// Override postgres.js default date parsers: https://github.com/porsager/postgres/discussions/761\n+\tfor (const type of ['1184', '1082', '1083', '1114']) {",
        "comment_created_at": "2023-12-27T16:11:17+00:00",
        "comment_author": "Angelelz",
        "comment_body": "Yes, you are correct. But I thought that handling what's received from the driver without assuming what it is might be smarter/shielded from future similar bugs.\r\nLet me know if you'd like me to revert the mappings I added at `timestamp.ts`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1441709660",
    "pr_number": 1659,
    "pr_file": "integration-tests/tests/pg.test.ts",
    "created_at": "2024-01-04T12:47:58+00:00",
    "commented_code": "await db.execute(sql`drop type ${name(categoryEnum.enumName)}`);\n });\n \n+test.serial('all date and time columns', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\tdateString: date('date_string', { mode: 'string' }).notNull(),\n+\t\ttime: time('time', { precision: 3 }).notNull(),\n+\t\tdatetime: timestamp('datetime').notNull(),\n+\t\tdatetimeWTZ: timestamp('datetime_wtz', { withTimezone: true }).notNull(),\n+\t\tdatetimeString: timestamp('datetime_string', { mode: 'string' }).notNull(),\n+\t\tdatetimeFullPrecision: timestamp('datetime_full_precision', { precision: 6, mode: 'string' }).notNull(),\n+\t\tdatetimeWTZString: timestamp('datetime_wtz_string', { withTimezone: true, mode: 'string' }).notNull(),\n+\t\tinterval: interval('interval').notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\tdate_string date not null,\n+\t\t\t\t\ttime time(3) not null,\n+\t\t\t\t\tdatetime timestamp not null,\n+\t\t\t\t\tdatetime_wtz timestamp with time zone not null,\n+\t\t\t\t\tdatetime_string timestamp not null,\n+\t\t\t\t\tdatetime_full_precision timestamp(6) not null,\n+\t\t\t\t\tdatetime_wtz_string timestamp with time zone not null,\n+\t\t\t\t\tinterval interval not null\n+\t\t\t)\n+\t`);\n+\n+\tconst someDatetime = new Date('2022-01-01T00:00:00.123Z');\n+\tconst fullPrecision = '2022-01-01T00:00:00.123456Z';\n+\tconst someTime = '23:23:12.432';\n+\n+\tawait db.insert(table).values({\n+\t\tdateString: '2022-01-01',\n+\t\ttime: someTime,\n+\t\tdatetime: someDatetime,\n+\t\tdatetimeWTZ: someDatetime,\n+\t\tdatetimeString: '2022-01-01T00:00:00.123Z',\n+\t\tdatetimeFullPrecision: fullPrecision,\n+\t\tdatetimeWTZString: '2022-01-01T00:00:00.123Z',\n+\t\tinterval: '1 day',\n+\t});\n+\n+\tconst result = await db.select().from(table);\n+\n+\tExpect<\n+\t\tEqual<{\n+\t\t\tid: number;\n+\t\t\tdateString: string;\n+\t\t\ttime: string;\n+\t\t\tdatetime: Date;\n+\t\t\tdatetimeWTZ: Date;\n+\t\t\tdatetimeString: string;\n+\t\t\tdatetimeFullPrecision: string;\n+\t\t\tdatetimeWTZString: string;\n+\t\t\tinterval: string;\n+\t\t}[], typeof result>\n+\t>;\n+\n+\tExpect<\n+\t\tEqual<{\n+\t\t\tdateString: string;\n+\t\t\ttime: string;\n+\t\t\tdatetime: Date;\n+\t\t\tdatetimeWTZ: Date;\n+\t\t\tdatetimeString: string;\n+\t\t\tdatetimeFullPrecision: string;\n+\t\t\tdatetimeWTZString: string;\n+\t\t\tinterval: string;\n+\t\t\tid?: number | undefined;\n+\t\t}, typeof table.$inferInsert>\n+\t>;\n+\n+\tt.deepEqual(result, [\n+\t\t{\n+\t\t\tid: 1,\n+\t\t\tdateString: '2022-01-01',\n+\t\t\ttime: someTime,\n+\t\t\tdatetime: someDatetime,\n+\t\t\tdatetimeWTZ: someDatetime,\n+\t\t\tdatetimeString: '2022-01-01 00:00:00.123',\n+\t\t\tdatetimeFullPrecision: fullPrecision.replace('T', ' ').replace('Z', ''),\n+\t\t\tdatetimeWTZString: '2022-01-01 00:00:00.123+00',\n+\t\t\tinterval: '1 day',\n+\t\t},\n+\t]);\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns with timezone first case mode string', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'string', withTimezone: true, precision: 6 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(6) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\t// 1. Insert date in string format with timezone in it\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: '2022-01-01 02:00:00.123456-0200' },\n+\t]);\n+\n+\t// 2, Select in string format and check that values are the same\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: '2022-01-01 04:00:00.123456+00' }]);\n+\n+\t// 3. Select as raw query and check that values are the same\n+\tconst result2 = await db.execute<{\n+\t\tid: number;\n+\t\ttimestamp_string: string;\n+\t}>(sql`select * from ${table}`);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: '2022-01-01 04:00:00.123456+00' }]);\n+\n+\tt.deepEqual(result2.rows, [{ id: 1, timestamp_string: '2022-01-01 04:00:00.123456+00' }]);\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns with timezone second case mode date', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'date', withTimezone: true, precision: 3 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(3) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\tconst insertedDate = new Date();\n+\n+\t// 1. Insert date as new date\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: insertedDate },\n+\t]);\n+\n+\t// 2, Select as date and check that timezones are the same\n+\t// There is no way to check timezone in Date object, as it is always represented internally in UTC\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: insertedDate }]);\n+\n+\t// 3. Compare both dates\n+\tt.deepEqual(insertedDate.getTime(), result[0]?.timestamp.getTime());\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns with timezone third case mode date', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'date', withTimezone: true, precision: 3 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(3) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\tconst insertedDate = new Date('2022-01-01 20:00:00.123-04'); // used different time zones, internally is still UTC\n+\tconst insertedDate2 = new Date('2022-01-02 04:00:00.123+04'); // They are both the same date in different time zones\n+\n+\t// 1. Insert date as new dates with different time zones\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: insertedDate },\n+\t\t{ timestamp: insertedDate2 },\n+\t]);\n+\n+\t// 2, Select and compare both dates\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result[0]?.timestamp.getTime(), result[1]?.timestamp.getTime());\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns without timezone first case mode string', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'string', precision: 6 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(6) not null\n+\t\t\t)\n+\t`);\n+\n+\t// 1. Insert date in string format without timezone in it\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: '2022-01-01 02:00:00.123456' },\n+\t]);\n+\n+\t// 2, Select in string format and check that values are the same\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: '2022-01-01 02:00:00.123456' }]);\n+\n+\t// 3. Select as raw query and check that values are the same\n+\tconst result2 = await db.execute<{\n+\t\tid: number;\n+\t\ttimestamp_string: string;\n+\t}>(sql`select * from ${table}`);\n+\n+\tt.deepEqual(result2.rows, [{ id: 1, timestamp_string: '2022-01-01 02:00:00.123456' }]);\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns without timezone second case mode string', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'string', precision: 6 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(6) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\t// 1. Insert date in string format with timezone in it\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: '2022-01-01T02:00:00.123456-02' },\n+\t]);\n+\n+\t// 2, Select as raw query and check that values are the same\n+\tconst result = await db.execute<{\n+\t\tid: number;\n+\t\ttimestamp_string: string;\n+\t}>(sql`select * from ${table}`);\n+\n+\t// Please notice that postgres will transform the date to UTC and it saves it in UTC.\n+\t// even if set without time zone, just becuase it was provided a timezone offset, it will transform it to UTC\n+\tt.deepEqual(result.rows, [{ id: 1, timestamp_string: '2022-01-01 04:00:00.123456+00' }]);",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1441709660",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1659,
        "pr_file": "integration-tests/tests/pg.test.ts",
        "discussion_id": "1441709660",
        "commented_code": "@@ -2384,6 +2387,500 @@ test.serial('select from enum', async (t) => {\n \tawait db.execute(sql`drop type ${name(categoryEnum.enumName)}`);\n });\n \n+test.serial('all date and time columns', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\tdateString: date('date_string', { mode: 'string' }).notNull(),\n+\t\ttime: time('time', { precision: 3 }).notNull(),\n+\t\tdatetime: timestamp('datetime').notNull(),\n+\t\tdatetimeWTZ: timestamp('datetime_wtz', { withTimezone: true }).notNull(),\n+\t\tdatetimeString: timestamp('datetime_string', { mode: 'string' }).notNull(),\n+\t\tdatetimeFullPrecision: timestamp('datetime_full_precision', { precision: 6, mode: 'string' }).notNull(),\n+\t\tdatetimeWTZString: timestamp('datetime_wtz_string', { withTimezone: true, mode: 'string' }).notNull(),\n+\t\tinterval: interval('interval').notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\tdate_string date not null,\n+\t\t\t\t\ttime time(3) not null,\n+\t\t\t\t\tdatetime timestamp not null,\n+\t\t\t\t\tdatetime_wtz timestamp with time zone not null,\n+\t\t\t\t\tdatetime_string timestamp not null,\n+\t\t\t\t\tdatetime_full_precision timestamp(6) not null,\n+\t\t\t\t\tdatetime_wtz_string timestamp with time zone not null,\n+\t\t\t\t\tinterval interval not null\n+\t\t\t)\n+\t`);\n+\n+\tconst someDatetime = new Date('2022-01-01T00:00:00.123Z');\n+\tconst fullPrecision = '2022-01-01T00:00:00.123456Z';\n+\tconst someTime = '23:23:12.432';\n+\n+\tawait db.insert(table).values({\n+\t\tdateString: '2022-01-01',\n+\t\ttime: someTime,\n+\t\tdatetime: someDatetime,\n+\t\tdatetimeWTZ: someDatetime,\n+\t\tdatetimeString: '2022-01-01T00:00:00.123Z',\n+\t\tdatetimeFullPrecision: fullPrecision,\n+\t\tdatetimeWTZString: '2022-01-01T00:00:00.123Z',\n+\t\tinterval: '1 day',\n+\t});\n+\n+\tconst result = await db.select().from(table);\n+\n+\tExpect<\n+\t\tEqual<{\n+\t\t\tid: number;\n+\t\t\tdateString: string;\n+\t\t\ttime: string;\n+\t\t\tdatetime: Date;\n+\t\t\tdatetimeWTZ: Date;\n+\t\t\tdatetimeString: string;\n+\t\t\tdatetimeFullPrecision: string;\n+\t\t\tdatetimeWTZString: string;\n+\t\t\tinterval: string;\n+\t\t}[], typeof result>\n+\t>;\n+\n+\tExpect<\n+\t\tEqual<{\n+\t\t\tdateString: string;\n+\t\t\ttime: string;\n+\t\t\tdatetime: Date;\n+\t\t\tdatetimeWTZ: Date;\n+\t\t\tdatetimeString: string;\n+\t\t\tdatetimeFullPrecision: string;\n+\t\t\tdatetimeWTZString: string;\n+\t\t\tinterval: string;\n+\t\t\tid?: number | undefined;\n+\t\t}, typeof table.$inferInsert>\n+\t>;\n+\n+\tt.deepEqual(result, [\n+\t\t{\n+\t\t\tid: 1,\n+\t\t\tdateString: '2022-01-01',\n+\t\t\ttime: someTime,\n+\t\t\tdatetime: someDatetime,\n+\t\t\tdatetimeWTZ: someDatetime,\n+\t\t\tdatetimeString: '2022-01-01 00:00:00.123',\n+\t\t\tdatetimeFullPrecision: fullPrecision.replace('T', ' ').replace('Z', ''),\n+\t\t\tdatetimeWTZString: '2022-01-01 00:00:00.123+00',\n+\t\t\tinterval: '1 day',\n+\t\t},\n+\t]);\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns with timezone first case mode string', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'string', withTimezone: true, precision: 6 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(6) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\t// 1. Insert date in string format with timezone in it\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: '2022-01-01 02:00:00.123456-0200' },\n+\t]);\n+\n+\t// 2, Select in string format and check that values are the same\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: '2022-01-01 04:00:00.123456+00' }]);\n+\n+\t// 3. Select as raw query and check that values are the same\n+\tconst result2 = await db.execute<{\n+\t\tid: number;\n+\t\ttimestamp_string: string;\n+\t}>(sql`select * from ${table}`);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: '2022-01-01 04:00:00.123456+00' }]);\n+\n+\tt.deepEqual(result2.rows, [{ id: 1, timestamp_string: '2022-01-01 04:00:00.123456+00' }]);\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns with timezone second case mode date', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'date', withTimezone: true, precision: 3 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(3) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\tconst insertedDate = new Date();\n+\n+\t// 1. Insert date as new date\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: insertedDate },\n+\t]);\n+\n+\t// 2, Select as date and check that timezones are the same\n+\t// There is no way to check timezone in Date object, as it is always represented internally in UTC\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: insertedDate }]);\n+\n+\t// 3. Compare both dates\n+\tt.deepEqual(insertedDate.getTime(), result[0]?.timestamp.getTime());\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns with timezone third case mode date', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'date', withTimezone: true, precision: 3 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(3) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\tconst insertedDate = new Date('2022-01-01 20:00:00.123-04'); // used different time zones, internally is still UTC\n+\tconst insertedDate2 = new Date('2022-01-02 04:00:00.123+04'); // They are both the same date in different time zones\n+\n+\t// 1. Insert date as new dates with different time zones\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: insertedDate },\n+\t\t{ timestamp: insertedDate2 },\n+\t]);\n+\n+\t// 2, Select and compare both dates\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result[0]?.timestamp.getTime(), result[1]?.timestamp.getTime());\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns without timezone first case mode string', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'string', precision: 6 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(6) not null\n+\t\t\t)\n+\t`);\n+\n+\t// 1. Insert date in string format without timezone in it\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: '2022-01-01 02:00:00.123456' },\n+\t]);\n+\n+\t// 2, Select in string format and check that values are the same\n+\tconst result = await db.select().from(table);\n+\n+\tt.deepEqual(result, [{ id: 1, timestamp: '2022-01-01 02:00:00.123456' }]);\n+\n+\t// 3. Select as raw query and check that values are the same\n+\tconst result2 = await db.execute<{\n+\t\tid: number;\n+\t\ttimestamp_string: string;\n+\t}>(sql`select * from ${table}`);\n+\n+\tt.deepEqual(result2.rows, [{ id: 1, timestamp_string: '2022-01-01 02:00:00.123456' }]);\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+});\n+\n+test.serial('all date and time columns without timezone second case mode string', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tconst table = pgTable('all_columns', {\n+\t\tid: serial('id').primaryKey(),\n+\t\ttimestamp: timestamp('timestamp_string', { mode: 'string', precision: 6 }).notNull(),\n+\t});\n+\n+\tawait db.execute(sql`drop table if exists ${table}`);\n+\n+\tawait db.execute(sql`\n+\t\tcreate table ${table} (\n+\t\t\t\t\tid serial primary key,\n+\t\t\t\t\ttimestamp_string timestamp(6) with time zone not null\n+\t\t\t)\n+\t`);\n+\n+\t// 1. Insert date in string format with timezone in it\n+\tawait db.insert(table).values([\n+\t\t{ timestamp: '2022-01-01T02:00:00.123456-02' },\n+\t]);\n+\n+\t// 2, Select as raw query and check that values are the same\n+\tconst result = await db.execute<{\n+\t\tid: number;\n+\t\ttimestamp_string: string;\n+\t}>(sql`select * from ${table}`);\n+\n+\t// Please notice that postgres will transform the date to UTC and it saves it in UTC.\n+\t// even if set without time zone, just becuase it was provided a timezone offset, it will transform it to UTC\n+\tt.deepEqual(result.rows, [{ id: 1, timestamp_string: '2022-01-01 04:00:00.123456+00' }]);",
        "comment_created_at": "2024-01-04T12:47:58+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "As Postgres [docs](https://www.postgresql.org/docs/current/datatype-datetime.html) states\r\n\r\n> In a literal that has been determined to be timestamp without time zone, PostgreSQL will silently ignore any time zone indication. That is, the resulting value is derived from the date/time fields in the input value, and is not adjusted for time zone.\r\n\r\nThis means that when you insert a string with a timezone into a `timestamp without time zone` type, the timezone should be simply removed without any time conversions. For example, for `2022-01-01T02:00:00.123456-02`, you should receive `2022-01-01 02:00:00.123456` in return\r\n\r\nThe reason why it happened - you have created `timestamp(6) with time zone` instead of `timestamp(6)`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1309138033",
    "pr_number": 1082,
    "pr_file": "integration-tests/tests/mysql.test.ts",
    "created_at": "2023-08-29T17:19:17+00:00",
    "commented_code": "await db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('utc config for datetime', async (t) => {",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1309138033",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1082,
        "pr_file": "integration-tests/tests/mysql.test.ts",
        "discussion_id": "1309138033",
        "commented_code": "@@ -1967,3 +1967,46 @@ test.serial('update undefined', async (t) => {\n \n \tawait db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('utc config for datetime', async (t) => {",
        "comment_created_at": "2023-08-29T17:19:17+00:00",
        "comment_author": "dankochetov",
        "comment_body": "Could you add a check to this test that verifies the actual value that's put into the DB with `mode: \"date\"`? You could use a raw `select` query to get the data bypassing the mapping.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1310291010",
    "pr_number": 1082,
    "pr_file": "integration-tests/tests/mysql.test.ts",
    "created_at": "2023-08-30T13:33:15+00:00",
    "commented_code": "await db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('utc config for datetime', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tawait db.execute(sql`drop table if exists \\`datestable\\``);\n+\tawait db.execute(\n+\t\tsql`\n+\t\t\tcreate table \\`datestable\\` (\n+\t\t\t\t\\`datetime_utc\\` datetime(3),\n+\t\t\t\t\\`datetime\\` datetime(3),\n+\t\t\t\t\\`datetime_as_string\\` datetime\n+\t\t\t)\n+\t\t`,\n+\t);\n+\tconst datesTable2 = mysqlTable('datestable', {\n+\t\tdatetimeUTC: datetime('datetime_utc', { fsp: 3, mode: 'date' }),\n+\t\tdatetime: datetime('datetime', { fsp: 3 }),\n+\t\tdatetimeAsString: datetime('datetime_as_string', { mode: 'string' }),\n+\t});\n+\n+\tconst dateObj = new Date('2022-11-11');\n+\tconst dateUtc = new Date(Date.now());\n+\n+\tawait db.insert(datesTable2).values({\n+\t\tdatetimeUTC: dateUtc,\n+\t\tdatetime: dateObj,\n+\t\tdatetimeAsString: '2022-11-11 12:12:12',\n+\t});\n+\n+\tconst res = await db.select().from(datesTable2);\n+\n+\tconst [rawSelect] = await db.execute(sql`select \\`datetime_utc\\` from \\`datestable\\``);\n+\tconst datetimeUTC = (rawSelect as unknown as [{ datetime_utc: string }])[0];\n+\n+\tt.is(datetimeUTC.datetime_utc.replace(' ', 'T') + 'Z', dateUtc.toISOString());",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1310291010",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1082,
        "pr_file": "integration-tests/tests/mysql.test.ts",
        "discussion_id": "1310291010",
        "commented_code": "@@ -1967,3 +1967,52 @@ test.serial('update undefined', async (t) => {\n \n \tawait db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('utc config for datetime', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tawait db.execute(sql`drop table if exists \\`datestable\\``);\n+\tawait db.execute(\n+\t\tsql`\n+\t\t\tcreate table \\`datestable\\` (\n+\t\t\t\t\\`datetime_utc\\` datetime(3),\n+\t\t\t\t\\`datetime\\` datetime(3),\n+\t\t\t\t\\`datetime_as_string\\` datetime\n+\t\t\t)\n+\t\t`,\n+\t);\n+\tconst datesTable2 = mysqlTable('datestable', {\n+\t\tdatetimeUTC: datetime('datetime_utc', { fsp: 3, mode: 'date' }),\n+\t\tdatetime: datetime('datetime', { fsp: 3 }),\n+\t\tdatetimeAsString: datetime('datetime_as_string', { mode: 'string' }),\n+\t});\n+\n+\tconst dateObj = new Date('2022-11-11');\n+\tconst dateUtc = new Date(Date.now());\n+\n+\tawait db.insert(datesTable2).values({\n+\t\tdatetimeUTC: dateUtc,\n+\t\tdatetime: dateObj,\n+\t\tdatetimeAsString: '2022-11-11 12:12:12',\n+\t});\n+\n+\tconst res = await db.select().from(datesTable2);\n+\n+\tconst [rawSelect] = await db.execute(sql`select \\`datetime_utc\\` from \\`datestable\\``);\n+\tconst datetimeUTC = (rawSelect as unknown as [{ datetime_utc: string }])[0];\n+\n+\tt.is(datetimeUTC.datetime_utc.replace(' ', 'T') + 'Z', dateUtc.toISOString());",
        "comment_created_at": "2023-08-30T13:33:15+00:00",
        "comment_author": "dankochetov",
        "comment_body": "Let's compare `datetime_utc` to a hardcoded string without any transformations. The goal is to verify that the DB value is in an exact format, not that it corresponds to the original date - that is checked in other parts of the test.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1155287792",
    "pr_number": 288,
    "pr_file": "integration-tests/tests/pg.test.ts",
    "created_at": "2023-04-02T10:57:08+00:00",
    "commented_code": "await db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('timestamp timezone', async (t) => {",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1155287792",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 288,
        "pr_file": "integration-tests/tests/pg.test.ts",
        "discussion_id": "1155287792",
        "commented_code": "@@ -1562,3 +1562,22 @@ test.serial('prefixed table', async (t) => {\n \n \tawait db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('timestamp timezone', async (t) => {",
        "comment_created_at": "2023-04-02T10:57:08+00:00",
        "comment_author": "dankochetov",
        "comment_body": "Did you actually run this test? We don't run the integration tests in the pipeline yet, so it's up to the developers to run them locally. This one looks like it won't work, because you're not creating the \"users\" table, you're just defining it, and I'm pretty sure there's already a different \"users\" table defined in the tests and present in the test DB.",
        "pr_file_module": null
      },
      {
        "comment_id": "1155369173",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 288,
        "pr_file": "integration-tests/tests/pg.test.ts",
        "discussion_id": "1155287792",
        "commented_code": "@@ -1562,3 +1562,22 @@ test.serial('prefixed table', async (t) => {\n \n \tawait db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('timestamp timezone', async (t) => {",
        "comment_created_at": "2023-04-02T20:15:29+00:00",
        "comment_author": "AppelBoomHD",
        "comment_body": "The test succeeded, but I can see now that it doesn't make any sense. It seems I wasn't paying good attention writing this part \ud83d\ude05. Thanks for pointing it out!\r\nI pushed a fix where a new table is actually created, also with a different name.\r\nSince the test was now failing, I noticed that postgres timestamp without timezones were being mapped to the client's timezone, which I had originally suspected. Hence, I've reverted my revert (commit https://github.com/drizzle-team/drizzle-orm/pull/288/commits/34bd785b53e489f58e12a0f4175a0e702252f8af) which made the test succeed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1155288060",
    "pr_number": 288,
    "pr_file": "integration-tests/tests/mysql.test.ts",
    "created_at": "2023-04-02T10:58:43+00:00",
    "commented_code": "await db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('timestamp timezone', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tawait db.insert(usersTable).values({ name: 'John' });",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1155288060",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 288,
        "pr_file": "integration-tests/tests/mysql.test.ts",
        "discussion_id": "1155288060",
        "commented_code": "@@ -1263,3 +1263,12 @@ test.serial('prefixed table', async (t) => {\n \n \tawait db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('timestamp timezone', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tawait db.insert(usersTable).values({ name: 'John' });",
        "comment_created_at": "2023-04-02T10:58:43+00:00",
        "comment_author": "dankochetov",
        "comment_body": "Could you add a test inserting a Date with a non-default timezone specified? I'm curious if it'll change the date string format returned from the driver on selection.",
        "pr_file_module": null
      },
      {
        "comment_id": "1155369604",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 288,
        "pr_file": "integration-tests/tests/mysql.test.ts",
        "discussion_id": "1155288060",
        "commented_code": "@@ -1263,3 +1263,12 @@ test.serial('prefixed table', async (t) => {\n \n \tawait db.execute(sql`drop table ${users}`);\n });\n+\n+test.serial('timestamp timezone', async (t) => {\n+\tconst { db } = t.context;\n+\n+\tawait db.insert(usersTable).values({ name: 'John' });",
        "comment_created_at": "2023-04-02T20:19:26+00:00",
        "comment_author": "AppelBoomHD",
        "comment_body": "Good point! I added the test as you specified for both mysql and postgres timestamps. Upon running the tests I found out that timestamps are by default inserted respecting the client's timezone as well, instead of in UTC format. I pushed a fix for this behavior, which passed all the tests.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136017228",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:22:40+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136017228",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136017228",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';",
        "comment_created_at": "2023-03-14T18:22:40+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "We should use mysql specific helper functions for mysql zod integration",
        "pr_file_module": null
      },
      {
        "comment_id": "1137481877",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136017228",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';",
        "comment_created_at": "2023-03-15T17:18:34+00:00",
        "comment_author": "JonathonRP",
        "comment_body": "Question, would these changes also apply to planet scale? Like could I still import MySQL columns and helpers from MySQL core or would I need to also use the planet scale client? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1137549403",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136017228",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';",
        "comment_created_at": "2023-03-15T18:04:28+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "PlanetScale is just a driver. So if you will implement everything from mysql core it could be used for any mysql driver",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136018020",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:23:29+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136018020",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136018020",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =",
        "comment_created_at": "2023-03-14T18:23:29+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "`AnyPgColumn` is used for postgres specific functions. We need to use `AnyMySqlColumn` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136018101",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:23:33+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136018101",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136018101",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType",
        "comment_created_at": "2023-03-14T18:23:33+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "`AnyPgColumn` is used for postgres specific functions. We need to use `AnyMySqlColumn` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136018563",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:24:01+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136018563",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136018563",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,",
        "comment_created_at": "2023-03-14T18:24:01+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "`AnyPgTable` is used for postgres specific functions. We need to use `AnyMySqlTable` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136018708",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:24:09+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136018708",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136018708",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,",
        "comment_created_at": "2023-03-14T18:24:09+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "`AnyPgTable` is used for postgres specific functions. We need to use `AnyMySqlTable` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136018852",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:24:18+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+> =\n+\t| { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never }\n+\t| ((\n+\t\tfields: BuildInsertSchema<TTable, TCase, {}, true>,\n+\t) => { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never });\n+\n+export function createInsertSchema<TTable extends AnyPgTable>(",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136018852",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136018852",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+> =\n+\t| { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never }\n+\t| ((\n+\t\tfields: BuildInsertSchema<TTable, TCase, {}, true>,\n+\t) => { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never });\n+\n+export function createInsertSchema<TTable extends AnyPgTable>(",
        "comment_created_at": "2023-03-14T18:24:18+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "`AnyPgTable` is used for postgres specific functions. We need to use `AnyMySqlTable` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136018924",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:24:24+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+> =\n+\t| { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never }\n+\t| ((\n+\t\tfields: BuildInsertSchema<TTable, TCase, {}, true>,\n+\t) => { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never });\n+\n+export function createInsertSchema<TTable extends AnyPgTable>(\n+\ttable: TTable,\n+): z.ZodObject<BuildInsertSchema<TTable, undefined, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param convertToCase Convert keys to snake_case or camelCase\n+\t */\n+\tconvertToCase: TCase,\n+): z.ZodObject<BuildInsertSchema<TTable, TCase, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136018924",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136018924",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+> =\n+\t| { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never }\n+\t| ((\n+\t\tfields: BuildInsertSchema<TTable, TCase, {}, true>,\n+\t) => { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never });\n+\n+export function createInsertSchema<TTable extends AnyPgTable>(\n+\ttable: TTable,\n+): z.ZodObject<BuildInsertSchema<TTable, undefined, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param convertToCase Convert keys to snake_case or camelCase\n+\t */\n+\tconvertToCase: TCase,\n+): z.ZodObject<BuildInsertSchema<TTable, TCase, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,",
        "comment_created_at": "2023-03-14T18:24:24+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "`AnyPgTable` is used for postgres specific functions. We need to use `AnyMySqlTable` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1136019021",
    "pr_number": 241,
    "pr_file": "drizzle-zod/src/mysql/index.ts",
    "created_at": "2023-03-14T18:24:29+00:00",
    "commented_code": "+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+> =\n+\t| { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never }\n+\t| ((\n+\t\tfields: BuildInsertSchema<TTable, TCase, {}, true>,\n+\t) => { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never });\n+\n+export function createInsertSchema<TTable extends AnyPgTable>(\n+\ttable: TTable,\n+): z.ZodObject<BuildInsertSchema<TTable, undefined, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param convertToCase Convert keys to snake_case or camelCase\n+\t */\n+\tconvertToCase: TCase,\n+): z.ZodObject<BuildInsertSchema<TTable, TCase, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, undefined, {}>]?: z.ZodTypeAny;\n+\t},\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param refine Refine schema fields\n+\t */\n+\trefine: Refine<TTable, undefined, TRefine>,\n+): z.ZodObject<BuildInsertSchema<TTable, undefined, TRefine>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param convertToCase convert keys to snake_case or camelCase\n+\t */\n+\tconvertToCase: TCase,\n+\t/**\n+\t * @param refine Refine schema fields\n+\t */\n+\trefine: Refine<TTable, TCase, TRefine>,\n+): z.ZodObject<BuildInsertSchema<TTable, TCase, TRefine>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+>(\n+\ttable: AnyPgTable,",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1136019021",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 241,
        "pr_file": "drizzle-zod/src/mysql/index.ts",
        "discussion_id": "1136019021",
        "commented_code": "@@ -0,0 +1,243 @@\n+import { GetColumnConfig } from 'drizzle-orm';\n+import {\n+\tAnyPgColumn,\n+\tAnyPgTable,\n+\tGetTableConfig,\n+\tPgBigInt53,\n+\tPgBigInt64,\n+\tPgBigSerial53,\n+\tPgBigSerial64,\n+\tPgBoolean,\n+\tPgDate,\n+\tPgDoublePrecision,\n+\tPgEnumColumn,\n+\tPgEnumColumnConfig,\n+\tPgInteger,\n+\tPgInterval,\n+\tPgNumeric,\n+\tPgReal,\n+\tPgSerial,\n+\tPgSmallInt,\n+\tPgSmallSerial,\n+\tPgText,\n+\tPgTextConfig,\n+\tPgTime,\n+\tPgTimestamp,\n+\tPgUUID,\n+\tPgVarchar,\n+} from 'drizzle-orm/mysql-core';\n+import { getTableColumns } from 'drizzle-orm/pg-core/utils';\n+import { Simplify } from 'drizzle-orm/utils';\n+import { z } from 'zod';\n+\n+type SnakeToCamelCase<S extends string> = S extends `${infer T}${'_' | '-'}${infer U}`\n+\t? `${T}${Capitalize<SnakeToCamelCase<U>>}`\n+\t: S;\n+\n+type ToSnakeCase<S extends string> = S extends `${infer T}${'' | '-'}${infer U}`\n+\t? `${T extends Capitalize<T> ? Lowercase<T> extends Capitalize<T> ? '' : '_' : ''}${Lowercase<T>}${ToSnakeCase<U>}`\n+\t: S;\n+\n+function toCamelCase(value: string): string {\n+\treturn value.replace(/([-_][a-z])/gi, ($1) => $1.toUpperCase().replace('-', '').replace('_', ''));\n+}\n+\n+function toSnakeCase(value: string): string {\n+\treturn value.replace(/([A-Z])/g, ($1) => `_${$1.toLowerCase()}`);\n+}\n+\n+type MaybeOptional<TColumn extends AnyPgColumn, TType extends z.ZodTypeAny, TNoOptional extends boolean = false> =\n+\tTNoOptional extends true ? TType\n+\t\t: GetColumnConfig<TColumn, 'hasDefault'> extends true ? z.ZodOptional<TType>\n+\t\t: TType;\n+\n+type GetZodType<TColumn extends AnyPgColumn> = GetColumnConfig<TColumn, 'data'> extends infer TType\n+\t? TColumn extends PgEnumColumn<PgEnumColumnConfig & { values: infer TValues extends [string, ...string[]] }>\n+\t\t? z.ZodEnum<TValues>\n+\t: TType extends number ? z.ZodNumber\n+\t: TType extends string ? z.ZodString\n+\t: TType extends boolean ? z.ZodBoolean\n+\t: TType extends Date ? z.ZodDate\n+\t: z.ZodAny\n+\t: never;\n+\n+type ConvertKeyName<K extends string, TCase extends 'snake' | 'camel' | undefined> = undefined extends TCase ? K\n+\t: 'snake' extends TCase ? ToSnakeCase<K>\n+\t: SnakeToCamelCase<K>;\n+\n+export type BuildInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends Record<string, z.ZodTypeAny | undefined>,\n+\tTNoOptional extends boolean = false,\n+> = GetTableConfig<TTable, 'columns'> extends infer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns & string as ConvertKeyName<K, TCase>]: MaybeOptional<\n+\t\t\tTColumns[K],\n+\t\t\tConvertKeyName<K, TCase> extends keyof TRefine\n+\t\t\t\t? TRefine[ConvertKeyName<K, TCase>] extends z.ZodTypeAny ? TRefine[ConvertKeyName<K, TCase>]\n+\t\t\t\t: GetZodType<TColumns[K]>\n+\t\t\t\t: GetZodType<TColumns[K]>,\n+\t\t\tTNoOptional\n+\t\t>;\n+\t}\n+\t: never;\n+\n+export type GetRequiredConfigFields<T extends AnyPgTable> = GetTableConfig<T, 'columns'> extends\n+\tinfer TColumns extends Record<string, AnyPgColumn> ? {\n+\t\t[K in keyof TColumns]: TColumns[K] extends PgText<PgTextConfig & { values: infer TValues }>\n+\t\t\t? [string, ...string[]] extends TValues ? never : TValues\n+\t\t\t: never;\n+\t}\n+\t: never;\n+\n+export type RequiredFieldsConfig<\n+\tTTable extends AnyPgTable,\n+> = Simplify<\n+\t{\n+\t\t[K in keyof GetRequiredConfigFields<TTable> as [GetRequiredConfigFields<TTable>[K]] extends [never] ? never : K]: {\n+\t\t\tanyString: true;\n+\t\t} | { enum: GetRequiredConfigFields<TTable>[K] };\n+\t}\n+>;\n+\n+export type Refine<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel' | undefined,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+> =\n+\t| { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never }\n+\t| ((\n+\t\tfields: BuildInsertSchema<TTable, TCase, {}, true>,\n+\t) => { [K in keyof TRefine]: K extends keyof BuildInsertSchema<TTable, TCase, {}> ? TRefine[K] : never });\n+\n+export function createInsertSchema<TTable extends AnyPgTable>(\n+\ttable: TTable,\n+): z.ZodObject<BuildInsertSchema<TTable, undefined, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param convertToCase Convert keys to snake_case or camelCase\n+\t */\n+\tconvertToCase: TCase,\n+): z.ZodObject<BuildInsertSchema<TTable, TCase, {}>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, undefined, {}>]?: z.ZodTypeAny;\n+\t},\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param refine Refine schema fields\n+\t */\n+\trefine: Refine<TTable, undefined, TRefine>,\n+): z.ZodObject<BuildInsertSchema<TTable, undefined, TRefine>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+>(\n+\ttable: TTable,\n+\t/**\n+\t * @param convertToCase convert keys to snake_case or camelCase\n+\t */\n+\tconvertToCase: TCase,\n+\t/**\n+\t * @param refine Refine schema fields\n+\t */\n+\trefine: Refine<TTable, TCase, TRefine>,\n+): z.ZodObject<BuildInsertSchema<TTable, TCase, TRefine>>;\n+export function createInsertSchema<\n+\tTTable extends AnyPgTable,\n+\tTCase extends 'snake' | 'camel',\n+\tTRefine extends {\n+\t\t[K in keyof BuildInsertSchema<TTable, TCase, {}>]?: z.ZodTypeAny;\n+\t},\n+>(\n+\ttable: AnyPgTable,",
        "comment_created_at": "2023-03-14T18:24:29+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "`AnyPgTable` is used for postgres specific functions. We need to use `AnyMySqlTable` here",
        "pr_file_module": null
      }
    ]
  }
]