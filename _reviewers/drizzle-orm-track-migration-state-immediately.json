[
  {
    "discussion_id": "1831292415",
    "pr_number": 2959,
    "pr_file": "drizzle-kit/src/serializer/mysqlSerializer.ts",
    "created_at": "2024-11-06T15:57:28+00:00",
    "commented_code": null,
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1831292415",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 2959,
        "pr_file": "drizzle-kit/src/serializer/mysqlSerializer.ts",
        "discussion_id": "1831292415",
        "commented_code": null,
        "comment_created_at": "2024-11-06T15:57:28+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "When we make changes to the serializer (referring to pgSerializer, mysqlSerializer, and sqliteSerializer), it means that the generated snapshot JSON may differ from the output produced for the same schema in previous versions. This results in `drizzle-kit generate` producing a new migration for cases where developers have fields in snapshots whose logic was altered by this PR.\r\n\r\nWe have a few options to address this:\r\n\r\n1. Avoid changing it at the serializer level and instead apply the modification later, after storing the snapshot. However, this approach may lead to increased maintenance burden in future releases and is not ideal.\r\n\r\n2. Ignore this change, as it will only impact developers with previous snapshot versions. In this case, we would need to provide clear guidance for developers on how to handle it.\r\n\r\n3. Use the `drizzle-kit up` command and implement new version upgrade. Ideally, we should increment snapshot versions and recursively update all snapshots, applying the new logic (e.g., escape, enum type handling) introduced in the serializer to ensure everything works as expected.\r\n\r\nWe need to decide between option 2 and option 3. Given that we are still in a pre-v1.0 phase, we could proceed with option 2 if the percentage of users affected by unnecessary migration generation (only once) is expected to be under 5%",
        "pr_file_module": null
      },
      {
        "comment_id": "1831295184",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 2959,
        "pr_file": "drizzle-kit/src/serializer/mysqlSerializer.ts",
        "discussion_id": "1831292415",
        "commented_code": null,
        "comment_created_at": "2024-11-06T15:59:13+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "We have only defaults changed, so I think option 2 may be good",
        "pr_file_module": null
      },
      {
        "comment_id": "1831412279",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 2959,
        "pr_file": "drizzle-kit/src/serializer/mysqlSerializer.ts",
        "discussion_id": "1831292415",
        "commented_code": null,
        "comment_created_at": "2024-11-06T17:02:29+00:00",
        "comment_author": "L-Mario564",
        "comment_body": "I agree, I think option 2 is the better option.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1523395073",
    "pr_number": 1902,
    "pr_file": "drizzle-orm/src/xata-http/migrator.ts",
    "created_at": "2024-03-13T14:45:26+00:00",
    "commented_code": "+import type { MigrationConfig } from '~/migrator.ts';\n+import { readMigrationFiles } from '~/migrator.ts';\n+import { type SQL, sql } from '~/sql/sql.ts';\n+import type { XataHttpDatabase } from './driver.ts';\n+\n+/**\n+ * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database\n+ *\n+ * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,\n+ * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.\n+ * @param db - drizzle db instance\n+ * @param config - path to migration folder generated by drizzle-kit\n+ */\n+export async function migrate<TSchema extends Record<string, unknown>>(db: XataHttpDatabase<TSchema>, config: string | MigrationConfig) {\n+  const migrations = readMigrationFiles(config);\n+  const migrationsTable = typeof config === 'string' ? '__drizzle_migrations' : config.migrationsTable ?? '__drizzle_migrations';\n+  const migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n+  const migrationTableCreate = sql`\n+\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n+\t\t\tid SERIAL PRIMARY KEY,\n+\t\t\thash text NOT NULL,\n+\t\t\tcreated_at bigint\n+\t\t)\n+\t`;\n+  await db.session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n+  await db.session.execute(migrationTableCreate);\n+\n+  const dbMigrations = await db.session.all<{\n+    id: number;\n+    hash: string;\n+    created_at: string;\n+  }>(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);\n+\n+  const lastDbMigration = dbMigrations[0];\n+  const rowsToInsert: SQL[] = [];\n+  for await (const migration of migrations) {\n+    if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {\n+      for (const stmt of migration.sql) {\n+        await db.session.execute(sql.raw(stmt));\n+      }\n+\n+      rowsToInsert.push(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`);",
    "repo_full_name": "drizzle-team/drizzle-orm",
    "discussion_comments": [
      {
        "comment_id": "1523395073",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1902,
        "pr_file": "drizzle-orm/src/xata-http/migrator.ts",
        "discussion_id": "1523395073",
        "commented_code": "@@ -0,0 +1,49 @@\n+import type { MigrationConfig } from '~/migrator.ts';\n+import { readMigrationFiles } from '~/migrator.ts';\n+import { type SQL, sql } from '~/sql/sql.ts';\n+import type { XataHttpDatabase } from './driver.ts';\n+\n+/**\n+ * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database\n+ *\n+ * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,\n+ * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.\n+ * @param db - drizzle db instance\n+ * @param config - path to migration folder generated by drizzle-kit\n+ */\n+export async function migrate<TSchema extends Record<string, unknown>>(db: XataHttpDatabase<TSchema>, config: string | MigrationConfig) {\n+  const migrations = readMigrationFiles(config);\n+  const migrationsTable = typeof config === 'string' ? '__drizzle_migrations' : config.migrationsTable ?? '__drizzle_migrations';\n+  const migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n+  const migrationTableCreate = sql`\n+\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n+\t\t\tid SERIAL PRIMARY KEY,\n+\t\t\thash text NOT NULL,\n+\t\t\tcreated_at bigint\n+\t\t)\n+\t`;\n+  await db.session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n+  await db.session.execute(migrationTableCreate);\n+\n+  const dbMigrations = await db.session.all<{\n+    id: number;\n+    hash: string;\n+    created_at: string;\n+  }>(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);\n+\n+  const lastDbMigration = dbMigrations[0];\n+  const rowsToInsert: SQL[] = [];\n+  for await (const migration of migrations) {\n+    if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {\n+      for (const stmt of migration.sql) {\n+        await db.session.execute(sql.raw(stmt));\n+      }\n+\n+      rowsToInsert.push(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`);",
        "comment_created_at": "2024-03-13T14:45:26+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "Depending on the results you want to see here, it may be either a good or a bad decision.\r\n\r\nSo, currently, here is what will happen:\r\n\r\nYou have 2 files with migrations (`migration_1.sql`, `migration_2.sql`):\r\n\r\n- If the migration process fails after `migration_1.sql` is applied, the row in the `__drizzle_migrations` table won't be created, and you will be in a situation where you have all statements from the first file applied, but nothing is stored about that in the database.\r\n\r\nAs a user, I would expect the migrator to store information about the applied migration file in the database. Therefore, perhaps you need to run this insert query here and not on lines 46-48",
        "pr_file_module": null
      },
      {
        "comment_id": "1523426315",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1902,
        "pr_file": "drizzle-orm/src/xata-http/migrator.ts",
        "discussion_id": "1523395073",
        "commented_code": "@@ -0,0 +1,49 @@\n+import type { MigrationConfig } from '~/migrator.ts';\n+import { readMigrationFiles } from '~/migrator.ts';\n+import { type SQL, sql } from '~/sql/sql.ts';\n+import type { XataHttpDatabase } from './driver.ts';\n+\n+/**\n+ * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database\n+ *\n+ * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,\n+ * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.\n+ * @param db - drizzle db instance\n+ * @param config - path to migration folder generated by drizzle-kit\n+ */\n+export async function migrate<TSchema extends Record<string, unknown>>(db: XataHttpDatabase<TSchema>, config: string | MigrationConfig) {\n+  const migrations = readMigrationFiles(config);\n+  const migrationsTable = typeof config === 'string' ? '__drizzle_migrations' : config.migrationsTable ?? '__drizzle_migrations';\n+  const migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n+  const migrationTableCreate = sql`\n+\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n+\t\t\tid SERIAL PRIMARY KEY,\n+\t\t\thash text NOT NULL,\n+\t\t\tcreated_at bigint\n+\t\t)\n+\t`;\n+  await db.session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n+  await db.session.execute(migrationTableCreate);\n+\n+  const dbMigrations = await db.session.all<{\n+    id: number;\n+    hash: string;\n+    created_at: string;\n+  }>(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);\n+\n+  const lastDbMigration = dbMigrations[0];\n+  const rowsToInsert: SQL[] = [];\n+  for await (const migration of migrations) {\n+    if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {\n+      for (const stmt of migration.sql) {\n+        await db.session.execute(sql.raw(stmt));\n+      }\n+\n+      rowsToInsert.push(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`);",
        "comment_created_at": "2024-03-13T14:59:38+00:00",
        "comment_author": "SferaDev",
        "comment_body": "I followed the example set by Neon's HTTP migrator: https://github.com/drizzle-team/drizzle-orm/blob/main/drizzle-orm/src/neon-http/migrator.ts#L37-L50\r\n\r\nMaybe theirs should also be updated?",
        "pr_file_module": null
      },
      {
        "comment_id": "1523445036",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1902,
        "pr_file": "drizzle-orm/src/xata-http/migrator.ts",
        "discussion_id": "1523395073",
        "commented_code": "@@ -0,0 +1,49 @@\n+import type { MigrationConfig } from '~/migrator.ts';\n+import { readMigrationFiles } from '~/migrator.ts';\n+import { type SQL, sql } from '~/sql/sql.ts';\n+import type { XataHttpDatabase } from './driver.ts';\n+\n+/**\n+ * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database\n+ *\n+ * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,\n+ * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.\n+ * @param db - drizzle db instance\n+ * @param config - path to migration folder generated by drizzle-kit\n+ */\n+export async function migrate<TSchema extends Record<string, unknown>>(db: XataHttpDatabase<TSchema>, config: string | MigrationConfig) {\n+  const migrations = readMigrationFiles(config);\n+  const migrationsTable = typeof config === 'string' ? '__drizzle_migrations' : config.migrationsTable ?? '__drizzle_migrations';\n+  const migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n+  const migrationTableCreate = sql`\n+\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n+\t\t\tid SERIAL PRIMARY KEY,\n+\t\t\thash text NOT NULL,\n+\t\t\tcreated_at bigint\n+\t\t)\n+\t`;\n+  await db.session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n+  await db.session.execute(migrationTableCreate);\n+\n+  const dbMigrations = await db.session.all<{\n+    id: number;\n+    hash: string;\n+    created_at: string;\n+  }>(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);\n+\n+  const lastDbMigration = dbMigrations[0];\n+  const rowsToInsert: SQL[] = [];\n+  for await (const migration of migrations) {\n+    if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {\n+      for (const stmt of migration.sql) {\n+        await db.session.execute(sql.raw(stmt));\n+      }\n+\n+      rowsToInsert.push(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`);",
        "comment_created_at": "2024-03-13T15:09:14+00:00",
        "comment_author": "AndriiSherman",
        "comment_body": "good point, will need to change it as well, I guess I missed it on a review",
        "pr_file_module": null
      },
      {
        "comment_id": "1526104657",
        "repo_full_name": "drizzle-team/drizzle-orm",
        "pr_number": 1902,
        "pr_file": "drizzle-orm/src/xata-http/migrator.ts",
        "discussion_id": "1523395073",
        "commented_code": "@@ -0,0 +1,49 @@\n+import type { MigrationConfig } from '~/migrator.ts';\n+import { readMigrationFiles } from '~/migrator.ts';\n+import { type SQL, sql } from '~/sql/sql.ts';\n+import type { XataHttpDatabase } from './driver.ts';\n+\n+/**\n+ * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database\n+ *\n+ * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,\n+ * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.\n+ * @param db - drizzle db instance\n+ * @param config - path to migration folder generated by drizzle-kit\n+ */\n+export async function migrate<TSchema extends Record<string, unknown>>(db: XataHttpDatabase<TSchema>, config: string | MigrationConfig) {\n+  const migrations = readMigrationFiles(config);\n+  const migrationsTable = typeof config === 'string' ? '__drizzle_migrations' : config.migrationsTable ?? '__drizzle_migrations';\n+  const migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n+  const migrationTableCreate = sql`\n+\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n+\t\t\tid SERIAL PRIMARY KEY,\n+\t\t\thash text NOT NULL,\n+\t\t\tcreated_at bigint\n+\t\t)\n+\t`;\n+  await db.session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n+  await db.session.execute(migrationTableCreate);\n+\n+  const dbMigrations = await db.session.all<{\n+    id: number;\n+    hash: string;\n+    created_at: string;\n+  }>(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);\n+\n+  const lastDbMigration = dbMigrations[0];\n+  const rowsToInsert: SQL[] = [];\n+  for await (const migration of migrations) {\n+    if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {\n+      for (const stmt of migration.sql) {\n+        await db.session.execute(sql.raw(stmt));\n+      }\n+\n+      rowsToInsert.push(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`);",
        "comment_created_at": "2024-03-15T11:00:42+00:00",
        "comment_author": "SferaDev",
        "comment_body": "https://github.com/drizzle-team/drizzle-orm/pull/1902/commits/6ce62ea2c1e2f81568e515bb18395d0324a13a47",
        "pr_file_module": null
      }
    ]
  }
]