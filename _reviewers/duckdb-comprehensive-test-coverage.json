[
  {
    "discussion_id": "1903852574",
    "pr_number": 15435,
    "pr_file": "benchmark/parquet/large_schema_union_by_name.benchmark",
    "created_at": "2025-01-06T08:43:47+00:00",
    "commented_code": "+# name: benchmark/parquet/large_schema_union_by_name.benchmark",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1903852574",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15435,
        "pr_file": "benchmark/parquet/large_schema_union_by_name.benchmark",
        "discussion_id": "1903852574",
        "commented_code": "@@ -0,0 +1,40 @@\n+# name: benchmark/parquet/large_schema_union_by_name.benchmark",
        "comment_created_at": "2025-01-06T08:43:47+00:00",
        "comment_author": "lnkuiper",
        "comment_body": "Can we add a test that tests the new parameter for CSV as well?",
        "pr_file_module": null
      },
      {
        "comment_id": "1906666195",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15435,
        "pr_file": "benchmark/parquet/large_schema_union_by_name.benchmark",
        "discussion_id": "1903852574",
        "commented_code": "@@ -0,0 +1,40 @@\n+# name: benchmark/parquet/large_schema_union_by_name.benchmark",
        "comment_created_at": "2025-01-08T08:01:55+00:00",
        "comment_author": "thalassemia",
        "comment_body": "I got this PR working for CSVs as well. For testing, I added an existing `union_by_name` benchmark to the regression test suite and several tests for `cache_union_readers=False`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1822177261",
    "pr_number": 12078,
    "pr_file": "test/sql/collate/collate_union.test",
    "created_at": "2024-10-30T09:12:11+00:00",
    "commented_code": "+# name: test/sql/collate/collate_union.test\n+# description: Test collation in Union operator\n+# group: [collate]\n+\n+require icu\n+\n+query I\n+SELECT 'A' COLLATE NOCASE UNION SELECT 'a'",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1822177261",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 12078,
        "pr_file": "test/sql/collate/collate_union.test",
        "discussion_id": "1822177261",
        "commented_code": "@@ -0,0 +1,130 @@\n+# name: test/sql/collate/collate_union.test\n+# description: Test collation in Union operator\n+# group: [collate]\n+\n+require icu\n+\n+query I\n+SELECT 'A' COLLATE NOCASE UNION SELECT 'a'",
        "comment_created_at": "2024-10-30T09:12:11+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Can we add some more tests?\r\n\r\n* `EXCEPT` and `INTERSECT` tests\r\n* Tests using `default_collation` instead of `COLLATE` expressions\r\n* Tests using collations stored in columns\r\n* Tests using mismatching collations\r\n* Tests using collations in nested set operations (e.g. `(SELECT 'A' UNION SELECT 'b') UNION (SELECT 'c' UNION SELECT 'A' COLLATE NOCASE);`)\r\n* Tests with ICU collations\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "804501711",
    "pr_number": 3065,
    "pr_file": "test/sql/function/list/list_contains.test",
    "created_at": "2022-02-11T09:57:12+00:00",
    "commented_code": "+# name: test/sql/function/list/list_contains.test\n+# description: Test list_ccontains function\n+# group: [list]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table TEST (i int[]);\n+\n+statement ok\n+insert into TEST values ([2,1,3]), ([2,3,4]), ([1]);\n+\n+query TT\n+SELECT i, list_contains(i,1) from TEST;\n+----\n+[2, 1, 3]\t1\n+[2, 3, 4]\t0\n+[1]\t1\n+\n+query TT\n+SELECT i, list_contains(i,4.0) from TEST;\n+----\n+[2, 1, 3]\t0\n+[2, 3, 4]\t1\n+[1]\t0\n+\n+statement ok\n+create table STR_TEST (i string[]);\n+\n+statement ok\n+insert into STR_TEST values (['a','b','c']), (['d','a','e']), (['b']);\n+\n+query TT\n+SELECT i, list_contains(i,'a') from STR_TEST;\n+----\n+[a, b, c]\t1\n+[d, a, e]\t1\n+[b]\t0\n+\n+query TT\n+SELECT i, list_contains(i,0) from STR_TEST;\n+----\n+[a, b, c]\t0\n+[d, a, e]\t0\n+[b]\t0\n+\n+\n+query TT\n+SELECT i, list_contains(i,NULL) from STR_TEST;\n+----\n+[a, b, c]\tNULL\n+[d, a, e]\tNULL\n+[b]\tNULL\n+\n+\n+# basic functionality\n+query T\n+SELECT list_contains([7,2,5], 7)\n+----\n+1\n+\n+# Empty list\n+query T\n+SELECT list_contains([], 7)\n+----\n+0\n+\n+# Mixed data types\n+query T\n+SELECT list_contains([1,2,3],1.0)\n+----\n+1\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0,4.0],1)\n+----\n+1\n+\n+query T\n+SELECT list_contains([1,2,3],4.0)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0],4)\n+----\n+0\n+\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0], 'a')\n+----\n+0\n+\n+# Not a list as input\n+statement error\n+SELECT list_contains('a', 'a')\n+\n+query T\n+SELECT list_contains(NULL,NULL)\n+----\n+NULL\n+\n+\n+query T\n+SELECT list_contains([7], 5)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1,2,3,4],4)\n+----\n+1\n+\n+query T\n+SELECT list_contains([1,2,3,4],5)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0,4.0],5.0)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0,4.0],4.0)\n+----\n+1\n+\n+query T\n+SELECT list_contains([true, false],true)\n+----\n+1\n+\n+query T\n+SELECT list_contains([true, true],false)\n+----\n+0\n+\n+query T\n+SELECT list_contains(['test', 'notest'],'notest')\n+----\n+1\n+\n+query T\n+SELECT list_contains(['test', 'notest'],'a')\n+----\n+0\n+\n+# Null types\n+query T\n+SELECT list_contains(NULL,1)\n+----\n+NULL\n+\n+query T\n+SELECT list_contains([NULL],NULL)\n+----\n+NULL\n+\n+query T\n+SELECT list_contains([NULL, 1],NULL)\n+----\n+NULL\n+\n+query T\n+SELECT list_contains([NULL, 1],1)\n+----\n+1\n+\n+query T\n+SELECT list_contains([NULL, 0],1)\n+----\n+0\n+\n+query T\n+SELECT list_contains([],NULL)\n+----\n+NULL\n+\n+\n+query T\n+SELECT list_contains([NULL,7], 7)\n+----\n+1\n+\n+statement error\n+SELECT list_contains([[1,2,3],[1],[1,2,3])\n+",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "804501711",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 3065,
        "pr_file": "test/sql/function/list/list_contains.test",
        "discussion_id": "804501711",
        "commented_code": "@@ -0,0 +1,190 @@\n+# name: test/sql/function/list/list_contains.test\n+# description: Test list_ccontains function\n+# group: [list]\n+\n+statement ok\n+PRAGMA enable_verification\n+\n+statement ok\n+create table TEST (i int[]);\n+\n+statement ok\n+insert into TEST values ([2,1,3]), ([2,3,4]), ([1]);\n+\n+query TT\n+SELECT i, list_contains(i,1) from TEST;\n+----\n+[2, 1, 3]\t1\n+[2, 3, 4]\t0\n+[1]\t1\n+\n+query TT\n+SELECT i, list_contains(i,4.0) from TEST;\n+----\n+[2, 1, 3]\t0\n+[2, 3, 4]\t1\n+[1]\t0\n+\n+statement ok\n+create table STR_TEST (i string[]);\n+\n+statement ok\n+insert into STR_TEST values (['a','b','c']), (['d','a','e']), (['b']);\n+\n+query TT\n+SELECT i, list_contains(i,'a') from STR_TEST;\n+----\n+[a, b, c]\t1\n+[d, a, e]\t1\n+[b]\t0\n+\n+query TT\n+SELECT i, list_contains(i,0) from STR_TEST;\n+----\n+[a, b, c]\t0\n+[d, a, e]\t0\n+[b]\t0\n+\n+\n+query TT\n+SELECT i, list_contains(i,NULL) from STR_TEST;\n+----\n+[a, b, c]\tNULL\n+[d, a, e]\tNULL\n+[b]\tNULL\n+\n+\n+# basic functionality\n+query T\n+SELECT list_contains([7,2,5], 7)\n+----\n+1\n+\n+# Empty list\n+query T\n+SELECT list_contains([], 7)\n+----\n+0\n+\n+# Mixed data types\n+query T\n+SELECT list_contains([1,2,3],1.0)\n+----\n+1\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0,4.0],1)\n+----\n+1\n+\n+query T\n+SELECT list_contains([1,2,3],4.0)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0],4)\n+----\n+0\n+\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0], 'a')\n+----\n+0\n+\n+# Not a list as input\n+statement error\n+SELECT list_contains('a', 'a')\n+\n+query T\n+SELECT list_contains(NULL,NULL)\n+----\n+NULL\n+\n+\n+query T\n+SELECT list_contains([7], 5)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1,2,3,4],4)\n+----\n+1\n+\n+query T\n+SELECT list_contains([1,2,3,4],5)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0,4.0],5.0)\n+----\n+0\n+\n+query T\n+SELECT list_contains([1.0,2.0,3.0,4.0],4.0)\n+----\n+1\n+\n+query T\n+SELECT list_contains([true, false],true)\n+----\n+1\n+\n+query T\n+SELECT list_contains([true, true],false)\n+----\n+0\n+\n+query T\n+SELECT list_contains(['test', 'notest'],'notest')\n+----\n+1\n+\n+query T\n+SELECT list_contains(['test', 'notest'],'a')\n+----\n+0\n+\n+# Null types\n+query T\n+SELECT list_contains(NULL,1)\n+----\n+NULL\n+\n+query T\n+SELECT list_contains([NULL],NULL)\n+----\n+NULL\n+\n+query T\n+SELECT list_contains([NULL, 1],NULL)\n+----\n+NULL\n+\n+query T\n+SELECT list_contains([NULL, 1],1)\n+----\n+1\n+\n+query T\n+SELECT list_contains([NULL, 0],1)\n+----\n+0\n+\n+query T\n+SELECT list_contains([],NULL)\n+----\n+NULL\n+\n+\n+query T\n+SELECT list_contains([NULL,7], 7)\n+----\n+1\n+\n+statement error\n+SELECT list_contains([[1,2,3],[1],[1,2,3])\n+",
        "comment_created_at": "2022-02-11T09:57:12+00:00",
        "comment_author": "lnkuiper",
        "comment_body": "For the mixed types, could you please add something along the lines of:\r\n```sql\r\nforeach type <integral> varchar\r\n-- some tests\r\nendloop\r\n```\r\n\r\nYou can see an example of this in `test_order_nested.test`\r\n\r\nThis will improve code coverage for your code, which you can find here:\r\nhttps://app.codecov.io/gh/duckdb/duckdb/compare/3065/tree/src/function/scalar/list/list_contains.cpp\r\n\r\nWe strive for near 100% coverage.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1010834070",
    "pr_number": 5160,
    "pr_file": "test/sql/cast/test_string_cast.test",
    "created_at": "2022-11-01T19:44:19+00:00",
    "commented_code": "0.5\n -128.5\n \n+query IIIII\n+SELECT '0xF'::INTEGER, '0x0'::INTEGER, '0xFEE'::INTEGER, '0xfee'::INTEGER, '0x00FEE'::INTEGER",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1010834070",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 5160,
        "pr_file": "test/sql/cast/test_string_cast.test",
        "discussion_id": "1010834070",
        "commented_code": "@@ -54,6 +54,15 @@ SELECT 2::DOUBLE::VARCHAR, 0.5::DOUBLE::VARCHAR, (-128.5)::DOUBLE::VARCHAR\n 0.5\n -128.5\n \n+query IIIII\n+SELECT '0xF'::INTEGER, '0x0'::INTEGER, '0xFEE'::INTEGER, '0xfee'::INTEGER, '0x00FEE'::INTEGER",
        "comment_created_at": "2022-11-01T19:44:19+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Could we add some tests with:\r\n\r\n* `'0x'::INT` (empty hex: should fail)\r\n* `'0'::INT` (should succeed and return 0)\r\n* Upper-case `x` (`'0XFF'::INT`)\r\n* Mix of different cases (`'0XfEfE'::INT`)\r\n* `'0xFFFFFFFFFFFFFFFFF'::INT` (i.e. very large overflow)\r\n* `'0x000000000000000'::INT` (many zeros - should succeed)\r\n* Exact bound tests for all types - should all succeed (`'0x7F'::TINYINT`, `'0x7FFF'::SMALLINT`, `'0x7FFFFFFF'::INT`, `'0x7FFFFFFFFFFFFFFF'::BIGINT`)\r\n* Exact bound tests exceeded for all types - should all fail (`'0x80'::TINYINT`, `'0x8000'::SMALLINT`, `'0x80000000'::INT`, `'0x8000000000000000'::BIGINT`)\r\n* `TRY_CAST` with an out-of-bounds integer (e.g. `SELECT TRY_CAST('0x80' AS TINYINT)` - should return `NULL`)\r\n* The same exact bound tests with casts to unsigned types (`'0xFF'::UTINYINT`, etc)",
        "pr_file_module": null
      },
      {
        "comment_id": "1010848331",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 5160,
        "pr_file": "test/sql/cast/test_string_cast.test",
        "discussion_id": "1010834070",
        "commented_code": "@@ -54,6 +54,15 @@ SELECT 2::DOUBLE::VARCHAR, 0.5::DOUBLE::VARCHAR, (-128.5)::DOUBLE::VARCHAR\n 0.5\n -128.5\n \n+query IIIII\n+SELECT '0xF'::INTEGER, '0x0'::INTEGER, '0xFEE'::INTEGER, '0xfee'::INTEGER, '0x00FEE'::INTEGER",
        "comment_created_at": "2022-11-01T20:02:06+00:00",
        "comment_author": "IanCal",
        "comment_body": "Yep, happy to add a chunk more tests given the general approach looks good :) I think I can see the right way of testing out of bounds (other than the try_cast which I'll do as well) - other files have \"statement error\", is that the right approach? Or should I be adding those cases to the c++ test cases?",
        "pr_file_module": null
      },
      {
        "comment_id": "1010853802",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 5160,
        "pr_file": "test/sql/cast/test_string_cast.test",
        "discussion_id": "1010834070",
        "commented_code": "@@ -54,6 +54,15 @@ SELECT 2::DOUBLE::VARCHAR, 0.5::DOUBLE::VARCHAR, (-128.5)::DOUBLE::VARCHAR\n 0.5\n -128.5\n \n+query IIIII\n+SELECT '0xF'::INTEGER, '0x0'::INTEGER, '0xFEE'::INTEGER, '0xfee'::INTEGER, '0x00FEE'::INTEGER",
        "comment_created_at": "2022-11-01T20:08:45+00:00",
        "comment_author": "Mytherin",
        "comment_body": "`statement error` is indeed the correct approach\r\n\r\nNote that you should only test one out-of-bounds per query, otherwise the query will fail on the first error on not correctly test the remaining, so e.g.:\r\n\r\n```sql\r\nstatement error\r\nSELECT '0x80'::TINYINT;\r\n\r\nstatement error\r\nSELECT '0x8000'::SMALLINT;\r\n\r\n...\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1701821746",
    "pr_number": 13277,
    "pr_file": "test/sql/function/string/test_format_extensions.test",
    "created_at": "2024-08-02T13:04:27+00:00",
    "commented_code": "----\n 123456789\n \n+query I\n+select printf('%,d', 123456789123456789123456789::HUGEINT)\n+----\n+123,456,789,123,456,789,123,456,789",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1701821746",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 13277,
        "pr_file": "test/sql/function/string/test_format_extensions.test",
        "discussion_id": "1701821746",
        "commented_code": "@@ -16,6 +16,11 @@ select format('{:d}', 123456789)\n ----\n 123456789\n \n+query I\n+select printf('%,d', 123456789123456789123456789::HUGEINT)\n+----\n+123,456,789,123,456,789,123,456,789",
        "comment_created_at": "2024-08-02T13:04:27+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Can we add a test for a negative hugeint, as well as for the min/max values of hugeint? (these can be obtained from `select hugeint, uhugeint from test_all_types();`)",
        "pr_file_module": null
      },
      {
        "comment_id": "1702178744",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 13277,
        "pr_file": "test/sql/function/string/test_format_extensions.test",
        "discussion_id": "1701821746",
        "commented_code": "@@ -16,6 +16,11 @@ select format('{:d}', 123456789)\n ----\n 123456789\n \n+query I\n+select printf('%,d', 123456789123456789123456789::HUGEINT)\n+----\n+123,456,789,123,456,789,123,456,789",
        "comment_created_at": "2024-08-02T18:19:50+00:00",
        "comment_author": "xuke-hat",
        "comment_body": "Thanks for advice! The negative case is wrong and I've added a fix.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2017149846",
    "pr_number": 16870,
    "pr_file": "test/sql/function/list/list_concat.test",
    "created_at": "2025-03-27T16:55:43+00:00",
    "commented_code": "----\n [1, 2]\n \n+query T\n+SELECT list_concat([1, 2], [3, 4], [5, 6])\n+----\n+[1, 2, 3, 4, 5, 6]\n+\n+query T\n+SELECT list_concat([1, 2], [3, 4], [])\n+----\n+[1, 2, 3, 4]\n+\n+query T\n+SELECT list_concat([1, 2], [], [5, 6])\n+----\n+[1, 2, 5, 6]\n+\n+query T\n+SELECT list_concat([], [3, 4], [5, 6])",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2017149846",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16870,
        "pr_file": "test/sql/function/list/list_concat.test",
        "discussion_id": "2017149846",
        "commented_code": "@@ -41,6 +41,36 @@ SELECT list_concat([1, 2], [])\n ----\n [1, 2]\n \n+query T\n+SELECT list_concat([1, 2], [3, 4], [5, 6])\n+----\n+[1, 2, 3, 4, 5, 6]\n+\n+query T\n+SELECT list_concat([1, 2], [3, 4], [])\n+----\n+[1, 2, 3, 4]\n+\n+query T\n+SELECT list_concat([1, 2], [], [5, 6])\n+----\n+[1, 2, 5, 6]\n+\n+query T\n+SELECT list_concat([], [3, 4], [5, 6])",
        "comment_created_at": "2025-03-27T16:55:43+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "Let's also add a test concatenating a `NULL`, maybe a `NULL` in a table, incompatible list types, and a non-list type in the top-level parameters (if these tests don't already exist).",
        "pr_file_module": null
      },
      {
        "comment_id": "2018122225",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16870,
        "pr_file": "test/sql/function/list/list_concat.test",
        "discussion_id": "2017149846",
        "commented_code": "@@ -41,6 +41,36 @@ SELECT list_concat([1, 2], [])\n ----\n [1, 2]\n \n+query T\n+SELECT list_concat([1, 2], [3, 4], [5, 6])\n+----\n+[1, 2, 3, 4, 5, 6]\n+\n+query T\n+SELECT list_concat([1, 2], [3, 4], [])\n+----\n+[1, 2, 3, 4]\n+\n+query T\n+SELECT list_concat([1, 2], [], [5, 6])\n+----\n+[1, 2, 5, 6]\n+\n+query T\n+SELECT list_concat([], [3, 4], [5, 6])",
        "comment_created_at": "2025-03-28T08:17:55+00:00",
        "comment_author": "maiadegraaf",
        "comment_body": "Some of these tests already exist in `test_concat_binding.test`, but I've added more to be safe. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1647349373",
    "pr_number": 12430,
    "pr_file": "test/sql/cte/recursive_cte_key_variant.test",
    "created_at": "2024-06-20T10:20:49+00:00",
    "commented_code": "+# name: test/sql/cte/recursive_cte_key_variant.test\n+# description: Recursive CTEs with an error thrown in the pipelines\n+# group: [cte]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (2,2,5)) UNION SELECT a+1, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+2\t3\t3\n+3\t4\t3\n+4\t4\t5\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (b) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,2)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,2)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t4\t3\n+2\t4\t2\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a,b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+2\t3\t3\n+1\t3\t3\n+2\t4\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (1,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a,b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (1,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+# Reference the recurring table more than once\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT 1, NULL, NULL UNION SELECT tbl.a+1, rec1.a, rec2.b FROM tbl, recurring_tbl AS rec1, recurring_tbl AS rec2 WHERE tbl.a < 5) SELECT * FROM tbl;\n+----\n+1\tNULL\tNULL\n+2\t1\tNULL\n+3\t2\t1\n+4\t3\t2\n+5\t4\t3\n+\n+\n+#######################\n+# Connected components\n+#######################\n+statement ok\n+CREATE OR REPLACE TABLE nodes (node int);\n+\n+statement ok\n+INSERT INTO nodes VALUES (0), (1), (2), (3), (4), (5), (6);\n+\n+statement ok\n+CREATE OR REPLACE TABLE edges (here int, there int);\n+\n+statement ok\n+INSERT INTO edges VALUES  (0,4), (4,0),\n+\t\t\t\t\t\t  (0,3), (3,0),\n+\t\t\t\t\t\t  (1,4), (4,1),\n+\t\t\t\t\t\t  (3,4), (4,3),\n+\t\t\t\t\t\t  (2,5), (5,2);\n+\n+\n+\n+query II\n+WITH RECURSIVE cc(node, comp) USING KEY (node) AS (\n+\tSELECT n.node, n.node AS comp\n+\tFROM nodes AS n\n+\t\tUNION\n+\t(SELECT DISTINCT ON (u.node) u.node, v.comp\n+\tFROM recurring_cc AS u, cc AS v, edges AS e\n+\tWHERE (e.here, e.there) = (u.node, v.node)\n+\tAND v.comp < u.comp\n+\tORDER BY u.node asc, v.comp asc)\n+)\n+TABLE cc ORDER BY node;\n+----\n+0\t0\n+1\t0\n+2\t2\n+3\t0\n+4\t0\n+5\t2\n+6\t6\n+\n+#######################\n+# bellman-ford\n+#######################\n+statement ok\n+CREATE OR REPLACE TABLE edges (here   char(2), -- source node\n+  \t\t\t\t\t\t\t   there  char(2), -- target node\n+  \t\t\t\t\t\t\t   length int,  -- edge weight\n+  \t\t\t\t\t\t\t   PRIMARY KEY (here, there));\n+\n+statement ok\n+INSERT INTO edges(here, there, length) VALUES\n+  ('v0', 'v1', 9),\n+  ('v0', 'v2', 3),\n+  ('v1', 'v2', 6),\n+  ('v1', 'v4', 2),\n+  ('v2', 'v1', 2),\n+  ('v2', 'v3', 1),\n+  ('v3', 'v2', 2),\n+  ('v3', 'v4', 2);\n+\n+statement ok\n+DROP TABLE nodes;\n+\n+statement ok\n+CREATE OR REPLACE VIEW nodes(node) AS\n+  SELECT e.here\n+  FROM   edges AS e\n+   UNION\n+  SELECT e.there\n+  FROM   edges AS e;\n+\n+query II\n+WITH RECURSIVE bellman(knode, distance) USING KEY (knode) AS (\n+  -- distance is 0 from source, \u221e from any other node\n+  SELECT n.node AS knode,\n+         CASE WHEN n.node = 'v0' THEN 0 ELSE 50000000 END AS distance\n+  FROM   nodes AS n\n+  UNION\n+  (SELECT rec.knode AS knode, n.distance + e.length AS distance\n+  FROM   bellman AS n, edges AS e, recurring_bellman AS rec\n+  WHERE  (e.here, e.there) = (n.knode, rec.knode)\n+  AND    rec.distance > n.distance + e.length\n+  ORDER BY distance DESC)\n+)\n+SELECT n.knode || CASE WHEN n.knode = 'v0' THEN ' (source)' ELSE '' END AS node,\n+       n.distance\n+FROM   bellman AS n\n+ORDER BY n.knode;\n+----\n+v0 (source)\t0\n+v1\t5\n+v2\t3\n+v3\t4\n+v4\t6\n+\n+\n+# more rows than STANDARD_CHUNK_SIZE\n+query I\n+WITH RECURSIVE tbl(n) USING KEY (n) AS (SELECT 1 UNION SELECT n+1 FROM tbl WHERE n < 3000) SELECT SUM(n) FROM tbl\n+----\n+4501500\n+\n+# You can use recursive CTE with and without a key in a query.\n+query II\n+WITH RECURSIVE tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3), tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3) SELECT * FROM tbl;\n+----\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3), tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3) SELECT * FROM tbl2;\n+----\n+1\t1\n+1\t2\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3), tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3) SELECT * FROM tbl2;\n+----\n+1\t1\n+1\t2\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3), tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3) SELECT * FROM tbl;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1647349373",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 12430,
        "pr_file": "test/sql/cte/recursive_cte_key_variant.test",
        "discussion_id": "1647349373",
        "commented_code": "@@ -0,0 +1,195 @@\n+# name: test/sql/cte/recursive_cte_key_variant.test\n+# description: Recursive CTEs with an error thrown in the pipelines\n+# group: [cte]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (2,2,5)) UNION SELECT a+1, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+2\t3\t3\n+3\t4\t3\n+4\t4\t5\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (b) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,2)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,2)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t4\t3\n+2\t4\t2\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a,b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+2\t3\t3\n+1\t3\t3\n+2\t4\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (1,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a,b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (1,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+# Reference the recurring table more than once\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT 1, NULL, NULL UNION SELECT tbl.a+1, rec1.a, rec2.b FROM tbl, recurring_tbl AS rec1, recurring_tbl AS rec2 WHERE tbl.a < 5) SELECT * FROM tbl;\n+----\n+1\tNULL\tNULL\n+2\t1\tNULL\n+3\t2\t1\n+4\t3\t2\n+5\t4\t3\n+\n+\n+#######################\n+# Connected components\n+#######################\n+statement ok\n+CREATE OR REPLACE TABLE nodes (node int);\n+\n+statement ok\n+INSERT INTO nodes VALUES (0), (1), (2), (3), (4), (5), (6);\n+\n+statement ok\n+CREATE OR REPLACE TABLE edges (here int, there int);\n+\n+statement ok\n+INSERT INTO edges VALUES  (0,4), (4,0),\n+\t\t\t\t\t\t  (0,3), (3,0),\n+\t\t\t\t\t\t  (1,4), (4,1),\n+\t\t\t\t\t\t  (3,4), (4,3),\n+\t\t\t\t\t\t  (2,5), (5,2);\n+\n+\n+\n+query II\n+WITH RECURSIVE cc(node, comp) USING KEY (node) AS (\n+\tSELECT n.node, n.node AS comp\n+\tFROM nodes AS n\n+\t\tUNION\n+\t(SELECT DISTINCT ON (u.node) u.node, v.comp\n+\tFROM recurring_cc AS u, cc AS v, edges AS e\n+\tWHERE (e.here, e.there) = (u.node, v.node)\n+\tAND v.comp < u.comp\n+\tORDER BY u.node asc, v.comp asc)\n+)\n+TABLE cc ORDER BY node;\n+----\n+0\t0\n+1\t0\n+2\t2\n+3\t0\n+4\t0\n+5\t2\n+6\t6\n+\n+#######################\n+# bellman-ford\n+#######################\n+statement ok\n+CREATE OR REPLACE TABLE edges (here   char(2), -- source node\n+  \t\t\t\t\t\t\t   there  char(2), -- target node\n+  \t\t\t\t\t\t\t   length int,  -- edge weight\n+  \t\t\t\t\t\t\t   PRIMARY KEY (here, there));\n+\n+statement ok\n+INSERT INTO edges(here, there, length) VALUES\n+  ('v0', 'v1', 9),\n+  ('v0', 'v2', 3),\n+  ('v1', 'v2', 6),\n+  ('v1', 'v4', 2),\n+  ('v2', 'v1', 2),\n+  ('v2', 'v3', 1),\n+  ('v3', 'v2', 2),\n+  ('v3', 'v4', 2);\n+\n+statement ok\n+DROP TABLE nodes;\n+\n+statement ok\n+CREATE OR REPLACE VIEW nodes(node) AS\n+  SELECT e.here\n+  FROM   edges AS e\n+   UNION\n+  SELECT e.there\n+  FROM   edges AS e;\n+\n+query II\n+WITH RECURSIVE bellman(knode, distance) USING KEY (knode) AS (\n+  -- distance is 0 from source, \u221e from any other node\n+  SELECT n.node AS knode,\n+         CASE WHEN n.node = 'v0' THEN 0 ELSE 50000000 END AS distance\n+  FROM   nodes AS n\n+  UNION\n+  (SELECT rec.knode AS knode, n.distance + e.length AS distance\n+  FROM   bellman AS n, edges AS e, recurring_bellman AS rec\n+  WHERE  (e.here, e.there) = (n.knode, rec.knode)\n+  AND    rec.distance > n.distance + e.length\n+  ORDER BY distance DESC)\n+)\n+SELECT n.knode || CASE WHEN n.knode = 'v0' THEN ' (source)' ELSE '' END AS node,\n+       n.distance\n+FROM   bellman AS n\n+ORDER BY n.knode;\n+----\n+v0 (source)\t0\n+v1\t5\n+v2\t3\n+v3\t4\n+v4\t6\n+\n+\n+# more rows than STANDARD_CHUNK_SIZE\n+query I\n+WITH RECURSIVE tbl(n) USING KEY (n) AS (SELECT 1 UNION SELECT n+1 FROM tbl WHERE n < 3000) SELECT SUM(n) FROM tbl\n+----\n+4501500\n+\n+# You can use recursive CTE with and without a key in a query.\n+query II\n+WITH RECURSIVE tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3), tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3) SELECT * FROM tbl;\n+----\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3), tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3) SELECT * FROM tbl2;\n+----\n+1\t1\n+1\t2\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3), tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3) SELECT * FROM tbl2;\n+----\n+1\t1\n+1\t2\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3), tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3) SELECT * FROM tbl;",
        "comment_created_at": "2024-06-20T10:20:49+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Could we add some more tests with failure conditions?\r\n\r\n* What if the key is not present in the table\r\n* What if there are duplicate keys\r\n* Given you are using an `expr_list_opt_comma`, what if the keys are arbitrary expressions (or perhaps this should be changed to `name_list_opt_comma` in the parser?)\r\n* Can we add a test using these in subqueries?\r\n* Can we add a test nesting these (similar to `test/sql/cte/test_nested_recursive_cte.test`)?\r\n* Can we add a test nesting these alongside regular recursive CTEs?\r\n* Can we add a test that uses `UNION ALL`?\r\n* Can we add tests with more complex key types (e.g. string or list)?",
        "pr_file_module": null
      },
      {
        "comment_id": "1660669185",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 12430,
        "pr_file": "test/sql/cte/recursive_cte_key_variant.test",
        "discussion_id": "1647349373",
        "commented_code": "@@ -0,0 +1,195 @@\n+# name: test/sql/cte/recursive_cte_key_variant.test\n+# description: Recursive CTEs with an error thrown in the pipelines\n+# group: [cte]\n+\n+statement ok\n+PRAGMA enable_verification;\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (2,2,5)) UNION SELECT a+1, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+2\t3\t3\n+3\t4\t3\n+4\t4\t5\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (b) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,2)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,2)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t4\t3\n+2\t4\t2\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a,b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (2,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+2\t3\t3\n+1\t3\t3\n+2\t4\t3\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT * FROM (VALUES (1, 2, 3), (1,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t4\t3\n+\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a,b,c) AS (SELECT * FROM (VALUES (1, 2, 3), (1,3,3)) UNION SELECT a, b+1, c FROM tbl WHERE b < 4) SELECT * FROM  tbl;\n+----\n+1\t2\t3\n+1\t3\t3\n+1\t4\t3\n+\n+# Reference the recurring table more than once\n+query III\n+WITH RECURSIVE tbl(a,b,c) USING KEY (a) AS (SELECT 1, NULL, NULL UNION SELECT tbl.a+1, rec1.a, rec2.b FROM tbl, recurring_tbl AS rec1, recurring_tbl AS rec2 WHERE tbl.a < 5) SELECT * FROM tbl;\n+----\n+1\tNULL\tNULL\n+2\t1\tNULL\n+3\t2\t1\n+4\t3\t2\n+5\t4\t3\n+\n+\n+#######################\n+# Connected components\n+#######################\n+statement ok\n+CREATE OR REPLACE TABLE nodes (node int);\n+\n+statement ok\n+INSERT INTO nodes VALUES (0), (1), (2), (3), (4), (5), (6);\n+\n+statement ok\n+CREATE OR REPLACE TABLE edges (here int, there int);\n+\n+statement ok\n+INSERT INTO edges VALUES  (0,4), (4,0),\n+\t\t\t\t\t\t  (0,3), (3,0),\n+\t\t\t\t\t\t  (1,4), (4,1),\n+\t\t\t\t\t\t  (3,4), (4,3),\n+\t\t\t\t\t\t  (2,5), (5,2);\n+\n+\n+\n+query II\n+WITH RECURSIVE cc(node, comp) USING KEY (node) AS (\n+\tSELECT n.node, n.node AS comp\n+\tFROM nodes AS n\n+\t\tUNION\n+\t(SELECT DISTINCT ON (u.node) u.node, v.comp\n+\tFROM recurring_cc AS u, cc AS v, edges AS e\n+\tWHERE (e.here, e.there) = (u.node, v.node)\n+\tAND v.comp < u.comp\n+\tORDER BY u.node asc, v.comp asc)\n+)\n+TABLE cc ORDER BY node;\n+----\n+0\t0\n+1\t0\n+2\t2\n+3\t0\n+4\t0\n+5\t2\n+6\t6\n+\n+#######################\n+# bellman-ford\n+#######################\n+statement ok\n+CREATE OR REPLACE TABLE edges (here   char(2), -- source node\n+  \t\t\t\t\t\t\t   there  char(2), -- target node\n+  \t\t\t\t\t\t\t   length int,  -- edge weight\n+  \t\t\t\t\t\t\t   PRIMARY KEY (here, there));\n+\n+statement ok\n+INSERT INTO edges(here, there, length) VALUES\n+  ('v0', 'v1', 9),\n+  ('v0', 'v2', 3),\n+  ('v1', 'v2', 6),\n+  ('v1', 'v4', 2),\n+  ('v2', 'v1', 2),\n+  ('v2', 'v3', 1),\n+  ('v3', 'v2', 2),\n+  ('v3', 'v4', 2);\n+\n+statement ok\n+DROP TABLE nodes;\n+\n+statement ok\n+CREATE OR REPLACE VIEW nodes(node) AS\n+  SELECT e.here\n+  FROM   edges AS e\n+   UNION\n+  SELECT e.there\n+  FROM   edges AS e;\n+\n+query II\n+WITH RECURSIVE bellman(knode, distance) USING KEY (knode) AS (\n+  -- distance is 0 from source, \u221e from any other node\n+  SELECT n.node AS knode,\n+         CASE WHEN n.node = 'v0' THEN 0 ELSE 50000000 END AS distance\n+  FROM   nodes AS n\n+  UNION\n+  (SELECT rec.knode AS knode, n.distance + e.length AS distance\n+  FROM   bellman AS n, edges AS e, recurring_bellman AS rec\n+  WHERE  (e.here, e.there) = (n.knode, rec.knode)\n+  AND    rec.distance > n.distance + e.length\n+  ORDER BY distance DESC)\n+)\n+SELECT n.knode || CASE WHEN n.knode = 'v0' THEN ' (source)' ELSE '' END AS node,\n+       n.distance\n+FROM   bellman AS n\n+ORDER BY n.knode;\n+----\n+v0 (source)\t0\n+v1\t5\n+v2\t3\n+v3\t4\n+v4\t6\n+\n+\n+# more rows than STANDARD_CHUNK_SIZE\n+query I\n+WITH RECURSIVE tbl(n) USING KEY (n) AS (SELECT 1 UNION SELECT n+1 FROM tbl WHERE n < 3000) SELECT SUM(n) FROM tbl\n+----\n+4501500\n+\n+# You can use recursive CTE with and without a key in a query.\n+query II\n+WITH RECURSIVE tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3), tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3) SELECT * FROM tbl;\n+----\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3), tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3) SELECT * FROM tbl2;\n+----\n+1\t1\n+1\t2\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3), tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3) SELECT * FROM tbl2;\n+----\n+1\t1\n+1\t2\n+1\t3\n+\n+query II\n+WITH RECURSIVE tbl2(a,b) AS (SELECT 1, 1 UNION SELECT a, b+1 FROM tbl2 WHERE b < 3), tbl (a, b) USING KEY (a) AS (SELECT 1 , 1 UNION SELECT a, b+1 FROM tbl WHERE b < 3) SELECT * FROM tbl;",
        "comment_created_at": "2024-07-01T08:28:06+00:00",
        "comment_author": "cryoEncryp",
        "comment_body": "I will write more test, when the syntax is determined. :+1:",
        "pr_file_module": null
      }
    ]
  }
]