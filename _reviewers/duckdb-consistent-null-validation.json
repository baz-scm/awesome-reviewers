[
  {
    "discussion_id": "2240161723",
    "pr_number": 18410,
    "pr_file": "src/common/types.cpp",
    "created_at": "2025-07-29T15:05:28+00:00",
    "commented_code": "return LogicalType(LogicalTypeId::INTEGER_LITERAL, std::move(type_info));\n }\n \n+//===--------------------------------------------------------------------===//\n+// Template Type\n+//===--------------------------------------------------------------------===//\n+LogicalType LogicalType::TEMPLATE() {\n+\treturn LogicalType::TEMPLATE(\"T\"); // Default template type name\n+}\n+LogicalType LogicalType::TEMPLATE(const string &name) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2240161723",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18410,
        "pr_file": "src/common/types.cpp",
        "discussion_id": "2240161723",
        "commented_code": "@@ -1934,6 +1947,24 @@ LogicalType LogicalType::INTEGER_LITERAL(const Value &constant) { // NOLINT\n \treturn LogicalType(LogicalTypeId::INTEGER_LITERAL, std::move(type_info));\n }\n \n+//===--------------------------------------------------------------------===//\n+// Template Type\n+//===--------------------------------------------------------------------===//\n+LogicalType LogicalType::TEMPLATE() {\n+\treturn LogicalType::TEMPLATE(\"T\"); // Default template type name\n+}\n+LogicalType LogicalType::TEMPLATE(const string &name) {",
        "comment_created_at": "2025-07-29T15:05:28+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "Maybe `D_ASSERT(!name.empty())`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2210201483",
    "pr_number": 18246,
    "pr_file": "src/main/capi/arrow-c.cpp",
    "created_at": "2025-07-16T12:14:29+00:00",
    "commented_code": "}\n \n duckdb_error_data duckdb_data_chunk_to_arrow(duckdb_client_properties client_properties, duckdb_data_chunk chunk,\n-                                             duckdb_arrow_array *out_arrow_array) {\n-\tif (!client_properties || !out_arrow_array || !chunk) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2210201483",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18246,
        "pr_file": "src/main/capi/arrow-c.cpp",
        "discussion_id": "2210201483",
        "commented_code": "@@ -43,8 +42,8 @@ duckdb_error_data duckdb_to_arrow_schema(duckdb_client_properties client_propert\n }\n \n duckdb_error_data duckdb_data_chunk_to_arrow(duckdb_client_properties client_properties, duckdb_data_chunk chunk,\n-                                             duckdb_arrow_array *out_arrow_array) {\n-\tif (!client_properties || !out_arrow_array || !chunk) {",
        "comment_created_at": "2025-07-16T12:14:29+00:00",
        "comment_author": "Tishj",
        "comment_body": "`!out_arrow_array` still needs to be checked",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2192992348",
    "pr_number": 18187,
    "pr_file": "extension/parquet/reader/variant/variant_binary_decoder.cpp",
    "created_at": "2025-07-08T16:45:59+00:00",
    "commented_code": "+#include \"reader/variant/variant_binary_decoder.hpp\"\n+#include \"duckdb/common/printer.hpp\"\n+#include \"utf8proc_wrapper.hpp\"\n+\n+#include \"reader/uuid_column_reader.hpp\"\n+\n+#include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/common/types/decimal.hpp\"\n+#include \"duckdb/common/types/uuid.hpp\"\n+#include \"duckdb/common/types/time.hpp\"\n+#include \"duckdb/common/types/date.hpp\"\n+\n+static constexpr uint8_t VERSION_MASK = 0xF;\n+static constexpr uint8_t SORTED_STRINGS_MASK = 0x1;\n+static constexpr uint8_t SORTED_STRINGS_SHIFT = 4;\n+static constexpr uint8_t OFFSET_SIZE_MINUS_ONE_MASK = 0x3;\n+static constexpr uint8_t OFFSET_SIZE_MINUS_ONE_SHIFT = 5;\n+\n+static constexpr uint8_t BASIC_TYPE_MASK = 0x3;\n+static constexpr uint8_t VALUE_HEADER_SHIFT = 2;\n+\n+//! Object and Array header\n+static constexpr uint8_t FIELD_OFFSET_SIZE_MINUS_ONE_MASK = 0x3;\n+\n+//! Object header\n+static constexpr uint8_t FIELD_ID_SIZE_MINUS_ONE_MASK = 0x3;\n+static constexpr uint8_t FIELD_ID_SIZE_MINUS_ONE_SHIFT = 2;\n+\n+static constexpr uint8_t OBJECT_IS_LARGE_MASK = 0x1;\n+static constexpr uint8_t OBJECT_IS_LARGE_SHIFT = 4;\n+\n+//! Array header\n+static constexpr uint8_t ARRAY_IS_LARGE_MASK = 0x1;\n+static constexpr uint8_t ARRAY_IS_LARGE_SHIFT = 2;\n+\n+using namespace duckdb_yyjson;\n+\n+namespace duckdb {\n+\n+namespace {\n+\n+static idx_t ReadVariableLengthLittleEndian(idx_t length_in_bytes, const_data_ptr_t &ptr) {\n+\tif (length_in_bytes > sizeof(idx_t)) {\n+\t\tthrow NotImplementedException(\"Can't read little-endian value of %d bytes\", length_in_bytes);\n+\t}\n+\tidx_t result = 0;\n+\tmemcpy(reinterpret_cast<uint8_t *>(&result), ptr, length_in_bytes);\n+\tptr += length_in_bytes;\n+\treturn result;\n+}\n+\n+} // namespace\n+\n+VariantMetadataHeader VariantMetadataHeader::FromHeaderByte(uint8_t byte) {\n+\tVariantMetadataHeader header;\n+\theader.version = byte & VERSION_MASK;\n+\theader.sorted_strings = (byte >> SORTED_STRINGS_SHIFT) & SORTED_STRINGS_MASK;\n+\theader.offset_size = ((byte >> OFFSET_SIZE_MINUS_ONE_SHIFT) & OFFSET_SIZE_MINUS_ONE_MASK) + 1;\n+\n+\tif (header.version != 1) {\n+\t\tthrow NotImplementedException(\"Only version 1 of the Variant encoding scheme is supported, found version: %d\",\n+\t\t                              header.version);\n+\t}\n+\n+\treturn header;\n+}\n+\n+VariantMetadata::VariantMetadata(const string_t &metadata) : metadata(metadata) {\n+\tauto metadata_data = metadata.GetData();\n+\n+\theader = VariantMetadataHeader::FromHeaderByte(metadata_data[0]);\n+\n+\tconst_data_ptr_t ptr = reinterpret_cast<const_data_ptr_t>(metadata_data + sizeof(uint8_t));\n+\tidx_t dictionary_size = ReadVariableLengthLittleEndian(header.offset_size, ptr);\n+\n+\toffsets = ptr;\n+\tbytes = offsets + ((dictionary_size + 1) * header.offset_size);\n+\tidx_t last_offset = ReadVariableLengthLittleEndian(header.offset_size, ptr);\n+\tfor (idx_t i = 0; i < dictionary_size; i++) {\n+\t\tauto next_offset = ReadVariableLengthLittleEndian(header.offset_size, ptr);\n+\t\tstrings.emplace_back(reinterpret_cast<const char *>(bytes + last_offset), next_offset - last_offset);\n+\t\tlast_offset = next_offset;\n+\t}\n+}\n+\n+VariantValueMetadata VariantValueMetadata::FromHeaderByte(uint8_t byte) {\n+\tVariantValueMetadata result;\n+\tresult.basic_type = VariantBasicTypeFromByte(byte & BASIC_TYPE_MASK);\n+\tuint8_t value_header = byte >> VALUE_HEADER_SHIFT;\n+\tswitch (result.basic_type) {\n+\tcase VariantBasicType::PRIMITIVE: {\n+\t\tresult.primitive_type = VariantPrimitiveTypeFromByte(value_header);\n+\t\tbreak;\n+\t}\n+\tcase VariantBasicType::SHORT_STRING: {\n+\t\tresult.string_size = value_header;\n+\t\tbreak;\n+\t}\n+\tcase VariantBasicType::OBJECT: {\n+\t\tresult.field_offset_size = (value_header & FIELD_OFFSET_SIZE_MINUS_ONE_MASK) + 1;\n+\t\tresult.field_id_size = ((value_header >> FIELD_ID_SIZE_MINUS_ONE_SHIFT) & FIELD_ID_SIZE_MINUS_ONE_MASK) + 1;\n+\t\tresult.is_large = (value_header >> OBJECT_IS_LARGE_SHIFT) & OBJECT_IS_LARGE_MASK;\n+\t\tbreak;\n+\t}\n+\tcase VariantBasicType::ARRAY: {\n+\t\tresult.field_offset_size = (value_header & FIELD_OFFSET_SIZE_MINUS_ONE_MASK) + 1;\n+\t\tresult.is_large = (value_header >> ARRAY_IS_LARGE_SHIFT) & ARRAY_IS_LARGE_MASK;\n+\t\tbreak;\n+\t}\n+\t}\n+\treturn result;\n+}\n+\n+VariantBinaryDecoder::VariantBinaryDecoder() {\n+}\n+\n+template <class T>\n+static T DecodeDecimal(const_data_ptr_t data, uint8_t &scale, uint8_t &width) {\n+\tscale = Load<uint8_t>(data);\n+\tdata++;\n+\n+\tauto result = Load<T>(data);\n+\t//! FIXME: The spec says:\n+\t//! The implied precision of a decimal value is `floor(log_10(val)) + 1`\n+\twidth = DecimalWidth<T>::max;\n+\treturn result;\n+}\n+\n+template <>\n+hugeint_t DecodeDecimal(const_data_ptr_t data, uint8_t &scale, uint8_t &width) {\n+\tscale = Load<uint8_t>(data);\n+\tdata++;\n+\n+\thugeint_t result;\n+\tresult.lower = Load<uint64_t>(data);\n+\tresult.upper = Load<int64_t>(data + sizeof(uint64_t));\n+\t//! FIXME: The spec says:\n+\t//! The implied precision of a decimal value is `floor(log_10(val)) + 1`\n+\twidth = DecimalWidth<hugeint_t>::max;\n+\treturn result;\n+}\n+\n+yyjson_mut_val *VariantBinaryDecoder::PrimitiveTypeDecode(yyjson_mut_doc *doc, const VariantMetadata &metadata,\n+                                                          const VariantValueMetadata &value_metadata,\n+                                                          const_data_ptr_t data) {\n+\tswitch (value_metadata.primitive_type) {\n+\tcase VariantPrimitiveType::NULL_TYPE: {\n+\t\treturn yyjson_mut_null(doc);\n+\t}\n+\tcase VariantPrimitiveType::BOOLEAN_TRUE: {\n+\t\treturn yyjson_mut_true(doc);\n+\t}\n+\tcase VariantPrimitiveType::BOOLEAN_FALSE: {\n+\t\treturn yyjson_mut_false(doc);\n+\t}\n+\tcase VariantPrimitiveType::INT8: {\n+\t\tauto value = Load<int8_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::INT16: {\n+\t\tauto value = Load<int16_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::INT32: {\n+\t\tauto value = Load<int32_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::INT64: {\n+\t\tauto value = Load<int64_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::DOUBLE: {\n+\t\tdouble value;\n+\t\tmemcpy(&value, data, sizeof(double));\n+\t\treturn yyjson_mut_real(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::DECIMAL4: {\n+\t\tuint8_t scale;\n+\t\tuint8_t width;\n+\n+\t\tauto value = DecodeDecimal<int32_t>(data, scale, width);\n+\t\tauto value_str = Decimal::ToString(value, width, scale);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::DECIMAL8: {\n+\t\tuint8_t scale;\n+\t\tuint8_t width;\n+\n+\t\tauto value = DecodeDecimal<int64_t>(data, scale, width);\n+\t\tauto value_str = Decimal::ToString(value, width, scale);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::DECIMAL16: {\n+\t\tuint8_t scale;\n+\t\tuint8_t width;\n+\n+\t\tauto value = DecodeDecimal<hugeint_t>(data, scale, width);\n+\t\tauto value_str = Decimal::ToString(value, width, scale);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::DATE: {\n+\t\tdate_t value;\n+\t\tvalue.days = Load<int32_t>(data);\n+\t\tauto value_str = Date::ToString(value);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::TIMESTAMP_MICROS: {\n+\t\ttimestamp_tz_t micros_tz_ts;\n+\t\tmicros_tz_ts.value = Load<int64_t>(data);\n+\n+\t\tauto value = Value::TIMESTAMPTZ(micros_tz_ts);\n+\t\tauto value_str = value.ToString();\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::TIMESTAMP_NTZ_MICROS: {\n+\t\ttimestamp_t micros_ts;\n+\t\tmicros_ts.value = Load<int64_t>(data);\n+\n+\t\tauto value = Value::TIMESTAMP(micros_ts);\n+\t\tauto value_str = value.ToString();\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::FLOAT: {\n+\t\tfloat value;\n+\t\tmemcpy(&value, data, sizeof(float));\n+\t\treturn yyjson_mut_real(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::BINARY:\n+\tcase VariantPrimitiveType::STRING: {\n+\t\tauto size = Load<uint32_t>(data);\n+\t\tauto string_data = reinterpret_cast<const char *>(data + sizeof(uint32_t));\n+\t\treturn yyjson_mut_strncpy(doc, string_data, size);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2192992348",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18187,
        "pr_file": "extension/parquet/reader/variant/variant_binary_decoder.cpp",
        "discussion_id": "2192992348",
        "commented_code": "@@ -0,0 +1,360 @@\n+#include \"reader/variant/variant_binary_decoder.hpp\"\n+#include \"duckdb/common/printer.hpp\"\n+#include \"utf8proc_wrapper.hpp\"\n+\n+#include \"reader/uuid_column_reader.hpp\"\n+\n+#include \"duckdb/common/types/timestamp.hpp\"\n+#include \"duckdb/common/types/decimal.hpp\"\n+#include \"duckdb/common/types/uuid.hpp\"\n+#include \"duckdb/common/types/time.hpp\"\n+#include \"duckdb/common/types/date.hpp\"\n+\n+static constexpr uint8_t VERSION_MASK = 0xF;\n+static constexpr uint8_t SORTED_STRINGS_MASK = 0x1;\n+static constexpr uint8_t SORTED_STRINGS_SHIFT = 4;\n+static constexpr uint8_t OFFSET_SIZE_MINUS_ONE_MASK = 0x3;\n+static constexpr uint8_t OFFSET_SIZE_MINUS_ONE_SHIFT = 5;\n+\n+static constexpr uint8_t BASIC_TYPE_MASK = 0x3;\n+static constexpr uint8_t VALUE_HEADER_SHIFT = 2;\n+\n+//! Object and Array header\n+static constexpr uint8_t FIELD_OFFSET_SIZE_MINUS_ONE_MASK = 0x3;\n+\n+//! Object header\n+static constexpr uint8_t FIELD_ID_SIZE_MINUS_ONE_MASK = 0x3;\n+static constexpr uint8_t FIELD_ID_SIZE_MINUS_ONE_SHIFT = 2;\n+\n+static constexpr uint8_t OBJECT_IS_LARGE_MASK = 0x1;\n+static constexpr uint8_t OBJECT_IS_LARGE_SHIFT = 4;\n+\n+//! Array header\n+static constexpr uint8_t ARRAY_IS_LARGE_MASK = 0x1;\n+static constexpr uint8_t ARRAY_IS_LARGE_SHIFT = 2;\n+\n+using namespace duckdb_yyjson;\n+\n+namespace duckdb {\n+\n+namespace {\n+\n+static idx_t ReadVariableLengthLittleEndian(idx_t length_in_bytes, const_data_ptr_t &ptr) {\n+\tif (length_in_bytes > sizeof(idx_t)) {\n+\t\tthrow NotImplementedException(\"Can't read little-endian value of %d bytes\", length_in_bytes);\n+\t}\n+\tidx_t result = 0;\n+\tmemcpy(reinterpret_cast<uint8_t *>(&result), ptr, length_in_bytes);\n+\tptr += length_in_bytes;\n+\treturn result;\n+}\n+\n+} // namespace\n+\n+VariantMetadataHeader VariantMetadataHeader::FromHeaderByte(uint8_t byte) {\n+\tVariantMetadataHeader header;\n+\theader.version = byte & VERSION_MASK;\n+\theader.sorted_strings = (byte >> SORTED_STRINGS_SHIFT) & SORTED_STRINGS_MASK;\n+\theader.offset_size = ((byte >> OFFSET_SIZE_MINUS_ONE_SHIFT) & OFFSET_SIZE_MINUS_ONE_MASK) + 1;\n+\n+\tif (header.version != 1) {\n+\t\tthrow NotImplementedException(\"Only version 1 of the Variant encoding scheme is supported, found version: %d\",\n+\t\t                              header.version);\n+\t}\n+\n+\treturn header;\n+}\n+\n+VariantMetadata::VariantMetadata(const string_t &metadata) : metadata(metadata) {\n+\tauto metadata_data = metadata.GetData();\n+\n+\theader = VariantMetadataHeader::FromHeaderByte(metadata_data[0]);\n+\n+\tconst_data_ptr_t ptr = reinterpret_cast<const_data_ptr_t>(metadata_data + sizeof(uint8_t));\n+\tidx_t dictionary_size = ReadVariableLengthLittleEndian(header.offset_size, ptr);\n+\n+\toffsets = ptr;\n+\tbytes = offsets + ((dictionary_size + 1) * header.offset_size);\n+\tidx_t last_offset = ReadVariableLengthLittleEndian(header.offset_size, ptr);\n+\tfor (idx_t i = 0; i < dictionary_size; i++) {\n+\t\tauto next_offset = ReadVariableLengthLittleEndian(header.offset_size, ptr);\n+\t\tstrings.emplace_back(reinterpret_cast<const char *>(bytes + last_offset), next_offset - last_offset);\n+\t\tlast_offset = next_offset;\n+\t}\n+}\n+\n+VariantValueMetadata VariantValueMetadata::FromHeaderByte(uint8_t byte) {\n+\tVariantValueMetadata result;\n+\tresult.basic_type = VariantBasicTypeFromByte(byte & BASIC_TYPE_MASK);\n+\tuint8_t value_header = byte >> VALUE_HEADER_SHIFT;\n+\tswitch (result.basic_type) {\n+\tcase VariantBasicType::PRIMITIVE: {\n+\t\tresult.primitive_type = VariantPrimitiveTypeFromByte(value_header);\n+\t\tbreak;\n+\t}\n+\tcase VariantBasicType::SHORT_STRING: {\n+\t\tresult.string_size = value_header;\n+\t\tbreak;\n+\t}\n+\tcase VariantBasicType::OBJECT: {\n+\t\tresult.field_offset_size = (value_header & FIELD_OFFSET_SIZE_MINUS_ONE_MASK) + 1;\n+\t\tresult.field_id_size = ((value_header >> FIELD_ID_SIZE_MINUS_ONE_SHIFT) & FIELD_ID_SIZE_MINUS_ONE_MASK) + 1;\n+\t\tresult.is_large = (value_header >> OBJECT_IS_LARGE_SHIFT) & OBJECT_IS_LARGE_MASK;\n+\t\tbreak;\n+\t}\n+\tcase VariantBasicType::ARRAY: {\n+\t\tresult.field_offset_size = (value_header & FIELD_OFFSET_SIZE_MINUS_ONE_MASK) + 1;\n+\t\tresult.is_large = (value_header >> ARRAY_IS_LARGE_SHIFT) & ARRAY_IS_LARGE_MASK;\n+\t\tbreak;\n+\t}\n+\t}\n+\treturn result;\n+}\n+\n+VariantBinaryDecoder::VariantBinaryDecoder() {\n+}\n+\n+template <class T>\n+static T DecodeDecimal(const_data_ptr_t data, uint8_t &scale, uint8_t &width) {\n+\tscale = Load<uint8_t>(data);\n+\tdata++;\n+\n+\tauto result = Load<T>(data);\n+\t//! FIXME: The spec says:\n+\t//! The implied precision of a decimal value is `floor(log_10(val)) + 1`\n+\twidth = DecimalWidth<T>::max;\n+\treturn result;\n+}\n+\n+template <>\n+hugeint_t DecodeDecimal(const_data_ptr_t data, uint8_t &scale, uint8_t &width) {\n+\tscale = Load<uint8_t>(data);\n+\tdata++;\n+\n+\thugeint_t result;\n+\tresult.lower = Load<uint64_t>(data);\n+\tresult.upper = Load<int64_t>(data + sizeof(uint64_t));\n+\t//! FIXME: The spec says:\n+\t//! The implied precision of a decimal value is `floor(log_10(val)) + 1`\n+\twidth = DecimalWidth<hugeint_t>::max;\n+\treturn result;\n+}\n+\n+yyjson_mut_val *VariantBinaryDecoder::PrimitiveTypeDecode(yyjson_mut_doc *doc, const VariantMetadata &metadata,\n+                                                          const VariantValueMetadata &value_metadata,\n+                                                          const_data_ptr_t data) {\n+\tswitch (value_metadata.primitive_type) {\n+\tcase VariantPrimitiveType::NULL_TYPE: {\n+\t\treturn yyjson_mut_null(doc);\n+\t}\n+\tcase VariantPrimitiveType::BOOLEAN_TRUE: {\n+\t\treturn yyjson_mut_true(doc);\n+\t}\n+\tcase VariantPrimitiveType::BOOLEAN_FALSE: {\n+\t\treturn yyjson_mut_false(doc);\n+\t}\n+\tcase VariantPrimitiveType::INT8: {\n+\t\tauto value = Load<int8_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::INT16: {\n+\t\tauto value = Load<int16_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::INT32: {\n+\t\tauto value = Load<int32_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::INT64: {\n+\t\tauto value = Load<int64_t>(data);\n+\t\treturn yyjson_mut_int(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::DOUBLE: {\n+\t\tdouble value;\n+\t\tmemcpy(&value, data, sizeof(double));\n+\t\treturn yyjson_mut_real(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::DECIMAL4: {\n+\t\tuint8_t scale;\n+\t\tuint8_t width;\n+\n+\t\tauto value = DecodeDecimal<int32_t>(data, scale, width);\n+\t\tauto value_str = Decimal::ToString(value, width, scale);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::DECIMAL8: {\n+\t\tuint8_t scale;\n+\t\tuint8_t width;\n+\n+\t\tauto value = DecodeDecimal<int64_t>(data, scale, width);\n+\t\tauto value_str = Decimal::ToString(value, width, scale);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::DECIMAL16: {\n+\t\tuint8_t scale;\n+\t\tuint8_t width;\n+\n+\t\tauto value = DecodeDecimal<hugeint_t>(data, scale, width);\n+\t\tauto value_str = Decimal::ToString(value, width, scale);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::DATE: {\n+\t\tdate_t value;\n+\t\tvalue.days = Load<int32_t>(data);\n+\t\tauto value_str = Date::ToString(value);\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::TIMESTAMP_MICROS: {\n+\t\ttimestamp_tz_t micros_tz_ts;\n+\t\tmicros_tz_ts.value = Load<int64_t>(data);\n+\n+\t\tauto value = Value::TIMESTAMPTZ(micros_tz_ts);\n+\t\tauto value_str = value.ToString();\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::TIMESTAMP_NTZ_MICROS: {\n+\t\ttimestamp_t micros_ts;\n+\t\tmicros_ts.value = Load<int64_t>(data);\n+\n+\t\tauto value = Value::TIMESTAMP(micros_ts);\n+\t\tauto value_str = value.ToString();\n+\t\treturn yyjson_mut_strcpy(doc, value_str.c_str());\n+\t}\n+\tcase VariantPrimitiveType::FLOAT: {\n+\t\tfloat value;\n+\t\tmemcpy(&value, data, sizeof(float));\n+\t\treturn yyjson_mut_real(doc, value);\n+\t}\n+\tcase VariantPrimitiveType::BINARY:\n+\tcase VariantPrimitiveType::STRING: {\n+\t\tauto size = Load<uint32_t>(data);\n+\t\tauto string_data = reinterpret_cast<const char *>(data + sizeof(uint32_t));\n+\t\treturn yyjson_mut_strncpy(doc, string_data, size);",
        "comment_created_at": "2025-07-08T16:45:59+00:00",
        "comment_author": "Tishj",
        "comment_body": "`STRING` is only allowed to have UTF8 values, so we should probably verify that here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2084111187",
    "pr_number": 17437,
    "pr_file": "extension/json/json_functions/json_create.cpp",
    "created_at": "2025-05-12T08:24:39+00:00",
    "commented_code": "template <class INPUT_TYPE>\n struct CreateJSONValue<INPUT_TYPE, double> {\n \tstatic inline yyjson_mut_val *Operation(yyjson_mut_doc *doc, const INPUT_TYPE &input) {\n+\t\tif (Value::IsNan(input) || !std::isfinite(input)) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2084111187",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17437,
        "pr_file": "extension/json/json_functions/json_create.cpp",
        "discussion_id": "2084111187",
        "commented_code": "@@ -207,6 +207,9 @@ struct CreateJSONValue<INPUT_TYPE, int64_t> {\n template <class INPUT_TYPE>\n struct CreateJSONValue<INPUT_TYPE, double> {\n \tstatic inline yyjson_mut_val *Operation(yyjson_mut_doc *doc, const INPUT_TYPE &input) {\n+\t\tif (Value::IsNan(input) || !std::isfinite(input)) {",
        "comment_created_at": "2025-05-12T08:24:39+00:00",
        "comment_author": "lnkuiper",
        "comment_body": "Can you change this to `Value::IsFinite`? This checks for both `inf` and `nan` at the same time.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1983267690",
    "pr_number": 16471,
    "pr_file": "src/main/capi/duckdb_value-c.cpp",
    "created_at": "2025-03-06T12:27:56+00:00",
    "commented_code": "return WrapValue(new duckdb::Value(children[index]));\n }\n+\n+char *duckdb_to_sql_string(duckdb_value val) {\n+\tauto v = UnwrapValue(val);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1983267690",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16471,
        "pr_file": "src/main/capi/duckdb_value-c.cpp",
        "discussion_id": "1983267690",
        "commented_code": "@@ -537,3 +537,13 @@ duckdb_value duckdb_get_struct_child(duckdb_value value, idx_t index) {\n \n \treturn WrapValue(new duckdb::Value(children[index]));\n }\n+\n+char *duckdb_to_sql_string(duckdb_value val) {\n+\tauto v = UnwrapValue(val);",
        "comment_created_at": "2025-03-06T12:27:56+00:00",
        "comment_author": "Mytherin",
        "comment_body": "In other functions we check for `NULL` - could we do that here as well?",
        "pr_file_module": null
      }
    ]
  }
]