[
  {
    "discussion_id": "2276382865",
    "pr_number": 18518,
    "pr_file": "src/include/duckdb/common/file_system.hpp",
    "created_at": "2025-08-14T11:39:26+00:00",
    "commented_code": "namespace duckdb {\n \n+// Forward declarations\n+class Expression;\n+struct MultiFileOptions;\n+struct MultiFilePushdownInfo;\n+\n+//! Wrapper struct for hive filtering parameters passed to Glob\n+struct HiveFilterParams {\n+\tClientContext &context;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2276382865",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18518,
        "pr_file": "src/include/duckdb/common/file_system.hpp",
        "discussion_id": "2276382865",
        "commented_code": "@@ -28,6 +28,24 @@\n \n namespace duckdb {\n \n+// Forward declarations\n+class Expression;\n+struct MultiFileOptions;\n+struct MultiFilePushdownInfo;\n+\n+//! Wrapper struct for hive filtering parameters passed to Glob\n+struct HiveFilterParams {\n+\tClientContext &context;",
        "comment_created_at": "2025-08-14T11:39:26+00:00",
        "comment_author": "samansmink",
        "comment_body": "I believe this is unused? Also adding context references like this is something that should be done with care, as its pretty error-prone",
        "pr_file_module": null
      },
      {
        "comment_id": "2276387356",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18518,
        "pr_file": "src/include/duckdb/common/file_system.hpp",
        "discussion_id": "2276382865",
        "commented_code": "@@ -28,6 +28,24 @@\n \n namespace duckdb {\n \n+// Forward declarations\n+class Expression;\n+struct MultiFileOptions;\n+struct MultiFilePushdownInfo;\n+\n+//! Wrapper struct for hive filtering parameters passed to Glob\n+struct HiveFilterParams {\n+\tClientContext &context;",
        "comment_created_at": "2025-08-14T11:41:43+00:00",
        "comment_author": "samansmink",
        "comment_body": "Related: https://github.com/duckdb/duckdb/pull/18514 is currently going through the effort of routing the clientcontext through more filesystem functions. Maybe it's interesting to take a look there and see if that can be leveraged if you need contexts available",
        "pr_file_module": null
      },
      {
        "comment_id": "2277630181",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18518,
        "pr_file": "src/include/duckdb/common/file_system.hpp",
        "discussion_id": "2276382865",
        "commented_code": "@@ -28,6 +28,24 @@\n \n namespace duckdb {\n \n+// Forward declarations\n+class Expression;\n+struct MultiFileOptions;\n+struct MultiFilePushdownInfo;\n+\n+//! Wrapper struct for hive filtering parameters passed to Glob\n+struct HiveFilterParams {\n+\tClientContext &context;",
        "comment_created_at": "2025-08-14T20:12:36+00:00",
        "comment_author": "xevix",
        "comment_body": "The context gets used in functions called by `HivePartitioning::ApplyFiltersToFile` to do things like casting Values.\r\n\r\nNice, once that gets merged in could look at using that instead.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2242364219",
    "pr_number": 18438,
    "pr_file": "extension/parquet/include/thrift_tools.hpp",
    "created_at": "2025-07-30T11:46:15+00:00",
    "commented_code": "if (read_head.GetEnd() > file_handle.GetFileSize()) {\n \t\t\t\tthrow std::runtime_error(\"Prefetch registered requested for bytes outside file\");\n \t\t\t}\n-\t\t\tread_head.buffer_handle = file_handle.Read(read_head.buffer_ptr, read_head.size, read_head.location);\n+\t\t\tread_head.buffer_handle =\n+\t\t\t    file_handle.Read(QueryContext(), read_head.buffer_ptr, read_head.size, read_head.location);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2242364219",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18438,
        "pr_file": "extension/parquet/include/thrift_tools.hpp",
        "discussion_id": "2242364219",
        "commented_code": "@@ -118,7 +118,8 @@ struct ReadAheadBuffer {\n \t\t\tif (read_head.GetEnd() > file_handle.GetFileSize()) {\n \t\t\t\tthrow std::runtime_error(\"Prefetch registered requested for bytes outside file\");\n \t\t\t}\n-\t\t\tread_head.buffer_handle = file_handle.Read(read_head.buffer_ptr, read_head.size, read_head.location);\n+\t\t\tread_head.buffer_handle =\n+\t\t\t    file_handle.Read(QueryContext(), read_head.buffer_ptr, read_head.size, read_head.location);",
        "comment_created_at": "2025-07-30T11:46:15+00:00",
        "comment_author": "Mytherin",
        "comment_body": "We should be able to pass a `ClientContext` into the constructor of the `ThriftFileTransport` and use that here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2221431732",
    "pr_number": 18221,
    "pr_file": "extension/autocomplete/include/keyword_helper.hpp",
    "created_at": "2025-07-22T07:02:11+00:00",
    "commented_code": "+#pragma once\n+\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/common/string.hpp\"\n+\n+namespace duckdb {\n+enum class KeywordCategory : uint8_t {\n+\tKEYWORD_NONE,\n+\tKEYWORD_UNRESERVED,\n+\tKEYWORD_RESERVED,\n+\tKEYWORD_TYPE_FUNC,\n+\tKEYWORD_COL_NAME\n+};\n+\n+class KeywordHelper {\n+public:\n+\tstatic KeywordHelper &Instance();\n+\tbool KeywordCategoryType(const string &text, KeywordCategory type) const;\n+\tvoid InitializeKeywordMaps();\n+\n+private:\n+\tKeywordHelper();\n+\tbool initialized;\n+\tcase_insensitive_set_t reserved_keyword_map;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2221431732",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18221,
        "pr_file": "extension/autocomplete/include/keyword_helper.hpp",
        "discussion_id": "2221431732",
        "commented_code": "@@ -0,0 +1,29 @@\n+#pragma once\n+\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/common/string.hpp\"\n+\n+namespace duckdb {\n+enum class KeywordCategory : uint8_t {\n+\tKEYWORD_NONE,\n+\tKEYWORD_UNRESERVED,\n+\tKEYWORD_RESERVED,\n+\tKEYWORD_TYPE_FUNC,\n+\tKEYWORD_COL_NAME\n+};\n+\n+class KeywordHelper {\n+public:\n+\tstatic KeywordHelper &Instance();\n+\tbool KeywordCategoryType(const string &text, KeywordCategory type) const;\n+\tvoid InitializeKeywordMaps();\n+\n+private:\n+\tKeywordHelper();\n+\tbool initialized;\n+\tcase_insensitive_set_t reserved_keyword_map;",
        "comment_created_at": "2025-07-22T07:02:11+00:00",
        "comment_author": "Mytherin",
        "comment_body": "For now this is fine - but we can't use globals in the final design. Globals can't be extended by extensions. Extensions can be loaded per DuckDB instance - and different DuckDB instances can have a different set of extensions loaded. The current design will therefore prohibit extensions from registering additional keywords.\r\n\r\nI think this needs to live in the `DatabaseInstance` or `DBConfig` somehow in the future, i.e. similar to where the parser extensions currently live.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2137330918",
    "pr_number": 17275,
    "pr_file": "src/include/duckdb/storage/single_file_block_manager.hpp",
    "created_at": "2025-06-10T09:04:47+00:00",
    "commented_code": "FileOpenFlags GetFileFlags(bool create_new) const;\n \t//! Creates a new database.\n-\tvoid CreateNewDatabase(optional_ptr<ClientContext> context);\n+\tvoid CreateNewDatabase(optional_ptr<ClientContext> context, optional_ptr<string> encryption_key = nullptr);\n \t//! Loads an existing database. We pass the provided block allocation size as a parameter\n \t//! to detect inconsistencies with the file header.\n-\tvoid LoadExistingDatabase();\n+\tvoid LoadExistingDatabase(optional_ptr<string> encryption_key = nullptr);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2137330918",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17275,
        "pr_file": "src/include/duckdb/storage/single_file_block_manager.hpp",
        "discussion_id": "2137330918",
        "commented_code": "@@ -49,10 +61,10 @@ class SingleFileBlockManager : public BlockManager {\n \n \tFileOpenFlags GetFileFlags(bool create_new) const;\n \t//! Creates a new database.\n-\tvoid CreateNewDatabase(optional_ptr<ClientContext> context);\n+\tvoid CreateNewDatabase(optional_ptr<ClientContext> context, optional_ptr<string> encryption_key = nullptr);\n \t//! Loads an existing database. We pass the provided block allocation size as a parameter\n \t//! to detect inconsistencies with the file header.\n-\tvoid LoadExistingDatabase();\n+\tvoid LoadExistingDatabase(optional_ptr<string> encryption_key = nullptr);",
        "comment_created_at": "2025-06-10T09:04:47+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Should this be a `string`?\r\n\r\nI also wonder - do we need to pass this into these individual methods? Can't we pass it in using the `StorageManagerOptions` in the constructor?",
        "pr_file_module": null
      }
    ]
  }
]