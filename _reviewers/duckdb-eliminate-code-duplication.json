[
  {
    "discussion_id": "2259875020",
    "pr_number": 18319,
    "pr_file": "src/function/table/table_scan.cpp",
    "created_at": "2025-08-07T10:36:01+00:00",
    "commented_code": "return expressions;\n }\n \n+// Recursively updates column bindings in an index expression to match the current input projection,\n+// even if they are the child of a function or cast\n+void UpdateIndexExprColumnBindings(unique_ptr<Expression> &expr, const vector<column_t> &input_column_ids,\n+\t\t\t\t\t\t  \t\t   const vector<column_t> &indexed_columns) {\n+\tif (!expr) { return; }\n+\n+\tswitch (expr->GetExpressionClass()) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2259875020",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18319,
        "pr_file": "src/function/table/table_scan.cpp",
        "discussion_id": "2259875020",
        "commented_code": "@@ -484,6 +488,42 @@ vector<unique_ptr<Expression>> ExtractFilterExpressions(const ColumnDefinition &\n \treturn expressions;\n }\n \n+// Recursively updates column bindings in an index expression to match the current input projection,\n+// even if they are the child of a function or cast\n+void UpdateIndexExprColumnBindings(unique_ptr<Expression> &expr, const vector<column_t> &input_column_ids,\n+\t\t\t\t\t\t  \t\t   const vector<column_t> &indexed_columns) {\n+\tif (!expr) { return; }\n+\n+\tswitch (expr->GetExpressionClass()) {",
        "comment_created_at": "2025-08-07T10:36:01+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "You don't need to write your own switch-case here: we have `ExpressionIterator::EnumerateChildren` for that :) ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2280800928",
    "pr_number": 18514,
    "pr_file": "src/common/file_system.cpp",
    "created_at": "2025-08-17T09:25:26+00:00",
    "commented_code": "}\n }\n \n+string FileHandle::ReadLine(QueryContext context) {\n+\tstring result;\n+\tchar buffer[1];\n+\twhile (true) {\n+\t\tauto tuples_read = UnsafeNumericCast<idx_t>(Read(context, buffer, 1));\n+\t\tif (tuples_read == 0 || buffer[0] == '\n') {\n+\t\t\treturn result;\n+\t\t}\n+\t\tif (buffer[0] != '\\r') {\n+\t\t\tresult += buffer[0];\n+\t\t}\n+\t}\n+}\n+",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2280800928",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18514,
        "pr_file": "src/common/file_system.cpp",
        "discussion_id": "2280800928",
        "commented_code": "@@ -752,6 +758,20 @@ string FileHandle::ReadLine() {\n \t}\n }\n \n+string FileHandle::ReadLine(QueryContext context) {\n+\tstring result;\n+\tchar buffer[1];\n+\twhile (true) {\n+\t\tauto tuples_read = UnsafeNumericCast<idx_t>(Read(context, buffer, 1));\n+\t\tif (tuples_read == 0 || buffer[0] == '\\n') {\n+\t\t\treturn result;\n+\t\t}\n+\t\tif (buffer[0] != '\\r') {\n+\t\t\tresult += buffer[0];\n+\t\t}\n+\t}\n+}\n+",
        "comment_created_at": "2025-08-17T09:25:26+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "Do we need a new (copy-pasted) function here? Could we keep the code less duplicated by calling into this function from the old `ReadLine`?\r\n\r\n```cpp\r\nstring FileHandle::ReadLine() {\r\n\treturn ReadLine(QueryContext());\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2190297887",
    "pr_number": 17692,
    "pr_file": "src/common/csv_utils.cpp",
    "created_at": "2025-07-07T14:39:27+00:00",
    "commented_code": "+#include \"duckdb/common/csv_utils.hpp\"\n+#include \"duckdb/common/serializer/write_stream.hpp\"\n+\n+namespace duckdb {\n+\n+void CSVUtils::WriteQuoteOrEscape(WriteStream &writer, char quote_or_escape) {\n+\tif (quote_or_escape != '\\0') {\n+\t\twriter.Write(quote_or_escape);\n+\t}\n+}\n+\n+string CSVUtils::AddEscapes(char to_be_escaped, char escape, const string &val) {\n+\tidx_t i = 0;\n+\tstring new_val = \"\";\n+\tidx_t found = val.find(to_be_escaped);\n+\n+\twhile (found != string::npos) {\n+\t\twhile (i < found) {\n+\t\t\tnew_val += val[i];\n+\t\t\ti++;\n+\t\t}\n+\t\tif (escape != '\\0') {\n+\t\t\tnew_val += escape;\n+\t\t\tfound = val.find(to_be_escaped, found + 1);\n+\t\t}\n+\t}\n+\twhile (i < val.length()) {\n+\t\tnew_val += val[i];\n+\t\ti++;\n+\t}\n+\treturn new_val;\n+}\n+\n+bool CSVUtils::RequiresQuotes(const char *str, idx_t len, vector<string> &null_str,\n+                              unsafe_unique_array<bool> &requires_quotes) {\n+\t// check if the string is equal to the null string\n+\tif (len == null_str[0].size() && memcmp(str, null_str[0].c_str(), len) == 0) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2190297887",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17692,
        "pr_file": "src/common/csv_utils.cpp",
        "discussion_id": "2190297887",
        "commented_code": "@@ -0,0 +1,95 @@\n+#include \"duckdb/common/csv_utils.hpp\"\n+#include \"duckdb/common/serializer/write_stream.hpp\"\n+\n+namespace duckdb {\n+\n+void CSVUtils::WriteQuoteOrEscape(WriteStream &writer, char quote_or_escape) {\n+\tif (quote_or_escape != '\\0') {\n+\t\twriter.Write(quote_or_escape);\n+\t}\n+}\n+\n+string CSVUtils::AddEscapes(char to_be_escaped, char escape, const string &val) {\n+\tidx_t i = 0;\n+\tstring new_val = \"\";\n+\tidx_t found = val.find(to_be_escaped);\n+\n+\twhile (found != string::npos) {\n+\t\twhile (i < found) {\n+\t\t\tnew_val += val[i];\n+\t\t\ti++;\n+\t\t}\n+\t\tif (escape != '\\0') {\n+\t\t\tnew_val += escape;\n+\t\t\tfound = val.find(to_be_escaped, found + 1);\n+\t\t}\n+\t}\n+\twhile (i < val.length()) {\n+\t\tnew_val += val[i];\n+\t\ti++;\n+\t}\n+\treturn new_val;\n+}\n+\n+bool CSVUtils::RequiresQuotes(const char *str, idx_t len, vector<string> &null_str,\n+                              unsafe_unique_array<bool> &requires_quotes) {\n+\t// check if the string is equal to the null string\n+\tif (len == null_str[0].size() && memcmp(str, null_str[0].c_str(), len) == 0) {",
        "comment_created_at": "2025-07-07T14:39:27+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Could we maybe try to extract the CSV writer methods into a separate `CSVWriter` class that is used both by the copy csv and the logger?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166162130",
    "pr_number": 18054,
    "pr_file": "test/sqlite/sqllogic_test_runner.cpp",
    "created_at": "2025-06-25T08:43:19+00:00",
    "commented_code": "}\n \t}\n \n-\tif (!config->options.autoload_known_extensions) {\n+\tbool could_autoload = false;\n+\tif (config->options.autoload_known_extensions && !excluded_from_autoloading) {\n+\t\tcould_autoload = true;\n+\t}\n+\n+\tif (could_autoload) {\n+\t\tbool install_has_error = false;\n+\t\tif (install_mode == TestConfiguration::ExtensionInstallMode::LOCAL_ONLY ||\n+\t\t    install_mode == TestConfiguration::ExtensionInstallMode::EITHER) {\n+\t\t\tinstall_has_error |= con->Query(\"INSTALL \" + param + \" FROM '\" + local_extension_repo + \"';\")->HasError();\n+\t\t}\n+\t\tif (install_mode == TestConfiguration::ExtensionInstallMode::EITHER ||\n+\t\t    install_mode == TestConfiguration::ExtensionInstallMode::REMOTE_ONLY) {\n+\t\t\tinstall_has_error |= con->Query(\"INSTALL \" + param + \";\")->HasError();",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2166162130",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18054,
        "pr_file": "test/sqlite/sqllogic_test_runner.cpp",
        "discussion_id": "2166162130",
        "commented_code": "@@ -561,7 +603,54 @@ RequireResult SQLLogicTestRunner::CheckRequire(SQLLogicParser &parser, const vec\n \t\t}\n \t}\n \n-\tif (!config->options.autoload_known_extensions) {\n+\tbool could_autoload = false;\n+\tif (config->options.autoload_known_extensions && !excluded_from_autoloading) {\n+\t\tcould_autoload = true;\n+\t}\n+\n+\tif (could_autoload) {\n+\t\tbool install_has_error = false;\n+\t\tif (install_mode == TestConfiguration::ExtensionInstallMode::LOCAL_ONLY ||\n+\t\t    install_mode == TestConfiguration::ExtensionInstallMode::EITHER) {\n+\t\t\tinstall_has_error |= con->Query(\"INSTALL \" + param + \" FROM '\" + local_extension_repo + \"';\")->HasError();\n+\t\t}\n+\t\tif (install_mode == TestConfiguration::ExtensionInstallMode::EITHER ||\n+\t\t    install_mode == TestConfiguration::ExtensionInstallMode::REMOTE_ONLY) {\n+\t\t\tinstall_has_error |= con->Query(\"INSTALL \" + param + \";\")->HasError();",
        "comment_created_at": "2025-06-25T08:43:19+00:00",
        "comment_author": "Mytherin",
        "comment_body": "This seems like a copy-paste from below - what's the difference here between `could_autoload` and not? Can we unify this code?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163320593",
    "pr_number": 18013,
    "pr_file": "src/common/encryption_functions.cpp",
    "created_at": "2025-06-24T08:40:52+00:00",
    "commented_code": "encryption_state->Finalize(internal_buffer + delta, 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n }\n \n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, FileBuffer &out_buffer,\n+                                              uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];\n+\tmemset(tag, 0, MainHeader::AES_TAG_LEN);\n+\n+\t//! a nonce is randomly generated for every block\n+\tuint8_t nonce[MainHeader::AES_IV_LEN];\n+\tmemset(nonce, 0, MainHeader::AES_IV_LEN);\n+\n+\tencryption_state->GenerateRandomData(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN);\n+\n+\t//! store the nonce at the the start of metadata buffer\n+\tmemcpy(metadata, nonce, MainHeader::AES_NONCE_LEN);\n+\tencryption_state->InitializeEncryption(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN, temp_key,\n+\t                                       MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\tauto aes_res = encryption_state->Process(input_buffer.InternalBuffer(), input_buffer.AllocSize(),\n+\t                                         out_buffer.InternalBuffer(), input_buffer.AllocSize());\n+\n+\tif (aes_res != input_buffer.AllocSize()) {\n+\t\tthrow IOException(\"Encryption failure: in- and output size differ\");\n+\t}\n+\n+\t//! Finalize and extract the tag\n+\tencryption_state->Finalize(out_buffer.InternalBuffer(), 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n+\n+\t//! store the generated tag after consequetively the nonce\n+\tmemcpy(metadata + MainHeader::AES_NONCE_LEN, tag, MainHeader::AES_TAG_LEN);\n+\t// check if tag is correctly stored\n+\tD_ASSERT(memcmp(tag, metadata + 12, 16) == 0);\n+}\n+\n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2163320593",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18013,
        "pr_file": "src/common/encryption_functions.cpp",
        "discussion_id": "2163320593",
        "commented_code": "@@ -127,4 +128,272 @@ void EncryptionEngine::DecryptBlock(DatabaseInstance &db, const string &key_id,\n \t    encryption_state->Finalize(internal_buffer + delta, 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n }\n \n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, FileBuffer &out_buffer,\n+                                              uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];\n+\tmemset(tag, 0, MainHeader::AES_TAG_LEN);\n+\n+\t//! a nonce is randomly generated for every block\n+\tuint8_t nonce[MainHeader::AES_IV_LEN];\n+\tmemset(nonce, 0, MainHeader::AES_IV_LEN);\n+\n+\tencryption_state->GenerateRandomData(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN);\n+\n+\t//! store the nonce at the the start of metadata buffer\n+\tmemcpy(metadata, nonce, MainHeader::AES_NONCE_LEN);\n+\tencryption_state->InitializeEncryption(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN, temp_key,\n+\t                                       MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\tauto aes_res = encryption_state->Process(input_buffer.InternalBuffer(), input_buffer.AllocSize(),\n+\t                                         out_buffer.InternalBuffer(), input_buffer.AllocSize());\n+\n+\tif (aes_res != input_buffer.AllocSize()) {\n+\t\tthrow IOException(\"Encryption failure: in- and output size differ\");\n+\t}\n+\n+\t//! Finalize and extract the tag\n+\tencryption_state->Finalize(out_buffer.InternalBuffer(), 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n+\n+\t//! store the generated tag after consequetively the nonce\n+\tmemcpy(metadata + MainHeader::AES_NONCE_LEN, tag, MainHeader::AES_TAG_LEN);\n+\t// check if tag is correctly stored\n+\tD_ASSERT(memcmp(tag, metadata + 12, 16) == 0);\n+}\n+\n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");",
        "comment_created_at": "2025-06-24T08:40:52+00:00",
        "comment_author": "Mytherin",
        "comment_body": "It looks like there is a lot of duplicated code between the two `EncryptTemporaryBuffer` methods - can we unify them?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163323776",
    "pr_number": 18013,
    "pr_file": "src/common/encryption_functions.cpp",
    "created_at": "2025-06-24T08:42:21+00:00",
    "commented_code": "encryption_state->Finalize(internal_buffer + delta, 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n }\n \n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, FileBuffer &out_buffer,\n+                                              uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];\n+\tmemset(tag, 0, MainHeader::AES_TAG_LEN);\n+\n+\t//! a nonce is randomly generated for every block\n+\tuint8_t nonce[MainHeader::AES_IV_LEN];\n+\tmemset(nonce, 0, MainHeader::AES_IV_LEN);\n+\n+\tencryption_state->GenerateRandomData(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN);\n+\n+\t//! store the nonce at the the start of metadata buffer\n+\tmemcpy(metadata, nonce, MainHeader::AES_NONCE_LEN);\n+\tencryption_state->InitializeEncryption(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN, temp_key,\n+\t                                       MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\tauto aes_res = encryption_state->Process(input_buffer.InternalBuffer(), input_buffer.AllocSize(),\n+\t                                         out_buffer.InternalBuffer(), input_buffer.AllocSize());\n+\n+\tif (aes_res != input_buffer.AllocSize()) {\n+\t\tthrow IOException(\"Encryption failure: in- and output size differ\");\n+\t}\n+\n+\t//! Finalize and extract the tag\n+\tencryption_state->Finalize(out_buffer.InternalBuffer(), 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n+\n+\t//! store the generated tag after consequetively the nonce\n+\tmemcpy(metadata + MainHeader::AES_NONCE_LEN, tag, MainHeader::AES_TAG_LEN);\n+\t// check if tag is correctly stored\n+\tD_ASSERT(memcmp(tag, metadata + 12, 16) == 0);\n+}\n+\n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];\n+\tmemset(tag, 0, MainHeader::AES_TAG_LEN);\n+\n+\t//! a nonce is randomly generated for every block\n+\tuint8_t nonce[MainHeader::AES_IV_LEN];\n+\tmemset(nonce, 0, MainHeader::AES_IV_LEN);\n+\n+\tencryption_state->GenerateRandomData(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN);\n+\n+\t//! store the nonce at the the start of metadata buffer\n+\tmemcpy(metadata, nonce, MainHeader::AES_NONCE_LEN);\n+\tencryption_state->InitializeEncryption(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN, temp_key,\n+\t                                       MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\tauto aes_res = encryption_state->Process(input_buffer.InternalBuffer(), input_buffer.AllocSize(),\n+\t                                         input_buffer.InternalBuffer(), input_buffer.AllocSize());\n+\n+\tif (aes_res != input_buffer.AllocSize()) {\n+\t\tthrow IOException(\"Encryption failure: in- and output size differ\");\n+\t}\n+\n+\t//! Finalize and extract the tag\n+\tencryption_state->Finalize(input_buffer.InternalBuffer(), 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n+\n+\t//! store the generated tag after consequetively the nonce\n+\tmemcpy(metadata + MainHeader::AES_NONCE_LEN, tag, MainHeader::AES_TAG_LEN);\n+\n+\t// check if tag is correctly stored\n+\tD_ASSERT(memcmp(tag, metadata + 12, 16) == 0);\n+}\n+\n+void EncryptionEngine::EncryptTemporaryAllocatedData(DatabaseInstance &db, AllocatedData &input_buffer,\n+                                                     AllocatedData &out_buffer, idx_t nr_bytes, uint8_t *metadata) {\n+\n+\t// this already expects an empty (\"header\" of delta bytes).\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2163323776",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18013,
        "pr_file": "src/common/encryption_functions.cpp",
        "discussion_id": "2163323776",
        "commented_code": "@@ -127,4 +128,272 @@ void EncryptionEngine::DecryptBlock(DatabaseInstance &db, const string &key_id,\n \t    encryption_state->Finalize(internal_buffer + delta, 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n }\n \n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, FileBuffer &out_buffer,\n+                                              uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];\n+\tmemset(tag, 0, MainHeader::AES_TAG_LEN);\n+\n+\t//! a nonce is randomly generated for every block\n+\tuint8_t nonce[MainHeader::AES_IV_LEN];\n+\tmemset(nonce, 0, MainHeader::AES_IV_LEN);\n+\n+\tencryption_state->GenerateRandomData(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN);\n+\n+\t//! store the nonce at the the start of metadata buffer\n+\tmemcpy(metadata, nonce, MainHeader::AES_NONCE_LEN);\n+\tencryption_state->InitializeEncryption(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN, temp_key,\n+\t                                       MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\tauto aes_res = encryption_state->Process(input_buffer.InternalBuffer(), input_buffer.AllocSize(),\n+\t                                         out_buffer.InternalBuffer(), input_buffer.AllocSize());\n+\n+\tif (aes_res != input_buffer.AllocSize()) {\n+\t\tthrow IOException(\"Encryption failure: in- and output size differ\");\n+\t}\n+\n+\t//! Finalize and extract the tag\n+\tencryption_state->Finalize(out_buffer.InternalBuffer(), 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n+\n+\t//! store the generated tag after consequetively the nonce\n+\tmemcpy(metadata + MainHeader::AES_NONCE_LEN, tag, MainHeader::AES_TAG_LEN);\n+\t// check if tag is correctly stored\n+\tD_ASSERT(memcmp(tag, metadata + 12, 16) == 0);\n+}\n+\n+void EncryptionEngine::EncryptTemporaryBuffer(DatabaseInstance &db, FileBuffer &input_buffer, uint8_t *metadata) {\n+\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];\n+\tmemset(tag, 0, MainHeader::AES_TAG_LEN);\n+\n+\t//! a nonce is randomly generated for every block\n+\tuint8_t nonce[MainHeader::AES_IV_LEN];\n+\tmemset(nonce, 0, MainHeader::AES_IV_LEN);\n+\n+\tencryption_state->GenerateRandomData(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN);\n+\n+\t//! store the nonce at the the start of metadata buffer\n+\tmemcpy(metadata, nonce, MainHeader::AES_NONCE_LEN);\n+\tencryption_state->InitializeEncryption(static_cast<data_ptr_t>(nonce), MainHeader::AES_NONCE_LEN, temp_key,\n+\t                                       MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\tauto aes_res = encryption_state->Process(input_buffer.InternalBuffer(), input_buffer.AllocSize(),\n+\t                                         input_buffer.InternalBuffer(), input_buffer.AllocSize());\n+\n+\tif (aes_res != input_buffer.AllocSize()) {\n+\t\tthrow IOException(\"Encryption failure: in- and output size differ\");\n+\t}\n+\n+\t//! Finalize and extract the tag\n+\tencryption_state->Finalize(input_buffer.InternalBuffer(), 0, static_cast<data_ptr_t>(tag), MainHeader::AES_TAG_LEN);\n+\n+\t//! store the generated tag after consequetively the nonce\n+\tmemcpy(metadata + MainHeader::AES_NONCE_LEN, tag, MainHeader::AES_TAG_LEN);\n+\n+\t// check if tag is correctly stored\n+\tD_ASSERT(memcmp(tag, metadata + 12, 16) == 0);\n+}\n+\n+void EncryptionEngine::EncryptTemporaryAllocatedData(DatabaseInstance &db, AllocatedData &input_buffer,\n+                                                     AllocatedData &out_buffer, idx_t nr_bytes, uint8_t *metadata) {\n+\n+\t// this already expects an empty (\"header\" of delta bytes).\n+\tif (!ContainsKey(db, \"temp_key\")) {\n+\t\tAddTempKeyToCache(db);\n+\t}\n+\tauto temp_key = GetKeyFromCache(db, \"temp_key\");\n+\n+\tauto encryption_util = db.GetEncryptionUtil();\n+\tauto encryption_state = encryption_util->CreateEncryptionState(temp_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n+\n+\t// zero-out the metadata buffer\n+\tmemset(metadata, 0, DEFAULT_ENCRYPTED_BUFFER_HEADER_SIZE);\n+\n+\tuint8_t tag[MainHeader::AES_TAG_LEN];",
        "comment_created_at": "2025-06-24T08:42:21+00:00",
        "comment_author": "Mytherin",
        "comment_body": "This pattern seems to be present all over the code - perhaps it would be nicer to have a dedicated class for this? e.g.:\r\n\r\n\r\n```cpp\r\nstruct EncryptionTag {\r\n    EncryptionTag() {\r\n        memset(tag, 0, MainHeader::AES_TAG_LEN);\r\n    }\r\n    data_ptr_t data();\r\n    idx_t size();\r\n\r\n    uint8_t data[MainHeader::AES_TAG_LEN];\r\n};\r\n```\r\n\r\nSame with the nonce.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "504840727",
    "pr_number": 1008,
    "pr_file": "src/execution/operator/join/physical_index_join.cpp",
    "created_at": "2020-10-14T17:12:05+00:00",
    "commented_code": "+#include \"duckdb/execution/operator/join/physical_index_join.hpp\"\n+\n+#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/execution/index/art/art.hpp\"\n+#include \"duckdb/execution/operator/scan/physical_table_scan.hpp\"\n+#include \"duckdb/function/table/table_scan.hpp\"\n+#include \"duckdb/storage/buffer_manager.hpp\"\n+#include \"duckdb/storage/storage_manager.hpp\"\n+#include \"duckdb/transaction/transaction.hpp\"\n+\n+#include <iostream>\n+#include <utility>\n+\n+using namespace std;\n+\n+namespace duckdb {\n+\n+class PhysicalIndexJoinOperatorState : public PhysicalOperatorState {\n+public:\n+\tPhysicalIndexJoinOperatorState(PhysicalOperator &op, PhysicalOperator *left, PhysicalOperator *right)\n+\t    : PhysicalOperatorState(op, left) {\n+\t\tassert(left && right);\n+\t\tfor (idx_t i = 0; i < STANDARD_VECTOR_SIZE; i++) {\n+\t\t\trhs_rows.emplace_back();\n+\t\t\tresult_sizes.emplace_back();\n+\t\t}\n+\t}\n+\n+\tidx_t lhs_idx = 0;\n+\tidx_t rhs_idx = 0;\n+\tidx_t result_size = 0;\n+\tvector<idx_t> result_sizes;\n+\tDataChunk join_keys;\n+\t//! Vector of rows that mush be fetched for every LHS key\n+\tvector<vector<row_t>> rhs_rows;\n+\tExpressionExecutor probe_executor;\n+\tIndexLock lock;\n+};\n+\n+PhysicalIndexJoin::PhysicalIndexJoin(LogicalOperator &op, unique_ptr<PhysicalOperator> left,\n+                                     unique_ptr<PhysicalOperator> right, vector<JoinCondition> cond, JoinType join_type,\n+                                     const vector<idx_t> &left_projection_map, vector<idx_t> right_projection_map,\n+                                     vector<column_t> column_ids_, Index *index, bool lhs_first)\n+    : PhysicalOperator(PhysicalOperatorType::INDEX_JOIN, move(op.types)), left_projection_map(left_projection_map),\n+      right_projection_map(move(right_projection_map)), index(index), conditions(move(cond)), join_type(join_type),\n+      lhs_first(lhs_first) {\n+\tcolumn_ids = move(column_ids_);\n+\tchildren.push_back(move(left));\n+\tchildren.push_back(move(right));\n+\tfor (auto &condition : conditions) {\n+\t\tcondition_types.push_back(condition.left->return_type);\n+\t}\n+\t//! Only add to fetch_ids columns that are not indexed\n+\tfor (auto &index_id : index->column_ids) {\n+\t\tindex_ids.insert(index_id);\n+\t}\n+\tfor (size_t column_id = 0; column_id < column_ids.size(); column_id++) {\n+\t\tauto it = index_ids.find(column_ids[column_id]);\n+\t\tif (it == index_ids.end()) {\n+\t\t\tfetch_ids.push_back(column_ids[column_id]);\n+\t\t\tfetch_types.push_back(children[1]->types[column_id]);\n+\t\t}\n+\t}\n+}\n+\n+void PhysicalIndexJoin::Output(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state_) {\n+\tauto &transaction = Transaction::GetTransaction(context.client);\n+\tauto &phy_tbl_scan = (PhysicalTableScan &)*children[1];\n+\tauto &bind_tbl = (TableScanBindData &)*phy_tbl_scan.bind_data;\n+\tauto tbl = bind_tbl.table->storage.get();\n+\tDataChunk rhs_chunk;\n+\tidx_t rhs_column_idx = 0;\n+\tSelectionVector sel;\n+\tsel.Initialize(STANDARD_VECTOR_SIZE);\n+\tsize_t output_sel_idx{};\n+\tvector<row_t> fetch_rows;\n+\tauto state = reinterpret_cast<PhysicalIndexJoinOperatorState *>(state_);\n+\twhile (output_sel_idx < STANDARD_VECTOR_SIZE && state->lhs_idx < state->child_chunk.size()) {\n+\t\tif (state->rhs_idx < state->result_sizes[state->lhs_idx]) {\n+\t\t\tsel.set_index(output_sel_idx++, state->lhs_idx);\n+\t\t\tif (!fetch_types.empty()) {\n+\t\t\t\t//! We need to collect the rows we want to fetch\n+\t\t\t\tfetch_rows.push_back(state->rhs_rows[state->lhs_idx][state->rhs_idx]);\n+\t\t\t}\n+\t\t\tstate->rhs_idx++;\n+\t\t} else {\n+\t\t\t//! We are done with the matches from this LHS Key\n+\t\t\tstate->rhs_idx = 0;\n+\t\t\tstate->lhs_idx++;\n+\t\t}\n+\t}\n+\t//! Now we fetch the RHS data\n+\tif (!fetch_types.empty()) {\n+\t\trhs_chunk.Initialize(fetch_types);\n+\t\tColumnFetchState fetch_state;\n+\t\tVector row_ids;\n+\t\trow_ids.type = LOGICAL_ROW_TYPE;\n+\t\tFlatVector::SetData(row_ids, (data_ptr_t)&fetch_rows[0]);\n+\t\ttbl->Fetch(transaction, rhs_chunk, fetch_ids, row_ids, output_sel_idx, fetch_state);\n+\t}\n+\n+\t//! Now we actually produce our result chunk\n+\tif (!lhs_first) {\n+\t\tfor (idx_t i = 0; i < right_projection_map.size(); i++) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "504840727",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 1008,
        "pr_file": "src/execution/operator/join/physical_index_join.cpp",
        "discussion_id": "504840727",
        "commented_code": "@@ -0,0 +1,214 @@\n+#include \"duckdb/execution/operator/join/physical_index_join.hpp\"\n+\n+#include \"duckdb/common/vector_operations/vector_operations.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/execution/index/art/art.hpp\"\n+#include \"duckdb/execution/operator/scan/physical_table_scan.hpp\"\n+#include \"duckdb/function/table/table_scan.hpp\"\n+#include \"duckdb/storage/buffer_manager.hpp\"\n+#include \"duckdb/storage/storage_manager.hpp\"\n+#include \"duckdb/transaction/transaction.hpp\"\n+\n+#include <iostream>\n+#include <utility>\n+\n+using namespace std;\n+\n+namespace duckdb {\n+\n+class PhysicalIndexJoinOperatorState : public PhysicalOperatorState {\n+public:\n+\tPhysicalIndexJoinOperatorState(PhysicalOperator &op, PhysicalOperator *left, PhysicalOperator *right)\n+\t    : PhysicalOperatorState(op, left) {\n+\t\tassert(left && right);\n+\t\tfor (idx_t i = 0; i < STANDARD_VECTOR_SIZE; i++) {\n+\t\t\trhs_rows.emplace_back();\n+\t\t\tresult_sizes.emplace_back();\n+\t\t}\n+\t}\n+\n+\tidx_t lhs_idx = 0;\n+\tidx_t rhs_idx = 0;\n+\tidx_t result_size = 0;\n+\tvector<idx_t> result_sizes;\n+\tDataChunk join_keys;\n+\t//! Vector of rows that mush be fetched for every LHS key\n+\tvector<vector<row_t>> rhs_rows;\n+\tExpressionExecutor probe_executor;\n+\tIndexLock lock;\n+};\n+\n+PhysicalIndexJoin::PhysicalIndexJoin(LogicalOperator &op, unique_ptr<PhysicalOperator> left,\n+                                     unique_ptr<PhysicalOperator> right, vector<JoinCondition> cond, JoinType join_type,\n+                                     const vector<idx_t> &left_projection_map, vector<idx_t> right_projection_map,\n+                                     vector<column_t> column_ids_, Index *index, bool lhs_first)\n+    : PhysicalOperator(PhysicalOperatorType::INDEX_JOIN, move(op.types)), left_projection_map(left_projection_map),\n+      right_projection_map(move(right_projection_map)), index(index), conditions(move(cond)), join_type(join_type),\n+      lhs_first(lhs_first) {\n+\tcolumn_ids = move(column_ids_);\n+\tchildren.push_back(move(left));\n+\tchildren.push_back(move(right));\n+\tfor (auto &condition : conditions) {\n+\t\tcondition_types.push_back(condition.left->return_type);\n+\t}\n+\t//! Only add to fetch_ids columns that are not indexed\n+\tfor (auto &index_id : index->column_ids) {\n+\t\tindex_ids.insert(index_id);\n+\t}\n+\tfor (size_t column_id = 0; column_id < column_ids.size(); column_id++) {\n+\t\tauto it = index_ids.find(column_ids[column_id]);\n+\t\tif (it == index_ids.end()) {\n+\t\t\tfetch_ids.push_back(column_ids[column_id]);\n+\t\t\tfetch_types.push_back(children[1]->types[column_id]);\n+\t\t}\n+\t}\n+}\n+\n+void PhysicalIndexJoin::Output(ExecutionContext &context, DataChunk &chunk, PhysicalOperatorState *state_) {\n+\tauto &transaction = Transaction::GetTransaction(context.client);\n+\tauto &phy_tbl_scan = (PhysicalTableScan &)*children[1];\n+\tauto &bind_tbl = (TableScanBindData &)*phy_tbl_scan.bind_data;\n+\tauto tbl = bind_tbl.table->storage.get();\n+\tDataChunk rhs_chunk;\n+\tidx_t rhs_column_idx = 0;\n+\tSelectionVector sel;\n+\tsel.Initialize(STANDARD_VECTOR_SIZE);\n+\tsize_t output_sel_idx{};\n+\tvector<row_t> fetch_rows;\n+\tauto state = reinterpret_cast<PhysicalIndexJoinOperatorState *>(state_);\n+\twhile (output_sel_idx < STANDARD_VECTOR_SIZE && state->lhs_idx < state->child_chunk.size()) {\n+\t\tif (state->rhs_idx < state->result_sizes[state->lhs_idx]) {\n+\t\t\tsel.set_index(output_sel_idx++, state->lhs_idx);\n+\t\t\tif (!fetch_types.empty()) {\n+\t\t\t\t//! We need to collect the rows we want to fetch\n+\t\t\t\tfetch_rows.push_back(state->rhs_rows[state->lhs_idx][state->rhs_idx]);\n+\t\t\t}\n+\t\t\tstate->rhs_idx++;\n+\t\t} else {\n+\t\t\t//! We are done with the matches from this LHS Key\n+\t\t\tstate->rhs_idx = 0;\n+\t\t\tstate->lhs_idx++;\n+\t\t}\n+\t}\n+\t//! Now we fetch the RHS data\n+\tif (!fetch_types.empty()) {\n+\t\trhs_chunk.Initialize(fetch_types);\n+\t\tColumnFetchState fetch_state;\n+\t\tVector row_ids;\n+\t\trow_ids.type = LOGICAL_ROW_TYPE;\n+\t\tFlatVector::SetData(row_ids, (data_ptr_t)&fetch_rows[0]);\n+\t\ttbl->Fetch(transaction, rhs_chunk, fetch_ids, row_ids, output_sel_idx, fetch_state);\n+\t}\n+\n+\t//! Now we actually produce our result chunk\n+\tif (!lhs_first) {\n+\t\tfor (idx_t i = 0; i < right_projection_map.size(); i++) {",
        "comment_created_at": "2020-10-14T17:12:05+00:00",
        "comment_author": "Mytherin",
        "comment_body": "As far as I can tell all that changes based on `lhs_first` is the index into the final chunk, is that correct? If so, rather than duplicating code perhaps you can do:\r\n```sql\r\nidx_t left_offset = lhs_first ? 0 : right_projection_map.size();\r\nidx_t right_offset = lhs_first ? left_projection_map.size() : 0;\r\n...\r\nchunk.data[left_offset + i].Reference(...)\r\n...\r\nchunk.data[right_offset + i].Reference(...)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2021073145",
    "pr_number": 16833,
    "pr_file": "test/sqlite/sqllogic_test_logger.cpp",
    "created_at": "2025-03-31T13:43:19+00:00",
    "commented_code": "PrintLineSep();\n }\n \n-void SQLLogicTestLogger::ColumnCountMismatch(MaterializedQueryResult &result,\n-                                             const vector<string> &result_values_string, idx_t expected_column_count,\n-                                             bool row_wise) {\n-\tPrintErrorHeader(\"Wrong column count in query!\");\n+string SQLLogicTestLogger::ColumnCountMismatch(MaterializedQueryResult &result,\n+                                               const vector<string> &result_values_string, idx_t expected_column_count,\n+                                               bool row_wise) {\n+\n+\tstring log_message = PrintErrorHeader(\"Wrong column count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_column_count << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << result.ColumnCount() << termcolor::reset << \" columns\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintResultError(result, result_values_string, expected_column_count, row_wise);\n+\tlog_message += \"Expected \" + to_string(expected_column_count) + \" columns, but got \" +\n+\t               to_string(result.ColumnCount()) + \" columns\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintResultError(result, result_values_string, expected_column_count, row_wise);\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::NotCleanlyDivisible(idx_t expected_column_count, idx_t actual_column_count) {\n-\tPrintErrorHeader(\"Error in test!\");\n-\tPrintLineSep();\n+string SQLLogicTestLogger::NotCleanlyDivisible(idx_t expected_column_count, idx_t actual_column_count) {\n+\tstring log_message = PrintErrorHeader(\"Error in test!\");\n+\tlog_message += PrintLineSep();\n \tfprintf(stderr, \"Expected %d columns, but %d values were supplied\n\", (int)expected_column_count,\n \t        (int)actual_column_count);\n \tfprintf(stderr, \"This is not cleanly divisible (i.e. the last row does not have enough values)\n\");\n+\tlog_message += \"Expected \" + to_string(expected_column_count) + \" columns, but \" + to_string(actual_column_count) +\n+\t               \" values were supplied\n\";\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::WrongRowCount(idx_t expected_rows, MaterializedQueryResult &result,\n-                                       const vector<string> &comparison_values, idx_t expected_column_count,\n-                                       bool row_wise) {\n-\tPrintErrorHeader(\"Wrong row count in query!\");\n+string SQLLogicTestLogger::WrongRowCount(idx_t expected_rows, MaterializedQueryResult &result,\n+                                         const vector<string> &comparison_values, idx_t expected_column_count,\n+                                         bool row_wise) {\n+\tstring log_message = PrintErrorHeader(\"Wrong row count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_rows << termcolor::reset << \" rows, but got \"\n \t          << termcolor::bold << result.RowCount() << termcolor::reset << \" rows\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintResultError(result, comparison_values, expected_column_count, row_wise);\n+\tlog_message +=\n+\t    \"Expected \" + to_string(expected_rows) + \" rows, but got \" + to_string(result.RowCount()) + \" rows\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintResultError(result, comparison_values, expected_column_count, row_wise);\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::ColumnCountMismatchCorrectResult(idx_t original_expected_columns, idx_t expected_column_count,\n-                                                          MaterializedQueryResult &result) {\n-\tPrintLineSep();\n-\tPrintErrorHeader(\"Wrong column count in query!\");\n+string SQLLogicTestLogger::ColumnCountMismatchCorrectResult(idx_t original_expected_columns,\n+                                                            idx_t expected_column_count,\n+                                                            MaterializedQueryResult &result) {\n+\tstring log_message = PrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Wrong column count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << original_expected_columns << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << expected_column_count << termcolor::reset << \" columns\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n \tstd::cerr << \"The expected result \" << termcolor::bold << \"matched\" << termcolor::reset << \" the query result.\"\n \t          << std::endl;\n+\tlog_message += PrintLineSep();\n \tstd::cerr << termcolor::bold << \"Suggested fix: modify header to \\\"\" << termcolor::green << \"query \"\n \t          << string(result.ColumnCount(), 'I') << termcolor::reset << termcolor::bold << \"\\\"\" << termcolor::reset\n \t          << std::endl;\n-\tPrintLineSep();\n+\tlog_message += \"The expected result matched the query result.\n\";\n+\tlog_message += \"Suggested fix: modify header to \\\" query \" + string(result.ColumnCount(), 'I') + \"\\\"\n\";\n+\tlog_message += PrintLineSep();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count) {\n-\tPrintLineSep();\n-\tPrintErrorHeader(\"Error in test! Column count mismatch after splitting on tab on row \" + to_string(row_number) +\n-\t                 \"!\");\n+string SQLLogicTestLogger::SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count) {\n+\tstring log_message = PrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Error in test! Column count mismatch after splitting on tab on row \" +\n+\t                                to_string(row_number) + \"!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_column_count << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << split_count << termcolor::reset << \" columns\" << std::endl;\n \tstd::cerr << \"Does the result contain tab values? In that case, place every value on a single row.\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+\tlog_message +=\n+\t    \"Expected \" + to_string(expected_column_count) + \" columns, but got \" + to_string(split_count) + \" columns\n\";\n+\tlog_message += \"Does the result contain tab values? In that case, place every value on a single row.\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result) {\n+string SQLLogicTestLogger::WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result) {\n+\tstring log_message = \"\";\n \tif (expected_result) {\n \t\texpected_result->Print();\n+\t\tlog_message += expected_result->ToString();\n \t} else {\n \t\tstd::cerr << \"???\" << std::endl;\n+\t\tlog_message += \"???\n\";\n \t}\n-\tPrintErrorHeader(\"Wrong result hash!\");\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintHeader(\"Expected result:\");\n-\tPrintLineSep();\n-\tPrintHeader(\"Actual result:\");\n-\tPrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Wrong result hash!\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintHeader(\"Expected result:\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintHeader(\"Actual result:\");\n+\tlog_message += PrintLineSep();\n \tresult.Print();\n+\tlog_message += result.ToString();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result) {\n-\tPrintErrorHeader(!expect_ok ? \"Query unexpectedly succeeded!\" : \"Query unexpectedly failed!\");\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+string SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result) {\n+\tstring log_message = PrintErrorHeader(!expect_ok ? \"Query unexpectedly succeeded!\" : \"Query unexpectedly failed!\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += result.ToString() + \"\n\";\n \tresult.Print();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {\n-\tPrintErrorHeader(\"Query failed, but error message did not match expected error message: \" + expected_error);\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintHeader(\"Actual result:\");\n-\tPrintLineSep();\n+string SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {\n+\tstring log_message =\n+\t    PrintErrorHeader(\"Query failed, but error message did not match expected error message: \" + expected_error);\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintHeader(\"Actual result:\");\n+\tlog_message += PrintLineSep();\n \tresult.Print();\n+\tlog_message += result.ToString();",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2021073145",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16833,
        "pr_file": "test/sqlite/sqllogic_test_logger.cpp",
        "discussion_id": "2021073145",
        "commented_code": "@@ -182,108 +202,138 @@ void SQLLogicTestLogger::OutputHash(const string &hash_value) {\n \tPrintLineSep();\n }\n \n-void SQLLogicTestLogger::ColumnCountMismatch(MaterializedQueryResult &result,\n-                                             const vector<string> &result_values_string, idx_t expected_column_count,\n-                                             bool row_wise) {\n-\tPrintErrorHeader(\"Wrong column count in query!\");\n+string SQLLogicTestLogger::ColumnCountMismatch(MaterializedQueryResult &result,\n+                                               const vector<string> &result_values_string, idx_t expected_column_count,\n+                                               bool row_wise) {\n+\n+\tstring log_message = PrintErrorHeader(\"Wrong column count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_column_count << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << result.ColumnCount() << termcolor::reset << \" columns\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintResultError(result, result_values_string, expected_column_count, row_wise);\n+\tlog_message += \"Expected \" + to_string(expected_column_count) + \" columns, but got \" +\n+\t               to_string(result.ColumnCount()) + \" columns\\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintResultError(result, result_values_string, expected_column_count, row_wise);\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::NotCleanlyDivisible(idx_t expected_column_count, idx_t actual_column_count) {\n-\tPrintErrorHeader(\"Error in test!\");\n-\tPrintLineSep();\n+string SQLLogicTestLogger::NotCleanlyDivisible(idx_t expected_column_count, idx_t actual_column_count) {\n+\tstring log_message = PrintErrorHeader(\"Error in test!\");\n+\tlog_message += PrintLineSep();\n \tfprintf(stderr, \"Expected %d columns, but %d values were supplied\\n\", (int)expected_column_count,\n \t        (int)actual_column_count);\n \tfprintf(stderr, \"This is not cleanly divisible (i.e. the last row does not have enough values)\\n\");\n+\tlog_message += \"Expected \" + to_string(expected_column_count) + \" columns, but \" + to_string(actual_column_count) +\n+\t               \" values were supplied\\n\";\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::WrongRowCount(idx_t expected_rows, MaterializedQueryResult &result,\n-                                       const vector<string> &comparison_values, idx_t expected_column_count,\n-                                       bool row_wise) {\n-\tPrintErrorHeader(\"Wrong row count in query!\");\n+string SQLLogicTestLogger::WrongRowCount(idx_t expected_rows, MaterializedQueryResult &result,\n+                                         const vector<string> &comparison_values, idx_t expected_column_count,\n+                                         bool row_wise) {\n+\tstring log_message = PrintErrorHeader(\"Wrong row count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_rows << termcolor::reset << \" rows, but got \"\n \t          << termcolor::bold << result.RowCount() << termcolor::reset << \" rows\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintResultError(result, comparison_values, expected_column_count, row_wise);\n+\tlog_message +=\n+\t    \"Expected \" + to_string(expected_rows) + \" rows, but got \" + to_string(result.RowCount()) + \" rows\\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintResultError(result, comparison_values, expected_column_count, row_wise);\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::ColumnCountMismatchCorrectResult(idx_t original_expected_columns, idx_t expected_column_count,\n-                                                          MaterializedQueryResult &result) {\n-\tPrintLineSep();\n-\tPrintErrorHeader(\"Wrong column count in query!\");\n+string SQLLogicTestLogger::ColumnCountMismatchCorrectResult(idx_t original_expected_columns,\n+                                                            idx_t expected_column_count,\n+                                                            MaterializedQueryResult &result) {\n+\tstring log_message = PrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Wrong column count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << original_expected_columns << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << expected_column_count << termcolor::reset << \" columns\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n \tstd::cerr << \"The expected result \" << termcolor::bold << \"matched\" << termcolor::reset << \" the query result.\"\n \t          << std::endl;\n+\tlog_message += PrintLineSep();\n \tstd::cerr << termcolor::bold << \"Suggested fix: modify header to \\\"\" << termcolor::green << \"query \"\n \t          << string(result.ColumnCount(), 'I') << termcolor::reset << termcolor::bold << \"\\\"\" << termcolor::reset\n \t          << std::endl;\n-\tPrintLineSep();\n+\tlog_message += \"The expected result matched the query result.\\n\";\n+\tlog_message += \"Suggested fix: modify header to \\\" query \" + string(result.ColumnCount(), 'I') + \"\\\"\\n\";\n+\tlog_message += PrintLineSep();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count) {\n-\tPrintLineSep();\n-\tPrintErrorHeader(\"Error in test! Column count mismatch after splitting on tab on row \" + to_string(row_number) +\n-\t                 \"!\");\n+string SQLLogicTestLogger::SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count) {\n+\tstring log_message = PrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Error in test! Column count mismatch after splitting on tab on row \" +\n+\t                                to_string(row_number) + \"!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_column_count << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << split_count << termcolor::reset << \" columns\" << std::endl;\n \tstd::cerr << \"Does the result contain tab values? In that case, place every value on a single row.\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+\tlog_message +=\n+\t    \"Expected \" + to_string(expected_column_count) + \" columns, but got \" + to_string(split_count) + \" columns\\n\";\n+\tlog_message += \"Does the result contain tab values? In that case, place every value on a single row.\\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result) {\n+string SQLLogicTestLogger::WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result) {\n+\tstring log_message = \"\";\n \tif (expected_result) {\n \t\texpected_result->Print();\n+\t\tlog_message += expected_result->ToString();\n \t} else {\n \t\tstd::cerr << \"???\" << std::endl;\n+\t\tlog_message += \"???\\n\";\n \t}\n-\tPrintErrorHeader(\"Wrong result hash!\");\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintHeader(\"Expected result:\");\n-\tPrintLineSep();\n-\tPrintHeader(\"Actual result:\");\n-\tPrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Wrong result hash!\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintHeader(\"Expected result:\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintHeader(\"Actual result:\");\n+\tlog_message += PrintLineSep();\n \tresult.Print();\n+\tlog_message += result.ToString();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result) {\n-\tPrintErrorHeader(!expect_ok ? \"Query unexpectedly succeeded!\" : \"Query unexpectedly failed!\");\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+string SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result) {\n+\tstring log_message = PrintErrorHeader(!expect_ok ? \"Query unexpectedly succeeded!\" : \"Query unexpectedly failed!\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += result.ToString() + \"\\n\";\n \tresult.Print();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {\n-\tPrintErrorHeader(\"Query failed, but error message did not match expected error message: \" + expected_error);\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintHeader(\"Actual result:\");\n-\tPrintLineSep();\n+string SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {\n+\tstring log_message =\n+\t    PrintErrorHeader(\"Query failed, but error message did not match expected error message: \" + expected_error);\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintHeader(\"Actual result:\");\n+\tlog_message += PrintLineSep();\n \tresult.Print();\n+\tlog_message += result.ToString();",
        "comment_created_at": "2025-03-31T13:43:19+00:00",
        "comment_author": "Mytherin",
        "comment_body": "It feels like we are doing a lot of duplicate work here which complicates the code (`result.Print()` followed by `result.ToString()`).\r\n\r\nGenerally the way we would achieve either printing or collecting a string is to write to a stream object, e.g. an `std::ostream &ss`. Then we can pass in a `std::stringstream` to obtain a string, or pass in another output stream (e.g. `stdout`) to render to a different location.\r\n\r\nCan we rework this to use that construct to avoid having to change/duplicate all of this code?",
        "pr_file_module": null
      },
      {
        "comment_id": "2024850328",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16833,
        "pr_file": "test/sqlite/sqllogic_test_logger.cpp",
        "discussion_id": "2021073145",
        "commented_code": "@@ -182,108 +202,138 @@ void SQLLogicTestLogger::OutputHash(const string &hash_value) {\n \tPrintLineSep();\n }\n \n-void SQLLogicTestLogger::ColumnCountMismatch(MaterializedQueryResult &result,\n-                                             const vector<string> &result_values_string, idx_t expected_column_count,\n-                                             bool row_wise) {\n-\tPrintErrorHeader(\"Wrong column count in query!\");\n+string SQLLogicTestLogger::ColumnCountMismatch(MaterializedQueryResult &result,\n+                                               const vector<string> &result_values_string, idx_t expected_column_count,\n+                                               bool row_wise) {\n+\n+\tstring log_message = PrintErrorHeader(\"Wrong column count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_column_count << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << result.ColumnCount() << termcolor::reset << \" columns\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintResultError(result, result_values_string, expected_column_count, row_wise);\n+\tlog_message += \"Expected \" + to_string(expected_column_count) + \" columns, but got \" +\n+\t               to_string(result.ColumnCount()) + \" columns\\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintResultError(result, result_values_string, expected_column_count, row_wise);\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::NotCleanlyDivisible(idx_t expected_column_count, idx_t actual_column_count) {\n-\tPrintErrorHeader(\"Error in test!\");\n-\tPrintLineSep();\n+string SQLLogicTestLogger::NotCleanlyDivisible(idx_t expected_column_count, idx_t actual_column_count) {\n+\tstring log_message = PrintErrorHeader(\"Error in test!\");\n+\tlog_message += PrintLineSep();\n \tfprintf(stderr, \"Expected %d columns, but %d values were supplied\\n\", (int)expected_column_count,\n \t        (int)actual_column_count);\n \tfprintf(stderr, \"This is not cleanly divisible (i.e. the last row does not have enough values)\\n\");\n+\tlog_message += \"Expected \" + to_string(expected_column_count) + \" columns, but \" + to_string(actual_column_count) +\n+\t               \" values were supplied\\n\";\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::WrongRowCount(idx_t expected_rows, MaterializedQueryResult &result,\n-                                       const vector<string> &comparison_values, idx_t expected_column_count,\n-                                       bool row_wise) {\n-\tPrintErrorHeader(\"Wrong row count in query!\");\n+string SQLLogicTestLogger::WrongRowCount(idx_t expected_rows, MaterializedQueryResult &result,\n+                                         const vector<string> &comparison_values, idx_t expected_column_count,\n+                                         bool row_wise) {\n+\tstring log_message = PrintErrorHeader(\"Wrong row count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_rows << termcolor::reset << \" rows, but got \"\n \t          << termcolor::bold << result.RowCount() << termcolor::reset << \" rows\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintResultError(result, comparison_values, expected_column_count, row_wise);\n+\tlog_message +=\n+\t    \"Expected \" + to_string(expected_rows) + \" rows, but got \" + to_string(result.RowCount()) + \" rows\\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintResultError(result, comparison_values, expected_column_count, row_wise);\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::ColumnCountMismatchCorrectResult(idx_t original_expected_columns, idx_t expected_column_count,\n-                                                          MaterializedQueryResult &result) {\n-\tPrintLineSep();\n-\tPrintErrorHeader(\"Wrong column count in query!\");\n+string SQLLogicTestLogger::ColumnCountMismatchCorrectResult(idx_t original_expected_columns,\n+                                                            idx_t expected_column_count,\n+                                                            MaterializedQueryResult &result) {\n+\tstring log_message = PrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Wrong column count in query!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << original_expected_columns << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << expected_column_count << termcolor::reset << \" columns\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n \tstd::cerr << \"The expected result \" << termcolor::bold << \"matched\" << termcolor::reset << \" the query result.\"\n \t          << std::endl;\n+\tlog_message += PrintLineSep();\n \tstd::cerr << termcolor::bold << \"Suggested fix: modify header to \\\"\" << termcolor::green << \"query \"\n \t          << string(result.ColumnCount(), 'I') << termcolor::reset << termcolor::bold << \"\\\"\" << termcolor::reset\n \t          << std::endl;\n-\tPrintLineSep();\n+\tlog_message += \"The expected result matched the query result.\\n\";\n+\tlog_message += \"Suggested fix: modify header to \\\" query \" + string(result.ColumnCount(), 'I') + \"\\\"\\n\";\n+\tlog_message += PrintLineSep();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count) {\n-\tPrintLineSep();\n-\tPrintErrorHeader(\"Error in test! Column count mismatch after splitting on tab on row \" + to_string(row_number) +\n-\t                 \"!\");\n+string SQLLogicTestLogger::SplitMismatch(idx_t row_number, idx_t expected_column_count, idx_t split_count) {\n+\tstring log_message = PrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Error in test! Column count mismatch after splitting on tab on row \" +\n+\t                                to_string(row_number) + \"!\");\n \tstd::cerr << \"Expected \" << termcolor::bold << expected_column_count << termcolor::reset << \" columns, but got \"\n \t          << termcolor::bold << split_count << termcolor::reset << \" columns\" << std::endl;\n \tstd::cerr << \"Does the result contain tab values? In that case, place every value on a single row.\" << std::endl;\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+\tlog_message +=\n+\t    \"Expected \" + to_string(expected_column_count) + \" columns, but got \" + to_string(split_count) + \" columns\\n\";\n+\tlog_message += \"Does the result contain tab values? In that case, place every value on a single row.\\n\";\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result) {\n+string SQLLogicTestLogger::WrongResultHash(QueryResult *expected_result, MaterializedQueryResult &result) {\n+\tstring log_message = \"\";\n \tif (expected_result) {\n \t\texpected_result->Print();\n+\t\tlog_message += expected_result->ToString();\n \t} else {\n \t\tstd::cerr << \"???\" << std::endl;\n+\t\tlog_message += \"???\\n\";\n \t}\n-\tPrintErrorHeader(\"Wrong result hash!\");\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n-\tPrintHeader(\"Expected result:\");\n-\tPrintLineSep();\n-\tPrintHeader(\"Actual result:\");\n-\tPrintLineSep();\n+\tlog_message += PrintErrorHeader(\"Wrong result hash!\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintHeader(\"Expected result:\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintHeader(\"Actual result:\");\n+\tlog_message += PrintLineSep();\n \tresult.Print();\n+\tlog_message += result.ToString();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result) {\n-\tPrintErrorHeader(!expect_ok ? \"Query unexpectedly succeeded!\" : \"Query unexpectedly failed!\");\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintLineSep();\n+string SQLLogicTestLogger::UnexpectedStatement(bool expect_ok, MaterializedQueryResult &result) {\n+\tstring log_message = PrintErrorHeader(!expect_ok ? \"Query unexpectedly succeeded!\" : \"Query unexpectedly failed!\");\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintLineSep();\n+\tlog_message += result.ToString() + \"\\n\";\n \tresult.Print();\n+\treturn log_message;\n }\n \n-void SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {\n-\tPrintErrorHeader(\"Query failed, but error message did not match expected error message: \" + expected_error);\n-\tPrintLineSep();\n-\tPrintSQL();\n-\tPrintHeader(\"Actual result:\");\n-\tPrintLineSep();\n+string SQLLogicTestLogger::ExpectedErrorMismatch(const string &expected_error, MaterializedQueryResult &result) {\n+\tstring log_message =\n+\t    PrintErrorHeader(\"Query failed, but error message did not match expected error message: \" + expected_error);\n+\tlog_message += PrintLineSep();\n+\tlog_message += PrintSQL();\n+\tlog_message += PrintHeader(\"Actual result:\");\n+\tlog_message += PrintLineSep();\n \tresult.Print();\n+\tlog_message += result.ToString();",
        "comment_created_at": "2025-04-02T13:37:53+00:00",
        "comment_author": "hmeriann",
        "comment_body": "I thought I could only do it if I touch the `Printer::Print`, but after discussion with @Tmonster I understood how can work around",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1340583804",
    "pr_number": 9014,
    "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
    "created_at": "2023-09-28T19:28:09+00:00",
    "commented_code": "return std::move(result);\n }\n \n+void PhysicalTableInOutFunction::PrepareOrdinality(DataChunk &chunk, idx_t &ord_index, bool &ord_reset) const {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1340583804",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 9014,
        "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
        "discussion_id": "1340583804",
        "commented_code": "@@ -52,14 +54,30 @@ unique_ptr<GlobalOperatorState> PhysicalTableInOutFunction::GetGlobalOperatorSta\n \treturn std::move(result);\n }\n \n+void PhysicalTableInOutFunction::PrepareOrdinality(DataChunk &chunk, idx_t &ord_index, bool &ord_reset) const {",
        "comment_created_at": "2023-09-28T19:28:09+00:00",
        "comment_author": "Tishj",
        "comment_body": "Can we deduplicate this logic by making an OrdinalityData struct that encapsulates this\r\n\r\nInstead of creating this method on both the PhysicalTableInOut and PhysicalTableScan",
        "pr_file_module": null
      },
      {
        "comment_id": "1341444432",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 9014,
        "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
        "discussion_id": "1340583804",
        "commented_code": "@@ -52,14 +54,30 @@ unique_ptr<GlobalOperatorState> PhysicalTableInOutFunction::GetGlobalOperatorSta\n \treturn std::move(result);\n }\n \n+void PhysicalTableInOutFunction::PrepareOrdinality(DataChunk &chunk, idx_t &ord_index, bool &ord_reset) const {",
        "comment_created_at": "2023-09-29T14:34:32+00:00",
        "comment_author": "niykko",
        "comment_body": "The new struct OrdinalityData now contains static functions that take care of this logic",
        "pr_file_module": null
      }
    ]
  }
]