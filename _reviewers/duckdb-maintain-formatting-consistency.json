[
  {
    "discussion_id": "2071322192",
    "pr_number": 17305,
    "pr_file": "scripts/format.py",
    "created_at": "2025-05-02T09:05:03+00:00",
    "commented_code": "-#!/usr/bin/python\n-\n-# this script is used to format the source directory\n+#!/usr/bin/python3\n \n import os\n-import time\n-import sys\n-import inspect\n import subprocess\n-import difflib\n-import re\n-import tempfile\n-import uuid\n+import sys\n+import argparse\n import concurrent.futures\n-from python_helpers import open_utf8\n-\n-try:\n-    ver = subprocess.check_output(('black', '--version'), text=True)\n-    if int(ver.split(' ')[1].split('.')[0]) < 24:\n-        print('you need to run `pip install \"black>=24\"`', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install \"black>=24\"`', e)\n-    exit(-1)\n-\n-try:\n-    ver = subprocess.check_output(('clang-format', '--version'), text=True)\n-    if '11.' not in ver:\n-        print('you need to run `pip install clang_format==11.0.1 - `', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install clang_format==11.0.1 - `', e)\n-    exit(-1)\n-\n-cpp_format_command = 'clang-format --sort-includes=0 -style=file'\n-cmake_format_command = 'cmake-format'\n+import difflib\n+from pathlib import Path\n \n-try:\n-    subprocess.check_output(('cmake-format', '--version'), text=True)\n-except Exception as e:\n-    print('you need to run `pip install cmake-format`', e)\n-    exit(-1)\n \n-extensions = [\n-    '.cpp',\n-    '.ipp',\n-    '.c',\n-    '.hpp',\n-    '.h',\n-    '.cc',\n-    '.hh',\n-    'CMakeLists.txt',\n-    '.test',\n-    '.test_slow',\n-    '.test_coverage',\n-    '.benchmark',\n-    '.py',\n-    '.java',\n+# Check formatter versions\n+def check_formatter_version(command, version_key, min_version, install_instruction):\n+    try:\n+        output = subprocess.check_output(command, text=True).strip()\n+        # Extract version number for clang-format (e.g., \"11.0.1\" from \"clang-format version 11.0.1...\")\n+        if command[0] == \"clang-format\":\n+            version = output.split()[2].split(\".\")[0]\n+        elif command[0] == \"black\":\n+            version = output.split()[1].split(\".\")[0]\n+        else:\n+            version = output.split()[0].split(\".\")[0]\n+        version_key_mismatch = version_key is not None and version_key not in output\n+        if version_key_mismatch or int(version) < min_version:\n+            print(f\"Please install {install_instruction}\")\n+            print(f\"Required: {min_version}. Present: {version}\")\n+            sys.exit(1)\n+    except Exception as e:\n+        breakpoint()\n+        print(f\"Please install {install_instruction}: {e}\")\n+        sys.exit(1)\n+\n+\n+# Configuration\n+EXTENSIONS = [\n+    \".cpp\",\n+    \".ipp\",\n+    \".c\",\n+    \".hpp\",\n+    \".h\",\n+    \".cc\",\n+    \".hh\",\n+    \"CMakeLists.txt\",\n+    \".py\",\n+    \".java\",\n ]\n-formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension', 'scripts']\n-ignored_files = [\n-    'tpch_constants.hpp',\n-    'tpcds_constants.hpp',\n-    '_generated',\n-    'tpce_flat_input.hpp',\n-    'test_csv_header.hpp',\n-    'duckdb.cpp',\n-    'duckdb.hpp',\n-    'json.hpp',\n-    'sqlite3.h',\n-    'shell.c',\n-    'termcolor.hpp',\n-    'test_insert_invalid.test',\n-    'httplib.hpp',\n-    'os_win.c',\n-    'glob.c',\n-    'printf.c',\n-    'helper.hpp',\n-    'single_thread_ptr.hpp',\n-    'types.hpp',\n-    'default_views.cpp',\n-    'default_functions.cpp',\n-    'release.h',\n-    'genrand.cpp',\n-    'address.cpp',\n-    'visualizer_constants.hpp',\n-    'icu-collate.cpp',\n-    'icu-collate.hpp',\n-    'yyjson.cpp',\n-    'yyjson.hpp',\n-    'duckdb_pdqsort.hpp',\n-    'stubdata.cpp',\n-    'nf_calendar.cpp',\n-    'nf_calendar.h',\n-    'nf_localedata.cpp',\n-    'nf_localedata.h',\n-    'nf_zformat.cpp',\n-    'nf_zformat.h',\n-    'expr.cc',\n-    'function_list.cpp',\n-    'inlined_grammar.hpp',\n+FORMATTED_DIRECTORIES = [\n+    \"src\",\n+    \"benchmark\",\n+    \"test\",\n+    \"tools\",\n+    \"examples\",\n+    \"extension\",\n+    \"scripts\",\n ]\n-ignored_directories = [\n-    '.eggs',\n-    '__pycache__',\n-    'dbgen',\n-    os.path.join('tools', 'pythonpkg', 'duckdb'),\n-    os.path.join('tools', 'pythonpkg', 'build'),\n-    os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n-    os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n-    os.path.join('extension', 'tpcds', 'dsdgen'),\n-    os.path.join('extension', 'jemalloc', 'jemalloc'),\n-    os.path.join('extension', 'icu', 'third_party'),\n-    os.path.join('tools', 'nodejs', 'src', 'duckdb'),\n+IGNORED_FILES = {\n+    \"tpch_constants.hpp\",\n+    \"tpcds_constants.hpp\",\n+    \"_generated\",\n+    \"tpce_flat_input.hpp\",\n+    \"test_csv_header.hpp\",\n+    \"duckdb.cpp\",\n+    \"duckdb.hpp\",\n+    \"json.hpp\",\n+    \"sqlite3.h\",\n+    \"shell.c\",\n+    \"termcolor.hpp\",\n+    \"test_insert_invalid.test\",\n+    \"httplib.hpp\",\n+    \"os_win.c\",\n+    \"glob.c\",\n+    \"printf.c\",\n+    \"helper.hpp\",\n+    \"single_thread_ptr.hpp\",\n+    \"types.hpp\",\n+    \"default_views.cpp\",\n+    \"default_functions.cpp\",\n+    \"release.h\",\n+    \"genrand.cpp\",\n+    \"address.cpp\",\n+    \"visualizer_constants.hpp\",\n+    \"icu-collate.cpp\",\n+    \"icu-collate.hpp\",\n+    \"yyjson.cpp\",\n+    \"yyjson.hpp\",\n+    \"duckdb_pdqsort.hpp\",\n+    \"stubdata.cpp\",\n+    \"nf_calendar.cpp\",\n+    \"nf_calendar.h\",\n+    \"nf_localedata.cpp\",\n+    \"nf_localedata.h\",\n+    \"nf_zformat.cpp\",\n+    \"nf_zformat.h\",\n+    \"expr.cc\",\n+    \"function_list.cpp\",\n+    \"inlined_grammar.hpp\",\n+}\n+IGNORED_DIRECTORIES = [\n+    \".eggs\",\n+    \"__pycache__\",\n+    \"dbgen\",\n+    \"tools/pythonpkg/duckdb\",\n+    \"tools/pythonpkg/build\",\n+    \"tools/rpkg/src/duckdb\",\n+    \"tools/rpkg/inst/include/cpp11\",\n+    \"extension/tpcds/dsdgen\",\n+    \"extension/jemalloc/jemalloc\",\n+    \"extension/icu/third_party\",\n+    \"tools/nodejs/src/duckdb\",\n ]\n-format_all = False\n-check_only = True\n-confirm = True\n-silent = False\n-force = False\n-\n-\n-def print_usage():\n-    print(\"Usage: python scripts/format.py [revision|--all] [--check|--fix] [--force]\")\n-    print(\n-        \"   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)\"\n-    )\n-    print(\"                  if [revision] is set to --all, all files will be formatted\")\n-    print(\"   --check only prints differences, --fix also fixes the files (--check is default)\")\n-    exit(1)\n \n+FORMAT_COMMANDS = {\n+    \".cpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".ipp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".c\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp at\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".h\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hh\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".cc\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".txt\": [\"cmake-format\", \"-i\"],\n+    \".py\": [\"black\", \"-q\", \"--skip-string-normalization\", \"--line-length\", \"120\"],\n+    \".java\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".test\": [\"cmake-format\", \"-i\"],\n+    \".test_slow\": [\"cmake-format\", \"-i\"],\n+    \".test_coverage\": [\"cmake-format\", \"-i\"],\n+    \".benchmark\": [\"cmake-format\", \"-i\"],\n+}\n \n-if len(sys.argv) == 1:\n-    revision = \"HEAD\"\n-elif len(sys.argv) >= 2:\n-    revision = sys.argv[1]\n-else:\n-    print_usage()\n \n-if len(sys.argv) > 2:\n-    for arg in sys.argv[2:]:\n-        if arg == '--check':\n-            check_only = True\n-        elif arg == '--fix':\n-            check_only = False\n-        elif arg == '--noconfirm':\n-            confirm = False\n-        elif arg == '--confirm':\n-            confirm = True\n-        elif arg == '--silent':\n-            silent = True\n-        elif arg == '--force':\n-            force = True\n-        else:\n-            print_usage()\n-\n-if revision == '--all':\n-    format_all = True\n+# Argument parsing\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Format source code files\")\n+    parser.add_argument(\n+        \"revision\",\n+        nargs=\"?\",\n+        default=\"HEAD\",\n+        help=\"Revision number to format all files (default: HEAD)\",\n+    )\n+    parser.add_argument(\n+        \"--check\",\n+        action=\"store_true\",\n+        help=\"Check formatting without modifying files (default)\",\n+    )\n+    parser.add_argument(\"--all\", action=\"store_true\", help=\"Format all files\")\n+    parser.add_argument(\"--fix\", action=\"store_true\", help=\"Fix formatting issues in files\")\n+    parser.add_argument(\"--force\", action=\"store_true\", help=\"Format even non-standard files\")\n+    parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress output of formatted files\")\n+    parser.add_argument(\"--noconfirm\", action=\"store_true\", help=\"Skip confirmation prompt for fixing\")\n+    return parser.parse_args()\n \n \n+# File filtering\n def file_is_ignored(full_path):\n-    if os.path.basename(full_path) in ignored_files:\n-        return True\n-    dirnames = os.path.sep.join(full_path.split(os.path.sep)[:-1])\n-    for ignored_directory in ignored_directories:\n-        if ignored_directory in dirnames:\n-            return True\n-    return False\n+    return Path(full_path).name in IGNORED_FILES or any(ignored in str(full_path) for ignored in IGNORED_DIRECTORIES)\n \n \n def can_format_file(full_path):\n-    global extensions, formatted_directories, ignored_files\n-    if not os.path.isfile(full_path):\n+    if not Path(full_path).is_file():\n         return False\n-    fname = full_path.split(os.path.sep)[-1]\n-    found = False\n-    # check file extension\n-    for ext in extensions:\n-        if full_path.endswith(ext):\n-            found = True\n-            break\n-    if not found:\n+    if not any(full_path.endswith(ext) for ext in EXTENSIONS):\n         return False\n-    # check ignored files\n     if file_is_ignored(full_path):\n         return False\n-    # now check file directory\n-    for dname in formatted_directories:\n-        if full_path.startswith(dname):\n-            return True\n-    return False\n-\n-\n-action = \"Formatting\"\n-if check_only:\n-    action = \"Checking\"\n+    return any(full_path.startswith(d) for d in FORMATTED_DIRECTORIES)\n \n \n+# File collection\n def get_changed_files(revision):\n-    proc = subprocess.Popen(['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)\n-    files = proc.stdout.read().decode('utf8').split('\n')\n-    changed_files = []\n-    for f in files:\n-        if not can_format_file(f):\n-            continue\n-        if file_is_ignored(f):\n-            continue\n-        changed_files.append(f)\n-    return changed_files\n-\n-\n-if os.path.isfile(revision):\n-    print(action + \" individual file: \" + revision)\n-    changed_files = [revision]\n-elif os.path.isdir(revision):\n-    print(action + \" files in directory: \" + revision)\n-    changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]\n+    result = subprocess.run([\"git\", \"diff\", \"--name-only\", revision], capture_output=True, text=True)\n+    return [f for f in result.stdout.splitlines() if can_format_file(f) and not file_is_ignored(f)]\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-elif not format_all:\n-    if revision == 'main':\n-        # fetch new changes when comparing to the master\n-        os.system(\"git fetch origin main:main\")\n-    print(action + \" since branch or revision: \" + revision)\n-    changed_files = get_changed_files(revision)\n-    if len(changed_files) == 0:\n-        print(\"No changed files found!\")\n-        exit(0)\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-else:\n-    print(action + \" all files\")\n-\n-if confirm and not check_only:\n-    print(\"The files listed above will be reformatted.\")\n-    result = input(\"Continue with changes (y/n)?\n\")\n-    if result != 'y':\n-        print(\"Aborting.\")\n-        exit(0)\n-\n-format_commands = {\n-    '.cpp': cpp_format_command,\n-    '.ipp': cpp_format_command,\n-    '.c': cpp_format_command,\n-    '.hpp': cpp_format_command,\n-    '.h': cpp_format_command,\n-    '.hh': cpp_format_command,\n-    '.cc': cpp_format_command,\n-    '.txt': cmake_format_command,\n-    '.py': 'black --quiet - --skip-string-normalization --line-length 120 --stdin-filename',\n-    '.java': cpp_format_command,\n-}\n-\n-difference_files = []\n-\n-header_top = \"//===----------------------------------------------------------------------===//\n\"\n-header_top += \"//                         DuckDB\n\" + \"//\n\"\n-header_bottom = \"//\n\" + \"//\n\"\n-header_bottom += \"//===----------------------------------------------------------------------===//\n\n\"\n-base_dir = os.path.join(os.getcwd(), 'src/include')\n+def format_directory(directory):\n+    files = []\n+    for path in Path(directory).rglob(\"*\"):\n+        if path.is_file() and can_format_file(str(path)):\n+            files.append(str(path))\n+    return files\n \n \n-def get_formatted_text(f, full_path, directory, ext):\n-    if not can_format_file(full_path):\n+# Formatting logic\n+def format_file(full_path, check_only, force, silent):\n+    ext = Path(full_path).suffix\n+    if ext not in FORMAT_COMMANDS:\n         if not force:\n-            print(\n-                \"File \"\n-                + full_path\n-                + \" is not normally formatted - but attempted to format anyway. Use --force if formatting is desirable\"\n-            )\n-            exit(1)\n-    if f == 'list.hpp':\n-        # fill in list file\n-        file_list = [\n-            os.path.join(dp, f)\n-            for dp, dn, filenames in os.walk(directory)\n-            for f in filenames\n-            if os.path.splitext(f)[1] == '.hpp' and not f.endswith(\"list.hpp\")\n-        ]\n-        file_list = [x.replace('src/include/', '') for x in file_list]\n-        file_list.sort()\n-        result = \"\"\n-        for x in file_list:\n-            result += '#include \"%s\"\n' % (x)\n-        return result\n-\n-    if ext == \".hpp\" and directory.startswith(\"src/include\"):\n-        with open_utf8(full_path, 'r') as f:\n-            lines = f.readlines()\n-\n-        # format header in files\n-        header_middle = \"// \" + os.path.relpath(full_path, base_dir) + \"\n\"\n-        text = header_top + header_middle + header_bottom\n-        is_old_header = True\n-        for line in lines:\n-            if not (line.startswith(\"//\") or line.startswith(\"\n\")) and is_old_header:\n-                is_old_header = False\n-            if not is_old_header:\n-                text += line\n-\n-    if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2071322192",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17305,
        "pr_file": "scripts/format.py",
        "discussion_id": "2071322192",
        "commented_code": "@@ -1,467 +1,299 @@\n-#!/usr/bin/python\n-\n-# this script is used to format the source directory\n+#!/usr/bin/python3\n \n import os\n-import time\n-import sys\n-import inspect\n import subprocess\n-import difflib\n-import re\n-import tempfile\n-import uuid\n+import sys\n+import argparse\n import concurrent.futures\n-from python_helpers import open_utf8\n-\n-try:\n-    ver = subprocess.check_output(('black', '--version'), text=True)\n-    if int(ver.split(' ')[1].split('.')[0]) < 24:\n-        print('you need to run `pip install \"black>=24\"`', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install \"black>=24\"`', e)\n-    exit(-1)\n-\n-try:\n-    ver = subprocess.check_output(('clang-format', '--version'), text=True)\n-    if '11.' not in ver:\n-        print('you need to run `pip install clang_format==11.0.1 - `', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install clang_format==11.0.1 - `', e)\n-    exit(-1)\n-\n-cpp_format_command = 'clang-format --sort-includes=0 -style=file'\n-cmake_format_command = 'cmake-format'\n+import difflib\n+from pathlib import Path\n \n-try:\n-    subprocess.check_output(('cmake-format', '--version'), text=True)\n-except Exception as e:\n-    print('you need to run `pip install cmake-format`', e)\n-    exit(-1)\n \n-extensions = [\n-    '.cpp',\n-    '.ipp',\n-    '.c',\n-    '.hpp',\n-    '.h',\n-    '.cc',\n-    '.hh',\n-    'CMakeLists.txt',\n-    '.test',\n-    '.test_slow',\n-    '.test_coverage',\n-    '.benchmark',\n-    '.py',\n-    '.java',\n+# Check formatter versions\n+def check_formatter_version(command, version_key, min_version, install_instruction):\n+    try:\n+        output = subprocess.check_output(command, text=True).strip()\n+        # Extract version number for clang-format (e.g., \"11.0.1\" from \"clang-format version 11.0.1...\")\n+        if command[0] == \"clang-format\":\n+            version = output.split()[2].split(\".\")[0]\n+        elif command[0] == \"black\":\n+            version = output.split()[1].split(\".\")[0]\n+        else:\n+            version = output.split()[0].split(\".\")[0]\n+        version_key_mismatch = version_key is not None and version_key not in output\n+        if version_key_mismatch or int(version) < min_version:\n+            print(f\"Please install {install_instruction}\")\n+            print(f\"Required: {min_version}. Present: {version}\")\n+            sys.exit(1)\n+    except Exception as e:\n+        breakpoint()\n+        print(f\"Please install {install_instruction}: {e}\")\n+        sys.exit(1)\n+\n+\n+# Configuration\n+EXTENSIONS = [\n+    \".cpp\",\n+    \".ipp\",\n+    \".c\",\n+    \".hpp\",\n+    \".h\",\n+    \".cc\",\n+    \".hh\",\n+    \"CMakeLists.txt\",\n+    \".py\",\n+    \".java\",\n ]\n-formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension', 'scripts']\n-ignored_files = [\n-    'tpch_constants.hpp',\n-    'tpcds_constants.hpp',\n-    '_generated',\n-    'tpce_flat_input.hpp',\n-    'test_csv_header.hpp',\n-    'duckdb.cpp',\n-    'duckdb.hpp',\n-    'json.hpp',\n-    'sqlite3.h',\n-    'shell.c',\n-    'termcolor.hpp',\n-    'test_insert_invalid.test',\n-    'httplib.hpp',\n-    'os_win.c',\n-    'glob.c',\n-    'printf.c',\n-    'helper.hpp',\n-    'single_thread_ptr.hpp',\n-    'types.hpp',\n-    'default_views.cpp',\n-    'default_functions.cpp',\n-    'release.h',\n-    'genrand.cpp',\n-    'address.cpp',\n-    'visualizer_constants.hpp',\n-    'icu-collate.cpp',\n-    'icu-collate.hpp',\n-    'yyjson.cpp',\n-    'yyjson.hpp',\n-    'duckdb_pdqsort.hpp',\n-    'stubdata.cpp',\n-    'nf_calendar.cpp',\n-    'nf_calendar.h',\n-    'nf_localedata.cpp',\n-    'nf_localedata.h',\n-    'nf_zformat.cpp',\n-    'nf_zformat.h',\n-    'expr.cc',\n-    'function_list.cpp',\n-    'inlined_grammar.hpp',\n+FORMATTED_DIRECTORIES = [\n+    \"src\",\n+    \"benchmark\",\n+    \"test\",\n+    \"tools\",\n+    \"examples\",\n+    \"extension\",\n+    \"scripts\",\n ]\n-ignored_directories = [\n-    '.eggs',\n-    '__pycache__',\n-    'dbgen',\n-    os.path.join('tools', 'pythonpkg', 'duckdb'),\n-    os.path.join('tools', 'pythonpkg', 'build'),\n-    os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n-    os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n-    os.path.join('extension', 'tpcds', 'dsdgen'),\n-    os.path.join('extension', 'jemalloc', 'jemalloc'),\n-    os.path.join('extension', 'icu', 'third_party'),\n-    os.path.join('tools', 'nodejs', 'src', 'duckdb'),\n+IGNORED_FILES = {\n+    \"tpch_constants.hpp\",\n+    \"tpcds_constants.hpp\",\n+    \"_generated\",\n+    \"tpce_flat_input.hpp\",\n+    \"test_csv_header.hpp\",\n+    \"duckdb.cpp\",\n+    \"duckdb.hpp\",\n+    \"json.hpp\",\n+    \"sqlite3.h\",\n+    \"shell.c\",\n+    \"termcolor.hpp\",\n+    \"test_insert_invalid.test\",\n+    \"httplib.hpp\",\n+    \"os_win.c\",\n+    \"glob.c\",\n+    \"printf.c\",\n+    \"helper.hpp\",\n+    \"single_thread_ptr.hpp\",\n+    \"types.hpp\",\n+    \"default_views.cpp\",\n+    \"default_functions.cpp\",\n+    \"release.h\",\n+    \"genrand.cpp\",\n+    \"address.cpp\",\n+    \"visualizer_constants.hpp\",\n+    \"icu-collate.cpp\",\n+    \"icu-collate.hpp\",\n+    \"yyjson.cpp\",\n+    \"yyjson.hpp\",\n+    \"duckdb_pdqsort.hpp\",\n+    \"stubdata.cpp\",\n+    \"nf_calendar.cpp\",\n+    \"nf_calendar.h\",\n+    \"nf_localedata.cpp\",\n+    \"nf_localedata.h\",\n+    \"nf_zformat.cpp\",\n+    \"nf_zformat.h\",\n+    \"expr.cc\",\n+    \"function_list.cpp\",\n+    \"inlined_grammar.hpp\",\n+}\n+IGNORED_DIRECTORIES = [\n+    \".eggs\",\n+    \"__pycache__\",\n+    \"dbgen\",\n+    \"tools/pythonpkg/duckdb\",\n+    \"tools/pythonpkg/build\",\n+    \"tools/rpkg/src/duckdb\",\n+    \"tools/rpkg/inst/include/cpp11\",\n+    \"extension/tpcds/dsdgen\",\n+    \"extension/jemalloc/jemalloc\",\n+    \"extension/icu/third_party\",\n+    \"tools/nodejs/src/duckdb\",\n ]\n-format_all = False\n-check_only = True\n-confirm = True\n-silent = False\n-force = False\n-\n-\n-def print_usage():\n-    print(\"Usage: python scripts/format.py [revision|--all] [--check|--fix] [--force]\")\n-    print(\n-        \"   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)\"\n-    )\n-    print(\"                  if [revision] is set to --all, all files will be formatted\")\n-    print(\"   --check only prints differences, --fix also fixes the files (--check is default)\")\n-    exit(1)\n \n+FORMAT_COMMANDS = {\n+    \".cpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".ipp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".c\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp at\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".h\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hh\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".cc\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".txt\": [\"cmake-format\", \"-i\"],\n+    \".py\": [\"black\", \"-q\", \"--skip-string-normalization\", \"--line-length\", \"120\"],\n+    \".java\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".test\": [\"cmake-format\", \"-i\"],\n+    \".test_slow\": [\"cmake-format\", \"-i\"],\n+    \".test_coverage\": [\"cmake-format\", \"-i\"],\n+    \".benchmark\": [\"cmake-format\", \"-i\"],\n+}\n \n-if len(sys.argv) == 1:\n-    revision = \"HEAD\"\n-elif len(sys.argv) >= 2:\n-    revision = sys.argv[1]\n-else:\n-    print_usage()\n \n-if len(sys.argv) > 2:\n-    for arg in sys.argv[2:]:\n-        if arg == '--check':\n-            check_only = True\n-        elif arg == '--fix':\n-            check_only = False\n-        elif arg == '--noconfirm':\n-            confirm = False\n-        elif arg == '--confirm':\n-            confirm = True\n-        elif arg == '--silent':\n-            silent = True\n-        elif arg == '--force':\n-            force = True\n-        else:\n-            print_usage()\n-\n-if revision == '--all':\n-    format_all = True\n+# Argument parsing\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Format source code files\")\n+    parser.add_argument(\n+        \"revision\",\n+        nargs=\"?\",\n+        default=\"HEAD\",\n+        help=\"Revision number to format all files (default: HEAD)\",\n+    )\n+    parser.add_argument(\n+        \"--check\",\n+        action=\"store_true\",\n+        help=\"Check formatting without modifying files (default)\",\n+    )\n+    parser.add_argument(\"--all\", action=\"store_true\", help=\"Format all files\")\n+    parser.add_argument(\"--fix\", action=\"store_true\", help=\"Fix formatting issues in files\")\n+    parser.add_argument(\"--force\", action=\"store_true\", help=\"Format even non-standard files\")\n+    parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress output of formatted files\")\n+    parser.add_argument(\"--noconfirm\", action=\"store_true\", help=\"Skip confirmation prompt for fixing\")\n+    return parser.parse_args()\n \n \n+# File filtering\n def file_is_ignored(full_path):\n-    if os.path.basename(full_path) in ignored_files:\n-        return True\n-    dirnames = os.path.sep.join(full_path.split(os.path.sep)[:-1])\n-    for ignored_directory in ignored_directories:\n-        if ignored_directory in dirnames:\n-            return True\n-    return False\n+    return Path(full_path).name in IGNORED_FILES or any(ignored in str(full_path) for ignored in IGNORED_DIRECTORIES)\n \n \n def can_format_file(full_path):\n-    global extensions, formatted_directories, ignored_files\n-    if not os.path.isfile(full_path):\n+    if not Path(full_path).is_file():\n         return False\n-    fname = full_path.split(os.path.sep)[-1]\n-    found = False\n-    # check file extension\n-    for ext in extensions:\n-        if full_path.endswith(ext):\n-            found = True\n-            break\n-    if not found:\n+    if not any(full_path.endswith(ext) for ext in EXTENSIONS):\n         return False\n-    # check ignored files\n     if file_is_ignored(full_path):\n         return False\n-    # now check file directory\n-    for dname in formatted_directories:\n-        if full_path.startswith(dname):\n-            return True\n-    return False\n-\n-\n-action = \"Formatting\"\n-if check_only:\n-    action = \"Checking\"\n+    return any(full_path.startswith(d) for d in FORMATTED_DIRECTORIES)\n \n \n+# File collection\n def get_changed_files(revision):\n-    proc = subprocess.Popen(['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)\n-    files = proc.stdout.read().decode('utf8').split('\\n')\n-    changed_files = []\n-    for f in files:\n-        if not can_format_file(f):\n-            continue\n-        if file_is_ignored(f):\n-            continue\n-        changed_files.append(f)\n-    return changed_files\n-\n-\n-if os.path.isfile(revision):\n-    print(action + \" individual file: \" + revision)\n-    changed_files = [revision]\n-elif os.path.isdir(revision):\n-    print(action + \" files in directory: \" + revision)\n-    changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]\n+    result = subprocess.run([\"git\", \"diff\", \"--name-only\", revision], capture_output=True, text=True)\n+    return [f for f in result.stdout.splitlines() if can_format_file(f) and not file_is_ignored(f)]\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-elif not format_all:\n-    if revision == 'main':\n-        # fetch new changes when comparing to the master\n-        os.system(\"git fetch origin main:main\")\n-    print(action + \" since branch or revision: \" + revision)\n-    changed_files = get_changed_files(revision)\n-    if len(changed_files) == 0:\n-        print(\"No changed files found!\")\n-        exit(0)\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-else:\n-    print(action + \" all files\")\n-\n-if confirm and not check_only:\n-    print(\"The files listed above will be reformatted.\")\n-    result = input(\"Continue with changes (y/n)?\\n\")\n-    if result != 'y':\n-        print(\"Aborting.\")\n-        exit(0)\n-\n-format_commands = {\n-    '.cpp': cpp_format_command,\n-    '.ipp': cpp_format_command,\n-    '.c': cpp_format_command,\n-    '.hpp': cpp_format_command,\n-    '.h': cpp_format_command,\n-    '.hh': cpp_format_command,\n-    '.cc': cpp_format_command,\n-    '.txt': cmake_format_command,\n-    '.py': 'black --quiet - --skip-string-normalization --line-length 120 --stdin-filename',\n-    '.java': cpp_format_command,\n-}\n-\n-difference_files = []\n-\n-header_top = \"//===----------------------------------------------------------------------===//\\n\"\n-header_top += \"//                         DuckDB\\n\" + \"//\\n\"\n-header_bottom = \"//\\n\" + \"//\\n\"\n-header_bottom += \"//===----------------------------------------------------------------------===//\\n\\n\"\n-base_dir = os.path.join(os.getcwd(), 'src/include')\n+def format_directory(directory):\n+    files = []\n+    for path in Path(directory).rglob(\"*\"):\n+        if path.is_file() and can_format_file(str(path)):\n+            files.append(str(path))\n+    return files\n \n \n-def get_formatted_text(f, full_path, directory, ext):\n-    if not can_format_file(full_path):\n+# Formatting logic\n+def format_file(full_path, check_only, force, silent):\n+    ext = Path(full_path).suffix\n+    if ext not in FORMAT_COMMANDS:\n         if not force:\n-            print(\n-                \"File \"\n-                + full_path\n-                + \" is not normally formatted - but attempted to format anyway. Use --force if formatting is desirable\"\n-            )\n-            exit(1)\n-    if f == 'list.hpp':\n-        # fill in list file\n-        file_list = [\n-            os.path.join(dp, f)\n-            for dp, dn, filenames in os.walk(directory)\n-            for f in filenames\n-            if os.path.splitext(f)[1] == '.hpp' and not f.endswith(\"list.hpp\")\n-        ]\n-        file_list = [x.replace('src/include/', '') for x in file_list]\n-        file_list.sort()\n-        result = \"\"\n-        for x in file_list:\n-            result += '#include \"%s\"\\n' % (x)\n-        return result\n-\n-    if ext == \".hpp\" and directory.startswith(\"src/include\"):\n-        with open_utf8(full_path, 'r') as f:\n-            lines = f.readlines()\n-\n-        # format header in files\n-        header_middle = \"// \" + os.path.relpath(full_path, base_dir) + \"\\n\"\n-        text = header_top + header_middle + header_bottom\n-        is_old_header = True\n-        for line in lines:\n-            if not (line.startswith(\"//\") or line.startswith(\"\\n\")) and is_old_header:\n-                is_old_header = False\n-            if not is_old_header:\n-                text += line\n-\n-    if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':",
        "comment_created_at": "2025-05-02T09:05:03+00:00",
        "comment_author": "Tishj",
        "comment_body": "If you're touching this file, you might want to preserve the existing behavior\r\nWith removing all of these lines I doubt that this behaves the same.",
        "pr_file_module": null
      },
      {
        "comment_id": "2071841064",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17305,
        "pr_file": "scripts/format.py",
        "discussion_id": "2071322192",
        "commented_code": "@@ -1,467 +1,299 @@\n-#!/usr/bin/python\n-\n-# this script is used to format the source directory\n+#!/usr/bin/python3\n \n import os\n-import time\n-import sys\n-import inspect\n import subprocess\n-import difflib\n-import re\n-import tempfile\n-import uuid\n+import sys\n+import argparse\n import concurrent.futures\n-from python_helpers import open_utf8\n-\n-try:\n-    ver = subprocess.check_output(('black', '--version'), text=True)\n-    if int(ver.split(' ')[1].split('.')[0]) < 24:\n-        print('you need to run `pip install \"black>=24\"`', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install \"black>=24\"`', e)\n-    exit(-1)\n-\n-try:\n-    ver = subprocess.check_output(('clang-format', '--version'), text=True)\n-    if '11.' not in ver:\n-        print('you need to run `pip install clang_format==11.0.1 - `', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install clang_format==11.0.1 - `', e)\n-    exit(-1)\n-\n-cpp_format_command = 'clang-format --sort-includes=0 -style=file'\n-cmake_format_command = 'cmake-format'\n+import difflib\n+from pathlib import Path\n \n-try:\n-    subprocess.check_output(('cmake-format', '--version'), text=True)\n-except Exception as e:\n-    print('you need to run `pip install cmake-format`', e)\n-    exit(-1)\n \n-extensions = [\n-    '.cpp',\n-    '.ipp',\n-    '.c',\n-    '.hpp',\n-    '.h',\n-    '.cc',\n-    '.hh',\n-    'CMakeLists.txt',\n-    '.test',\n-    '.test_slow',\n-    '.test_coverage',\n-    '.benchmark',\n-    '.py',\n-    '.java',\n+# Check formatter versions\n+def check_formatter_version(command, version_key, min_version, install_instruction):\n+    try:\n+        output = subprocess.check_output(command, text=True).strip()\n+        # Extract version number for clang-format (e.g., \"11.0.1\" from \"clang-format version 11.0.1...\")\n+        if command[0] == \"clang-format\":\n+            version = output.split()[2].split(\".\")[0]\n+        elif command[0] == \"black\":\n+            version = output.split()[1].split(\".\")[0]\n+        else:\n+            version = output.split()[0].split(\".\")[0]\n+        version_key_mismatch = version_key is not None and version_key not in output\n+        if version_key_mismatch or int(version) < min_version:\n+            print(f\"Please install {install_instruction}\")\n+            print(f\"Required: {min_version}. Present: {version}\")\n+            sys.exit(1)\n+    except Exception as e:\n+        breakpoint()\n+        print(f\"Please install {install_instruction}: {e}\")\n+        sys.exit(1)\n+\n+\n+# Configuration\n+EXTENSIONS = [\n+    \".cpp\",\n+    \".ipp\",\n+    \".c\",\n+    \".hpp\",\n+    \".h\",\n+    \".cc\",\n+    \".hh\",\n+    \"CMakeLists.txt\",\n+    \".py\",\n+    \".java\",\n ]\n-formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension', 'scripts']\n-ignored_files = [\n-    'tpch_constants.hpp',\n-    'tpcds_constants.hpp',\n-    '_generated',\n-    'tpce_flat_input.hpp',\n-    'test_csv_header.hpp',\n-    'duckdb.cpp',\n-    'duckdb.hpp',\n-    'json.hpp',\n-    'sqlite3.h',\n-    'shell.c',\n-    'termcolor.hpp',\n-    'test_insert_invalid.test',\n-    'httplib.hpp',\n-    'os_win.c',\n-    'glob.c',\n-    'printf.c',\n-    'helper.hpp',\n-    'single_thread_ptr.hpp',\n-    'types.hpp',\n-    'default_views.cpp',\n-    'default_functions.cpp',\n-    'release.h',\n-    'genrand.cpp',\n-    'address.cpp',\n-    'visualizer_constants.hpp',\n-    'icu-collate.cpp',\n-    'icu-collate.hpp',\n-    'yyjson.cpp',\n-    'yyjson.hpp',\n-    'duckdb_pdqsort.hpp',\n-    'stubdata.cpp',\n-    'nf_calendar.cpp',\n-    'nf_calendar.h',\n-    'nf_localedata.cpp',\n-    'nf_localedata.h',\n-    'nf_zformat.cpp',\n-    'nf_zformat.h',\n-    'expr.cc',\n-    'function_list.cpp',\n-    'inlined_grammar.hpp',\n+FORMATTED_DIRECTORIES = [\n+    \"src\",\n+    \"benchmark\",\n+    \"test\",\n+    \"tools\",\n+    \"examples\",\n+    \"extension\",\n+    \"scripts\",\n ]\n-ignored_directories = [\n-    '.eggs',\n-    '__pycache__',\n-    'dbgen',\n-    os.path.join('tools', 'pythonpkg', 'duckdb'),\n-    os.path.join('tools', 'pythonpkg', 'build'),\n-    os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n-    os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n-    os.path.join('extension', 'tpcds', 'dsdgen'),\n-    os.path.join('extension', 'jemalloc', 'jemalloc'),\n-    os.path.join('extension', 'icu', 'third_party'),\n-    os.path.join('tools', 'nodejs', 'src', 'duckdb'),\n+IGNORED_FILES = {\n+    \"tpch_constants.hpp\",\n+    \"tpcds_constants.hpp\",\n+    \"_generated\",\n+    \"tpce_flat_input.hpp\",\n+    \"test_csv_header.hpp\",\n+    \"duckdb.cpp\",\n+    \"duckdb.hpp\",\n+    \"json.hpp\",\n+    \"sqlite3.h\",\n+    \"shell.c\",\n+    \"termcolor.hpp\",\n+    \"test_insert_invalid.test\",\n+    \"httplib.hpp\",\n+    \"os_win.c\",\n+    \"glob.c\",\n+    \"printf.c\",\n+    \"helper.hpp\",\n+    \"single_thread_ptr.hpp\",\n+    \"types.hpp\",\n+    \"default_views.cpp\",\n+    \"default_functions.cpp\",\n+    \"release.h\",\n+    \"genrand.cpp\",\n+    \"address.cpp\",\n+    \"visualizer_constants.hpp\",\n+    \"icu-collate.cpp\",\n+    \"icu-collate.hpp\",\n+    \"yyjson.cpp\",\n+    \"yyjson.hpp\",\n+    \"duckdb_pdqsort.hpp\",\n+    \"stubdata.cpp\",\n+    \"nf_calendar.cpp\",\n+    \"nf_calendar.h\",\n+    \"nf_localedata.cpp\",\n+    \"nf_localedata.h\",\n+    \"nf_zformat.cpp\",\n+    \"nf_zformat.h\",\n+    \"expr.cc\",\n+    \"function_list.cpp\",\n+    \"inlined_grammar.hpp\",\n+}\n+IGNORED_DIRECTORIES = [\n+    \".eggs\",\n+    \"__pycache__\",\n+    \"dbgen\",\n+    \"tools/pythonpkg/duckdb\",\n+    \"tools/pythonpkg/build\",\n+    \"tools/rpkg/src/duckdb\",\n+    \"tools/rpkg/inst/include/cpp11\",\n+    \"extension/tpcds/dsdgen\",\n+    \"extension/jemalloc/jemalloc\",\n+    \"extension/icu/third_party\",\n+    \"tools/nodejs/src/duckdb\",\n ]\n-format_all = False\n-check_only = True\n-confirm = True\n-silent = False\n-force = False\n-\n-\n-def print_usage():\n-    print(\"Usage: python scripts/format.py [revision|--all] [--check|--fix] [--force]\")\n-    print(\n-        \"   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)\"\n-    )\n-    print(\"                  if [revision] is set to --all, all files will be formatted\")\n-    print(\"   --check only prints differences, --fix also fixes the files (--check is default)\")\n-    exit(1)\n \n+FORMAT_COMMANDS = {\n+    \".cpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".ipp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".c\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp at\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".h\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hh\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".cc\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".txt\": [\"cmake-format\", \"-i\"],\n+    \".py\": [\"black\", \"-q\", \"--skip-string-normalization\", \"--line-length\", \"120\"],\n+    \".java\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".test\": [\"cmake-format\", \"-i\"],\n+    \".test_slow\": [\"cmake-format\", \"-i\"],\n+    \".test_coverage\": [\"cmake-format\", \"-i\"],\n+    \".benchmark\": [\"cmake-format\", \"-i\"],\n+}\n \n-if len(sys.argv) == 1:\n-    revision = \"HEAD\"\n-elif len(sys.argv) >= 2:\n-    revision = sys.argv[1]\n-else:\n-    print_usage()\n \n-if len(sys.argv) > 2:\n-    for arg in sys.argv[2:]:\n-        if arg == '--check':\n-            check_only = True\n-        elif arg == '--fix':\n-            check_only = False\n-        elif arg == '--noconfirm':\n-            confirm = False\n-        elif arg == '--confirm':\n-            confirm = True\n-        elif arg == '--silent':\n-            silent = True\n-        elif arg == '--force':\n-            force = True\n-        else:\n-            print_usage()\n-\n-if revision == '--all':\n-    format_all = True\n+# Argument parsing\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Format source code files\")\n+    parser.add_argument(\n+        \"revision\",\n+        nargs=\"?\",\n+        default=\"HEAD\",\n+        help=\"Revision number to format all files (default: HEAD)\",\n+    )\n+    parser.add_argument(\n+        \"--check\",\n+        action=\"store_true\",\n+        help=\"Check formatting without modifying files (default)\",\n+    )\n+    parser.add_argument(\"--all\", action=\"store_true\", help=\"Format all files\")\n+    parser.add_argument(\"--fix\", action=\"store_true\", help=\"Fix formatting issues in files\")\n+    parser.add_argument(\"--force\", action=\"store_true\", help=\"Format even non-standard files\")\n+    parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress output of formatted files\")\n+    parser.add_argument(\"--noconfirm\", action=\"store_true\", help=\"Skip confirmation prompt for fixing\")\n+    return parser.parse_args()\n \n \n+# File filtering\n def file_is_ignored(full_path):\n-    if os.path.basename(full_path) in ignored_files:\n-        return True\n-    dirnames = os.path.sep.join(full_path.split(os.path.sep)[:-1])\n-    for ignored_directory in ignored_directories:\n-        if ignored_directory in dirnames:\n-            return True\n-    return False\n+    return Path(full_path).name in IGNORED_FILES or any(ignored in str(full_path) for ignored in IGNORED_DIRECTORIES)\n \n \n def can_format_file(full_path):\n-    global extensions, formatted_directories, ignored_files\n-    if not os.path.isfile(full_path):\n+    if not Path(full_path).is_file():\n         return False\n-    fname = full_path.split(os.path.sep)[-1]\n-    found = False\n-    # check file extension\n-    for ext in extensions:\n-        if full_path.endswith(ext):\n-            found = True\n-            break\n-    if not found:\n+    if not any(full_path.endswith(ext) for ext in EXTENSIONS):\n         return False\n-    # check ignored files\n     if file_is_ignored(full_path):\n         return False\n-    # now check file directory\n-    for dname in formatted_directories:\n-        if full_path.startswith(dname):\n-            return True\n-    return False\n-\n-\n-action = \"Formatting\"\n-if check_only:\n-    action = \"Checking\"\n+    return any(full_path.startswith(d) for d in FORMATTED_DIRECTORIES)\n \n \n+# File collection\n def get_changed_files(revision):\n-    proc = subprocess.Popen(['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)\n-    files = proc.stdout.read().decode('utf8').split('\\n')\n-    changed_files = []\n-    for f in files:\n-        if not can_format_file(f):\n-            continue\n-        if file_is_ignored(f):\n-            continue\n-        changed_files.append(f)\n-    return changed_files\n-\n-\n-if os.path.isfile(revision):\n-    print(action + \" individual file: \" + revision)\n-    changed_files = [revision]\n-elif os.path.isdir(revision):\n-    print(action + \" files in directory: \" + revision)\n-    changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]\n+    result = subprocess.run([\"git\", \"diff\", \"--name-only\", revision], capture_output=True, text=True)\n+    return [f for f in result.stdout.splitlines() if can_format_file(f) and not file_is_ignored(f)]\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-elif not format_all:\n-    if revision == 'main':\n-        # fetch new changes when comparing to the master\n-        os.system(\"git fetch origin main:main\")\n-    print(action + \" since branch or revision: \" + revision)\n-    changed_files = get_changed_files(revision)\n-    if len(changed_files) == 0:\n-        print(\"No changed files found!\")\n-        exit(0)\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-else:\n-    print(action + \" all files\")\n-\n-if confirm and not check_only:\n-    print(\"The files listed above will be reformatted.\")\n-    result = input(\"Continue with changes (y/n)?\\n\")\n-    if result != 'y':\n-        print(\"Aborting.\")\n-        exit(0)\n-\n-format_commands = {\n-    '.cpp': cpp_format_command,\n-    '.ipp': cpp_format_command,\n-    '.c': cpp_format_command,\n-    '.hpp': cpp_format_command,\n-    '.h': cpp_format_command,\n-    '.hh': cpp_format_command,\n-    '.cc': cpp_format_command,\n-    '.txt': cmake_format_command,\n-    '.py': 'black --quiet - --skip-string-normalization --line-length 120 --stdin-filename',\n-    '.java': cpp_format_command,\n-}\n-\n-difference_files = []\n-\n-header_top = \"//===----------------------------------------------------------------------===//\\n\"\n-header_top += \"//                         DuckDB\\n\" + \"//\\n\"\n-header_bottom = \"//\\n\" + \"//\\n\"\n-header_bottom += \"//===----------------------------------------------------------------------===//\\n\\n\"\n-base_dir = os.path.join(os.getcwd(), 'src/include')\n+def format_directory(directory):\n+    files = []\n+    for path in Path(directory).rglob(\"*\"):\n+        if path.is_file() and can_format_file(str(path)):\n+            files.append(str(path))\n+    return files\n \n \n-def get_formatted_text(f, full_path, directory, ext):\n-    if not can_format_file(full_path):\n+# Formatting logic\n+def format_file(full_path, check_only, force, silent):\n+    ext = Path(full_path).suffix\n+    if ext not in FORMAT_COMMANDS:\n         if not force:\n-            print(\n-                \"File \"\n-                + full_path\n-                + \" is not normally formatted - but attempted to format anyway. Use --force if formatting is desirable\"\n-            )\n-            exit(1)\n-    if f == 'list.hpp':\n-        # fill in list file\n-        file_list = [\n-            os.path.join(dp, f)\n-            for dp, dn, filenames in os.walk(directory)\n-            for f in filenames\n-            if os.path.splitext(f)[1] == '.hpp' and not f.endswith(\"list.hpp\")\n-        ]\n-        file_list = [x.replace('src/include/', '') for x in file_list]\n-        file_list.sort()\n-        result = \"\"\n-        for x in file_list:\n-            result += '#include \"%s\"\\n' % (x)\n-        return result\n-\n-    if ext == \".hpp\" and directory.startswith(\"src/include\"):\n-        with open_utf8(full_path, 'r') as f:\n-            lines = f.readlines()\n-\n-        # format header in files\n-        header_middle = \"// \" + os.path.relpath(full_path, base_dir) + \"\\n\"\n-        text = header_top + header_middle + header_bottom\n-        is_old_header = True\n-        for line in lines:\n-            if not (line.startswith(\"//\") or line.startswith(\"\\n\")) and is_old_header:\n-                is_old_header = False\n-            if not is_old_header:\n-                text += line\n-\n-    if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':",
        "comment_created_at": "2025-05-02T16:10:01+00:00",
        "comment_author": "adsharma",
        "comment_body": "Does cmake-format actually have the ability to format `.test` files?\r\n\r\n```\r\ncmake-format -i test/planner/projection_binding.test\r\n...\r\nValueError: Unexpected WORD token at 5:10, expecting l-paren, got 'ok'\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2071843398",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17305,
        "pr_file": "scripts/format.py",
        "discussion_id": "2071322192",
        "commented_code": "@@ -1,467 +1,299 @@\n-#!/usr/bin/python\n-\n-# this script is used to format the source directory\n+#!/usr/bin/python3\n \n import os\n-import time\n-import sys\n-import inspect\n import subprocess\n-import difflib\n-import re\n-import tempfile\n-import uuid\n+import sys\n+import argparse\n import concurrent.futures\n-from python_helpers import open_utf8\n-\n-try:\n-    ver = subprocess.check_output(('black', '--version'), text=True)\n-    if int(ver.split(' ')[1].split('.')[0]) < 24:\n-        print('you need to run `pip install \"black>=24\"`', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install \"black>=24\"`', e)\n-    exit(-1)\n-\n-try:\n-    ver = subprocess.check_output(('clang-format', '--version'), text=True)\n-    if '11.' not in ver:\n-        print('you need to run `pip install clang_format==11.0.1 - `', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install clang_format==11.0.1 - `', e)\n-    exit(-1)\n-\n-cpp_format_command = 'clang-format --sort-includes=0 -style=file'\n-cmake_format_command = 'cmake-format'\n+import difflib\n+from pathlib import Path\n \n-try:\n-    subprocess.check_output(('cmake-format', '--version'), text=True)\n-except Exception as e:\n-    print('you need to run `pip install cmake-format`', e)\n-    exit(-1)\n \n-extensions = [\n-    '.cpp',\n-    '.ipp',\n-    '.c',\n-    '.hpp',\n-    '.h',\n-    '.cc',\n-    '.hh',\n-    'CMakeLists.txt',\n-    '.test',\n-    '.test_slow',\n-    '.test_coverage',\n-    '.benchmark',\n-    '.py',\n-    '.java',\n+# Check formatter versions\n+def check_formatter_version(command, version_key, min_version, install_instruction):\n+    try:\n+        output = subprocess.check_output(command, text=True).strip()\n+        # Extract version number for clang-format (e.g., \"11.0.1\" from \"clang-format version 11.0.1...\")\n+        if command[0] == \"clang-format\":\n+            version = output.split()[2].split(\".\")[0]\n+        elif command[0] == \"black\":\n+            version = output.split()[1].split(\".\")[0]\n+        else:\n+            version = output.split()[0].split(\".\")[0]\n+        version_key_mismatch = version_key is not None and version_key not in output\n+        if version_key_mismatch or int(version) < min_version:\n+            print(f\"Please install {install_instruction}\")\n+            print(f\"Required: {min_version}. Present: {version}\")\n+            sys.exit(1)\n+    except Exception as e:\n+        breakpoint()\n+        print(f\"Please install {install_instruction}: {e}\")\n+        sys.exit(1)\n+\n+\n+# Configuration\n+EXTENSIONS = [\n+    \".cpp\",\n+    \".ipp\",\n+    \".c\",\n+    \".hpp\",\n+    \".h\",\n+    \".cc\",\n+    \".hh\",\n+    \"CMakeLists.txt\",\n+    \".py\",\n+    \".java\",\n ]\n-formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension', 'scripts']\n-ignored_files = [\n-    'tpch_constants.hpp',\n-    'tpcds_constants.hpp',\n-    '_generated',\n-    'tpce_flat_input.hpp',\n-    'test_csv_header.hpp',\n-    'duckdb.cpp',\n-    'duckdb.hpp',\n-    'json.hpp',\n-    'sqlite3.h',\n-    'shell.c',\n-    'termcolor.hpp',\n-    'test_insert_invalid.test',\n-    'httplib.hpp',\n-    'os_win.c',\n-    'glob.c',\n-    'printf.c',\n-    'helper.hpp',\n-    'single_thread_ptr.hpp',\n-    'types.hpp',\n-    'default_views.cpp',\n-    'default_functions.cpp',\n-    'release.h',\n-    'genrand.cpp',\n-    'address.cpp',\n-    'visualizer_constants.hpp',\n-    'icu-collate.cpp',\n-    'icu-collate.hpp',\n-    'yyjson.cpp',\n-    'yyjson.hpp',\n-    'duckdb_pdqsort.hpp',\n-    'stubdata.cpp',\n-    'nf_calendar.cpp',\n-    'nf_calendar.h',\n-    'nf_localedata.cpp',\n-    'nf_localedata.h',\n-    'nf_zformat.cpp',\n-    'nf_zformat.h',\n-    'expr.cc',\n-    'function_list.cpp',\n-    'inlined_grammar.hpp',\n+FORMATTED_DIRECTORIES = [\n+    \"src\",\n+    \"benchmark\",\n+    \"test\",\n+    \"tools\",\n+    \"examples\",\n+    \"extension\",\n+    \"scripts\",\n ]\n-ignored_directories = [\n-    '.eggs',\n-    '__pycache__',\n-    'dbgen',\n-    os.path.join('tools', 'pythonpkg', 'duckdb'),\n-    os.path.join('tools', 'pythonpkg', 'build'),\n-    os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n-    os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n-    os.path.join('extension', 'tpcds', 'dsdgen'),\n-    os.path.join('extension', 'jemalloc', 'jemalloc'),\n-    os.path.join('extension', 'icu', 'third_party'),\n-    os.path.join('tools', 'nodejs', 'src', 'duckdb'),\n+IGNORED_FILES = {\n+    \"tpch_constants.hpp\",\n+    \"tpcds_constants.hpp\",\n+    \"_generated\",\n+    \"tpce_flat_input.hpp\",\n+    \"test_csv_header.hpp\",\n+    \"duckdb.cpp\",\n+    \"duckdb.hpp\",\n+    \"json.hpp\",\n+    \"sqlite3.h\",\n+    \"shell.c\",\n+    \"termcolor.hpp\",\n+    \"test_insert_invalid.test\",\n+    \"httplib.hpp\",\n+    \"os_win.c\",\n+    \"glob.c\",\n+    \"printf.c\",\n+    \"helper.hpp\",\n+    \"single_thread_ptr.hpp\",\n+    \"types.hpp\",\n+    \"default_views.cpp\",\n+    \"default_functions.cpp\",\n+    \"release.h\",\n+    \"genrand.cpp\",\n+    \"address.cpp\",\n+    \"visualizer_constants.hpp\",\n+    \"icu-collate.cpp\",\n+    \"icu-collate.hpp\",\n+    \"yyjson.cpp\",\n+    \"yyjson.hpp\",\n+    \"duckdb_pdqsort.hpp\",\n+    \"stubdata.cpp\",\n+    \"nf_calendar.cpp\",\n+    \"nf_calendar.h\",\n+    \"nf_localedata.cpp\",\n+    \"nf_localedata.h\",\n+    \"nf_zformat.cpp\",\n+    \"nf_zformat.h\",\n+    \"expr.cc\",\n+    \"function_list.cpp\",\n+    \"inlined_grammar.hpp\",\n+}\n+IGNORED_DIRECTORIES = [\n+    \".eggs\",\n+    \"__pycache__\",\n+    \"dbgen\",\n+    \"tools/pythonpkg/duckdb\",\n+    \"tools/pythonpkg/build\",\n+    \"tools/rpkg/src/duckdb\",\n+    \"tools/rpkg/inst/include/cpp11\",\n+    \"extension/tpcds/dsdgen\",\n+    \"extension/jemalloc/jemalloc\",\n+    \"extension/icu/third_party\",\n+    \"tools/nodejs/src/duckdb\",\n ]\n-format_all = False\n-check_only = True\n-confirm = True\n-silent = False\n-force = False\n-\n-\n-def print_usage():\n-    print(\"Usage: python scripts/format.py [revision|--all] [--check|--fix] [--force]\")\n-    print(\n-        \"   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)\"\n-    )\n-    print(\"                  if [revision] is set to --all, all files will be formatted\")\n-    print(\"   --check only prints differences, --fix also fixes the files (--check is default)\")\n-    exit(1)\n \n+FORMAT_COMMANDS = {\n+    \".cpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".ipp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".c\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp at\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".h\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hh\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".cc\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".txt\": [\"cmake-format\", \"-i\"],\n+    \".py\": [\"black\", \"-q\", \"--skip-string-normalization\", \"--line-length\", \"120\"],\n+    \".java\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".test\": [\"cmake-format\", \"-i\"],\n+    \".test_slow\": [\"cmake-format\", \"-i\"],\n+    \".test_coverage\": [\"cmake-format\", \"-i\"],\n+    \".benchmark\": [\"cmake-format\", \"-i\"],\n+}\n \n-if len(sys.argv) == 1:\n-    revision = \"HEAD\"\n-elif len(sys.argv) >= 2:\n-    revision = sys.argv[1]\n-else:\n-    print_usage()\n \n-if len(sys.argv) > 2:\n-    for arg in sys.argv[2:]:\n-        if arg == '--check':\n-            check_only = True\n-        elif arg == '--fix':\n-            check_only = False\n-        elif arg == '--noconfirm':\n-            confirm = False\n-        elif arg == '--confirm':\n-            confirm = True\n-        elif arg == '--silent':\n-            silent = True\n-        elif arg == '--force':\n-            force = True\n-        else:\n-            print_usage()\n-\n-if revision == '--all':\n-    format_all = True\n+# Argument parsing\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Format source code files\")\n+    parser.add_argument(\n+        \"revision\",\n+        nargs=\"?\",\n+        default=\"HEAD\",\n+        help=\"Revision number to format all files (default: HEAD)\",\n+    )\n+    parser.add_argument(\n+        \"--check\",\n+        action=\"store_true\",\n+        help=\"Check formatting without modifying files (default)\",\n+    )\n+    parser.add_argument(\"--all\", action=\"store_true\", help=\"Format all files\")\n+    parser.add_argument(\"--fix\", action=\"store_true\", help=\"Fix formatting issues in files\")\n+    parser.add_argument(\"--force\", action=\"store_true\", help=\"Format even non-standard files\")\n+    parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress output of formatted files\")\n+    parser.add_argument(\"--noconfirm\", action=\"store_true\", help=\"Skip confirmation prompt for fixing\")\n+    return parser.parse_args()\n \n \n+# File filtering\n def file_is_ignored(full_path):\n-    if os.path.basename(full_path) in ignored_files:\n-        return True\n-    dirnames = os.path.sep.join(full_path.split(os.path.sep)[:-1])\n-    for ignored_directory in ignored_directories:\n-        if ignored_directory in dirnames:\n-            return True\n-    return False\n+    return Path(full_path).name in IGNORED_FILES or any(ignored in str(full_path) for ignored in IGNORED_DIRECTORIES)\n \n \n def can_format_file(full_path):\n-    global extensions, formatted_directories, ignored_files\n-    if not os.path.isfile(full_path):\n+    if not Path(full_path).is_file():\n         return False\n-    fname = full_path.split(os.path.sep)[-1]\n-    found = False\n-    # check file extension\n-    for ext in extensions:\n-        if full_path.endswith(ext):\n-            found = True\n-            break\n-    if not found:\n+    if not any(full_path.endswith(ext) for ext in EXTENSIONS):\n         return False\n-    # check ignored files\n     if file_is_ignored(full_path):\n         return False\n-    # now check file directory\n-    for dname in formatted_directories:\n-        if full_path.startswith(dname):\n-            return True\n-    return False\n-\n-\n-action = \"Formatting\"\n-if check_only:\n-    action = \"Checking\"\n+    return any(full_path.startswith(d) for d in FORMATTED_DIRECTORIES)\n \n \n+# File collection\n def get_changed_files(revision):\n-    proc = subprocess.Popen(['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)\n-    files = proc.stdout.read().decode('utf8').split('\\n')\n-    changed_files = []\n-    for f in files:\n-        if not can_format_file(f):\n-            continue\n-        if file_is_ignored(f):\n-            continue\n-        changed_files.append(f)\n-    return changed_files\n-\n-\n-if os.path.isfile(revision):\n-    print(action + \" individual file: \" + revision)\n-    changed_files = [revision]\n-elif os.path.isdir(revision):\n-    print(action + \" files in directory: \" + revision)\n-    changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]\n+    result = subprocess.run([\"git\", \"diff\", \"--name-only\", revision], capture_output=True, text=True)\n+    return [f for f in result.stdout.splitlines() if can_format_file(f) and not file_is_ignored(f)]\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-elif not format_all:\n-    if revision == 'main':\n-        # fetch new changes when comparing to the master\n-        os.system(\"git fetch origin main:main\")\n-    print(action + \" since branch or revision: \" + revision)\n-    changed_files = get_changed_files(revision)\n-    if len(changed_files) == 0:\n-        print(\"No changed files found!\")\n-        exit(0)\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-else:\n-    print(action + \" all files\")\n-\n-if confirm and not check_only:\n-    print(\"The files listed above will be reformatted.\")\n-    result = input(\"Continue with changes (y/n)?\\n\")\n-    if result != 'y':\n-        print(\"Aborting.\")\n-        exit(0)\n-\n-format_commands = {\n-    '.cpp': cpp_format_command,\n-    '.ipp': cpp_format_command,\n-    '.c': cpp_format_command,\n-    '.hpp': cpp_format_command,\n-    '.h': cpp_format_command,\n-    '.hh': cpp_format_command,\n-    '.cc': cpp_format_command,\n-    '.txt': cmake_format_command,\n-    '.py': 'black --quiet - --skip-string-normalization --line-length 120 --stdin-filename',\n-    '.java': cpp_format_command,\n-}\n-\n-difference_files = []\n-\n-header_top = \"//===----------------------------------------------------------------------===//\\n\"\n-header_top += \"//                         DuckDB\\n\" + \"//\\n\"\n-header_bottom = \"//\\n\" + \"//\\n\"\n-header_bottom += \"//===----------------------------------------------------------------------===//\\n\\n\"\n-base_dir = os.path.join(os.getcwd(), 'src/include')\n+def format_directory(directory):\n+    files = []\n+    for path in Path(directory).rglob(\"*\"):\n+        if path.is_file() and can_format_file(str(path)):\n+            files.append(str(path))\n+    return files\n \n \n-def get_formatted_text(f, full_path, directory, ext):\n-    if not can_format_file(full_path):\n+# Formatting logic\n+def format_file(full_path, check_only, force, silent):\n+    ext = Path(full_path).suffix\n+    if ext not in FORMAT_COMMANDS:\n         if not force:\n-            print(\n-                \"File \"\n-                + full_path\n-                + \" is not normally formatted - but attempted to format anyway. Use --force if formatting is desirable\"\n-            )\n-            exit(1)\n-    if f == 'list.hpp':\n-        # fill in list file\n-        file_list = [\n-            os.path.join(dp, f)\n-            for dp, dn, filenames in os.walk(directory)\n-            for f in filenames\n-            if os.path.splitext(f)[1] == '.hpp' and not f.endswith(\"list.hpp\")\n-        ]\n-        file_list = [x.replace('src/include/', '') for x in file_list]\n-        file_list.sort()\n-        result = \"\"\n-        for x in file_list:\n-            result += '#include \"%s\"\\n' % (x)\n-        return result\n-\n-    if ext == \".hpp\" and directory.startswith(\"src/include\"):\n-        with open_utf8(full_path, 'r') as f:\n-            lines = f.readlines()\n-\n-        # format header in files\n-        header_middle = \"// \" + os.path.relpath(full_path, base_dir) + \"\\n\"\n-        text = header_top + header_middle + header_bottom\n-        is_old_header = True\n-        for line in lines:\n-            if not (line.startswith(\"//\") or line.startswith(\"\\n\")) and is_old_header:\n-                is_old_header = False\n-            if not is_old_header:\n-                text += line\n-\n-    if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':",
        "comment_created_at": "2025-05-02T16:11:50+00:00",
        "comment_author": "Tishj",
        "comment_body": "No, it doesn't\r\nWhich is why it's not handled by cmake-format",
        "pr_file_module": null
      },
      {
        "comment_id": "2071844739",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17305,
        "pr_file": "scripts/format.py",
        "discussion_id": "2071322192",
        "commented_code": "@@ -1,467 +1,299 @@\n-#!/usr/bin/python\n-\n-# this script is used to format the source directory\n+#!/usr/bin/python3\n \n import os\n-import time\n-import sys\n-import inspect\n import subprocess\n-import difflib\n-import re\n-import tempfile\n-import uuid\n+import sys\n+import argparse\n import concurrent.futures\n-from python_helpers import open_utf8\n-\n-try:\n-    ver = subprocess.check_output(('black', '--version'), text=True)\n-    if int(ver.split(' ')[1].split('.')[0]) < 24:\n-        print('you need to run `pip install \"black>=24\"`', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install \"black>=24\"`', e)\n-    exit(-1)\n-\n-try:\n-    ver = subprocess.check_output(('clang-format', '--version'), text=True)\n-    if '11.' not in ver:\n-        print('you need to run `pip install clang_format==11.0.1 - `', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install clang_format==11.0.1 - `', e)\n-    exit(-1)\n-\n-cpp_format_command = 'clang-format --sort-includes=0 -style=file'\n-cmake_format_command = 'cmake-format'\n+import difflib\n+from pathlib import Path\n \n-try:\n-    subprocess.check_output(('cmake-format', '--version'), text=True)\n-except Exception as e:\n-    print('you need to run `pip install cmake-format`', e)\n-    exit(-1)\n \n-extensions = [\n-    '.cpp',\n-    '.ipp',\n-    '.c',\n-    '.hpp',\n-    '.h',\n-    '.cc',\n-    '.hh',\n-    'CMakeLists.txt',\n-    '.test',\n-    '.test_slow',\n-    '.test_coverage',\n-    '.benchmark',\n-    '.py',\n-    '.java',\n+# Check formatter versions\n+def check_formatter_version(command, version_key, min_version, install_instruction):\n+    try:\n+        output = subprocess.check_output(command, text=True).strip()\n+        # Extract version number for clang-format (e.g., \"11.0.1\" from \"clang-format version 11.0.1...\")\n+        if command[0] == \"clang-format\":\n+            version = output.split()[2].split(\".\")[0]\n+        elif command[0] == \"black\":\n+            version = output.split()[1].split(\".\")[0]\n+        else:\n+            version = output.split()[0].split(\".\")[0]\n+        version_key_mismatch = version_key is not None and version_key not in output\n+        if version_key_mismatch or int(version) < min_version:\n+            print(f\"Please install {install_instruction}\")\n+            print(f\"Required: {min_version}. Present: {version}\")\n+            sys.exit(1)\n+    except Exception as e:\n+        breakpoint()\n+        print(f\"Please install {install_instruction}: {e}\")\n+        sys.exit(1)\n+\n+\n+# Configuration\n+EXTENSIONS = [\n+    \".cpp\",\n+    \".ipp\",\n+    \".c\",\n+    \".hpp\",\n+    \".h\",\n+    \".cc\",\n+    \".hh\",\n+    \"CMakeLists.txt\",\n+    \".py\",\n+    \".java\",\n ]\n-formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension', 'scripts']\n-ignored_files = [\n-    'tpch_constants.hpp',\n-    'tpcds_constants.hpp',\n-    '_generated',\n-    'tpce_flat_input.hpp',\n-    'test_csv_header.hpp',\n-    'duckdb.cpp',\n-    'duckdb.hpp',\n-    'json.hpp',\n-    'sqlite3.h',\n-    'shell.c',\n-    'termcolor.hpp',\n-    'test_insert_invalid.test',\n-    'httplib.hpp',\n-    'os_win.c',\n-    'glob.c',\n-    'printf.c',\n-    'helper.hpp',\n-    'single_thread_ptr.hpp',\n-    'types.hpp',\n-    'default_views.cpp',\n-    'default_functions.cpp',\n-    'release.h',\n-    'genrand.cpp',\n-    'address.cpp',\n-    'visualizer_constants.hpp',\n-    'icu-collate.cpp',\n-    'icu-collate.hpp',\n-    'yyjson.cpp',\n-    'yyjson.hpp',\n-    'duckdb_pdqsort.hpp',\n-    'stubdata.cpp',\n-    'nf_calendar.cpp',\n-    'nf_calendar.h',\n-    'nf_localedata.cpp',\n-    'nf_localedata.h',\n-    'nf_zformat.cpp',\n-    'nf_zformat.h',\n-    'expr.cc',\n-    'function_list.cpp',\n-    'inlined_grammar.hpp',\n+FORMATTED_DIRECTORIES = [\n+    \"src\",\n+    \"benchmark\",\n+    \"test\",\n+    \"tools\",\n+    \"examples\",\n+    \"extension\",\n+    \"scripts\",\n ]\n-ignored_directories = [\n-    '.eggs',\n-    '__pycache__',\n-    'dbgen',\n-    os.path.join('tools', 'pythonpkg', 'duckdb'),\n-    os.path.join('tools', 'pythonpkg', 'build'),\n-    os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n-    os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n-    os.path.join('extension', 'tpcds', 'dsdgen'),\n-    os.path.join('extension', 'jemalloc', 'jemalloc'),\n-    os.path.join('extension', 'icu', 'third_party'),\n-    os.path.join('tools', 'nodejs', 'src', 'duckdb'),\n+IGNORED_FILES = {\n+    \"tpch_constants.hpp\",\n+    \"tpcds_constants.hpp\",\n+    \"_generated\",\n+    \"tpce_flat_input.hpp\",\n+    \"test_csv_header.hpp\",\n+    \"duckdb.cpp\",\n+    \"duckdb.hpp\",\n+    \"json.hpp\",\n+    \"sqlite3.h\",\n+    \"shell.c\",\n+    \"termcolor.hpp\",\n+    \"test_insert_invalid.test\",\n+    \"httplib.hpp\",\n+    \"os_win.c\",\n+    \"glob.c\",\n+    \"printf.c\",\n+    \"helper.hpp\",\n+    \"single_thread_ptr.hpp\",\n+    \"types.hpp\",\n+    \"default_views.cpp\",\n+    \"default_functions.cpp\",\n+    \"release.h\",\n+    \"genrand.cpp\",\n+    \"address.cpp\",\n+    \"visualizer_constants.hpp\",\n+    \"icu-collate.cpp\",\n+    \"icu-collate.hpp\",\n+    \"yyjson.cpp\",\n+    \"yyjson.hpp\",\n+    \"duckdb_pdqsort.hpp\",\n+    \"stubdata.cpp\",\n+    \"nf_calendar.cpp\",\n+    \"nf_calendar.h\",\n+    \"nf_localedata.cpp\",\n+    \"nf_localedata.h\",\n+    \"nf_zformat.cpp\",\n+    \"nf_zformat.h\",\n+    \"expr.cc\",\n+    \"function_list.cpp\",\n+    \"inlined_grammar.hpp\",\n+}\n+IGNORED_DIRECTORIES = [\n+    \".eggs\",\n+    \"__pycache__\",\n+    \"dbgen\",\n+    \"tools/pythonpkg/duckdb\",\n+    \"tools/pythonpkg/build\",\n+    \"tools/rpkg/src/duckdb\",\n+    \"tools/rpkg/inst/include/cpp11\",\n+    \"extension/tpcds/dsdgen\",\n+    \"extension/jemalloc/jemalloc\",\n+    \"extension/icu/third_party\",\n+    \"tools/nodejs/src/duckdb\",\n ]\n-format_all = False\n-check_only = True\n-confirm = True\n-silent = False\n-force = False\n-\n-\n-def print_usage():\n-    print(\"Usage: python scripts/format.py [revision|--all] [--check|--fix] [--force]\")\n-    print(\n-        \"   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)\"\n-    )\n-    print(\"                  if [revision] is set to --all, all files will be formatted\")\n-    print(\"   --check only prints differences, --fix also fixes the files (--check is default)\")\n-    exit(1)\n \n+FORMAT_COMMANDS = {\n+    \".cpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".ipp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".c\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp at\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".h\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hh\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".cc\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".txt\": [\"cmake-format\", \"-i\"],\n+    \".py\": [\"black\", \"-q\", \"--skip-string-normalization\", \"--line-length\", \"120\"],\n+    \".java\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".test\": [\"cmake-format\", \"-i\"],\n+    \".test_slow\": [\"cmake-format\", \"-i\"],\n+    \".test_coverage\": [\"cmake-format\", \"-i\"],\n+    \".benchmark\": [\"cmake-format\", \"-i\"],\n+}\n \n-if len(sys.argv) == 1:\n-    revision = \"HEAD\"\n-elif len(sys.argv) >= 2:\n-    revision = sys.argv[1]\n-else:\n-    print_usage()\n \n-if len(sys.argv) > 2:\n-    for arg in sys.argv[2:]:\n-        if arg == '--check':\n-            check_only = True\n-        elif arg == '--fix':\n-            check_only = False\n-        elif arg == '--noconfirm':\n-            confirm = False\n-        elif arg == '--confirm':\n-            confirm = True\n-        elif arg == '--silent':\n-            silent = True\n-        elif arg == '--force':\n-            force = True\n-        else:\n-            print_usage()\n-\n-if revision == '--all':\n-    format_all = True\n+# Argument parsing\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Format source code files\")\n+    parser.add_argument(\n+        \"revision\",\n+        nargs=\"?\",\n+        default=\"HEAD\",\n+        help=\"Revision number to format all files (default: HEAD)\",\n+    )\n+    parser.add_argument(\n+        \"--check\",\n+        action=\"store_true\",\n+        help=\"Check formatting without modifying files (default)\",\n+    )\n+    parser.add_argument(\"--all\", action=\"store_true\", help=\"Format all files\")\n+    parser.add_argument(\"--fix\", action=\"store_true\", help=\"Fix formatting issues in files\")\n+    parser.add_argument(\"--force\", action=\"store_true\", help=\"Format even non-standard files\")\n+    parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress output of formatted files\")\n+    parser.add_argument(\"--noconfirm\", action=\"store_true\", help=\"Skip confirmation prompt for fixing\")\n+    return parser.parse_args()\n \n \n+# File filtering\n def file_is_ignored(full_path):\n-    if os.path.basename(full_path) in ignored_files:\n-        return True\n-    dirnames = os.path.sep.join(full_path.split(os.path.sep)[:-1])\n-    for ignored_directory in ignored_directories:\n-        if ignored_directory in dirnames:\n-            return True\n-    return False\n+    return Path(full_path).name in IGNORED_FILES or any(ignored in str(full_path) for ignored in IGNORED_DIRECTORIES)\n \n \n def can_format_file(full_path):\n-    global extensions, formatted_directories, ignored_files\n-    if not os.path.isfile(full_path):\n+    if not Path(full_path).is_file():\n         return False\n-    fname = full_path.split(os.path.sep)[-1]\n-    found = False\n-    # check file extension\n-    for ext in extensions:\n-        if full_path.endswith(ext):\n-            found = True\n-            break\n-    if not found:\n+    if not any(full_path.endswith(ext) for ext in EXTENSIONS):\n         return False\n-    # check ignored files\n     if file_is_ignored(full_path):\n         return False\n-    # now check file directory\n-    for dname in formatted_directories:\n-        if full_path.startswith(dname):\n-            return True\n-    return False\n-\n-\n-action = \"Formatting\"\n-if check_only:\n-    action = \"Checking\"\n+    return any(full_path.startswith(d) for d in FORMATTED_DIRECTORIES)\n \n \n+# File collection\n def get_changed_files(revision):\n-    proc = subprocess.Popen(['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)\n-    files = proc.stdout.read().decode('utf8').split('\\n')\n-    changed_files = []\n-    for f in files:\n-        if not can_format_file(f):\n-            continue\n-        if file_is_ignored(f):\n-            continue\n-        changed_files.append(f)\n-    return changed_files\n-\n-\n-if os.path.isfile(revision):\n-    print(action + \" individual file: \" + revision)\n-    changed_files = [revision]\n-elif os.path.isdir(revision):\n-    print(action + \" files in directory: \" + revision)\n-    changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]\n+    result = subprocess.run([\"git\", \"diff\", \"--name-only\", revision], capture_output=True, text=True)\n+    return [f for f in result.stdout.splitlines() if can_format_file(f) and not file_is_ignored(f)]\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-elif not format_all:\n-    if revision == 'main':\n-        # fetch new changes when comparing to the master\n-        os.system(\"git fetch origin main:main\")\n-    print(action + \" since branch or revision: \" + revision)\n-    changed_files = get_changed_files(revision)\n-    if len(changed_files) == 0:\n-        print(\"No changed files found!\")\n-        exit(0)\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-else:\n-    print(action + \" all files\")\n-\n-if confirm and not check_only:\n-    print(\"The files listed above will be reformatted.\")\n-    result = input(\"Continue with changes (y/n)?\\n\")\n-    if result != 'y':\n-        print(\"Aborting.\")\n-        exit(0)\n-\n-format_commands = {\n-    '.cpp': cpp_format_command,\n-    '.ipp': cpp_format_command,\n-    '.c': cpp_format_command,\n-    '.hpp': cpp_format_command,\n-    '.h': cpp_format_command,\n-    '.hh': cpp_format_command,\n-    '.cc': cpp_format_command,\n-    '.txt': cmake_format_command,\n-    '.py': 'black --quiet - --skip-string-normalization --line-length 120 --stdin-filename',\n-    '.java': cpp_format_command,\n-}\n-\n-difference_files = []\n-\n-header_top = \"//===----------------------------------------------------------------------===//\\n\"\n-header_top += \"//                         DuckDB\\n\" + \"//\\n\"\n-header_bottom = \"//\\n\" + \"//\\n\"\n-header_bottom += \"//===----------------------------------------------------------------------===//\\n\\n\"\n-base_dir = os.path.join(os.getcwd(), 'src/include')\n+def format_directory(directory):\n+    files = []\n+    for path in Path(directory).rglob(\"*\"):\n+        if path.is_file() and can_format_file(str(path)):\n+            files.append(str(path))\n+    return files\n \n \n-def get_formatted_text(f, full_path, directory, ext):\n-    if not can_format_file(full_path):\n+# Formatting logic\n+def format_file(full_path, check_only, force, silent):\n+    ext = Path(full_path).suffix\n+    if ext not in FORMAT_COMMANDS:\n         if not force:\n-            print(\n-                \"File \"\n-                + full_path\n-                + \" is not normally formatted - but attempted to format anyway. Use --force if formatting is desirable\"\n-            )\n-            exit(1)\n-    if f == 'list.hpp':\n-        # fill in list file\n-        file_list = [\n-            os.path.join(dp, f)\n-            for dp, dn, filenames in os.walk(directory)\n-            for f in filenames\n-            if os.path.splitext(f)[1] == '.hpp' and not f.endswith(\"list.hpp\")\n-        ]\n-        file_list = [x.replace('src/include/', '') for x in file_list]\n-        file_list.sort()\n-        result = \"\"\n-        for x in file_list:\n-            result += '#include \"%s\"\\n' % (x)\n-        return result\n-\n-    if ext == \".hpp\" and directory.startswith(\"src/include\"):\n-        with open_utf8(full_path, 'r') as f:\n-            lines = f.readlines()\n-\n-        # format header in files\n-        header_middle = \"// \" + os.path.relpath(full_path, base_dir) + \"\\n\"\n-        text = header_top + header_middle + header_bottom\n-        is_old_header = True\n-        for line in lines:\n-            if not (line.startswith(\"//\") or line.startswith(\"\\n\")) and is_old_header:\n-                is_old_header = False\n-            if not is_old_header:\n-                text += line\n-\n-    if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':",
        "comment_created_at": "2025-05-02T16:12:33+00:00",
        "comment_author": "adsharma",
        "comment_body": "But your overall observation is right - substantial parts of the file have been rewritten. Only the argparse/top level control flow can be described as a refactor.",
        "pr_file_module": null
      },
      {
        "comment_id": "2071848857",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17305,
        "pr_file": "scripts/format.py",
        "discussion_id": "2071322192",
        "commented_code": "@@ -1,467 +1,299 @@\n-#!/usr/bin/python\n-\n-# this script is used to format the source directory\n+#!/usr/bin/python3\n \n import os\n-import time\n-import sys\n-import inspect\n import subprocess\n-import difflib\n-import re\n-import tempfile\n-import uuid\n+import sys\n+import argparse\n import concurrent.futures\n-from python_helpers import open_utf8\n-\n-try:\n-    ver = subprocess.check_output(('black', '--version'), text=True)\n-    if int(ver.split(' ')[1].split('.')[0]) < 24:\n-        print('you need to run `pip install \"black>=24\"`', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install \"black>=24\"`', e)\n-    exit(-1)\n-\n-try:\n-    ver = subprocess.check_output(('clang-format', '--version'), text=True)\n-    if '11.' not in ver:\n-        print('you need to run `pip install clang_format==11.0.1 - `', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install clang_format==11.0.1 - `', e)\n-    exit(-1)\n-\n-cpp_format_command = 'clang-format --sort-includes=0 -style=file'\n-cmake_format_command = 'cmake-format'\n+import difflib\n+from pathlib import Path\n \n-try:\n-    subprocess.check_output(('cmake-format', '--version'), text=True)\n-except Exception as e:\n-    print('you need to run `pip install cmake-format`', e)\n-    exit(-1)\n \n-extensions = [\n-    '.cpp',\n-    '.ipp',\n-    '.c',\n-    '.hpp',\n-    '.h',\n-    '.cc',\n-    '.hh',\n-    'CMakeLists.txt',\n-    '.test',\n-    '.test_slow',\n-    '.test_coverage',\n-    '.benchmark',\n-    '.py',\n-    '.java',\n+# Check formatter versions\n+def check_formatter_version(command, version_key, min_version, install_instruction):\n+    try:\n+        output = subprocess.check_output(command, text=True).strip()\n+        # Extract version number for clang-format (e.g., \"11.0.1\" from \"clang-format version 11.0.1...\")\n+        if command[0] == \"clang-format\":\n+            version = output.split()[2].split(\".\")[0]\n+        elif command[0] == \"black\":\n+            version = output.split()[1].split(\".\")[0]\n+        else:\n+            version = output.split()[0].split(\".\")[0]\n+        version_key_mismatch = version_key is not None and version_key not in output\n+        if version_key_mismatch or int(version) < min_version:\n+            print(f\"Please install {install_instruction}\")\n+            print(f\"Required: {min_version}. Present: {version}\")\n+            sys.exit(1)\n+    except Exception as e:\n+        breakpoint()\n+        print(f\"Please install {install_instruction}: {e}\")\n+        sys.exit(1)\n+\n+\n+# Configuration\n+EXTENSIONS = [\n+    \".cpp\",\n+    \".ipp\",\n+    \".c\",\n+    \".hpp\",\n+    \".h\",\n+    \".cc\",\n+    \".hh\",\n+    \"CMakeLists.txt\",\n+    \".py\",\n+    \".java\",\n ]\n-formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension', 'scripts']\n-ignored_files = [\n-    'tpch_constants.hpp',\n-    'tpcds_constants.hpp',\n-    '_generated',\n-    'tpce_flat_input.hpp',\n-    'test_csv_header.hpp',\n-    'duckdb.cpp',\n-    'duckdb.hpp',\n-    'json.hpp',\n-    'sqlite3.h',\n-    'shell.c',\n-    'termcolor.hpp',\n-    'test_insert_invalid.test',\n-    'httplib.hpp',\n-    'os_win.c',\n-    'glob.c',\n-    'printf.c',\n-    'helper.hpp',\n-    'single_thread_ptr.hpp',\n-    'types.hpp',\n-    'default_views.cpp',\n-    'default_functions.cpp',\n-    'release.h',\n-    'genrand.cpp',\n-    'address.cpp',\n-    'visualizer_constants.hpp',\n-    'icu-collate.cpp',\n-    'icu-collate.hpp',\n-    'yyjson.cpp',\n-    'yyjson.hpp',\n-    'duckdb_pdqsort.hpp',\n-    'stubdata.cpp',\n-    'nf_calendar.cpp',\n-    'nf_calendar.h',\n-    'nf_localedata.cpp',\n-    'nf_localedata.h',\n-    'nf_zformat.cpp',\n-    'nf_zformat.h',\n-    'expr.cc',\n-    'function_list.cpp',\n-    'inlined_grammar.hpp',\n+FORMATTED_DIRECTORIES = [\n+    \"src\",\n+    \"benchmark\",\n+    \"test\",\n+    \"tools\",\n+    \"examples\",\n+    \"extension\",\n+    \"scripts\",\n ]\n-ignored_directories = [\n-    '.eggs',\n-    '__pycache__',\n-    'dbgen',\n-    os.path.join('tools', 'pythonpkg', 'duckdb'),\n-    os.path.join('tools', 'pythonpkg', 'build'),\n-    os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n-    os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n-    os.path.join('extension', 'tpcds', 'dsdgen'),\n-    os.path.join('extension', 'jemalloc', 'jemalloc'),\n-    os.path.join('extension', 'icu', 'third_party'),\n-    os.path.join('tools', 'nodejs', 'src', 'duckdb'),\n+IGNORED_FILES = {\n+    \"tpch_constants.hpp\",\n+    \"tpcds_constants.hpp\",\n+    \"_generated\",\n+    \"tpce_flat_input.hpp\",\n+    \"test_csv_header.hpp\",\n+    \"duckdb.cpp\",\n+    \"duckdb.hpp\",\n+    \"json.hpp\",\n+    \"sqlite3.h\",\n+    \"shell.c\",\n+    \"termcolor.hpp\",\n+    \"test_insert_invalid.test\",\n+    \"httplib.hpp\",\n+    \"os_win.c\",\n+    \"glob.c\",\n+    \"printf.c\",\n+    \"helper.hpp\",\n+    \"single_thread_ptr.hpp\",\n+    \"types.hpp\",\n+    \"default_views.cpp\",\n+    \"default_functions.cpp\",\n+    \"release.h\",\n+    \"genrand.cpp\",\n+    \"address.cpp\",\n+    \"visualizer_constants.hpp\",\n+    \"icu-collate.cpp\",\n+    \"icu-collate.hpp\",\n+    \"yyjson.cpp\",\n+    \"yyjson.hpp\",\n+    \"duckdb_pdqsort.hpp\",\n+    \"stubdata.cpp\",\n+    \"nf_calendar.cpp\",\n+    \"nf_calendar.h\",\n+    \"nf_localedata.cpp\",\n+    \"nf_localedata.h\",\n+    \"nf_zformat.cpp\",\n+    \"nf_zformat.h\",\n+    \"expr.cc\",\n+    \"function_list.cpp\",\n+    \"inlined_grammar.hpp\",\n+}\n+IGNORED_DIRECTORIES = [\n+    \".eggs\",\n+    \"__pycache__\",\n+    \"dbgen\",\n+    \"tools/pythonpkg/duckdb\",\n+    \"tools/pythonpkg/build\",\n+    \"tools/rpkg/src/duckdb\",\n+    \"tools/rpkg/inst/include/cpp11\",\n+    \"extension/tpcds/dsdgen\",\n+    \"extension/jemalloc/jemalloc\",\n+    \"extension/icu/third_party\",\n+    \"tools/nodejs/src/duckdb\",\n ]\n-format_all = False\n-check_only = True\n-confirm = True\n-silent = False\n-force = False\n-\n-\n-def print_usage():\n-    print(\"Usage: python scripts/format.py [revision|--all] [--check|--fix] [--force]\")\n-    print(\n-        \"   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)\"\n-    )\n-    print(\"                  if [revision] is set to --all, all files will be formatted\")\n-    print(\"   --check only prints differences, --fix also fixes the files (--check is default)\")\n-    exit(1)\n \n+FORMAT_COMMANDS = {\n+    \".cpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".ipp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".c\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp at\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".h\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hh\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".cc\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".txt\": [\"cmake-format\", \"-i\"],\n+    \".py\": [\"black\", \"-q\", \"--skip-string-normalization\", \"--line-length\", \"120\"],\n+    \".java\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".test\": [\"cmake-format\", \"-i\"],\n+    \".test_slow\": [\"cmake-format\", \"-i\"],\n+    \".test_coverage\": [\"cmake-format\", \"-i\"],\n+    \".benchmark\": [\"cmake-format\", \"-i\"],\n+}\n \n-if len(sys.argv) == 1:\n-    revision = \"HEAD\"\n-elif len(sys.argv) >= 2:\n-    revision = sys.argv[1]\n-else:\n-    print_usage()\n \n-if len(sys.argv) > 2:\n-    for arg in sys.argv[2:]:\n-        if arg == '--check':\n-            check_only = True\n-        elif arg == '--fix':\n-            check_only = False\n-        elif arg == '--noconfirm':\n-            confirm = False\n-        elif arg == '--confirm':\n-            confirm = True\n-        elif arg == '--silent':\n-            silent = True\n-        elif arg == '--force':\n-            force = True\n-        else:\n-            print_usage()\n-\n-if revision == '--all':\n-    format_all = True\n+# Argument parsing\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Format source code files\")\n+    parser.add_argument(\n+        \"revision\",\n+        nargs=\"?\",\n+        default=\"HEAD\",\n+        help=\"Revision number to format all files (default: HEAD)\",\n+    )\n+    parser.add_argument(\n+        \"--check\",\n+        action=\"store_true\",\n+        help=\"Check formatting without modifying files (default)\",\n+    )\n+    parser.add_argument(\"--all\", action=\"store_true\", help=\"Format all files\")\n+    parser.add_argument(\"--fix\", action=\"store_true\", help=\"Fix formatting issues in files\")\n+    parser.add_argument(\"--force\", action=\"store_true\", help=\"Format even non-standard files\")\n+    parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress output of formatted files\")\n+    parser.add_argument(\"--noconfirm\", action=\"store_true\", help=\"Skip confirmation prompt for fixing\")\n+    return parser.parse_args()\n \n \n+# File filtering\n def file_is_ignored(full_path):\n-    if os.path.basename(full_path) in ignored_files:\n-        return True\n-    dirnames = os.path.sep.join(full_path.split(os.path.sep)[:-1])\n-    for ignored_directory in ignored_directories:\n-        if ignored_directory in dirnames:\n-            return True\n-    return False\n+    return Path(full_path).name in IGNORED_FILES or any(ignored in str(full_path) for ignored in IGNORED_DIRECTORIES)\n \n \n def can_format_file(full_path):\n-    global extensions, formatted_directories, ignored_files\n-    if not os.path.isfile(full_path):\n+    if not Path(full_path).is_file():\n         return False\n-    fname = full_path.split(os.path.sep)[-1]\n-    found = False\n-    # check file extension\n-    for ext in extensions:\n-        if full_path.endswith(ext):\n-            found = True\n-            break\n-    if not found:\n+    if not any(full_path.endswith(ext) for ext in EXTENSIONS):\n         return False\n-    # check ignored files\n     if file_is_ignored(full_path):\n         return False\n-    # now check file directory\n-    for dname in formatted_directories:\n-        if full_path.startswith(dname):\n-            return True\n-    return False\n-\n-\n-action = \"Formatting\"\n-if check_only:\n-    action = \"Checking\"\n+    return any(full_path.startswith(d) for d in FORMATTED_DIRECTORIES)\n \n \n+# File collection\n def get_changed_files(revision):\n-    proc = subprocess.Popen(['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)\n-    files = proc.stdout.read().decode('utf8').split('\\n')\n-    changed_files = []\n-    for f in files:\n-        if not can_format_file(f):\n-            continue\n-        if file_is_ignored(f):\n-            continue\n-        changed_files.append(f)\n-    return changed_files\n-\n-\n-if os.path.isfile(revision):\n-    print(action + \" individual file: \" + revision)\n-    changed_files = [revision]\n-elif os.path.isdir(revision):\n-    print(action + \" files in directory: \" + revision)\n-    changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]\n+    result = subprocess.run([\"git\", \"diff\", \"--name-only\", revision], capture_output=True, text=True)\n+    return [f for f in result.stdout.splitlines() if can_format_file(f) and not file_is_ignored(f)]\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-elif not format_all:\n-    if revision == 'main':\n-        # fetch new changes when comparing to the master\n-        os.system(\"git fetch origin main:main\")\n-    print(action + \" since branch or revision: \" + revision)\n-    changed_files = get_changed_files(revision)\n-    if len(changed_files) == 0:\n-        print(\"No changed files found!\")\n-        exit(0)\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-else:\n-    print(action + \" all files\")\n-\n-if confirm and not check_only:\n-    print(\"The files listed above will be reformatted.\")\n-    result = input(\"Continue with changes (y/n)?\\n\")\n-    if result != 'y':\n-        print(\"Aborting.\")\n-        exit(0)\n-\n-format_commands = {\n-    '.cpp': cpp_format_command,\n-    '.ipp': cpp_format_command,\n-    '.c': cpp_format_command,\n-    '.hpp': cpp_format_command,\n-    '.h': cpp_format_command,\n-    '.hh': cpp_format_command,\n-    '.cc': cpp_format_command,\n-    '.txt': cmake_format_command,\n-    '.py': 'black --quiet - --skip-string-normalization --line-length 120 --stdin-filename',\n-    '.java': cpp_format_command,\n-}\n-\n-difference_files = []\n-\n-header_top = \"//===----------------------------------------------------------------------===//\\n\"\n-header_top += \"//                         DuckDB\\n\" + \"//\\n\"\n-header_bottom = \"//\\n\" + \"//\\n\"\n-header_bottom += \"//===----------------------------------------------------------------------===//\\n\\n\"\n-base_dir = os.path.join(os.getcwd(), 'src/include')\n+def format_directory(directory):\n+    files = []\n+    for path in Path(directory).rglob(\"*\"):\n+        if path.is_file() and can_format_file(str(path)):\n+            files.append(str(path))\n+    return files\n \n \n-def get_formatted_text(f, full_path, directory, ext):\n-    if not can_format_file(full_path):\n+# Formatting logic\n+def format_file(full_path, check_only, force, silent):\n+    ext = Path(full_path).suffix\n+    if ext not in FORMAT_COMMANDS:\n         if not force:\n-            print(\n-                \"File \"\n-                + full_path\n-                + \" is not normally formatted - but attempted to format anyway. Use --force if formatting is desirable\"\n-            )\n-            exit(1)\n-    if f == 'list.hpp':\n-        # fill in list file\n-        file_list = [\n-            os.path.join(dp, f)\n-            for dp, dn, filenames in os.walk(directory)\n-            for f in filenames\n-            if os.path.splitext(f)[1] == '.hpp' and not f.endswith(\"list.hpp\")\n-        ]\n-        file_list = [x.replace('src/include/', '') for x in file_list]\n-        file_list.sort()\n-        result = \"\"\n-        for x in file_list:\n-            result += '#include \"%s\"\\n' % (x)\n-        return result\n-\n-    if ext == \".hpp\" and directory.startswith(\"src/include\"):\n-        with open_utf8(full_path, 'r') as f:\n-            lines = f.readlines()\n-\n-        # format header in files\n-        header_middle = \"// \" + os.path.relpath(full_path, base_dir) + \"\\n\"\n-        text = header_top + header_middle + header_bottom\n-        is_old_header = True\n-        for line in lines:\n-            if not (line.startswith(\"//\") or line.startswith(\"\\n\")) and is_old_header:\n-                is_old_header = False\n-            if not is_old_header:\n-                text += line\n-\n-    if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':",
        "comment_created_at": "2025-05-02T16:16:08+00:00",
        "comment_author": "adsharma",
        "comment_body": "I missed that. What if we move the formatting logic here to a tool of its own and invoke it similar to other tools?",
        "pr_file_module": null
      },
      {
        "comment_id": "2071944133",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17305,
        "pr_file": "scripts/format.py",
        "discussion_id": "2071322192",
        "commented_code": "@@ -1,467 +1,299 @@\n-#!/usr/bin/python\n-\n-# this script is used to format the source directory\n+#!/usr/bin/python3\n \n import os\n-import time\n-import sys\n-import inspect\n import subprocess\n-import difflib\n-import re\n-import tempfile\n-import uuid\n+import sys\n+import argparse\n import concurrent.futures\n-from python_helpers import open_utf8\n-\n-try:\n-    ver = subprocess.check_output(('black', '--version'), text=True)\n-    if int(ver.split(' ')[1].split('.')[0]) < 24:\n-        print('you need to run `pip install \"black>=24\"`', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install \"black>=24\"`', e)\n-    exit(-1)\n-\n-try:\n-    ver = subprocess.check_output(('clang-format', '--version'), text=True)\n-    if '11.' not in ver:\n-        print('you need to run `pip install clang_format==11.0.1 - `', ver)\n-        exit(-1)\n-except Exception as e:\n-    print('you need to run `pip install clang_format==11.0.1 - `', e)\n-    exit(-1)\n-\n-cpp_format_command = 'clang-format --sort-includes=0 -style=file'\n-cmake_format_command = 'cmake-format'\n+import difflib\n+from pathlib import Path\n \n-try:\n-    subprocess.check_output(('cmake-format', '--version'), text=True)\n-except Exception as e:\n-    print('you need to run `pip install cmake-format`', e)\n-    exit(-1)\n \n-extensions = [\n-    '.cpp',\n-    '.ipp',\n-    '.c',\n-    '.hpp',\n-    '.h',\n-    '.cc',\n-    '.hh',\n-    'CMakeLists.txt',\n-    '.test',\n-    '.test_slow',\n-    '.test_coverage',\n-    '.benchmark',\n-    '.py',\n-    '.java',\n+# Check formatter versions\n+def check_formatter_version(command, version_key, min_version, install_instruction):\n+    try:\n+        output = subprocess.check_output(command, text=True).strip()\n+        # Extract version number for clang-format (e.g., \"11.0.1\" from \"clang-format version 11.0.1...\")\n+        if command[0] == \"clang-format\":\n+            version = output.split()[2].split(\".\")[0]\n+        elif command[0] == \"black\":\n+            version = output.split()[1].split(\".\")[0]\n+        else:\n+            version = output.split()[0].split(\".\")[0]\n+        version_key_mismatch = version_key is not None and version_key not in output\n+        if version_key_mismatch or int(version) < min_version:\n+            print(f\"Please install {install_instruction}\")\n+            print(f\"Required: {min_version}. Present: {version}\")\n+            sys.exit(1)\n+    except Exception as e:\n+        breakpoint()\n+        print(f\"Please install {install_instruction}: {e}\")\n+        sys.exit(1)\n+\n+\n+# Configuration\n+EXTENSIONS = [\n+    \".cpp\",\n+    \".ipp\",\n+    \".c\",\n+    \".hpp\",\n+    \".h\",\n+    \".cc\",\n+    \".hh\",\n+    \"CMakeLists.txt\",\n+    \".py\",\n+    \".java\",\n ]\n-formatted_directories = ['src', 'benchmark', 'test', 'tools', 'examples', 'extension', 'scripts']\n-ignored_files = [\n-    'tpch_constants.hpp',\n-    'tpcds_constants.hpp',\n-    '_generated',\n-    'tpce_flat_input.hpp',\n-    'test_csv_header.hpp',\n-    'duckdb.cpp',\n-    'duckdb.hpp',\n-    'json.hpp',\n-    'sqlite3.h',\n-    'shell.c',\n-    'termcolor.hpp',\n-    'test_insert_invalid.test',\n-    'httplib.hpp',\n-    'os_win.c',\n-    'glob.c',\n-    'printf.c',\n-    'helper.hpp',\n-    'single_thread_ptr.hpp',\n-    'types.hpp',\n-    'default_views.cpp',\n-    'default_functions.cpp',\n-    'release.h',\n-    'genrand.cpp',\n-    'address.cpp',\n-    'visualizer_constants.hpp',\n-    'icu-collate.cpp',\n-    'icu-collate.hpp',\n-    'yyjson.cpp',\n-    'yyjson.hpp',\n-    'duckdb_pdqsort.hpp',\n-    'stubdata.cpp',\n-    'nf_calendar.cpp',\n-    'nf_calendar.h',\n-    'nf_localedata.cpp',\n-    'nf_localedata.h',\n-    'nf_zformat.cpp',\n-    'nf_zformat.h',\n-    'expr.cc',\n-    'function_list.cpp',\n-    'inlined_grammar.hpp',\n+FORMATTED_DIRECTORIES = [\n+    \"src\",\n+    \"benchmark\",\n+    \"test\",\n+    \"tools\",\n+    \"examples\",\n+    \"extension\",\n+    \"scripts\",\n ]\n-ignored_directories = [\n-    '.eggs',\n-    '__pycache__',\n-    'dbgen',\n-    os.path.join('tools', 'pythonpkg', 'duckdb'),\n-    os.path.join('tools', 'pythonpkg', 'build'),\n-    os.path.join('tools', 'rpkg', 'src', 'duckdb'),\n-    os.path.join('tools', 'rpkg', 'inst', 'include', 'cpp11'),\n-    os.path.join('extension', 'tpcds', 'dsdgen'),\n-    os.path.join('extension', 'jemalloc', 'jemalloc'),\n-    os.path.join('extension', 'icu', 'third_party'),\n-    os.path.join('tools', 'nodejs', 'src', 'duckdb'),\n+IGNORED_FILES = {\n+    \"tpch_constants.hpp\",\n+    \"tpcds_constants.hpp\",\n+    \"_generated\",\n+    \"tpce_flat_input.hpp\",\n+    \"test_csv_header.hpp\",\n+    \"duckdb.cpp\",\n+    \"duckdb.hpp\",\n+    \"json.hpp\",\n+    \"sqlite3.h\",\n+    \"shell.c\",\n+    \"termcolor.hpp\",\n+    \"test_insert_invalid.test\",\n+    \"httplib.hpp\",\n+    \"os_win.c\",\n+    \"glob.c\",\n+    \"printf.c\",\n+    \"helper.hpp\",\n+    \"single_thread_ptr.hpp\",\n+    \"types.hpp\",\n+    \"default_views.cpp\",\n+    \"default_functions.cpp\",\n+    \"release.h\",\n+    \"genrand.cpp\",\n+    \"address.cpp\",\n+    \"visualizer_constants.hpp\",\n+    \"icu-collate.cpp\",\n+    \"icu-collate.hpp\",\n+    \"yyjson.cpp\",\n+    \"yyjson.hpp\",\n+    \"duckdb_pdqsort.hpp\",\n+    \"stubdata.cpp\",\n+    \"nf_calendar.cpp\",\n+    \"nf_calendar.h\",\n+    \"nf_localedata.cpp\",\n+    \"nf_localedata.h\",\n+    \"nf_zformat.cpp\",\n+    \"nf_zformat.h\",\n+    \"expr.cc\",\n+    \"function_list.cpp\",\n+    \"inlined_grammar.hpp\",\n+}\n+IGNORED_DIRECTORIES = [\n+    \".eggs\",\n+    \"__pycache__\",\n+    \"dbgen\",\n+    \"tools/pythonpkg/duckdb\",\n+    \"tools/pythonpkg/build\",\n+    \"tools/rpkg/src/duckdb\",\n+    \"tools/rpkg/inst/include/cpp11\",\n+    \"extension/tpcds/dsdgen\",\n+    \"extension/jemalloc/jemalloc\",\n+    \"extension/icu/third_party\",\n+    \"tools/nodejs/src/duckdb\",\n ]\n-format_all = False\n-check_only = True\n-confirm = True\n-silent = False\n-force = False\n-\n-\n-def print_usage():\n-    print(\"Usage: python scripts/format.py [revision|--all] [--check|--fix] [--force]\")\n-    print(\n-        \"   [revision]     is an optional revision number, all files that changed since that revision will be formatted (default=HEAD)\"\n-    )\n-    print(\"                  if [revision] is set to --all, all files will be formatted\")\n-    print(\"   --check only prints differences, --fix also fixes the files (--check is default)\")\n-    exit(1)\n \n+FORMAT_COMMANDS = {\n+    \".cpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".ipp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".c\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp at\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hpp\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".h\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".hh\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".cc\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".txt\": [\"cmake-format\", \"-i\"],\n+    \".py\": [\"black\", \"-q\", \"--skip-string-normalization\", \"--line-length\", \"120\"],\n+    \".java\": [\"clang-format\", \"-i\", \"--sort-includes=0\", \"-style=file\"],\n+    \".test\": [\"cmake-format\", \"-i\"],\n+    \".test_slow\": [\"cmake-format\", \"-i\"],\n+    \".test_coverage\": [\"cmake-format\", \"-i\"],\n+    \".benchmark\": [\"cmake-format\", \"-i\"],\n+}\n \n-if len(sys.argv) == 1:\n-    revision = \"HEAD\"\n-elif len(sys.argv) >= 2:\n-    revision = sys.argv[1]\n-else:\n-    print_usage()\n \n-if len(sys.argv) > 2:\n-    for arg in sys.argv[2:]:\n-        if arg == '--check':\n-            check_only = True\n-        elif arg == '--fix':\n-            check_only = False\n-        elif arg == '--noconfirm':\n-            confirm = False\n-        elif arg == '--confirm':\n-            confirm = True\n-        elif arg == '--silent':\n-            silent = True\n-        elif arg == '--force':\n-            force = True\n-        else:\n-            print_usage()\n-\n-if revision == '--all':\n-    format_all = True\n+# Argument parsing\n+def parse_args():\n+    parser = argparse.ArgumentParser(description=\"Format source code files\")\n+    parser.add_argument(\n+        \"revision\",\n+        nargs=\"?\",\n+        default=\"HEAD\",\n+        help=\"Revision number to format all files (default: HEAD)\",\n+    )\n+    parser.add_argument(\n+        \"--check\",\n+        action=\"store_true\",\n+        help=\"Check formatting without modifying files (default)\",\n+    )\n+    parser.add_argument(\"--all\", action=\"store_true\", help=\"Format all files\")\n+    parser.add_argument(\"--fix\", action=\"store_true\", help=\"Fix formatting issues in files\")\n+    parser.add_argument(\"--force\", action=\"store_true\", help=\"Format even non-standard files\")\n+    parser.add_argument(\"--silent\", action=\"store_true\", help=\"Suppress output of formatted files\")\n+    parser.add_argument(\"--noconfirm\", action=\"store_true\", help=\"Skip confirmation prompt for fixing\")\n+    return parser.parse_args()\n \n \n+# File filtering\n def file_is_ignored(full_path):\n-    if os.path.basename(full_path) in ignored_files:\n-        return True\n-    dirnames = os.path.sep.join(full_path.split(os.path.sep)[:-1])\n-    for ignored_directory in ignored_directories:\n-        if ignored_directory in dirnames:\n-            return True\n-    return False\n+    return Path(full_path).name in IGNORED_FILES or any(ignored in str(full_path) for ignored in IGNORED_DIRECTORIES)\n \n \n def can_format_file(full_path):\n-    global extensions, formatted_directories, ignored_files\n-    if not os.path.isfile(full_path):\n+    if not Path(full_path).is_file():\n         return False\n-    fname = full_path.split(os.path.sep)[-1]\n-    found = False\n-    # check file extension\n-    for ext in extensions:\n-        if full_path.endswith(ext):\n-            found = True\n-            break\n-    if not found:\n+    if not any(full_path.endswith(ext) for ext in EXTENSIONS):\n         return False\n-    # check ignored files\n     if file_is_ignored(full_path):\n         return False\n-    # now check file directory\n-    for dname in formatted_directories:\n-        if full_path.startswith(dname):\n-            return True\n-    return False\n-\n-\n-action = \"Formatting\"\n-if check_only:\n-    action = \"Checking\"\n+    return any(full_path.startswith(d) for d in FORMATTED_DIRECTORIES)\n \n \n+# File collection\n def get_changed_files(revision):\n-    proc = subprocess.Popen(['git', 'diff', '--name-only', revision], stdout=subprocess.PIPE)\n-    files = proc.stdout.read().decode('utf8').split('\\n')\n-    changed_files = []\n-    for f in files:\n-        if not can_format_file(f):\n-            continue\n-        if file_is_ignored(f):\n-            continue\n-        changed_files.append(f)\n-    return changed_files\n-\n-\n-if os.path.isfile(revision):\n-    print(action + \" individual file: \" + revision)\n-    changed_files = [revision]\n-elif os.path.isdir(revision):\n-    print(action + \" files in directory: \" + revision)\n-    changed_files = [os.path.join(revision, x) for x in os.listdir(revision)]\n+    result = subprocess.run([\"git\", \"diff\", \"--name-only\", revision], capture_output=True, text=True)\n+    return [f for f in result.stdout.splitlines() if can_format_file(f) and not file_is_ignored(f)]\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-elif not format_all:\n-    if revision == 'main':\n-        # fetch new changes when comparing to the master\n-        os.system(\"git fetch origin main:main\")\n-    print(action + \" since branch or revision: \" + revision)\n-    changed_files = get_changed_files(revision)\n-    if len(changed_files) == 0:\n-        print(\"No changed files found!\")\n-        exit(0)\n \n-    print(\"Changeset:\")\n-    for fname in changed_files:\n-        print(fname)\n-else:\n-    print(action + \" all files\")\n-\n-if confirm and not check_only:\n-    print(\"The files listed above will be reformatted.\")\n-    result = input(\"Continue with changes (y/n)?\\n\")\n-    if result != 'y':\n-        print(\"Aborting.\")\n-        exit(0)\n-\n-format_commands = {\n-    '.cpp': cpp_format_command,\n-    '.ipp': cpp_format_command,\n-    '.c': cpp_format_command,\n-    '.hpp': cpp_format_command,\n-    '.h': cpp_format_command,\n-    '.hh': cpp_format_command,\n-    '.cc': cpp_format_command,\n-    '.txt': cmake_format_command,\n-    '.py': 'black --quiet - --skip-string-normalization --line-length 120 --stdin-filename',\n-    '.java': cpp_format_command,\n-}\n-\n-difference_files = []\n-\n-header_top = \"//===----------------------------------------------------------------------===//\\n\"\n-header_top += \"//                         DuckDB\\n\" + \"//\\n\"\n-header_bottom = \"//\\n\" + \"//\\n\"\n-header_bottom += \"//===----------------------------------------------------------------------===//\\n\\n\"\n-base_dir = os.path.join(os.getcwd(), 'src/include')\n+def format_directory(directory):\n+    files = []\n+    for path in Path(directory).rglob(\"*\"):\n+        if path.is_file() and can_format_file(str(path)):\n+            files.append(str(path))\n+    return files\n \n \n-def get_formatted_text(f, full_path, directory, ext):\n-    if not can_format_file(full_path):\n+# Formatting logic\n+def format_file(full_path, check_only, force, silent):\n+    ext = Path(full_path).suffix\n+    if ext not in FORMAT_COMMANDS:\n         if not force:\n-            print(\n-                \"File \"\n-                + full_path\n-                + \" is not normally formatted - but attempted to format anyway. Use --force if formatting is desirable\"\n-            )\n-            exit(1)\n-    if f == 'list.hpp':\n-        # fill in list file\n-        file_list = [\n-            os.path.join(dp, f)\n-            for dp, dn, filenames in os.walk(directory)\n-            for f in filenames\n-            if os.path.splitext(f)[1] == '.hpp' and not f.endswith(\"list.hpp\")\n-        ]\n-        file_list = [x.replace('src/include/', '') for x in file_list]\n-        file_list.sort()\n-        result = \"\"\n-        for x in file_list:\n-            result += '#include \"%s\"\\n' % (x)\n-        return result\n-\n-    if ext == \".hpp\" and directory.startswith(\"src/include\"):\n-        with open_utf8(full_path, 'r') as f:\n-            lines = f.readlines()\n-\n-        # format header in files\n-        header_middle = \"// \" + os.path.relpath(full_path, base_dir) + \"\\n\"\n-        text = header_top + header_middle + header_bottom\n-        is_old_header = True\n-        for line in lines:\n-            if not (line.startswith(\"//\") or line.startswith(\"\\n\")) and is_old_header:\n-                is_old_header = False\n-            if not is_old_header:\n-                text += line\n-\n-    if ext == '.test' or ext == '.test_slow' or ext == '.test_coverage' or ext == '.benchmark':",
        "comment_created_at": "2025-05-02T17:39:19+00:00",
        "comment_author": "adsharma",
        "comment_body": "Updated implementation tries to stick to the original algorithm as closely as possible. A small number of deltas were found and included in a separate commit for your review.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2007748209",
    "pr_number": 16759,
    "pr_file": "scripts/regression/test_runner.py",
    "created_at": "2025-03-21T14:50:03+00:00",
    "commented_code": "# nuke cached benchmark data between runs\n if os.path.isdir(\"duckdb_benchmark_data\"):\n     shutil.rmtree('duckdb_benchmark_data')\n+\n+if summary and not no_summary:\n+    print(\n+        '''\n\n====================================================\n+================  FAILURES SUMMARY  ================\n+====================================================\n+'''\n+    )\n+    for i, failure_message in enumerate(summary, start=1):\n+        print(f\"{i}: \", failure_message[\"benchmark\"])\n+        if failure_message[\"old_failure\"] != failure_message[\"new_failure\"]:\n+            print(\"Old:\n\", failure_message[\"old_failure\"])\n+            print(\"New:\n\", failure_message[\"new_failure\"])\n+        else:\n+            print(failure_message[\"old_failure\"])\n+",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2007748209",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16759,
        "pr_file": "scripts/regression/test_runner.py",
        "discussion_id": "2007748209",
        "commented_code": "@@ -175,4 +191,20 @@ class BenchmarkResult:\n # nuke cached benchmark data between runs\n if os.path.isdir(\"duckdb_benchmark_data\"):\n     shutil.rmtree('duckdb_benchmark_data')\n+\n+if summary and not no_summary:\n+    print(\n+        '''\\n\\n====================================================\n+================  FAILURES SUMMARY  ================\n+====================================================\n+'''\n+    )\n+    for i, failure_message in enumerate(summary, start=1):\n+        print(f\"{i}: \", failure_message[\"benchmark\"])\n+        if failure_message[\"old_failure\"] != failure_message[\"new_failure\"]:\n+            print(\"Old:\\n\", failure_message[\"old_failure\"])\n+            print(\"New:\\n\", failure_message[\"new_failure\"])\n+        else:\n+            print(failure_message[\"old_failure\"])\n+",
        "comment_created_at": "2025-03-21T14:50:03+00:00",
        "comment_author": "carlopi",
        "comment_body": "Here format is different that above, with 3 lines instead of single line, maybe the can be made somewhat more similar?\r\n\r\nAlso here it's `f{i}: ` above `f{i}. `, I would try to set up on a standard to follow.",
        "pr_file_module": null
      }
    ]
  }
]