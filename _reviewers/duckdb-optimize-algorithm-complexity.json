[
  {
    "discussion_id": "2191645093",
    "pr_number": 17992,
    "pr_file": "src/include/duckdb/common/types/string.hpp",
    "created_at": "2025-07-08T06:56:44+00:00",
    "commented_code": "+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/string.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+\n+namespace duckdb {\n+class String {\n+public:\n+\t// Owning constructors\n+\tString(std::string str) // NOLINT: allow implicit conversion\n+\t    : owned_data(std::move(str)), data(owned_data.c_str()), size(owned_data.size()) {\n+\t}\n+\n+\tString(const char *ptr, const size_t len) : owned_data(ptr, len), data(ptr), size(len) {\n+\t}\n+\n+\tString(const char *ptr) // NOLINT: allow implicit conversion\n+\t    : String(ptr, strlen(ptr)) {\n+\t}\n+\n+\t// Non-owning constructors\n+\tstatic String CreateView(const char *ptr, const size_t len) {\n+\t\tString str;\n+\t\tstr.data = ptr;\n+\t\tstr.size = len;\n+\t\treturn str;\n+\t}\n+\n+\tstatic String CreateView(const char *ptr) {\n+\t\treturn CreateView(ptr, strlen(ptr));\n+\t}\n+\n+public:\n+\tbool operator==(const String &other) const {\n+\t\tconst idx_t this_size = GetSize();\n+\t\tconst idx_t other_size = other.GetSize();\n+\n+\t\tif (this_size != other_size) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tconst char *this_data = GetData();\n+\t\tconst char *other_data = other.GetData();\n+",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2191645093",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17992,
        "pr_file": "src/include/duckdb/common/types/string.hpp",
        "discussion_id": "2191645093",
        "commented_code": "@@ -0,0 +1,190 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/string.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+\n+namespace duckdb {\n+class String {\n+public:\n+\t// Owning constructors\n+\tString(std::string str) // NOLINT: allow implicit conversion\n+\t    : owned_data(std::move(str)), data(owned_data.c_str()), size(owned_data.size()) {\n+\t}\n+\n+\tString(const char *ptr, const size_t len) : owned_data(ptr, len), data(ptr), size(len) {\n+\t}\n+\n+\tString(const char *ptr) // NOLINT: allow implicit conversion\n+\t    : String(ptr, strlen(ptr)) {\n+\t}\n+\n+\t// Non-owning constructors\n+\tstatic String CreateView(const char *ptr, const size_t len) {\n+\t\tString str;\n+\t\tstr.data = ptr;\n+\t\tstr.size = len;\n+\t\treturn str;\n+\t}\n+\n+\tstatic String CreateView(const char *ptr) {\n+\t\treturn CreateView(ptr, strlen(ptr));\n+\t}\n+\n+public:\n+\tbool operator==(const String &other) const {\n+\t\tconst idx_t this_size = GetSize();\n+\t\tconst idx_t other_size = other.GetSize();\n+\n+\t\tif (this_size != other_size) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tconst char *this_data = GetData();\n+\t\tconst char *other_data = other.GetData();\n+",
        "comment_created_at": "2025-07-08T06:56:44+00:00",
        "comment_author": "carlopi",
        "comment_body": "```suggestion\r\n\r\n      if (this_data == other_data) {\r\n            return true;\r\n      }\r\n      \r\n```\r\nshort-circuit if they point to same underlying data.\r\n\r\nAlso maybe some library (`memcmp` or a friend) are likely faster.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2193076354",
    "pr_number": 17992,
    "pr_file": "src/include/duckdb/common/types/string.hpp",
    "created_at": "2025-07-08T17:32:04+00:00",
    "commented_code": "const char *this_data = GetData();\n \t\tconst char *other_data = other.GetData();\n \n+\t\tif (memcmp(this_data, other_data, this_size) == 0) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2193076354",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17992,
        "pr_file": "src/include/duckdb/common/types/string.hpp",
        "discussion_id": "2193076354",
        "commented_code": "@@ -50,6 +50,10 @@ class String {\n \t\tconst char *this_data = GetData();\n \t\tconst char *other_data = other.GetData();\n \n+\t\tif (memcmp(this_data, other_data, this_size) == 0) {",
        "comment_created_at": "2025-07-08T17:32:04+00:00",
        "comment_author": "carlopi",
        "comment_body": "I think that something is off here.\r\n\r\nI though of two changes:\r\n* fast check if `this_data` and `other_data` point to exact the same location (say one is a view on the other, you might want a faster that iteration check)\r\n* second, using `auto res = memcmp(this_data, other_data, this_size);` instead of a loop.\r\nI think current changes are quadratic.\r\n\r\nI would have gone for something similar to here: https://github.com/duckdb/duckdb/blob/223ff0a7dba7900039d5910a009247ef097fff3c/src/include/duckdb/common/types/string_type.hpp#L209",
        "pr_file_module": null
      },
      {
        "comment_id": "2259373595",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17992,
        "pr_file": "src/include/duckdb/common/types/string.hpp",
        "discussion_id": "2193076354",
        "commented_code": "@@ -50,6 +50,10 @@ class String {\n \t\tconst char *this_data = GetData();\n \t\tconst char *other_data = other.GetData();\n \n+\t\tif (memcmp(this_data, other_data, this_size) == 0) {",
        "comment_created_at": "2025-08-07T07:24:04+00:00",
        "comment_author": "maiadegraaf",
        "comment_body": "Thanks! Yes this makes more sense! ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2165992422",
    "pr_number": 18037,
    "pr_file": ".github/patches/extensions/azure/azure_loader_and_timestamp.patch",
    "created_at": "2025-06-25T07:22:40+00:00",
    "commented_code": "-#endif\n +}\n \\ No newline at end of file\n+diff --git a/src/azure_filesystem.cpp b/src/azure_filesystem.cpp\n+index d7ed201..ef11c56 100644\n+--- a/src/azure_filesystem.cpp\n++++ b/src/azure_filesystem.cpp\n+@@ -40,7 +40,7 @@ AzureFileHandle::AzureFileHandle(AzureStorageFileSystem &fs, const OpenFileInfo\n+ \t\t}\n+ \t\tauto entry2 = info.extended_info->options.find(\"last_modified\");\n+ \t\tif (entry2 != info.extended_info->options.end()) {\n+-\t\t\tlast_modified = Timestamp::ToTimeT(entry2->second.GetValue<timestamp_t>());\n++\t\t\tlast_modified = entry2->second.GetValue<timestamp_t>();\n+ \t\t}\n+ \t}\n+ }\n+@@ -93,7 +93,7 @@ int64_t AzureStorageFileSystem::GetFileSize(FileHandle &handle) {\n+ \treturn afh.length;\n+ }\n+ \n+-time_t AzureStorageFileSystem::GetLastModifiedTime(FileHandle &handle) {\n++timestamp_t AzureStorageFileSystem::GetLastModifiedTime(FileHandle &handle) {\n+ \tauto &afh = handle.Cast<AzureFileHandle>();\n+ \treturn afh.last_modified;\n+ }\n+@@ -228,9 +228,9 @@ AzureReadOptions AzureStorageFileSystem::ParseAzureReadOptions(optional_ptr<File\n+ \treturn options;\n+ }\n+ \n+-time_t AzureStorageFileSystem::ToTimeT(const Azure::DateTime &dt) {\n++timestamp_t AzureStorageFileSystem::ToTimestamp(const Azure::DateTime &dt) {\n+ \tauto time_point = static_cast<std::chrono::system_clock::time_point>(dt);\n+-\treturn std::chrono::system_clock::to_time_t(time_point);\n++\treturn Timestamp::FromTimeT(std::chrono::system_clock::to_time_t(time_point));",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2165992422",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18037,
        "pr_file": ".github/patches/extensions/azure/azure_loader_and_timestamp.patch",
        "discussion_id": "2165992422",
        "commented_code": "@@ -70,6 +122,40 @@ index 5ce0b8d..d0758e2 100644\n -#endif\n +}\n \\ No newline at end of file\n+diff --git a/src/azure_filesystem.cpp b/src/azure_filesystem.cpp\n+index d7ed201..ef11c56 100644\n+--- a/src/azure_filesystem.cpp\n++++ b/src/azure_filesystem.cpp\n+@@ -40,7 +40,7 @@ AzureFileHandle::AzureFileHandle(AzureStorageFileSystem &fs, const OpenFileInfo\n+ \t\t}\n+ \t\tauto entry2 = info.extended_info->options.find(\"last_modified\");\n+ \t\tif (entry2 != info.extended_info->options.end()) {\n+-\t\t\tlast_modified = Timestamp::ToTimeT(entry2->second.GetValue<timestamp_t>());\n++\t\t\tlast_modified = entry2->second.GetValue<timestamp_t>();\n+ \t\t}\n+ \t}\n+ }\n+@@ -93,7 +93,7 @@ int64_t AzureStorageFileSystem::GetFileSize(FileHandle &handle) {\n+ \treturn afh.length;\n+ }\n+ \n+-time_t AzureStorageFileSystem::GetLastModifiedTime(FileHandle &handle) {\n++timestamp_t AzureStorageFileSystem::GetLastModifiedTime(FileHandle &handle) {\n+ \tauto &afh = handle.Cast<AzureFileHandle>();\n+ \treturn afh.last_modified;\n+ }\n+@@ -228,9 +228,9 @@ AzureReadOptions AzureStorageFileSystem::ParseAzureReadOptions(optional_ptr<File\n+ \treturn options;\n+ }\n+ \n+-time_t AzureStorageFileSystem::ToTimeT(const Azure::DateTime &dt) {\n++timestamp_t AzureStorageFileSystem::ToTimestamp(const Azure::DateTime &dt) {\n+ \tauto time_point = static_cast<std::chrono::system_clock::time_point>(dt);\n+-\treturn std::chrono::system_clock::to_time_t(time_point);\n++\treturn Timestamp::FromTimeT(std::chrono::system_clock::to_time_t(time_point));",
        "comment_created_at": "2025-06-25T07:22:40+00:00",
        "comment_author": "Mytherin",
        "comment_body": "We should be able to directly go from the time_point to our timestamp using `time_since_epoch`, e.g.:\r\n\r\n```sql\r\nstd::chrono::duration_cast<std::chrono::microseconds>(time_point.time_since_epoch()).count();\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1965484084",
    "pr_number": 16304,
    "pr_file": "src/include/duckdb/function/cast/vector_cast_helpers.hpp",
    "created_at": "2025-02-21T13:33:42+00:00",
    "commented_code": "throw InternalException(\"Unimplemented internal type for decimal\");\n \t\t}\n \t}\n+\n+\ttemplate <bool WRITE_QUOTES = true>\n+\tstatic idx_t CalculateEscapedStringLength(const string_t &string, const char *special_chars,\n+\t                                          idx_t special_chars_length) {\n+\t\tauto base_length = string.GetSize();\n+\t\tidx_t length = 0;\n+\t\tauto string_data = string.GetData();\n+\t\tif (base_length == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tbool needs_quotes = false;\n+\t\tif (isspace(string_data[0])) {\n+\t\t\tneeds_quotes = true;\n+\t\t} else if (base_length >= 2 && isspace(string_data[base_length - 1])) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\t\tif (base_length == 4 && StringUtil::CIEquals(std::string(string_data, string_data + base_length), \"null\")) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tconst auto string_end = string_data + base_length;\n+\t\tauto res = std::find_first_of(string_data, string_end, special_chars, special_chars + special_chars_length);\n+\t\tif (res != string_end) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tif (!needs_quotes) {\n+\t\t\treturn base_length;\n+\t\t}\n+\n+\t\tfor (idx_t i = 0; i < base_length; i++) {\n+\t\t\tif (string_data[i] == '\\'' || string_data[i] == '\\\\') {\n+\t\t\t\tlength++;\n+\t\t\t}\n+\t\t\tlength++;\n+\t\t}\n+\t\tif (WRITE_QUOTES) {\n+\t\t\tlength += 2;\n+\t\t}\n+\t\treturn length;\n+\t}\n+\n+\ttemplate <bool WRITE_QUOTES = false>\n+\tstatic idx_t CalculateStringLength(const string_t &string, const char *special_chars, idx_t special_chars_length) {\n+\t\treturn string.GetSize();\n+\t}\n+\n+\ttemplate <bool WRITE_QUOTES = false>\n+\tstatic idx_t WriteEscapedString(void *dest, const string_t &string, const char *special_chars,\n+\t                                idx_t special_chars_length) {\n+\t\tauto base_length = string.GetSize();\n+\t\tif (base_length == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tauto string_start = string.GetData();\n+\t\tauto string_data = string_start;\n+\n+\t\tbool needs_quotes = false;\n+\t\tif (isspace(string_data[0])) {\n+\t\t\tneeds_quotes = true;\n+\t\t} else if (base_length >= 2 && isspace(string_data[base_length - 1])) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\t\tif (base_length == 4 && StringUtil::CIEquals(std::string(string_data, string_data + base_length), \"null\")) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tconst auto string_end = string_data + base_length;\n+\t\tauto res = std::find_first_of(string_data, string_end, special_chars, special_chars + special_chars_length);\n+\t\tif (res != string_end) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tauto destination = reinterpret_cast<char *>(dest);\n+\t\tif (!needs_quotes) {\n+\t\t\tmemcpy(destination, string_data, base_length);\n+\t\t\treturn base_length;\n+\t\t}\n+\n+\t\tidx_t offset = 0;\n+\t\tif (WRITE_QUOTES) {\n+\t\t\tmemset(reinterpret_cast<char *>(dest) + offset, '\\'', 1);\n+\t\t\toffset++;\n+\t\t}\n+\n+\t\tstatic constexpr char SPECIAL_CHARACTERS[] = {'\\'', '\\\\'};\n+\n+\t\twhile (string_data < string_end) {\n+\t\t\tauto res = std::find_first_of(string_data, string_end, SPECIAL_CHARACTERS,\n+\t\t\t                              SPECIAL_CHARACTERS + sizeof(SPECIAL_CHARACTERS));\n+\n+\t\t\tif (res == string_end) {\n+\t\t\t\tauto distance = UnsafeNumericCast<size_t>(res - string_data);\n+\t\t\t\tmemcpy(reinterpret_cast<char *>(dest) + offset, string_data, distance);\n+\t\t\t\toffset += distance;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tauto length = UnsafeNumericCast<size_t>(res - string_data);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1965484084",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16304,
        "pr_file": "src/include/duckdb/function/cast/vector_cast_helpers.hpp",
        "discussion_id": "1965484084",
        "commented_code": "@@ -180,6 +180,128 @@ struct VectorCastHelpers {\n \t\t\tthrow InternalException(\"Unimplemented internal type for decimal\");\n \t\t}\n \t}\n+\n+\ttemplate <bool WRITE_QUOTES = true>\n+\tstatic idx_t CalculateEscapedStringLength(const string_t &string, const char *special_chars,\n+\t                                          idx_t special_chars_length) {\n+\t\tauto base_length = string.GetSize();\n+\t\tidx_t length = 0;\n+\t\tauto string_data = string.GetData();\n+\t\tif (base_length == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tbool needs_quotes = false;\n+\t\tif (isspace(string_data[0])) {\n+\t\t\tneeds_quotes = true;\n+\t\t} else if (base_length >= 2 && isspace(string_data[base_length - 1])) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\t\tif (base_length == 4 && StringUtil::CIEquals(std::string(string_data, string_data + base_length), \"null\")) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tconst auto string_end = string_data + base_length;\n+\t\tauto res = std::find_first_of(string_data, string_end, special_chars, special_chars + special_chars_length);\n+\t\tif (res != string_end) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tif (!needs_quotes) {\n+\t\t\treturn base_length;\n+\t\t}\n+\n+\t\tfor (idx_t i = 0; i < base_length; i++) {\n+\t\t\tif (string_data[i] == '\\'' || string_data[i] == '\\\\') {\n+\t\t\t\tlength++;\n+\t\t\t}\n+\t\t\tlength++;\n+\t\t}\n+\t\tif (WRITE_QUOTES) {\n+\t\t\tlength += 2;\n+\t\t}\n+\t\treturn length;\n+\t}\n+\n+\ttemplate <bool WRITE_QUOTES = false>\n+\tstatic idx_t CalculateStringLength(const string_t &string, const char *special_chars, idx_t special_chars_length) {\n+\t\treturn string.GetSize();\n+\t}\n+\n+\ttemplate <bool WRITE_QUOTES = false>\n+\tstatic idx_t WriteEscapedString(void *dest, const string_t &string, const char *special_chars,\n+\t                                idx_t special_chars_length) {\n+\t\tauto base_length = string.GetSize();\n+\t\tif (base_length == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tauto string_start = string.GetData();\n+\t\tauto string_data = string_start;\n+\n+\t\tbool needs_quotes = false;\n+\t\tif (isspace(string_data[0])) {\n+\t\t\tneeds_quotes = true;\n+\t\t} else if (base_length >= 2 && isspace(string_data[base_length - 1])) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\t\tif (base_length == 4 && StringUtil::CIEquals(std::string(string_data, string_data + base_length), \"null\")) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tconst auto string_end = string_data + base_length;\n+\t\tauto res = std::find_first_of(string_data, string_end, special_chars, special_chars + special_chars_length);\n+\t\tif (res != string_end) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tauto destination = reinterpret_cast<char *>(dest);\n+\t\tif (!needs_quotes) {\n+\t\t\tmemcpy(destination, string_data, base_length);\n+\t\t\treturn base_length;\n+\t\t}\n+\n+\t\tidx_t offset = 0;\n+\t\tif (WRITE_QUOTES) {\n+\t\t\tmemset(reinterpret_cast<char *>(dest) + offset, '\\'', 1);\n+\t\t\toffset++;\n+\t\t}\n+\n+\t\tstatic constexpr char SPECIAL_CHARACTERS[] = {'\\'', '\\\\'};\n+\n+\t\twhile (string_data < string_end) {\n+\t\t\tauto res = std::find_first_of(string_data, string_end, SPECIAL_CHARACTERS,\n+\t\t\t                              SPECIAL_CHARACTERS + sizeof(SPECIAL_CHARACTERS));\n+\n+\t\t\tif (res == string_end) {\n+\t\t\t\tauto distance = UnsafeNumericCast<size_t>(res - string_data);\n+\t\t\t\tmemcpy(reinterpret_cast<char *>(dest) + offset, string_data, distance);\n+\t\t\t\toffset += distance;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tauto length = UnsafeNumericCast<size_t>(res - string_data);",
        "comment_created_at": "2025-02-21T13:33:42+00:00",
        "comment_author": "Mytherin",
        "comment_body": "We can avoid `find_first_of` here by predicating, not sure if this is worth it, maybe you can benchmark it:\r\n\r\n```cpp\r\nchar c = string_data[current_pos];\r\nresult[result_offset] = '\\\\';\r\nresult_offset += c == '\\\\' || c == '\\'';\r\nresult[result_offset] = c;\r\nresult_offset++;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1965486087",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16304,
        "pr_file": "src/include/duckdb/function/cast/vector_cast_helpers.hpp",
        "discussion_id": "1965484084",
        "commented_code": "@@ -180,6 +180,128 @@ struct VectorCastHelpers {\n \t\t\tthrow InternalException(\"Unimplemented internal type for decimal\");\n \t\t}\n \t}\n+\n+\ttemplate <bool WRITE_QUOTES = true>\n+\tstatic idx_t CalculateEscapedStringLength(const string_t &string, const char *special_chars,\n+\t                                          idx_t special_chars_length) {\n+\t\tauto base_length = string.GetSize();\n+\t\tidx_t length = 0;\n+\t\tauto string_data = string.GetData();\n+\t\tif (base_length == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tbool needs_quotes = false;\n+\t\tif (isspace(string_data[0])) {\n+\t\t\tneeds_quotes = true;\n+\t\t} else if (base_length >= 2 && isspace(string_data[base_length - 1])) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\t\tif (base_length == 4 && StringUtil::CIEquals(std::string(string_data, string_data + base_length), \"null\")) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tconst auto string_end = string_data + base_length;\n+\t\tauto res = std::find_first_of(string_data, string_end, special_chars, special_chars + special_chars_length);\n+\t\tif (res != string_end) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tif (!needs_quotes) {\n+\t\t\treturn base_length;\n+\t\t}\n+\n+\t\tfor (idx_t i = 0; i < base_length; i++) {\n+\t\t\tif (string_data[i] == '\\'' || string_data[i] == '\\\\') {\n+\t\t\t\tlength++;\n+\t\t\t}\n+\t\t\tlength++;\n+\t\t}\n+\t\tif (WRITE_QUOTES) {\n+\t\t\tlength += 2;\n+\t\t}\n+\t\treturn length;\n+\t}\n+\n+\ttemplate <bool WRITE_QUOTES = false>\n+\tstatic idx_t CalculateStringLength(const string_t &string, const char *special_chars, idx_t special_chars_length) {\n+\t\treturn string.GetSize();\n+\t}\n+\n+\ttemplate <bool WRITE_QUOTES = false>\n+\tstatic idx_t WriteEscapedString(void *dest, const string_t &string, const char *special_chars,\n+\t                                idx_t special_chars_length) {\n+\t\tauto base_length = string.GetSize();\n+\t\tif (base_length == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tauto string_start = string.GetData();\n+\t\tauto string_data = string_start;\n+\n+\t\tbool needs_quotes = false;\n+\t\tif (isspace(string_data[0])) {\n+\t\t\tneeds_quotes = true;\n+\t\t} else if (base_length >= 2 && isspace(string_data[base_length - 1])) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\t\tif (base_length == 4 && StringUtil::CIEquals(std::string(string_data, string_data + base_length), \"null\")) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tconst auto string_end = string_data + base_length;\n+\t\tauto res = std::find_first_of(string_data, string_end, special_chars, special_chars + special_chars_length);\n+\t\tif (res != string_end) {\n+\t\t\tneeds_quotes = true;\n+\t\t}\n+\n+\t\tauto destination = reinterpret_cast<char *>(dest);\n+\t\tif (!needs_quotes) {\n+\t\t\tmemcpy(destination, string_data, base_length);\n+\t\t\treturn base_length;\n+\t\t}\n+\n+\t\tidx_t offset = 0;\n+\t\tif (WRITE_QUOTES) {\n+\t\t\tmemset(reinterpret_cast<char *>(dest) + offset, '\\'', 1);\n+\t\t\toffset++;\n+\t\t}\n+\n+\t\tstatic constexpr char SPECIAL_CHARACTERS[] = {'\\'', '\\\\'};\n+\n+\t\twhile (string_data < string_end) {\n+\t\t\tauto res = std::find_first_of(string_data, string_end, SPECIAL_CHARACTERS,\n+\t\t\t                              SPECIAL_CHARACTERS + sizeof(SPECIAL_CHARACTERS));\n+\n+\t\t\tif (res == string_end) {\n+\t\t\t\tauto distance = UnsafeNumericCast<size_t>(res - string_data);\n+\t\t\t\tmemcpy(reinterpret_cast<char *>(dest) + offset, string_data, distance);\n+\t\t\t\toffset += distance;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tauto length = UnsafeNumericCast<size_t>(res - string_data);",
        "comment_created_at": "2025-02-21T13:35:17+00:00",
        "comment_author": "Mytherin",
        "comment_body": "For the size measurement we can do something similar:\r\n\r\n```cpp\r\nchar c = string_data[current_pos];\r\nstr_len += c == '\\\\' || c == '\\'';\r\nstr_len++;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2137322607",
    "pr_number": 17459,
    "pr_file": "src/include/duckdb/planner/logical_operator_deep_copy.hpp",
    "created_at": "2025-06-10T09:00:27+00:00",
    "commented_code": "+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/planner/logical_operator_deep_copy.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/common.hpp\"\n+#include \"duckdb/planner/bound_tokens.hpp\"\n+#include \"duckdb/planner/logical_tokens.hpp\"\n+\n+#include \"duckdb/planner/logical_operator_visitor.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/planner/bound_parameter_map.hpp\"\n+\n+namespace duckdb {\n+\n+//! While it is possible to copy a logical plan using `Copy()`, both, the original and the copy\n+//! are\u2014by design\u2014identical. This includes any table_idx values etc. This is bad, when we try\n+//! to use part of a logical plan multiple times in the same plan.\n+//! The LogicalOperatorDeepCopy first copies a LogicalOperator, but then traverses the entire plan\n+//! and replaces all table indexes. We store a map from the original table index to the new index,\n+//! which we use in the TableBindingReplacer to correct all column accesses.\n+class LogicalOperatorDeepCopy : public LogicalOperatorVisitor {\n+public:\n+\tLogicalOperatorDeepCopy(Binder &binder, optional_ptr<bound_parameter_map_t> parameter_data);\n+\n+\tunique_ptr<LogicalOperator> DeepCopy(unique_ptr<LogicalOperator> &op);\n+\n+private:\n+\tvoid VisitOperator(LogicalOperator &op) override;\n+\n+private:\n+\t// Single-field version\n+\ttemplate <typename T>\n+\tvoid ReplaceTableIndex(LogicalOperator &op);\n+\t// Multi-field version\n+\ttemplate <typename T>\n+\tvoid ReplaceTableIndexMulti(LogicalOperator &op);\n+\n+private:\n+\tBinder &binder;\n+\tstd::map<idx_t, idx_t> table_idx_replacements;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2137322607",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17459,
        "pr_file": "src/include/duckdb/planner/logical_operator_deep_copy.hpp",
        "discussion_id": "2137322607",
        "commented_code": "@@ -0,0 +1,67 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/planner/logical_operator_deep_copy.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/common.hpp\"\n+#include \"duckdb/planner/bound_tokens.hpp\"\n+#include \"duckdb/planner/logical_tokens.hpp\"\n+\n+#include \"duckdb/planner/logical_operator_visitor.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/planner/bound_parameter_map.hpp\"\n+\n+namespace duckdb {\n+\n+//! While it is possible to copy a logical plan using `Copy()`, both, the original and the copy\n+//! are\u2014by design\u2014identical. This includes any table_idx values etc. This is bad, when we try\n+//! to use part of a logical plan multiple times in the same plan.\n+//! The LogicalOperatorDeepCopy first copies a LogicalOperator, but then traverses the entire plan\n+//! and replaces all table indexes. We store a map from the original table index to the new index,\n+//! which we use in the TableBindingReplacer to correct all column accesses.\n+class LogicalOperatorDeepCopy : public LogicalOperatorVisitor {\n+public:\n+\tLogicalOperatorDeepCopy(Binder &binder, optional_ptr<bound_parameter_map_t> parameter_data);\n+\n+\tunique_ptr<LogicalOperator> DeepCopy(unique_ptr<LogicalOperator> &op);\n+\n+private:\n+\tvoid VisitOperator(LogicalOperator &op) override;\n+\n+private:\n+\t// Single-field version\n+\ttemplate <typename T>\n+\tvoid ReplaceTableIndex(LogicalOperator &op);\n+\t// Multi-field version\n+\ttemplate <typename T>\n+\tvoid ReplaceTableIndexMulti(LogicalOperator &op);\n+\n+private:\n+\tBinder &binder;\n+\tstd::map<idx_t, idx_t> table_idx_replacements;",
        "comment_created_at": "2025-06-10T09:00:27+00:00",
        "comment_author": "lnkuiper",
        "comment_body": "I don't see the code relying the table indices being ordered. Can this be an `unordered_map` instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "2137401925",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17459,
        "pr_file": "src/include/duckdb/planner/logical_operator_deep_copy.hpp",
        "discussion_id": "2137322607",
        "commented_code": "@@ -0,0 +1,67 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/planner/logical_operator_deep_copy.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/common.hpp\"\n+#include \"duckdb/planner/bound_tokens.hpp\"\n+#include \"duckdb/planner/logical_tokens.hpp\"\n+\n+#include \"duckdb/planner/logical_operator_visitor.hpp\"\n+#include \"duckdb/planner/binder.hpp\"\n+#include \"duckdb/planner/bound_parameter_map.hpp\"\n+\n+namespace duckdb {\n+\n+//! While it is possible to copy a logical plan using `Copy()`, both, the original and the copy\n+//! are\u2014by design\u2014identical. This includes any table_idx values etc. This is bad, when we try\n+//! to use part of a logical plan multiple times in the same plan.\n+//! The LogicalOperatorDeepCopy first copies a LogicalOperator, but then traverses the entire plan\n+//! and replaces all table indexes. We store a map from the original table index to the new index,\n+//! which we use in the TableBindingReplacer to correct all column accesses.\n+class LogicalOperatorDeepCopy : public LogicalOperatorVisitor {\n+public:\n+\tLogicalOperatorDeepCopy(Binder &binder, optional_ptr<bound_parameter_map_t> parameter_data);\n+\n+\tunique_ptr<LogicalOperator> DeepCopy(unique_ptr<LogicalOperator> &op);\n+\n+private:\n+\tvoid VisitOperator(LogicalOperator &op) override;\n+\n+private:\n+\t// Single-field version\n+\ttemplate <typename T>\n+\tvoid ReplaceTableIndex(LogicalOperator &op);\n+\t// Multi-field version\n+\ttemplate <typename T>\n+\tvoid ReplaceTableIndexMulti(LogicalOperator &op);\n+\n+private:\n+\tBinder &binder;\n+\tstd::map<idx_t, idx_t> table_idx_replacements;",
        "comment_created_at": "2025-06-10T09:42:12+00:00",
        "comment_author": "kryonix",
        "comment_body": "Good point. This is absolutely not required.",
        "pr_file_module": null
      }
    ]
  }
]