[
  {
    "discussion_id": "2190298887",
    "pr_number": 17692,
    "pr_file": "src/function/pragma/pragma_functions.cpp",
    "created_at": "2025-07-07T14:39:55+00:00",
    "commented_code": "set.AddFunction(PragmaFunction::PragmaStatement(\"enable_object_cache\", PragmaEnableObjectCache));\n \tset.AddFunction(PragmaFunction::PragmaStatement(\"disable_object_cache\", PragmaDisableObjectCache));\n \n-\tset.AddFunction(PragmaFunction::PragmaCall(\"enable_logging\", PragmaEnableLogging, {}, LogicalType::VARCHAR));\n+\tauto logging_enable_function =\n+\t    PragmaFunction::PragmaCall(\"enable_logging\", PragmaEnableLogging, {}, LogicalType::ANY);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2190298887",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17692,
        "pr_file": "src/function/pragma/pragma_functions.cpp",
        "discussion_id": "2190298887",
        "commented_code": "@@ -176,7 +196,11 @@ void PragmaFunctions::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(PragmaFunction::PragmaStatement(\"enable_object_cache\", PragmaEnableObjectCache));\n \tset.AddFunction(PragmaFunction::PragmaStatement(\"disable_object_cache\", PragmaDisableObjectCache));\n \n-\tset.AddFunction(PragmaFunction::PragmaCall(\"enable_logging\", PragmaEnableLogging, {}, LogicalType::VARCHAR));\n+\tauto logging_enable_function =\n+\t    PragmaFunction::PragmaCall(\"enable_logging\", PragmaEnableLogging, {}, LogicalType::ANY);",
        "comment_created_at": "2025-07-07T14:39:55+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Can we maybe turn this into a table function? `CALL enable_logging(....)`",
        "pr_file_module": null
      },
      {
        "comment_id": "2190303703",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17692,
        "pr_file": "src/function/pragma/pragma_functions.cpp",
        "discussion_id": "2190298887",
        "commented_code": "@@ -176,7 +196,11 @@ void PragmaFunctions::RegisterFunction(BuiltinFunctions &set) {\n \tset.AddFunction(PragmaFunction::PragmaStatement(\"enable_object_cache\", PragmaEnableObjectCache));\n \tset.AddFunction(PragmaFunction::PragmaStatement(\"disable_object_cache\", PragmaDisableObjectCache));\n \n-\tset.AddFunction(PragmaFunction::PragmaCall(\"enable_logging\", PragmaEnableLogging, {}, LogicalType::VARCHAR));\n+\tauto logging_enable_function =\n+\t    PragmaFunction::PragmaCall(\"enable_logging\", PragmaEnableLogging, {}, LogicalType::ANY);",
        "comment_created_at": "2025-07-07T14:42:00+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Maybe add a comment as well to the pragmas so that this is clear for devs looking at adding a new one and to encourage them to instead add a setting or table function",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166403958",
    "pr_number": 18054,
    "pr_file": "test/sqlite/sqllogic_test_runner.cpp",
    "created_at": "2025-06-25T10:41:26+00:00",
    "commented_code": "config->options.allow_unredacted_secrets = true;\n \tconfig->options.load_extensions = false;\n \n+\tauto &test_config = TestConfiguration::Get();\n+\tloading_mode = test_config.GetExtensionLoadingMode();\n+\tinstall_mode = test_config.GetExtensionInstallMode();\n+\n+\tconfig->options.autoload_known_extensions = false;\n+\tconfig->options.autoinstall_known_extensions = false;\n+\tconfig->options.allow_unsigned_extensions = true;\n+\tlocal_extension_repo = \"\";\n+\n \tauto env_var = std::getenv(\"LOCAL_EXTENSION_REPO\");",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2166403958",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18054,
        "pr_file": "test/sqlite/sqllogic_test_runner.cpp",
        "discussion_id": "2166403958",
        "commented_code": "@@ -23,13 +23,55 @@ SQLLogicTestRunner::SQLLogicTestRunner(string dbpath) : dbpath(std::move(dbpath)\n \tconfig->options.allow_unredacted_secrets = true;\n \tconfig->options.load_extensions = false;\n \n+\tauto &test_config = TestConfiguration::Get();\n+\tloading_mode = test_config.GetExtensionLoadingMode();\n+\tinstall_mode = test_config.GetExtensionInstallMode();\n+\n+\tconfig->options.autoload_known_extensions = false;\n+\tconfig->options.autoinstall_known_extensions = false;\n+\tconfig->options.allow_unsigned_extensions = true;\n+\tlocal_extension_repo = \"\";\n+\n \tauto env_var = std::getenv(\"LOCAL_EXTENSION_REPO\");",
        "comment_created_at": "2025-06-25T10:41:26+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Ideally the `LOCAL_EXTENSION_REPO` environment variable should also be removed and everything should be moved to the new config",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163248847",
    "pr_number": 17955,
    "pr_file": "src/function/pragma/pragma_functions.cpp",
    "created_at": "2025-06-24T08:09:02+00:00",
    "commented_code": "DBConfig::GetConfig(context).options.checkpoint_on_shutdown = false;\n }\n \n+static void PragmaEnableWalEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_wal_encryption = true;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2163248847",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17955,
        "pr_file": "src/function/pragma/pragma_functions.cpp",
        "discussion_id": "2163248847",
        "commented_code": "@@ -115,6 +115,14 @@ static void PragmaDisableCheckpointOnShutdown(ClientContext &context, const Func\n \tDBConfig::GetConfig(context).options.checkpoint_on_shutdown = false;\n }\n \n+static void PragmaEnableWalEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_wal_encryption = true;",
        "comment_created_at": "2025-06-24T08:09:02+00:00",
        "comment_author": "Mytherin",
        "comment_body": "We try to avoid pragmas nowadays - can you replace this with a setting (e.g. `SET wal_encryption=...`)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2156987002",
    "pr_number": 17950,
    "pr_file": "src/storage/single_file_block_manager.cpp",
    "created_at": "2025-06-19T13:09:12+00:00",
    "commented_code": "}\n \n \tMainHeader main_header = DeserializeMainHeader(header_buffer.buffer - delta);\n-\n-\tif (main_header.IsEncrypted() && !options.encryption_options.encryption_enabled) {\n-\t\t// Todo; look if keys are stored in DuckDB secrets\n-\t\t// then automatically derive that key\n-\t\tthrow CatalogException(\"Cannot open encrypted database \\\"%s\\\" without a key\", path);\n-\t}\n+\tauto &config = DBConfig::GetConfig(db.GetDatabase());\n \n \tif (!main_header.IsEncrypted() && options.encryption_options.encryption_enabled) {\n+\t\tthrow CatalogException(\"A key is explicitly specified, but database \\\"%s\\\" is not encrypted\", path);\n \t\t// database is not encrypted, but is tried to be opened with a key\n-\t\tthrow CatalogException(\"A key is specified, but database \\\"%s\\\" is not encrypted\", path);\n+\t} else if (!main_header.IsEncrypted() && config.options.contains_user_key) {\n+\t\t// We provide a -key, but database is not encrypted\n+\t\tthrow CatalogException(\"A key is explicitly specified, but database \\\"%s\\\" is not encrypted\", path);\n+\t}\n \n-\t} else if (main_header.IsEncrypted()) {\n+\tif (main_header.IsEncrypted()) {\n+\t\t// encryption is set, check if the given key upon attach is correct\n \t\t//! Get the stored salt\n \t\tuint8_t salt[MainHeader::SALT_LEN];\n \t\tmemset(salt, 0, MainHeader::SALT_LEN);\n \t\tmemcpy(salt, main_header.GetSalt(), MainHeader::SALT_LEN);\n \n-\t\t//! Check if the correct key is used to decrypt the database\n-\t\t// Derive the encryption key and add it to cache\n-\t\tdata_t derived_key[MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH];\n-\t\tEncryptionKeyManager::DeriveKey(*options.encryption_options.user_key, salt, derived_key);\n-\t\t// delete user key\n-\t\toptions.encryption_options.user_key = nullptr;\n-\t\tauto encryption_state = db.GetDatabase().GetEncryptionUtil()->CreateEncryptionState(\n-\t\t    derived_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n-\t\tif (!DecryptCanary(main_header, encryption_state, derived_key)) {\n-\t\t\tthrow IOException(\"Wrong encryption key used to open the database file\");\n+\t\tif (options.encryption_options.encryption_enabled) {\n+\t\t\t//! Key given with attach\n+\t\t\t//! Check if the correct key is used to decrypt the database\n+\t\t\t// Derive the encryption key and add it to cache\n+\t\t\tCheckAndAddEncryptionKey(main_header);\n+\t\t\t// delete user key ptr\n+\t\t\toptions.encryption_options.user_key = nullptr;\n+\t\t} else if (config.options.contains_user_key) {\n+\t\t\t//! A new (encrypted) database is added through the Command Line\n+\t\t\t//! If a user key is given, let's try this key\n+\t\t\t//! If it succeeds, we put the key in cache\n+\t\t\t//! input key is with -key in the command line\n+\t\t\tCheckAndAddEncryptionKey(main_header, *config.options.user_key);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2156987002",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17950,
        "pr_file": "src/storage/single_file_block_manager.cpp",
        "discussion_id": "2156987002",
        "commented_code": "@@ -412,36 +455,48 @@ void SingleFileBlockManager::LoadExistingDatabase() {\n \t}\n \n \tMainHeader main_header = DeserializeMainHeader(header_buffer.buffer - delta);\n-\n-\tif (main_header.IsEncrypted() && !options.encryption_options.encryption_enabled) {\n-\t\t// Todo; look if keys are stored in DuckDB secrets\n-\t\t// then automatically derive that key\n-\t\tthrow CatalogException(\"Cannot open encrypted database \\\"%s\\\" without a key\", path);\n-\t}\n+\tauto &config = DBConfig::GetConfig(db.GetDatabase());\n \n \tif (!main_header.IsEncrypted() && options.encryption_options.encryption_enabled) {\n+\t\tthrow CatalogException(\"A key is explicitly specified, but database \\\"%s\\\" is not encrypted\", path);\n \t\t// database is not encrypted, but is tried to be opened with a key\n-\t\tthrow CatalogException(\"A key is specified, but database \\\"%s\\\" is not encrypted\", path);\n+\t} else if (!main_header.IsEncrypted() && config.options.contains_user_key) {\n+\t\t// We provide a -key, but database is not encrypted\n+\t\tthrow CatalogException(\"A key is explicitly specified, but database \\\"%s\\\" is not encrypted\", path);\n+\t}\n \n-\t} else if (main_header.IsEncrypted()) {\n+\tif (main_header.IsEncrypted()) {\n+\t\t// encryption is set, check if the given key upon attach is correct\n \t\t//! Get the stored salt\n \t\tuint8_t salt[MainHeader::SALT_LEN];\n \t\tmemset(salt, 0, MainHeader::SALT_LEN);\n \t\tmemcpy(salt, main_header.GetSalt(), MainHeader::SALT_LEN);\n \n-\t\t//! Check if the correct key is used to decrypt the database\n-\t\t// Derive the encryption key and add it to cache\n-\t\tdata_t derived_key[MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH];\n-\t\tEncryptionKeyManager::DeriveKey(*options.encryption_options.user_key, salt, derived_key);\n-\t\t// delete user key\n-\t\toptions.encryption_options.user_key = nullptr;\n-\t\tauto encryption_state = db.GetDatabase().GetEncryptionUtil()->CreateEncryptionState(\n-\t\t    derived_key, MainHeader::DEFAULT_ENCRYPTION_KEY_LENGTH);\n-\t\tif (!DecryptCanary(main_header, encryption_state, derived_key)) {\n-\t\t\tthrow IOException(\"Wrong encryption key used to open the database file\");\n+\t\tif (options.encryption_options.encryption_enabled) {\n+\t\t\t//! Key given with attach\n+\t\t\t//! Check if the correct key is used to decrypt the database\n+\t\t\t// Derive the encryption key and add it to cache\n+\t\t\tCheckAndAddEncryptionKey(main_header);\n+\t\t\t// delete user key ptr\n+\t\t\toptions.encryption_options.user_key = nullptr;\n+\t\t} else if (config.options.contains_user_key) {\n+\t\t\t//! A new (encrypted) database is added through the Command Line\n+\t\t\t//! If a user key is given, let's try this key\n+\t\t\t//! If it succeeds, we put the key in cache\n+\t\t\t//! input key is with -key in the command line\n+\t\t\tCheckAndAddEncryptionKey(main_header, *config.options.user_key);",
        "comment_created_at": "2025-06-19T13:09:12+00:00",
        "comment_author": "Mytherin",
        "comment_body": "It feels to me like the distinction between \"provided using `user_key` vs provided as `ATTACH` option\" should be made at a higher level, and we should just get the key as part of the provided StorageOptions here. Perhaps that could be done in order to simplify the code here?",
        "pr_file_module": null
      }
    ]
  }
]