[
  {
    "discussion_id": "2072501988",
    "pr_number": 17353,
    "pr_file": "src/include/duckdb/common/enums/catalog_type.hpp",
    "created_at": "2025-05-04T02:24:22+00:00",
    "commented_code": "enum class CatalogType : uint8_t {\n \tINVALID = 0,\n \tTABLE_ENTRY = 1,\n-\tSCHEMA_ENTRY = 2,\n-\tVIEW_ENTRY = 3,\n-\tINDEX_ENTRY = 4,\n-\tPREPARED_STATEMENT = 5,\n-\tSEQUENCE_ENTRY = 6,\n-\tCOLLATION_ENTRY = 7,\n-\tTYPE_ENTRY = 8,\n-\tDATABASE_ENTRY = 9,\n+\tMATVIEW_ENTRY = 2,",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2072501988",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17353,
        "pr_file": "src/include/duckdb/common/enums/catalog_type.hpp",
        "discussion_id": "2072501988",
        "commented_code": "@@ -18,14 +18,15 @@ namespace duckdb {\n enum class CatalogType : uint8_t {\n \tINVALID = 0,\n \tTABLE_ENTRY = 1,\n-\tSCHEMA_ENTRY = 2,\n-\tVIEW_ENTRY = 3,\n-\tINDEX_ENTRY = 4,\n-\tPREPARED_STATEMENT = 5,\n-\tSEQUENCE_ENTRY = 6,\n-\tCOLLATION_ENTRY = 7,\n-\tTYPE_ENTRY = 8,\n-\tDATABASE_ENTRY = 9,\n+\tMATVIEW_ENTRY = 2,",
        "comment_created_at": "2025-05-04T02:24:22+00:00",
        "comment_author": "Maxxen",
        "comment_body": "I don't think you can change the orders of these without breaking serialization and backwards/compatability.",
        "pr_file_module": null
      },
      {
        "comment_id": "2072529034",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17353,
        "pr_file": "src/include/duckdb/common/enums/catalog_type.hpp",
        "discussion_id": "2072501988",
        "commented_code": "@@ -18,14 +18,15 @@ namespace duckdb {\n enum class CatalogType : uint8_t {\n \tINVALID = 0,\n \tTABLE_ENTRY = 1,\n-\tSCHEMA_ENTRY = 2,\n-\tVIEW_ENTRY = 3,\n-\tINDEX_ENTRY = 4,\n-\tPREPARED_STATEMENT = 5,\n-\tSEQUENCE_ENTRY = 6,\n-\tCOLLATION_ENTRY = 7,\n-\tTYPE_ENTRY = 8,\n-\tDATABASE_ENTRY = 9,\n+\tMATVIEW_ENTRY = 2,",
        "comment_created_at": "2025-05-04T06:03:55+00:00",
        "comment_author": "kyungmax",
        "comment_body": "@Maxxen Thank you for the review. I'll append the new entry to the last. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140289641",
    "pr_number": 16581,
    "pr_file": "test/api/serialized_plans/serialized_plans.binary",
    "created_at": "2025-06-11T14:05:56+00:00",
    "commented_code": null,
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2140289641",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16581,
        "pr_file": "test/api/serialized_plans/serialized_plans.binary",
        "discussion_id": "2140289641",
        "commented_code": null,
        "comment_created_at": "2025-06-11T14:05:56+00:00",
        "comment_author": "Mytherin",
        "comment_body": "We should not need to re-generate the serialized plans here. If this is necessary something is going wrong with serialization which can impact forward and/or backward compatibility. Can you revert this change and instead fix what caused this to be necessary?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1918516350",
    "pr_number": 15547,
    "pr_file": "src/include/duckdb/function/function_serialization.hpp",
    "created_at": "2025-01-16T13:14:12+00:00",
    "commented_code": "static pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1918516350",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:14:12+00:00",
        "comment_author": "Maxxen",
        "comment_body": "I don't think this is the right way to go about this. As far as Im aware functions (like all identifiers) can have dots in their name. This is a macro, but id imagine it would work for functions too.\r\n```sql\r\nCREATE OR REPLACE FUNCTION \"foo.bar\"() as 1 + 2;\r\nD select \"foo.bar\"();\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 \"foo.bar\"() \u2502\r\n\u2502    int32    \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502           3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI would instead serialize the catalog and schema as separate properties. Then you can even set the `SYSTEM_CATALOG` and `DEFAULT_SCHEMA` as explicit defaults. This would then cause the catalog and schema fields to be omitted when they are the defaults, ensuring older version of DuckDB could still read the  serialized plans from a later DuckDB if they only contain functions within the default catalog/schema.  ",
        "pr_file_module": null
      },
      {
        "comment_id": "1918522248",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:16:33+00:00",
        "comment_author": "rustyconover",
        "comment_body": "I originally tried to do that, but I need the catalog name and schema name before the other function information and I couldn't figure out a way to change the order of deserialization since everything uses numeric tags and must be deserialized in order.  ",
        "pr_file_module": null
      },
      {
        "comment_id": "1918527828",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:18:31+00:00",
        "comment_author": "rustyconover",
        "comment_body": "Do you know of a technique where I can deserialize the catalog and schema name fields back in the order it needed to perform the lookup?",
        "pr_file_module": null
      },
      {
        "comment_id": "1918565242",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:33:01+00:00",
        "comment_author": "Maxxen",
        "comment_body": "I see, that's unfortunate. Although in this case I think it's fine? The `DeserializeFunction` call doesn't actually read anything (it just does a catalog lookup) so I think you could defer doing that until after you've read the new catalog/schema fields (with id 504 and 505) AFTER the 503 \"has_serialize\". \r\n\r\nSomething like this?\r\n```c++\r\n\ttemplate <class FUNC, class CATALOG_ENTRY>\r\n\tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\r\n\t\tauto &context = deserializer.Get<ClientContext &>();\r\n\t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\r\n\t\tauto arguments = deserializer.ReadProperty<vector<LogicalType>>(501, \"arguments\");\r\n\t\tauto original_arguments = deserializer.ReadProperty<vector<LogicalType>>(502, \"original_arguments\");\r\n\r\n\t\tauto has_serialize = deserializer.ReadProperty<bool>(503, \"has_serialize\");\r\n\t\tauto schema = deserializer.ReadPropertyWithExplicitDefault<string>(504, \"function_schema\", DEFAULT_SCHEMA);\r\n\t\tauto catalog = deserializer.ReadPropertyWithExplicitDefault<string>(505, \"function_catalog\", SYSTEM_CATALOG);\r\n\r\n\t\t// Now call DeserializeFunction to get the actual function, potentially passing in the catalog and schema?\r\n\t\tauto function = DeserializeFunction<FUNC, CATALOG_ENTRY>(context, catalog_type, name, std::move(arguments),\r\n\t\t\t\t\t\t\t\t\t std::move(original_arguments));\r\n\r\n\t\treturn make_pair(std::move(function), has_serialize);\r\n\t}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1918566698",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:34:06+00:00",
        "comment_author": "Maxxen",
        "comment_body": "ah no wait, shit, that doesn't work on the serialization side cause you need to write the function data...",
        "pr_file_module": null
      },
      {
        "comment_id": "1918568492",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:35:23+00:00",
        "comment_author": "rustyconover",
        "comment_body": "Yep @Maxxen you are right - I ran into that problem hence this hack. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1918588806",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:48:23+00:00",
        "comment_author": "Maxxen",
        "comment_body": "So, even though field identifiers are numeric, I don't think they actually have to be \"in order\", you just can't change the type of existing ones. Meaning, I think you should be able to add new properties with e.g. id `505` and `506` _before_ the existing `504` \"function_data\". As long as the fields are set to their default values (which they most likely will be for the vast majority of functions) they won't be serialized so you'd preserve forwards-compatibility at least in that case. \r\n\r\nThat said, I think we're currently trying to not break forwards compatibility at all for a while, or at least there has been some work in trying to make it explicit/identifiable when a database contains \"newer\" entities that older versions won't be able to deserialize. But since functions aren't normally serialized as part of the database file anyway Im not sure what the current policy is...",
        "pr_file_module": null
      },
      {
        "comment_id": "1918590406",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-01-16T13:49:26+00:00",
        "comment_author": "Maxxen",
        "comment_body": "Somewhat related: https://github.com/duckdb/duckdb/pull/15702",
        "pr_file_module": null
      },
      {
        "comment_id": "2090180763",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15547,
        "pr_file": "src/include/duckdb/function/function_serialization.hpp",
        "discussion_id": "1918516350",
        "commented_code": "@@ -51,10 +59,29 @@ class FunctionSerializer {\n \tstatic pair<FUNC, bool> DeserializeBase(Deserializer &deserializer, CatalogType catalog_type) {\n \t\tauto &context = deserializer.Get<ClientContext &>();\n \t\tauto name = deserializer.ReadProperty<string>(500, \"name\");\n+\t\tstring catalog_name;\n+\t\tstring schema_name;\n+\t\tif (name.find('.') != std::string::npos) {\n+\t\t\tstd::vector<std::string> parts;\n+\t\t\tstd::stringstream ss(name);\n+\t\t\tstd::string token;\n+\n+\t\t\twhile (std::getline(ss, token, '.')) {\n+\t\t\t\tparts.push_back(token);\n+\t\t\t}\n+\n+\t\t\tif (parts.size() != 3) {\n+\t\t\t\tthrow InternalException(\n+\t\t\t\t    \"DeserializeBase - expected three parts for fully qualified serialized function %s\", name);\n+\t\t\t}\n+\t\t\tcatalog_name = parts[0];\n+\t\t\tschema_name = parts[1];\n+\t\t\tname = parts[2];",
        "comment_created_at": "2025-05-15T03:50:15+00:00",
        "comment_author": "rustyconover",
        "comment_body": "@Maxxen do you think we can get this landed in 1.3.x?  Can we break compatibility now?  @carlopi what do you think?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2009808315",
    "pr_number": 16800,
    "pr_file": "test/sql/storage/storage_versions.test",
    "created_at": "2025-03-24T09:38:40+00:00",
    "commented_code": "SELECT tags FROM duckdb_databases() WHERE database_name LIKE 'empty%' ORDER BY database_name;\n ----\n {storage_version=v1.0.0 - v1.1.3}\n-{storage_version=v1.2.0 - v1.2.1}\n+{storage_version=v1.2.0 - v1.2.2}",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2009808315",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16800,
        "pr_file": "test/sql/storage/storage_versions.test",
        "discussion_id": "2009808315",
        "commented_code": "@@ -24,4 +24,4 @@ query I\n SELECT tags FROM duckdb_databases() WHERE database_name LIKE 'empty%' ORDER BY database_name;\n ----\n {storage_version=v1.0.0 - v1.1.3}\n-{storage_version=v1.2.0 - v1.2.1}\n+{storage_version=v1.2.0 - v1.2.2}",
        "comment_created_at": "2025-03-24T09:38:40+00:00",
        "comment_author": "Tishj",
        "comment_body": "Isn't this wrong now?\r\nThey should just say `v1.0.0+` and `v1.2.0+` ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2009835496",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16800,
        "pr_file": "test/sql/storage/storage_versions.test",
        "discussion_id": "2009808315",
        "commented_code": "@@ -24,4 +24,4 @@ query I\n SELECT tags FROM duckdb_databases() WHERE database_name LIKE 'empty%' ORDER BY database_name;\n ----\n {storage_version=v1.0.0 - v1.1.3}\n-{storage_version=v1.2.0 - v1.2.1}\n+{storage_version=v1.2.0 - v1.2.2}",
        "comment_created_at": "2025-03-24T09:54:41+00:00",
        "comment_author": "carlopi",
        "comment_body": "Thanks! Fixed up.",
        "pr_file_module": null
      }
    ]
  }
]