[
  {
    "discussion_id": "2140269635",
    "pr_number": 16581,
    "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
    "created_at": "2025-06-11T14:00:15+00:00",
    "commented_code": "state.input_chunk.SetCardinality(1);\n \t\tstate.row_index++;\n \t\tstate.new_row = false;\n+\t\tlock_guard<mutex> guard(gstate.ordinality_lock);\n+\t\tgstate.current_ordinality_idx = 1;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2140269635",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16581,
        "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
        "discussion_id": "2140269635",
        "commented_code": "@@ -87,6 +96,8 @@ OperatorResultType PhysicalTableInOutFunction::Execute(ExecutionContext &context\n \t\tstate.input_chunk.SetCardinality(1);\n \t\tstate.row_index++;\n \t\tstate.new_row = false;\n+\t\tlock_guard<mutex> guard(gstate.ordinality_lock);\n+\t\tgstate.current_ordinality_idx = 1;",
        "comment_created_at": "2025-06-11T14:00:15+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Given that the other scan state is all located in the local state - I suspect the global state is the wrong place for the `current_ordinality_idx`. Do we have a test with a larger `UNNEST` or similar table function that triggers multi-threading?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2221423462",
    "pr_number": 18221,
    "pr_file": "extension/autocomplete/keyword_map.cpp",
    "created_at": "2025-07-22T06:58:29+00:00",
    "commented_code": "+/* THIS FILE WAS AUTOMATICALLY GENERATED BY inline_grammar.py */\n+#include \"keyword_helper.hpp\"\n+\n+namespace duckdb {\n+void KeywordHelper::InitializeKeywordMaps() { // Renamed for clarity\n+\tif (initialized) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2221423462",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18221,
        "pr_file": "extension/autocomplete/keyword_map.cpp",
        "discussion_id": "2221423462",
        "commented_code": "@@ -0,0 +1,513 @@\n+/* THIS FILE WAS AUTOMATICALLY GENERATED BY inline_grammar.py */\n+#include \"keyword_helper.hpp\"\n+\n+namespace duckdb {\n+void KeywordHelper::InitializeKeywordMaps() { // Renamed for clarity\n+\tif (initialized) {",
        "comment_created_at": "2025-07-22T06:58:29+00:00",
        "comment_author": "Mytherin",
        "comment_body": "This needs to use `std::call_once`, otherwise this is prone to race conditions",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2078454382",
    "pr_number": 16833,
    "pr_file": "test/unittest.cpp",
    "created_at": "2025-05-07T20:36:38+00:00",
    "commented_code": "return test_memory_leaks;\n }\n \n+bool SummarizeFailures() {\n+\treturn summarize_failures;\n+}\n+\n+size_t GetSummaryCounter() {\n+\treturn ++failures_summary_counter;\n+}\n+\n+std::ostringstream &GetSummary() {\n+\tstatic std::ostringstream summary;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2078454382",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16833,
        "pr_file": "test/unittest.cpp",
        "discussion_id": "2078454382",
        "commented_code": "@@ -24,12 +28,30 @@ bool TestMemoryLeaks() {\n \treturn test_memory_leaks;\n }\n \n+bool SummarizeFailures() {\n+\treturn summarize_failures;\n+}\n+\n+size_t GetSummaryCounter() {\n+\treturn ++failures_summary_counter;\n+}\n+\n+std::ostringstream &GetSummary() {\n+\tstatic std::ostringstream summary;",
        "comment_created_at": "2025-05-07T20:36:38+00:00",
        "comment_author": "Tishj",
        "comment_body": "I think we want to wrap this with a mutex:\r\n```c++\r\nstruct FailureSummary {\r\npublic:\r\n    void AddSummary(const string &failure) {\r\n        std::lock_guard<std::mutex> guard(lock);\r\n        summary << failure;\r\n    }\r\npublic:\r\n    std::ostringstream summary;\r\n    std::mutex lock;\r\n};\r\n```\r\n\r\n```c++\r\nFailureSummary &GetSummary() {\r\n    static FailureSummary summary;\r\n    return summary;\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2078468012",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16833,
        "pr_file": "test/unittest.cpp",
        "discussion_id": "2078454382",
        "commented_code": "@@ -24,12 +28,30 @@ bool TestMemoryLeaks() {\n \treturn test_memory_leaks;\n }\n \n+bool SummarizeFailures() {\n+\treturn summarize_failures;\n+}\n+\n+size_t GetSummaryCounter() {\n+\treturn ++failures_summary_counter;\n+}\n+\n+std::ostringstream &GetSummary() {\n+\tstatic std::ostringstream summary;",
        "comment_created_at": "2025-05-07T20:46:20+00:00",
        "comment_author": "Tishj",
        "comment_body": "Or, looking at how we use the `<<` operator a lot, we could create this instead of the `AddSummary` method:\r\n```c++\r\nvoid SafeAppend(std::function<void(std::ostringstream &)> callback) {\r\n    std::lock_guard<std::mutex> guard(lock);\r\n    callback(summary);\r\n}\r\n```\r\n\r\nused like:\r\n```c++\r\nfailure_summary.SafeAppend([&](std::ostringstream &oss) {\r\n    oss << termcolor::red << termcolor::bold << \"Mismatch on row \" << current_row + 1 << \", column \"\r\n\t\t    << result.ColumnName(current_column) << \"(index \" << current_column + 1 << \")\" << std::endl\r\n\t\t    << termcolor::reset; \r\n});\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1379102490",
    "pr_number": 9014,
    "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
    "created_at": "2023-11-01T17:29:35+00:00",
    "commented_code": null,
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1379102490",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 9014,
        "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
        "discussion_id": "1379102490",
        "commented_code": null,
        "comment_created_at": "2023-11-01T17:29:35+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "I only had a quick look at this file, but this won't work once we start parallelising the operator. If the ordinality data is in the thread-local state, then we build ordinalities for each thread. You must put the ordinality data in the global state, and then you need to synchronise the access to that global state between local states. Or, each thread has to be aware of its current offset in the table function's input.\r\n\r\nCan you please add this test and make sure that it returns correct results? You can see that for higher numbers, the ordinality jumps back to 1 and then starts increasing again.\r\n\r\n```sql\r\nD CREATE TABLE my_tbl (a int);\r\nD INSERT INTO my_tbl SELECT range FROM range(10000000);\r\nD COPY my_tbl TO 'output.csv' (HEADER, DELIMITER ',');\r\nD select * from read_csv_auto('output.csv') with ordinality  where a % 122880 = 0 OR a % 122880 = 1 OR a % 122880 = 122879;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502    a    \u2502 Ordinality \u2502\r\n\u2502  int64  \u2502   int32    \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502       0 \u2502          1 \u2502\r\n\u2502       1 \u2502          2 \u2502\r\n\u2502  122879 \u2502     122880 \u2502\r\n\u2502  122880 \u2502     122881 \u2502\r\n\u2502  122881 \u2502     122882 \u2502\r\n\u2502  245759 \u2502     245760 \u2502\r\n\u2502  245761 \u2502     245762 \u2502\r\n\u2502  245760 \u2502     245761 \u2502\r\n\u2502  368639 \u2502     368640 \u2502\r\n\u2502  368640 \u2502     368641 \u2502\r\n\u2502  368641 \u2502     368642 \u2502\r\n\u2502  491520 \u2502      18505 \u2502\r\n\u2502  491521 \u2502      18506 \u2502\r\n\u2502  491519 \u2502      18504 \u2502\r\n\u2502  614399 \u2502     141384 \u2502\r\n\u2502  614400 \u2502     141385 \u2502\r\n\u2502  614401 \u2502     141386 \u2502\r\n\u2502  737281 \u2502     264266 \u2502\r\n# ...\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1457378376",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 9014,
        "pr_file": "src/execution/operator/projection/physical_tableinout_function.cpp",
        "discussion_id": "1379102490",
        "commented_code": null,
        "comment_created_at": "2024-01-18T12:33:42+00:00",
        "comment_author": "niykko",
        "comment_body": "> I discussed making `WITH ORDINALITY` multithreaded with a colleague. It will take significant effort and is outside of this PR's scope. Instead, let's make the `PhysicalTableInOutFunction` single-threaded if the user did specify `WITH ORDINALITY`.\r\n> \r\n\r\nI will also consider this resolved for now since this PR is just the singlethreaded version :+1: ",
        "pr_file_module": null
      }
    ]
  }
]