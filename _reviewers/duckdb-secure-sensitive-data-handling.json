[
  {
    "discussion_id": "2070177171",
    "pr_number": 17275,
    "pr_file": "src/storage/single_file_block_manager.cpp",
    "created_at": "2025-05-01T11:38:36+00:00",
    "commented_code": "iteration_count(0), options(options) {\n }\n \n+void SingleFileBlockManager::LockEncryptionKey() {\n+\tauto &derived_key = options.encryption_options.derived_key;\n+\n+#if defined(_WIN32)\n+\tVirtualLock(const_cast<void *>(static_cast<const void *>(derived_key.data())), derived_key.size());\n+#else\n+\tmlock(derived_key.data(), derived_key.size());",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2070177171",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17275,
        "pr_file": "src/storage/single_file_block_manager.cpp",
        "discussion_id": "2070177171",
        "commented_code": "@@ -159,6 +255,30 @@ SingleFileBlockManager::SingleFileBlockManager(AttachedDatabase &db, const strin\n       iteration_count(0), options(options) {\n }\n \n+void SingleFileBlockManager::LockEncryptionKey() {\n+\tauto &derived_key = options.encryption_options.derived_key;\n+\n+#if defined(_WIN32)\n+\tVirtualLock(const_cast<void *>(static_cast<const void *>(derived_key.data())), derived_key.size());\n+#else\n+\tmlock(derived_key.data(), derived_key.size());",
        "comment_created_at": "2025-05-01T11:38:36+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Given we are going through lengths here not to page out the memory of the encryption key - I think we should not use a `std::string` to store the encryption key. It is very easy to accidentally copy over an `std::string` which would then negate this protection.\r\n\r\nCan we perhaps rewrite the keys to use a separate class that is not copy constructible (and that calls `mlock`/`munlock` itself perhaps on memory that it is allocating to hold the key?).",
        "pr_file_module": null
      },
      {
        "comment_id": "2071429436",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17275,
        "pr_file": "src/storage/single_file_block_manager.cpp",
        "discussion_id": "2070177171",
        "commented_code": "@@ -159,6 +255,30 @@ SingleFileBlockManager::SingleFileBlockManager(AttachedDatabase &db, const strin\n       iteration_count(0), options(options) {\n }\n \n+void SingleFileBlockManager::LockEncryptionKey() {\n+\tauto &derived_key = options.encryption_options.derived_key;\n+\n+#if defined(_WIN32)\n+\tVirtualLock(const_cast<void *>(static_cast<const void *>(derived_key.data())), derived_key.size());\n+#else\n+\tmlock(derived_key.data(), derived_key.size());",
        "comment_created_at": "2025-05-02T10:40:18+00:00",
        "comment_author": "ccfelius",
        "comment_body": "Sounds good!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2137321184",
    "pr_number": 17275,
    "pr_file": "src/parser/parsed_data/attach_info.cpp",
    "created_at": "2025-06-10T08:59:43+00:00",
    "commented_code": "// even though the corresponding option we expose to the user is called \"block_size\".\n \t\t\tstorage_options.block_alloc_size = entry.second.GetValue<uint64_t>();\n \t\t} else if (entry.first == \"encryption_key\") {\n+\t\t\tauto user_key = entry.second.GetValue<string>();\n+\t\t\t// do we need to check here whether the string is valid?\n+\t\t\tif (user_key.empty() || user_key == \"true\") {\n+\t\t\t\tthrow BinderException(\"\\\"%s\\\" is not a valid key. A key must not be empty\", entry.second.ToString());\n+\t\t\t}\n+\t\t\tstorage_options.encryption_key = user_key;\n+\n+\t\t\t// clear the user key\n+\t\t\tfill(user_key.begin(), user_key.end(), '\\0');\n+\t\t\tuser_key.clear();\n+\n \t\t\tstorage_options.block_header_size = DEFAULT_ENCRYPTION_BLOCK_HEADER_SIZE;\n \t\t\tstorage_options.encryption = true;\n+\t\t\t// set storage version to v1.3.0\n+\t\t\tstorage_options.storage_version = SerializationCompatibility::FromString(\"v1.3.0\").serialization_version;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2137321184",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17275,
        "pr_file": "src/parser/parsed_data/attach_info.cpp",
        "discussion_id": "2137321184",
        "commented_code": "@@ -16,8 +16,23 @@ StorageOptions AttachInfo::GetStorageOptions() const {\n \t\t\t// even though the corresponding option we expose to the user is called \"block_size\".\n \t\t\tstorage_options.block_alloc_size = entry.second.GetValue<uint64_t>();\n \t\t} else if (entry.first == \"encryption_key\") {\n+\t\t\tauto user_key = entry.second.GetValue<string>();\n+\t\t\t// do we need to check here whether the string is valid?\n+\t\t\tif (user_key.empty() || user_key == \"true\") {\n+\t\t\t\tthrow BinderException(\"\\\"%s\\\" is not a valid key. A key must not be empty\", entry.second.ToString());\n+\t\t\t}\n+\t\t\tstorage_options.encryption_key = user_key;\n+\n+\t\t\t// clear the user key\n+\t\t\tfill(user_key.begin(), user_key.end(), '\\0');\n+\t\t\tuser_key.clear();\n+\n \t\t\tstorage_options.block_header_size = DEFAULT_ENCRYPTION_BLOCK_HEADER_SIZE;\n \t\t\tstorage_options.encryption = true;\n+\t\t\t// set storage version to v1.3.0\n+\t\t\tstorage_options.storage_version = SerializationCompatibility::FromString(\"v1.3.0\").serialization_version;",
        "comment_created_at": "2025-06-10T08:59:43+00:00",
        "comment_author": "Mytherin",
        "comment_body": "We should only set this if it is not specified by the user itself - otherwise the encryption key option overrides the user-provided setting. \r\n\r\ni.e. this should throw an error:\r\n\r\n```sql\r\nATTACH '...' (STORAGE_VERSION 'v1.1', ENCRYPTION_KEY '...');\r\n```\r\n\r\nAnd this should use storage version v1.4, not v1.3:\r\n\r\n```sql\r\nATTACH '...' (STORAGE_VERSION 'v1.14, ENCRYPTION_KEY '...');\r\n```",
        "pr_file_module": null
      }
    ]
  }
]