[
  {
    "discussion_id": "2191723974",
    "pr_number": 17992,
    "pr_file": "src/include/duckdb/common/types/string.hpp",
    "created_at": "2025-07-08T07:37:06+00:00",
    "commented_code": "+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/string.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+\n+namespace duckdb {\n+class String {\n+public:\n+\t// Owning constructors\n+\tString(std::string str) // NOLINT: allow implicit conversion\n+\t    : owned_data(std::move(str)), data(owned_data.c_str()), size(owned_data.size()) {\n+\t}\n+\n+\tString(const char *ptr, const size_t len) : owned_data(ptr, len), data(ptr), size(len) {\n+\t}\n+\n+\tString(const char *ptr) // NOLINT: allow implicit conversion\n+\t    : String(ptr, strlen(ptr)) {\n+\t}\n+\n+\t// Non-owning constructors\n+\tstatic String CreateView(const char *ptr, const size_t len) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2191723974",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17992,
        "pr_file": "src/include/duckdb/common/types/string.hpp",
        "discussion_id": "2191723974",
        "commented_code": "@@ -0,0 +1,190 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/string.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+\n+namespace duckdb {\n+class String {\n+public:\n+\t// Owning constructors\n+\tString(std::string str) // NOLINT: allow implicit conversion\n+\t    : owned_data(std::move(str)), data(owned_data.c_str()), size(owned_data.size()) {\n+\t}\n+\n+\tString(const char *ptr, const size_t len) : owned_data(ptr, len), data(ptr), size(len) {\n+\t}\n+\n+\tString(const char *ptr) // NOLINT: allow implicit conversion\n+\t    : String(ptr, strlen(ptr)) {\n+\t}\n+\n+\t// Non-owning constructors\n+\tstatic String CreateView(const char *ptr, const size_t len) {",
        "comment_created_at": "2025-07-08T07:37:06+00:00",
        "comment_author": "Maxxen",
        "comment_body": "Maybe a bit of a nit, but if we do add a StringView in the future this is a bit confusing, maybe we can call it something like `Reference()` or `NonOwning()`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2282769497",
    "pr_number": 17992,
    "pr_file": "src/include/duckdb/common/types/string.hpp",
    "created_at": "2025-08-18T15:37:41+00:00",
    "commented_code": "+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/string.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include <string>\n+#include <cstring>\n+\n+#include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+#include \"duckdb/common/assert.hpp\"\n+\n+namespace duckdb {\n+\n+class String {\n+\t/*\n+\t    String either can own its data (with automatic cleanup) or hold a non-owning reference.\n+\t    * Move only semantics, no copying allowed.\n+\t    * Small Strings (\u22647 bytes) are stored inline to avoid heap allocation.\n+\t    * 32-bit length limit with overflow protection.\n+\n+\t    To create an owning String, use the constructors.\n+\t    To create a non-owning String, use the Reference methods.\n+\t */\n+\n+public:\n+\t// Constructors (create an owning String)\n+\tString() : len(0), buf {0} {\n+\t}\n+\n+\tString(const std::string &str) { // NOLINT allowimplicit conversion\n+\t\tAssignOwning(str.data(), SafeStrlen(str));\n+\t}\n+\n+\tString(const char *str, const uint32_t size) {\n+\t\tif (str == nullptr) {\n+\t\t\tAssignOwning(str, 0);\n+\t\t\treturn;\n+\t\t}\n+\t\tAssignOwning(str, size);\n+\t}\n+\n+\tString(const char *str) // NOLINT allowimplicit conversion\n+\t    : String(str, str ? SafeStrlen(str) : 0) {\n+\t}\n+\n+public:\n+\t// Copying is not allowed, use move semantics instead or explicitly create a new String instance.\n+\tString(const String &other) = delete;\n+\tString &operator=(const String &other) = delete;\n+\n+\t// Move Constructor\n+\tString(String &&other) noexcept {\n+\t\tAssignOwning(other.data(), other.size());\n+\t\tother.Release();\n+\t}\n+\n+\t// Move Assignment\n+\tString &operator=(String &&other) noexcept {\n+\t\tif (this != &other) {\n+\t\t\tDestroy();\n+\t\t\tAssignOwning(other.data(), other.size());\n+\t\t\tother.Release();\n+\t\t}\n+\t\treturn *this;\n+\t}\n+\n+\t// Destructor\n+\t~String() {\n+\t\tDestroy();\n+\t}\n+\n+public:\n+\t// Operators\n+\tbool operator==(const String &other) const {\n+\t\tif (this == &other) {\n+\t\t\treturn true; // points to the same instance\n+\t\t}\n+\n+\t\tif (size() != other.size()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn memcmp(data(), other.data(), size()) == 0;\n+\t}\n+\n+\tbool operator==(const std::string &other) const {\n+\t\tif (SafeStrlen(other) != size()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn memcmp(data(), other.data(), size()) == 0;\n+\t}\n+\n+\tbool operator==(const char *other) const {\n+\t\tif (!other || SafeStrlen(other) != size()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (this->data() == other) {\n+\t\t\treturn true; // points to the same instance\n+\t\t}\n+\n+\t\treturn memcmp(data(), other, size()) == 0;\n+\t}\n+\n+\tbool operator>(const String &other) const {\n+\t\tconst auto this_size = size();\n+\t\tconst auto other_size = other.size();\n+\t\tconst auto min_size = MinValue<idx_t>(this_size, other_size);\n+\n+\t\tauto memcmp_res = memcmp(data(), other.data(), min_size);\n+\t\treturn memcmp_res > 0 || (memcmp_res == 0 && this_size > other_size);\n+\t}\n+\n+\tbool operator!=(const String &other) const {\n+\t\treturn !(*this == other);\n+\t}\n+\tbool operator<(const String &other) const {\n+\t\treturn other > *this;\n+\t}\n+\tbool operator>=(const String &other) const {\n+\t\treturn !(*this < other);\n+\t}\n+\tbool operator<=(const String &other) const {\n+\t\treturn !(*this > other);\n+\t}\n+\n+\tchar operator[](const idx_t pos) const {\n+\t\tD_ASSERT(pos < size());\n+\n+\t\tif (IsInline()) {\n+\t\t\treturn buf[pos];\n+\t\t}\n+\t\treturn ptr[pos];\n+\t}\n+\n+public:\n+\t// STL-like interface\n+\t// NOLINTBEGIN - mimic std::string interface\n+\tuint32_t size() const {\n+\t\treturn len & ~NON_OWN_BIT;\n+\t}\n+\tbool empty() const {\n+\t\treturn len == 0;\n+\t}\n+\tconst char *data() const {\n+\t\treturn IsInline() ? buf : ptr;\n+\t}\n+\tconst char *begin() const {\n+\t\treturn data();\n+\t}\n+\tconst char *end() const {\n+\t\treturn data() + size();\n+\t}\n+\tconst char *c_str() const {\n+\t\treturn data();\n+\t}\n+\t// NOLINTEND\n+\n+\t// Helper methods\n+\tbool IsOwning() const {\n+\t\treturn (len & NON_OWN_BIT) == 0;\n+\t}\n+\n+\tbool IsInline() const {\n+\t\treturn len <= INLINE_MAX;\n+\t}\n+\n+\tstatic bool CanBeInlined(uint32_t size) {\n+\t\treturn size <= INLINE_MAX;\n+\t}\n+\n+\t// Creates a new String instance with its own copy of the data\n+\tstatic String Copy(const char *data, uint32_t size) {\n+\t\tif (data == nullptr) {\n+\t\t\treturn String(); // Return an empty String\n+\t\t}\n+\n+\t\tString result;\n+\t\tresult.AssignOwning(data, size);\n+\t\treturn result;\n+\t}\n+\n+\tstatic String Copy(const String &other) {\n+\t\treturn Copy(other.data(), other.size());\n+\t}\n+\tstatic String Copy(const char *data) {\n+\t\treturn Copy(data, data ? SafeStrlen(data) : 0);\n+\t}\n+\tstatic String Copy(const std::string &str) {\n+\t\treturn Copy(str.data(), SafeStrlen(str));\n+\t}\n+\tString Copy() const {\n+\t\treturn String::Copy(data(), size());\n+\t}\n+\n+\t// Creates a new String instance that references the data without owning it\n+\t// If the size is small enough, it will inline the data; which WILL be owning\n+\tstatic String Reference(const char *data, uint32_t size) {\n+\t\tif (data == nullptr) {\n+\t\t\treturn String(); // Return an empty String\n+\t\t}\n+\n+\t\tString result;\n+\t\t// If we reference, and we can inline it, we make owning anyway\n+\t\tif (size <= INLINE_MAX) {\n+\t\t\tresult.AssignOwning(data, size);\n+\t\t} else {\n+\t\t\tresult.ptr = const_cast<char *>(data); // NOLINT allow const cast\n+\t\t\tresult.len = size | NON_OWN_BIT;       // Set the non-owning bit\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic String Reference(const String &other) {\n+\t\treturn Reference(other.data(), other.size());\n+\t}\n+\tstatic String Reference(const char *data) {\n+\t\treturn Reference(data, data ? SafeStrlen(data) : 0);\n+\t}\n+\tstatic String Reference(const std::string &str) {\n+\t\treturn Reference(str.data(), SafeStrlen(str));\n+\t}\n+\tString Reference() const {\n+\t\treturn String::Reference(data(), size());\n+\t}\n+\n+\tstd::string ToStdString() const {\n+\t\tif (IsInline()) {\n+\t\t\treturn std::string(buf, size());\n+\t\t}\n+\t\treturn std::string(ptr, size());\n+\t}\n+\n+\tstatic uint32_t SafeStrlen(const char *data) {\n+\t\tif (!data) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tconst auto len = strlen(data);\n+\t\tD_ASSERT(len < NumericLimits<uint32_t>::Maximum());\n+\t\treturn static_cast<uint32_t>(len);\n+\t}\n+\n+\tstatic uint32_t SafeStrlen(const std::string &data) {\n+\t\tconst auto len = data.size();\n+\t\tD_ASSERT(len < NumericLimits<uint32_t>::Maximum());\n+\t\treturn static_cast<uint32_t>(len);\n+\t}\n+\n+public:\n+\tstatic char CharacterToLower(char c) {\n+\t\tif (c >= 'A' && c <= 'Z') {\n+\t\t\treturn UnsafeNumericCast<char>(c + ('a' - 'A'));\n+\t\t}\n+\t\treturn c;\n+\t}\n+\n+\tString Lower() const {\n+\t\tconst auto str_data = data();\n+\t\tconst auto str_size = size();\n+\n+\t\tstd::string lowercase_str;\n+\t\tlowercase_str.reserve(str_size);\n+\t\tfor (idx_t i = 0; i < str_size; ++i) {\n+\t\t\tlowercase_str.push_back(CharacterToLower(str_data[i]));\n+\t\t}\n+\t\treturn String(lowercase_str);\n+\t}\n+\n+private:\n+\tstatic constexpr auto INLINE_CAP = sizeof(char *);\n+\tstatic constexpr auto INLINE_MAX = INLINE_CAP - 1;\n+\tstatic constexpr auto NON_OWN_BIT = 1UL << (sizeof(uint32_t) * 8 - 1);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2282769497",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17992,
        "pr_file": "src/include/duckdb/common/types/string.hpp",
        "discussion_id": "2282769497",
        "commented_code": "@@ -0,0 +1,334 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/string.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include <string>\n+#include <cstring>\n+\n+#include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+#include \"duckdb/common/assert.hpp\"\n+\n+namespace duckdb {\n+\n+class String {\n+\t/*\n+\t    String either can own its data (with automatic cleanup) or hold a non-owning reference.\n+\t    * Move only semantics, no copying allowed.\n+\t    * Small Strings (\u22647 bytes) are stored inline to avoid heap allocation.\n+\t    * 32-bit length limit with overflow protection.\n+\n+\t    To create an owning String, use the constructors.\n+\t    To create a non-owning String, use the Reference methods.\n+\t */\n+\n+public:\n+\t// Constructors (create an owning String)\n+\tString() : len(0), buf {0} {\n+\t}\n+\n+\tString(const std::string &str) { // NOLINT allowimplicit conversion\n+\t\tAssignOwning(str.data(), SafeStrlen(str));\n+\t}\n+\n+\tString(const char *str, const uint32_t size) {\n+\t\tif (str == nullptr) {\n+\t\t\tAssignOwning(str, 0);\n+\t\t\treturn;\n+\t\t}\n+\t\tAssignOwning(str, size);\n+\t}\n+\n+\tString(const char *str) // NOLINT allowimplicit conversion\n+\t    : String(str, str ? SafeStrlen(str) : 0) {\n+\t}\n+\n+public:\n+\t// Copying is not allowed, use move semantics instead or explicitly create a new String instance.\n+\tString(const String &other) = delete;\n+\tString &operator=(const String &other) = delete;\n+\n+\t// Move Constructor\n+\tString(String &&other) noexcept {\n+\t\tAssignOwning(other.data(), other.size());\n+\t\tother.Release();\n+\t}\n+\n+\t// Move Assignment\n+\tString &operator=(String &&other) noexcept {\n+\t\tif (this != &other) {\n+\t\t\tDestroy();\n+\t\t\tAssignOwning(other.data(), other.size());\n+\t\t\tother.Release();\n+\t\t}\n+\t\treturn *this;\n+\t}\n+\n+\t// Destructor\n+\t~String() {\n+\t\tDestroy();\n+\t}\n+\n+public:\n+\t// Operators\n+\tbool operator==(const String &other) const {\n+\t\tif (this == &other) {\n+\t\t\treturn true; // points to the same instance\n+\t\t}\n+\n+\t\tif (size() != other.size()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn memcmp(data(), other.data(), size()) == 0;\n+\t}\n+\n+\tbool operator==(const std::string &other) const {\n+\t\tif (SafeStrlen(other) != size()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn memcmp(data(), other.data(), size()) == 0;\n+\t}\n+\n+\tbool operator==(const char *other) const {\n+\t\tif (!other || SafeStrlen(other) != size()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (this->data() == other) {\n+\t\t\treturn true; // points to the same instance\n+\t\t}\n+\n+\t\treturn memcmp(data(), other, size()) == 0;\n+\t}\n+\n+\tbool operator>(const String &other) const {\n+\t\tconst auto this_size = size();\n+\t\tconst auto other_size = other.size();\n+\t\tconst auto min_size = MinValue<idx_t>(this_size, other_size);\n+\n+\t\tauto memcmp_res = memcmp(data(), other.data(), min_size);\n+\t\treturn memcmp_res > 0 || (memcmp_res == 0 && this_size > other_size);\n+\t}\n+\n+\tbool operator!=(const String &other) const {\n+\t\treturn !(*this == other);\n+\t}\n+\tbool operator<(const String &other) const {\n+\t\treturn other > *this;\n+\t}\n+\tbool operator>=(const String &other) const {\n+\t\treturn !(*this < other);\n+\t}\n+\tbool operator<=(const String &other) const {\n+\t\treturn !(*this > other);\n+\t}\n+\n+\tchar operator[](const idx_t pos) const {\n+\t\tD_ASSERT(pos < size());\n+\n+\t\tif (IsInline()) {\n+\t\t\treturn buf[pos];\n+\t\t}\n+\t\treturn ptr[pos];\n+\t}\n+\n+public:\n+\t// STL-like interface\n+\t// NOLINTBEGIN - mimic std::string interface\n+\tuint32_t size() const {\n+\t\treturn len & ~NON_OWN_BIT;\n+\t}\n+\tbool empty() const {\n+\t\treturn len == 0;\n+\t}\n+\tconst char *data() const {\n+\t\treturn IsInline() ? buf : ptr;\n+\t}\n+\tconst char *begin() const {\n+\t\treturn data();\n+\t}\n+\tconst char *end() const {\n+\t\treturn data() + size();\n+\t}\n+\tconst char *c_str() const {\n+\t\treturn data();\n+\t}\n+\t// NOLINTEND\n+\n+\t// Helper methods\n+\tbool IsOwning() const {\n+\t\treturn (len & NON_OWN_BIT) == 0;\n+\t}\n+\n+\tbool IsInline() const {\n+\t\treturn len <= INLINE_MAX;\n+\t}\n+\n+\tstatic bool CanBeInlined(uint32_t size) {\n+\t\treturn size <= INLINE_MAX;\n+\t}\n+\n+\t// Creates a new String instance with its own copy of the data\n+\tstatic String Copy(const char *data, uint32_t size) {\n+\t\tif (data == nullptr) {\n+\t\t\treturn String(); // Return an empty String\n+\t\t}\n+\n+\t\tString result;\n+\t\tresult.AssignOwning(data, size);\n+\t\treturn result;\n+\t}\n+\n+\tstatic String Copy(const String &other) {\n+\t\treturn Copy(other.data(), other.size());\n+\t}\n+\tstatic String Copy(const char *data) {\n+\t\treturn Copy(data, data ? SafeStrlen(data) : 0);\n+\t}\n+\tstatic String Copy(const std::string &str) {\n+\t\treturn Copy(str.data(), SafeStrlen(str));\n+\t}\n+\tString Copy() const {\n+\t\treturn String::Copy(data(), size());\n+\t}\n+\n+\t// Creates a new String instance that references the data without owning it\n+\t// If the size is small enough, it will inline the data; which WILL be owning\n+\tstatic String Reference(const char *data, uint32_t size) {\n+\t\tif (data == nullptr) {\n+\t\t\treturn String(); // Return an empty String\n+\t\t}\n+\n+\t\tString result;\n+\t\t// If we reference, and we can inline it, we make owning anyway\n+\t\tif (size <= INLINE_MAX) {\n+\t\t\tresult.AssignOwning(data, size);\n+\t\t} else {\n+\t\t\tresult.ptr = const_cast<char *>(data); // NOLINT allow const cast\n+\t\t\tresult.len = size | NON_OWN_BIT;       // Set the non-owning bit\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic String Reference(const String &other) {\n+\t\treturn Reference(other.data(), other.size());\n+\t}\n+\tstatic String Reference(const char *data) {\n+\t\treturn Reference(data, data ? SafeStrlen(data) : 0);\n+\t}\n+\tstatic String Reference(const std::string &str) {\n+\t\treturn Reference(str.data(), SafeStrlen(str));\n+\t}\n+\tString Reference() const {\n+\t\treturn String::Reference(data(), size());\n+\t}\n+\n+\tstd::string ToStdString() const {\n+\t\tif (IsInline()) {\n+\t\t\treturn std::string(buf, size());\n+\t\t}\n+\t\treturn std::string(ptr, size());\n+\t}\n+\n+\tstatic uint32_t SafeStrlen(const char *data) {\n+\t\tif (!data) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tconst auto len = strlen(data);\n+\t\tD_ASSERT(len < NumericLimits<uint32_t>::Maximum());\n+\t\treturn static_cast<uint32_t>(len);\n+\t}\n+\n+\tstatic uint32_t SafeStrlen(const std::string &data) {\n+\t\tconst auto len = data.size();\n+\t\tD_ASSERT(len < NumericLimits<uint32_t>::Maximum());\n+\t\treturn static_cast<uint32_t>(len);\n+\t}\n+\n+public:\n+\tstatic char CharacterToLower(char c) {\n+\t\tif (c >= 'A' && c <= 'Z') {\n+\t\t\treturn UnsafeNumericCast<char>(c + ('a' - 'A'));\n+\t\t}\n+\t\treturn c;\n+\t}\n+\n+\tString Lower() const {\n+\t\tconst auto str_data = data();\n+\t\tconst auto str_size = size();\n+\n+\t\tstd::string lowercase_str;\n+\t\tlowercase_str.reserve(str_size);\n+\t\tfor (idx_t i = 0; i < str_size; ++i) {\n+\t\t\tlowercase_str.push_back(CharacterToLower(str_data[i]));\n+\t\t}\n+\t\treturn String(lowercase_str);\n+\t}\n+\n+private:\n+\tstatic constexpr auto INLINE_CAP = sizeof(char *);\n+\tstatic constexpr auto INLINE_MAX = INLINE_CAP - 1;\n+\tstatic constexpr auto NON_OWN_BIT = 1UL << (sizeof(uint32_t) * 8 - 1);",
        "comment_created_at": "2025-08-18T15:37:41+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "`NONE_`?",
        "pr_file_module": null
      },
      {
        "comment_id": "2284536834",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17992,
        "pr_file": "src/include/duckdb/common/types/string.hpp",
        "discussion_id": "2282769497",
        "commented_code": "@@ -0,0 +1,334 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/types/string.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include <string>\n+#include <cstring>\n+\n+#include \"duckdb/common/numeric_utils.hpp\"\n+#include \"duckdb/common/typedefs.hpp\"\n+#include \"duckdb/common/assert.hpp\"\n+\n+namespace duckdb {\n+\n+class String {\n+\t/*\n+\t    String either can own its data (with automatic cleanup) or hold a non-owning reference.\n+\t    * Move only semantics, no copying allowed.\n+\t    * Small Strings (\u22647 bytes) are stored inline to avoid heap allocation.\n+\t    * 32-bit length limit with overflow protection.\n+\n+\t    To create an owning String, use the constructors.\n+\t    To create a non-owning String, use the Reference methods.\n+\t */\n+\n+public:\n+\t// Constructors (create an owning String)\n+\tString() : len(0), buf {0} {\n+\t}\n+\n+\tString(const std::string &str) { // NOLINT allowimplicit conversion\n+\t\tAssignOwning(str.data(), SafeStrlen(str));\n+\t}\n+\n+\tString(const char *str, const uint32_t size) {\n+\t\tif (str == nullptr) {\n+\t\t\tAssignOwning(str, 0);\n+\t\t\treturn;\n+\t\t}\n+\t\tAssignOwning(str, size);\n+\t}\n+\n+\tString(const char *str) // NOLINT allowimplicit conversion\n+\t    : String(str, str ? SafeStrlen(str) : 0) {\n+\t}\n+\n+public:\n+\t// Copying is not allowed, use move semantics instead or explicitly create a new String instance.\n+\tString(const String &other) = delete;\n+\tString &operator=(const String &other) = delete;\n+\n+\t// Move Constructor\n+\tString(String &&other) noexcept {\n+\t\tAssignOwning(other.data(), other.size());\n+\t\tother.Release();\n+\t}\n+\n+\t// Move Assignment\n+\tString &operator=(String &&other) noexcept {\n+\t\tif (this != &other) {\n+\t\t\tDestroy();\n+\t\t\tAssignOwning(other.data(), other.size());\n+\t\t\tother.Release();\n+\t\t}\n+\t\treturn *this;\n+\t}\n+\n+\t// Destructor\n+\t~String() {\n+\t\tDestroy();\n+\t}\n+\n+public:\n+\t// Operators\n+\tbool operator==(const String &other) const {\n+\t\tif (this == &other) {\n+\t\t\treturn true; // points to the same instance\n+\t\t}\n+\n+\t\tif (size() != other.size()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\treturn memcmp(data(), other.data(), size()) == 0;\n+\t}\n+\n+\tbool operator==(const std::string &other) const {\n+\t\tif (SafeStrlen(other) != size()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn memcmp(data(), other.data(), size()) == 0;\n+\t}\n+\n+\tbool operator==(const char *other) const {\n+\t\tif (!other || SafeStrlen(other) != size()) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (this->data() == other) {\n+\t\t\treturn true; // points to the same instance\n+\t\t}\n+\n+\t\treturn memcmp(data(), other, size()) == 0;\n+\t}\n+\n+\tbool operator>(const String &other) const {\n+\t\tconst auto this_size = size();\n+\t\tconst auto other_size = other.size();\n+\t\tconst auto min_size = MinValue<idx_t>(this_size, other_size);\n+\n+\t\tauto memcmp_res = memcmp(data(), other.data(), min_size);\n+\t\treturn memcmp_res > 0 || (memcmp_res == 0 && this_size > other_size);\n+\t}\n+\n+\tbool operator!=(const String &other) const {\n+\t\treturn !(*this == other);\n+\t}\n+\tbool operator<(const String &other) const {\n+\t\treturn other > *this;\n+\t}\n+\tbool operator>=(const String &other) const {\n+\t\treturn !(*this < other);\n+\t}\n+\tbool operator<=(const String &other) const {\n+\t\treturn !(*this > other);\n+\t}\n+\n+\tchar operator[](const idx_t pos) const {\n+\t\tD_ASSERT(pos < size());\n+\n+\t\tif (IsInline()) {\n+\t\t\treturn buf[pos];\n+\t\t}\n+\t\treturn ptr[pos];\n+\t}\n+\n+public:\n+\t// STL-like interface\n+\t// NOLINTBEGIN - mimic std::string interface\n+\tuint32_t size() const {\n+\t\treturn len & ~NON_OWN_BIT;\n+\t}\n+\tbool empty() const {\n+\t\treturn len == 0;\n+\t}\n+\tconst char *data() const {\n+\t\treturn IsInline() ? buf : ptr;\n+\t}\n+\tconst char *begin() const {\n+\t\treturn data();\n+\t}\n+\tconst char *end() const {\n+\t\treturn data() + size();\n+\t}\n+\tconst char *c_str() const {\n+\t\treturn data();\n+\t}\n+\t// NOLINTEND\n+\n+\t// Helper methods\n+\tbool IsOwning() const {\n+\t\treturn (len & NON_OWN_BIT) == 0;\n+\t}\n+\n+\tbool IsInline() const {\n+\t\treturn len <= INLINE_MAX;\n+\t}\n+\n+\tstatic bool CanBeInlined(uint32_t size) {\n+\t\treturn size <= INLINE_MAX;\n+\t}\n+\n+\t// Creates a new String instance with its own copy of the data\n+\tstatic String Copy(const char *data, uint32_t size) {\n+\t\tif (data == nullptr) {\n+\t\t\treturn String(); // Return an empty String\n+\t\t}\n+\n+\t\tString result;\n+\t\tresult.AssignOwning(data, size);\n+\t\treturn result;\n+\t}\n+\n+\tstatic String Copy(const String &other) {\n+\t\treturn Copy(other.data(), other.size());\n+\t}\n+\tstatic String Copy(const char *data) {\n+\t\treturn Copy(data, data ? SafeStrlen(data) : 0);\n+\t}\n+\tstatic String Copy(const std::string &str) {\n+\t\treturn Copy(str.data(), SafeStrlen(str));\n+\t}\n+\tString Copy() const {\n+\t\treturn String::Copy(data(), size());\n+\t}\n+\n+\t// Creates a new String instance that references the data without owning it\n+\t// If the size is small enough, it will inline the data; which WILL be owning\n+\tstatic String Reference(const char *data, uint32_t size) {\n+\t\tif (data == nullptr) {\n+\t\t\treturn String(); // Return an empty String\n+\t\t}\n+\n+\t\tString result;\n+\t\t// If we reference, and we can inline it, we make owning anyway\n+\t\tif (size <= INLINE_MAX) {\n+\t\t\tresult.AssignOwning(data, size);\n+\t\t} else {\n+\t\t\tresult.ptr = const_cast<char *>(data); // NOLINT allow const cast\n+\t\t\tresult.len = size | NON_OWN_BIT;       // Set the non-owning bit\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tstatic String Reference(const String &other) {\n+\t\treturn Reference(other.data(), other.size());\n+\t}\n+\tstatic String Reference(const char *data) {\n+\t\treturn Reference(data, data ? SafeStrlen(data) : 0);\n+\t}\n+\tstatic String Reference(const std::string &str) {\n+\t\treturn Reference(str.data(), SafeStrlen(str));\n+\t}\n+\tString Reference() const {\n+\t\treturn String::Reference(data(), size());\n+\t}\n+\n+\tstd::string ToStdString() const {\n+\t\tif (IsInline()) {\n+\t\t\treturn std::string(buf, size());\n+\t\t}\n+\t\treturn std::string(ptr, size());\n+\t}\n+\n+\tstatic uint32_t SafeStrlen(const char *data) {\n+\t\tif (!data) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tconst auto len = strlen(data);\n+\t\tD_ASSERT(len < NumericLimits<uint32_t>::Maximum());\n+\t\treturn static_cast<uint32_t>(len);\n+\t}\n+\n+\tstatic uint32_t SafeStrlen(const std::string &data) {\n+\t\tconst auto len = data.size();\n+\t\tD_ASSERT(len < NumericLimits<uint32_t>::Maximum());\n+\t\treturn static_cast<uint32_t>(len);\n+\t}\n+\n+public:\n+\tstatic char CharacterToLower(char c) {\n+\t\tif (c >= 'A' && c <= 'Z') {\n+\t\t\treturn UnsafeNumericCast<char>(c + ('a' - 'A'));\n+\t\t}\n+\t\treturn c;\n+\t}\n+\n+\tString Lower() const {\n+\t\tconst auto str_data = data();\n+\t\tconst auto str_size = size();\n+\n+\t\tstd::string lowercase_str;\n+\t\tlowercase_str.reserve(str_size);\n+\t\tfor (idx_t i = 0; i < str_size; ++i) {\n+\t\t\tlowercase_str.push_back(CharacterToLower(str_data[i]));\n+\t\t}\n+\t\treturn String(lowercase_str);\n+\t}\n+\n+private:\n+\tstatic constexpr auto INLINE_CAP = sizeof(char *);\n+\tstatic constexpr auto INLINE_MAX = INLINE_CAP - 1;\n+\tstatic constexpr auto NON_OWN_BIT = 1UL << (sizeof(uint32_t) * 8 - 1);",
        "comment_created_at": "2025-08-19T08:32:06+00:00",
        "comment_author": "maiadegraaf",
        "comment_body": "Its a non owning bit, could be `NON_OWNING_BIT` instead? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2276396019",
    "pr_number": 18518,
    "pr_file": "src/include/duckdb/common/hive_partitioning.hpp",
    "created_at": "2025-08-14T11:45:42+00:00",
    "commented_code": "class HivePartitioning {\n public:\n+\t// Constructor\n+\tHivePartitioning(ClientContext &context, vector<unique_ptr<Expression>> &filters, const MultiFileOptions &options,",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2276396019",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18518,
        "pr_file": "src/include/duckdb/common/hive_partitioning.hpp",
        "discussion_id": "2276396019",
        "commented_code": "@@ -30,22 +30,50 @@ struct HivePartitioningFilterInfo {\n \n class HivePartitioning {\n public:\n+\t// Constructor\n+\tHivePartitioning(ClientContext &context, vector<unique_ptr<Expression>> &filters, const MultiFileOptions &options,",
        "comment_created_at": "2025-08-14T11:45:42+00:00",
        "comment_author": "samansmink",
        "comment_body": "I find the concept of a non-static class called `HivePartitioning` a little unclear to reason about. What does a `HivePartitioning`-object do? Could we perhaps instead create a new`HivePartitioningExecutor` class that has the sole task of handling the hive filter execution? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2269771034",
    "pr_number": 18575,
    "pr_file": "src/include/duckdb/common/progress_bar/unscented_kalman_filter.hpp",
    "created_at": "2025-08-12T13:00:28+00:00",
    "commented_code": "+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/progress_bar/unscented_kalman_filter.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb.hpp\"\n+#include <chrono>\n+\n+namespace duckdb {\n+\n+class UnscentedKalmanFilter {\n+private:\n+\tstatic constexpr size_t STATE_DIM = 2; // [progress, velocity]\n+\tstatic constexpr size_t OBS_DIM = 1;   // [progress]\n+\tstatic constexpr size_t SIGMA_POINTS = 2 * STATE_DIM + 1;\n+\n+\t// UKF parameters\n+\tstatic constexpr double ALPHA = 0.1;\n+\tstatic constexpr double BETA = 1.0;\n+\tstatic constexpr double KAPPA = 0.0;\n+\n+\tdouble lambda;\n+\tstd::vector<double> wm, wc; // weights for mean and covariance\n+\n+\t// State: [progress (0-1), velocity (progress/second)]\n+\tstd::vector<double> x;              // state estimate\n+\tstd::vector<std::vector<double>> P; // covariance matrix\n+\tstd::vector<std::vector<double>> Q; // process noise\n+\tstd::vector<std::vector<double>> R; // measurement noise\n+\n+\tdouble last_time;\n+\tbool initialized;\n+\n+\t// Helper functions\n+\tstd::vector<std::vector<double>> matrixSqrt(const std::vector<std::vector<double>> &mat);\n+\tstd::vector<std::vector<double>> generateSigmaPoints();\n+\tstd::vector<double> stateTransition(const std::vector<double> &state, double dt);\n+\tstd::vector<double> measurementFunction(const std::vector<double> &state);\n+\n+public:\n+\tUnscentedKalmanFilter();\n+\n+\tvoid initialize(double initial_progress, double current_time);\n+\tvoid predict(double current_time);\n+\tvoid update(double measured_progress);\n+\n+\tdouble getProgress() const;\n+\tdouble getVelocity() const;\n+\tdouble getEstimatedRemainingSeconds() const;\n+\tdouble getProgressVariance() const;\n+\tdouble getVelocityVariance() const;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2269771034",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18575,
        "pr_file": "src/include/duckdb/common/progress_bar/unscented_kalman_filter.hpp",
        "discussion_id": "2269771034",
        "commented_code": "@@ -0,0 +1,59 @@\n+//===----------------------------------------------------------------------===//\n+//                         DuckDB\n+//\n+// duckdb/common/progress_bar/unscented_kalman_filter.hpp\n+//\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#pragma once\n+\n+#include \"duckdb.hpp\"\n+#include <chrono>\n+\n+namespace duckdb {\n+\n+class UnscentedKalmanFilter {\n+private:\n+\tstatic constexpr size_t STATE_DIM = 2; // [progress, velocity]\n+\tstatic constexpr size_t OBS_DIM = 1;   // [progress]\n+\tstatic constexpr size_t SIGMA_POINTS = 2 * STATE_DIM + 1;\n+\n+\t// UKF parameters\n+\tstatic constexpr double ALPHA = 0.1;\n+\tstatic constexpr double BETA = 1.0;\n+\tstatic constexpr double KAPPA = 0.0;\n+\n+\tdouble lambda;\n+\tstd::vector<double> wm, wc; // weights for mean and covariance\n+\n+\t// State: [progress (0-1), velocity (progress/second)]\n+\tstd::vector<double> x;              // state estimate\n+\tstd::vector<std::vector<double>> P; // covariance matrix\n+\tstd::vector<std::vector<double>> Q; // process noise\n+\tstd::vector<std::vector<double>> R; // measurement noise\n+\n+\tdouble last_time;\n+\tbool initialized;\n+\n+\t// Helper functions\n+\tstd::vector<std::vector<double>> matrixSqrt(const std::vector<std::vector<double>> &mat);\n+\tstd::vector<std::vector<double>> generateSigmaPoints();\n+\tstd::vector<double> stateTransition(const std::vector<double> &state, double dt);\n+\tstd::vector<double> measurementFunction(const std::vector<double> &state);\n+\n+public:\n+\tUnscentedKalmanFilter();\n+\n+\tvoid initialize(double initial_progress, double current_time);\n+\tvoid predict(double current_time);\n+\tvoid update(double measured_progress);\n+\n+\tdouble getProgress() const;\n+\tdouble getVelocity() const;\n+\tdouble getEstimatedRemainingSeconds() const;\n+\tdouble getProgressVariance() const;\n+\tdouble getVelocityVariance() const;",
        "comment_created_at": "2025-08-12T13:00:28+00:00",
        "comment_author": "pdet",
        "comment_body": "Function - Naming not following DuckDB convention.\r\ne.g., GetProgress()",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2039633686",
    "pr_number": 17065,
    "pr_file": "src/include/duckdb/main/capi/extension_api.hpp",
    "created_at": "2025-04-11T14:07:49+00:00",
    "commented_code": "duckdb_selection_vector (*duckdb_create_selection_vector)(idx_t size);\n \tvoid (*duckdb_destroy_selection_vector)(duckdb_selection_vector vector);\n \tsel_t *(*duckdb_selection_vector_get_data_ptr)(duckdb_selection_vector vector);\n+\tconst char *(*duckdb_stringify_data_chunk)(duckdb_data_chunk chunk);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2039633686",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17065,
        "pr_file": "src/include/duckdb/main/capi/extension_api.hpp",
        "discussion_id": "2039633686",
        "commented_code": "@@ -480,6 +480,8 @@ typedef struct {\n \tduckdb_selection_vector (*duckdb_create_selection_vector)(idx_t size);\n \tvoid (*duckdb_destroy_selection_vector)(duckdb_selection_vector vector);\n \tsel_t *(*duckdb_selection_vector_get_data_ptr)(duckdb_selection_vector vector);\n+\tconst char *(*duckdb_stringify_data_chunk)(duckdb_data_chunk chunk);",
        "comment_created_at": "2025-04-11T14:07:49+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Can we call this `duckdb_data_chunk_to_string`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2201547582",
    "pr_number": 18224,
    "pr_file": "extension/parquet/include/reader/variant/variant_value.hpp",
    "created_at": "2025-07-11T18:54:09+00:00",
    "commented_code": "+#pragma once\n+\n+#include \"duckdb/common/map.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n+\n+#include \"yyjson.hpp\"\n+\n+using namespace duckdb_yyjson;\n+\n+namespace duckdb {\n+\n+enum class VariantValueType : uint8_t { PRIMITIVE, OBJECT, ARRAY, INVALID };",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2201547582",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18224,
        "pr_file": "extension/parquet/include/reader/variant/variant_value.hpp",
        "discussion_id": "2201547582",
        "commented_code": "@@ -0,0 +1,56 @@\n+#pragma once\n+\n+#include \"duckdb/common/map.hpp\"\n+#include \"duckdb/common/vector.hpp\"\n+#include \"duckdb/common/types/value.hpp\"\n+\n+#include \"yyjson.hpp\"\n+\n+using namespace duckdb_yyjson;\n+\n+namespace duckdb {\n+\n+enum class VariantValueType : uint8_t { PRIMITIVE, OBJECT, ARRAY, INVALID };",
        "comment_created_at": "2025-07-11T18:54:09+00:00",
        "comment_author": "Tishj",
        "comment_body": "`INVALID` is a bit of a bad name for this, maybe this should be called `MISSING`, which better matches the spec:\r\n> A field's `value` and `typed_value` are set to null (missing) to indicate that the field does not exist in the variant.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2137336527",
    "pr_number": 17275,
    "pr_file": "src/include/duckdb/storage/single_file_block_manager.hpp",
    "created_at": "2025-06-10T09:07:50+00:00",
    "commented_code": "#include \"duckdb/common/set.hpp\"\n #include \"duckdb/common/vector.hpp\"\n #include \"duckdb/main/config.hpp\"\n+#include \"duckdb/common/encryption_functions.hpp\"\n \n namespace duckdb {\n \n class DatabaseInstance;\n struct MetadataHandle;\n \n+struct EncryptionOptions {\n+\n+\t//! indicates whether the db is encrypted\n+\tbool encryption_enabled = false;\n+\t//! Whether Additional Authenticated Data is used\n+\tbool aad = false;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2137336527",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17275,
        "pr_file": "src/include/duckdb/storage/single_file_block_manager.hpp",
        "discussion_id": "2137336527",
        "commented_code": "@@ -16,12 +16,29 @@\n #include \"duckdb/common/set.hpp\"\n #include \"duckdb/common/vector.hpp\"\n #include \"duckdb/main/config.hpp\"\n+#include \"duckdb/common/encryption_functions.hpp\"\n \n namespace duckdb {\n \n class DatabaseInstance;\n struct MetadataHandle;\n \n+struct EncryptionOptions {\n+\n+\t//! indicates whether the db is encrypted\n+\tbool encryption_enabled = false;\n+\t//! Whether Additional Authenticated Data is used\n+\tbool aad = false;",
        "comment_created_at": "2025-06-10T09:07:50+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Can we call this `additional_authenticated_data` for clarity?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072024572",
    "pr_number": 17235,
    "pr_file": "src/include/duckdb/parser/expression/lambda_expression.hpp",
    "created_at": "2025-05-02T18:54:28+00:00",
    "commented_code": "namespace duckdb {\n \n-//! LambdaExpression represents either:\n-//! \t1. A lambda function that can be used for, e.g., mapping an expression to a list\n-//! \t2. An OperatorExpression with the \"->\" operator (JSON)\n-//! Lambda expressions are written in the form of \"params -> expr\", e.g., \"x -> x + 1\"\n+enum class LambdaSyntaxType : uint8_t { DEPRECATED_STORAGE = 0, DEPRECATED = 1, NEW = 2 };",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2072024572",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17235,
        "pr_file": "src/include/duckdb/parser/expression/lambda_expression.hpp",
        "discussion_id": "2072024572",
        "commented_code": "@@ -14,24 +14,30 @@\n \n namespace duckdb {\n \n-//! LambdaExpression represents either:\n-//! \t1. A lambda function that can be used for, e.g., mapping an expression to a list\n-//! \t2. An OperatorExpression with the \"->\" operator (JSON)\n-//! Lambda expressions are written in the form of \"params -> expr\", e.g., \"x -> x + 1\"\n+enum class LambdaSyntaxType : uint8_t { DEPRECATED_STORAGE = 0, DEPRECATED = 1, NEW = 2 };",
        "comment_created_at": "2025-05-02T18:54:28+00:00",
        "comment_author": "carlopi",
        "comment_body": "```suggestion\r\nenum class LambdaSyntaxType : uint8_t { DEPRECATED_STORAGE = 0, DEPRECATED = 1, EXPLICIT_LAMBDA = 2 };\r\n```\r\nIdea is that `new` will eventually stop being recent. And similar in the ToString and co.\r\n\r\nPossibly also DEPRECATED_[STORAGE] could use a more descriptive rename (eg ARROW_STYLE and ARROW_STYLE_WHILE_DEPRECATED)",
        "pr_file_module": null
      },
      {
        "comment_id": "2074873168",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 17235,
        "pr_file": "src/include/duckdb/parser/expression/lambda_expression.hpp",
        "discussion_id": "2072024572",
        "commented_code": "@@ -14,24 +14,30 @@\n \n namespace duckdb {\n \n-//! LambdaExpression represents either:\n-//! \t1. A lambda function that can be used for, e.g., mapping an expression to a list\n-//! \t2. An OperatorExpression with the \"->\" operator (JSON)\n-//! Lambda expressions are written in the form of \"params -> expr\", e.g., \"x -> x + 1\"\n+enum class LambdaSyntaxType : uint8_t { DEPRECATED_STORAGE = 0, DEPRECATED = 1, NEW = 2 };",
        "comment_created_at": "2025-05-06T07:23:15+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "Fair point, thanks! I'll adjust the PR. :)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2020070822",
    "pr_number": 16889,
    "pr_file": "src/include/duckdb/common/types/cast_helpers.hpp",
    "created_at": "2025-03-30T05:42:10+00:00",
    "commented_code": "return UnsafeNumericCast<int32_t>(trailing_zeros);\n \t}\n \n-\tstatic idx_t Length(int32_t time[], char micro_buffer[]) {\n+\tstatic idx_t Length(int32_t micros, char micro_buffer[]) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2020070822",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 16889,
        "pr_file": "src/include/duckdb/common/types/cast_helpers.hpp",
        "discussion_id": "2020070822",
        "commented_code": "@@ -261,11 +272,11 @@ struct TimeToStringCast {\n \t\treturn UnsafeNumericCast<int32_t>(trailing_zeros);\n \t}\n \n-\tstatic idx_t Length(int32_t time[], char micro_buffer[]) {\n+\tstatic idx_t Length(int32_t micros, char micro_buffer[]) {",
        "comment_created_at": "2025-03-30T05:42:10+00:00",
        "comment_author": "hawkfish",
        "comment_body": "Maybe `MicrosLength`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1344673037",
    "pr_number": 9014,
    "pr_file": "src/include/duckdb/execution/operator/projection/OrdinalityData.h",
    "created_at": "2023-10-03T20:09:29+00:00",
    "commented_code": "+#pragma once",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1344673037",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 9014,
        "pr_file": "src/include/duckdb/execution/operator/projection/OrdinalityData.h",
        "discussion_id": "1344673037",
        "commented_code": "@@ -0,0 +1,26 @@\n+#pragma once",
        "comment_created_at": "2023-10-03T20:09:29+00:00",
        "comment_author": "Tishj",
        "comment_body": "The name of this file should be `ordinality_data.hpp`, I'm also not sure this is where it should live",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1379039524",
    "pr_number": 9014,
    "pr_file": "src/include/duckdb/function/table_function.hpp",
    "created_at": "2023-11-01T16:37:41+00:00",
    "commented_code": "bool filter_prune;\n \t//! Additional function info, passed to the bind\n \tshared_ptr<TableFunctionInfo> function_info;\n+\t//! Data for WITH ORDINALITY feature\n+\tOrdinalityData ordinalityData;\n+\t//! bool to check whether or not WITH ORDINALITY feature has been implemented for this table function\n+\tbool ordinality_implemented;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1379039524",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 9014,
        "pr_file": "src/include/duckdb/function/table_function.hpp",
        "discussion_id": "1379039524",
        "commented_code": "@@ -277,6 +278,10 @@ class TableFunction : public SimpleNamedParameterFunction {\n \tbool filter_prune;\n \t//! Additional function info, passed to the bind\n \tshared_ptr<TableFunctionInfo> function_info;\n+\t//! Data for WITH ORDINALITY feature\n+\tOrdinalityData ordinalityData;\n+\t//! bool to check whether or not WITH ORDINALITY feature has been implemented for this table function\n+\tbool ordinality_implemented;",
        "comment_created_at": "2023-11-01T16:37:41+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "Rename `ordinalityData` to `ordinality_data` and `ordinality_implemented` to `supports_ordinality`.",
        "pr_file_module": null
      }
    ]
  }
]