[
  {
    "discussion_id": "2259872790",
    "pr_number": 18319,
    "pr_file": "src/function/table/table_scan.cpp",
    "created_at": "2025-08-07T10:34:56+00:00",
    "commented_code": "return expressions;\n }\n \n+// Recursively updates column bindings in an index expression to match the current input projection,\n+// even if they are the child of a function or cast\n+void UpdateIndexExprColumnBindings(unique_ptr<Expression> &expr, const vector<column_t> &input_column_ids,\n+\t\t\t\t\t\t  \t\t   const vector<column_t> &indexed_columns) {\n+\tif (!expr) { return; }\n+\n+\tswitch (expr->GetExpressionClass()) {\n+\t\tcase ExpressionClass::BOUND_COLUMN_REF: {\n+\t\t\tauto &bound_column_ref_expr = expr->Cast<BoundColumnRefExpression>();\n+\n+\t\t\tfor (idx_t i=0; i < input_column_ids.size(); ++i) {\n+\t\t\t\tif (input_column_ids[i] == indexed_columns[0]) {\n+\t\t\t\t\tbound_column_ref_expr.binding.column_index = i;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2259872790",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18319,
        "pr_file": "src/function/table/table_scan.cpp",
        "discussion_id": "2259872790",
        "commented_code": "@@ -484,6 +488,42 @@ vector<unique_ptr<Expression>> ExtractFilterExpressions(const ColumnDefinition &\n \treturn expressions;\n }\n \n+// Recursively updates column bindings in an index expression to match the current input projection,\n+// even if they are the child of a function or cast\n+void UpdateIndexExprColumnBindings(unique_ptr<Expression> &expr, const vector<column_t> &input_column_ids,\n+\t\t\t\t\t\t  \t\t   const vector<column_t> &indexed_columns) {\n+\tif (!expr) { return; }\n+\n+\tswitch (expr->GetExpressionClass()) {\n+\t\tcase ExpressionClass::BOUND_COLUMN_REF: {\n+\t\t\tauto &bound_column_ref_expr = expr->Cast<BoundColumnRefExpression>();\n+\n+\t\t\tfor (idx_t i=0; i < input_column_ids.size(); ++i) {\n+\t\t\t\tif (input_column_ids[i] == indexed_columns[0]) {\n+\t\t\t\t\tbound_column_ref_expr.binding.column_index = i;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}",
        "comment_created_at": "2025-08-07T10:34:56+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "I am not sure if the logic here is correct, mainly because we don't tie the `bound_column_ref_expr` to the indexed column. Like, we now always replace the `binding.column_index` with the index column, even if the original `bound_column_ref_expr` has nothing to do with the indexed column.\r\n\r\nI am wondering if it should look more like this:\r\n```cpp\r\n\t\tcase ExpressionClass::BOUND_COLUMN_REF: {\r\n\t\t\tauto &bound_column_ref_expr = expr->Cast<BoundColumnRefExpression>();\r\n\t\t\tif (bound_column_ref_expr.binding.column_index == indexed_columns[0]) {\r\n\t\t\t\tfor (idx_t i = 0; i < input_column_ids.size(); ++i) {\r\n\t\t\t\t\tif (input_column_ids[i] == indexed_columns[0]) {\r\n\t\t\t\t\t\tbound_column_ref_expr.binding.column_index = i;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n```\r\n\r\nAnd if that's the correct logic, then we might as well move the for-loop outside of the recursion and only pass in the `replace_index`. So the updated function signature would look like:\r\n\r\n```cpp\r\nvoid UpdateIndexExprColumnBindings(unique_ptr<Expression> &expr, const column_t updated_column, const column_t index_column)\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2283519291",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18319,
        "pr_file": "src/function/table/table_scan.cpp",
        "discussion_id": "2259872790",
        "commented_code": "@@ -484,6 +488,42 @@ vector<unique_ptr<Expression>> ExtractFilterExpressions(const ColumnDefinition &\n \treturn expressions;\n }\n \n+// Recursively updates column bindings in an index expression to match the current input projection,\n+// even if they are the child of a function or cast\n+void UpdateIndexExprColumnBindings(unique_ptr<Expression> &expr, const vector<column_t> &input_column_ids,\n+\t\t\t\t\t\t  \t\t   const vector<column_t> &indexed_columns) {\n+\tif (!expr) { return; }\n+\n+\tswitch (expr->GetExpressionClass()) {\n+\t\tcase ExpressionClass::BOUND_COLUMN_REF: {\n+\t\t\tauto &bound_column_ref_expr = expr->Cast<BoundColumnRefExpression>();\n+\n+\t\t\tfor (idx_t i=0; i < input_column_ids.size(); ++i) {\n+\t\t\t\tif (input_column_ids[i] == indexed_columns[0]) {\n+\t\t\t\t\tbound_column_ref_expr.binding.column_index = i;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}",
        "comment_created_at": "2025-08-18T21:21:06+00:00",
        "comment_author": "mach-kernel",
        "comment_body": "The code was very terse with `ExpressionIterator` so I opted to do everything in `TryScanIndex`. Added the extra check as shown.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1588045101",
    "pr_number": 11905,
    "pr_file": "test/appender/test_appender.cpp",
    "created_at": "2024-05-02T17:47:29+00:00",
    "commented_code": "REQUIRE(CHECK_COLUMN(result, 2, {Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)}));\n }\n \n+TEST_CASE(\"Test default value appender\", \"[appender]\") {\n+\tduckdb::unique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER, j INTEGER DEFAULT 5)\"));",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1588045101",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 11905,
        "pr_file": "test/appender/test_appender.cpp",
        "discussion_id": "1588045101",
        "commented_code": "@@ -169,6 +169,38 @@ TEST_CASE(\"Test AppendRow\", \"[appender]\") {\n \tREQUIRE(CHECK_COLUMN(result, 2, {Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)}));\n }\n \n+TEST_CASE(\"Test default value appender\", \"[appender]\") {\n+\tduckdb::unique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER, j INTEGER DEFAULT 5)\"));",
        "comment_created_at": "2024-05-02T17:47:29+00:00",
        "comment_author": "Mytherin",
        "comment_body": "* Can we add a test for `DEFAULT nextval('seq')`?\r\n* Can we add a test for `DEFAULT random()`?\r\n* Can we add a test for `DEFAULT now()`?\r\n* Can we add a default value that triggers an error, e.g.:\r\n\r\n```sql\r\ncreate table integers(i integer default 'hello'::int);\r\ninsert into integers default values;\r\n-- Conversion Error: Could not convert string 'hello' to INT32\r\n```\r\n\r\n* Can we add a test for the \"default default\", i.e. returning `NULL` when no value is specified",
        "pr_file_module": null
      },
      {
        "comment_id": "1588227266",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 11905,
        "pr_file": "test/appender/test_appender.cpp",
        "discussion_id": "1588045101",
        "commented_code": "@@ -169,6 +169,38 @@ TEST_CASE(\"Test AppendRow\", \"[appender]\") {\n \tREQUIRE(CHECK_COLUMN(result, 2, {Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)}));\n }\n \n+TEST_CASE(\"Test default value appender\", \"[appender]\") {\n+\tduckdb::unique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER, j INTEGER DEFAULT 5)\"));",
        "comment_created_at": "2024-05-02T19:15:43+00:00",
        "comment_author": "Tishj",
        "comment_body": "I disabled the \"default default\", only if the column has a default expression is the use of AppendDefault allowed\r\nIt throws an exception otherwise (added a test for that behavior as well)",
        "pr_file_module": null
      },
      {
        "comment_id": "1588280506",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 11905,
        "pr_file": "test/appender/test_appender.cpp",
        "discussion_id": "1588045101",
        "commented_code": "@@ -169,6 +169,38 @@ TEST_CASE(\"Test AppendRow\", \"[appender]\") {\n \tREQUIRE(CHECK_COLUMN(result, 2, {Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)}));\n }\n \n+TEST_CASE(\"Test default value appender\", \"[appender]\") {\n+\tduckdb::unique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER, j INTEGER DEFAULT 5)\"));",
        "comment_created_at": "2024-05-02T19:57:04+00:00",
        "comment_author": "Mytherin",
        "comment_body": "That\u2019s supported in SQL normally, I think it makes sense for this to be equivalent to the SQL DEFAULT expression so I would vote for allowing this",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1593668894",
    "pr_number": 11905,
    "pr_file": "test/appender/test_appender.cpp",
    "created_at": "2024-05-08T08:51:49+00:00",
    "commented_code": "REQUIRE(CHECK_COLUMN(result, 2, {Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)}));\n }\n \n+TEST_CASE(\"Test default value appender\", \"[appender]\") {\n+\tduckdb::unique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER, j INTEGER DEFAULT 5)\"));\n+\n+\t// Insert DEFAULT into default column\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(2);\n+\t\tappender.AppendDefault();\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(2)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::INTEGER(5)}));\n+\n+\tcon.Query(\"DELETE from integers\");\n+\n+\t// Insert DEFAULT into non-default column\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\t// 'i' does not have a DEFAULT value, so it gets NULL\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value(LogicalTypeId::INTEGER)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::INTEGER(5)}));\n+\n+\t// Insert DEFAULT into column that can't be NULL\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i integer NOT NULL)\"));\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\t// NOT NULL constraint failed\n+\t\tREQUIRE_THROWS(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tauto chunk = result->Fetch();\n+\tREQUIRE(chunk == nullptr);\n+\n+\t// DEFAULT nextval('seq')\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE SEQUENCE seq\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i iNTEGER, j INTEGER DEFAULT nextval('seq'))\"));\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(1);\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(1)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::INTEGER(1)}));\n+\n+\t// DEFAULT random()\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i iNTEGER, j DOUBLE DEFAULT random())\"));\n+\tcon.Query(\"select setseed(0.42)\");\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(1);\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(1)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::DOUBLE(0.4729174713138491)}));\n+\n+\t// DEFAULT now()\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i iNTEGER, j TIMESTAMPTZ DEFAULT now())\"));\n+\tcon.Query(\"BEGIN TRANSACTION\");\n+\tresult = con.Query(\"select now()\");\n+\tauto &materialized_result = result->Cast<MaterializedQueryResult>();\n+\tauto current_time = materialized_result.GetValue(0, 0);\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(1);\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(1)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {current_time}));\n+\tcon.Query(\"COMMIT\");\n+}\n+\n+TEST_CASE(\"Test append default into Vector\", \"[appender]\") {\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER)\"));\n+\n+\tauto result = con.Query(\"SELECT a::INTEGER FROM RANGE(15) t(a)\");\n+\tauto chunk = result->Fetch();\n+\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n+\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\n+\t\tauto &column = chunk->data[0];\n+\t\tSelectionVector sel(3);\n+\n+\t\tsel.set_index(0, 5);\n+\t\tsel.set_index(1, 8);\n+\t\tsel.set_index(2, 3);\n+\n+\t\tappender.AppendDefaultToVector(column, 0, sel, 3);\n+\t\tREQUIRE(column.GetValue(0) == 0);\n+\t\tREQUIRE(column.GetValue(1) == 1);\n+\n+\t\tREQUIRE(column.GetValue(5).IsNull());\n+\n+\t\tREQUIRE(column.GetValue(8).IsNull());\n+\n+\t\tREQUIRE(column.GetValue(3).IsNull());\n+\n+\t\tREQUIRE(!column.GetValue(14).IsNull());\n+\t\tREQUIRE(column.GetValue(14) == 14);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1593668894",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 11905,
        "pr_file": "test/appender/test_appender.cpp",
        "discussion_id": "1593668894",
        "commented_code": "@@ -169,6 +169,141 @@ TEST_CASE(\"Test AppendRow\", \"[appender]\") {\n \tREQUIRE(CHECK_COLUMN(result, 2, {Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)}));\n }\n \n+TEST_CASE(\"Test default value appender\", \"[appender]\") {\n+\tduckdb::unique_ptr<QueryResult> result;\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER, j INTEGER DEFAULT 5)\"));\n+\n+\t// Insert DEFAULT into default column\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(2);\n+\t\tappender.AppendDefault();\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(2)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::INTEGER(5)}));\n+\n+\tcon.Query(\"DELETE from integers\");\n+\n+\t// Insert DEFAULT into non-default column\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\t// 'i' does not have a DEFAULT value, so it gets NULL\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value(LogicalTypeId::INTEGER)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::INTEGER(5)}));\n+\n+\t// Insert DEFAULT into column that can't be NULL\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i integer NOT NULL)\"));\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\t// NOT NULL constraint failed\n+\t\tREQUIRE_THROWS(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tauto chunk = result->Fetch();\n+\tREQUIRE(chunk == nullptr);\n+\n+\t// DEFAULT nextval('seq')\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE SEQUENCE seq\"));\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i iNTEGER, j INTEGER DEFAULT nextval('seq'))\"));\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(1);\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(1)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::INTEGER(1)}));\n+\n+\t// DEFAULT random()\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i iNTEGER, j DOUBLE DEFAULT random())\"));\n+\tcon.Query(\"select setseed(0.42)\");\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(1);\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(1)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {Value::DOUBLE(0.4729174713138491)}));\n+\n+\t// DEFAULT now()\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE OR REPLACE TABLE integers(i iNTEGER, j TIMESTAMPTZ DEFAULT now())\"));\n+\tcon.Query(\"BEGIN TRANSACTION\");\n+\tresult = con.Query(\"select now()\");\n+\tauto &materialized_result = result->Cast<MaterializedQueryResult>();\n+\tauto current_time = materialized_result.GetValue(0, 0);\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\t\tappender.BeginRow();\n+\t\tappender.Append<int32_t>(1);\n+\t\tREQUIRE_NOTHROW(appender.AppendDefault());\n+\t\tREQUIRE_NOTHROW(appender.EndRow());\n+\t\tREQUIRE_NOTHROW(appender.Close());\n+\t}\n+\tresult = con.Query(\"SELECT * FROM integers\");\n+\tREQUIRE(CHECK_COLUMN(result, 0, {Value::INTEGER(1)}));\n+\tREQUIRE(CHECK_COLUMN(result, 1, {current_time}));\n+\tcon.Query(\"COMMIT\");\n+}\n+\n+TEST_CASE(\"Test append default into Vector\", \"[appender]\") {\n+\tDuckDB db(nullptr);\n+\tConnection con(db);\n+\n+\tREQUIRE_NO_FAIL(con.Query(\"CREATE TABLE integers(i iNTEGER)\"));\n+\n+\tauto result = con.Query(\"SELECT a::INTEGER FROM RANGE(15) t(a)\");\n+\tauto chunk = result->Fetch();\n+\tD_ASSERT(result->type == QueryResultType::MATERIALIZED_RESULT);\n+\n+\t{\n+\t\tAppender appender(con, \"integers\");\n+\n+\t\tauto &column = chunk->data[0];\n+\t\tSelectionVector sel(3);\n+\n+\t\tsel.set_index(0, 5);\n+\t\tsel.set_index(1, 8);\n+\t\tsel.set_index(2, 3);\n+\n+\t\tappender.AppendDefaultToVector(column, 0, sel, 3);\n+\t\tREQUIRE(column.GetValue(0) == 0);\n+\t\tREQUIRE(column.GetValue(1) == 1);\n+\n+\t\tREQUIRE(column.GetValue(5).IsNull());\n+\n+\t\tREQUIRE(column.GetValue(8).IsNull());\n+\n+\t\tREQUIRE(column.GetValue(3).IsNull());\n+\n+\t\tREQUIRE(!column.GetValue(14).IsNull());\n+\t\tREQUIRE(column.GetValue(14) == 14);",
        "comment_created_at": "2024-05-08T08:51:49+00:00",
        "comment_author": "taniabogatsch",
        "comment_body": "Let's extend this test by trying to append the data chunk to the table after setting the default values. Can we also add other `AppendDefaultsToVector` tests triggering the exceptions?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2251981517",
    "pr_number": 18457,
    "pr_file": "src/optimizer/rule/date_trunc_simplification.cpp",
    "created_at": "2025-08-04T16:23:47+00:00",
    "commented_code": "+#include \"duckdb/optimizer/rule/date_trunc_simplification.hpp\"\n+\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/enums/expression_type.hpp\"\n+#include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_conjunction_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/optimizer/matcher/expression_matcher.hpp\"\n+#include \"duckdb/optimizer/expression_rewriter.hpp\"\n+#include \"duckdb/common/enums/date_part_specifier.hpp\"\n+#include \"duckdb/function/function.hpp\"\n+#include \"duckdb/function/function_binder.hpp\"\n+#include \"duckdb/function/cast/default_casts.hpp\"\n+\n+namespace duckdb {\n+\n+DateTruncSimplificationRule::DateTruncSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {\n+\tauto op = make_uniq<ComparisonExpressionMatcher>();\n+\n+\tauto lhs = make_uniq<FunctionExpressionMatcher>();\n+\tlhs->function = make_uniq<ManyFunctionMatcher>(unordered_set<string> {\"date_trunc\", \"datetrunc\"});\n+\tlhs->matchers.push_back(make_uniq<ConstantExpressionMatcher>());\n+\tlhs->matchers.push_back(make_uniq<ExpressionMatcher>());\n+\tlhs->policy = SetMatcher::Policy::ORDERED;\n+\n+\tauto rhs = make_uniq<ConstantExpressionMatcher>();\n+\n+\top->matchers.push_back(std::move(lhs));\n+\top->matchers.push_back(std::move(rhs));\n+\top->policy = SetMatcher::Policy::UNORDERED;\n+\n+\troot = std::move(op);\n+}\n+\n+unique_ptr<Expression> DateTruncSimplificationRule::Apply(LogicalOperator &op, vector<reference<Expression>> &bindings,\n+                                                          bool &changes_made, bool is_root) {\n+\tauto &expr = bindings[0].get().Cast<BoundComparisonExpression>();\n+\tauto comparison_type = expr.GetExpressionType();\n+\n+\tauto &date_part = bindings[2].get().Cast<BoundConstantExpression>();\n+\tauto &column_part = bindings[3].get().Cast<BoundColumnRefExpression>();\n+\tauto &rhs = bindings[4].get().Cast<BoundConstantExpression>();\n+\n+\t// Determine whether or not the column name is on the lhs or rhs.\n+\tconst bool col_is_lhs = (expr.left->GetExpressionClass() == ExpressionClass::BOUND_FUNCTION);\n+\n+\t// We want to treat rhs >= col equivalently to col <= rhs.\n+\t// So, get the expression type if it was ordered such that the constant was actually on the right hand side.\n+\tExpressionType rhs_comparison_type = comparison_type;\n+\tif (!col_is_lhs) {\n+\t\tswitch (comparison_type) {\n+\t\tcase ExpressionType::COMPARE_LESSTHAN:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_GREATERTHAN;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_GREATERTHANOREQUALTO;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_LESSTHAN;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_LESSTHANOREQUALTO;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t// Check whether trunc(date_part, constant_rhs) = constant_rhs.\n+\tconst bool is_truncated = DateIsTruncated(date_part, rhs);\n+\n+\tswitch (rhs_comparison_type) {\n+\tcase ExpressionType::COMPARE_EQUAL:\n+\t\t// date_trunc(part, column) = constant_rhs  -->  column >= date_trunc(part, constant_rhs) AND\n+\t\t//                                               column < date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                  INTERVAL 1 part)\n+\t\t//    or, if date_trunc(part, constant_rhs) <> constant_rhs, this is unsatisfiable\n+\t\t{\n+\t\t\tif (!is_truncated) {\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value::BOOLEAN(false));\n+\t\t\t}\n+\n+\t\t\tauto trunc = CreateTrunc(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto trunc_add = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc_add) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto gteq = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,\n+\t\t\t                                                 column_part.Copy(), std::move(trunc));\n+\t\t\tauto lt = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHAN, column_part.Copy(),\n+\t\t\t                                               std::move(trunc_add));\n+\n+\t\t\treturn make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(gteq),\n+\t\t\t                                             std::move(lt));\n+\t\t}\n+\n+\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\t\t// date_trunc(part, column) <> constant_rhs  -->  column < date_trunc(part, constant_rhs) OR\n+\t\t//                                                column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part)\n+\t\t//   or, if date_trunc(part, constant_rhs) <> constant_rhs, this is always true\n+\t\t{\n+\t\t\tif (!is_truncated) {\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value::BOOLEAN(true));\n+\t\t\t}\n+\n+\t\t\tauto trunc = CreateTrunc(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto trunc_add = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc_add) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto lt = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHAN, column_part.Copy(),\n+\t\t\t                                               std::move(trunc));\n+\t\t\tauto gteq = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,\n+\t\t\t                                                 column_part.Copy(), std::move(trunc_add));\n+\n+\t\t\treturn make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR, std::move(gteq),\n+\t\t\t                                             std::move(lt));\n+\t\t}\n+\t\treturn nullptr;\n+\n+\tcase ExpressionType::COMPARE_LESSTHAN:\n+\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\t// date_trunc(part, column) <  constant_rhs  -->  column <  date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t// date_trunc(part, column) >= constant_rhs  -->  column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t{\n+\t\t\t// The optimization for < and >= is a little tricky: if trunc(rhs) = rhs, then we need to just\n+\t\t\t// use the rhs as-is, instead of using trunc(rhs + 1 date_part).\n+\t\t\tif (!is_truncated) {\n+\t\t\t\t// Create date_trunc(part, date_add(rhs, INTERVAL 1 part)) and fold the constant.\n+\t\t\t\tauto trunc = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\t\tif (!trunc) {\n+\t\t\t\t\treturn nullptr; // Something went wrong---don't do the optimization.\n+\t\t\t\t}\n+\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\t\texpr.right = std::move(trunc);\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\t\texpr.left = std::move(trunc);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// If the RHS is already truncated (i.e.  date_trunc(part, rhs) = rhs), then we can use\n+\t\t\t\t// it as-is.\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\t\t// Determine whether the RHS needs to be casted.\n+\t\t\t\t\tif (rhs.return_type.id() != expr.left->return_type.id()) {\n+\t\t\t\t\t\texpr.right = CastAndEvaluate(std::move(expr.right), expr.left->return_type);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\t\t// Determine whether the RHS needs to be casted.\n+\t\t\t\t\tif (rhs.return_type.id() != expr.right->return_type.id()) {\n+\t\t\t\t\t\texpr.left = CastAndEvaluate(std::move(expr.left), expr.right->return_type);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tchanges_made = true;\n+\t\t\treturn nullptr;\n+\t\t}\n+\n+\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\t// date_trunc(part, column) <= constant_rhs  -->  column <= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t// date_trunc(part, column) >  constant_rhs  -->  column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t{\n+\t\t\t// Create date_trunc(part, date_add(rhs, INTERVAL 1 part)) and fold the constant.\n+\t\t\tauto trunc = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr; // Something went wrong---don't do the optimization.\n+\t\t\t}\n+\n+\t\t\tif (col_is_lhs) {\n+\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\texpr.right = std::move(trunc);\n+\t\t\t} else {\n+\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\texpr.left = std::move(trunc);\n+\t\t\t}\n+\n+\t\t\t// If this is a >, we need to change it to >= for correctness.\n+\t\t\tif (rhs_comparison_type == ExpressionType::COMPARE_GREATERTHAN) {\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.SetExpressionTypeUnsafe(ExpressionType::COMPARE_GREATERTHANOREQUALTO);\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.SetExpressionTypeUnsafe(ExpressionType::COMPARE_LESSTHANOREQUALTO);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tchanges_made = true;\n+\t\t\treturn nullptr;\n+\t\t}\n+\n+\tdefault:",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2251981517",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18457,
        "pr_file": "src/optimizer/rule/date_trunc_simplification.cpp",
        "discussion_id": "2251981517",
        "commented_code": "@@ -0,0 +1,376 @@\n+#include \"duckdb/optimizer/rule/date_trunc_simplification.hpp\"\n+\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/enums/expression_type.hpp\"\n+#include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_conjunction_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/optimizer/matcher/expression_matcher.hpp\"\n+#include \"duckdb/optimizer/expression_rewriter.hpp\"\n+#include \"duckdb/common/enums/date_part_specifier.hpp\"\n+#include \"duckdb/function/function.hpp\"\n+#include \"duckdb/function/function_binder.hpp\"\n+#include \"duckdb/function/cast/default_casts.hpp\"\n+\n+namespace duckdb {\n+\n+DateTruncSimplificationRule::DateTruncSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {\n+\tauto op = make_uniq<ComparisonExpressionMatcher>();\n+\n+\tauto lhs = make_uniq<FunctionExpressionMatcher>();\n+\tlhs->function = make_uniq<ManyFunctionMatcher>(unordered_set<string> {\"date_trunc\", \"datetrunc\"});\n+\tlhs->matchers.push_back(make_uniq<ConstantExpressionMatcher>());\n+\tlhs->matchers.push_back(make_uniq<ExpressionMatcher>());\n+\tlhs->policy = SetMatcher::Policy::ORDERED;\n+\n+\tauto rhs = make_uniq<ConstantExpressionMatcher>();\n+\n+\top->matchers.push_back(std::move(lhs));\n+\top->matchers.push_back(std::move(rhs));\n+\top->policy = SetMatcher::Policy::UNORDERED;\n+\n+\troot = std::move(op);\n+}\n+\n+unique_ptr<Expression> DateTruncSimplificationRule::Apply(LogicalOperator &op, vector<reference<Expression>> &bindings,\n+                                                          bool &changes_made, bool is_root) {\n+\tauto &expr = bindings[0].get().Cast<BoundComparisonExpression>();\n+\tauto comparison_type = expr.GetExpressionType();\n+\n+\tauto &date_part = bindings[2].get().Cast<BoundConstantExpression>();\n+\tauto &column_part = bindings[3].get().Cast<BoundColumnRefExpression>();\n+\tauto &rhs = bindings[4].get().Cast<BoundConstantExpression>();\n+\n+\t// Determine whether or not the column name is on the lhs or rhs.\n+\tconst bool col_is_lhs = (expr.left->GetExpressionClass() == ExpressionClass::BOUND_FUNCTION);\n+\n+\t// We want to treat rhs >= col equivalently to col <= rhs.\n+\t// So, get the expression type if it was ordered such that the constant was actually on the right hand side.\n+\tExpressionType rhs_comparison_type = comparison_type;\n+\tif (!col_is_lhs) {\n+\t\tswitch (comparison_type) {\n+\t\tcase ExpressionType::COMPARE_LESSTHAN:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_GREATERTHAN;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_GREATERTHANOREQUALTO;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_LESSTHAN;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_LESSTHANOREQUALTO;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t// Check whether trunc(date_part, constant_rhs) = constant_rhs.\n+\tconst bool is_truncated = DateIsTruncated(date_part, rhs);\n+\n+\tswitch (rhs_comparison_type) {\n+\tcase ExpressionType::COMPARE_EQUAL:\n+\t\t// date_trunc(part, column) = constant_rhs  -->  column >= date_trunc(part, constant_rhs) AND\n+\t\t//                                               column < date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                  INTERVAL 1 part)\n+\t\t//    or, if date_trunc(part, constant_rhs) <> constant_rhs, this is unsatisfiable\n+\t\t{\n+\t\t\tif (!is_truncated) {\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value::BOOLEAN(false));\n+\t\t\t}\n+\n+\t\t\tauto trunc = CreateTrunc(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto trunc_add = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc_add) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto gteq = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,\n+\t\t\t                                                 column_part.Copy(), std::move(trunc));\n+\t\t\tauto lt = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHAN, column_part.Copy(),\n+\t\t\t                                               std::move(trunc_add));\n+\n+\t\t\treturn make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(gteq),\n+\t\t\t                                             std::move(lt));\n+\t\t}\n+\n+\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\t\t// date_trunc(part, column) <> constant_rhs  -->  column < date_trunc(part, constant_rhs) OR\n+\t\t//                                                column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part)\n+\t\t//   or, if date_trunc(part, constant_rhs) <> constant_rhs, this is always true\n+\t\t{\n+\t\t\tif (!is_truncated) {\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value::BOOLEAN(true));\n+\t\t\t}\n+\n+\t\t\tauto trunc = CreateTrunc(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto trunc_add = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc_add) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto lt = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHAN, column_part.Copy(),\n+\t\t\t                                               std::move(trunc));\n+\t\t\tauto gteq = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,\n+\t\t\t                                                 column_part.Copy(), std::move(trunc_add));\n+\n+\t\t\treturn make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR, std::move(gteq),\n+\t\t\t                                             std::move(lt));\n+\t\t}\n+\t\treturn nullptr;\n+\n+\tcase ExpressionType::COMPARE_LESSTHAN:\n+\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\t// date_trunc(part, column) <  constant_rhs  -->  column <  date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t// date_trunc(part, column) >= constant_rhs  -->  column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t{\n+\t\t\t// The optimization for < and >= is a little tricky: if trunc(rhs) = rhs, then we need to just\n+\t\t\t// use the rhs as-is, instead of using trunc(rhs + 1 date_part).\n+\t\t\tif (!is_truncated) {\n+\t\t\t\t// Create date_trunc(part, date_add(rhs, INTERVAL 1 part)) and fold the constant.\n+\t\t\t\tauto trunc = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\t\tif (!trunc) {\n+\t\t\t\t\treturn nullptr; // Something went wrong---don't do the optimization.\n+\t\t\t\t}\n+\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\t\texpr.right = std::move(trunc);\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\t\texpr.left = std::move(trunc);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// If the RHS is already truncated (i.e.  date_trunc(part, rhs) = rhs), then we can use\n+\t\t\t\t// it as-is.\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\t\t// Determine whether the RHS needs to be casted.\n+\t\t\t\t\tif (rhs.return_type.id() != expr.left->return_type.id()) {\n+\t\t\t\t\t\texpr.right = CastAndEvaluate(std::move(expr.right), expr.left->return_type);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\t\t// Determine whether the RHS needs to be casted.\n+\t\t\t\t\tif (rhs.return_type.id() != expr.right->return_type.id()) {\n+\t\t\t\t\t\texpr.left = CastAndEvaluate(std::move(expr.left), expr.right->return_type);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tchanges_made = true;\n+\t\t\treturn nullptr;\n+\t\t}\n+\n+\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\t// date_trunc(part, column) <= constant_rhs  -->  column <= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t// date_trunc(part, column) >  constant_rhs  -->  column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t{\n+\t\t\t// Create date_trunc(part, date_add(rhs, INTERVAL 1 part)) and fold the constant.\n+\t\t\tauto trunc = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr; // Something went wrong---don't do the optimization.\n+\t\t\t}\n+\n+\t\t\tif (col_is_lhs) {\n+\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\texpr.right = std::move(trunc);\n+\t\t\t} else {\n+\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\texpr.left = std::move(trunc);\n+\t\t\t}\n+\n+\t\t\t// If this is a >, we need to change it to >= for correctness.\n+\t\t\tif (rhs_comparison_type == ExpressionType::COMPARE_GREATERTHAN) {\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.SetExpressionTypeUnsafe(ExpressionType::COMPARE_GREATERTHANOREQUALTO);\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.SetExpressionTypeUnsafe(ExpressionType::COMPARE_LESSTHANOREQUALTO);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tchanges_made = true;\n+\t\t\treturn nullptr;\n+\t\t}\n+\n+\tdefault:",
        "comment_created_at": "2025-08-04T16:23:47+00:00",
        "comment_author": "hawkfish",
        "comment_body": "Can we add `IS [NOT] DISTINCT` cases as well?",
        "pr_file_module": null
      },
      {
        "comment_id": "2252370106",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18457,
        "pr_file": "src/optimizer/rule/date_trunc_simplification.cpp",
        "discussion_id": "2251981517",
        "commented_code": "@@ -0,0 +1,376 @@\n+#include \"duckdb/optimizer/rule/date_trunc_simplification.hpp\"\n+\n+#include \"duckdb/common/exception.hpp\"\n+#include \"duckdb/common/enums/expression_type.hpp\"\n+#include \"duckdb/catalog/catalog_entry/scalar_function_catalog_entry.hpp\"\n+#include \"duckdb/execution/expression_executor.hpp\"\n+#include \"duckdb/planner/expression/bound_cast_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_columnref_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_comparison_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_conjunction_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_constant_expression.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/optimizer/matcher/expression_matcher.hpp\"\n+#include \"duckdb/optimizer/expression_rewriter.hpp\"\n+#include \"duckdb/common/enums/date_part_specifier.hpp\"\n+#include \"duckdb/function/function.hpp\"\n+#include \"duckdb/function/function_binder.hpp\"\n+#include \"duckdb/function/cast/default_casts.hpp\"\n+\n+namespace duckdb {\n+\n+DateTruncSimplificationRule::DateTruncSimplificationRule(ExpressionRewriter &rewriter) : Rule(rewriter) {\n+\tauto op = make_uniq<ComparisonExpressionMatcher>();\n+\n+\tauto lhs = make_uniq<FunctionExpressionMatcher>();\n+\tlhs->function = make_uniq<ManyFunctionMatcher>(unordered_set<string> {\"date_trunc\", \"datetrunc\"});\n+\tlhs->matchers.push_back(make_uniq<ConstantExpressionMatcher>());\n+\tlhs->matchers.push_back(make_uniq<ExpressionMatcher>());\n+\tlhs->policy = SetMatcher::Policy::ORDERED;\n+\n+\tauto rhs = make_uniq<ConstantExpressionMatcher>();\n+\n+\top->matchers.push_back(std::move(lhs));\n+\top->matchers.push_back(std::move(rhs));\n+\top->policy = SetMatcher::Policy::UNORDERED;\n+\n+\troot = std::move(op);\n+}\n+\n+unique_ptr<Expression> DateTruncSimplificationRule::Apply(LogicalOperator &op, vector<reference<Expression>> &bindings,\n+                                                          bool &changes_made, bool is_root) {\n+\tauto &expr = bindings[0].get().Cast<BoundComparisonExpression>();\n+\tauto comparison_type = expr.GetExpressionType();\n+\n+\tauto &date_part = bindings[2].get().Cast<BoundConstantExpression>();\n+\tauto &column_part = bindings[3].get().Cast<BoundColumnRefExpression>();\n+\tauto &rhs = bindings[4].get().Cast<BoundConstantExpression>();\n+\n+\t// Determine whether or not the column name is on the lhs or rhs.\n+\tconst bool col_is_lhs = (expr.left->GetExpressionClass() == ExpressionClass::BOUND_FUNCTION);\n+\n+\t// We want to treat rhs >= col equivalently to col <= rhs.\n+\t// So, get the expression type if it was ordered such that the constant was actually on the right hand side.\n+\tExpressionType rhs_comparison_type = comparison_type;\n+\tif (!col_is_lhs) {\n+\t\tswitch (comparison_type) {\n+\t\tcase ExpressionType::COMPARE_LESSTHAN:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_GREATERTHAN;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_GREATERTHANOREQUALTO;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_LESSTHAN;\n+\t\t\tbreak;\n+\t\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\t\trhs_comparison_type = ExpressionType::COMPARE_LESSTHANOREQUALTO;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t// Check whether trunc(date_part, constant_rhs) = constant_rhs.\n+\tconst bool is_truncated = DateIsTruncated(date_part, rhs);\n+\n+\tswitch (rhs_comparison_type) {\n+\tcase ExpressionType::COMPARE_EQUAL:\n+\t\t// date_trunc(part, column) = constant_rhs  -->  column >= date_trunc(part, constant_rhs) AND\n+\t\t//                                               column < date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                  INTERVAL 1 part)\n+\t\t//    or, if date_trunc(part, constant_rhs) <> constant_rhs, this is unsatisfiable\n+\t\t{\n+\t\t\tif (!is_truncated) {\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value::BOOLEAN(false));\n+\t\t\t}\n+\n+\t\t\tauto trunc = CreateTrunc(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto trunc_add = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc_add) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto gteq = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,\n+\t\t\t                                                 column_part.Copy(), std::move(trunc));\n+\t\t\tauto lt = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHAN, column_part.Copy(),\n+\t\t\t                                               std::move(trunc_add));\n+\n+\t\t\treturn make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_AND, std::move(gteq),\n+\t\t\t                                             std::move(lt));\n+\t\t}\n+\n+\tcase ExpressionType::COMPARE_NOTEQUAL:\n+\t\t// date_trunc(part, column) <> constant_rhs  -->  column < date_trunc(part, constant_rhs) OR\n+\t\t//                                                column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part)\n+\t\t//   or, if date_trunc(part, constant_rhs) <> constant_rhs, this is always true\n+\t\t{\n+\t\t\tif (!is_truncated) {\n+\t\t\t\treturn make_uniq<BoundConstantExpression>(Value::BOOLEAN(true));\n+\t\t\t}\n+\n+\t\t\tauto trunc = CreateTrunc(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto trunc_add = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc_add) {\n+\t\t\t\treturn nullptr;\n+\t\t\t}\n+\n+\t\t\tauto lt = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_LESSTHAN, column_part.Copy(),\n+\t\t\t                                               std::move(trunc));\n+\t\t\tauto gteq = make_uniq<BoundComparisonExpression>(ExpressionType::COMPARE_GREATERTHANOREQUALTO,\n+\t\t\t                                                 column_part.Copy(), std::move(trunc_add));\n+\n+\t\t\treturn make_uniq<BoundConjunctionExpression>(ExpressionType::CONJUNCTION_OR, std::move(gteq),\n+\t\t\t                                             std::move(lt));\n+\t\t}\n+\t\treturn nullptr;\n+\n+\tcase ExpressionType::COMPARE_LESSTHAN:\n+\tcase ExpressionType::COMPARE_GREATERTHANOREQUALTO:\n+\t\t// date_trunc(part, column) <  constant_rhs  -->  column <  date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t// date_trunc(part, column) >= constant_rhs  -->  column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t{\n+\t\t\t// The optimization for < and >= is a little tricky: if trunc(rhs) = rhs, then we need to just\n+\t\t\t// use the rhs as-is, instead of using trunc(rhs + 1 date_part).\n+\t\t\tif (!is_truncated) {\n+\t\t\t\t// Create date_trunc(part, date_add(rhs, INTERVAL 1 part)) and fold the constant.\n+\t\t\t\tauto trunc = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\t\tif (!trunc) {\n+\t\t\t\t\treturn nullptr; // Something went wrong---don't do the optimization.\n+\t\t\t\t}\n+\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\t\texpr.right = std::move(trunc);\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\t\texpr.left = std::move(trunc);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// If the RHS is already truncated (i.e.  date_trunc(part, rhs) = rhs), then we can use\n+\t\t\t\t// it as-is.\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\t\t// Determine whether the RHS needs to be casted.\n+\t\t\t\t\tif (rhs.return_type.id() != expr.left->return_type.id()) {\n+\t\t\t\t\t\texpr.right = CastAndEvaluate(std::move(expr.right), expr.left->return_type);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\t\t// Determine whether the RHS needs to be casted.\n+\t\t\t\t\tif (rhs.return_type.id() != expr.right->return_type.id()) {\n+\t\t\t\t\t\texpr.left = CastAndEvaluate(std::move(expr.left), expr.right->return_type);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tchanges_made = true;\n+\t\t\treturn nullptr;\n+\t\t}\n+\n+\tcase ExpressionType::COMPARE_LESSTHANOREQUALTO:\n+\tcase ExpressionType::COMPARE_GREATERTHAN:\n+\t\t// date_trunc(part, column) <= constant_rhs  -->  column <= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t// date_trunc(part, column) >  constant_rhs  -->  column >= date_trunc(part, date_add(constant_rhs,\n+\t\t//                                                                                    INTERVAL 1 part))\n+\t\t{\n+\t\t\t// Create date_trunc(part, date_add(rhs, INTERVAL 1 part)) and fold the constant.\n+\t\t\tauto trunc = CreateTruncAdd(date_part, rhs, column_part.return_type);\n+\t\t\tif (!trunc) {\n+\t\t\t\treturn nullptr; // Something went wrong---don't do the optimization.\n+\t\t\t}\n+\n+\t\t\tif (col_is_lhs) {\n+\t\t\t\texpr.left = column_part.Copy();\n+\t\t\t\texpr.right = std::move(trunc);\n+\t\t\t} else {\n+\t\t\t\texpr.right = column_part.Copy();\n+\t\t\t\texpr.left = std::move(trunc);\n+\t\t\t}\n+\n+\t\t\t// If this is a >, we need to change it to >= for correctness.\n+\t\t\tif (rhs_comparison_type == ExpressionType::COMPARE_GREATERTHAN) {\n+\t\t\t\tif (col_is_lhs) {\n+\t\t\t\t\texpr.SetExpressionTypeUnsafe(ExpressionType::COMPARE_GREATERTHANOREQUALTO);\n+\t\t\t\t} else {\n+\t\t\t\t\texpr.SetExpressionTypeUnsafe(ExpressionType::COMPARE_LESSTHANOREQUALTO);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tchanges_made = true;\n+\t\t\treturn nullptr;\n+\t\t}\n+\n+\tdefault:",
        "comment_created_at": "2025-08-04T19:12:35+00:00",
        "comment_author": "rcurtin",
        "comment_body": "Ah!  I overlooked those.  After working through the algebra I implemented them (they're quite similar but not exactly the same as the `<>` and `=` cases).  I also added a bunch of tests to handle `NULL`s on the rhs or lhs in 56f49e0608.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2210200322",
    "pr_number": 18246,
    "pr_file": "src/main/capi/arrow-c.cpp",
    "created_at": "2025-07-16T12:14:01+00:00",
    "commented_code": "return nullptr;\n }\n \n-duckdb_error_data arrow_to_duckdb_schema(duckdb_connection connection, duckdb_arrow_schema schema,\n+duckdb_error_data arrow_to_duckdb_schema(duckdb_connection connection, ArrowSchema *schema,\n                                          duckdb_arrow_converted_schema *out_types, char ***out_names,\n                                          idx_t *out_column_count) {\n-\tif (!connection || !schema || !out_types || !out_names || !out_column_count) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2210200322",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18246,
        "pr_file": "src/main/capi/arrow-c.cpp",
        "discussion_id": "2210200322",
        "commented_code": "@@ -66,10 +65,10 @@ duckdb_error_data duckdb_data_chunk_to_arrow(duckdb_client_properties client_pro\n \treturn nullptr;\n }\n \n-duckdb_error_data arrow_to_duckdb_schema(duckdb_connection connection, duckdb_arrow_schema schema,\n+duckdb_error_data arrow_to_duckdb_schema(duckdb_connection connection, ArrowSchema *schema,\n                                          duckdb_arrow_converted_schema *out_types, char ***out_names,\n                                          idx_t *out_column_count) {\n-\tif (!connection || !schema || !out_types || !out_names || !out_column_count) {",
        "comment_created_at": "2025-07-16T12:14:01+00:00",
        "comment_author": "Tishj",
        "comment_body": "`!schema` still needs to be checked",
        "pr_file_module": null
      }
    ]
  }
]