[
  {
    "discussion_id": "1901593001",
    "pr_number": 15533,
    "pr_file": "extension/core_functions/scalar/struct/struct_update.cpp",
    "created_at": "2025-01-03T09:12:16+00:00",
    "commented_code": "+#include \"core_functions/scalar/struct_functions.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/parser/expression/bound_expression.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/storage/statistics/struct_stats.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n+\n+namespace duckdb {\n+\n+static void StructUpdateFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &starting_vec = args.data[0];\n+\tstarting_vec.Verify(args.size());\n+\n+\tauto &starting_child_entries = StructVector::GetEntries(starting_vec);\n+\tauto &result_child_entries = StructVector::GetEntries(result);\n+\n+\tauto &starting_types = StructType::GetChildTypes(starting_vec.GetType());\n+\n+\tauto &func_args = state.expr.Cast<BoundFunctionExpression>().children;\n+\tauto new_entries = case_insensitive_tree_t<idx_t>();\n+\tauto is_new_field = vector<bool>(args.ColumnCount(), true);\n+\n+\tfor (idx_t arg_idx = 1; arg_idx < func_args.size(); arg_idx++) {\n+\t\tauto &new_child = func_args[arg_idx];\n+\t\tnew_entries.emplace(new_child->alias, arg_idx);\n+\t}\n+\n+\t// Assign the original child entries to the STRUCT.\n+\tfor (idx_t field_idx = 0; field_idx < starting_child_entries.size(); field_idx++) {\n+\t\tauto &starting_child = starting_child_entries[field_idx];\n+\t\tauto update = new_entries.find(starting_types[field_idx].first.c_str());",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1901593001",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15533,
        "pr_file": "extension/core_functions/scalar/struct/struct_update.cpp",
        "discussion_id": "1901593001",
        "commented_code": "@@ -0,0 +1,158 @@\n+#include \"core_functions/scalar/struct_functions.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/parser/expression/bound_expression.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/storage/statistics/struct_stats.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n+\n+namespace duckdb {\n+\n+static void StructUpdateFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &starting_vec = args.data[0];\n+\tstarting_vec.Verify(args.size());\n+\n+\tauto &starting_child_entries = StructVector::GetEntries(starting_vec);\n+\tauto &result_child_entries = StructVector::GetEntries(result);\n+\n+\tauto &starting_types = StructType::GetChildTypes(starting_vec.GetType());\n+\n+\tauto &func_args = state.expr.Cast<BoundFunctionExpression>().children;\n+\tauto new_entries = case_insensitive_tree_t<idx_t>();\n+\tauto is_new_field = vector<bool>(args.ColumnCount(), true);\n+\n+\tfor (idx_t arg_idx = 1; arg_idx < func_args.size(); arg_idx++) {\n+\t\tauto &new_child = func_args[arg_idx];\n+\t\tnew_entries.emplace(new_child->alias, arg_idx);\n+\t}\n+\n+\t// Assign the original child entries to the STRUCT.\n+\tfor (idx_t field_idx = 0; field_idx < starting_child_entries.size(); field_idx++) {\n+\t\tauto &starting_child = starting_child_entries[field_idx];\n+\t\tauto update = new_entries.find(starting_types[field_idx].first.c_str());",
        "comment_created_at": "2025-01-03T09:12:16+00:00",
        "comment_author": "Tishj",
        "comment_body": "This looks to me like there is nothing preventing the same alias from being provided twice?\r\nUnless that's not possible and prevented somewhere else\r\n\r\nBut I'd like to see a test for this, i.e:\r\n```sql\r\nselect struct_update({'a': 42}, a := 3, a := 4);\r\n```\r\n\r\n`emplace` will make sure the second `a := 4` is ignored I believe, but I think it's better if this results in an InvalidInput or Binder Exception",
        "pr_file_module": null
      },
      {
        "comment_id": "1902207582",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15533,
        "pr_file": "extension/core_functions/scalar/struct/struct_update.cpp",
        "discussion_id": "1901593001",
        "commented_code": "@@ -0,0 +1,158 @@\n+#include \"core_functions/scalar/struct_functions.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/parser/expression/bound_expression.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/storage/statistics/struct_stats.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n+\n+namespace duckdb {\n+\n+static void StructUpdateFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &starting_vec = args.data[0];\n+\tstarting_vec.Verify(args.size());\n+\n+\tauto &starting_child_entries = StructVector::GetEntries(starting_vec);\n+\tauto &result_child_entries = StructVector::GetEntries(result);\n+\n+\tauto &starting_types = StructType::GetChildTypes(starting_vec.GetType());\n+\n+\tauto &func_args = state.expr.Cast<BoundFunctionExpression>().children;\n+\tauto new_entries = case_insensitive_tree_t<idx_t>();\n+\tauto is_new_field = vector<bool>(args.ColumnCount(), true);\n+\n+\tfor (idx_t arg_idx = 1; arg_idx < func_args.size(); arg_idx++) {\n+\t\tauto &new_child = func_args[arg_idx];\n+\t\tnew_entries.emplace(new_child->alias, arg_idx);\n+\t}\n+\n+\t// Assign the original child entries to the STRUCT.\n+\tfor (idx_t field_idx = 0; field_idx < starting_child_entries.size(); field_idx++) {\n+\t\tauto &starting_child = starting_child_entries[field_idx];\n+\t\tauto update = new_entries.find(starting_types[field_idx].first.c_str());",
        "comment_created_at": "2025-01-03T22:18:53+00:00",
        "comment_author": "teaguesterling",
        "comment_body": "Added test cases and handled duplicate args",
        "pr_file_module": null
      },
      {
        "comment_id": "1902280525",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15533,
        "pr_file": "extension/core_functions/scalar/struct/struct_update.cpp",
        "discussion_id": "1901593001",
        "commented_code": "@@ -0,0 +1,158 @@\n+#include \"core_functions/scalar/struct_functions.hpp\"\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/common/string_util.hpp\"\n+#include \"duckdb/parser/expression/bound_expression.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/common/case_insensitive_map.hpp\"\n+#include \"duckdb/storage/statistics/struct_stats.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n+\n+namespace duckdb {\n+\n+static void StructUpdateFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tauto &starting_vec = args.data[0];\n+\tstarting_vec.Verify(args.size());\n+\n+\tauto &starting_child_entries = StructVector::GetEntries(starting_vec);\n+\tauto &result_child_entries = StructVector::GetEntries(result);\n+\n+\tauto &starting_types = StructType::GetChildTypes(starting_vec.GetType());\n+\n+\tauto &func_args = state.expr.Cast<BoundFunctionExpression>().children;\n+\tauto new_entries = case_insensitive_tree_t<idx_t>();\n+\tauto is_new_field = vector<bool>(args.ColumnCount(), true);\n+\n+\tfor (idx_t arg_idx = 1; arg_idx < func_args.size(); arg_idx++) {\n+\t\tauto &new_child = func_args[arg_idx];\n+\t\tnew_entries.emplace(new_child->alias, arg_idx);\n+\t}\n+\n+\t// Assign the original child entries to the STRUCT.\n+\tfor (idx_t field_idx = 0; field_idx < starting_child_entries.size(); field_idx++) {\n+\t\tauto &starting_child = starting_child_entries[field_idx];\n+\t\tauto update = new_entries.find(starting_types[field_idx].first.c_str());",
        "comment_created_at": "2025-01-04T03:59:54+00:00",
        "comment_author": "teaguesterling",
        "comment_body": "I implemented this in the bind section, but if it should've been here, please let me know.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "804514381",
    "pr_number": 3065,
    "pr_file": "src/function/scalar/list/list_contains.cpp",
    "created_at": "2022-02-11T10:14:15+00:00",
    "commented_code": "+#include <iostream>\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n+\n+namespace duckdb {\n+\n+static void SetResultFalse(Vector &result) {\n+\tauto result_data = FlatVector::GetData<bool>(result);\n+\tresult_data[0] = false;\n+\treturn;\n+}\n+\n+template <class T>\n+static void TemplatedListContainsStringFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tD_ASSERT(args.ColumnCount() == 2);\n+\tauto count = args.size();\n+\tVector &list = args.data[0];\n+\tVector &value = args.data[1];\n+\tVectorData value_data;\n+\tvalue.Orrify(count, value_data);\n+\n+\tif (list.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\n+\tauto list_size = ListVector::GetListSize(list);\n+\tif (list_size == 0) { // empty list will never contain a value\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tauto &child_vector = ListVector::GetEntry(list);\n+\tif (child_vector.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tVectorData child_data;\n+\tchild_vector.Orrify(list_size, child_data);\n+\n+\tVectorData list_data;\n+\tlist.Orrify(count, list_data);\n+\tauto list_entries = (list_entry_t *)list_data.data;\n+\n+\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\tauto result_entries = FlatVector::GetData<bool>(result); // Create a vector of bool\n+\tauto &result_validity = FlatVector::Validity(result);\n+\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto list_index = list_data.sel->get_index(i);\n+\n+\t\tif (!list_data.validity.RowIsValid(list_index)) {\n+\t\t\tresult_validity.SetInvalid(i);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tresult_entries[list_index] = false;\n+\n+\t\tconst auto &entry = list_entries[list_index];\n+\t\tauto source_idx = child_data.sel->get_index(entry.offset);\n+\t\tauto child_value = FlatVector::GetData<T>(child_vector);\n+\n+\t\tfor (idx_t child_idx = 0; child_idx < entry.length; child_idx++) {\n+\t\t\tauto value_idx = source_idx + child_idx;\n+\t\t\tif (!child_data.validity.RowIsValid(value_idx)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tauto actual_value = child_value[value_idx];\n+\t\t\tif (StringComparisonOperators::EqualsOrNot<false>(actual_value, ((T *)value_data.data)[0])) {\n+\t\t\t\tresult_entries[list_index] = true;\n+\t\t\t\tbreak; // Found value in list, no need to look further\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn;\n+}\n+\n+template <class T>\n+static void TemplatedListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tD_ASSERT(args.ColumnCount() == 2);\n+\tauto count = args.size();\n+\tVector &list = args.data[0];\n+\tVector &value = args.data[1];\n+\tVectorData value_data;\n+\tvalue.Orrify(count, value_data);\n+\n+\tif (list.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\n+\tauto list_size = ListVector::GetListSize(list);\n+\tif (list_size == 0) { // empty list will never contain a value\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tauto &child_vector = ListVector::GetEntry(list);\n+\tif (child_vector.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tVectorData child_data;\n+\tchild_vector.Orrify(list_size, child_data);\n+\n+\tVectorData list_data;\n+\tlist.Orrify(count, list_data);\n+\tauto list_entries = (list_entry_t *)list_data.data;\n+\n+\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\tauto result_entries = FlatVector::GetData<bool>(result); // Create a vector of bool\n+\tauto &result_validity = FlatVector::Validity(result);\n+\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto list_index = list_data.sel->get_index(i);\n+\n+\t\tif (!list_data.validity.RowIsValid(list_index)) {\n+\t\t\tresult_validity.SetInvalid(i);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tresult_entries[list_index] = false;\n+\n+\t\tconst auto &entry = list_entries[list_index];\n+\t\tauto source_idx = child_data.sel->get_index(entry.offset);\n+\t\tauto child_value = FlatVector::GetData<T>(child_vector);\n+\n+\t\tfor (idx_t child_idx = 0; child_idx < entry.length; child_idx++) {\n+\t\t\tauto value_idx = source_idx + child_idx;\n+\t\t\tif (!child_data.validity.RowIsValid(value_idx)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tauto actual_value = child_value[value_idx];\n+\t\t\tif (actual_value == ((T *)value_data.data)[0]) {\n+\t\t\t\tresult_entries[list_index] = true;\n+\t\t\t\tbreak; // Found value in list, no need to look further\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn;\n+}\n+\n+static void ListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tswitch (args.data[1].GetType().InternalType()) {\n+\tcase PhysicalType::BOOL:\n+\tcase PhysicalType::INT8:\n+\t\tTemplatedListContainsFunction<int8_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT16:\n+\t\tTemplatedListContainsFunction<int16_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT32:\n+\t\tTemplatedListContainsFunction<int32_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT64:\n+\t\tTemplatedListContainsFunction<int64_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT128:\n+\t\tTemplatedListContainsFunction<hugeint_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT8:\n+\t\tTemplatedListContainsFunction<uint8_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT16:\n+\t\tTemplatedListContainsFunction<uint16_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT32:\n+\t\tTemplatedListContainsFunction<uint32_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT64:\n+\t\tTemplatedListContainsFunction<uint64_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::FLOAT:\n+\t\tTemplatedListContainsFunction<float>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::DOUBLE:\n+\t\tTemplatedListContainsFunction<double>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::VARCHAR:\n+\t\tTemplatedListContainsStringFunction<string_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::LIST:\n+\t\tthrow NotImplementedException(\"This function has not yet been implemented for nested types\");\n+\tdefault:\n+\t\tthrow InvalidTypeException(args.data[1].GetType().id(), \"Invalid type for List Contains\");",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "804514381",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 3065,
        "pr_file": "src/function/scalar/list/list_contains.cpp",
        "discussion_id": "804514381",
        "commented_code": "@@ -0,0 +1,226 @@\n+#include <iostream>\n+#include \"duckdb/planner/expression/bound_function_expression.hpp\"\n+#include \"duckdb/function/scalar/nested_functions.hpp\"\n+#include \"duckdb/planner/expression_binder.hpp\"\n+\n+namespace duckdb {\n+\n+static void SetResultFalse(Vector &result) {\n+\tauto result_data = FlatVector::GetData<bool>(result);\n+\tresult_data[0] = false;\n+\treturn;\n+}\n+\n+template <class T>\n+static void TemplatedListContainsStringFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tD_ASSERT(args.ColumnCount() == 2);\n+\tauto count = args.size();\n+\tVector &list = args.data[0];\n+\tVector &value = args.data[1];\n+\tVectorData value_data;\n+\tvalue.Orrify(count, value_data);\n+\n+\tif (list.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\n+\tauto list_size = ListVector::GetListSize(list);\n+\tif (list_size == 0) { // empty list will never contain a value\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tauto &child_vector = ListVector::GetEntry(list);\n+\tif (child_vector.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tVectorData child_data;\n+\tchild_vector.Orrify(list_size, child_data);\n+\n+\tVectorData list_data;\n+\tlist.Orrify(count, list_data);\n+\tauto list_entries = (list_entry_t *)list_data.data;\n+\n+\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\tauto result_entries = FlatVector::GetData<bool>(result); // Create a vector of bool\n+\tauto &result_validity = FlatVector::Validity(result);\n+\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto list_index = list_data.sel->get_index(i);\n+\n+\t\tif (!list_data.validity.RowIsValid(list_index)) {\n+\t\t\tresult_validity.SetInvalid(i);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tresult_entries[list_index] = false;\n+\n+\t\tconst auto &entry = list_entries[list_index];\n+\t\tauto source_idx = child_data.sel->get_index(entry.offset);\n+\t\tauto child_value = FlatVector::GetData<T>(child_vector);\n+\n+\t\tfor (idx_t child_idx = 0; child_idx < entry.length; child_idx++) {\n+\t\t\tauto value_idx = source_idx + child_idx;\n+\t\t\tif (!child_data.validity.RowIsValid(value_idx)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tauto actual_value = child_value[value_idx];\n+\t\t\tif (StringComparisonOperators::EqualsOrNot<false>(actual_value, ((T *)value_data.data)[0])) {\n+\t\t\t\tresult_entries[list_index] = true;\n+\t\t\t\tbreak; // Found value in list, no need to look further\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn;\n+}\n+\n+template <class T>\n+static void TemplatedListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tD_ASSERT(args.ColumnCount() == 2);\n+\tauto count = args.size();\n+\tVector &list = args.data[0];\n+\tVector &value = args.data[1];\n+\tVectorData value_data;\n+\tvalue.Orrify(count, value_data);\n+\n+\tif (list.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\n+\tauto list_size = ListVector::GetListSize(list);\n+\tif (list_size == 0) { // empty list will never contain a value\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tauto &child_vector = ListVector::GetEntry(list);\n+\tif (child_vector.GetType().id() == LogicalTypeId::SQLNULL) {\n+\t\tSetResultFalse(result);\n+\t\treturn;\n+\t}\n+\tVectorData child_data;\n+\tchild_vector.Orrify(list_size, child_data);\n+\n+\tVectorData list_data;\n+\tlist.Orrify(count, list_data);\n+\tauto list_entries = (list_entry_t *)list_data.data;\n+\n+\tresult.SetVectorType(VectorType::FLAT_VECTOR);\n+\tauto result_entries = FlatVector::GetData<bool>(result); // Create a vector of bool\n+\tauto &result_validity = FlatVector::Validity(result);\n+\n+\tfor (idx_t i = 0; i < count; i++) {\n+\t\tauto list_index = list_data.sel->get_index(i);\n+\n+\t\tif (!list_data.validity.RowIsValid(list_index)) {\n+\t\t\tresult_validity.SetInvalid(i);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tresult_entries[list_index] = false;\n+\n+\t\tconst auto &entry = list_entries[list_index];\n+\t\tauto source_idx = child_data.sel->get_index(entry.offset);\n+\t\tauto child_value = FlatVector::GetData<T>(child_vector);\n+\n+\t\tfor (idx_t child_idx = 0; child_idx < entry.length; child_idx++) {\n+\t\t\tauto value_idx = source_idx + child_idx;\n+\t\t\tif (!child_data.validity.RowIsValid(value_idx)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tauto actual_value = child_value[value_idx];\n+\t\t\tif (actual_value == ((T *)value_data.data)[0]) {\n+\t\t\t\tresult_entries[list_index] = true;\n+\t\t\t\tbreak; // Found value in list, no need to look further\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn;\n+}\n+\n+static void ListContainsFunction(DataChunk &args, ExpressionState &state, Vector &result) {\n+\tswitch (args.data[1].GetType().InternalType()) {\n+\tcase PhysicalType::BOOL:\n+\tcase PhysicalType::INT8:\n+\t\tTemplatedListContainsFunction<int8_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT16:\n+\t\tTemplatedListContainsFunction<int16_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT32:\n+\t\tTemplatedListContainsFunction<int32_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT64:\n+\t\tTemplatedListContainsFunction<int64_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::INT128:\n+\t\tTemplatedListContainsFunction<hugeint_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT8:\n+\t\tTemplatedListContainsFunction<uint8_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT16:\n+\t\tTemplatedListContainsFunction<uint16_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT32:\n+\t\tTemplatedListContainsFunction<uint32_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::UINT64:\n+\t\tTemplatedListContainsFunction<uint64_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::FLOAT:\n+\t\tTemplatedListContainsFunction<float>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::DOUBLE:\n+\t\tTemplatedListContainsFunction<double>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::VARCHAR:\n+\t\tTemplatedListContainsStringFunction<string_t>(args, state, result);\n+\t\tbreak;\n+\tcase PhysicalType::LIST:\n+\t\tthrow NotImplementedException(\"This function has not yet been implemented for nested types\");\n+\tdefault:\n+\t\tthrow InvalidTypeException(args.data[1].GetType().id(), \"Invalid type for List Contains\");",
        "comment_created_at": "2022-02-11T10:14:15+00:00",
        "comment_author": "lnkuiper",
        "comment_body": "We can check whether nested types have been supplied in `ListContainsBind` already, that way the errors happens before the query has started executing. This should also be a `NotImplementedException`, because I don't think any type should be invalid for this function",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2163333580",
    "pr_number": 18013,
    "pr_file": "src/function/pragma/pragma_functions.cpp",
    "created_at": "2025-06-24T08:46:49+00:00",
    "commented_code": "DBConfig::GetConfig(context).options.checkpoint_on_shutdown = false;\n }\n \n+static void PragmaEnableWalEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_wal_encryption = true;\n+}\n+\n+static void PragmaDisableWalEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_wal_encryption = false;\n+}\n+\n+static void PragmaEnableTempFilesEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_temp_file_encryption = true;",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "2163333580",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 18013,
        "pr_file": "src/function/pragma/pragma_functions.cpp",
        "discussion_id": "2163333580",
        "commented_code": "@@ -115,6 +116,35 @@ static void PragmaDisableCheckpointOnShutdown(ClientContext &context, const Func\n \tDBConfig::GetConfig(context).options.checkpoint_on_shutdown = false;\n }\n \n+static void PragmaEnableWalEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_wal_encryption = true;\n+}\n+\n+static void PragmaDisableWalEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_wal_encryption = false;\n+}\n+\n+static void PragmaEnableTempFilesEncryption(ClientContext &context, const FunctionParameters &parameters) {\n+\tDBConfig::GetConfig(context).options.enable_temp_file_encryption = true;",
        "comment_created_at": "2025-06-24T08:46:49+00:00",
        "comment_author": "Mytherin",
        "comment_body": "Can we maybe verify there are no temporary files currently active when setting this - and throw an error if there are any - given that this will lead to not being able to read/interact with the existing temporary files?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1966598109",
    "pr_number": 14613,
    "pr_file": "src/main/capi/duckdb_value-c.cpp",
    "created_at": "2025-02-22T20:47:33+00:00",
    "commented_code": "return WrapValue(array_value);\n }\n \n+duckdb_value duckdb_create_map_value(duckdb_logical_type map_type, duckdb_value keys, duckdb_value values) {\n+\tif (!map_type || !keys || !values) {\n+\t\treturn nullptr;\n+\t}\n+\n+\tauto &map_logical_type = UnwrapType(map_type);\n+\tif (duckdb::TypeVisitor::Contains(map_logical_type, duckdb::LogicalTypeId::INVALID) ||\n+\t    duckdb::TypeVisitor::Contains(map_logical_type, duckdb::LogicalTypeId::ANY)) {\n+\t\treturn nullptr;\n+\t}\n+\n+\tauto &key_logical_type = duckdb::MapType::KeyType(map_logical_type);",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1966598109",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 14613,
        "pr_file": "src/main/capi/duckdb_value-c.cpp",
        "discussion_id": "1966598109",
        "commented_code": "@@ -393,6 +393,91 @@ duckdb_value duckdb_create_array_value(duckdb_logical_type type, duckdb_value *v\n \treturn WrapValue(array_value);\n }\n \n+duckdb_value duckdb_create_map_value(duckdb_logical_type map_type, duckdb_value keys, duckdb_value values) {\n+\tif (!map_type || !keys || !values) {\n+\t\treturn nullptr;\n+\t}\n+\n+\tauto &map_logical_type = UnwrapType(map_type);\n+\tif (duckdb::TypeVisitor::Contains(map_logical_type, duckdb::LogicalTypeId::INVALID) ||\n+\t    duckdb::TypeVisitor::Contains(map_logical_type, duckdb::LogicalTypeId::ANY)) {\n+\t\treturn nullptr;\n+\t}\n+\n+\tauto &key_logical_type = duckdb::MapType::KeyType(map_logical_type);",
        "comment_created_at": "2025-02-22T20:47:33+00:00",
        "comment_author": "Tishj",
        "comment_body": "This is assuming `map_logical_type` is a MAP, but this isn't verified anywhere before this, I assume there is no test for this either because this will throw an InternalException I'm pretty sure, can we add a test and fix this?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1903096257",
    "pr_number": 15534,
    "pr_file": "src/planner/binder/expression/bind_operator_expression.cpp",
    "created_at": "2025-01-04T13:00:59+00:00",
    "commented_code": "LogicalType ExpressionBinder::ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children) {\n \t// NOT expression, cast child to BOOLEAN\n-\tD_ASSERT(children.size() == 1);\n+\tif (children.size() != 1) {",
    "repo_full_name": "duckdb/duckdb",
    "discussion_comments": [
      {
        "comment_id": "1903096257",
        "repo_full_name": "duckdb/duckdb",
        "pr_number": 15534,
        "pr_file": "src/planner/binder/expression/bind_operator_expression.cpp",
        "discussion_id": "1903096257",
        "commented_code": "@@ -13,7 +13,11 @@ namespace duckdb {\n \n LogicalType ExpressionBinder::ResolveNotType(OperatorExpression &op, vector<unique_ptr<Expression>> &children) {\n \t// NOT expression, cast child to BOOLEAN\n-\tD_ASSERT(children.size() == 1);\n+\tif (children.size() != 1) {",
        "comment_created_at": "2025-01-04T13:00:59+00:00",
        "comment_author": "Mytherin",
        "comment_body": "I think this is the wrong place to fix the error - NOT operators should not be generated with multiple expressions. I think we should be throwing this error when expanding the `*COLUMNS(*)` expression instead ",
        "pr_file_module": null
      }
    ]
  }
]