---
title: Measure before optimizing performance
description: 'Before implementing performance optimizations, measure and validate
  the impact through benchmarks. This applies especially to:


  1. Changes affecting common operations (string conversions, collections)'
repository: elastic/elasticsearch
label: Performance Optimization
language: Java
comments_count: 6
repository_stars: 73104
---

Before implementing performance optimizations, measure and validate the impact through benchmarks. This applies especially to:

1. Changes affecting common operations (string conversions, collections)
2. Modifications to critical paths (search, indexing)
3. Updates to shared resources or services

Example benchmark approach:
```java
@Fork(value = 1)
@Warmup(iterations = 5)
@Measurement(iterations = 5)
@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class PerformanceBenchmark {
    @Param({"10", "100", "1000"})
    private int size;
    
    @Benchmark
    public void benchmarkOperation() {
        // Test both existing and new implementation
        // Compare results across different input sizes
    }
}
```

Key practices:
- Test with varying input sizes to understand scaling characteristics
- Measure both average case and edge cases
- Compare before/after metrics to quantify improvements
- Consider system-wide impact, not just local optimizations

This approach helps prevent premature optimization and ensures changes provide meaningful performance benefits.


[
  {
    "discussion_id": "2166503674",
    "pr_number": 129969,
    "pr_file": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java",
    "created_at": "2025-06-25T11:38:51+00:00",
    "commented_code": "iwc.setMaxFullFlushMergeWaitMillis(-1);\n        iwc.setSimilarity(engineConfig.getSimilarity());\n        iwc.setRAMBufferSizeMB(engineConfig.getIndexingBufferSize().getMbFrac());\n        iwc.setCodec(engineConfig.getCodec());\n        iwc.setCodec(new TrackingPostingsInMemoryBytesCodec(engineConfig.getCodec()));",
    "repo_full_name": "elastic/elasticsearch",
    "discussion_comments": [
      {
        "comment_id": "2166503674",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 129969,
        "pr_file": "server/src/main/java/org/elasticsearch/index/engine/InternalEngine.java",
        "discussion_id": "2166503674",
        "commented_code": "@@ -2778,7 +2779,7 @@ private IndexWriterConfig getIndexWriterConfig() {\n         iwc.setMaxFullFlushMergeWaitMillis(-1);\n         iwc.setSimilarity(engineConfig.getSimilarity());\n         iwc.setRAMBufferSizeMB(engineConfig.getIndexingBufferSize().getMbFrac());\n-        iwc.setCodec(engineConfig.getCodec());\n+        iwc.setCodec(new TrackingPostingsInMemoryBytesCodec(engineConfig.getCodec()));",
        "comment_created_at": "2025-06-25T11:38:51+00:00",
        "comment_author": "martijnvg",
        "comment_body": "I wonder what the overhead is of always wrapping the codec in `TrackingPostingsInMemoryBytesCodec`. Maybe let's quickly run benchmark? (elastic/logs?)\r\n\r\nAdditionally I wonder whether this should only be done for stateless only.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2168541968",
    "pr_number": 129997,
    "pr_file": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java",
    "created_at": "2025-06-26T08:47:27+00:00",
    "commented_code": "XContentParser.Token token;\n        XContentParser.Token previousToken = parser.currentToken();\n        int elements = 0;\n        int countArray = 0;\n        long nestedDocsLimit = context.indexSettings().getMappingNestedDocsLimit();\n        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n            if (token == XContentParser.Token.START_OBJECT) {\n                if (countArray++ >= nestedDocsLimit) {",
    "repo_full_name": "elastic/elasticsearch",
    "discussion_comments": [
      {
        "comment_id": "2168541968",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 129997,
        "pr_file": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java",
        "discussion_id": "2168541968",
        "commented_code": "@@ -749,8 +749,20 @@ private static void parseNonDynamicArray(\n         XContentParser.Token token;\n         XContentParser.Token previousToken = parser.currentToken();\n         int elements = 0;\n+        int countArray = 0;\n+        long nestedDocsLimit = context.indexSettings().getMappingNestedDocsLimit();\n         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n             if (token == XContentParser.Token.START_OBJECT) {\n+                if (countArray++ >= nestedDocsLimit) {",
        "comment_created_at": "2025-06-26T08:47:27+00:00",
        "comment_author": "javanna",
        "comment_body": "I worry that this will be a performance hit when parsing documents perhaps. We should have micro benchmarks for document parsing under ./benchmarks. It is probably worth double checking the impact of this change.",
        "pr_file_module": null
      },
      {
        "comment_id": "2168594099",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 129997,
        "pr_file": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java",
        "discussion_id": "2168541968",
        "commented_code": "@@ -749,8 +749,20 @@ private static void parseNonDynamicArray(\n         XContentParser.Token token;\n         XContentParser.Token previousToken = parser.currentToken();\n         int elements = 0;\n+        int countArray = 0;\n+        long nestedDocsLimit = context.indexSettings().getMappingNestedDocsLimit();\n         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n             if (token == XContentParser.Token.START_OBJECT) {\n+                if (countArray++ >= nestedDocsLimit) {",
        "comment_created_at": "2025-06-26T09:12:03+00:00",
        "comment_author": "drempapis",
        "comment_body": ">We should have micro benchmarks for document parsing under ./benchmarks.\r\n\r\nWhat\u2019s the recommended way to micro-benchmark this functionality",
        "pr_file_module": null
      },
      {
        "comment_id": "2172680459",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 129997,
        "pr_file": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java",
        "discussion_id": "2168541968",
        "commented_code": "@@ -749,8 +749,20 @@ private static void parseNonDynamicArray(\n         XContentParser.Token token;\n         XContentParser.Token previousToken = parser.currentToken();\n         int elements = 0;\n+        int countArray = 0;\n+        long nestedDocsLimit = context.indexSettings().getMappingNestedDocsLimit();\n         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n             if (token == XContentParser.Token.START_OBJECT) {\n+                if (countArray++ >= nestedDocsLimit) {",
        "comment_created_at": "2025-06-27T18:54:56+00:00",
        "comment_author": "javanna",
        "comment_body": "I would run the existing micro benchmarks for document parsing, and check if they would detect regressions around the counting you added, or add a new one that's specific to this scenario if needed. We may actually need documents with an array including many inner objects that we likely don't have in the existing benchmarks",
        "pr_file_module": null
      },
      {
        "comment_id": "2177851365",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 129997,
        "pr_file": "server/src/main/java/org/elasticsearch/index/mapper/DocumentParser.java",
        "discussion_id": "2168541968",
        "commented_code": "@@ -749,8 +749,20 @@ private static void parseNonDynamicArray(\n         XContentParser.Token token;\n         XContentParser.Token previousToken = parser.currentToken();\n         int elements = 0;\n+        int countArray = 0;\n+        long nestedDocsLimit = context.indexSettings().getMappingNestedDocsLimit();\n         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n             if (token == XContentParser.Token.START_OBJECT) {\n+                if (countArray++ >= nestedDocsLimit) {",
        "comment_created_at": "2025-07-01T15:04:00+00:00",
        "comment_author": "drempapis",
        "comment_body": "I did a micro-benchmarking to test the time it takes to parse documents with varying `array` sizes.\r\nThe `Run 1` is for he main branch where`Run 2` is for the current branch (update)\r\n\r\n```\r\n\r\nArray Size | Run 1 Avg (ns/op) | Run 2 Avg (ns/op) | Difference (ns) | % Change\r\n--------------------------------------------------------------------------------\r\n10         |      1983.711     |      2223.238     |    +239.527    |   +12.07%\r\n100        |     15356.069     |     15497.797     |    +141.728    |    +0.92%\r\n1000       |    141146.977     |    145791.315     |   +4644.338    |    +3.29%\r\n10000      |   1432616.938     |   1443769.196     |  +11152.258    |    +0.78%\r\n```\r\nThe performance degraded slightly in the second run for all array sizes. For larger array sizes (1000 and 10000), the performance remained quite stable. \r\n\r\nFor the array size of 10 we observe the largest relative increase though the absolute impact is small.\r\n\r\nI executed the benchmark locally, aiming to minimize system load by stopping all resource-intensive processes. However, some system noise or garbage collection activity may have influenced the results.\r\n\r\nThe code I executed was the following \r\n```\r\n@Fork(value = 1)\r\n@Warmup(iterations = 5)\r\n@Measurement(iterations = 5)\r\n@BenchmarkMode(Mode.AverageTime)\r\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\r\n@State(Scope.Benchmark)\r\npublic class DocumentParserBenchmark {\r\n\r\n    static {\r\n        LogConfigurator.loadLog4jPlugins();\r\n        LogConfigurator.configureESLogging();\r\n    }\r\n\r\n    @Param({\"10\", \"100\", \"1000\", \"10000\"})\r\n    private int arraySize;\r\n\r\n    private MapperService mapperService;\r\n\r\n    private SourceToParse sourceToParse;\r\n\r\n    @Setup\r\n    public void setUp() {\r\n        this.mapperService = MapperServiceFactory.create(\"\"\"\r\n            {\r\n              \"properties\": {\r\n                 \"array\": {\r\n                    \"properties\": {\r\n                       \"value\": { \"type\": \"integer\" }\r\n                    }\r\n                 }\r\n              }\r\n            }\r\n            \\s\"\"\");\r\n\r\n        this.sourceToParse = new SourceToParse(UUIDs.randomBase64UUID(),\r\n            new BytesArray(generateDocWithArray(arraySize)), XContentType.JSON);\r\n    }\r\n\r\n    @Benchmark\r\n    public List<LuceneDocument> benchmarkDocumentWithLargeArray() {\r\n        return mapperService.documentMapper().parse(sourceToParse).docs();\r\n    }\r\n\r\n    private static String generateDocWithArray(int arraySize) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"{ \\\"array\\\": [\");\r\n        for (int i = 1; i <= arraySize; i++) {\r\n            sb.append(\"{\\\"value\\\": \").append(i).append(\"}\");\r\n            if (i < arraySize) {\r\n                sb.append(\",\");\r\n            }\r\n        }\r\n        sb.append(\"]}\");\r\n        return sb.toString();\r\n    }\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1965662264",
    "pr_number": 123148,
    "pr_file": "server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesFetcher.java",
    "created_at": "2025-02-21T15:14:51+00:00",
    "commented_code": "null,\n                            Map.of()\n                        );\n                        responseMap.put(parentField, fieldCap);\n\n                        if (filter == null || Arrays.asList(types).contains(type)) {",
    "repo_full_name": "elastic/elasticsearch",
    "discussion_comments": [
      {
        "comment_id": "1965662264",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 123148,
        "pr_file": "server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesFetcher.java",
        "discussion_id": "1965662264",
        "commented_code": "@@ -214,7 +215,10 @@ static Map<String, IndexFieldCapabilities> retrieveFieldCaps(\n                             null,\n                             Map.of()\n                         );\n-                        responseMap.put(parentField, fieldCap);\n+\n+                        if (filter == null || Arrays.asList(types).contains(type)) {",
        "comment_created_at": "2025-02-21T15:14:51+00:00",
        "comment_author": "piergm",
        "comment_body": "Careful, by calling `Arrays.asList` in a loop, here we are converting every time the array to a new `ArrayList` and it is not very efficient.\r\nThere are a couple of options here:\r\n1) We can convert the array to a ArrayList before the for loop (this should be safe since we are not changing the array content).\r\n2) Use a Set instead of an ArrayList (also placed outside the loop), in this way the .contains call is O(1), while for ArrayList is O(n). \r\nSide note: I don't expect this array to ever become huge therefore both approach should be safe to use but to be extra safe I'd opt for the Set.\r\nIf we are using Set we can even go for `Set.of(types)` since it returns an unmodifiable set!",
        "pr_file_module": null
      },
      {
        "comment_id": "1967988577",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 123148,
        "pr_file": "server/src/main/java/org/elasticsearch/action/fieldcaps/FieldCapabilitiesFetcher.java",
        "discussion_id": "1965662264",
        "commented_code": "@@ -214,7 +215,10 @@ static Map<String, IndexFieldCapabilities> retrieveFieldCaps(\n                             null,\n                             Map.of()\n                         );\n-                        responseMap.put(parentField, fieldCap);\n+\n+                        if (filter == null || Arrays.asList(types).contains(type)) {",
        "comment_created_at": "2025-02-24T16:21:56+00:00",
        "comment_author": "luizgpsantos",
        "comment_body": "Yep, that makes sense. To avoid the duplicated initialization of `Set.of(types)`, I changed some other places. Also, now I have to check for the `parent` in the filters, so I used the same `Set` strategy.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1957201015",
    "pr_number": 122669,
    "pr_file": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java",
    "created_at": "2025-02-15T22:19:48+00:00",
    "commented_code": "final SearchActionListener<SearchPhaseResult> listener\n    ) {\n        ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt, listener.requestIndex));\n        getSearchTransport().sendExecuteQuery(connection, request, getTask(), listener);\n        var searchTransport = getSearchTransport();\n        var task = getTask();\n        if (searchTransport.transportService().getLocalNodeConnection() == connection) {\n            searchService.executeQueryPhase(request, task, listener);",
    "repo_full_name": "elastic/elasticsearch",
    "discussion_comments": [
      {
        "comment_id": "1957201015",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122669,
        "pr_file": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java",
        "discussion_id": "1957201015",
        "commented_code": "@@ -95,7 +98,13 @@ protected void executePhaseOnShard(\n         final SearchActionListener<SearchPhaseResult> listener\n     ) {\n         ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt, listener.requestIndex));\n-        getSearchTransport().sendExecuteQuery(connection, request, getTask(), listener);\n+        var searchTransport = getSearchTransport();\n+        var task = getTask();\n+        if (searchTransport.transportService().getLocalNodeConnection() == connection) {\n+            searchService.executeQueryPhase(request, task, listener);",
        "comment_created_at": "2025-02-15T22:19:48+00:00",
        "comment_author": "javanna",
        "comment_body": "out of curiosity: if we do this, why do it only for the query phase? Also, couldn't this conditional be added to the sendExecuteQuery method instead? What kind of overhead does this save? I can imagine that this is a pretty common pattern, or is search the edge case?",
        "pr_file_module": null
      },
      {
        "comment_id": "1957204416",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122669,
        "pr_file": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java",
        "discussion_id": "1957201015",
        "commented_code": "@@ -95,7 +98,13 @@ protected void executePhaseOnShard(\n         final SearchActionListener<SearchPhaseResult> listener\n     ) {\n         ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt, listener.requestIndex));\n-        getSearchTransport().sendExecuteQuery(connection, request, getTask(), listener);\n+        var searchTransport = getSearchTransport();\n+        var task = getTask();\n+        if (searchTransport.transportService().getLocalNodeConnection() == connection) {\n+            searchService.executeQueryPhase(request, task, listener);",
        "comment_created_at": "2025-02-15T22:49:01+00:00",
        "comment_author": "original-brownbear",
        "comment_body": "Hmm good question. I guess I only noticed this in benchmarks for search and for the query phase specifically. For fetch it's not super visible since you don't hit so many shards mostly and for bulk indexing you still have per-shard bulks so the cost isn't in that.\r\nI first noticed this with batched execution where the overhead becomes super visible but it's equally visible without it for large data nodes that do coordination work already (or if queries are heavy, like a large terms query or some geo stuff or so).\r\nThe overhead saved is 1. all the lookups in the transport layer, lots of listener wrapping, child-task registration and most importantly security.\r\n**But** :) that's why I need a review from security here I think. Functionally I think security still works the same way if not more efficiently. All tests pass because we auth the top level search request. DLS/FLS are applied as well but somehow those cache assertions needed adjustment and seemingly we do use the cache more now and I can't explain why.\r\nthe security overhead is considerable here, it's well in excess of the can_match cost for most rally runs it seems :O ",
        "pr_file_module": null
      },
      {
        "comment_id": "1957206010",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122669,
        "pr_file": "server/src/main/java/org/elasticsearch/action/search/SearchQueryThenFetchAsyncAction.java",
        "discussion_id": "1957201015",
        "commented_code": "@@ -95,7 +98,13 @@ protected void executePhaseOnShard(\n         final SearchActionListener<SearchPhaseResult> listener\n     ) {\n         ShardSearchRequest request = rewriteShardSearchRequest(super.buildShardSearchRequest(shardIt, listener.requestIndex));\n-        getSearchTransport().sendExecuteQuery(connection, request, getTask(), listener);\n+        var searchTransport = getSearchTransport();\n+        var task = getTask();\n+        if (searchTransport.transportService().getLocalNodeConnection() == connection) {\n+            searchService.executeQueryPhase(request, task, listener);",
        "comment_created_at": "2025-02-15T23:03:00+00:00",
        "comment_author": "original-brownbear",
        "comment_body": "It's this (couldn't zoom out further :P)\r\n![out2](https://github.com/user-attachments/assets/b242f23c-1ed1-41f4-bb97-5c5ed261f12c)\r\n\r\nvs this\r\n![out](https://github.com/user-attachments/assets/246c2643-a0ce-4ab5-8730-a6f50f4ed0c8)\r\n\r\nand on a transport thread. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2012358741",
    "pr_number": 122491,
    "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
    "created_at": "2025-03-25T15:21:43+00:00",
    "commented_code": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\npackage org.elasticsearch.ingest.common;\n\nimport org.elasticsearch.ingest.IngestDocument;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nfinal class CefParser {\n\n    private final IngestDocument ingestDocument;\n    private final boolean removeEmptyValue;\n\n    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n        this.ingestDocument = ingestDocument;\n        this.removeEmptyValue = removeEmptyValue;\n    }\n\n    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n\n    // New patterns for extension parsing\n    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n    );\n    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n\n    static {\n        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n\n        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n        FIELD_MAPPING.put(\"act\", \"event.action\");\n        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n        FIELD_MAPPING.put(\"end\", \"event.end\");\n        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n        FIELD_MAPPING.put(\"fname\", \"file.name\");\n        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n        FIELD_MAPPING.put(\"msg\", \"message\");\n        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n        FIELD_MAPPING.put(\"request\", \"url.original\");\n        FIELD_MAPPING.put(\"src\", \"source.ip\");\n        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n        FIELD_MAPPING.put(\"spt\", \"source.port\");\n        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n        FIELD_MAPPING.put(\"start\", \"event.start\");\n        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n        // Add more mappings as needed\n    }\n\n    void process(String cefString, String targetField) {\n        List<String> headerFields = new ArrayList<>();\n        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n        int extensionStart = 0;\n\n        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n            String field = headerMatcher.group(1);\n            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n            headerFields.add(field);\n            extensionStart = headerMatcher.end();\n        }\n\n        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n            CEFEvent event = new CEFEvent();\n            // Add error message if there are not enough header fields\n            if (headerFields.size() != 7) {\n                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n            }\n            for (int i = 0; i < headerFields.size(); i++) {\n                switch (i) {\n                    case 0:\n                        event.setVersion(headerFields.get(0).substring(4));\n                        break;\n                    case 1:\n                        event.setDeviceVendor(headerFields.get(1));\n                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n                        break;\n                    case 2:\n                        event.setDeviceProduct(headerFields.get(2));\n                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n                        break;\n                    case 3:\n                        event.setDeviceVersion(headerFields.get(3));\n                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n                        break;\n                    case 4:\n                        event.setDeviceEventClassId(headerFields.get(4));\n                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n                        break;\n                    case 5:\n                        event.setName(headerFields.get(5));\n                        break;\n                    case 6:\n                        event.setSeverity(headerFields.get(6));\n                        break;\n                }\n            }\n            String extensionString = cefString.substring(extensionStart);\n            Map<String, String> extensions = parseExtensions(extensionString);\n\n            if (removeEmptyValue) {\n                removeEmptyValue(extensions);\n            }\n            event.setExtensions(extensions);\n\n            // Translate possible ECS fields and remove them from extensions\n            Map<String, Object> translatedFields = extensions.entrySet()\n                .stream()\n                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n                    return convertValueToType(entry.getValue(), fieldType);\n                }));\n\n            // Remove the translated entries from extensions\n            event.removeMappedExtensions();\n\n            ingestDocument.setFieldValue(targetField, event.toObject());\n            // Add ECS translations to the root of the document\n            if (translatedFields.isEmpty() == false) {\n                translatedFields.forEach(ingestDocument::setFieldValue);\n            }\n        } else {\n            throw new IllegalArgumentException(\"Invalid CEF format\");\n        }\n    }\n\n    private Object convertValueToType(String value, Class<?> type) {\n        if (type == Long.class) {\n            return Long.parseLong(value);\n        } else if (type == Double.class) {\n            return Double.parseDouble(value);\n        } else if (type == Integer.class) {\n            return Integer.parseInt(value);\n        } else {\n            return value; // Default to String\n        }\n    }\n\n    private Map<String, String> parseExtensions(String extensionString) {\n        Map<String, String> extensions = new HashMap<>();\n        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n        int lastEnd = 0;\n        while (matcher.find()) {\n            String key = matcher.group(1);\n            String value = matcher.group(2);\n\n            // Convert extension field name to strict legal field_reference\n            if (key.endsWith(\"]\")) {\n                key = convertArrayLikeKey(key);\n            }\n\n            extensions.put(key, desanitizeExtensionVal(value.trim()));\n            lastEnd = matcher.end();\n        }\n        // If there's any remaining unparsed content, throw an exception\n        if (lastEnd < extensionString.length()) {\n            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n        }\n        return extensions;\n    }\n\n    private void removeEmptyValue(Map<String, String> map) {\n        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n        map.entrySet().removeIf(entry -> entry.getValue() == null);\n    }\n\n    private String convertArrayLikeKey(String key) {\n        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n        if (matcher.matches()) {\n            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n        }\n        return key;\n    }\n\n    public static String desanitizeExtensionVal(String value) {\n        String desanitized = value;\n        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n        }\n        return desanitized;\n    }\n\n    public static class CEFEvent {\n        private String version;\n        private String deviceVendor;\n        private String deviceProduct;\n        private String deviceVersion;\n        private String deviceEventClassId;\n        private String name;\n        private String severity;\n        private final Map<String, String> extensions = new HashMap<>();\n        private Map<String, String> translatedFields;\n\n        // Getters and setters for all fields\n        public String getVersion() {\n            return version;\n        }\n\n        public void setVersion(String version) {\n            this.version = version;\n        }\n\n        public String getDeviceVendor() {\n            return deviceVendor;\n        }\n\n        public void setDeviceVendor(String deviceVendor) {\n            this.deviceVendor = deviceVendor;\n        }\n\n        public String getDeviceProduct() {\n            return deviceProduct;\n        }\n\n        public void setDeviceProduct(String deviceProduct) {\n            this.deviceProduct = deviceProduct;\n        }\n\n        public String getDeviceVersion() {\n            return deviceVersion;\n        }\n\n        public void setDeviceVersion(String deviceVersion) {\n            this.deviceVersion = deviceVersion;\n        }\n\n        public String getDeviceEventClassId() {\n            return deviceEventClassId;\n        }\n\n        public void setDeviceEventClassId(String deviceEventClassId) {\n            this.deviceEventClassId = deviceEventClassId;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getSeverity() {\n            return severity;\n        }\n\n        public void setSeverity(String severity) {\n            this.severity = severity;\n        }\n\n        public Map<String, String> getExtensions() {\n            return extensions;\n        }\n\n        public void setExtensions(Map<String, String> extensions) {\n            this.extensions.putAll(extensions);\n        }\n\n        public void addExtension(String key, String extension) {\n            this.extensions.put(key, extension);\n        }\n\n        public void removeMappedExtensions() {\n            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
    "repo_full_name": "elastic/elasticsearch",
    "discussion_comments": [
      {
        "comment_id": "2012358741",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-25T15:21:43+00:00",
        "comment_author": "joegallo",
        "comment_body": "You're doing N scans through the whole collection here, I doubt that's going to be especially performant.",
        "pr_file_module": null
      },
      {
        "comment_id": "2012372556",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-25T15:28:16+00:00",
        "comment_author": "bhapas",
        "comment_body": "I think this can be \r\n\r\n```java\r\npublic void removeMappedExtensions() {\r\n    this.extensions.entrySet().removeIf(entry -> \r\n        FIELD_MAPPING.containsKey(entry.getKey()) || FIELD_MAPPING.containsValue(entry.getKey())\r\n    );\r\n}\r\n```\r\n\r\nOr you mean something else?",
        "pr_file_module": null
      },
      {
        "comment_id": "2012395998",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-25T15:39:16+00:00",
        "comment_author": "joegallo",
        "comment_body": "Explain to me how `containsValue` works on a Map.",
        "pr_file_module": null
      },
      {
        "comment_id": "2012404187",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-25T15:43:23+00:00",
        "comment_author": "bhapas",
        "comment_body": "Ohh yeah I get your point now.. I was only looking at `containsKey` thing. Yeah the `containsValue` iterates over the   N entries each time. I ll figure out a different way for this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2012455120",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-25T16:09:29+00:00",
        "comment_author": "joegallo",
        "comment_body": "If you smash all the keys and all the values into a single additional static `Set`, then you could do a `this.extensions.removeAll(thatStaticSet)`.",
        "pr_file_module": null
      },
      {
        "comment_id": "2014378954",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-26T15:00:44+00:00",
        "comment_author": "bhapas",
        "comment_body": "```\r\n        public void removeMappedExtensions() {\r\n            Set<String> fieldMappingKeysAndValues = new HashSet<>();\r\n            fieldMappingKeysAndValues.addAll(FIELD_MAPPING.keySet());\r\n            fieldMappingKeysAndValues.addAll(FIELD_MAPPING.values());\r\n\r\n            extensions.entrySet().removeIf(entry -> fieldMappingKeysAndValues.contains(entry.getKey()));\r\n        }\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2014448667",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-26T15:33:55+00:00",
        "comment_author": "joegallo",
        "comment_body": "No, do it staticly. There's no need to allocate a new HashSet umpteen times.",
        "pr_file_module": null
      },
      {
        "comment_id": "2016204628",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-27T10:40:24+00:00",
        "comment_author": "bhapas",
        "comment_body": "Moved to static Hashset.",
        "pr_file_module": null
      },
      {
        "comment_id": "2016853377",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2012358741",
        "commented_code": "@@ -0,0 +1,449 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the \"Elastic License\n+ * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n+ * Public License v 1\"; you may not use this file except in compliance with, at\n+ * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n+ * License v3.0 only\", or the \"Server Side Public License, v 1\".\n+ */\n+package org.elasticsearch.ingest.common;\n+\n+import org.elasticsearch.ingest.IngestDocument;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+final class CefParser {\n+\n+    private final IngestDocument ingestDocument;\n+    private final boolean removeEmptyValue;\n+\n+    CefParser(IngestDocument ingestDocument, boolean removeEmptyValue) {\n+        this.ingestDocument = ingestDocument;\n+        this.removeEmptyValue = removeEmptyValue;\n+    }\n+\n+    private static final Pattern HEADER_PATTERN = Pattern.compile(\"(?:\\\\\\\\\\\\||\\\\\\\\\\\\\\\\|[^|])*?\");\n+    private static final Pattern HEADER_NEXT_FIELD_PATTERN = Pattern.compile(\"(\" + HEADER_PATTERN.pattern() + \")\\\\|\");\n+    private static final Pattern HEADER_ESCAPE_CAPTURE = Pattern.compile(\"\\\\\\\\([\\\\\\\\|])\");\n+\n+    // New patterns for extension parsing\n+    private static final String EXTENSION_KEY_PATTERN = \"(?:[\\\\w-]+(?:\\\\.[^\\\\.=\\\\s\\\\|\\\\\\\\\\\\[\\\\]]+)*(?:\\\\[[0-9]+\\\\])?(?==))\";\n+    private static final Pattern EXTENSION_KEY_ARRAY_CAPTURE = Pattern.compile(\"^([^\\\\[\\\\]]+)((?:\\\\[[0-9]+\\\\])+)$\");\n+    private static final String EXTENSION_VALUE_PATTERN = \"(?:\\\\S|\\\\s(?!\" + EXTENSION_KEY_PATTERN + \"=))*\";\n+    private static final Pattern EXTENSION_NEXT_KEY_VALUE_PATTERN = Pattern.compile(\n+        \"(\" + EXTENSION_KEY_PATTERN + \")=(\" + EXTENSION_VALUE_PATTERN + \")(?:\\\\s+|$)\"\n+    );\n+    private static final Map<String, String> EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING = new HashMap<>();\n+    private static final Map<String, String> FIELD_MAPPING = new HashMap<>();\n+    private static final String ERROR_MESSAGE_INCOMPLETE_CEF_HEADER = \"incomplete CEF header\";\n+\n+    static {\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\\\\", \"\\\\\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\=\", \"=\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\n\", \"\\n\");\n+        EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.put(\"\\\\\\r\", \"\\r\");\n+\n+        FIELD_MAPPING.put(\"app\", \"network.protocol\");\n+        FIELD_MAPPING.put(\"in\", \"source.bytes\");\n+        FIELD_MAPPING.put(\"out\", \"destination.bytes\");\n+        FIELD_MAPPING.put(\"dst\", \"destination.ip\");\n+        FIELD_MAPPING.put(\"dlat\", \"destination.geo.location.lat\");\n+        FIELD_MAPPING.put(\"dlong\", \"destination.geo.location.lon\");\n+        FIELD_MAPPING.put(\"dhost\", \"destination.domain\");\n+        FIELD_MAPPING.put(\"dmac\", \"destination.mac\");\n+        FIELD_MAPPING.put(\"dntdom\", \"destination.registered_domain\");\n+        FIELD_MAPPING.put(\"dpt\", \"destination.port\");\n+        FIELD_MAPPING.put(\"dpid\", \"destination.process.pid\");\n+        FIELD_MAPPING.put(\"dproc\", \"destination.process.name\");\n+        FIELD_MAPPING.put(\"duid\", \"destination.user.id\");\n+        FIELD_MAPPING.put(\"duser\", \"destination.user.name\");\n+        FIELD_MAPPING.put(\"dpriv\", \"destination.user.group.name\");\n+        FIELD_MAPPING.put(\"act\", \"event.action\");\n+        FIELD_MAPPING.put(\"dvc\", \"observer.ip\");\n+        FIELD_MAPPING.put(\"deviceDirection\", \"network.direction\");\n+        FIELD_MAPPING.put(\"deviceDnsDomain\", \"observer.registered_domain\");\n+        FIELD_MAPPING.put(\"deviceExternalId\", \"observer.name\");\n+        FIELD_MAPPING.put(\"deviceFacility\", \"log.syslog.facility.code\");\n+        FIELD_MAPPING.put(\"dvchost\", \"observer.hostname\");\n+        FIELD_MAPPING.put(\"deviceInboundInterface\", \"observer.ingress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcmac\", \"observer.mac\");\n+        FIELD_MAPPING.put(\"deviceOutboundInterface\", \"observer.egress.interface.name\");\n+        FIELD_MAPPING.put(\"dvcpid\", \"process.pid\");\n+        FIELD_MAPPING.put(\"deviceProcessName\", \"process.name\");\n+        FIELD_MAPPING.put(\"rt\", \"@timestamp\");\n+        FIELD_MAPPING.put(\"dtz\", \"event.timezone\");\n+        FIELD_MAPPING.put(\"deviceTranslatedAddress\", \"host.nat.ip\");\n+        FIELD_MAPPING.put(\"device.version\", \"observer.version\");\n+        FIELD_MAPPING.put(\"deviceVersion\", \"observer.version\");\n+        FIELD_MAPPING.put(\"device.product\", \"observer.product\");\n+        FIELD_MAPPING.put(\"deviceProduct\", \"observer.product\");\n+        FIELD_MAPPING.put(\"device.event_class_id\", \"event.code\");\n+        FIELD_MAPPING.put(\"device.vendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"deviceVendor\", \"observer.vendor\");\n+        FIELD_MAPPING.put(\"end\", \"event.end\");\n+        FIELD_MAPPING.put(\"eventId\", \"event.id\");\n+        FIELD_MAPPING.put(\"outcome\", \"event.outcome\");\n+        FIELD_MAPPING.put(\"fileCreateTime\", \"file.created\");\n+        FIELD_MAPPING.put(\"fileHash\", \"file.hash\");\n+        FIELD_MAPPING.put(\"fileId\", \"file.inode\");\n+        FIELD_MAPPING.put(\"fileModificationTime\", \"file.mtime\");\n+        FIELD_MAPPING.put(\"fname\", \"file.name\");\n+        FIELD_MAPPING.put(\"filePath\", \"file.path\");\n+        FIELD_MAPPING.put(\"filePermission\", \"file.group\");\n+        FIELD_MAPPING.put(\"fsize\", \"file.size\");\n+        FIELD_MAPPING.put(\"fileType\", \"file.extension\");\n+        FIELD_MAPPING.put(\"mrt\", \"event.ingested\");\n+        FIELD_MAPPING.put(\"msg\", \"message\");\n+        FIELD_MAPPING.put(\"reason\", \"event.reason\");\n+        FIELD_MAPPING.put(\"requestClientApplication\", \"user_agent.original\");\n+        FIELD_MAPPING.put(\"requestContext\", \"http.request.referrer\");\n+        FIELD_MAPPING.put(\"requestMethod\", \"http.request.method\");\n+        FIELD_MAPPING.put(\"request\", \"url.original\");\n+        FIELD_MAPPING.put(\"src\", \"source.ip\");\n+        FIELD_MAPPING.put(\"sourceDnsDomain\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"slat\", \"source.geo.location.lat\");\n+        FIELD_MAPPING.put(\"slong\", \"source.geo.location.lon\");\n+        FIELD_MAPPING.put(\"shost\", \"source.domain\");\n+        FIELD_MAPPING.put(\"smac\", \"source.mac\");\n+        FIELD_MAPPING.put(\"sntdom\", \"source.registered_domain\");\n+        FIELD_MAPPING.put(\"spt\", \"source.port\");\n+        FIELD_MAPPING.put(\"spid\", \"source.process.pid\");\n+        FIELD_MAPPING.put(\"sproc\", \"source.process.name\");\n+        FIELD_MAPPING.put(\"sourceServiceName\", \"source.service.name\");\n+        FIELD_MAPPING.put(\"suser\", \"source.user.name\");\n+        FIELD_MAPPING.put(\"start\", \"event.start\");\n+        FIELD_MAPPING.put(\"proto\", \"network.transport\");\n+        // Add more mappings as needed\n+    }\n+\n+    void process(String cefString, String targetField) {\n+        List<String> headerFields = new ArrayList<>();\n+        Matcher headerMatcher = HEADER_NEXT_FIELD_PATTERN.matcher(cefString);\n+        int extensionStart = 0;\n+\n+        for (int i = 0; i < 7 && headerMatcher.find(); i++) {\n+            String field = headerMatcher.group(1);\n+            field = HEADER_ESCAPE_CAPTURE.matcher(field).replaceAll(\"$1\");\n+            headerFields.add(field);\n+            extensionStart = headerMatcher.end();\n+        }\n+\n+        if (headerFields.size() > 0 && headerFields.get(0).startsWith(\"CEF:\")) {\n+            CEFEvent event = new CEFEvent();\n+            // Add error message if there are not enough header fields\n+            if (headerFields.size() != 7) {\n+                ingestDocument.appendFieldValue(\"error.message\", ERROR_MESSAGE_INCOMPLETE_CEF_HEADER);\n+            }\n+            for (int i = 0; i < headerFields.size(); i++) {\n+                switch (i) {\n+                    case 0:\n+                        event.setVersion(headerFields.get(0).substring(4));\n+                        break;\n+                    case 1:\n+                        event.setDeviceVendor(headerFields.get(1));\n+                        ingestDocument.setFieldValue(\"observer.vendor\", headerFields.get(1));\n+                        break;\n+                    case 2:\n+                        event.setDeviceProduct(headerFields.get(2));\n+                        ingestDocument.setFieldValue(\"observer.product\", headerFields.get(2));\n+                        break;\n+                    case 3:\n+                        event.setDeviceVersion(headerFields.get(3));\n+                        ingestDocument.setFieldValue(\"observer.version\", headerFields.get(3));\n+                        break;\n+                    case 4:\n+                        event.setDeviceEventClassId(headerFields.get(4));\n+                        ingestDocument.setFieldValue(\"event.code\", headerFields.get(4));\n+                        break;\n+                    case 5:\n+                        event.setName(headerFields.get(5));\n+                        break;\n+                    case 6:\n+                        event.setSeverity(headerFields.get(6));\n+                        break;\n+                }\n+            }\n+            String extensionString = cefString.substring(extensionStart);\n+            Map<String, String> extensions = parseExtensions(extensionString);\n+\n+            if (removeEmptyValue) {\n+                removeEmptyValue(extensions);\n+            }\n+            event.setExtensions(extensions);\n+\n+            // Translate possible ECS fields and remove them from extensions\n+            Map<String, Object> translatedFields = extensions.entrySet()\n+                .stream()\n+                .filter(entry -> FIELD_MAPPING.containsKey(entry.getKey()))\n+                .collect(Collectors.toMap(entry -> FIELD_MAPPING.get(entry.getKey()), entry -> {\n+                    Class<?> fieldType = ECSFieldWithType.getFieldType(FIELD_MAPPING.get(entry.getKey()));\n+                    return convertValueToType(entry.getValue(), fieldType);\n+                }));\n+\n+            // Remove the translated entries from extensions\n+            event.removeMappedExtensions();\n+\n+            ingestDocument.setFieldValue(targetField, event.toObject());\n+            // Add ECS translations to the root of the document\n+            if (translatedFields.isEmpty() == false) {\n+                translatedFields.forEach(ingestDocument::setFieldValue);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid CEF format\");\n+        }\n+    }\n+\n+    private Object convertValueToType(String value, Class<?> type) {\n+        if (type == Long.class) {\n+            return Long.parseLong(value);\n+        } else if (type == Double.class) {\n+            return Double.parseDouble(value);\n+        } else if (type == Integer.class) {\n+            return Integer.parseInt(value);\n+        } else {\n+            return value; // Default to String\n+        }\n+    }\n+\n+    private Map<String, String> parseExtensions(String extensionString) {\n+        Map<String, String> extensions = new HashMap<>();\n+        Matcher matcher = EXTENSION_NEXT_KEY_VALUE_PATTERN.matcher(extensionString);\n+        int lastEnd = 0;\n+        while (matcher.find()) {\n+            String key = matcher.group(1);\n+            String value = matcher.group(2);\n+\n+            // Convert extension field name to strict legal field_reference\n+            if (key.endsWith(\"]\")) {\n+                key = convertArrayLikeKey(key);\n+            }\n+\n+            extensions.put(key, desanitizeExtensionVal(value.trim()));\n+            lastEnd = matcher.end();\n+        }\n+        // If there's any remaining unparsed content, throw an exception\n+        if (lastEnd < extensionString.length()) {\n+            throw new IllegalArgumentException(\"Invalid extensions; keyless value present: \" + extensionString.substring(lastEnd));\n+        }\n+        return extensions;\n+    }\n+\n+    private void removeEmptyValue(Map<String, String> map) {\n+        map.entrySet().removeIf(entry -> entry.getValue().isEmpty());\n+        map.entrySet().removeIf(entry -> entry.getValue() == null);\n+    }\n+\n+    private String convertArrayLikeKey(String key) {\n+        Matcher matcher = EXTENSION_KEY_ARRAY_CAPTURE.matcher(key);\n+        if (matcher.matches()) {\n+            return \"[\" + matcher.group(1) + \"]\" + matcher.group(2);\n+        }\n+        return key;\n+    }\n+\n+    public static String desanitizeExtensionVal(String value) {\n+        String desanitized = value;\n+        for (Map.Entry<String, String> entry : EXTENSION_VALUE_SANITIZER_REVERSE_MAPPING.entrySet()) {\n+            desanitized = desanitized.replace(entry.getKey(), entry.getValue());\n+        }\n+        return desanitized;\n+    }\n+\n+    public static class CEFEvent {\n+        private String version;\n+        private String deviceVendor;\n+        private String deviceProduct;\n+        private String deviceVersion;\n+        private String deviceEventClassId;\n+        private String name;\n+        private String severity;\n+        private final Map<String, String> extensions = new HashMap<>();\n+        private Map<String, String> translatedFields;\n+\n+        // Getters and setters for all fields\n+        public String getVersion() {\n+            return version;\n+        }\n+\n+        public void setVersion(String version) {\n+            this.version = version;\n+        }\n+\n+        public String getDeviceVendor() {\n+            return deviceVendor;\n+        }\n+\n+        public void setDeviceVendor(String deviceVendor) {\n+            this.deviceVendor = deviceVendor;\n+        }\n+\n+        public String getDeviceProduct() {\n+            return deviceProduct;\n+        }\n+\n+        public void setDeviceProduct(String deviceProduct) {\n+            this.deviceProduct = deviceProduct;\n+        }\n+\n+        public String getDeviceVersion() {\n+            return deviceVersion;\n+        }\n+\n+        public void setDeviceVersion(String deviceVersion) {\n+            this.deviceVersion = deviceVersion;\n+        }\n+\n+        public String getDeviceEventClassId() {\n+            return deviceEventClassId;\n+        }\n+\n+        public void setDeviceEventClassId(String deviceEventClassId) {\n+            this.deviceEventClassId = deviceEventClassId;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public void setName(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getSeverity() {\n+            return severity;\n+        }\n+\n+        public void setSeverity(String severity) {\n+            this.severity = severity;\n+        }\n+\n+        public Map<String, String> getExtensions() {\n+            return extensions;\n+        }\n+\n+        public void setExtensions(Map<String, String> extensions) {\n+            this.extensions.putAll(extensions);\n+        }\n+\n+        public void addExtension(String key, String extension) {\n+            this.extensions.put(key, extension);\n+        }\n+\n+        public void removeMappedExtensions() {\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsKey(entry.getKey()));\n+            this.extensions.entrySet().removeIf(entry -> FIELD_MAPPING.containsValue(entry.getKey()));",
        "comment_created_at": "2025-03-27T14:48:18+00:00",
        "comment_author": "joegallo",
        "comment_body": "This looks right to me now, but I moved the location of the definition of the static set.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2018560953",
    "pr_number": 122491,
    "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
    "created_at": "2025-03-28T12:20:15+00:00",
    "commented_code": "}\n\n        // Translate extensions to possible ECS fields\n        Map<String, Object> translatedFields = extensions.entrySet()\n            .stream()\n            .filter(entry -> FIELD_MAPPINGS.containsKey(entry.getKey()))\n            .collect(Collectors.toMap(entry -> FIELD_MAPPINGS.get(entry.getKey()), entry -> {\n                DataType fieldType = FIELDS.get(FIELD_MAPPINGS.get(entry.getKey()));\n                return convertValueToType(entry.getValue(), fieldType);\n            }));\n        Map<String, Object> translatedFields = new HashMap<>();",
    "repo_full_name": "elastic/elasticsearch",
    "discussion_comments": [
      {
        "comment_id": "2018560953",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2018560953",
        "commented_code": "@@ -348,13 +347,15 @@ private void processExtensions(String cefString, int extensionStart, CEFEvent ev\n         }\n \n         // Translate extensions to possible ECS fields\n-        Map<String, Object> translatedFields = extensions.entrySet()\n-            .stream()\n-            .filter(entry -> FIELD_MAPPINGS.containsKey(entry.getKey()))\n-            .collect(Collectors.toMap(entry -> FIELD_MAPPINGS.get(entry.getKey()), entry -> {\n-                DataType fieldType = FIELDS.get(FIELD_MAPPINGS.get(entry.getKey()));\n-                return convertValueToType(entry.getValue(), fieldType);\n-            }));\n+        Map<String, Object> translatedFields = new HashMap<>();",
        "comment_created_at": "2025-03-28T12:20:15+00:00",
        "comment_author": "joegallo",
        "comment_body": "Do you think it's worth pre-sizing this `HashMap` (via `HashMap.newHashMap`) to match the size of the `extensions`? By my read that would slightly oversize the map, but with the effect that you'd never need to resize. I imagine it's worth it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2019736523",
        "repo_full_name": "elastic/elasticsearch",
        "pr_number": 122491,
        "pr_file": "modules/ingest-common/src/main/java/org/elasticsearch/ingest/common/CefParser.java",
        "discussion_id": "2018560953",
        "commented_code": "@@ -348,13 +347,15 @@ private void processExtensions(String cefString, int extensionStart, CEFEvent ev\n         }\n \n         // Translate extensions to possible ECS fields\n-        Map<String, Object> translatedFields = extensions.entrySet()\n-            .stream()\n-            .filter(entry -> FIELD_MAPPINGS.containsKey(entry.getKey()))\n-            .collect(Collectors.toMap(entry -> FIELD_MAPPINGS.get(entry.getKey()), entry -> {\n-                DataType fieldType = FIELDS.get(FIELD_MAPPINGS.get(entry.getKey()));\n-                return convertValueToType(entry.getValue(), fieldType);\n-            }));\n+        Map<String, Object> translatedFields = new HashMap<>();",
        "comment_created_at": "2025-03-29T06:40:34+00:00",
        "comment_author": "bhapas",
        "comment_body": "Removing all intermediate collections. Adding the mapping to event as we parse.",
        "pr_file_module": null
      }
    ]
  }
]
