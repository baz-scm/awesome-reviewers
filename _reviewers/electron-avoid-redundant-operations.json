[
  {
    "discussion_id": "2205058935",
    "pr_number": 47740,
    "pr_file": "shell/browser/native_window_views.cc",
    "created_at": "2025-07-14T14:15:36+00:00",
    "commented_code": "NativeWindow::NotifyWindowBlur();\n   }\n \n+#if BUILDFLAG(IS_WIN)\n+  // Update accent color based on activation state when no explicit color is\n+  // set.\n+  UpdateWindowAccentColor();",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2205058935",
        "repo_full_name": "electron/electron",
        "pr_number": 47740,
        "pr_file": "shell/browser/native_window_views.cc",
        "discussion_id": "2205058935",
        "commented_code": "@@ -1732,6 +1732,12 @@ void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,\n     NativeWindow::NotifyWindowBlur();\n   }\n \n+#if BUILDFLAG(IS_WIN)\n+  // Update accent color based on activation state when no explicit color is\n+  // set.\n+  UpdateWindowAccentColor();",
        "comment_created_at": "2025-07-14T14:15:36+00:00",
        "comment_author": "deepak1556",
        "comment_body": "Could pass the active state to avoid the extra `IsActive` call in `UpdateWindowAccentColor` given `OnWidgetActivationChanged` fires for window startup phase as well ?\r\n\r\n```suggestion\r\n  UpdateWindowAccentColor(active);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2205067603",
        "repo_full_name": "electron/electron",
        "pr_number": 47740,
        "pr_file": "shell/browser/native_window_views.cc",
        "discussion_id": "2205058935",
        "commented_code": "@@ -1732,6 +1732,12 @@ void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,\n     NativeWindow::NotifyWindowBlur();\n   }\n \n+#if BUILDFLAG(IS_WIN)\n+  // Update accent color based on activation state when no explicit color is\n+  // set.\n+  UpdateWindowAccentColor();",
        "comment_created_at": "2025-07-14T14:19:24+00:00",
        "comment_author": "codebytere",
        "comment_body": "ah ok - did you envision we just pass `IsActive` in the other spots?",
        "pr_file_module": null
      },
      {
        "comment_id": "2205076915",
        "repo_full_name": "electron/electron",
        "pr_number": 47740,
        "pr_file": "shell/browser/native_window_views.cc",
        "discussion_id": "2205058935",
        "commented_code": "@@ -1732,6 +1732,12 @@ void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,\n     NativeWindow::NotifyWindowBlur();\n   }\n \n+#if BUILDFLAG(IS_WIN)\n+  // Update accent color based on activation state when no explicit color is\n+  // set.\n+  UpdateWindowAccentColor();",
        "comment_created_at": "2025-07-14T14:23:29+00:00",
        "comment_author": "deepak1556",
        "comment_body": "The only other callsite I see is https://github.com/electron/electron/blob/9f3636ffe21cde2fcdb9aaee9d592d957e744b1c/shell/browser/native_window_views.cc#L424 ? This leads me to a follow-up question, with the call happening in `OnWidgetActivationChanged` do we need the former,  IIRC `OnWidgetActivationChanged` gets called for every window on startup ? If this is not the case, then I am good with the current implementation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2205082602",
        "repo_full_name": "electron/electron",
        "pr_number": 47740,
        "pr_file": "shell/browser/native_window_views.cc",
        "discussion_id": "2205058935",
        "commented_code": "@@ -1732,6 +1732,12 @@ void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,\n     NativeWindow::NotifyWindowBlur();\n   }\n \n+#if BUILDFLAG(IS_WIN)\n+  // Update accent color based on activation state when no explicit color is\n+  // set.\n+  UpdateWindowAccentColor();",
        "comment_created_at": "2025-07-14T14:25:39+00:00",
        "comment_author": "codebytere",
        "comment_body": "@deepak1556 there are four callsites total - we need to account for any time the accent color changes",
        "pr_file_module": null
      },
      {
        "comment_id": "2205109114",
        "repo_full_name": "electron/electron",
        "pr_number": 47740,
        "pr_file": "shell/browser/native_window_views.cc",
        "discussion_id": "2205058935",
        "commented_code": "@@ -1732,6 +1732,12 @@ void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,\n     NativeWindow::NotifyWindowBlur();\n   }\n \n+#if BUILDFLAG(IS_WIN)\n+  // Update accent color based on activation state when no explicit color is\n+  // set.\n+  UpdateWindowAccentColor();",
        "comment_created_at": "2025-07-14T14:37:33+00:00",
        "comment_author": "deepak1556",
        "comment_body": "Yes those should have `IsAccent` check but is the initial call on window construction needed with `OnWidgetActivationChanged` handling it now https://source.chromium.org/chromium/chromium/src/+/main:ui/views/win/hwnd_message_handler.cc;l=1146-1149 ? Just want to make sure we don't perform duplicate calls on window creation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2209928404",
        "repo_full_name": "electron/electron",
        "pr_number": 47740,
        "pr_file": "shell/browser/native_window_views.cc",
        "discussion_id": "2205058935",
        "commented_code": "@@ -1732,6 +1732,12 @@ void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,\n     NativeWindow::NotifyWindowBlur();\n   }\n \n+#if BUILDFLAG(IS_WIN)\n+  // Update accent color based on activation state when no explicit color is\n+  // set.\n+  UpdateWindowAccentColor();",
        "comment_created_at": "2025-07-16T10:28:43+00:00",
        "comment_author": "codebytere",
        "comment_body": "@deepak1556 just verified and you're correct - i've removed the window creation call!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169954566",
    "pr_number": 47425,
    "pr_file": "shell/browser/api/electron_api_base_window.cc",
    "created_at": "2025-06-26T20:34:22+00:00",
    "commented_code": "}\n \n void BaseWindow::OnWindowResize() {\n+  window_->SaveWindowState();",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2169954566",
        "repo_full_name": "electron/electron",
        "pr_number": 47425,
        "pr_file": "shell/browser/api/electron_api_base_window.cc",
        "discussion_id": "2169954566",
        "commented_code": "@@ -267,6 +267,7 @@ void BaseWindow::OnWindowWillResize(const gfx::Rect& new_bounds,\n }\n \n void BaseWindow::OnWindowResize() {\n+  window_->SaveWindowState();",
        "comment_created_at": "2025-06-26T20:34:22+00:00",
        "comment_author": "georgexu99",
        "comment_body": "Question: can this lead to redundant writes if the window is rapidly resized/ moved? applies to the onwindowmove event as well.\r\n\r\nFor example, if I am playing with the window position/size and spam changes, will this affect performance?",
        "pr_file_module": null
      },
      {
        "comment_id": "2169955255",
        "repo_full_name": "electron/electron",
        "pr_number": 47425,
        "pr_file": "shell/browser/api/electron_api_base_window.cc",
        "discussion_id": "2169954566",
        "commented_code": "@@ -267,6 +267,7 @@ void BaseWindow::OnWindowWillResize(const gfx::Rect& new_bounds,\n }\n \n void BaseWindow::OnWindowResize() {\n+  window_->SaveWindowState();",
        "comment_created_at": "2025-06-26T20:34:49+00:00",
        "comment_author": "georgexu99",
        "comment_body": "What if we added a debounce? ie. max once per second",
        "pr_file_module": null
      },
      {
        "comment_id": "2170129443",
        "repo_full_name": "electron/electron",
        "pr_number": 47425,
        "pr_file": "shell/browser/api/electron_api_base_window.cc",
        "discussion_id": "2169954566",
        "commented_code": "@@ -267,6 +267,7 @@ void BaseWindow::OnWindowWillResize(const gfx::Rect& new_bounds,\n }\n \n void BaseWindow::OnWindowResize() {\n+  window_->SaveWindowState();",
        "comment_created_at": "2025-06-26T22:13:59+00:00",
        "comment_author": "nilayarya",
        "comment_body": "> Question: can this lead to redundant writes if the window is rapidly resized/ moved? applies to the onwindowmove event as well.\r\n\r\nI don't think we can have back to back redundant `saveWindowState` calls for any set of [x, y, height, width] even when the window is rapidly resized/moved because 'resize' and 'move' fire on every pixel change\r\n\r\n> For example, if I am playing with the window position/size and spam changes, will this affect performance?\r\n\r\nFrom what I know about C++ a few thousand extra calls to `saveWindowState` should add a few extra hundred micro seconds \ud83d\ude1b. Not sure if that's the case here, but it would be technically correct to debounce `saveWindowState` and avoid those extra calls. Should I go ahead with that?\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2065319889",
    "pr_number": 46849,
    "pr_file": "shell/browser/native_window.cc",
    "created_at": "2025-04-29T02:58:10+00:00",
    "commented_code": "return accessible_title_;\n }\n \n+std::string NativeWindow::GetTitle() const {\n+  return base::UTF16ToUTF8(WidgetDelegate::GetWindowTitle());\n+}\n+\n+void NativeWindow::SetTitle(const std::string_view title) {\n+  if (title == GetTitle())\n+    return;",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2065319889",
        "repo_full_name": "electron/electron",
        "pr_number": 46849,
        "pr_file": "shell/browser/native_window.cc",
        "discussion_id": "2065319889",
        "commented_code": "@@ -804,6 +804,18 @@ std::u16string NativeWindow::GetAccessibleWindowTitle() const {\n   return accessible_title_;\n }\n \n+std::string NativeWindow::GetTitle() const {\n+  return base::UTF16ToUTF8(WidgetDelegate::GetWindowTitle());\n+}\n+\n+void NativeWindow::SetTitle(const std::string_view title) {\n+  if (title == GetTitle())\n+    return;",
        "comment_created_at": "2025-04-29T02:58:10+00:00",
        "comment_author": "deepak1556",
        "comment_body": "redundant https://source.chromium.org/chromium/chromium/src/+/main:ui/views/widget/widget_delegate.cc;l=496-499 ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2065331679",
        "repo_full_name": "electron/electron",
        "pr_number": 46849,
        "pr_file": "shell/browser/native_window.cc",
        "discussion_id": "2065319889",
        "commented_code": "@@ -804,6 +804,18 @@ std::u16string NativeWindow::GetAccessibleWindowTitle() const {\n   return accessible_title_;\n }\n \n+std::string NativeWindow::GetTitle() const {\n+  return base::UTF16ToUTF8(WidgetDelegate::GetWindowTitle());\n+}\n+\n+void NativeWindow::SetTitle(const std::string_view title) {\n+  if (title == GetTitle())\n+    return;",
        "comment_created_at": "2025-04-29T03:13:10+00:00",
        "comment_author": "ckerr",
        "comment_body": "It's there to prevent `NativeWindow::OnTitleChanged()` from being called on line 816  if the title is unchanged.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1973833219",
    "pr_number": 45310,
    "pr_file": "shell/common/platform_util_linux.cc",
    "created_at": "2025-02-27T15:32:02+00:00",
    "commented_code": "base::nix::CreateLaunchOptionsWithXdgActivation(base::BindOnce(\n         [](base::RepeatingClosure quit_loop, base::LaunchOptions* options_out,\n            base::LaunchOptions options) {\n+          // Correct the XDG_CURRENT_DESKTOP environment variable before calling\n+          // XDG, in case it was changed for compatibility.\n+          if (options.environment.find(kOriginalXdgCurrentDesktopEnvVar) !=\n+              options.environment.end()) {\n+            options.environment[kXdgCurrentDesktopEnvVar] =\n+                options.environment[kOriginalXdgCurrentDesktopEnvVar];\n+          }",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1973833219",
        "repo_full_name": "electron/electron",
        "pr_number": 45310,
        "pr_file": "shell/common/platform_util_linux.cc",
        "discussion_id": "1973833219",
        "commented_code": "@@ -282,6 +285,13 @@ bool XDGUtil(const std::vector<std::string>& argv,\n     base::nix::CreateLaunchOptionsWithXdgActivation(base::BindOnce(\n         [](base::RepeatingClosure quit_loop, base::LaunchOptions* options_out,\n            base::LaunchOptions options) {\n+          // Correct the XDG_CURRENT_DESKTOP environment variable before calling\n+          // XDG, in case it was changed for compatibility.\n+          if (options.environment.find(kOriginalXdgCurrentDesktopEnvVar) !=\n+              options.environment.end()) {\n+            options.environment[kXdgCurrentDesktopEnvVar] =\n+                options.environment[kOriginalXdgCurrentDesktopEnvVar];\n+          }",
        "comment_created_at": "2025-02-27T15:32:02+00:00",
        "comment_author": "ckerr",
        "comment_body": "Concept LGTM.\r\n\r\nOne impl suggestion -- we can avoid that second map lookup on line 293 by holding onto the return value of the `find()` call on 290. Chromium has a helper convenience function for this, [`base::FindOrNull()`](https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/containers/map_util.h#24):\r\n\r\n```c++\r\n// Correct the XDG_CURRENT_DESKTOP environment variable before calling\r\n// XDG, in case it was changed for compatibility.\r\nif (const auto* orig = base::FindOrNull(\r\n        options.environment, kOriginalXdgCurrentDesktopEnvVar))\r\n  options.environment.emplace(kXdgCurrentDesktopEnvVar, *orig);\r\n```\r\n\r\nYou'll need to `#include` the header for this at the top of the file:\r\n\r\n```diff\r\n #include \"base/cancelable_callback.h\"\r\n #include \"base/containers/contains.h\"\r\n+#include \"base/containers/map_util.h\"\r\n #include \"base/environment.h\"\r\n #include \"base/files/file_util.h\"\r\n #include \"base/files/scoped_file.h\"\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1976522461",
        "repo_full_name": "electron/electron",
        "pr_number": 45310,
        "pr_file": "shell/common/platform_util_linux.cc",
        "discussion_id": "1973833219",
        "commented_code": "@@ -282,6 +285,13 @@ bool XDGUtil(const std::vector<std::string>& argv,\n     base::nix::CreateLaunchOptionsWithXdgActivation(base::BindOnce(\n         [](base::RepeatingClosure quit_loop, base::LaunchOptions* options_out,\n            base::LaunchOptions options) {\n+          // Correct the XDG_CURRENT_DESKTOP environment variable before calling\n+          // XDG, in case it was changed for compatibility.\n+          if (options.environment.find(kOriginalXdgCurrentDesktopEnvVar) !=\n+              options.environment.end()) {\n+            options.environment[kXdgCurrentDesktopEnvVar] =\n+                options.environment[kOriginalXdgCurrentDesktopEnvVar];\n+          }",
        "comment_created_at": "2025-03-02T01:48:31+00:00",
        "comment_author": "esimkowitz",
        "comment_body": "applied your suggestion, thanks for the tip!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2012428137",
    "pr_number": 46253,
    "pr_file": "shell/renderer/api/electron_api_context_bridge.cc",
    "created_at": "2025-03-25T15:55:38+00:00",
    "commented_code": "return v8::MaybeLocal<v8::Value>(\n           blob.ToV8Value(destination_context->GetIsolate()));\n     }\n+\n+    // Custom logic to \"clone\" FileList references\n+    auto object_value = value.As<v8::Object>();\n+    v8::Maybe<bool> has_length = object_value->Has(\n+        source_context,\n+        gin::StringToV8(source_context->GetIsolate(), \"length\"));\n+    v8::Maybe<bool> has_item = object_value->Has(\n+        source_context, gin::StringToV8(source_context->GetIsolate(), \"item\"));",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2012428137",
        "repo_full_name": "electron/electron",
        "pr_number": 46253,
        "pr_file": "shell/renderer/api/electron_api_context_bridge.cc",
        "discussion_id": "2012428137",
        "commented_code": "@@ -417,6 +417,50 @@ v8::MaybeLocal<v8::Value> PassValueToOtherContextInner(\n       return v8::MaybeLocal<v8::Value>(\n           blob.ToV8Value(destination_context->GetIsolate()));\n     }\n+\n+    // Custom logic to \"clone\" FileList references\n+    auto object_value = value.As<v8::Object>();\n+    v8::Maybe<bool> has_length = object_value->Has(\n+        source_context,\n+        gin::StringToV8(source_context->GetIsolate(), \"length\"));\n+    v8::Maybe<bool> has_item = object_value->Has(\n+        source_context, gin::StringToV8(source_context->GetIsolate(), \"item\"));",
        "comment_created_at": "2025-03-25T15:55:38+00:00",
        "comment_author": "ckerr",
        "comment_body": "- When you've got a string literal, `v8::String::NewFromUtf8Literal()` is fastest\r\n- We v8ize these two keys twice, but only need to do it once.\r\n\r\n```suggestion\r\n\r\n    const v8::Local<v8::String> length_key =\r\n        v8::String::NewFromUtf8Literal(source_context->GetIsolate(), \"length\");\r\n    const v8::Local<v8::String> item_key =\r\n        v8::String::NewFromUtf8Literal(source_context->GetIsolate(), \"item\");\r\n\r\n    v8::Maybe<bool> has_length = object_value->Has(source_context, length_key);\r\n    v8::Maybe<bool> has_item = object_value->Has(source_context, item_key);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2009567085",
    "pr_number": 46100,
    "pr_file": "patches/node/fix_ensure_traverseparent_bails_on_resource_path_exit.patch",
    "created_at": "2025-03-24T07:04:22+00:00",
    "commented_code": "+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Shelley Vohr <shelley.vohr@gmail.com>\n+Date: Tue, 18 Mar 2025 10:41:27 +0100\n+Subject: fix: ensure TraverseParent bails on resource path exit\n+\n+Electron's security model requires that we do not traverse outside of the\n+resource path. This commit ensures that the TraverseParent function\n+bails out if the parent path is outside of the resource path.\n+\n+diff --git a/src/node_modules.cc b/src/node_modules.cc\n+index 210a01d24e11764dc9fc37a77b354f11383693f8..4e9f70a1c41b44d2a1863b778d4f1e37279178d9 100644\n+--- a/src/node_modules.cc\n++++ b/src/node_modules.cc\n+@@ -290,8 +290,41 @@ const BindingData::PackageConfig* BindingData::TraverseParent(\n+     Realm* realm, const std::filesystem::path& check_path) {\n+   std::filesystem::path current_path = check_path;\n+   auto env = realm->env();\n++  Isolate* isolate = env->isolate();\n+   const bool is_permissions_enabled = env->permission()->enabled();\n+ \n++  // Get the resources path with trailing slash.\n++  std::string resources_path;",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2009567085",
        "repo_full_name": "electron/electron",
        "pr_number": 46100,
        "pr_file": "patches/node/fix_ensure_traverseparent_bails_on_resource_path_exit.patch",
        "discussion_id": "2009567085",
        "commented_code": "@@ -0,0 +1,68 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Shelley Vohr <shelley.vohr@gmail.com>\n+Date: Tue, 18 Mar 2025 10:41:27 +0100\n+Subject: fix: ensure TraverseParent bails on resource path exit\n+\n+Electron's security model requires that we do not traverse outside of the\n+resource path. This commit ensures that the TraverseParent function\n+bails out if the parent path is outside of the resource path.\n+\n+diff --git a/src/node_modules.cc b/src/node_modules.cc\n+index 210a01d24e11764dc9fc37a77b354f11383693f8..4e9f70a1c41b44d2a1863b778d4f1e37279178d9 100644\n+--- a/src/node_modules.cc\n++++ b/src/node_modules.cc\n+@@ -290,8 +290,41 @@ const BindingData::PackageConfig* BindingData::TraverseParent(\n+     Realm* realm, const std::filesystem::path& check_path) {\n+   std::filesystem::path current_path = check_path;\n+   auto env = realm->env();\n++  Isolate* isolate = env->isolate();\n+   const bool is_permissions_enabled = env->permission()->enabled();\n+ \n++  // Get the resources path with trailing slash.\n++  std::string resources_path;",
        "comment_created_at": "2025-03-24T07:04:22+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "non-blocking-fast-follow: This is susceptible to userland modification of `resourcesPath`, unlike the impl in `node/init.ts` which captures the value before userland code runs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2009567704",
        "repo_full_name": "electron/electron",
        "pr_number": 46100,
        "pr_file": "patches/node/fix_ensure_traverseparent_bails_on_resource_path_exit.patch",
        "discussion_id": "2009567085",
        "commented_code": "@@ -0,0 +1,68 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Shelley Vohr <shelley.vohr@gmail.com>\n+Date: Tue, 18 Mar 2025 10:41:27 +0100\n+Subject: fix: ensure TraverseParent bails on resource path exit\n+\n+Electron's security model requires that we do not traverse outside of the\n+resource path. This commit ensures that the TraverseParent function\n+bails out if the parent path is outside of the resource path.\n+\n+diff --git a/src/node_modules.cc b/src/node_modules.cc\n+index 210a01d24e11764dc9fc37a77b354f11383693f8..4e9f70a1c41b44d2a1863b778d4f1e37279178d9 100644\n+--- a/src/node_modules.cc\n++++ b/src/node_modules.cc\n+@@ -290,8 +290,41 @@ const BindingData::PackageConfig* BindingData::TraverseParent(\n+     Realm* realm, const std::filesystem::path& check_path) {\n+   std::filesystem::path current_path = check_path;\n+   auto env = realm->env();\n++  Isolate* isolate = env->isolate();\n+   const bool is_permissions_enabled = env->permission()->enabled();\n+ \n++  // Get the resources path with trailing slash.\n++  std::string resources_path;",
        "comment_created_at": "2025-03-24T07:05:01+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "non-blocking: this also has a perf hit during module loading as we're reading this on every module load, we should be able to cache this in a `base::NoDestructor<std::string>` or something for future use",
        "pr_file_module": null
      }
    ]
  }
]