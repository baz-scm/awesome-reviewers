[
  {
    "discussion_id": "2209370679",
    "pr_number": 47386,
    "pr_file": "shell/browser/api/electron_api_browser_window.cc",
    "created_at": "2025-07-16T06:19:40+00:00",
    "commented_code": "}\n }\n \n+void BrowserWindow::SetBackgroundMaterial(const std::string& material) {\n+  BaseWindow::SetBackgroundMaterial(material);\n+  const char* const materialTypes[] = {\n+      \"tabbed\",\n+      \"mica\",\n+      \"acrylic\",\n+  };",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2209370679",
        "repo_full_name": "electron/electron",
        "pr_number": 47386,
        "pr_file": "shell/browser/api/electron_api_browser_window.cc",
        "discussion_id": "2209370679",
        "commented_code": "@@ -247,6 +247,21 @@ void BrowserWindow::SetBackgroundColor(const std::string& color_name) {\n   }\n }\n \n+void BrowserWindow::SetBackgroundMaterial(const std::string& material) {\n+  BaseWindow::SetBackgroundMaterial(material);\n+  const char* const materialTypes[] = {\n+      \"tabbed\",\n+      \"mica\",\n+      \"acrylic\",\n+  };",
        "comment_created_at": "2025-07-16T06:19:40+00:00",
        "comment_author": "deepak1556",
        "comment_body": "```suggestion\n  static constexpr auto materialTypes = base::MakeFixedFlatSet<std::string_view>(\n        {\"tabbed\", \"mica\", \"acrylic\"});\n  if (materialTypes.contains(material)) {\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2206988147",
    "pr_number": 47741,
    "pr_file": "shell/browser/native_window_views_win.cc",
    "created_at": "2025-07-15T09:36:06+00:00",
    "commented_code": "SetWindowBorderAndCaptionColor(GetAcceleratedWidget(), final_color);\n }\n \n+void NativeWindowViews::SetAccentColor(\n+    std::variant<bool, std::string> accent_color) {\n+  if (std::holds_alternative<std::string>(accent_color)) {\n+    std::optional<SkColor> maybe_color =\n+        ParseCSSColor(std::get<std::string>(accent_color));\n+    if (maybe_color.has_value())\n+      accent_color_ = maybe_color.value();\n+  } else if (std::holds_alternative<bool>(accent_color)) {\n+    accent_color_ = std::get<bool>(accent_color);\n+  }",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2206988147",
        "repo_full_name": "electron/electron",
        "pr_number": 47741,
        "pr_file": "shell/browser/native_window_views_win.cc",
        "discussion_id": "2206988147",
        "commented_code": "@@ -606,6 +593,51 @@ void NativeWindowViews::UpdateWindowAccentColor() {\n   SetWindowBorderAndCaptionColor(GetAcceleratedWidget(), final_color);\n }\n \n+void NativeWindowViews::SetAccentColor(\n+    std::variant<bool, std::string> accent_color) {\n+  if (std::holds_alternative<std::string>(accent_color)) {\n+    std::optional<SkColor> maybe_color =\n+        ParseCSSColor(std::get<std::string>(accent_color));\n+    if (maybe_color.has_value())\n+      accent_color_ = maybe_color.value();\n+  } else if (std::holds_alternative<bool>(accent_color)) {\n+    accent_color_ = std::get<bool>(accent_color);\n+  }",
        "comment_created_at": "2025-07-15T09:36:06+00:00",
        "comment_author": "deepak1556",
        "comment_body": "`BaseWindow::SetAccentColor` already knows the type at runtime if this logic is moved into it then we can save another round of type inference that is happening here. Feels indirect that we pass accent_color variant from api layer just to reparse into a different variant accent_color_. Thoughts ?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1722423308",
    "pr_number": 42953,
    "pr_file": "shell/common/gin_converters/osr_converter.cc",
    "created_at": "2024-08-19T22:13:28+00:00",
    "commented_code": "+\ufeff\n+// Copyright (c) 2024 GitHub, Inc.\n+// Use of this source code is governed by the MIT license that can be found in\n+// the LICENSE file.\n+\n+#include \"shell/common/gin_converters/osr_converter.h\"\n+\n+#include \"gin/dictionary.h\"\n+#include \"v8-external.h\"\n+#include \"v8-function.h\"\n+\n+#include <string>\n+\n+#include \"shell/common/gin_converters/gfx_converter.h\"\n+#include \"shell/common/gin_converters/optional_converter.h\"\n+#include \"shell/common/node_includes.h\"\n+#include \"shell/common/process_util.h\"\n+\n+namespace gin {\n+\n+namespace {\n+std::string OsrVideoPixelFormatToString(media::VideoPixelFormat format) {\n+  switch (format) {\n+    case media::PIXEL_FORMAT_ARGB:\n+      return \"bgra\";\n+    case media::PIXEL_FORMAT_ABGR:\n+      return \"rgba\";\n+    default:\n+      NOTREACHED_NORETURN();\n+  }\n+}\n+\n+std::string OsrWidgetTypeToString(content::WidgetType type) {\n+  switch (type) {\n+    case content::WidgetType::kPopup:\n+      return \"popup\";\n+    case content::WidgetType::kFrame:\n+      return \"frame\";\n+    default:\n+      NOTREACHED_NORETURN();\n+  }\n+}\n+\n+struct OffscreenReleaseHolderMonitor {\n+  explicit OffscreenReleaseHolderMonitor(\n+      electron::OffscreenReleaserHolder* holder)\n+      : holder_(holder) {\n+    CHECK(holder);\n+  }\n+\n+  void ReleaseTexture() {\n+    delete holder_;\n+    holder_ = nullptr;\n+  }\n+\n+  bool IsTextureReleased() const { return holder_ == nullptr; }\n+\n+  v8::Persistent<v8::Value>* CreatePersistent(v8::Isolate* isolate,\n+                                              v8::Local<v8::Value> value) {\n+    persistent_ = std::make_unique<v8::Persistent<v8::Value>>(isolate, value);\n+    return persistent_.get();\n+  }\n+\n+  void ResetPersistent() const { persistent_->Reset(); }\n+\n+ private:\n+  raw_ptr<electron::OffscreenReleaserHolder> holder_;\n+  std::unique_ptr<v8::Persistent<v8::Value>> persistent_;\n+};\n+\n+}  // namespace\n+\n+// static\n+v8::Local<v8::Value> Converter<electron::OffscreenSharedTextureValue>::ToV8(\n+    v8::Isolate* isolate,\n+    const electron::OffscreenSharedTextureValue& val) {\n+  gin::Dictionary root(isolate, v8::Object::New(isolate));\n+\n+  // Create a monitor to hold the releaser holder, which enables us to\n+  // monitor whether the user explicitly released the texture before\n+  // GC collects the object.\n+  auto* monitor = new OffscreenReleaseHolderMonitor(val.releaser_holder);\n+\n+  auto releaserHolder = v8::External::New(isolate, monitor);\n+  auto releaserFunc = [](const v8::FunctionCallbackInfo<v8::Value>& info) {\n+    auto* holder = static_cast<OffscreenReleaseHolderMonitor*>(\n+        info.Data().As<v8::External>()->Value());\n+    // Release the shared texture, so that future frames can be generated.\n+    holder->ReleaseTexture();\n+  };\n+  auto releaser = v8::Function::New(isolate->GetCurrentContext(), releaserFunc,\n+                                    releaserHolder)\n+                      .ToLocalChecked();\n+\n+  root.Set(\"release\", releaser);\n+\n+  gin::Dictionary dict(isolate, v8::Object::New(isolate));\n+  dict.Set(\"pixelFormat\", OsrVideoPixelFormatToString(val.pixel_format));\n+  dict.Set(\"codedSize\", val.coded_size);\n+  dict.Set(\"visibleRect\", val.visible_rect);\n+  dict.Set(\"contentRect\", val.content_rect);\n+  dict.Set(\"timestamp\", val.timestamp);\n+  dict.Set(\"widgetType\", OsrWidgetTypeToString(val.widget_type));\n+\n+  gin::Dictionary metadata(isolate, v8::Object::New(isolate));\n+  metadata.Set(\"captureUpdateRect\", val.capture_update_rect);\n+  metadata.Set(\"regionCaptureRect\", val.region_capture_rect);\n+  metadata.Set(\"sourceSize\", val.source_size);\n+  metadata.Set(\"frameCount\", val.frame_count);\n+  dict.Set(\"metadata\", ConvertToV8(isolate, metadata));\n+\n+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)\n+  auto handle_buf = node::Buffer::Copy(\n+      isolate,\n+      reinterpret_cast<char*>(\n+          const_cast<uintptr_t*>(&val.shared_texture_handle)),\n+      sizeof(val.shared_texture_handle));\n+  dict.Set(\"sharedTextureHandle\", handle_buf.ToLocalChecked());\n+#elif BUILDFLAG(IS_LINUX)\n+  std::vector<gin::Dictionary> v8_planes;\n+  for (size_t i = 0; i < val.planes.size(); ++i) {\n+    auto plane = val.planes[i];\n+    gin::Dictionary v8_plane(isolate, v8::Object::New(isolate));\n+    v8_plane.Set(\"stride\", plane.stride);\n+    v8_plane.Set(\"offset\", plane.offset);\n+    v8_plane.Set(\"size\", plane.size);\n+    v8_plane.Set(\"fd\", plane.fd);\n+    v8_planes.push_back(v8_plane);\n+  }",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1722423308",
        "repo_full_name": "electron/electron",
        "pr_number": 42953,
        "pr_file": "shell/common/gin_converters/osr_converter.cc",
        "discussion_id": "1722423308",
        "commented_code": "@@ -0,0 +1,177 @@\n+\ufeff\n+// Copyright (c) 2024 GitHub, Inc.\n+// Use of this source code is governed by the MIT license that can be found in\n+// the LICENSE file.\n+\n+#include \"shell/common/gin_converters/osr_converter.h\"\n+\n+#include \"gin/dictionary.h\"\n+#include \"v8-external.h\"\n+#include \"v8-function.h\"\n+\n+#include <string>\n+\n+#include \"shell/common/gin_converters/gfx_converter.h\"\n+#include \"shell/common/gin_converters/optional_converter.h\"\n+#include \"shell/common/node_includes.h\"\n+#include \"shell/common/process_util.h\"\n+\n+namespace gin {\n+\n+namespace {\n+std::string OsrVideoPixelFormatToString(media::VideoPixelFormat format) {\n+  switch (format) {\n+    case media::PIXEL_FORMAT_ARGB:\n+      return \"bgra\";\n+    case media::PIXEL_FORMAT_ABGR:\n+      return \"rgba\";\n+    default:\n+      NOTREACHED_NORETURN();\n+  }\n+}\n+\n+std::string OsrWidgetTypeToString(content::WidgetType type) {\n+  switch (type) {\n+    case content::WidgetType::kPopup:\n+      return \"popup\";\n+    case content::WidgetType::kFrame:\n+      return \"frame\";\n+    default:\n+      NOTREACHED_NORETURN();\n+  }\n+}\n+\n+struct OffscreenReleaseHolderMonitor {\n+  explicit OffscreenReleaseHolderMonitor(\n+      electron::OffscreenReleaserHolder* holder)\n+      : holder_(holder) {\n+    CHECK(holder);\n+  }\n+\n+  void ReleaseTexture() {\n+    delete holder_;\n+    holder_ = nullptr;\n+  }\n+\n+  bool IsTextureReleased() const { return holder_ == nullptr; }\n+\n+  v8::Persistent<v8::Value>* CreatePersistent(v8::Isolate* isolate,\n+                                              v8::Local<v8::Value> value) {\n+    persistent_ = std::make_unique<v8::Persistent<v8::Value>>(isolate, value);\n+    return persistent_.get();\n+  }\n+\n+  void ResetPersistent() const { persistent_->Reset(); }\n+\n+ private:\n+  raw_ptr<electron::OffscreenReleaserHolder> holder_;\n+  std::unique_ptr<v8::Persistent<v8::Value>> persistent_;\n+};\n+\n+}  // namespace\n+\n+// static\n+v8::Local<v8::Value> Converter<electron::OffscreenSharedTextureValue>::ToV8(\n+    v8::Isolate* isolate,\n+    const electron::OffscreenSharedTextureValue& val) {\n+  gin::Dictionary root(isolate, v8::Object::New(isolate));\n+\n+  // Create a monitor to hold the releaser holder, which enables us to\n+  // monitor whether the user explicitly released the texture before\n+  // GC collects the object.\n+  auto* monitor = new OffscreenReleaseHolderMonitor(val.releaser_holder);\n+\n+  auto releaserHolder = v8::External::New(isolate, monitor);\n+  auto releaserFunc = [](const v8::FunctionCallbackInfo<v8::Value>& info) {\n+    auto* holder = static_cast<OffscreenReleaseHolderMonitor*>(\n+        info.Data().As<v8::External>()->Value());\n+    // Release the shared texture, so that future frames can be generated.\n+    holder->ReleaseTexture();\n+  };\n+  auto releaser = v8::Function::New(isolate->GetCurrentContext(), releaserFunc,\n+                                    releaserHolder)\n+                      .ToLocalChecked();\n+\n+  root.Set(\"release\", releaser);\n+\n+  gin::Dictionary dict(isolate, v8::Object::New(isolate));\n+  dict.Set(\"pixelFormat\", OsrVideoPixelFormatToString(val.pixel_format));\n+  dict.Set(\"codedSize\", val.coded_size);\n+  dict.Set(\"visibleRect\", val.visible_rect);\n+  dict.Set(\"contentRect\", val.content_rect);\n+  dict.Set(\"timestamp\", val.timestamp);\n+  dict.Set(\"widgetType\", OsrWidgetTypeToString(val.widget_type));\n+\n+  gin::Dictionary metadata(isolate, v8::Object::New(isolate));\n+  metadata.Set(\"captureUpdateRect\", val.capture_update_rect);\n+  metadata.Set(\"regionCaptureRect\", val.region_capture_rect);\n+  metadata.Set(\"sourceSize\", val.source_size);\n+  metadata.Set(\"frameCount\", val.frame_count);\n+  dict.Set(\"metadata\", ConvertToV8(isolate, metadata));\n+\n+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)\n+  auto handle_buf = node::Buffer::Copy(\n+      isolate,\n+      reinterpret_cast<char*>(\n+          const_cast<uintptr_t*>(&val.shared_texture_handle)),\n+      sizeof(val.shared_texture_handle));\n+  dict.Set(\"sharedTextureHandle\", handle_buf.ToLocalChecked());\n+#elif BUILDFLAG(IS_LINUX)\n+  std::vector<gin::Dictionary> v8_planes;\n+  for (size_t i = 0; i < val.planes.size(); ++i) {\n+    auto plane = val.planes[i];\n+    gin::Dictionary v8_plane(isolate, v8::Object::New(isolate));\n+    v8_plane.Set(\"stride\", plane.stride);\n+    v8_plane.Set(\"offset\", plane.offset);\n+    v8_plane.Set(\"size\", plane.size);\n+    v8_plane.Set(\"fd\", plane.fd);\n+    v8_planes.push_back(v8_plane);\n+  }",
        "comment_created_at": "2024-08-19T22:13:28+00:00",
        "comment_author": "ckerr",
        "comment_body": "Looks like `plane` on 122 is an accidental copy rather than a reference. Maybe\r\n\r\n```c++\r\n  for (const auto& plane : val.planes) {\r\n```\r\n\r\nor even fancier,\r\n\r\n```suggestion\r\n  auto v8_planes = base::ToVector(val.planes, [isolate](const auto& plane){\r\n    gin::Dictionary v8_plane(isolate, v8::Object::New(isolate));\r\n    v8_plane.Set(\"stride\", plane.stride);\r\n    v8_plane.Set(\"offset\", plane.offset);\r\n    v8_plane.Set(\"size\", plane.size);\r\n    v8_plane.Set(\"fd\", plane.fd);\r\n    return v8_plane;\r\n  });\r\n```\r\n\r\n(will also need `#include \"base/containers/to_vector.h\"` at top)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2058615443",
    "pr_number": 46745,
    "pr_file": "shell/browser/lib/bluetooth_chooser.h",
    "created_at": "2025-04-24T14:41:27+00:00",
    "commented_code": "bool is_gatt_connected,\n                          bool is_paired,\n                          int signal_strength_level) override;\n+\n+  void OnDeviceChosen(const std::string& device_id);\n   std::vector<DeviceInfo> GetDeviceList();\n \n  private:\n-  std::map<std::string, std::u16string> device_map_;\n+  std::unordered_map<std::string, std::u16string> device_id_to_name_map_;",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2058615443",
        "repo_full_name": "electron/electron",
        "pr_number": 46745,
        "pr_file": "shell/browser/lib/bluetooth_chooser.h",
        "discussion_id": "2058615443",
        "commented_code": "@@ -39,14 +40,18 @@ class BluetoothChooser : public content::BluetoothChooser {\n                          bool is_gatt_connected,\n                          bool is_paired,\n                          int signal_strength_level) override;\n+\n+  void OnDeviceChosen(const std::string& device_id);\n   std::vector<DeviceInfo> GetDeviceList();\n \n  private:\n-  std::map<std::string, std::u16string> device_map_;\n+  std::unordered_map<std::string, std::u16string> device_id_to_name_map_;",
        "comment_created_at": "2025-04-24T14:41:27+00:00",
        "comment_author": "ckerr",
        "comment_body": "1. I like the new name, it's much easier to read :smile_cat: \r\n\r\n2. This field is a good candidate for `absl::flat_hash_map`.\r\n\r\n    Xref: https://chromium.googlesource.com/chromium/src/+/main/base/containers/README.md#map-and-set-selection-usage-advice\r\n    > Note that this advice never suggests the use of std::unordered_map and std::unordered_set. These containers provides similar features to the Abseil flat hash containers but with worse performance. They should only be used if absolutely required for compatibility with third-party code.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2003350125",
    "pr_number": 46100,
    "pr_file": "patches/node/fix_ensure_traverseparent_bails_on_resource_path_exit.patch",
    "created_at": "2025-03-19T13:36:45+00:00",
    "commented_code": "+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Shelley Vohr <shelley.vohr@gmail.com>\n+Date: Tue, 18 Mar 2025 10:41:27 +0100\n+Subject: fix: ensure TraverseParent bails on resource path exit\n+\n+Electron's security model requires that we do not traverse outside of the\n+resource path. This commit ensures that the TraverseParent function\n+bails out if the parent path is outside of the resource path.\n+\n+diff --git a/src/node_modules.cc b/src/node_modules.cc\n+index 210a01d24e11764dc9fc37a77b354f11383693f8..ad08cbbe806d9801e0b6049048ed719ec66458d1 100644\n+--- a/src/node_modules.cc\n++++ b/src/node_modules.cc\n+@@ -290,8 +290,41 @@ const BindingData::PackageConfig* BindingData::TraverseParent(\n+     Realm* realm, const std::filesystem::path& check_path) {\n+   std::filesystem::path current_path = check_path;\n+   auto env = realm->env();\n++  Isolate* isolate = env->isolate();\n+   const bool is_permissions_enabled = env->permission()->enabled();\n+ \n++  // Get the resources path with trailing slash.\n++  std::string resources_path;\n++  {\n++    HandleScope handle_scope(isolate);\n++    Local<Value> resources_path_value;\n++    Local<Object> process_object = env->process_object();\n++\n++    Local<String> resources_path_key =\n++        String::NewFromUtf8Literal(isolate, \"resourcesPath\");\n++    if (process_object->Get(env->context(), resources_path_key)\n++            .ToLocal(&resources_path_value) &&\n++        resources_path_value->IsString()) {\n++      resources_path = *String::Utf8Value(isolate, resources_path_value);\n++      if (!resources_path.empty() && !resources_path.ends_with(kPathSeparator)) {\n++        resources_path += kPathSeparator;\n++      }\n++    }\n++  }\n++\n++  auto starts_with = [](const std::string& str, const std::string& prefix) -> bool {\n++    if (prefix.size() > str.size()) return false;\n++    return std::equal(\n++        prefix.begin(), prefix.end(), str.begin(),\n++        [](char a, char b) {\n++          return std::tolower(static_cast<unsigned char>(a)) == \n++                std::tolower(static_cast<unsigned char>(b));\n++        });",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2003350125",
        "repo_full_name": "electron/electron",
        "pr_number": 46100,
        "pr_file": "patches/node/fix_ensure_traverseparent_bails_on_resource_path_exit.patch",
        "discussion_id": "2003350125",
        "commented_code": "@@ -0,0 +1,68 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Shelley Vohr <shelley.vohr@gmail.com>\n+Date: Tue, 18 Mar 2025 10:41:27 +0100\n+Subject: fix: ensure TraverseParent bails on resource path exit\n+\n+Electron's security model requires that we do not traverse outside of the\n+resource path. This commit ensures that the TraverseParent function\n+bails out if the parent path is outside of the resource path.\n+\n+diff --git a/src/node_modules.cc b/src/node_modules.cc\n+index 210a01d24e11764dc9fc37a77b354f11383693f8..ad08cbbe806d9801e0b6049048ed719ec66458d1 100644\n+--- a/src/node_modules.cc\n++++ b/src/node_modules.cc\n+@@ -290,8 +290,41 @@ const BindingData::PackageConfig* BindingData::TraverseParent(\n+     Realm* realm, const std::filesystem::path& check_path) {\n+   std::filesystem::path current_path = check_path;\n+   auto env = realm->env();\n++  Isolate* isolate = env->isolate();\n+   const bool is_permissions_enabled = env->permission()->enabled();\n+ \n++  // Get the resources path with trailing slash.\n++  std::string resources_path;\n++  {\n++    HandleScope handle_scope(isolate);\n++    Local<Value> resources_path_value;\n++    Local<Object> process_object = env->process_object();\n++\n++    Local<String> resources_path_key =\n++        String::NewFromUtf8Literal(isolate, \"resourcesPath\");\n++    if (process_object->Get(env->context(), resources_path_key)\n++            .ToLocal(&resources_path_value) &&\n++        resources_path_value->IsString()) {\n++      resources_path = *String::Utf8Value(isolate, resources_path_value);\n++      if (!resources_path.empty() && !resources_path.ends_with(kPathSeparator)) {\n++        resources_path += kPathSeparator;\n++      }\n++    }\n++  }\n++\n++  auto starts_with = [](const std::string& str, const std::string& prefix) -> bool {\n++    if (prefix.size() > str.size()) return false;\n++    return std::equal(\n++        prefix.begin(), prefix.end(), str.begin(),\n++        [](char a, char b) {\n++          return std::tolower(static_cast<unsigned char>(a)) == \n++                std::tolower(static_cast<unsigned char>(b));\n++        });",
        "comment_created_at": "2025-03-19T13:36:45+00:00",
        "comment_author": "ckerr",
        "comment_body": "```suggestion\r\n+    return base::StartsWith(str, prefix, base::CompareCase::INSENSITIVE_ASCII);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2003493203",
        "repo_full_name": "electron/electron",
        "pr_number": 46100,
        "pr_file": "patches/node/fix_ensure_traverseparent_bails_on_resource_path_exit.patch",
        "discussion_id": "2003350125",
        "commented_code": "@@ -0,0 +1,68 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Shelley Vohr <shelley.vohr@gmail.com>\n+Date: Tue, 18 Mar 2025 10:41:27 +0100\n+Subject: fix: ensure TraverseParent bails on resource path exit\n+\n+Electron's security model requires that we do not traverse outside of the\n+resource path. This commit ensures that the TraverseParent function\n+bails out if the parent path is outside of the resource path.\n+\n+diff --git a/src/node_modules.cc b/src/node_modules.cc\n+index 210a01d24e11764dc9fc37a77b354f11383693f8..ad08cbbe806d9801e0b6049048ed719ec66458d1 100644\n+--- a/src/node_modules.cc\n++++ b/src/node_modules.cc\n+@@ -290,8 +290,41 @@ const BindingData::PackageConfig* BindingData::TraverseParent(\n+     Realm* realm, const std::filesystem::path& check_path) {\n+   std::filesystem::path current_path = check_path;\n+   auto env = realm->env();\n++  Isolate* isolate = env->isolate();\n+   const bool is_permissions_enabled = env->permission()->enabled();\n+ \n++  // Get the resources path with trailing slash.\n++  std::string resources_path;\n++  {\n++    HandleScope handle_scope(isolate);\n++    Local<Value> resources_path_value;\n++    Local<Object> process_object = env->process_object();\n++\n++    Local<String> resources_path_key =\n++        String::NewFromUtf8Literal(isolate, \"resourcesPath\");\n++    if (process_object->Get(env->context(), resources_path_key)\n++            .ToLocal(&resources_path_value) &&\n++        resources_path_value->IsString()) {\n++      resources_path = *String::Utf8Value(isolate, resources_path_value);\n++      if (!resources_path.empty() && !resources_path.ends_with(kPathSeparator)) {\n++        resources_path += kPathSeparator;\n++      }\n++    }\n++  }\n++\n++  auto starts_with = [](const std::string& str, const std::string& prefix) -> bool {\n++    if (prefix.size() > str.size()) return false;\n++    return std::equal(\n++        prefix.begin(), prefix.end(), str.begin(),\n++        [](char a, char b) {\n++          return std::tolower(static_cast<unsigned char>(a)) == \n++                std::tolower(static_cast<unsigned char>(b));\n++        });",
        "comment_created_at": "2025-03-19T14:33:05+00:00",
        "comment_author": "codebytere",
        "comment_body": "@ckerr this change is happening in Node.js, not Chromium - we don't have access to these helpers as-is, and I don't think it's a good idea to pull in `base` functionality",
        "pr_file_module": null
      },
      {
        "comment_id": "2004425014",
        "repo_full_name": "electron/electron",
        "pr_number": 46100,
        "pr_file": "patches/node/fix_ensure_traverseparent_bails_on_resource_path_exit.patch",
        "discussion_id": "2003350125",
        "commented_code": "@@ -0,0 +1,68 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Shelley Vohr <shelley.vohr@gmail.com>\n+Date: Tue, 18 Mar 2025 10:41:27 +0100\n+Subject: fix: ensure TraverseParent bails on resource path exit\n+\n+Electron's security model requires that we do not traverse outside of the\n+resource path. This commit ensures that the TraverseParent function\n+bails out if the parent path is outside of the resource path.\n+\n+diff --git a/src/node_modules.cc b/src/node_modules.cc\n+index 210a01d24e11764dc9fc37a77b354f11383693f8..ad08cbbe806d9801e0b6049048ed719ec66458d1 100644\n+--- a/src/node_modules.cc\n++++ b/src/node_modules.cc\n+@@ -290,8 +290,41 @@ const BindingData::PackageConfig* BindingData::TraverseParent(\n+     Realm* realm, const std::filesystem::path& check_path) {\n+   std::filesystem::path current_path = check_path;\n+   auto env = realm->env();\n++  Isolate* isolate = env->isolate();\n+   const bool is_permissions_enabled = env->permission()->enabled();\n+ \n++  // Get the resources path with trailing slash.\n++  std::string resources_path;\n++  {\n++    HandleScope handle_scope(isolate);\n++    Local<Value> resources_path_value;\n++    Local<Object> process_object = env->process_object();\n++\n++    Local<String> resources_path_key =\n++        String::NewFromUtf8Literal(isolate, \"resourcesPath\");\n++    if (process_object->Get(env->context(), resources_path_key)\n++            .ToLocal(&resources_path_value) &&\n++        resources_path_value->IsString()) {\n++      resources_path = *String::Utf8Value(isolate, resources_path_value);\n++      if (!resources_path.empty() && !resources_path.ends_with(kPathSeparator)) {\n++        resources_path += kPathSeparator;\n++      }\n++    }\n++  }\n++\n++  auto starts_with = [](const std::string& str, const std::string& prefix) -> bool {\n++    if (prefix.size() > str.size()) return false;\n++    return std::equal(\n++        prefix.begin(), prefix.end(), str.begin(),\n++        [](char a, char b) {\n++          return std::tolower(static_cast<unsigned char>(a)) == \n++                std::tolower(static_cast<unsigned char>(b));\n++        });",
        "comment_created_at": "2025-03-19T22:49:48+00:00",
        "comment_author": "ckerr",
        "comment_body": "You're right, we shouldn't mix it there",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "591826567",
    "pr_number": 27917,
    "pr_file": "shell/browser/api/electron_api_web_contents.cc",
    "created_at": "2021-03-10T19:53:17+00:00",
    "commented_code": "native_fullscreen_ = false;\n }\n \n+#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n+v8::Local<v8::Value> WebContents::GetChromeTabDetails(gin::Arguments* args) {\n+  auto tab = extensions::ExtensionTabUtil::GetTabDetailsFromWebContents(this);\n+\n+  if (!tab)\n+    return v8::Null(args->isolate());\n+\n+  return gin::ConvertToV8(\n+      args->isolate(), std::move(*extensions::ExtensionTabUtil::CreateTabObject(",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "591826567",
        "repo_full_name": "electron/electron",
        "pr_number": 27917,
        "pr_file": "shell/browser/api/electron_api_web_contents.cc",
        "discussion_id": "591826567",
        "commented_code": "@@ -3477,6 +3479,20 @@ void WebContents::SetHtmlApiFullscreen(bool enter_fullscreen) {\n   native_fullscreen_ = false;\n }\n \n+#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n+v8::Local<v8::Value> WebContents::GetChromeTabDetails(gin::Arguments* args) {\n+  auto tab = extensions::ExtensionTabUtil::GetTabDetailsFromWebContents(this);\n+\n+  if (!tab)\n+    return v8::Null(args->isolate());\n+\n+  return gin::ConvertToV8(\n+      args->isolate(), std::move(*extensions::ExtensionTabUtil::CreateTabObject(",
        "comment_created_at": "2021-03-10T19:53:17+00:00",
        "comment_author": "nornagon",
        "comment_body": "is `std::move` necessary here? I'm not sure it has any effect, as temporary values like this are already implicitly passed with move semantics.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1821140465",
    "pr_number": 44296,
    "pr_file": "shell/browser/ui/file_dialog_win.cc",
    "created_at": "2024-10-29T16:10:44+00:00",
    "commented_code": "// We set file extension to the first none-wildcard extension to make\n   // sure the dialog will update file extension automatically.\n   for (size_t i = 0; i < filterspec.size(); ++i) {\n-    if (std::wstring(filterspec[i].pszSpec) != L\"*.*\") {\n+    std::wstring spec(filterspec[i].pszSpec);\n+    // only need first extension\n+    std::wstring firstSpec = spec.substr(0, spec.find(L';'));\n+    if (firstSpec != L\"*.*\") {\n       // SetFileTypeIndex is regarded as one-based index.\n       dialog->SetFileTypeIndex(i + 1);\n-      dialog->SetDefaultExtension(filterspec[i].pszSpec);\n+      // \"*.jpg\" => \"jpg\"\n+      dialog->SetDefaultExtension(firstSpec.substr(2).c_str());",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1821140465",
        "repo_full_name": "electron/electron",
        "pr_number": 44296,
        "pr_file": "shell/browser/ui/file_dialog_win.cc",
        "discussion_id": "1821140465",
        "commented_code": "@@ -144,10 +144,14 @@ static void ApplySettings(IFileDialog* dialog, const DialogSettings& settings) {\n   // We set file extension to the first none-wildcard extension to make\n   // sure the dialog will update file extension automatically.\n   for (size_t i = 0; i < filterspec.size(); ++i) {\n-    if (std::wstring(filterspec[i].pszSpec) != L\"*.*\") {\n+    std::wstring spec(filterspec[i].pszSpec);\n+    // only need first extension\n+    std::wstring firstSpec = spec.substr(0, spec.find(L';'));\n+    if (firstSpec != L\"*.*\") {\n       // SetFileTypeIndex is regarded as one-based index.\n       dialog->SetFileTypeIndex(i + 1);\n-      dialog->SetDefaultExtension(filterspec[i].pszSpec);\n+      // \"*.jpg\" => \"jpg\"\n+      dialog->SetDefaultExtension(firstSpec.substr(2).c_str());",
        "comment_created_at": "2024-10-29T16:10:44+00:00",
        "comment_author": "samuelmaddock",
        "comment_body": "```suggestion\r\n      // \"*.jpg;*.png\" => \"*.jpg\"\r\n      std::wstring first_spec = spec.substr(0, spec.find(L';'));\r\n      // \"*.jpg\" => \"jpg\"\r\n      dialog->SetDefaultExtension(first_spec.substr(2).c_str());\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1591621327",
    "pr_number": 42045,
    "pr_file": "shell/browser/ui/file_dialog_linux.cc",
    "created_at": "2024-05-06T22:32:58+00:00",
    "commented_code": "+// Copyright (c) 2024 Microsoft, Gmbh.\n+// Use of this source code is governed by the MIT license that can be\n+// found in the LICENSE file.\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"base/files/file_util.h\"\n+#include \"base/functional/bind.h\"\n+#include \"base/functional/callback.h\"\n+#include \"base/memory/raw_ptr.h\"\n+#include \"base/memory/raw_ptr_exclusion.h\"\n+#include \"base/run_loop.h\"\n+#include \"base/strings/string_util.h\"\n+#include \"base/strings/utf_string_conversions.h\"\n+#include \"shell/browser/javascript_environment.h\"\n+#include \"shell/browser/native_window_views.h\"\n+#include \"shell/browser/ui/file_dialog.h\"\n+#include \"shell/browser/ui/select_file_policy.h\"\n+#include \"shell/common/gin_converters/callback_converter.h\"\n+#include \"shell/common/gin_converters/file_path_converter.h\"\n+#include \"ui/shell_dialogs/select_file_dialog.h\"\n+#include \"ui/shell_dialogs/selected_file_info.h\"\n+\n+namespace file_dialog {\n+\n+DialogSettings::DialogSettings() = default;\n+DialogSettings::DialogSettings(const DialogSettings&) = default;\n+DialogSettings::~DialogSettings() = default;\n+\n+namespace {\n+\n+ui::SelectFileDialog::Type GetDialogType(int properties) {\n+  if (properties & OPEN_DIALOG_OPEN_FILE) {\n+    return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+  } else if (properties & OPEN_DIALOG_OPEN_DIRECTORY) {\n+    return ui::SelectFileDialog::SELECT_FOLDER;\n+  } else if (properties & OPEN_DIALOG_MULTI_SELECTIONS) {\n+    return ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE;\n+  }\n+\n+  return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+}\n+\n+// [save_label, show_overwrite_confirmation, show_hidden, ]\n+std::tuple<std::string, bool, bool> GetSettingsTuple(\n+    const DialogSettings& settings) {\n+  bool show_overwrite_confirmation =\n+      settings.properties & SAVE_DIALOG_SHOW_OVERWRITE_CONFIRMATION;\n+  bool show_hidden = settings.properties & SAVE_DIALOG_SHOW_HIDDEN_FILES;\n+\n+  return std::make_tuple(settings.button_label, show_overwrite_confirmation,\n+                         show_hidden);\n+}\n+\n+ui::SelectFileDialog::FileTypeInfo GetFilterInfo(const Filters& filters) {\n+  ui::SelectFileDialog::FileTypeInfo file_type_info;\n+\n+  for (const auto& filter : filters) {\n+    auto [name, extension_group] = filter;\n+    file_type_info.extension_description_overrides.push_back(\n+        base::UTF8ToUTF16(name));\n+\n+    bool has_all_files_wildcard =\n+        std::any_of(extension_group.begin(), extension_group.end(),\n+                    [](std::string ext) { return ext == \"*\"; });",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1591621327",
        "repo_full_name": "electron/electron",
        "pr_number": 42045,
        "pr_file": "shell/browser/ui/file_dialog_linux.cc",
        "discussion_id": "1591621327",
        "commented_code": "@@ -0,0 +1,260 @@\n+// Copyright (c) 2024 Microsoft, Gmbh.\n+// Use of this source code is governed by the MIT license that can be\n+// found in the LICENSE file.\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"base/files/file_util.h\"\n+#include \"base/functional/bind.h\"\n+#include \"base/functional/callback.h\"\n+#include \"base/memory/raw_ptr.h\"\n+#include \"base/memory/raw_ptr_exclusion.h\"\n+#include \"base/run_loop.h\"\n+#include \"base/strings/string_util.h\"\n+#include \"base/strings/utf_string_conversions.h\"\n+#include \"shell/browser/javascript_environment.h\"\n+#include \"shell/browser/native_window_views.h\"\n+#include \"shell/browser/ui/file_dialog.h\"\n+#include \"shell/browser/ui/select_file_policy.h\"\n+#include \"shell/common/gin_converters/callback_converter.h\"\n+#include \"shell/common/gin_converters/file_path_converter.h\"\n+#include \"ui/shell_dialogs/select_file_dialog.h\"\n+#include \"ui/shell_dialogs/selected_file_info.h\"\n+\n+namespace file_dialog {\n+\n+DialogSettings::DialogSettings() = default;\n+DialogSettings::DialogSettings(const DialogSettings&) = default;\n+DialogSettings::~DialogSettings() = default;\n+\n+namespace {\n+\n+ui::SelectFileDialog::Type GetDialogType(int properties) {\n+  if (properties & OPEN_DIALOG_OPEN_FILE) {\n+    return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+  } else if (properties & OPEN_DIALOG_OPEN_DIRECTORY) {\n+    return ui::SelectFileDialog::SELECT_FOLDER;\n+  } else if (properties & OPEN_DIALOG_MULTI_SELECTIONS) {\n+    return ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE;\n+  }\n+\n+  return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+}\n+\n+// [save_label, show_overwrite_confirmation, show_hidden, ]\n+std::tuple<std::string, bool, bool> GetSettingsTuple(\n+    const DialogSettings& settings) {\n+  bool show_overwrite_confirmation =\n+      settings.properties & SAVE_DIALOG_SHOW_OVERWRITE_CONFIRMATION;\n+  bool show_hidden = settings.properties & SAVE_DIALOG_SHOW_HIDDEN_FILES;\n+\n+  return std::make_tuple(settings.button_label, show_overwrite_confirmation,\n+                         show_hidden);\n+}\n+\n+ui::SelectFileDialog::FileTypeInfo GetFilterInfo(const Filters& filters) {\n+  ui::SelectFileDialog::FileTypeInfo file_type_info;\n+\n+  for (const auto& filter : filters) {\n+    auto [name, extension_group] = filter;\n+    file_type_info.extension_description_overrides.push_back(\n+        base::UTF8ToUTF16(name));\n+\n+    bool has_all_files_wildcard =\n+        std::any_of(extension_group.begin(), extension_group.end(),\n+                    [](std::string ext) { return ext == \"*\"; });",
        "comment_created_at": "2024-05-06T22:32:58+00:00",
        "comment_author": "ckerr",
        "comment_body": "```suggestion\r\n    const bool has_all_files_wildcard = base::ranges::any_of(\r\n        extension_group, [](const auto& ext) { return ext == \"*\"; });\r\n```\r\n\r\n_(opinion)_ or even\r\n\r\n```c++\r\nif (base::ranges::any_of(extension_group,\r\n                         [](const auto& ext) { return ext == \"*\"; })) {\r\n  file_type_info.include_all_files = true;\r\n} else {\r\n  file_type_info.extensions.push_back(extension_group);\r\n}",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1591784073",
    "pr_number": 42045,
    "pr_file": "shell/browser/ui/file_dialog_linux.cc",
    "created_at": "2024-05-07T04:03:43+00:00",
    "commented_code": "+// Copyright (c) 2024 Microsoft, Gmbh.\n+// Use of this source code is governed by the MIT license that can be\n+// found in the LICENSE file.\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"base/files/file_util.h\"\n+#include \"base/functional/bind.h\"\n+#include \"base/functional/callback.h\"\n+#include \"base/memory/raw_ptr.h\"\n+#include \"base/memory/raw_ptr_exclusion.h\"\n+#include \"base/run_loop.h\"\n+#include \"base/strings/string_util.h\"\n+#include \"base/strings/utf_string_conversions.h\"\n+#include \"shell/browser/javascript_environment.h\"\n+#include \"shell/browser/native_window_views.h\"\n+#include \"shell/browser/ui/file_dialog.h\"\n+#include \"shell/browser/ui/select_file_policy.h\"\n+#include \"shell/common/gin_converters/callback_converter.h\"\n+#include \"shell/common/gin_converters/file_path_converter.h\"\n+#include \"ui/shell_dialogs/select_file_dialog.h\"\n+#include \"ui/shell_dialogs/selected_file_info.h\"\n+\n+namespace file_dialog {\n+\n+DialogSettings::DialogSettings() = default;\n+DialogSettings::DialogSettings(const DialogSettings&) = default;\n+DialogSettings::~DialogSettings() = default;\n+\n+namespace {\n+\n+ui::SelectFileDialog::Type GetDialogType(int properties) {\n+  if (properties & OPEN_DIALOG_OPEN_FILE) {\n+    return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+  } else if (properties & OPEN_DIALOG_OPEN_DIRECTORY) {\n+    return ui::SelectFileDialog::SELECT_FOLDER;\n+  } else if (properties & OPEN_DIALOG_MULTI_SELECTIONS) {\n+    return ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE;\n+  }\n+\n+  return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+}\n+\n+// [save_label, show_overwrite_confirmation, show_hidden, ]\n+std::tuple<std::string, bool, bool> GetSettingsTuple(\n+    const DialogSettings& settings) {\n+  bool show_overwrite_confirmation =\n+      settings.properties & SAVE_DIALOG_SHOW_OVERWRITE_CONFIRMATION;\n+  bool show_hidden = settings.properties & SAVE_DIALOG_SHOW_HIDDEN_FILES;\n+\n+  return std::make_tuple(settings.button_label, show_overwrite_confirmation,\n+                         show_hidden);\n+}\n+\n+ui::SelectFileDialog::FileTypeInfo GetFilterInfo(const Filters& filters) {\n+  ui::SelectFileDialog::FileTypeInfo file_type_info;\n+\n+  for (const auto& filter : filters) {\n+    auto [name, extension_group] = filter;\n+    file_type_info.extension_description_overrides.push_back(\n+        base::UTF8ToUTF16(name));\n+\n+    bool has_all_files_wildcard =\n+        std::any_of(extension_group.begin(), extension_group.end(),\n+                    [](std::string ext) { return ext == \"*\"; });\n+    if (has_all_files_wildcard) {\n+      file_type_info.include_all_files = true;\n+    } else {\n+      file_type_info.extensions.push_back(extension_group);\n+    }\n+  }\n+\n+  return file_type_info;\n+}\n+\n+class FileChooserDialog : public ui::SelectFileDialog::Listener {\n+ public:\n+  enum class DialogType { OPEN, SAVE };\n+\n+  FileChooserDialog() {\n+    dialog_ = ui::SelectFileDialog::Create(\n+        this, std::make_unique<ElectronSelectFilePolicy>(nullptr));\n+  }\n+\n+  ~FileChooserDialog() override {\n+    // TODO(codebytere): anything we need to do here?\n+  }\n+\n+  void RunSaveDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::SAVE;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        ui::SelectFileDialog::SELECT_SAVEAS_FILE,\n+        base::UTF8ToUTF16(settings.title), settings.default_path,\n+        &file_info /* file_types */, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunSaveDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunSaveDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::OPEN;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        GetDialogType(settings.properties), base::UTF8ToUTF16(settings.title),\n+        settings.default_path, &file_info, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunOpenDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void FileSelected(const ui::SelectedFileInfo& file,\n+                    int index,\n+                    void* params) override {\n+    v8::Isolate* isolate = electron::JavascriptEnvironment::GetIsolate();\n+    v8::HandleScope scope(isolate);\n+    auto dict = gin_helper::Dictionary::CreateEmpty(isolate);\n+    dict.Set(\"canceled\", false);\n+    if (type_ == DialogType::SAVE) {\n+      dict.Set(\"filePath\", file.file_path);\n+    } else {\n+      dict.Set(\"filePaths\", std::vector<base::FilePath>{file.file_path});\n+    }\n+\n+    if (callback_) {\n+      std::move(callback_).Run(dict);",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1591784073",
        "repo_full_name": "electron/electron",
        "pr_number": 42045,
        "pr_file": "shell/browser/ui/file_dialog_linux.cc",
        "discussion_id": "1591784073",
        "commented_code": "@@ -0,0 +1,260 @@\n+// Copyright (c) 2024 Microsoft, Gmbh.\n+// Use of this source code is governed by the MIT license that can be\n+// found in the LICENSE file.\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"base/files/file_util.h\"\n+#include \"base/functional/bind.h\"\n+#include \"base/functional/callback.h\"\n+#include \"base/memory/raw_ptr.h\"\n+#include \"base/memory/raw_ptr_exclusion.h\"\n+#include \"base/run_loop.h\"\n+#include \"base/strings/string_util.h\"\n+#include \"base/strings/utf_string_conversions.h\"\n+#include \"shell/browser/javascript_environment.h\"\n+#include \"shell/browser/native_window_views.h\"\n+#include \"shell/browser/ui/file_dialog.h\"\n+#include \"shell/browser/ui/select_file_policy.h\"\n+#include \"shell/common/gin_converters/callback_converter.h\"\n+#include \"shell/common/gin_converters/file_path_converter.h\"\n+#include \"ui/shell_dialogs/select_file_dialog.h\"\n+#include \"ui/shell_dialogs/selected_file_info.h\"\n+\n+namespace file_dialog {\n+\n+DialogSettings::DialogSettings() = default;\n+DialogSettings::DialogSettings(const DialogSettings&) = default;\n+DialogSettings::~DialogSettings() = default;\n+\n+namespace {\n+\n+ui::SelectFileDialog::Type GetDialogType(int properties) {\n+  if (properties & OPEN_DIALOG_OPEN_FILE) {\n+    return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+  } else if (properties & OPEN_DIALOG_OPEN_DIRECTORY) {\n+    return ui::SelectFileDialog::SELECT_FOLDER;\n+  } else if (properties & OPEN_DIALOG_MULTI_SELECTIONS) {\n+    return ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE;\n+  }\n+\n+  return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+}\n+\n+// [save_label, show_overwrite_confirmation, show_hidden, ]\n+std::tuple<std::string, bool, bool> GetSettingsTuple(\n+    const DialogSettings& settings) {\n+  bool show_overwrite_confirmation =\n+      settings.properties & SAVE_DIALOG_SHOW_OVERWRITE_CONFIRMATION;\n+  bool show_hidden = settings.properties & SAVE_DIALOG_SHOW_HIDDEN_FILES;\n+\n+  return std::make_tuple(settings.button_label, show_overwrite_confirmation,\n+                         show_hidden);\n+}\n+\n+ui::SelectFileDialog::FileTypeInfo GetFilterInfo(const Filters& filters) {\n+  ui::SelectFileDialog::FileTypeInfo file_type_info;\n+\n+  for (const auto& filter : filters) {\n+    auto [name, extension_group] = filter;\n+    file_type_info.extension_description_overrides.push_back(\n+        base::UTF8ToUTF16(name));\n+\n+    bool has_all_files_wildcard =\n+        std::any_of(extension_group.begin(), extension_group.end(),\n+                    [](std::string ext) { return ext == \"*\"; });\n+    if (has_all_files_wildcard) {\n+      file_type_info.include_all_files = true;\n+    } else {\n+      file_type_info.extensions.push_back(extension_group);\n+    }\n+  }\n+\n+  return file_type_info;\n+}\n+\n+class FileChooserDialog : public ui::SelectFileDialog::Listener {\n+ public:\n+  enum class DialogType { OPEN, SAVE };\n+\n+  FileChooserDialog() {\n+    dialog_ = ui::SelectFileDialog::Create(\n+        this, std::make_unique<ElectronSelectFilePolicy>(nullptr));\n+  }\n+\n+  ~FileChooserDialog() override {\n+    // TODO(codebytere): anything we need to do here?\n+  }\n+\n+  void RunSaveDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::SAVE;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        ui::SelectFileDialog::SELECT_SAVEAS_FILE,\n+        base::UTF8ToUTF16(settings.title), settings.default_path,\n+        &file_info /* file_types */, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunSaveDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunSaveDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::OPEN;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        GetDialogType(settings.properties), base::UTF8ToUTF16(settings.title),\n+        settings.default_path, &file_info, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunOpenDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void FileSelected(const ui::SelectedFileInfo& file,\n+                    int index,\n+                    void* params) override {\n+    v8::Isolate* isolate = electron::JavascriptEnvironment::GetIsolate();\n+    v8::HandleScope scope(isolate);\n+    auto dict = gin_helper::Dictionary::CreateEmpty(isolate);\n+    dict.Set(\"canceled\", false);\n+    if (type_ == DialogType::SAVE) {\n+      dict.Set(\"filePath\", file.file_path);\n+    } else {\n+      dict.Set(\"filePaths\", std::vector<base::FilePath>{file.file_path});\n+    }\n+\n+    if (callback_) {\n+      std::move(callback_).Run(dict);",
        "comment_created_at": "2024-05-07T04:03:43+00:00",
        "comment_author": "ckerr",
        "comment_body": "```suggestion\r\n      std::move(callback_).Run(std::move(dict));\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1592019274",
        "repo_full_name": "electron/electron",
        "pr_number": 42045,
        "pr_file": "shell/browser/ui/file_dialog_linux.cc",
        "discussion_id": "1591784073",
        "commented_code": "@@ -0,0 +1,260 @@\n+// Copyright (c) 2024 Microsoft, Gmbh.\n+// Use of this source code is governed by the MIT license that can be\n+// found in the LICENSE file.\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"base/files/file_util.h\"\n+#include \"base/functional/bind.h\"\n+#include \"base/functional/callback.h\"\n+#include \"base/memory/raw_ptr.h\"\n+#include \"base/memory/raw_ptr_exclusion.h\"\n+#include \"base/run_loop.h\"\n+#include \"base/strings/string_util.h\"\n+#include \"base/strings/utf_string_conversions.h\"\n+#include \"shell/browser/javascript_environment.h\"\n+#include \"shell/browser/native_window_views.h\"\n+#include \"shell/browser/ui/file_dialog.h\"\n+#include \"shell/browser/ui/select_file_policy.h\"\n+#include \"shell/common/gin_converters/callback_converter.h\"\n+#include \"shell/common/gin_converters/file_path_converter.h\"\n+#include \"ui/shell_dialogs/select_file_dialog.h\"\n+#include \"ui/shell_dialogs/selected_file_info.h\"\n+\n+namespace file_dialog {\n+\n+DialogSettings::DialogSettings() = default;\n+DialogSettings::DialogSettings(const DialogSettings&) = default;\n+DialogSettings::~DialogSettings() = default;\n+\n+namespace {\n+\n+ui::SelectFileDialog::Type GetDialogType(int properties) {\n+  if (properties & OPEN_DIALOG_OPEN_FILE) {\n+    return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+  } else if (properties & OPEN_DIALOG_OPEN_DIRECTORY) {\n+    return ui::SelectFileDialog::SELECT_FOLDER;\n+  } else if (properties & OPEN_DIALOG_MULTI_SELECTIONS) {\n+    return ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE;\n+  }\n+\n+  return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+}\n+\n+// [save_label, show_overwrite_confirmation, show_hidden, ]\n+std::tuple<std::string, bool, bool> GetSettingsTuple(\n+    const DialogSettings& settings) {\n+  bool show_overwrite_confirmation =\n+      settings.properties & SAVE_DIALOG_SHOW_OVERWRITE_CONFIRMATION;\n+  bool show_hidden = settings.properties & SAVE_DIALOG_SHOW_HIDDEN_FILES;\n+\n+  return std::make_tuple(settings.button_label, show_overwrite_confirmation,\n+                         show_hidden);\n+}\n+\n+ui::SelectFileDialog::FileTypeInfo GetFilterInfo(const Filters& filters) {\n+  ui::SelectFileDialog::FileTypeInfo file_type_info;\n+\n+  for (const auto& filter : filters) {\n+    auto [name, extension_group] = filter;\n+    file_type_info.extension_description_overrides.push_back(\n+        base::UTF8ToUTF16(name));\n+\n+    bool has_all_files_wildcard =\n+        std::any_of(extension_group.begin(), extension_group.end(),\n+                    [](std::string ext) { return ext == \"*\"; });\n+    if (has_all_files_wildcard) {\n+      file_type_info.include_all_files = true;\n+    } else {\n+      file_type_info.extensions.push_back(extension_group);\n+    }\n+  }\n+\n+  return file_type_info;\n+}\n+\n+class FileChooserDialog : public ui::SelectFileDialog::Listener {\n+ public:\n+  enum class DialogType { OPEN, SAVE };\n+\n+  FileChooserDialog() {\n+    dialog_ = ui::SelectFileDialog::Create(\n+        this, std::make_unique<ElectronSelectFilePolicy>(nullptr));\n+  }\n+\n+  ~FileChooserDialog() override {\n+    // TODO(codebytere): anything we need to do here?\n+  }\n+\n+  void RunSaveDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::SAVE;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        ui::SelectFileDialog::SELECT_SAVEAS_FILE,\n+        base::UTF8ToUTF16(settings.title), settings.default_path,\n+        &file_info /* file_types */, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunSaveDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunSaveDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::OPEN;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        GetDialogType(settings.properties), base::UTF8ToUTF16(settings.title),\n+        settings.default_path, &file_info, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunOpenDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void FileSelected(const ui::SelectedFileInfo& file,\n+                    int index,\n+                    void* params) override {\n+    v8::Isolate* isolate = electron::JavascriptEnvironment::GetIsolate();\n+    v8::HandleScope scope(isolate);\n+    auto dict = gin_helper::Dictionary::CreateEmpty(isolate);\n+    dict.Set(\"canceled\", false);\n+    if (type_ == DialogType::SAVE) {\n+      dict.Set(\"filePath\", file.file_path);\n+    } else {\n+      dict.Set(\"filePaths\", std::vector<base::FilePath>{file.file_path});\n+    }\n+\n+    if (callback_) {\n+      std::move(callback_).Run(dict);",
        "comment_created_at": "2024-05-07T08:26:35+00:00",
        "comment_author": "codebytere",
        "comment_body": "`base::Value::Dict` is move-only but `gin::Dictionary` isn't so i don't think we need this here \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1592678453",
        "repo_full_name": "electron/electron",
        "pr_number": 42045,
        "pr_file": "shell/browser/ui/file_dialog_linux.cc",
        "discussion_id": "1591784073",
        "commented_code": "@@ -0,0 +1,260 @@\n+// Copyright (c) 2024 Microsoft, Gmbh.\n+// Use of this source code is governed by the MIT license that can be\n+// found in the LICENSE file.\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"base/files/file_util.h\"\n+#include \"base/functional/bind.h\"\n+#include \"base/functional/callback.h\"\n+#include \"base/memory/raw_ptr.h\"\n+#include \"base/memory/raw_ptr_exclusion.h\"\n+#include \"base/run_loop.h\"\n+#include \"base/strings/string_util.h\"\n+#include \"base/strings/utf_string_conversions.h\"\n+#include \"shell/browser/javascript_environment.h\"\n+#include \"shell/browser/native_window_views.h\"\n+#include \"shell/browser/ui/file_dialog.h\"\n+#include \"shell/browser/ui/select_file_policy.h\"\n+#include \"shell/common/gin_converters/callback_converter.h\"\n+#include \"shell/common/gin_converters/file_path_converter.h\"\n+#include \"ui/shell_dialogs/select_file_dialog.h\"\n+#include \"ui/shell_dialogs/selected_file_info.h\"\n+\n+namespace file_dialog {\n+\n+DialogSettings::DialogSettings() = default;\n+DialogSettings::DialogSettings(const DialogSettings&) = default;\n+DialogSettings::~DialogSettings() = default;\n+\n+namespace {\n+\n+ui::SelectFileDialog::Type GetDialogType(int properties) {\n+  if (properties & OPEN_DIALOG_OPEN_FILE) {\n+    return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+  } else if (properties & OPEN_DIALOG_OPEN_DIRECTORY) {\n+    return ui::SelectFileDialog::SELECT_FOLDER;\n+  } else if (properties & OPEN_DIALOG_MULTI_SELECTIONS) {\n+    return ui::SelectFileDialog::SELECT_OPEN_MULTI_FILE;\n+  }\n+\n+  return ui::SelectFileDialog::SELECT_OPEN_FILE;\n+}\n+\n+// [save_label, show_overwrite_confirmation, show_hidden, ]\n+std::tuple<std::string, bool, bool> GetSettingsTuple(\n+    const DialogSettings& settings) {\n+  bool show_overwrite_confirmation =\n+      settings.properties & SAVE_DIALOG_SHOW_OVERWRITE_CONFIRMATION;\n+  bool show_hidden = settings.properties & SAVE_DIALOG_SHOW_HIDDEN_FILES;\n+\n+  return std::make_tuple(settings.button_label, show_overwrite_confirmation,\n+                         show_hidden);\n+}\n+\n+ui::SelectFileDialog::FileTypeInfo GetFilterInfo(const Filters& filters) {\n+  ui::SelectFileDialog::FileTypeInfo file_type_info;\n+\n+  for (const auto& filter : filters) {\n+    auto [name, extension_group] = filter;\n+    file_type_info.extension_description_overrides.push_back(\n+        base::UTF8ToUTF16(name));\n+\n+    bool has_all_files_wildcard =\n+        std::any_of(extension_group.begin(), extension_group.end(),\n+                    [](std::string ext) { return ext == \"*\"; });\n+    if (has_all_files_wildcard) {\n+      file_type_info.include_all_files = true;\n+    } else {\n+      file_type_info.extensions.push_back(extension_group);\n+    }\n+  }\n+\n+  return file_type_info;\n+}\n+\n+class FileChooserDialog : public ui::SelectFileDialog::Listener {\n+ public:\n+  enum class DialogType { OPEN, SAVE };\n+\n+  FileChooserDialog() {\n+    dialog_ = ui::SelectFileDialog::Create(\n+        this, std::make_unique<ElectronSelectFilePolicy>(nullptr));\n+  }\n+\n+  ~FileChooserDialog() override {\n+    // TODO(codebytere): anything we need to do here?\n+  }\n+\n+  void RunSaveDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::SAVE;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        ui::SelectFileDialog::SELECT_SAVEAS_FILE,\n+        base::UTF8ToUTF16(settings.title), settings.default_path,\n+        &file_info /* file_types */, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunSaveDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunSaveDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunSaveDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialogImpl(const DialogSettings& settings) {\n+    type_ = DialogType::OPEN;\n+    ui::SelectFileDialog::FileTypeInfo file_info =\n+        GetFilterInfo(settings.filters);\n+    std::tuple<std::string, bool, bool> extra_settings =\n+        GetSettingsTuple(settings);\n+    dialog_->SelectFile(\n+        GetDialogType(settings.properties), base::UTF8ToUTF16(settings.title),\n+        settings.default_path, &file_info, 0 /* file_type_index */,\n+        base::FilePath::StringType() /* default_extension */,\n+        settings.parent_window ? settings.parent_window->GetNativeWindow()\n+                               : nullptr,\n+        static_cast<void*>(&extra_settings));\n+  }\n+\n+  void RunOpenDialog(gin_helper::Promise<gin_helper::Dictionary> promise,\n+                     const DialogSettings& settings) {\n+    promise_ = std::make_unique<gin_helper::Promise<gin_helper::Dictionary>>(\n+        std::move(promise));\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void RunOpenDialog(base::OnceCallback<void(gin_helper::Dictionary)> callback,\n+                     const DialogSettings& settings) {\n+    callback_ = std::move(callback);\n+    RunOpenDialogImpl(settings);\n+  }\n+\n+  void FileSelected(const ui::SelectedFileInfo& file,\n+                    int index,\n+                    void* params) override {\n+    v8::Isolate* isolate = electron::JavascriptEnvironment::GetIsolate();\n+    v8::HandleScope scope(isolate);\n+    auto dict = gin_helper::Dictionary::CreateEmpty(isolate);\n+    dict.Set(\"canceled\", false);\n+    if (type_ == DialogType::SAVE) {\n+      dict.Set(\"filePath\", file.file_path);\n+    } else {\n+      dict.Set(\"filePaths\", std::vector<base::FilePath>{file.file_path});\n+    }\n+\n+    if (callback_) {\n+      std::move(callback_).Run(dict);",
        "comment_created_at": "2024-05-07T15:23:50+00:00",
        "comment_author": "ckerr",
        "comment_body": "You've got a point.\r\n\r\nUsually move semantics are good when we build some nontrivial object and our final act is to ship it off to someone else, since it avoids a complex copy. But we don't have `Dictionary(Dictionary&&)` or `Dictionary(Dictionaryh)` -- only `Dictionary(const Dictionary& that)` -- so the move is moot here :shrug: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1842966086",
    "pr_number": 44656,
    "pr_file": "shell/browser/api/electron_api_view.cc",
    "created_at": "2024-11-14T22:32:06+00:00",
    "commented_code": "if (!view_)\n     return;\n \n-  const auto it = base::ranges::find(child_views_, child.ToV8());\n+  const auto it =\n+      std::ranges::find_if(child_views_, [&](const ChildPair& child_view) {\n+        return child_view.second == child.ToV8();\n+      });",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1842966086",
        "repo_full_name": "electron/electron",
        "pr_number": 44656,
        "pr_file": "shell/browser/api/electron_api_view.cc",
        "discussion_id": "1842966086",
        "commented_code": "@@ -261,7 +256,10 @@ void View::RemoveChildView(gin::Handle<View> child) {\n   if (!view_)\n     return;\n \n-  const auto it = base::ranges::find(child_views_, child.ToV8());\n+  const auto it =\n+      std::ranges::find_if(child_views_, [&](const ChildPair& child_view) {\n+        return child_view.second == child.ToV8();\n+      });",
        "comment_created_at": "2024-11-14T22:32:06+00:00",
        "comment_author": "ckerr",
        "comment_body": "I'd like you to check my work; but I _think_ this test would work and is slightly cheaper than the `ToV8()` call\r\n\r\n```suggestion\r\n  const auto it =\r\n      std::ranges::find_if(child_views_, [&](const ChildPair& child_view) {\r\n        return child_view.first == child->view();\r\n      });\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1843077081",
        "repo_full_name": "electron/electron",
        "pr_number": 44656,
        "pr_file": "shell/browser/api/electron_api_view.cc",
        "discussion_id": "1842966086",
        "commented_code": "@@ -261,7 +256,10 @@ void View::RemoveChildView(gin::Handle<View> child) {\n   if (!view_)\n     return;\n \n-  const auto it = base::ranges::find(child_views_, child.ToV8());\n+  const auto it =\n+      std::ranges::find_if(child_views_, [&](const ChildPair& child_view) {\n+        return child_view.second == child.ToV8();\n+      });",
        "comment_created_at": "2024-11-15T01:27:18+00:00",
        "comment_author": "jkleinsc",
        "comment_body": "Yup that works!",
        "pr_file_module": null
      }
    ]
  }
]