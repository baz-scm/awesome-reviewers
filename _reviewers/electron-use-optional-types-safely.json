[
  {
    "discussion_id": "2185191809",
    "pr_number": 47660,
    "pr_file": "shell/browser/native_window_views_win.cc",
    "created_at": "2025-07-04T12:06:19+00:00",
    "commented_code": "if (base::win::GetVersion() < base::win::Version::WIN11)\n     return;\n \n-  COLORREF border_color;\n+  std::optional<COLORREF> border_color;\n   bool should_apply_accent = false;\n \n-  if (std::holds_alternative<bool>(accent_color_)) {\n-    bool force_accent = std::get<bool>(accent_color_);\n-    if (!force_accent) {\n-      should_apply_accent = false;\n-    } else {\n-      std::optional<DWORD> accent_color = GetAccentColor();\n-      if (accent_color.has_value()) {\n-        border_color = RGB(GetRValue(accent_color.value()),\n-                           GetGValue(accent_color.value()),\n-                           GetBValue(accent_color.value()));\n-        should_apply_accent = true;\n-      }\n-    }\n-  } else if (std::holds_alternative<SkColor>(accent_color_)) {\n+  if (std::holds_alternative<SkColor>(accent_color_)) {\n+    // If the user has explicitly set an accent color, use it\n+    // regardless of whether the system accent color is enabled.\n     SkColor color = std::get<SkColor>(accent_color_);\n     border_color =\n         RGB(SkColorGetR(color), SkColorGetG(color), SkColorGetB(color));\n     should_apply_accent = true;\n+  } else if (std::holds_alternative<bool>(accent_color_)) {\n+    // Allow the user to optionally force system color on/off.\n+    should_apply_accent = std::get<bool>(accent_color_);\n   } else if (std::holds_alternative<std::monostate>(accent_color_)) {\n-    if (IsAccentColorOnTitleBarsEnabled()) {\n-      std::optional<DWORD> accent_color = GetAccentColor();\n-      if (accent_color.has_value()) {\n-        border_color = RGB(GetRValue(accent_color.value()),\n-                           GetGValue(accent_color.value()),\n-                           GetBValue(accent_color.value()));\n-        should_apply_accent = true;\n-      }\n+    // If no explicit color was set, default to the system accent color.\n+    should_apply_accent = IsAccentColorOnTitleBarsEnabled();\n+  }\n+\n+  // Use system accent color as fallback if no explicit color was set.\n+  if (!border_color.has_value() && should_apply_accent) {\n+    std::optional<DWORD> system_accent_color = GetAccentColor();\n+    if (system_accent_color.has_value()) {\n+      border_color = RGB(GetRValue(system_accent_color.value()),\n+                         GetGValue(system_accent_color.value()),\n+                         GetBValue(system_accent_color.value()));\n+    } else {\n+      should_apply_accent = false;\n     }",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2185191809",
        "repo_full_name": "electron/electron",
        "pr_number": 47660,
        "pr_file": "shell/browser/native_window_views_win.cc",
        "discussion_id": "2185191809",
        "commented_code": "@@ -574,43 +574,40 @@ void NativeWindowViews::UpdateWindowAccentColor() {\n   if (base::win::GetVersion() < base::win::Version::WIN11)\n     return;\n \n-  COLORREF border_color;\n+  std::optional<COLORREF> border_color;\n   bool should_apply_accent = false;\n \n-  if (std::holds_alternative<bool>(accent_color_)) {\n-    bool force_accent = std::get<bool>(accent_color_);\n-    if (!force_accent) {\n-      should_apply_accent = false;\n-    } else {\n-      std::optional<DWORD> accent_color = GetAccentColor();\n-      if (accent_color.has_value()) {\n-        border_color = RGB(GetRValue(accent_color.value()),\n-                           GetGValue(accent_color.value()),\n-                           GetBValue(accent_color.value()));\n-        should_apply_accent = true;\n-      }\n-    }\n-  } else if (std::holds_alternative<SkColor>(accent_color_)) {\n+  if (std::holds_alternative<SkColor>(accent_color_)) {\n+    // If the user has explicitly set an accent color, use it\n+    // regardless of whether the system accent color is enabled.\n     SkColor color = std::get<SkColor>(accent_color_);\n     border_color =\n         RGB(SkColorGetR(color), SkColorGetG(color), SkColorGetB(color));\n     should_apply_accent = true;\n+  } else if (std::holds_alternative<bool>(accent_color_)) {\n+    // Allow the user to optionally force system color on/off.\n+    should_apply_accent = std::get<bool>(accent_color_);\n   } else if (std::holds_alternative<std::monostate>(accent_color_)) {\n-    if (IsAccentColorOnTitleBarsEnabled()) {\n-      std::optional<DWORD> accent_color = GetAccentColor();\n-      if (accent_color.has_value()) {\n-        border_color = RGB(GetRValue(accent_color.value()),\n-                           GetGValue(accent_color.value()),\n-                           GetBValue(accent_color.value()));\n-        should_apply_accent = true;\n-      }\n+    // If no explicit color was set, default to the system accent color.\n+    should_apply_accent = IsAccentColorOnTitleBarsEnabled();\n+  }\n+\n+  // Use system accent color as fallback if no explicit color was set.\n+  if (!border_color.has_value() && should_apply_accent) {\n+    std::optional<DWORD> system_accent_color = GetAccentColor();\n+    if (system_accent_color.has_value()) {\n+      border_color = RGB(GetRValue(system_accent_color.value()),\n+                         GetGValue(system_accent_color.value()),\n+                         GetBValue(system_accent_color.value()));\n+    } else {\n+      should_apply_accent = false;\n     }",
        "comment_created_at": "2025-07-04T12:06:19+00:00",
        "comment_author": "deepak1556",
        "comment_body": "Shouldn't be needed. \r\n\r\n```suggestion\r\n\r\n```\r\n\r\nThen the below can just be, is there a case where we have border_color and we don't want to apply accent ?\r\n\r\n```\r\nCOLORREF final_color = border_color.value_or(DWMWA_COLOR_DEFAULT);\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2112821601",
    "pr_number": 47285,
    "pr_file": "shell/browser/native_window_views_win.cc",
    "created_at": "2025-05-28T22:01:13+00:00",
    "commented_code": "namespace {\n \n+void SetWindowBorderAndCaptionColor(HWND hwnd, COLORREF color) {\n+  if (base::win::GetVersion() < base::win::Version::WIN11)\n+    return;\n+\n+  HRESULT result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_CAPTION_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set caption color\";\n+\n+  result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_BORDER_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set border color\";\n+}\n+\n+DWORD GetAccentColor() {",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2112821601",
        "repo_full_name": "electron/electron",
        "pr_number": 47285,
        "pr_file": "shell/browser/native_window_views_win.cc",
        "discussion_id": "2112821601",
        "commented_code": "@@ -28,6 +28,53 @@ namespace electron {\n \n namespace {\n \n+void SetWindowBorderAndCaptionColor(HWND hwnd, COLORREF color) {\n+  if (base::win::GetVersion() < base::win::Version::WIN11)\n+    return;\n+\n+  HRESULT result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_CAPTION_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set caption color\";\n+\n+  result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_BORDER_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set border color\";\n+}\n+\n+DWORD GetAccentColor() {",
        "comment_created_at": "2025-05-28T22:01:13+00:00",
        "comment_author": "dsanders11",
        "comment_body": "```suggestion\r\nstd::optional<DWORD> GetAccentColor() {\r\n```\r\n\r\nIf the `RegOpenKeyEx` call fails, currently this would return `0` which would then most likely result in a border color of black? So seems best to guard against that case and ensure the returned value from `GetAccentColor` is valid before applying it.",
        "pr_file_module": null
      },
      {
        "comment_id": "2119778598",
        "repo_full_name": "electron/electron",
        "pr_number": 47285,
        "pr_file": "shell/browser/native_window_views_win.cc",
        "discussion_id": "2112821601",
        "commented_code": "@@ -28,6 +28,53 @@ namespace electron {\n \n namespace {\n \n+void SetWindowBorderAndCaptionColor(HWND hwnd, COLORREF color) {\n+  if (base::win::GetVersion() < base::win::Version::WIN11)\n+    return;\n+\n+  HRESULT result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_CAPTION_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set caption color\";\n+\n+  result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_BORDER_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set border color\";\n+}\n+\n+DWORD GetAccentColor() {",
        "comment_created_at": "2025-06-02T00:44:13+00:00",
        "comment_author": "ckerr",
        "comment_body": "Marking as unresolved since it looks like this was changed in `NativeWindowViews::UpdateWindowAccentColor()` but not here?\r\n\r\nThis function needs to return a `std::optional<DWORD>` in order for this block below to make sense:\r\n\r\n```c++\r\n    std::optional<DWORD> accent_color = GetAccentColor();\r\n    if (!accent_color.has_value())\r\n      return;\r\n```\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2120501283",
        "repo_full_name": "electron/electron",
        "pr_number": 47285,
        "pr_file": "shell/browser/native_window_views_win.cc",
        "discussion_id": "2112821601",
        "commented_code": "@@ -28,6 +28,53 @@ namespace electron {\n \n namespace {\n \n+void SetWindowBorderAndCaptionColor(HWND hwnd, COLORREF color) {\n+  if (base::win::GetVersion() < base::win::Version::WIN11)\n+    return;\n+\n+  HRESULT result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_CAPTION_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set caption color\";\n+\n+  result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_BORDER_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set border color\";\n+}\n+\n+DWORD GetAccentColor() {",
        "comment_created_at": "2025-06-02T09:01:52+00:00",
        "comment_author": "deepak1556",
        "comment_body": "Would also recommend to replace calls with the base utility for dealing with registry https://source.chromium.org/chromium/chromium/src/+/main:base/win/registry.h;l=24-33;",
        "pr_file_module": null
      },
      {
        "comment_id": "2124183894",
        "repo_full_name": "electron/electron",
        "pr_number": 47285,
        "pr_file": "shell/browser/native_window_views_win.cc",
        "discussion_id": "2112821601",
        "commented_code": "@@ -28,6 +28,53 @@ namespace electron {\n \n namespace {\n \n+void SetWindowBorderAndCaptionColor(HWND hwnd, COLORREF color) {\n+  if (base::win::GetVersion() < base::win::Version::WIN11)\n+    return;\n+\n+  HRESULT result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_CAPTION_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set caption color\";\n+\n+  result =\n+      DwmSetWindowAttribute(hwnd, DWMWA_BORDER_COLOR, &color, sizeof(color));\n+\n+  if (FAILED(result))\n+    LOG(WARNING) << \"Failed to set border color\";\n+}\n+\n+DWORD GetAccentColor() {",
        "comment_created_at": "2025-06-03T15:11:09+00:00",
        "comment_author": "codebytere",
        "comment_body": "@deepak1556 @dsanders11 done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1905883767",
    "pr_number": 45138,
    "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
    "created_at": "2025-01-07T18:27:33+00:00",
    "commented_code": "if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1905883767",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1905883767",
        "commented_code": "@@ -57,14 +62,19 @@\n   if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
        "comment_created_at": "2025-01-07T18:27:33+00:00",
        "comment_author": "ckerr",
        "comment_body": "This is slightly brittle, it's possible to give the optional a `nullptr` s.t. the optional is nonempty with a null pointer and this paragraph results in a nullptr dereference\r\n\r\nMaybe replace `std::optional<WebFrameMain*>` with just a `WebFrameMain*` that may be nullptr?",
        "pr_file_module": null
      },
      {
        "comment_id": "1906031843",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1905883767",
        "commented_code": "@@ -57,14 +62,19 @@\n   if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
        "comment_created_at": "2025-01-07T20:57:43+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "> Maybe replace std::optional<WebFrameMain*> with just a WebFrameMain* that may be nullptr?\r\n\r\nI don't think the current gin converter will take `Undefined` and convert it to `nullptr` \ud83e\udd14 Nor do I think it should. The `std::optional` converter was added to allow basically `null | undefined | T` conversions that previously weren't possible without manual gin incantations.\r\n\r\nGiven the above I don't think it's possible in this case to have the optional wrap a `nullptr` as the converter would never put one there, but that isn't enforced by semantics so I do see the issue still.\r\n\r\nMaybe the gin converter should go to `std::reference_wrapper<T>` instead of `T*` to indicate it's non-null nature, but thats a bit of a lift for the whole codebase ",
        "pr_file_module": null
      },
      {
        "comment_id": "1906137301",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1905883767",
        "commented_code": "@@ -57,14 +62,19 @@\n   if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
        "comment_created_at": "2025-01-07T23:00:42+00:00",
        "comment_author": "samuelmaddock",
        "comment_body": "Maybe an alternative could be to pass the [`content::GlobalRenderFrameHostToken`](https://source.chromium.org/chromium/chromium/src/+/main:content/public/browser/render_frame_host.h;l=238-240;drc=f4daadec4cf496926ed23bb014749f7df81f6221) and retrieve the RenderFrameHost when needed. The token is used internally by WebFrameMain to lookup the RenderFrameHost. It's also recommended by the docs.\r\n\r\n```cpp\r\n// Returns the GlobalRenderFrameHostToken for this frame. Embedders should\r\n// store this instead of a raw RenderFrameHost pointer.\r\nvirtual GlobalRenderFrameHostToken GetGlobalFrameToken() const = 0;\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1906140890",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1905883767",
        "commented_code": "@@ -57,14 +62,19 @@\n   if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
        "comment_created_at": "2025-01-07T23:06:30+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "@samuelmaddock This value comes from JS, do we have existing precedent for a `frameToken` being passed around \ud83e\udd14 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1906145097",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1905883767",
        "commented_code": "@@ -57,14 +62,19 @@\n   if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
        "comment_created_at": "2025-01-07T23:13:13+00:00",
        "comment_author": "samuelmaddock",
        "comment_body": "Ah sorry, I misunderstood the initial discussion. The `GlobalRenderFrameHostToken` could be an alternative to passing the weak ptr. I'm okay with either though.\r\n\r\nAs for the argument converter, I believe you could instead accept a `content::RenderFrameHost*` and it'll be converted from a WebFrameMain for you.\r\n\r\nhttps://github.com/electron/electron/blob/da8288106be98912bf58aba346e927d7395b1679/shell/common/gin_converters/frame_converter.cc#L37-L48",
        "pr_file_module": null
      },
      {
        "comment_id": "1906152517",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1905883767",
        "commented_code": "@@ -57,14 +62,19 @@\n   if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
        "comment_created_at": "2025-01-07T23:25:15+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "The problem is because the argument is optional, if I want to use a gin bound template It would need to be `std::optional<content::RenderFrameHost*>` which then has the same three state issue that @ckerr pointed out, of being `nullptr`, `nullopt` and `T*`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1907145408",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1905883767",
        "commented_code": "@@ -57,14 +62,19 @@\n   if (!native_window)\n     return;\n \n+  base::WeakPtr<WebFrameMain> weak_frame;\n+  if (frame) {",
        "comment_created_at": "2025-01-08T12:58:34+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "I opted for a `foo && foo.value()` check to ensure no nullptr in this case, I think it would be good to consider a codebase wide change to something more declarative like `std::reference_wrapper` but that requires more thought / everything doing it so for now I'll just make this bit ok",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1987910397",
    "pr_number": 45138,
    "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
    "created_at": "2025-03-10T19:38:29+00:00",
    "commented_code": "position.x = position.x - [menu size].width;\n \n   [popup_controllers_[window_id] setCloseCallback:std::move(close_callback)];\n-  // Make sure events can be pumped while the menu is up.\n-  base::CurrentThread::ScopedAllowApplicationTasksInNativeNestedLoop allow;\n-\n-  // One of the events that could be pumped is |window.close()|.\n-  // User-initiated event-tracking loops protect against this by\n-  // setting flags in -[CrApplication sendEvent:], but since\n-  // web-content menus are initiated by IPC message the setup has to\n-  // be done manually.\n-  base::mac::ScopedSendingEvent sendingEventScoper;\n-\n-  // Don't emit unresponsive event when showing menu.\n-  [menu popUpMenuPositioningItem:item atLocation:position inView:view];\n+\n+  if (frame) {\n+    auto* rfh = frame->render_frame_host()->GetOutermostMainFrameOrEmbedder();",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1987910397",
        "repo_full_name": "electron/electron",
        "pr_number": 45138,
        "pr_file": "shell/browser/api/electron_api_menu_mac.mm",
        "discussion_id": "1987910397",
        "commented_code": "@@ -145,18 +156,27 @@\n     position.x = position.x - [menu size].width;\n \n   [popup_controllers_[window_id] setCloseCallback:std::move(close_callback)];\n-  // Make sure events can be pumped while the menu is up.\n-  base::CurrentThread::ScopedAllowApplicationTasksInNativeNestedLoop allow;\n-\n-  // One of the events that could be pumped is |window.close()|.\n-  // User-initiated event-tracking loops protect against this by\n-  // setting flags in -[CrApplication sendEvent:], but since\n-  // web-content menus are initiated by IPC message the setup has to\n-  // be done manually.\n-  base::mac::ScopedSendingEvent sendingEventScoper;\n-\n-  // Don't emit unresponsive event when showing menu.\n-  [menu popUpMenuPositioningItem:item atLocation:position inView:view];\n+\n+  if (frame) {\n+    auto* rfh = frame->render_frame_host()->GetOutermostMainFrameOrEmbedder();",
        "comment_created_at": "2025-03-10T19:38:29+00:00",
        "comment_author": "samuelmaddock",
        "comment_body": "Probably worth checking this since it can be a nullptr\r\n```suggestion\r\n    auto* frame_rfh = frame->render_frame_host();\r\n    auto* rfh = frame_rfh ? frame_rfh->GetOutermostMainFrameOrEmbedder() : nullptr;\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2017302186",
    "pr_number": 46264,
    "pr_file": "shell/browser/net/electron_url_loader_factory.cc",
    "created_at": "2025-03-27T17:50:36+00:00",
    "commented_code": "request->method != net::HttpRequestHeaders::kHeadMethod)\n     dict.Get(\"uploadData\", &upload_data);\n \n-  auto* browser_context = ElectronBrowserContext::GetDefaultBrowserContext();\n-  v8::Local<v8::Value> value;\n-  if (dict.Get(\"session\", &value)) {\n-    if (value->IsNull()) {\n-      browser_context = ElectronBrowserContext::From(\n-          base::Uuid::GenerateRandomV4().AsLowercaseString(), true);\n-    } else {\n-      gin::Handle<api::Session> session;\n-      if (gin::ConvertFromV8(dict.isolate(), value, &session) &&\n-          !session.IsEmpty()) {\n-        browser_context = session->browser_context();\n-      }\n-    }\n-  }\n+  gin::Handle<api::Session> session;\n+  auto* browser_context =\n+      dict.Get(\"session\", &session) && !session.IsEmpty()",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2017302186",
        "repo_full_name": "electron/electron",
        "pr_number": 46264,
        "pr_file": "shell/browser/net/electron_url_loader_factory.cc",
        "discussion_id": "2017302186",
        "commented_code": "@@ -671,20 +670,11 @@ void ElectronURLLoaderFactory::StartLoadingHttp(\n       request->method != net::HttpRequestHeaders::kHeadMethod)\n     dict.Get(\"uploadData\", &upload_data);\n \n-  auto* browser_context = ElectronBrowserContext::GetDefaultBrowserContext();\n-  v8::Local<v8::Value> value;\n-  if (dict.Get(\"session\", &value)) {\n-    if (value->IsNull()) {\n-      browser_context = ElectronBrowserContext::From(\n-          base::Uuid::GenerateRandomV4().AsLowercaseString(), true);\n-    } else {\n-      gin::Handle<api::Session> session;\n-      if (gin::ConvertFromV8(dict.isolate(), value, &session) &&\n-          !session.IsEmpty()) {\n-        browser_context = session->browser_context();\n-      }\n-    }\n-  }\n+  gin::Handle<api::Session> session;\n+  auto* browser_context =\n+      dict.Get(\"session\", &session) && !session.IsEmpty()",
        "comment_created_at": "2025-03-27T17:50:36+00:00",
        "comment_author": "itsananderson",
        "comment_body": "If someone passes `null` (or some other value that's not a Session), then `session.IsEmpty()` will be `true`, correct? In other words, existing code will fall back to the default browser context rather than crashing?",
        "pr_file_module": null
      },
      {
        "comment_id": "2017490236",
        "repo_full_name": "electron/electron",
        "pr_number": 46264,
        "pr_file": "shell/browser/net/electron_url_loader_factory.cc",
        "discussion_id": "2017302186",
        "commented_code": "@@ -671,20 +670,11 @@ void ElectronURLLoaderFactory::StartLoadingHttp(\n       request->method != net::HttpRequestHeaders::kHeadMethod)\n     dict.Get(\"uploadData\", &upload_data);\n \n-  auto* browser_context = ElectronBrowserContext::GetDefaultBrowserContext();\n-  v8::Local<v8::Value> value;\n-  if (dict.Get(\"session\", &value)) {\n-    if (value->IsNull()) {\n-      browser_context = ElectronBrowserContext::From(\n-          base::Uuid::GenerateRandomV4().AsLowercaseString(), true);\n-    } else {\n-      gin::Handle<api::Session> session;\n-      if (gin::ConvertFromV8(dict.isolate(), value, &session) &&\n-          !session.IsEmpty()) {\n-        browser_context = session->browser_context();\n-      }\n-    }\n-  }\n+  gin::Handle<api::Session> session;\n+  auto* browser_context =\n+      dict.Get(\"session\", &session) && !session.IsEmpty()",
        "comment_created_at": "2025-03-27T19:31:16+00:00",
        "comment_author": "ckerr",
        "comment_body": "Yes, that's correct. If the `session` property refers to a pre-existing session, it will be used. Otherwise, the default session is used.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "600271431",
    "pr_number": 27917,
    "pr_file": "shell/browser/api/electron_api_session.h",
    "created_at": "2021-03-24T08:38:22+00:00",
    "commented_code": "void OnExtensionUnloaded(content::BrowserContext* browser_context,\n                            const extensions::Extension* extension,\n                            extensions::UnloadedExtensionReason reason) override;\n+\n+  void SetExtensionAPIHandlers(const gin_helper::Dictionary& api,\n+                               gin::Arguments* args);\n+  std::unique_ptr<ExtensionTabDetails> GetExtensionTabDetails(",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "600271431",
        "repo_full_name": "electron/electron",
        "pr_number": 27917,
        "pr_file": "shell/browser/api/electron_api_session.h",
        "discussion_id": "600271431",
        "commented_code": "@@ -150,6 +174,12 @@ class Session : public gin::Wrappable<Session>,\n   void OnExtensionUnloaded(content::BrowserContext* browser_context,\n                            const extensions::Extension* extension,\n                            extensions::UnloadedExtensionReason reason) override;\n+\n+  void SetExtensionAPIHandlers(const gin_helper::Dictionary& api,\n+                               gin::Arguments* args);\n+  std::unique_ptr<ExtensionTabDetails> GetExtensionTabDetails(",
        "comment_created_at": "2021-03-24T08:38:22+00:00",
        "comment_author": "zcbenz",
        "comment_body": "For returning nullable value, the recommended coding style is to return `base::Optional<ExtensionTabDetails>`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "646097995",
    "pr_number": 27917,
    "pr_file": "shell/browser/api/electron_api_session.cc",
    "created_at": "2021-06-06T08:40:14+00:00",
    "commented_code": "const extensions::Extension* extension) {\n   Emit(\"extension-ready\", extension);\n }\n+\n+void Session::SetExtensionAPIHandlers(const gin_helper::Dictionary& api,\n+                                      gin::Arguments* args) {\n+  v8::Local<v8::Value> value;\n+  GetTabHandler get_tab_handler;\n+  bool set_get_tab_handler = false;\n+  GetActiveTabHandler get_active_tab_handler;\n+  bool set_get_active_tab_handler = false;\n+\n+  if (api.Get(\"getTab\", &value)) {\n+    if (value->IsNull() ||\n+        gin::ConvertFromV8(args->isolate(), value, &get_tab_handler)) {\n+      set_get_tab_handler = true;\n+    } else {\n+      args->ThrowTypeError(\"getTab must be a function or null.\");\n+      return;\n+    }\n+  }\n+\n+  if (api.Get(\"getActiveTab\", &value)) {\n+    if (value->IsNull() ||\n+        gin::ConvertFromV8(args->isolate(), value, &get_active_tab_handler)) {\n+      set_get_active_tab_handler = true;\n+    } else {\n+      args->ThrowTypeError(\"getActiveTab must be a function or null.\");\n+      return;\n+    }\n+  }\n+\n+  if (set_get_tab_handler)\n+    get_tab_handler_ = std::move(get_tab_handler);\n+  if (set_get_active_tab_handler)\n+    get_active_tab_handler_ = std::move(get_active_tab_handler);\n+}\n+\n+base::Optional<ExtensionTabDetails> Session::GetExtensionTabDetails(",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "646097995",
        "repo_full_name": "electron/electron",
        "pr_number": 27917,
        "pr_file": "shell/browser/api/electron_api_session.cc",
        "discussion_id": "646097995",
        "commented_code": "@@ -867,6 +901,89 @@ void Session::OnExtensionReady(content::BrowserContext* browser_context,\n                                const extensions::Extension* extension) {\n   Emit(\"extension-ready\", extension);\n }\n+\n+void Session::SetExtensionAPIHandlers(const gin_helper::Dictionary& api,\n+                                      gin::Arguments* args) {\n+  v8::Local<v8::Value> value;\n+  GetTabHandler get_tab_handler;\n+  bool set_get_tab_handler = false;\n+  GetActiveTabHandler get_active_tab_handler;\n+  bool set_get_active_tab_handler = false;\n+\n+  if (api.Get(\"getTab\", &value)) {\n+    if (value->IsNull() ||\n+        gin::ConvertFromV8(args->isolate(), value, &get_tab_handler)) {\n+      set_get_tab_handler = true;\n+    } else {\n+      args->ThrowTypeError(\"getTab must be a function or null.\");\n+      return;\n+    }\n+  }\n+\n+  if (api.Get(\"getActiveTab\", &value)) {\n+    if (value->IsNull() ||\n+        gin::ConvertFromV8(args->isolate(), value, &get_active_tab_handler)) {\n+      set_get_active_tab_handler = true;\n+    } else {\n+      args->ThrowTypeError(\"getActiveTab must be a function or null.\");\n+      return;\n+    }\n+  }\n+\n+  if (set_get_tab_handler)\n+    get_tab_handler_ = std::move(get_tab_handler);\n+  if (set_get_active_tab_handler)\n+    get_active_tab_handler_ = std::move(get_active_tab_handler);\n+}\n+\n+base::Optional<ExtensionTabDetails> Session::GetExtensionTabDetails(",
        "comment_created_at": "2021-06-06T08:40:14+00:00",
        "comment_author": "dsanders11",
        "comment_body": "`base::Optional` was removed upstream, so all uses of `base::Optional` and `base::nullopt` need to be changed to `absl::optional` and `absl::nullopt`, etc.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "818011269",
    "pr_number": 27917,
    "pr_file": "shell/browser/extensions/extension_tab_util.cc",
    "created_at": "2022-03-02T19:06:05+00:00",
    "commented_code": "+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \"shell/browser/extensions/extension_tab_util.h\"\n+\n+#include <iostream>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"base/stl_util.h\"\n+#include \"base/strings/pattern.h\"\n+#include \"chrome/browser/extensions/api/tabs/tabs_constants.h\"\n+#include \"chrome/common/webui_url_constants.h\"\n+#include \"components/url_formatter/url_fixer.h\"\n+#include \"content/public/browser/browser_context.h\"\n+#include \"content/public/browser/favicon_status.h\"\n+#include \"content/public/browser/navigation_controller.h\"\n+#include \"content/public/browser/navigation_entry.h\"\n+#include \"content/public/browser/render_process_host.h\"\n+#include \"content/public/browser/web_contents.h\"\n+#include \"content/public/common/url_constants.h\"\n+#include \"electron/shell/common/extensions/api/tabs.h\"\n+#include \"extensions/browser/extension_api_frame_id_map.h\"\n+#include \"extensions/common/error_utils.h\"\n+#include \"extensions/common/manifest_constants.h\"\n+#include \"extensions/common/manifest_handlers/incognito_info.h\"\n+#include \"extensions/common/permissions/api_permission.h\"\n+#include \"extensions/common/permissions/permissions_data.h\"\n+#include \"shell/browser/api/electron_api_session.h\"\n+#include \"shell/browser/api/electron_api_web_contents.h\"\n+#include \"shell/browser/native_window.h\"\n+#include \"shell/browser/web_contents_zoom_controller.h\"\n+#include \"shell/browser/window_list.h\"\n+#include \"third_party/blink/public/common/page/page_zoom.h\"\n+\n+using content::NavigationEntry;\n+using content::WebContents;\n+using extensions::mojom::APIPermissionID;\n+\n+namespace extensions {\n+\n+ExtensionTabUtil::ScrubTabBehaviorType GetScrubTabBehaviorImpl(\n+    const Extension* extension,\n+    Feature::Context context,\n+    const GURL& url,\n+    int tab_id) {\n+  if (context == Feature::Context::WEBUI_CONTEXT) {\n+    return ExtensionTabUtil::kDontScrubTab;\n+  }\n+\n+  if (context == Feature::Context::WEBUI_UNTRUSTED_CONTEXT) {\n+    return ExtensionTabUtil::kScrubTabFully;\n+  }\n+\n+  bool has_permission = false;\n+\n+  if (extension) {\n+    bool api_permission = false;\n+    if (tab_id == -1) {\n+      api_permission = extension->permissions_data()->HasAPIPermission(\n+          APIPermissionID::kTab);\n+    } else {\n+      api_permission = extension->permissions_data()->HasAPIPermissionForTab(\n+          tab_id, APIPermissionID::kTab);\n+    }\n+\n+    bool host_permission = extension->permissions_data()\n+                               ->active_permissions()\n+                               .HasExplicitAccessToOrigin(url);\n+    has_permission = api_permission || host_permission;\n+  }\n+\n+  if (!has_permission) {\n+    return ExtensionTabUtil::kScrubTabFully;\n+  }\n+\n+  return ExtensionTabUtil::kDontScrubTab;\n+}\n+\n+ExtensionTabUtil::ScrubTabBehavior ExtensionTabUtil::GetScrubTabBehavior(\n+    const Extension* extension,\n+    Feature::Context context,\n+    content::WebContents* contents) {\n+  auto* api_wc = electron::api::WebContents::From(contents);\n+\n+  ScrubTabBehavior behavior;\n+  behavior.committed_info = GetScrubTabBehaviorImpl(\n+      extension, context, contents->GetLastCommittedURL(), api_wc->ID());\n+  NavigationEntry* entry = contents->GetController().GetPendingEntry();\n+  GURL pending_url;\n+  if (entry) {\n+    pending_url = entry->GetVirtualURL();\n+  }\n+  behavior.pending_info =\n+      GetScrubTabBehaviorImpl(extension, context, pending_url, api_wc->ID());\n+  return behavior;\n+}\n+\n+void ExtensionTabUtil::ScrubTabForExtension(\n+    const Extension* extension,\n+    content::WebContents* contents,\n+    api::tabs::Tab* tab,\n+    ExtensionTabUtil::ScrubTabBehavior scrub_tab_behavior) {\n+  // Remove sensitive committed tab info if necessary.\n+  switch (scrub_tab_behavior.committed_info) {\n+    case kScrubTabFully:\n+      tab->url.reset();\n+      tab->title.reset();\n+      tab->fav_icon_url.reset();\n+      break;\n+    case kScrubTabUrlToOrigin:\n+      tab->url =\n+          std::make_unique<std::string>(GURL(*tab->url).GetOrigin().spec());\n+      break;\n+    case kDontScrubTab:\n+      break;\n+  }\n+\n+  // Remove sensitive pending tab info if necessary.\n+  if (tab->pending_url) {\n+    switch (scrub_tab_behavior.pending_info) {\n+      case kScrubTabFully:\n+        tab->pending_url.reset();\n+        break;\n+      case kScrubTabUrlToOrigin:\n+        tab->pending_url = std::make_unique<std::string>(\n+            GURL(*tab->pending_url).GetOrigin().spec());\n+        break;\n+      case kDontScrubTab:\n+        break;\n+    }\n+  }\n+}\n+\n+electron::api::WebContents* ExtensionTabUtil::GetWebContentsById(int tab_id) {\n+  return electron::api::WebContents::FromID(tab_id);\n+}\n+\n+absl::optional<electron::api::ExtensionTabDetails>\n+ExtensionTabUtil::GetTabDetailsFromWebContents(\n+    electron::api::WebContents* contents) {\n+  if (!contents)\n+    return absl::nullopt;\n+  return electron::api::Session::FromBrowserContext(\n+             contents->web_contents()->GetBrowserContext())\n+      ->GetExtensionTabDetails(contents);\n+}\n+\n+int ExtensionTabUtil::GetTabId(WebContents* web_contents) {\n+  return electron::api::WebContents::From(web_contents)->ID();",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "818011269",
        "repo_full_name": "electron/electron",
        "pr_number": 27917,
        "pr_file": "shell/browser/extensions/extension_tab_util.cc",
        "discussion_id": "818011269",
        "commented_code": "@@ -0,0 +1,251 @@\n+// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \"shell/browser/extensions/extension_tab_util.h\"\n+\n+#include <iostream>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"base/stl_util.h\"\n+#include \"base/strings/pattern.h\"\n+#include \"chrome/browser/extensions/api/tabs/tabs_constants.h\"\n+#include \"chrome/common/webui_url_constants.h\"\n+#include \"components/url_formatter/url_fixer.h\"\n+#include \"content/public/browser/browser_context.h\"\n+#include \"content/public/browser/favicon_status.h\"\n+#include \"content/public/browser/navigation_controller.h\"\n+#include \"content/public/browser/navigation_entry.h\"\n+#include \"content/public/browser/render_process_host.h\"\n+#include \"content/public/browser/web_contents.h\"\n+#include \"content/public/common/url_constants.h\"\n+#include \"electron/shell/common/extensions/api/tabs.h\"\n+#include \"extensions/browser/extension_api_frame_id_map.h\"\n+#include \"extensions/common/error_utils.h\"\n+#include \"extensions/common/manifest_constants.h\"\n+#include \"extensions/common/manifest_handlers/incognito_info.h\"\n+#include \"extensions/common/permissions/api_permission.h\"\n+#include \"extensions/common/permissions/permissions_data.h\"\n+#include \"shell/browser/api/electron_api_session.h\"\n+#include \"shell/browser/api/electron_api_web_contents.h\"\n+#include \"shell/browser/native_window.h\"\n+#include \"shell/browser/web_contents_zoom_controller.h\"\n+#include \"shell/browser/window_list.h\"\n+#include \"third_party/blink/public/common/page/page_zoom.h\"\n+\n+using content::NavigationEntry;\n+using content::WebContents;\n+using extensions::mojom::APIPermissionID;\n+\n+namespace extensions {\n+\n+ExtensionTabUtil::ScrubTabBehaviorType GetScrubTabBehaviorImpl(\n+    const Extension* extension,\n+    Feature::Context context,\n+    const GURL& url,\n+    int tab_id) {\n+  if (context == Feature::Context::WEBUI_CONTEXT) {\n+    return ExtensionTabUtil::kDontScrubTab;\n+  }\n+\n+  if (context == Feature::Context::WEBUI_UNTRUSTED_CONTEXT) {\n+    return ExtensionTabUtil::kScrubTabFully;\n+  }\n+\n+  bool has_permission = false;\n+\n+  if (extension) {\n+    bool api_permission = false;\n+    if (tab_id == -1) {\n+      api_permission = extension->permissions_data()->HasAPIPermission(\n+          APIPermissionID::kTab);\n+    } else {\n+      api_permission = extension->permissions_data()->HasAPIPermissionForTab(\n+          tab_id, APIPermissionID::kTab);\n+    }\n+\n+    bool host_permission = extension->permissions_data()\n+                               ->active_permissions()\n+                               .HasExplicitAccessToOrigin(url);\n+    has_permission = api_permission || host_permission;\n+  }\n+\n+  if (!has_permission) {\n+    return ExtensionTabUtil::kScrubTabFully;\n+  }\n+\n+  return ExtensionTabUtil::kDontScrubTab;\n+}\n+\n+ExtensionTabUtil::ScrubTabBehavior ExtensionTabUtil::GetScrubTabBehavior(\n+    const Extension* extension,\n+    Feature::Context context,\n+    content::WebContents* contents) {\n+  auto* api_wc = electron::api::WebContents::From(contents);\n+\n+  ScrubTabBehavior behavior;\n+  behavior.committed_info = GetScrubTabBehaviorImpl(\n+      extension, context, contents->GetLastCommittedURL(), api_wc->ID());\n+  NavigationEntry* entry = contents->GetController().GetPendingEntry();\n+  GURL pending_url;\n+  if (entry) {\n+    pending_url = entry->GetVirtualURL();\n+  }\n+  behavior.pending_info =\n+      GetScrubTabBehaviorImpl(extension, context, pending_url, api_wc->ID());\n+  return behavior;\n+}\n+\n+void ExtensionTabUtil::ScrubTabForExtension(\n+    const Extension* extension,\n+    content::WebContents* contents,\n+    api::tabs::Tab* tab,\n+    ExtensionTabUtil::ScrubTabBehavior scrub_tab_behavior) {\n+  // Remove sensitive committed tab info if necessary.\n+  switch (scrub_tab_behavior.committed_info) {\n+    case kScrubTabFully:\n+      tab->url.reset();\n+      tab->title.reset();\n+      tab->fav_icon_url.reset();\n+      break;\n+    case kScrubTabUrlToOrigin:\n+      tab->url =\n+          std::make_unique<std::string>(GURL(*tab->url).GetOrigin().spec());\n+      break;\n+    case kDontScrubTab:\n+      break;\n+  }\n+\n+  // Remove sensitive pending tab info if necessary.\n+  if (tab->pending_url) {\n+    switch (scrub_tab_behavior.pending_info) {\n+      case kScrubTabFully:\n+        tab->pending_url.reset();\n+        break;\n+      case kScrubTabUrlToOrigin:\n+        tab->pending_url = std::make_unique<std::string>(\n+            GURL(*tab->pending_url).GetOrigin().spec());\n+        break;\n+      case kDontScrubTab:\n+        break;\n+    }\n+  }\n+}\n+\n+electron::api::WebContents* ExtensionTabUtil::GetWebContentsById(int tab_id) {\n+  return electron::api::WebContents::FromID(tab_id);\n+}\n+\n+absl::optional<electron::api::ExtensionTabDetails>\n+ExtensionTabUtil::GetTabDetailsFromWebContents(\n+    electron::api::WebContents* contents) {\n+  if (!contents)\n+    return absl::nullopt;\n+  return electron::api::Session::FromBrowserContext(\n+             contents->web_contents()->GetBrowserContext())\n+      ->GetExtensionTabDetails(contents);\n+}\n+\n+int ExtensionTabUtil::GetTabId(WebContents* web_contents) {\n+  return electron::api::WebContents::From(web_contents)->ID();",
        "comment_created_at": "2022-03-02T19:06:05+00:00",
        "comment_author": "samuelmaddock",
        "comment_body": "```suggestion\r\n  auto* contents = electron::api::WebContents::From(web_contents);\r\n  return contents ? contents->ID() : -1;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]