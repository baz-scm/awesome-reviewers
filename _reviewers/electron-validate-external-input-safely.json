[
  {
    "discussion_id": "2014398027",
    "pr_number": 45934,
    "pr_file": "shell/browser/api/electron_api_session.cc",
    "created_at": "2025-03-26T15:10:16+00:00",
    "commented_code": "blink::PermissionType permission_type,\n          ElectronPermissionManager::StatusCallback callback,\n          const base::Value& details) {\n+#if (BUILDFLAG(IS_MAC))\n+        if (permission_type == blink::PermissionType::GEOLOCATION) {\n+          auto* command_line = base::CommandLine::ForCurrentProcess();\n+          if (command_line->HasSwitch(\"disable-geolocation\")) {\n+            std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\n+            return;\n+          }\n+        }\n+#endif",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "2014398027",
        "repo_full_name": "electron/electron",
        "pr_number": 45934,
        "pr_file": "shell/browser/api/electron_api_session.cc",
        "discussion_id": "2014398027",
        "commented_code": "@@ -853,6 +853,15 @@ void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,\n          blink::PermissionType permission_type,\n          ElectronPermissionManager::StatusCallback callback,\n          const base::Value& details) {\n+#if (BUILDFLAG(IS_MAC))\n+        if (permission_type == blink::PermissionType::GEOLOCATION) {\n+          auto* command_line = base::CommandLine::ForCurrentProcess();\n+          if (command_line->HasSwitch(\"disable-geolocation\")) {\n+            std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\n+            return;\n+          }\n+        }\n+#endif",
        "comment_created_at": "2025-03-26T15:10:16+00:00",
        "comment_author": "nilayarya",
        "comment_body": "We deny geolocation request internally and return before custom callback can be called. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2037918796",
        "repo_full_name": "electron/electron",
        "pr_number": 45934,
        "pr_file": "shell/browser/api/electron_api_session.cc",
        "discussion_id": "2014398027",
        "commented_code": "@@ -853,6 +853,15 @@ void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,\n          blink::PermissionType permission_type,\n          ElectronPermissionManager::StatusCallback callback,\n          const base::Value& details) {\n+#if (BUILDFLAG(IS_MAC))\n+        if (permission_type == blink::PermissionType::GEOLOCATION) {\n+          auto* command_line = base::CommandLine::ForCurrentProcess();\n+          if (command_line->HasSwitch(\"disable-geolocation\")) {\n+            std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\n+            return;\n+          }\n+        }\n+#endif",
        "comment_created_at": "2025-04-10T17:24:23+00:00",
        "comment_author": "itsananderson",
        "comment_body": "What if an app wants to `--disable-geolocation` but still wants to track requests for geolocation? Would it be possible to still invoke the custom callback, but deny the permissions request regardless of the response?",
        "pr_file_module": null
      },
      {
        "comment_id": "2038699588",
        "repo_full_name": "electron/electron",
        "pr_number": 45934,
        "pr_file": "shell/browser/api/electron_api_session.cc",
        "discussion_id": "2014398027",
        "commented_code": "@@ -853,6 +853,15 @@ void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,\n          blink::PermissionType permission_type,\n          ElectronPermissionManager::StatusCallback callback,\n          const base::Value& details) {\n+#if (BUILDFLAG(IS_MAC))\n+        if (permission_type == blink::PermissionType::GEOLOCATION) {\n+          auto* command_line = base::CommandLine::ForCurrentProcess();\n+          if (command_line->HasSwitch(\"disable-geolocation\")) {\n+            std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\n+            return;\n+          }\n+        }\n+#endif",
        "comment_created_at": "2025-04-11T02:16:48+00:00",
        "comment_author": "nilayarya",
        "comment_body": "Yes possible. Wrapping the custom callback like this works:\r\nAt Line 856\r\n```c++\r\n#if (BUILDFLAG(IS_MAC))\r\n        if (permission_type == blink::PermissionType::GEOLOCATION) {\r\n          if (IsGeolocationDisabledViaCommandLine()) {\r\n            auto original_callback = std::move(callback);\r\n            callback = base::BindOnce(\r\n                [](ElectronPermissionManager::StatusCallback callback, \r\n                   blink::mojom::PermissionStatus /*ignored_status*/) {\r\n                  // Always deny regardless of what blink::mojom::PermissionStatus is passed here\r\n                  std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\r\n                },\r\n                std::move(original_callback));\r\n          }\r\n        }\r\n#endif\r\n        handler->Run(web_contents, permission_type, std::move(callback),\r\n                     details);\r\n```\r\nShould I push this up?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2049396972",
        "repo_full_name": "electron/electron",
        "pr_number": 45934,
        "pr_file": "shell/browser/api/electron_api_session.cc",
        "discussion_id": "2014398027",
        "commented_code": "@@ -853,6 +853,15 @@ void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,\n          blink::PermissionType permission_type,\n          ElectronPermissionManager::StatusCallback callback,\n          const base::Value& details) {\n+#if (BUILDFLAG(IS_MAC))\n+        if (permission_type == blink::PermissionType::GEOLOCATION) {\n+          auto* command_line = base::CommandLine::ForCurrentProcess();\n+          if (command_line->HasSwitch(\"disable-geolocation\")) {\n+            std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\n+            return;\n+          }\n+        }\n+#endif",
        "comment_created_at": "2025-04-17T17:36:15+00:00",
        "comment_author": "itsananderson",
        "comment_body": "Yep, this is what I was thinking \ud83d\udc4d ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1918845191",
    "pr_number": 45221,
    "pr_file": "shell/common/node_bindings.cc",
    "created_at": "2025-01-16T16:23:01+00:00",
    "commented_code": "env->GetVar(\"NODE_OPTIONS\", &options);\n       std::vector<std::string> parts = base::SplitString(\n           options, \" \", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n-\n+      \n       bool is_packaged_app = electron::api::App::IsPackaged();\n \n+      if (env->HasVar(\"ELECTRON_LESS_RESTRICTIVE_NODE_OPTIONS_IN_PACKAGED_APP\") {",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "1918845191",
        "repo_full_name": "electron/electron",
        "pr_number": 45221,
        "pr_file": "shell/common/node_bindings.cc",
        "discussion_id": "1918845191",
        "commented_code": "@@ -368,9 +374,13 @@ void SetNodeOptions(base::Environment* env) {\n       env->GetVar(\"NODE_OPTIONS\", &options);\n       std::vector<std::string> parts = base::SplitString(\n           options, \" \", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n-\n+      \n       bool is_packaged_app = electron::api::App::IsPackaged();\n \n+      if (env->HasVar(\"ELECTRON_LESS_RESTRICTIVE_NODE_OPTIONS_IN_PACKAGED_APP\") {",
        "comment_created_at": "2025-01-16T16:23:01+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "This is incredibly dangerous, please remove this feature from this PR as it is basically a giant security hole. Apps should only ever be told \"you are packaged\" never the inverse.",
        "pr_file_module": null
      },
      {
        "comment_id": "1919439961",
        "repo_full_name": "electron/electron",
        "pr_number": 45221,
        "pr_file": "shell/common/node_bindings.cc",
        "discussion_id": "1918845191",
        "commented_code": "@@ -368,9 +374,13 @@ void SetNodeOptions(base::Environment* env) {\n       env->GetVar(\"NODE_OPTIONS\", &options);\n       std::vector<std::string> parts = base::SplitString(\n           options, \" \", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n-\n+      \n       bool is_packaged_app = electron::api::App::IsPackaged();\n \n+      if (env->HasVar(\"ELECTRON_LESS_RESTRICTIVE_NODE_OPTIONS_IN_PACKAGED_APP\") {",
        "comment_created_at": "2025-01-17T01:35:59+00:00",
        "comment_author": "nikwen",
        "comment_body": "Thanks, @MarshallOfSound! I'd also expect the PR not to compile because there seems to be a parenthesis missing here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1921515429",
        "repo_full_name": "electron/electron",
        "pr_number": 45221,
        "pr_file": "shell/common/node_bindings.cc",
        "discussion_id": "1918845191",
        "commented_code": "@@ -368,9 +374,13 @@ void SetNodeOptions(base::Environment* env) {\n       env->GetVar(\"NODE_OPTIONS\", &options);\n       std::vector<std::string> parts = base::SplitString(\n           options, \" \", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n-\n+      \n       bool is_packaged_app = electron::api::App::IsPackaged();\n \n+      if (env->HasVar(\"ELECTRON_LESS_RESTRICTIVE_NODE_OPTIONS_IN_PACKAGED_APP\") {",
        "comment_created_at": "2025-01-19T09:55:29+00:00",
        "comment_author": "James4Ever0",
        "comment_body": "I have removed this security flaw.",
        "pr_file_module": null
      },
      {
        "comment_id": "1922919454",
        "repo_full_name": "electron/electron",
        "pr_number": 45221,
        "pr_file": "shell/common/node_bindings.cc",
        "discussion_id": "1918845191",
        "commented_code": "@@ -368,9 +374,13 @@ void SetNodeOptions(base::Environment* env) {\n       env->GetVar(\"NODE_OPTIONS\", &options);\n       std::vector<std::string> parts = base::SplitString(\n           options, \" \", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n-\n+      \n       bool is_packaged_app = electron::api::App::IsPackaged();\n \n+      if (env->HasVar(\"ELECTRON_LESS_RESTRICTIVE_NODE_OPTIONS_IN_PACKAGED_APP\") {",
        "comment_created_at": "2025-01-20T23:56:24+00:00",
        "comment_author": "James4Ever0",
        "comment_body": "> Thanks, @MarshallOfSound! I'd also expect the PR not to compile because there seems to be a parenthesis missing here.\n\nDid you mean by adding back the parenthesis the security issue is not of any concern?",
        "pr_file_module": null
      },
      {
        "comment_id": "1922919915",
        "repo_full_name": "electron/electron",
        "pr_number": 45221,
        "pr_file": "shell/common/node_bindings.cc",
        "discussion_id": "1918845191",
        "commented_code": "@@ -368,9 +374,13 @@ void SetNodeOptions(base::Environment* env) {\n       env->GetVar(\"NODE_OPTIONS\", &options);\n       std::vector<std::string> parts = base::SplitString(\n           options, \" \", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);\n-\n+      \n       bool is_packaged_app = electron::api::App::IsPackaged();\n \n+      if (env->HasVar(\"ELECTRON_LESS_RESTRICTIVE_NODE_OPTIONS_IN_PACKAGED_APP\") {",
        "comment_created_at": "2025-01-20T23:57:40+00:00",
        "comment_author": "nikwen",
        "comment_body": "> Did you mean by adding back the parenthesis the security issue is not of any concern?\r\n\r\nNo!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "999304186",
    "pr_number": 35810,
    "pr_file": "shell/browser/notifications/win/windows_toast_notification.cc",
    "created_at": "2022-10-19T11:17:18+00:00",
    "commented_code": "return S_OK;\n }\n \n+struct CoTaskMemStringTraits {\n+  typedef PWSTR Type;\n+\n+  inline static bool Close(_In_ Type h) throw() {\n+    ::CoTaskMemFree(h);\n+    return true;\n+  }\n+\n+  inline static Type GetInvalidValue() throw() { return nullptr; }\n+};\n+typedef HandleT<CoTaskMemStringTraits> CoTaskMemString;\n+\n+// #pragma GCC diagnostic push\n+// #pragma GCC diagnostic ignored \"-Wmissing-braces\"\n+// #pragma GCC diagnostic ignored \"-Wc++98-compat-extra-semi\"\n+//  For the app to be activated from Action Center, it needs to provide a COM\n+//  server to be called when the notification is activated.  The CLSID of the\n+//  object needs t  registered with the OS via its shortcut so that it knows\n+//  who to call later.\n+class NotificationActivator final\n+    : public RuntimeClass<RuntimeClassFlags<ClassicCom>,\n+                          INotificationActivationCallback> {\n+ public:\n+  HRESULT STDMETHODCALLTYPE\n+  Activate(_In_ LPCWSTR appUserModelId,\n+           _In_ LPCWSTR invokedArgs,\n+           _In_reads_(dataCount) const NOTIFICATION_USER_INPUT_DATA* data,\n+           ULONG dataCount) override {\n+    // packing user input structs into stream\n+    std::wstringstream stm;\n+    // feat: Refine notification-activation for cold start\n+    if (dataCount) {\n+      stm << L\"[\";  // json array open brace\n+      std::for_each(data, data + dataCount,\n+                    [&](const NOTIFICATION_USER_INPUT_DATA& item) {\n+                      stm << item\n+                          // avoid problem with last delimeter\n+                          << std::wstring((static_cast<ULONG>(&item - data +\n+                                                              1) == dataCount)\n+                                              ? L\"\"\n+                                              : L\",\");\n+                    });\n+      stm << L\"]\";  // json array close brace",
    "repo_full_name": "electron/electron",
    "discussion_comments": [
      {
        "comment_id": "999304186",
        "repo_full_name": "electron/electron",
        "pr_number": 35810,
        "pr_file": "shell/browser/notifications/win/windows_toast_notification.cc",
        "discussion_id": "999304186",
        "commented_code": "@@ -636,4 +1249,282 @@ IFACEMETHODIMP ToastEventHandler::Invoke(\n   return S_OK;\n }\n \n+struct CoTaskMemStringTraits {\n+  typedef PWSTR Type;\n+\n+  inline static bool Close(_In_ Type h) throw() {\n+    ::CoTaskMemFree(h);\n+    return true;\n+  }\n+\n+  inline static Type GetInvalidValue() throw() { return nullptr; }\n+};\n+typedef HandleT<CoTaskMemStringTraits> CoTaskMemString;\n+\n+// #pragma GCC diagnostic push\n+// #pragma GCC diagnostic ignored \"-Wmissing-braces\"\n+// #pragma GCC diagnostic ignored \"-Wc++98-compat-extra-semi\"\n+//  For the app to be activated from Action Center, it needs to provide a COM\n+//  server to be called when the notification is activated.  The CLSID of the\n+//  object needs t  registered with the OS via its shortcut so that it knows\n+//  who to call later.\n+class NotificationActivator final\n+    : public RuntimeClass<RuntimeClassFlags<ClassicCom>,\n+                          INotificationActivationCallback> {\n+ public:\n+  HRESULT STDMETHODCALLTYPE\n+  Activate(_In_ LPCWSTR appUserModelId,\n+           _In_ LPCWSTR invokedArgs,\n+           _In_reads_(dataCount) const NOTIFICATION_USER_INPUT_DATA* data,\n+           ULONG dataCount) override {\n+    // packing user input structs into stream\n+    std::wstringstream stm;\n+    // feat: Refine notification-activation for cold start\n+    if (dataCount) {\n+      stm << L\"[\";  // json array open brace\n+      std::for_each(data, data + dataCount,\n+                    [&](const NOTIFICATION_USER_INPUT_DATA& item) {\n+                      stm << item\n+                          // avoid problem with last delimeter\n+                          << std::wstring((static_cast<ULONG>(&item - data +\n+                                                              1) == dataCount)\n+                                              ? L\"\"\n+                                              : L\",\");\n+                    });\n+      stm << L\"]\";  // json array close brace",
        "comment_created_at": "2022-10-19T11:17:18+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "This is wildly unsafe, please use an appropriate object builder or JSON implementation from `//base` or `//v8`",
        "pr_file_module": null
      },
      {
        "comment_id": "999328483",
        "repo_full_name": "electron/electron",
        "pr_number": 35810,
        "pr_file": "shell/browser/notifications/win/windows_toast_notification.cc",
        "discussion_id": "999304186",
        "commented_code": "@@ -636,4 +1249,282 @@ IFACEMETHODIMP ToastEventHandler::Invoke(\n   return S_OK;\n }\n \n+struct CoTaskMemStringTraits {\n+  typedef PWSTR Type;\n+\n+  inline static bool Close(_In_ Type h) throw() {\n+    ::CoTaskMemFree(h);\n+    return true;\n+  }\n+\n+  inline static Type GetInvalidValue() throw() { return nullptr; }\n+};\n+typedef HandleT<CoTaskMemStringTraits> CoTaskMemString;\n+\n+// #pragma GCC diagnostic push\n+// #pragma GCC diagnostic ignored \"-Wmissing-braces\"\n+// #pragma GCC diagnostic ignored \"-Wc++98-compat-extra-semi\"\n+//  For the app to be activated from Action Center, it needs to provide a COM\n+//  server to be called when the notification is activated.  The CLSID of the\n+//  object needs t  registered with the OS via its shortcut so that it knows\n+//  who to call later.\n+class NotificationActivator final\n+    : public RuntimeClass<RuntimeClassFlags<ClassicCom>,\n+                          INotificationActivationCallback> {\n+ public:\n+  HRESULT STDMETHODCALLTYPE\n+  Activate(_In_ LPCWSTR appUserModelId,\n+           _In_ LPCWSTR invokedArgs,\n+           _In_reads_(dataCount) const NOTIFICATION_USER_INPUT_DATA* data,\n+           ULONG dataCount) override {\n+    // packing user input structs into stream\n+    std::wstringstream stm;\n+    // feat: Refine notification-activation for cold start\n+    if (dataCount) {\n+      stm << L\"[\";  // json array open brace\n+      std::for_each(data, data + dataCount,\n+                    [&](const NOTIFICATION_USER_INPUT_DATA& item) {\n+                      stm << item\n+                          // avoid problem with last delimeter\n+                          << std::wstring((static_cast<ULONG>(&item - data +\n+                                                              1) == dataCount)\n+                                              ? L\"\"\n+                                              : L\",\");\n+                    });\n+      stm << L\"]\";  // json array close brace",
        "comment_created_at": "2022-10-19T11:43:48+00:00",
        "comment_author": "YuriL180821",
        "comment_body": "Hello @MarshallOfSound  this is a very very short list of self formed JSON into current project \r\nbase\\trace_event\\log_message.cc, Ln 23\r\njingle\\notifier\\listener\\notification_defines.cc, Ln 75\r\nbase\\test\\trace_to_file.cc, Ln 64\r\n...\r\n**Especially  logger in \\log_message.cc which is used widely.** \r\nIf into few words I know what I'm doing in code and I want to exclude unnecessary dependencies such as JSON related classes, which in my vision are not perfect.\r\nHave simple question: Why does we have self formed JSON into logger in case if my 3 lines of self formed JSON are so significant? I'm asking my question as developer and not with purpose to arguing, I want to understand demands of concept. Think You agree with me that \"better simpler than clever\", not?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1006703847",
        "repo_full_name": "electron/electron",
        "pr_number": 35810,
        "pr_file": "shell/browser/notifications/win/windows_toast_notification.cc",
        "discussion_id": "999304186",
        "commented_code": "@@ -636,4 +1249,282 @@ IFACEMETHODIMP ToastEventHandler::Invoke(\n   return S_OK;\n }\n \n+struct CoTaskMemStringTraits {\n+  typedef PWSTR Type;\n+\n+  inline static bool Close(_In_ Type h) throw() {\n+    ::CoTaskMemFree(h);\n+    return true;\n+  }\n+\n+  inline static Type GetInvalidValue() throw() { return nullptr; }\n+};\n+typedef HandleT<CoTaskMemStringTraits> CoTaskMemString;\n+\n+// #pragma GCC diagnostic push\n+// #pragma GCC diagnostic ignored \"-Wmissing-braces\"\n+// #pragma GCC diagnostic ignored \"-Wc++98-compat-extra-semi\"\n+//  For the app to be activated from Action Center, it needs to provide a COM\n+//  server to be called when the notification is activated.  The CLSID of the\n+//  object needs t  registered with the OS via its shortcut so that it knows\n+//  who to call later.\n+class NotificationActivator final\n+    : public RuntimeClass<RuntimeClassFlags<ClassicCom>,\n+                          INotificationActivationCallback> {\n+ public:\n+  HRESULT STDMETHODCALLTYPE\n+  Activate(_In_ LPCWSTR appUserModelId,\n+           _In_ LPCWSTR invokedArgs,\n+           _In_reads_(dataCount) const NOTIFICATION_USER_INPUT_DATA* data,\n+           ULONG dataCount) override {\n+    // packing user input structs into stream\n+    std::wstringstream stm;\n+    // feat: Refine notification-activation for cold start\n+    if (dataCount) {\n+      stm << L\"[\";  // json array open brace\n+      std::for_each(data, data + dataCount,\n+                    [&](const NOTIFICATION_USER_INPUT_DATA& item) {\n+                      stm << item\n+                          // avoid problem with last delimeter\n+                          << std::wstring((static_cast<ULONG>(&item - data +\n+                                                              1) == dataCount)\n+                                              ? L\"\"\n+                                              : L\",\");\n+                    });\n+      stm << L\"]\";  // json array close brace",
        "comment_created_at": "2022-10-27T10:39:46+00:00",
        "comment_author": "MarshallOfSound",
        "comment_body": "> Have simple question: Why does we have self formed JSON into logger in case if my 3 lines of self formed JSON are so significant?\r\n\r\nAll the code you referenced is deep in Chromium not in electron code.  This code / logic in it's current state is left up to users to consume and it is our responsibility as maintainers to ensure that users are safe and secure, that takes priority over any theoretical performance differences or \"visions\".\r\n\r\nManually forming JSON with user data is **unsafe**.  We have no way to guarantee their aren't quotes, escape sequences, etc. in that data.\r\n\r\nTo be clear, in it's current state this code will not be landed.",
        "pr_file_module": null
      },
      {
        "comment_id": "1006746825",
        "repo_full_name": "electron/electron",
        "pr_number": 35810,
        "pr_file": "shell/browser/notifications/win/windows_toast_notification.cc",
        "discussion_id": "999304186",
        "commented_code": "@@ -636,4 +1249,282 @@ IFACEMETHODIMP ToastEventHandler::Invoke(\n   return S_OK;\n }\n \n+struct CoTaskMemStringTraits {\n+  typedef PWSTR Type;\n+\n+  inline static bool Close(_In_ Type h) throw() {\n+    ::CoTaskMemFree(h);\n+    return true;\n+  }\n+\n+  inline static Type GetInvalidValue() throw() { return nullptr; }\n+};\n+typedef HandleT<CoTaskMemStringTraits> CoTaskMemString;\n+\n+// #pragma GCC diagnostic push\n+// #pragma GCC diagnostic ignored \"-Wmissing-braces\"\n+// #pragma GCC diagnostic ignored \"-Wc++98-compat-extra-semi\"\n+//  For the app to be activated from Action Center, it needs to provide a COM\n+//  server to be called when the notification is activated.  The CLSID of the\n+//  object needs t  registered with the OS via its shortcut so that it knows\n+//  who to call later.\n+class NotificationActivator final\n+    : public RuntimeClass<RuntimeClassFlags<ClassicCom>,\n+                          INotificationActivationCallback> {\n+ public:\n+  HRESULT STDMETHODCALLTYPE\n+  Activate(_In_ LPCWSTR appUserModelId,\n+           _In_ LPCWSTR invokedArgs,\n+           _In_reads_(dataCount) const NOTIFICATION_USER_INPUT_DATA* data,\n+           ULONG dataCount) override {\n+    // packing user input structs into stream\n+    std::wstringstream stm;\n+    // feat: Refine notification-activation for cold start\n+    if (dataCount) {\n+      stm << L\"[\";  // json array open brace\n+      std::for_each(data, data + dataCount,\n+                    [&](const NOTIFICATION_USER_INPUT_DATA& item) {\n+                      stm << item\n+                          // avoid problem with last delimeter\n+                          << std::wstring((static_cast<ULONG>(&item - data +\n+                                                              1) == dataCount)\n+                                              ? L\"\"\n+                                              : L\",\");\n+                    });\n+      stm << L\"]\";  // json array close brace",
        "comment_created_at": "2022-10-27T11:25:28+00:00",
        "comment_author": "YuriL180821",
        "comment_body": "`We have no way to guarantee their aren't quotes, escape sequences, etc. in that data.` - for this concrete case we have such guaranties\r\nPlease consider commit https://github.com/electron/electron/commit/88f173b1bf6a883f0de2c06c1eeb74942a641bb0",
        "pr_file_module": null
      }
    ]
  }
]