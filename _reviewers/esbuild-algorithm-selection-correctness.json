[
  {
    "discussion_id": "442491228",
    "pr_number": 186,
    "pr_file": "internal/bundler/bundler_test.go",
    "created_at": "2020-06-18T20:43:10+00:00",
    "commented_code": "})\n }\n \n+func TestExternalModuleExclusion(t *testing.T) {\n+\texpectBundled(t, bundled{\n+\t\tfiles: map[string]string{\n+\t\t\t\"/index.js\": `\n+\t\t\t\timport { S3 } from 'aws-sdk';\n+\t\t\t\timport { DocumentClient } from 'aws-sdk/clients/dynamodb';\n+\t\t\t\texport const s3 = new S3();\n+\t\t\t\texport const dynamodb = new DocumentClient();\n+\t\t\t`,\n+\t\t},\n+\t\tentryPaths: []string{\"/index.js\"},\n+\t\tparseOptions: parser.ParseOptions{\n+\t\t\tIsBundling: true,\n+\t\t},\n+\t\tbundleOptions: BundleOptions{\n+\t\t\tIsBundling:    true,\n+\t\t\tAbsOutputFile: \"/out.js\",\n+\t\t},\n+\t\tresolveOptions: resolver.ResolveOptions{\n+\t\t\tExternalModules: map[string]bool{\n+\t\t\t\t\"aws-sdk\": true,\n+\t\t\t},\n+\t\t},\n+\t\texpected: map[string]string{\n+\t\t\t\"/out.js\": `// /index.js\n+import {S3} from \"aws-sdk\";\n+import {DocumentClient} from \"aws-sdk/clients/dynamodb\";\n+const s3 = new S3();\n+const dynamodb2 = new DocumentClient();\n+export {\n+  dynamodb2 as dynamodb,",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "442491228",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 186,
        "pr_file": "internal/bundler/bundler_test.go",
        "discussion_id": "442491228",
        "commented_code": "@@ -4846,6 +4846,44 @@ render(h(App, null), document.getElementById(\"app\"));\n \t})\n }\n \n+func TestExternalModuleExclusion(t *testing.T) {\n+\texpectBundled(t, bundled{\n+\t\tfiles: map[string]string{\n+\t\t\t\"/index.js\": `\n+\t\t\t\timport { S3 } from 'aws-sdk';\n+\t\t\t\timport { DocumentClient } from 'aws-sdk/clients/dynamodb';\n+\t\t\t\texport const s3 = new S3();\n+\t\t\t\texport const dynamodb = new DocumentClient();\n+\t\t\t`,\n+\t\t},\n+\t\tentryPaths: []string{\"/index.js\"},\n+\t\tparseOptions: parser.ParseOptions{\n+\t\t\tIsBundling: true,\n+\t\t},\n+\t\tbundleOptions: BundleOptions{\n+\t\t\tIsBundling:    true,\n+\t\t\tAbsOutputFile: \"/out.js\",\n+\t\t},\n+\t\tresolveOptions: resolver.ResolveOptions{\n+\t\t\tExternalModules: map[string]bool{\n+\t\t\t\t\"aws-sdk\": true,\n+\t\t\t},\n+\t\t},\n+\t\texpected: map[string]string{\n+\t\t\t\"/out.js\": `// /index.js\n+import {S3} from \"aws-sdk\";\n+import {DocumentClient} from \"aws-sdk/clients/dynamodb\";\n+const s3 = new S3();\n+const dynamodb2 = new DocumentClient();\n+export {\n+  dynamodb2 as dynamodb,",
        "comment_created_at": "2020-06-18T20:43:10+00:00",
        "comment_author": "floydspace",
        "comment_body": "@evanw as a side question, could you tell please why this is bundled with suffix, I expected that it would be direct variable, should it be considered as a bug?",
        "pr_file_module": null
      },
      {
        "comment_id": "446615250",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 186,
        "pr_file": "internal/bundler/bundler_test.go",
        "discussion_id": "442491228",
        "commented_code": "@@ -4846,6 +4846,44 @@ render(h(App, null), document.getElementById(\"app\"));\n \t})\n }\n \n+func TestExternalModuleExclusion(t *testing.T) {\n+\texpectBundled(t, bundled{\n+\t\tfiles: map[string]string{\n+\t\t\t\"/index.js\": `\n+\t\t\t\timport { S3 } from 'aws-sdk';\n+\t\t\t\timport { DocumentClient } from 'aws-sdk/clients/dynamodb';\n+\t\t\t\texport const s3 = new S3();\n+\t\t\t\texport const dynamodb = new DocumentClient();\n+\t\t\t`,\n+\t\t},\n+\t\tentryPaths: []string{\"/index.js\"},\n+\t\tparseOptions: parser.ParseOptions{\n+\t\t\tIsBundling: true,\n+\t\t},\n+\t\tbundleOptions: BundleOptions{\n+\t\t\tIsBundling:    true,\n+\t\t\tAbsOutputFile: \"/out.js\",\n+\t\t},\n+\t\tresolveOptions: resolver.ResolveOptions{\n+\t\t\tExternalModules: map[string]bool{\n+\t\t\t\t\"aws-sdk\": true,\n+\t\t\t},\n+\t\t},\n+\t\texpected: map[string]string{\n+\t\t\t\"/out.js\": `// /index.js\n+import {S3} from \"aws-sdk\";\n+import {DocumentClient} from \"aws-sdk/clients/dynamodb\";\n+const s3 = new S3();\n+const dynamodb2 = new DocumentClient();\n+export {\n+  dynamodb2 as dynamodb,",
        "comment_created_at": "2020-06-28T07:51:23+00:00",
        "comment_author": "evanw",
        "comment_body": "This happens because of a complex interaction between the parser and the linker. The parser pre-allocates a namespace symbol for each import statement in case it's needed by the linker later. The hidden namespace is used in various cases such as the variable to store the result of `require()` for the CommonJS format. So for example this code might be turned into something like this for CommonJS:\r\n\r\n```js\r\nconst ns1 = __toModule(require(\"aws-sdk\"));\r\nconst ns2 = __toModule(require(\"aws-sdk/clients/dynamodb\"));\r\nconst s3 = new ns1.S3();\r\nconst dynamodb = new ns2.DocumentClient();\r\n```\r\n\r\nThis is done at parse time instead of link time because esbuild is trying to do as few passes as possible. Instead of doing an extra pass after parsing and before linking to rewrite external imports such as `S3` into property accesses such as `ns1.S3`, that rewriting pass is merged with the parser pass. The parser doesn't yet know if the imported module is external or not because that's computed in parallel, so it pessimistically assumes that all modules could be external and always does this transformation, which involves generating a namespace symbol for each import.\r\n\r\nExcept to make code more readable when not minifying, the name of the imported namespace is derived from the last part of the file path. This doesn't affect correctness at all but is more readable than `ns1, ns2, ...` especially when there are a lot of namespaces. So the two imports really turn into something more like this:\r\n\r\n```js\r\nconst aws_sdk = __toModule(require(\"aws-sdk\"));\r\nconst dynamodb = __toModule(require(\"aws-sdk/clients/dynamodb\"));\r\n```\r\n\r\nBut the name `dynamodb` collides with the existing symbol with the same name, which would be invalid JavaScript. The linker has a general-purpose solution that automatically renames all name collisions. That way earlier passes in the compiler can ignore the complexity of generating unique names for automatically-generated symbols and renaming can happen all in one place where it's easy to understand and audit.\r\n\r\nWhat happens here is that the import statement is processed first and grabs the `dynamodb` name for the namespace, then the variable statement is processed next and must be renamed to `dynamodb2`. You'll see that the variable statement will grab the `dynamodb` name first if you reorder the conflicting import statement to come after the variable statement.\r\n\r\nI do not consider this a bug because it does not affect correctness or minified build size. The minifier will use one-letter names for all of these identifiers, so the original names don't matter. The pretty-printing of the bundled code when not minifying just is a best-effort thing that tries to ensure the code is readable but doesn't guarantee that the symbols keep their original names. In the general case, keeping the original names is impossible anyway because ES6 the same export may be imported and re-exported using different aliases and many different symbols may be represented by a single symbol after scope flattening happens during linking.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "448652331",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 186,
        "pr_file": "internal/bundler/bundler_test.go",
        "discussion_id": "442491228",
        "commented_code": "@@ -4846,6 +4846,44 @@ render(h(App, null), document.getElementById(\"app\"));\n \t})\n }\n \n+func TestExternalModuleExclusion(t *testing.T) {\n+\texpectBundled(t, bundled{\n+\t\tfiles: map[string]string{\n+\t\t\t\"/index.js\": `\n+\t\t\t\timport { S3 } from 'aws-sdk';\n+\t\t\t\timport { DocumentClient } from 'aws-sdk/clients/dynamodb';\n+\t\t\t\texport const s3 = new S3();\n+\t\t\t\texport const dynamodb = new DocumentClient();\n+\t\t\t`,\n+\t\t},\n+\t\tentryPaths: []string{\"/index.js\"},\n+\t\tparseOptions: parser.ParseOptions{\n+\t\t\tIsBundling: true,\n+\t\t},\n+\t\tbundleOptions: BundleOptions{\n+\t\t\tIsBundling:    true,\n+\t\t\tAbsOutputFile: \"/out.js\",\n+\t\t},\n+\t\tresolveOptions: resolver.ResolveOptions{\n+\t\t\tExternalModules: map[string]bool{\n+\t\t\t\t\"aws-sdk\": true,\n+\t\t\t},\n+\t\t},\n+\t\texpected: map[string]string{\n+\t\t\t\"/out.js\": `// /index.js\n+import {S3} from \"aws-sdk\";\n+import {DocumentClient} from \"aws-sdk/clients/dynamodb\";\n+const s3 = new S3();\n+const dynamodb2 = new DocumentClient();\n+export {\n+  dynamodb2 as dynamodb,",
        "comment_created_at": "2020-07-01T22:40:28+00:00",
        "comment_author": "floydspace",
        "comment_body": "Thank you for the detailed explanation, clear like the sky",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "852162307",
    "pr_number": 2188,
    "pr_file": "internal/js_parser/ts_parser.go",
    "created_at": "2022-04-18T14:38:17+00:00",
    "commented_code": "return true\n \n \tcase\n-\t\t// These tokens can't follow in a call expression, nor can they start an\n-\t\t// expression. So, consider the type argument list part of an instantiation\n-\t\t// expression.\n-\t\tjs_lexer.TComma,                   // foo<x>,\n-\t\tjs_lexer.TDot,                     // foo<x>.\n-\t\tjs_lexer.TQuestionDot,             // foo<x>?.\n-\t\tjs_lexer.TCloseParen,              // foo<x>)\n-\t\tjs_lexer.TCloseBracket,            // foo<x>]\n-\t\tjs_lexer.TColon,                   // foo<x>:\n-\t\tjs_lexer.TSemicolon,               // foo<x>;\n-\t\tjs_lexer.TQuestion,                // foo<x>?\n-\t\tjs_lexer.TEqualsEquals,            // foo<x> ==\n-\t\tjs_lexer.TEqualsEqualsEquals,      // foo<x> ===\n-\t\tjs_lexer.TExclamationEquals,       // foo<x> !=\n-\t\tjs_lexer.TExclamationEqualsEquals, // foo<x> !==\n-\t\tjs_lexer.TAmpersandAmpersand,      // foo<x> &&\n-\t\tjs_lexer.TBarBar,                  // foo<x> ||\n-\t\tjs_lexer.TQuestionQuestion,        // foo<x> ??\n-\t\tjs_lexer.TCaret,                   // foo<x> ^\n-\t\tjs_lexer.TAmpersand,               // foo<x> &\n-\t\tjs_lexer.TBar,                     // foo<x> |\n-\t\tjs_lexer.TCloseBrace,              // foo<x> }\n-\t\tjs_lexer.TEndOfFile:               // foo<x>\n-\t\treturn true\n+\t\tjs_lexer.TPlus,\n+\t\tjs_lexer.TMinus,\n+\t\tjs_lexer.TTilde,\n+\t\tjs_lexer.TExclamation,\n+\t\tjs_lexer.TDelete,\n+\t\tjs_lexer.TTypeof,\n+\t\tjs_lexer.TVoid,\n+\t\tjs_lexer.TPlusPlus,\n+\t\tjs_lexer.TMinusMinus,\n+\t\tjs_lexer.TLessThan,\n+\t\tjs_lexer.TThis,\n+\t\tjs_lexer.TSuper,\n+\t\tjs_lexer.TNull,\n+\t\tjs_lexer.TTrue,\n+\t\tjs_lexer.TFalse,\n+\t\tjs_lexer.TNumericLiteral,\n+\t\tjs_lexer.TBigIntegerLiteral,\n+\t\tjs_lexer.TStringLiteral,\n+\t\tjs_lexer.TOpenBracket,\n+\t\tjs_lexer.TOpenBrace,\n+\t\tjs_lexer.TFunction,\n+\t\tjs_lexer.TClass,\n+\t\tjs_lexer.TNew,\n+\t\tjs_lexer.TSlash,\n+\t\tjs_lexer.TSlashEquals,\n+\t\tjs_lexer.TIdentifier:\n+\t\treturn false",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "852162307",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2188,
        "pr_file": "internal/js_parser/ts_parser.go",
        "discussion_id": "852162307",
        "commented_code": "@@ -866,34 +866,36 @@ func (p *parser) canFollowTypeArgumentsInExpression() bool {\n \t\treturn true\n \n \tcase\n-\t\t// These tokens can't follow in a call expression, nor can they start an\n-\t\t// expression. So, consider the type argument list part of an instantiation\n-\t\t// expression.\n-\t\tjs_lexer.TComma,                   // foo<x>,\n-\t\tjs_lexer.TDot,                     // foo<x>.\n-\t\tjs_lexer.TQuestionDot,             // foo<x>?.\n-\t\tjs_lexer.TCloseParen,              // foo<x>)\n-\t\tjs_lexer.TCloseBracket,            // foo<x>]\n-\t\tjs_lexer.TColon,                   // foo<x>:\n-\t\tjs_lexer.TSemicolon,               // foo<x>;\n-\t\tjs_lexer.TQuestion,                // foo<x>?\n-\t\tjs_lexer.TEqualsEquals,            // foo<x> ==\n-\t\tjs_lexer.TEqualsEqualsEquals,      // foo<x> ===\n-\t\tjs_lexer.TExclamationEquals,       // foo<x> !=\n-\t\tjs_lexer.TExclamationEqualsEquals, // foo<x> !==\n-\t\tjs_lexer.TAmpersandAmpersand,      // foo<x> &&\n-\t\tjs_lexer.TBarBar,                  // foo<x> ||\n-\t\tjs_lexer.TQuestionQuestion,        // foo<x> ??\n-\t\tjs_lexer.TCaret,                   // foo<x> ^\n-\t\tjs_lexer.TAmpersand,               // foo<x> &\n-\t\tjs_lexer.TBar,                     // foo<x> |\n-\t\tjs_lexer.TCloseBrace,              // foo<x> }\n-\t\tjs_lexer.TEndOfFile:               // foo<x>\n-\t\treturn true\n+\t\tjs_lexer.TPlus,\n+\t\tjs_lexer.TMinus,\n+\t\tjs_lexer.TTilde,\n+\t\tjs_lexer.TExclamation,\n+\t\tjs_lexer.TDelete,\n+\t\tjs_lexer.TTypeof,\n+\t\tjs_lexer.TVoid,\n+\t\tjs_lexer.TPlusPlus,\n+\t\tjs_lexer.TMinusMinus,\n+\t\tjs_lexer.TLessThan,\n+\t\tjs_lexer.TThis,\n+\t\tjs_lexer.TSuper,\n+\t\tjs_lexer.TNull,\n+\t\tjs_lexer.TTrue,\n+\t\tjs_lexer.TFalse,\n+\t\tjs_lexer.TNumericLiteral,\n+\t\tjs_lexer.TBigIntegerLiteral,\n+\t\tjs_lexer.TStringLiteral,\n+\t\tjs_lexer.TOpenBracket,\n+\t\tjs_lexer.TOpenBrace,\n+\t\tjs_lexer.TFunction,\n+\t\tjs_lexer.TClass,\n+\t\tjs_lexer.TNew,\n+\t\tjs_lexer.TSlash,\n+\t\tjs_lexer.TSlashEquals,\n+\t\tjs_lexer.TIdentifier:\n+\t\treturn false",
        "comment_created_at": "2022-04-18T14:38:17+00:00",
        "comment_author": "evanw",
        "comment_body": "Where did these come from? This doesn't appear to follow what Microsoft changed in their parser. For example, consider the following code:\r\n\r\n```js\r\nf<T>\r\nimport \"x\"\r\n\r\nf<T>\r\nimport(\"x\")\r\n```\r\n\r\nAfter their PR, [TypeScript parses it like this](https://www.typescriptlang.org/play?ts=4.7.0-dev.20220418#code/GYHgKgfAUAlgtgBwPYCcAuACARADy1KUSWRVNAClywEoog):\r\n\r\n```js\r\nf;\r\nimport \"x\";\r\n\r\nf < T > import(\"x\");\r\n```\r\n\r\nBut with your PR, esbuild parses it like this:\r\n\r\n```js\r\nf;\r\nimport \"x\";\r\nf;\r\nimport(\"x\");\r\n```\r\n\r\nI tested this case with `import` because some of the code Microsoft is now using looks like this:\r\n\r\n```ts\r\nfunction isStartOfLeftHandSideExpression(): boolean {\r\n  switch (token()) {\r\n    case SyntaxKind.ThisKeyword:\r\n    case SyntaxKind.SuperKeyword:\r\n    case SyntaxKind.NullKeyword:\r\n    case SyntaxKind.TrueKeyword:\r\n    case SyntaxKind.FalseKeyword:\r\n    case SyntaxKind.NumericLiteral:\r\n    case SyntaxKind.BigIntLiteral:\r\n    case SyntaxKind.StringLiteral:\r\n    case SyntaxKind.NoSubstitutionTemplateLiteral:\r\n    case SyntaxKind.TemplateHead:\r\n    case SyntaxKind.OpenParenToken:\r\n    case SyntaxKind.OpenBracketToken:\r\n    case SyntaxKind.OpenBraceToken:\r\n    case SyntaxKind.FunctionKeyword:\r\n    case SyntaxKind.ClassKeyword:\r\n    case SyntaxKind.NewKeyword:\r\n    case SyntaxKind.SlashToken:\r\n    case SyntaxKind.SlashEqualsToken:\r\n    case SyntaxKind.Identifier:\r\n      return true;\r\n    case SyntaxKind.ImportKeyword:\r\n      return lookAhead(nextTokenIsOpenParenOrLessThanOrDot);\r\n    default:\r\n      return isIdentifier();\r\n  }\r\n}\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "852173363",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2188,
        "pr_file": "internal/js_parser/ts_parser.go",
        "discussion_id": "852162307",
        "commented_code": "@@ -866,34 +866,36 @@ func (p *parser) canFollowTypeArgumentsInExpression() bool {\n \t\treturn true\n \n \tcase\n-\t\t// These tokens can't follow in a call expression, nor can they start an\n-\t\t// expression. So, consider the type argument list part of an instantiation\n-\t\t// expression.\n-\t\tjs_lexer.TComma,                   // foo<x>,\n-\t\tjs_lexer.TDot,                     // foo<x>.\n-\t\tjs_lexer.TQuestionDot,             // foo<x>?.\n-\t\tjs_lexer.TCloseParen,              // foo<x>)\n-\t\tjs_lexer.TCloseBracket,            // foo<x>]\n-\t\tjs_lexer.TColon,                   // foo<x>:\n-\t\tjs_lexer.TSemicolon,               // foo<x>;\n-\t\tjs_lexer.TQuestion,                // foo<x>?\n-\t\tjs_lexer.TEqualsEquals,            // foo<x> ==\n-\t\tjs_lexer.TEqualsEqualsEquals,      // foo<x> ===\n-\t\tjs_lexer.TExclamationEquals,       // foo<x> !=\n-\t\tjs_lexer.TExclamationEqualsEquals, // foo<x> !==\n-\t\tjs_lexer.TAmpersandAmpersand,      // foo<x> &&\n-\t\tjs_lexer.TBarBar,                  // foo<x> ||\n-\t\tjs_lexer.TQuestionQuestion,        // foo<x> ??\n-\t\tjs_lexer.TCaret,                   // foo<x> ^\n-\t\tjs_lexer.TAmpersand,               // foo<x> &\n-\t\tjs_lexer.TBar,                     // foo<x> |\n-\t\tjs_lexer.TCloseBrace,              // foo<x> }\n-\t\tjs_lexer.TEndOfFile:               // foo<x>\n-\t\treturn true\n+\t\tjs_lexer.TPlus,\n+\t\tjs_lexer.TMinus,\n+\t\tjs_lexer.TTilde,\n+\t\tjs_lexer.TExclamation,\n+\t\tjs_lexer.TDelete,\n+\t\tjs_lexer.TTypeof,\n+\t\tjs_lexer.TVoid,\n+\t\tjs_lexer.TPlusPlus,\n+\t\tjs_lexer.TMinusMinus,\n+\t\tjs_lexer.TLessThan,\n+\t\tjs_lexer.TThis,\n+\t\tjs_lexer.TSuper,\n+\t\tjs_lexer.TNull,\n+\t\tjs_lexer.TTrue,\n+\t\tjs_lexer.TFalse,\n+\t\tjs_lexer.TNumericLiteral,\n+\t\tjs_lexer.TBigIntegerLiteral,\n+\t\tjs_lexer.TStringLiteral,\n+\t\tjs_lexer.TOpenBracket,\n+\t\tjs_lexer.TOpenBrace,\n+\t\tjs_lexer.TFunction,\n+\t\tjs_lexer.TClass,\n+\t\tjs_lexer.TNew,\n+\t\tjs_lexer.TSlash,\n+\t\tjs_lexer.TSlashEquals,\n+\t\tjs_lexer.TIdentifier:\n+\t\treturn false",
        "comment_created_at": "2022-04-18T14:53:40+00:00",
        "comment_author": "g-plane",
        "comment_body": "I forgot to handle `import` token, and I will add it.\r\n\r\nThey changed to use an existing function [`isStartOfExpression`](https://github.com/microsoft/TypeScript/blob/56a4a93718ce016f038bcbce425bd3f47c3bec78/src/compiler/parser.ts#L4235).",
        "pr_file_module": null
      },
      {
        "comment_id": "852531784",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2188,
        "pr_file": "internal/js_parser/ts_parser.go",
        "discussion_id": "852162307",
        "commented_code": "@@ -866,34 +866,36 @@ func (p *parser) canFollowTypeArgumentsInExpression() bool {\n \t\treturn true\n \n \tcase\n-\t\t// These tokens can't follow in a call expression, nor can they start an\n-\t\t// expression. So, consider the type argument list part of an instantiation\n-\t\t// expression.\n-\t\tjs_lexer.TComma,                   // foo<x>,\n-\t\tjs_lexer.TDot,                     // foo<x>.\n-\t\tjs_lexer.TQuestionDot,             // foo<x>?.\n-\t\tjs_lexer.TCloseParen,              // foo<x>)\n-\t\tjs_lexer.TCloseBracket,            // foo<x>]\n-\t\tjs_lexer.TColon,                   // foo<x>:\n-\t\tjs_lexer.TSemicolon,               // foo<x>;\n-\t\tjs_lexer.TQuestion,                // foo<x>?\n-\t\tjs_lexer.TEqualsEquals,            // foo<x> ==\n-\t\tjs_lexer.TEqualsEqualsEquals,      // foo<x> ===\n-\t\tjs_lexer.TExclamationEquals,       // foo<x> !=\n-\t\tjs_lexer.TExclamationEqualsEquals, // foo<x> !==\n-\t\tjs_lexer.TAmpersandAmpersand,      // foo<x> &&\n-\t\tjs_lexer.TBarBar,                  // foo<x> ||\n-\t\tjs_lexer.TQuestionQuestion,        // foo<x> ??\n-\t\tjs_lexer.TCaret,                   // foo<x> ^\n-\t\tjs_lexer.TAmpersand,               // foo<x> &\n-\t\tjs_lexer.TBar,                     // foo<x> |\n-\t\tjs_lexer.TCloseBrace,              // foo<x> }\n-\t\tjs_lexer.TEndOfFile:               // foo<x>\n-\t\treturn true\n+\t\tjs_lexer.TPlus,\n+\t\tjs_lexer.TMinus,\n+\t\tjs_lexer.TTilde,\n+\t\tjs_lexer.TExclamation,\n+\t\tjs_lexer.TDelete,\n+\t\tjs_lexer.TTypeof,\n+\t\tjs_lexer.TVoid,\n+\t\tjs_lexer.TPlusPlus,\n+\t\tjs_lexer.TMinusMinus,\n+\t\tjs_lexer.TLessThan,\n+\t\tjs_lexer.TThis,\n+\t\tjs_lexer.TSuper,\n+\t\tjs_lexer.TNull,\n+\t\tjs_lexer.TTrue,\n+\t\tjs_lexer.TFalse,\n+\t\tjs_lexer.TNumericLiteral,\n+\t\tjs_lexer.TBigIntegerLiteral,\n+\t\tjs_lexer.TStringLiteral,\n+\t\tjs_lexer.TOpenBracket,\n+\t\tjs_lexer.TOpenBrace,\n+\t\tjs_lexer.TFunction,\n+\t\tjs_lexer.TClass,\n+\t\tjs_lexer.TNew,\n+\t\tjs_lexer.TSlash,\n+\t\tjs_lexer.TSlashEquals,\n+\t\tjs_lexer.TIdentifier:\n+\t\treturn false",
        "comment_created_at": "2022-04-19T01:56:46+00:00",
        "comment_author": "g-plane",
        "comment_body": "How can I do something similar to `lookAhead` in esbuild?",
        "pr_file_module": null
      },
      {
        "comment_id": "852538622",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2188,
        "pr_file": "internal/js_parser/ts_parser.go",
        "discussion_id": "852162307",
        "commented_code": "@@ -866,34 +866,36 @@ func (p *parser) canFollowTypeArgumentsInExpression() bool {\n \t\treturn true\n \n \tcase\n-\t\t// These tokens can't follow in a call expression, nor can they start an\n-\t\t// expression. So, consider the type argument list part of an instantiation\n-\t\t// expression.\n-\t\tjs_lexer.TComma,                   // foo<x>,\n-\t\tjs_lexer.TDot,                     // foo<x>.\n-\t\tjs_lexer.TQuestionDot,             // foo<x>?.\n-\t\tjs_lexer.TCloseParen,              // foo<x>)\n-\t\tjs_lexer.TCloseBracket,            // foo<x>]\n-\t\tjs_lexer.TColon,                   // foo<x>:\n-\t\tjs_lexer.TSemicolon,               // foo<x>;\n-\t\tjs_lexer.TQuestion,                // foo<x>?\n-\t\tjs_lexer.TEqualsEquals,            // foo<x> ==\n-\t\tjs_lexer.TEqualsEqualsEquals,      // foo<x> ===\n-\t\tjs_lexer.TExclamationEquals,       // foo<x> !=\n-\t\tjs_lexer.TExclamationEqualsEquals, // foo<x> !==\n-\t\tjs_lexer.TAmpersandAmpersand,      // foo<x> &&\n-\t\tjs_lexer.TBarBar,                  // foo<x> ||\n-\t\tjs_lexer.TQuestionQuestion,        // foo<x> ??\n-\t\tjs_lexer.TCaret,                   // foo<x> ^\n-\t\tjs_lexer.TAmpersand,               // foo<x> &\n-\t\tjs_lexer.TBar,                     // foo<x> |\n-\t\tjs_lexer.TCloseBrace,              // foo<x> }\n-\t\tjs_lexer.TEndOfFile:               // foo<x>\n-\t\treturn true\n+\t\tjs_lexer.TPlus,\n+\t\tjs_lexer.TMinus,\n+\t\tjs_lexer.TTilde,\n+\t\tjs_lexer.TExclamation,\n+\t\tjs_lexer.TDelete,\n+\t\tjs_lexer.TTypeof,\n+\t\tjs_lexer.TVoid,\n+\t\tjs_lexer.TPlusPlus,\n+\t\tjs_lexer.TMinusMinus,\n+\t\tjs_lexer.TLessThan,\n+\t\tjs_lexer.TThis,\n+\t\tjs_lexer.TSuper,\n+\t\tjs_lexer.TNull,\n+\t\tjs_lexer.TTrue,\n+\t\tjs_lexer.TFalse,\n+\t\tjs_lexer.TNumericLiteral,\n+\t\tjs_lexer.TBigIntegerLiteral,\n+\t\tjs_lexer.TStringLiteral,\n+\t\tjs_lexer.TOpenBracket,\n+\t\tjs_lexer.TOpenBrace,\n+\t\tjs_lexer.TFunction,\n+\t\tjs_lexer.TClass,\n+\t\tjs_lexer.TNew,\n+\t\tjs_lexer.TSlash,\n+\t\tjs_lexer.TSlashEquals,\n+\t\tjs_lexer.TIdentifier:\n+\t\treturn false",
        "comment_created_at": "2022-04-19T02:16:23+00:00",
        "comment_author": "evanw",
        "comment_body": "It's kind of hacky. I stash a copy of `p.lexer` on the stack and then overwrite it again after backtracking has finished. I can take this PR from here and add the backtracking.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "852540034",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2188,
        "pr_file": "internal/js_parser/ts_parser.go",
        "discussion_id": "852162307",
        "commented_code": "@@ -866,34 +866,36 @@ func (p *parser) canFollowTypeArgumentsInExpression() bool {\n \t\treturn true\n \n \tcase\n-\t\t// These tokens can't follow in a call expression, nor can they start an\n-\t\t// expression. So, consider the type argument list part of an instantiation\n-\t\t// expression.\n-\t\tjs_lexer.TComma,                   // foo<x>,\n-\t\tjs_lexer.TDot,                     // foo<x>.\n-\t\tjs_lexer.TQuestionDot,             // foo<x>?.\n-\t\tjs_lexer.TCloseParen,              // foo<x>)\n-\t\tjs_lexer.TCloseBracket,            // foo<x>]\n-\t\tjs_lexer.TColon,                   // foo<x>:\n-\t\tjs_lexer.TSemicolon,               // foo<x>;\n-\t\tjs_lexer.TQuestion,                // foo<x>?\n-\t\tjs_lexer.TEqualsEquals,            // foo<x> ==\n-\t\tjs_lexer.TEqualsEqualsEquals,      // foo<x> ===\n-\t\tjs_lexer.TExclamationEquals,       // foo<x> !=\n-\t\tjs_lexer.TExclamationEqualsEquals, // foo<x> !==\n-\t\tjs_lexer.TAmpersandAmpersand,      // foo<x> &&\n-\t\tjs_lexer.TBarBar,                  // foo<x> ||\n-\t\tjs_lexer.TQuestionQuestion,        // foo<x> ??\n-\t\tjs_lexer.TCaret,                   // foo<x> ^\n-\t\tjs_lexer.TAmpersand,               // foo<x> &\n-\t\tjs_lexer.TBar,                     // foo<x> |\n-\t\tjs_lexer.TCloseBrace,              // foo<x> }\n-\t\tjs_lexer.TEndOfFile:               // foo<x>\n-\t\treturn true\n+\t\tjs_lexer.TPlus,\n+\t\tjs_lexer.TMinus,\n+\t\tjs_lexer.TTilde,\n+\t\tjs_lexer.TExclamation,\n+\t\tjs_lexer.TDelete,\n+\t\tjs_lexer.TTypeof,\n+\t\tjs_lexer.TVoid,\n+\t\tjs_lexer.TPlusPlus,\n+\t\tjs_lexer.TMinusMinus,\n+\t\tjs_lexer.TLessThan,\n+\t\tjs_lexer.TThis,\n+\t\tjs_lexer.TSuper,\n+\t\tjs_lexer.TNull,\n+\t\tjs_lexer.TTrue,\n+\t\tjs_lexer.TFalse,\n+\t\tjs_lexer.TNumericLiteral,\n+\t\tjs_lexer.TBigIntegerLiteral,\n+\t\tjs_lexer.TStringLiteral,\n+\t\tjs_lexer.TOpenBracket,\n+\t\tjs_lexer.TOpenBrace,\n+\t\tjs_lexer.TFunction,\n+\t\tjs_lexer.TClass,\n+\t\tjs_lexer.TNew,\n+\t\tjs_lexer.TSlash,\n+\t\tjs_lexer.TSlashEquals,\n+\t\tjs_lexer.TIdentifier:\n+\t\treturn false",
        "comment_created_at": "2022-04-19T02:20:19+00:00",
        "comment_author": "g-plane",
        "comment_body": "To be honest, I hope we can have a more common method to do backtracking.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "628581468",
    "pr_number": 1261,
    "pr_file": "internal/js_parser/js_parser.go",
    "created_at": "2021-05-07T22:34:09+00:00",
    "commented_code": "return false\n \t\t\t}\n \n-\t\t\t// The last symbol must be unbound\n-\t\t\treturn p.symbols[result.ref.InnerIndex].Kind == js_ast.SymbolUnbound\n+\t\t\tp.ignoreUsage(result.ref)",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "628581468",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 1261,
        "pr_file": "internal/js_parser/js_parser.go",
        "discussion_id": "628581468",
        "commented_code": "@@ -9508,8 +9508,10 @@ func (p *parser) isDotDefineMatch(expr js_ast.Expr, parts []string) bool {\n \t\t\t\treturn false\n \t\t\t}\n \n-\t\t\t// The last symbol must be unbound\n-\t\t\treturn p.symbols[result.ref.InnerIndex].Kind == js_ast.SymbolUnbound\n+\t\t\tp.ignoreUsage(result.ref)",
        "comment_created_at": "2021-05-07T22:34:09+00:00",
        "comment_author": "rtsao",
        "comment_body": "If we replace an injected symbol with a define, we need to explicitly mark it as unused (as `p.findSymbol` has the effect of marking usage). Otherwise, the injected import won't be eliminated.\r\n\r\nCalling `p.ignoreUsage` feels a bit hacky. I also suppose that `ignoreUsage` should be invoked closer to the actual replacement callsite rather than in `isDotDefineMatch`, which doesn't necessitate that a replacement actually occurs...",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "430841064",
    "pr_number": 144,
    "pr_file": "internal/resolver/resolver.go",
    "created_at": "2020-05-27T03:45:52+00:00",
    "commented_code": "return \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil\n+}\n+\n func (r *resolver) loadNodeModules(path string, dirInfo *dirInfo) (string, bool) {\n \tfor {\n \t\t// Handle TypeScript base URLs for TypeScript code\n-\t\tif dirInfo.tsConfigJson != nil && dirInfo.tsConfigJson.absPathBaseUrl != nil {\n-\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)\n-\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n-\t\t\t\treturn absolute, true\n+\t\tif dirInfo.tsConfigJson != nil {\n+\n+\t\t\tif dirInfo.tsConfigJson.absPathBaseUrl != nil {\n+\t\t\t\tif dirInfo.tsConfigJson.paths != nil {\n+\t\t\t\t\tfor key, originalPaths := range dirInfo.tsConfigJson.paths {\n+\t\t\t\t\t\tfor _, originalPath := range originalPaths {\n+\t\t\t\t\t\t\tif matched, err := regexp.MatchString(\"^\"+key, path); matched && err == nil {",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "430841064",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 144,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "430841064",
        "commented_code": "@@ -578,13 +601,43 @@ func (r *resolver) loadAsFileOrDirectory(path string) (string, bool) {\n \treturn \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil\n+}\n+\n func (r *resolver) loadNodeModules(path string, dirInfo *dirInfo) (string, bool) {\n \tfor {\n \t\t// Handle TypeScript base URLs for TypeScript code\n-\t\tif dirInfo.tsConfigJson != nil && dirInfo.tsConfigJson.absPathBaseUrl != nil {\n-\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)\n-\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n-\t\t\t\treturn absolute, true\n+\t\tif dirInfo.tsConfigJson != nil {\n+\n+\t\t\tif dirInfo.tsConfigJson.absPathBaseUrl != nil {\n+\t\t\t\tif dirInfo.tsConfigJson.paths != nil {\n+\t\t\t\t\tfor key, originalPaths := range dirInfo.tsConfigJson.paths {\n+\t\t\t\t\t\tfor _, originalPath := range originalPaths {\n+\t\t\t\t\t\t\tif matched, err := regexp.MatchString(\"^\"+key, path); matched && err == nil {",
        "comment_created_at": "2020-05-27T03:45:52+00:00",
        "comment_author": "evanw",
        "comment_body": "Using a regex to match this isn't correct. The pattern is an asterisk, which causes a regex to repeat the previous character zero or more times. That would mean a pattern `foo*` would also match a directory named `foooo` and `fo`. I took some time to look at what the TypeScript compiler itself does. The relevant code is in `tryLoadModuleUsingPaths()` [here](https://github.com/microsoft/TypeScript/blob/c194abb38c54c1607831b4ec678c0bdd15f7fe49/src/compiler/moduleNameResolver.ts#L1361-L1387).\r\n\r\nOther relevant code is `tryParsePattern()` [here](https://github.com/microsoft/TypeScript/blob/c194abb38c54c1607831b4ec678c0bdd15f7fe49/src/compiler/utilities.ts#L6122-L6130):\r\n\r\n```ts\r\n    export function tryParsePattern(pattern: string): Pattern | undefined {\r\n        // This should be verified outside of here and a proper error thrown.\r\n        Debug.assert(hasZeroOrOneAsteriskCharacter(pattern));\r\n        const indexOfStar = pattern.indexOf(\"*\");\r\n        return indexOfStar === -1 ? undefined : {\r\n            prefix: pattern.substr(0, indexOfStar),\r\n            suffix: pattern.substr(indexOfStar + 1)\r\n        };\r\n    }\r\n```\r\n\r\nand `isPatternMatch()` [here](https://github.com/microsoft/TypeScript/blob/c194abb38c54c1607831b4ec678c0bdd15f7fe49/src/compiler/core.ts#L2015-L2019):\r\n\r\n```ts\r\n    function isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {\r\n        return candidate.length >= prefix.length + suffix.length &&\r\n            startsWith(candidate, prefix) &&\r\n            endsWith(candidate, suffix);\r\n    }\r\n```\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "431030789",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 144,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "430841064",
        "commented_code": "@@ -578,13 +601,43 @@ func (r *resolver) loadAsFileOrDirectory(path string) (string, bool) {\n \treturn \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil\n+}\n+\n func (r *resolver) loadNodeModules(path string, dirInfo *dirInfo) (string, bool) {\n \tfor {\n \t\t// Handle TypeScript base URLs for TypeScript code\n-\t\tif dirInfo.tsConfigJson != nil && dirInfo.tsConfigJson.absPathBaseUrl != nil {\n-\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)\n-\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n-\t\t\t\treturn absolute, true\n+\t\tif dirInfo.tsConfigJson != nil {\n+\n+\t\t\tif dirInfo.tsConfigJson.absPathBaseUrl != nil {\n+\t\t\t\tif dirInfo.tsConfigJson.paths != nil {\n+\t\t\t\t\tfor key, originalPaths := range dirInfo.tsConfigJson.paths {\n+\t\t\t\t\t\tfor _, originalPath := range originalPaths {\n+\t\t\t\t\t\t\tif matched, err := regexp.MatchString(\"^\"+key, path); matched && err == nil {",
        "comment_created_at": "2020-05-27T10:55:44+00:00",
        "comment_author": "viankakrisna",
        "comment_body": "thank you! i've added some commits to handle this more like ts compiler, but i haven't written the test case where `*` is at the start or middle of the path.\r\n",
        "pr_file_module": null
      }
    ]
  }
]