[
  {
    "discussion_id": "973746995",
    "pr_number": 2556,
    "pr_file": "internal/css_parser/css_parser.go",
    "created_at": "2022-09-18T16:42:14+00:00",
    "commented_code": "case \"keyframes\", \"-webkit-keyframes\", \"-moz-keyframes\", \"-ms-keyframes\", \"-o-keyframes\":\n \t\tp.eat(css_lexer.TWhitespace)\n \t\tvar name string\n+\t\tvar isStringName bool\n \n \t\tif p.peek(css_lexer.TIdent) {\n-\t\t\tname = p.decoded()\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tif name == \"none\" {\n+\t\t\t\tp.log.AddID(logger.MsgID_CSS_CSSSyntaxError, logger.Warning, &p.tracker, atRange, \"Expected identifier but found `none` which is invalid in this context\")\n+\t\t\t\tp.prevError = p.current().Range.Loc\n+\t\t\t}\n+\t\t\tp.advance()\n+\t\t\tisStringName = false\n+\t\t} else if p.peek(css_lexer.TString) {\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tisStringName = !p.options.MinifySyntax || cssWideAndReservedKeywords[name] || name == \"none\"\n \t\t\tp.advance()\n-\t\t} else if !p.expect(css_lexer.TIdent) && !p.eat(css_lexer.TString) && !p.peek(css_lexer.TOpenBrace) {\n+\t\t} else if !(p.expect(css_lexer.TIdent) && p.expect(css_lexer.TString)) && !p.peek(css_lexer.TOpenBrace) {\n \t\t\t// Consider string names a syntax error even though they are allowed by\n \t\t\t// the specification and they work in Firefox because they do not work in\n \t\t\t// Chrome or Safari.",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "973746995",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2556,
        "pr_file": "internal/css_parser/css_parser.go",
        "discussion_id": "973746995",
        "commented_code": "@@ -828,11 +828,21 @@ abortRuleParser:\n \tcase \"keyframes\", \"-webkit-keyframes\", \"-moz-keyframes\", \"-ms-keyframes\", \"-o-keyframes\":\n \t\tp.eat(css_lexer.TWhitespace)\n \t\tvar name string\n+\t\tvar isStringName bool\n \n \t\tif p.peek(css_lexer.TIdent) {\n-\t\t\tname = p.decoded()\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tif name == \"none\" {\n+\t\t\t\tp.log.AddID(logger.MsgID_CSS_CSSSyntaxError, logger.Warning, &p.tracker, atRange, \"Expected identifier but found `none` which is invalid in this context\")\n+\t\t\t\tp.prevError = p.current().Range.Loc\n+\t\t\t}\n+\t\t\tp.advance()\n+\t\t\tisStringName = false\n+\t\t} else if p.peek(css_lexer.TString) {\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tisStringName = !p.options.MinifySyntax || cssWideAndReservedKeywords[name] || name == \"none\"\n \t\t\tp.advance()\n-\t\t} else if !p.expect(css_lexer.TIdent) && !p.eat(css_lexer.TString) && !p.peek(css_lexer.TOpenBrace) {\n+\t\t} else if !(p.expect(css_lexer.TIdent) && p.expect(css_lexer.TString)) && !p.peek(css_lexer.TOpenBrace) {\n \t\t\t// Consider string names a syntax error even though they are allowed by\n \t\t\t// the specification and they work in Firefox because they do not work in\n \t\t\t// Chrome or Safari.",
        "comment_created_at": "2022-09-18T16:42:14+00:00",
        "comment_author": "evanw",
        "comment_body": "Not sure if you saw this comment or not but lack of support for this was deliberate. This is currently a Firefox-only feature, which I don't think makes sense to support natively in esbuild at this time.\r\n\r\nI agree that the bug that changes the contents of `@keyframes` rules with unsupported syntax should still be fixed. These should be passed through unmodified. I will fix that part.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "973805169",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2556,
        "pr_file": "internal/css_parser/css_parser.go",
        "discussion_id": "973746995",
        "commented_code": "@@ -828,11 +828,21 @@ abortRuleParser:\n \tcase \"keyframes\", \"-webkit-keyframes\", \"-moz-keyframes\", \"-ms-keyframes\", \"-o-keyframes\":\n \t\tp.eat(css_lexer.TWhitespace)\n \t\tvar name string\n+\t\tvar isStringName bool\n \n \t\tif p.peek(css_lexer.TIdent) {\n-\t\t\tname = p.decoded()\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tif name == \"none\" {\n+\t\t\t\tp.log.AddID(logger.MsgID_CSS_CSSSyntaxError, logger.Warning, &p.tracker, atRange, \"Expected identifier but found `none` which is invalid in this context\")\n+\t\t\t\tp.prevError = p.current().Range.Loc\n+\t\t\t}\n+\t\t\tp.advance()\n+\t\t\tisStringName = false\n+\t\t} else if p.peek(css_lexer.TString) {\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tisStringName = !p.options.MinifySyntax || cssWideAndReservedKeywords[name] || name == \"none\"\n \t\t\tp.advance()\n-\t\t} else if !p.expect(css_lexer.TIdent) && !p.eat(css_lexer.TString) && !p.peek(css_lexer.TOpenBrace) {\n+\t\t} else if !(p.expect(css_lexer.TIdent) && p.expect(css_lexer.TString)) && !p.peek(css_lexer.TOpenBrace) {\n \t\t\t// Consider string names a syntax error even though they are allowed by\n \t\t\t// the specification and they work in Firefox because they do not work in\n \t\t\t// Chrome or Safari.",
        "comment_created_at": "2022-09-19T00:40:26+00:00",
        "comment_author": "CGQAQ",
        "comment_body": "I currently working on blink, and the webkit one is already merged, I submitted a PR to SWC project as well, so I think the change will be good for all, and all majar browser vendor prefixed one support string type name BTW\r\n\r\nref: https://github.com/WebKit/WebKit/pull/4234\r\n      https://chromium-review.googlesource.com/c/chromium/src/+/3865188\r\n      https://github.com/swc-project/swc/pull/5894",
        "pr_file_module": null
      },
      {
        "comment_id": "973940514",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 2556,
        "pr_file": "internal/css_parser/css_parser.go",
        "discussion_id": "973746995",
        "commented_code": "@@ -828,11 +828,21 @@ abortRuleParser:\n \tcase \"keyframes\", \"-webkit-keyframes\", \"-moz-keyframes\", \"-ms-keyframes\", \"-o-keyframes\":\n \t\tp.eat(css_lexer.TWhitespace)\n \t\tvar name string\n+\t\tvar isStringName bool\n \n \t\tif p.peek(css_lexer.TIdent) {\n-\t\t\tname = p.decoded()\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tif name == \"none\" {\n+\t\t\t\tp.log.AddID(logger.MsgID_CSS_CSSSyntaxError, logger.Warning, &p.tracker, atRange, \"Expected identifier but found `none` which is invalid in this context\")\n+\t\t\t\tp.prevError = p.current().Range.Loc\n+\t\t\t}\n+\t\t\tp.advance()\n+\t\t\tisStringName = false\n+\t\t} else if p.peek(css_lexer.TString) {\n+\t\t\tname = strings.ToLower(p.decoded())\n+\t\t\tisStringName = !p.options.MinifySyntax || cssWideAndReservedKeywords[name] || name == \"none\"\n \t\t\tp.advance()\n-\t\t} else if !p.expect(css_lexer.TIdent) && !p.eat(css_lexer.TString) && !p.peek(css_lexer.TOpenBrace) {\n+\t\t} else if !(p.expect(css_lexer.TIdent) && p.expect(css_lexer.TString)) && !p.peek(css_lexer.TOpenBrace) {\n \t\t\t// Consider string names a syntax error even though they are allowed by\n \t\t\t// the specification and they work in Firefox because they do not work in\n \t\t\t// Chrome or Safari.",
        "comment_created_at": "2022-09-19T07:32:11+00:00",
        "comment_author": "yisibl",
        "comment_body": "@evanw This is not a Firefox-only syntax, the prefixed `@-webkit-keyframes / @-moz-keyframes` always support `<string>`, and there are [UseCounter](https://codereview.chromium.org/651123003/) in Chrome that say: `The usage counter for strings in prefixed case is too high`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "589165907",
    "pr_number": 924,
    "pr_file": "internal/resolver/resolver.go",
    "created_at": "2021-03-08T04:40:23+00:00",
    "commented_code": "for _, absDir := range r.options.AbsNodePaths {\n \t\tabsPath := r.fs.Join(absDir, path)\n \t\tif absolute, ok, diffCase := r.loadAsFileOrDirectory(absPath, kind); ok {\n-\t\t\treturn absolute, true, diffCase\n+\t\t\treturn absolute, true, diffCase, nil\n \t\t}\n \t}\n \n+\tesmPackageName, esmPackageSubpath, esmOK := esmParsePackageName(path)\n+\n \t// Then check for the package in any enclosing \"node_modules\" directories\n \tfor {\n \t\t// Skip directories that are themselves called \"node_modules\", since we\n \t\t// don't ever want to search for \"node_modules/node_modules\"\n \t\tif dirInfo.hasNodeModules {\n \t\t\tabsPath := r.fs.Join(dirInfo.absPath, \"node_modules\", path)\n \n+\t\t\t// Check for an \"exports\" map in the package's package.json folder\n+\t\t\tif esmOK {\n+\t\t\t\tabsPkgPath := r.fs.Join(dirInfo.absPath, \"node_modules\", esmPackageName)\n+\t\t\t\tif pkgDirInfo := r.dirInfoCached(absPkgPath); pkgDirInfo != nil {\n+\t\t\t\t\tif pkgJSON := pkgDirInfo.packageJSON; pkgJSON != nil && pkgJSON.exportsMap != nil {\n+\t\t\t\t\t\t// Resolve against the path \"/\", then join it with the absolute\n+\t\t\t\t\t\t// directory path. This is done because ESM package resolution uses\n+\t\t\t\t\t\t// URLs while our path resolution uses file system paths. We don't\n+\t\t\t\t\t\t// want problems due to Windows paths, which are very unlike URL\n+\t\t\t\t\t\t// paths. We also want to avoid any \"%\" characters in the absolute\n+\t\t\t\t\t\t// directory path accidentally being interpreted as URL escapes.\n+\t\t\t\t\t\tresolvedPath, status, token := esmPackageExportsResolveWithPostConditions(\"/\", esmPackageSubpath, pkgJSON.exportsMap.root, nil)",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "589165907",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 924,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "589165907",
        "commented_code": "@@ -1144,33 +1147,106 @@ func (r *resolver) loadNodeModules(path string, kind ast.ImportKind, dirInfo *di\n \tfor _, absDir := range r.options.AbsNodePaths {\n \t\tabsPath := r.fs.Join(absDir, path)\n \t\tif absolute, ok, diffCase := r.loadAsFileOrDirectory(absPath, kind); ok {\n-\t\t\treturn absolute, true, diffCase\n+\t\t\treturn absolute, true, diffCase, nil\n \t\t}\n \t}\n \n+\tesmPackageName, esmPackageSubpath, esmOK := esmParsePackageName(path)\n+\n \t// Then check for the package in any enclosing \"node_modules\" directories\n \tfor {\n \t\t// Skip directories that are themselves called \"node_modules\", since we\n \t\t// don't ever want to search for \"node_modules/node_modules\"\n \t\tif dirInfo.hasNodeModules {\n \t\t\tabsPath := r.fs.Join(dirInfo.absPath, \"node_modules\", path)\n \n+\t\t\t// Check for an \"exports\" map in the package's package.json folder\n+\t\t\tif esmOK {\n+\t\t\t\tabsPkgPath := r.fs.Join(dirInfo.absPath, \"node_modules\", esmPackageName)\n+\t\t\t\tif pkgDirInfo := r.dirInfoCached(absPkgPath); pkgDirInfo != nil {\n+\t\t\t\t\tif pkgJSON := pkgDirInfo.packageJSON; pkgJSON != nil && pkgJSON.exportsMap != nil {\n+\t\t\t\t\t\t// Resolve against the path \"/\", then join it with the absolute\n+\t\t\t\t\t\t// directory path. This is done because ESM package resolution uses\n+\t\t\t\t\t\t// URLs while our path resolution uses file system paths. We don't\n+\t\t\t\t\t\t// want problems due to Windows paths, which are very unlike URL\n+\t\t\t\t\t\t// paths. We also want to avoid any \"%\" characters in the absolute\n+\t\t\t\t\t\t// directory path accidentally being interpreted as URL escapes.\n+\t\t\t\t\t\tresolvedPath, status, token := esmPackageExportsResolveWithPostConditions(\"/\", esmPackageSubpath, pkgJSON.exportsMap.root, nil)",
        "comment_created_at": "2021-03-08T04:40:23+00:00",
        "comment_author": "lukeed",
        "comment_body": "Where do the `conditions` come from? AFAICT this is the only initialization point for the `exports` resolution phase",
        "pr_file_module": null
      },
      {
        "comment_id": "589166585",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 924,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "589165907",
        "commented_code": "@@ -1144,33 +1147,106 @@ func (r *resolver) loadNodeModules(path string, kind ast.ImportKind, dirInfo *di\n \tfor _, absDir := range r.options.AbsNodePaths {\n \t\tabsPath := r.fs.Join(absDir, path)\n \t\tif absolute, ok, diffCase := r.loadAsFileOrDirectory(absPath, kind); ok {\n-\t\t\treturn absolute, true, diffCase\n+\t\t\treturn absolute, true, diffCase, nil\n \t\t}\n \t}\n \n+\tesmPackageName, esmPackageSubpath, esmOK := esmParsePackageName(path)\n+\n \t// Then check for the package in any enclosing \"node_modules\" directories\n \tfor {\n \t\t// Skip directories that are themselves called \"node_modules\", since we\n \t\t// don't ever want to search for \"node_modules/node_modules\"\n \t\tif dirInfo.hasNodeModules {\n \t\t\tabsPath := r.fs.Join(dirInfo.absPath, \"node_modules\", path)\n \n+\t\t\t// Check for an \"exports\" map in the package's package.json folder\n+\t\t\tif esmOK {\n+\t\t\t\tabsPkgPath := r.fs.Join(dirInfo.absPath, \"node_modules\", esmPackageName)\n+\t\t\t\tif pkgDirInfo := r.dirInfoCached(absPkgPath); pkgDirInfo != nil {\n+\t\t\t\t\tif pkgJSON := pkgDirInfo.packageJSON; pkgJSON != nil && pkgJSON.exportsMap != nil {\n+\t\t\t\t\t\t// Resolve against the path \"/\", then join it with the absolute\n+\t\t\t\t\t\t// directory path. This is done because ESM package resolution uses\n+\t\t\t\t\t\t// URLs while our path resolution uses file system paths. We don't\n+\t\t\t\t\t\t// want problems due to Windows paths, which are very unlike URL\n+\t\t\t\t\t\t// paths. We also want to avoid any \"%\" characters in the absolute\n+\t\t\t\t\t\t// directory path accidentally being interpreted as URL escapes.\n+\t\t\t\t\t\tresolvedPath, status, token := esmPackageExportsResolveWithPostConditions(\"/\", esmPackageSubpath, pkgJSON.exportsMap.root, nil)",
        "comment_created_at": "2021-03-08T04:43:39+00:00",
        "comment_author": "evanw",
        "comment_body": "They were added in the very next commit. The first commit only respects the `default` condition and then the next commit adds `browser`, `node`, `import`, and `require`.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "589167988",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 924,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "589165907",
        "commented_code": "@@ -1144,33 +1147,106 @@ func (r *resolver) loadNodeModules(path string, kind ast.ImportKind, dirInfo *di\n \tfor _, absDir := range r.options.AbsNodePaths {\n \t\tabsPath := r.fs.Join(absDir, path)\n \t\tif absolute, ok, diffCase := r.loadAsFileOrDirectory(absPath, kind); ok {\n-\t\t\treturn absolute, true, diffCase\n+\t\t\treturn absolute, true, diffCase, nil\n \t\t}\n \t}\n \n+\tesmPackageName, esmPackageSubpath, esmOK := esmParsePackageName(path)\n+\n \t// Then check for the package in any enclosing \"node_modules\" directories\n \tfor {\n \t\t// Skip directories that are themselves called \"node_modules\", since we\n \t\t// don't ever want to search for \"node_modules/node_modules\"\n \t\tif dirInfo.hasNodeModules {\n \t\t\tabsPath := r.fs.Join(dirInfo.absPath, \"node_modules\", path)\n \n+\t\t\t// Check for an \"exports\" map in the package's package.json folder\n+\t\t\tif esmOK {\n+\t\t\t\tabsPkgPath := r.fs.Join(dirInfo.absPath, \"node_modules\", esmPackageName)\n+\t\t\t\tif pkgDirInfo := r.dirInfoCached(absPkgPath); pkgDirInfo != nil {\n+\t\t\t\t\tif pkgJSON := pkgDirInfo.packageJSON; pkgJSON != nil && pkgJSON.exportsMap != nil {\n+\t\t\t\t\t\t// Resolve against the path \"/\", then join it with the absolute\n+\t\t\t\t\t\t// directory path. This is done because ESM package resolution uses\n+\t\t\t\t\t\t// URLs while our path resolution uses file system paths. We don't\n+\t\t\t\t\t\t// want problems due to Windows paths, which are very unlike URL\n+\t\t\t\t\t\t// paths. We also want to avoid any \"%\" characters in the absolute\n+\t\t\t\t\t\t// directory path accidentally being interpreted as URL escapes.\n+\t\t\t\t\t\tresolvedPath, status, token := esmPackageExportsResolveWithPostConditions(\"/\", esmPackageSubpath, pkgJSON.exportsMap.root, nil)",
        "comment_created_at": "2021-03-08T04:48:52+00:00",
        "comment_author": "lukeed",
        "comment_body": "Oh, haha \ud83d\ude05 thanks I'll look now",
        "pr_file_module": null
      },
      {
        "comment_id": "589170849",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 924,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "589165907",
        "commented_code": "@@ -1144,33 +1147,106 @@ func (r *resolver) loadNodeModules(path string, kind ast.ImportKind, dirInfo *di\n \tfor _, absDir := range r.options.AbsNodePaths {\n \t\tabsPath := r.fs.Join(absDir, path)\n \t\tif absolute, ok, diffCase := r.loadAsFileOrDirectory(absPath, kind); ok {\n-\t\t\treturn absolute, true, diffCase\n+\t\t\treturn absolute, true, diffCase, nil\n \t\t}\n \t}\n \n+\tesmPackageName, esmPackageSubpath, esmOK := esmParsePackageName(path)\n+\n \t// Then check for the package in any enclosing \"node_modules\" directories\n \tfor {\n \t\t// Skip directories that are themselves called \"node_modules\", since we\n \t\t// don't ever want to search for \"node_modules/node_modules\"\n \t\tif dirInfo.hasNodeModules {\n \t\t\tabsPath := r.fs.Join(dirInfo.absPath, \"node_modules\", path)\n \n+\t\t\t// Check for an \"exports\" map in the package's package.json folder\n+\t\t\tif esmOK {\n+\t\t\t\tabsPkgPath := r.fs.Join(dirInfo.absPath, \"node_modules\", esmPackageName)\n+\t\t\t\tif pkgDirInfo := r.dirInfoCached(absPkgPath); pkgDirInfo != nil {\n+\t\t\t\t\tif pkgJSON := pkgDirInfo.packageJSON; pkgJSON != nil && pkgJSON.exportsMap != nil {\n+\t\t\t\t\t\t// Resolve against the path \"/\", then join it with the absolute\n+\t\t\t\t\t\t// directory path. This is done because ESM package resolution uses\n+\t\t\t\t\t\t// URLs while our path resolution uses file system paths. We don't\n+\t\t\t\t\t\t// want problems due to Windows paths, which are very unlike URL\n+\t\t\t\t\t\t// paths. We also want to avoid any \"%\" characters in the absolute\n+\t\t\t\t\t\t// directory path accidentally being interpreted as URL escapes.\n+\t\t\t\t\t\tresolvedPath, status, token := esmPackageExportsResolveWithPostConditions(\"/\", esmPackageSubpath, pkgJSON.exportsMap.root, nil)",
        "comment_created_at": "2021-03-08T05:00:26+00:00",
        "comment_author": "lukeed",
        "comment_body": "Looks great! The only thing I'm not seeing \u2013 i think \u2013 is support for custom conditions? \r\n\r\nFor example, webpack adds `development` -vs- `production` conditions & a lot of people are making use of that already. I've also seen (and have authored) modules with a `worker` condition. Technically anything can be a condition, and so long as resolver it willing to _look_ at it & the pkg author has defined it in the correct order-hierarchy, then it should be matched.",
        "pr_file_module": null
      },
      {
        "comment_id": "589179516",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 924,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "589165907",
        "commented_code": "@@ -1144,33 +1147,106 @@ func (r *resolver) loadNodeModules(path string, kind ast.ImportKind, dirInfo *di\n \tfor _, absDir := range r.options.AbsNodePaths {\n \t\tabsPath := r.fs.Join(absDir, path)\n \t\tif absolute, ok, diffCase := r.loadAsFileOrDirectory(absPath, kind); ok {\n-\t\t\treturn absolute, true, diffCase\n+\t\t\treturn absolute, true, diffCase, nil\n \t\t}\n \t}\n \n+\tesmPackageName, esmPackageSubpath, esmOK := esmParsePackageName(path)\n+\n \t// Then check for the package in any enclosing \"node_modules\" directories\n \tfor {\n \t\t// Skip directories that are themselves called \"node_modules\", since we\n \t\t// don't ever want to search for \"node_modules/node_modules\"\n \t\tif dirInfo.hasNodeModules {\n \t\t\tabsPath := r.fs.Join(dirInfo.absPath, \"node_modules\", path)\n \n+\t\t\t// Check for an \"exports\" map in the package's package.json folder\n+\t\t\tif esmOK {\n+\t\t\t\tabsPkgPath := r.fs.Join(dirInfo.absPath, \"node_modules\", esmPackageName)\n+\t\t\t\tif pkgDirInfo := r.dirInfoCached(absPkgPath); pkgDirInfo != nil {\n+\t\t\t\t\tif pkgJSON := pkgDirInfo.packageJSON; pkgJSON != nil && pkgJSON.exportsMap != nil {\n+\t\t\t\t\t\t// Resolve against the path \"/\", then join it with the absolute\n+\t\t\t\t\t\t// directory path. This is done because ESM package resolution uses\n+\t\t\t\t\t\t// URLs while our path resolution uses file system paths. We don't\n+\t\t\t\t\t\t// want problems due to Windows paths, which are very unlike URL\n+\t\t\t\t\t\t// paths. We also want to avoid any \"%\" characters in the absolute\n+\t\t\t\t\t\t// directory path accidentally being interpreted as URL escapes.\n+\t\t\t\t\t\tresolvedPath, status, token := esmPackageExportsResolveWithPostConditions(\"/\", esmPackageSubpath, pkgJSON.exportsMap.root, nil)",
        "comment_created_at": "2021-03-08T05:34:33+00:00",
        "comment_author": "evanw",
        "comment_body": "I'm already aware of the need for conditional exports. I'm still working on the 0.9.0 release and just haven't implemented them yet.\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "430846018",
    "pr_number": 135,
    "pr_file": "internal/bundler/bundler.go",
    "created_at": "2020-05-27T04:08:45+00:00",
    "commented_code": "ast := parser.ModuleExportsAST(log, source, parseOptions, expr)\n \t\tresults <- parseResult{source, ast, true}\n \n+\tcase LoaderURL:\n+\t\turl := path.Base(sourcePath)\n+\t\ttargetFolder := bundleOptions.AbsOutputDir\n+\t\tif targetFolder == \"\" {\n+\t\t\ttargetFolder = path.Dir(bundleOptions.AbsOutputFile)\n+\t\t}\n+\t\tdefer ioutil.WriteFile(path.Join(targetFolder, url), []byte(source.Contents), 0644)",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "430846018",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 135,
        "pr_file": "internal/bundler/bundler.go",
        "discussion_id": "430846018",
        "commented_code": "@@ -166,8 +167,19 @@ func parseFile(\n \t\tast := parser.ModuleExportsAST(log, source, parseOptions, expr)\n \t\tresults <- parseResult{source, ast, true}\n \n+\tcase LoaderURL:\n+\t\turl := path.Base(sourcePath)\n+\t\ttargetFolder := bundleOptions.AbsOutputDir\n+\t\tif targetFolder == \"\" {\n+\t\t\ttargetFolder = path.Dir(bundleOptions.AbsOutputFile)\n+\t\t}\n+\t\tdefer ioutil.WriteFile(path.Join(targetFolder, url), []byte(source.Contents), 0644)",
        "comment_created_at": "2020-05-27T04:08:45+00:00",
        "comment_author": "evanw",
        "comment_body": "The bundler isn't supposed to write files itself. The bundler returns all of the files to be written to the caller. This makes the bundler easier to unit test and also makes it easy for the API to return results without modifying the file system (see for example #139).\r\n\r\nDoing things this way also defeats future tree shaking optimizations, which may end up removing this module entirely. In that case the file should not be emitted in the output directory since it's unreferenced.\r\n\r\nInstead of writing to the file system, the contents of the file should be stashed somewhere associated with the file, probably just on the `parseResult` or `ast`. Then the bundler should return the file to the caller, probably as an extra `BundleResult` entry. But that requires generalizing `BundleResult` to handle non-JavaScript result files.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "431026253",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 135,
        "pr_file": "internal/bundler/bundler.go",
        "discussion_id": "430846018",
        "commented_code": "@@ -166,8 +167,19 @@ func parseFile(\n \t\tast := parser.ModuleExportsAST(log, source, parseOptions, expr)\n \t\tresults <- parseResult{source, ast, true}\n \n+\tcase LoaderURL:\n+\t\turl := path.Base(sourcePath)\n+\t\ttargetFolder := bundleOptions.AbsOutputDir\n+\t\tif targetFolder == \"\" {\n+\t\t\ttargetFolder = path.Dir(bundleOptions.AbsOutputFile)\n+\t\t}\n+\t\tdefer ioutil.WriteFile(path.Join(targetFolder, url), []byte(source.Contents), 0644)",
        "comment_created_at": "2020-05-27T10:46:26+00:00",
        "comment_author": "viankakrisna",
        "comment_body": "thank you! yeah this is a part where i'm not really sure. i'll try generalizing BundleResult to handle non-JavaScript result files",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "430842408",
    "pr_number": 144,
    "pr_file": "internal/resolver/resolver.go",
    "created_at": "2020-05-27T03:52:07+00:00",
    "commented_code": "return \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil\n+}\n+\n func (r *resolver) loadNodeModules(path string, dirInfo *dirInfo) (string, bool) {\n \tfor {\n \t\t// Handle TypeScript base URLs for TypeScript code\n-\t\tif dirInfo.tsConfigJson != nil && dirInfo.tsConfigJson.absPathBaseUrl != nil {\n-\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)\n-\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n-\t\t\t\treturn absolute, true\n+\t\tif dirInfo.tsConfigJson != nil {\n+\n+\t\t\tif dirInfo.tsConfigJson.absPathBaseUrl != nil {\n+\t\t\t\tif dirInfo.tsConfigJson.paths != nil {\n+\t\t\t\t\tfor key, originalPaths := range dirInfo.tsConfigJson.paths {\n+\t\t\t\t\t\tfor _, originalPath := range originalPaths {\n+\t\t\t\t\t\t\tif matched, err := regexp.MatchString(\"^\"+key, path); matched && err == nil {\n+\t\t\t\t\t\t\t\tif absoluteOriginalPath, err := resolvePathWithoutStar(*dirInfo.tsConfigJson.absPathBaseUrl, originalPath); err == nil {\n+\t\t\t\t\t\t\t\t\telements := strings.Split(path, \"/\")\n+\n+\t\t\t\t\t\t\t\t\telements = elements[1:]\n+\n+\t\t\t\t\t\t\t\t\tresolved := append(strings.Split(absoluteOriginalPath, string(os.PathSeparator)), elements...)\n+\t\t\t\t\t\t\t\t\tbasePath := strings.Join(resolved, \"/\")\n+\t\t\t\t\t\t\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n+\t\t\t\t\t\t\t\t\t\treturn absolute, true\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "430842408",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 144,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "430842408",
        "commented_code": "@@ -578,13 +601,43 @@ func (r *resolver) loadAsFileOrDirectory(path string) (string, bool) {\n \treturn \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil\n+}\n+\n func (r *resolver) loadNodeModules(path string, dirInfo *dirInfo) (string, bool) {\n \tfor {\n \t\t// Handle TypeScript base URLs for TypeScript code\n-\t\tif dirInfo.tsConfigJson != nil && dirInfo.tsConfigJson.absPathBaseUrl != nil {\n-\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)\n-\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n-\t\t\t\treturn absolute, true\n+\t\tif dirInfo.tsConfigJson != nil {\n+\n+\t\t\tif dirInfo.tsConfigJson.absPathBaseUrl != nil {\n+\t\t\t\tif dirInfo.tsConfigJson.paths != nil {\n+\t\t\t\t\tfor key, originalPaths := range dirInfo.tsConfigJson.paths {\n+\t\t\t\t\t\tfor _, originalPath := range originalPaths {\n+\t\t\t\t\t\t\tif matched, err := regexp.MatchString(\"^\"+key, path); matched && err == nil {\n+\t\t\t\t\t\t\t\tif absoluteOriginalPath, err := resolvePathWithoutStar(*dirInfo.tsConfigJson.absPathBaseUrl, originalPath); err == nil {\n+\t\t\t\t\t\t\t\t\telements := strings.Split(path, \"/\")\n+\n+\t\t\t\t\t\t\t\t\telements = elements[1:]\n+\n+\t\t\t\t\t\t\t\t\tresolved := append(strings.Split(absoluteOriginalPath, string(os.PathSeparator)), elements...)\n+\t\t\t\t\t\t\t\t\tbasePath := strings.Join(resolved, \"/\")\n+\t\t\t\t\t\t\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n+\t\t\t\t\t\t\t\t\t\treturn absolute, true\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)",
        "comment_created_at": "2020-05-27T03:52:07+00:00",
        "comment_author": "evanw",
        "comment_body": "It looks like the TypeScript compiler still respects `baseUrl` if no `paths` matched, so we should do that too.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "430876828",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 144,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "430842408",
        "commented_code": "@@ -578,13 +601,43 @@ func (r *resolver) loadAsFileOrDirectory(path string) (string, bool) {\n \treturn \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil\n+}\n+\n func (r *resolver) loadNodeModules(path string, dirInfo *dirInfo) (string, bool) {\n \tfor {\n \t\t// Handle TypeScript base URLs for TypeScript code\n-\t\tif dirInfo.tsConfigJson != nil && dirInfo.tsConfigJson.absPathBaseUrl != nil {\n-\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)\n-\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n-\t\t\t\treturn absolute, true\n+\t\tif dirInfo.tsConfigJson != nil {\n+\n+\t\t\tif dirInfo.tsConfigJson.absPathBaseUrl != nil {\n+\t\t\t\tif dirInfo.tsConfigJson.paths != nil {\n+\t\t\t\t\tfor key, originalPaths := range dirInfo.tsConfigJson.paths {\n+\t\t\t\t\t\tfor _, originalPath := range originalPaths {\n+\t\t\t\t\t\t\tif matched, err := regexp.MatchString(\"^\"+key, path); matched && err == nil {\n+\t\t\t\t\t\t\t\tif absoluteOriginalPath, err := resolvePathWithoutStar(*dirInfo.tsConfigJson.absPathBaseUrl, originalPath); err == nil {\n+\t\t\t\t\t\t\t\t\telements := strings.Split(path, \"/\")\n+\n+\t\t\t\t\t\t\t\t\telements = elements[1:]\n+\n+\t\t\t\t\t\t\t\t\tresolved := append(strings.Split(absoluteOriginalPath, string(os.PathSeparator)), elements...)\n+\t\t\t\t\t\t\t\t\tbasePath := strings.Join(resolved, \"/\")\n+\t\t\t\t\t\t\t\t\tif absolute, ok := r.loadAsFileOrDirectory(basePath); ok {\n+\t\t\t\t\t\t\t\t\t\treturn absolute, true\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tbasePath := r.fs.Join(*dirInfo.tsConfigJson.absPathBaseUrl, path)",
        "comment_created_at": "2020-05-27T06:06:48+00:00",
        "comment_author": "viankakrisna",
        "comment_body": "thanks! resolved on 2587e08d326018a478aa1b0ec1c8b0837ad846a2",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "430843045",
    "pr_number": 144,
    "pr_file": "internal/resolver/resolver.go",
    "created_at": "2020-05-27T03:55:03+00:00",
    "commented_code": "return \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil",
    "repo_full_name": "evanw/esbuild",
    "discussion_comments": [
      {
        "comment_id": "430843045",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 144,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "430843045",
        "commented_code": "@@ -578,13 +601,43 @@ func (r *resolver) loadAsFileOrDirectory(path string) (string, bool) {\n \treturn \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil",
        "comment_created_at": "2020-05-27T03:55:03+00:00",
        "comment_author": "evanw",
        "comment_body": "The code in this file is careful to always use the `fs` interface in the `resolver` instead of `path/filepath`. All platform-dependent things are supposed to happen inside the `fs` interface so that the resolver can be platform-independent. That interface uses the real `path/filepath` module for the esbuild command and the `path` module for tests. That way tests don't do different things on Windows.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "430877554",
        "repo_full_name": "evanw/esbuild",
        "pr_number": 144,
        "pr_file": "internal/resolver/resolver.go",
        "discussion_id": "430843045",
        "commented_code": "@@ -578,13 +601,43 @@ func (r *resolver) loadAsFileOrDirectory(path string) (string, bool) {\n \treturn \"\", false\n }\n \n+func resolvePathWithoutStar(from, path string) (string, error) {\n+\treplaced := strings.Replace(path, \"/*\", \"\", -1)\n+\treturn fp.Join(from, replaced), nil",
        "comment_created_at": "2020-05-27T06:09:04+00:00",
        "comment_author": "viankakrisna",
        "comment_body": "thank you! resolved in 444bfae",
        "pr_file_module": null
      }
    ]
  }
]