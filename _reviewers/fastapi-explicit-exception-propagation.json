[
  {
    "discussion_id": "1553933116",
    "pr_number": 11411,
    "pr_file": "docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md",
    "created_at": "2024-04-05T15:59:23+00:00",
    "commented_code": "{!> ../../../docs_src/dependencies/tutorial006_an.py!}\n     ```\n \n-=== \"Python 3.8 non-Annotated\"\n+=== \"Python 3.8 без Annotated\"\n \n-    !!! tip\n-        Prefer to use the `Annotated` version if possible.\n+    !!! Подсказка\n+        Рекомендуется использовать версию с Annotated если возможно.\n \n     ```Python hl_lines=\"17\"\n     {!> ../../../docs_src/dependencies/tutorial006.py!}\n     ```\n \n-These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your *path operation function*.\n+Зависимости из dependencies выполнятся так же, как и обычные зависимости. Но их значения (если они были) не будут переданы в *функцию операции пути*.\n \n-!!! tip\n-    Some editors check for unused function parameters, and show them as errors.\n+!!! Подсказка\n+    Некоторые редакторы кода определяют неиспользуемые параметры функций и подсвечивают их как ошибку.\n \n-    Using these `dependencies` in the *path operation decorator* you can make sure they are executed while avoiding editor/tooling errors.\n+    Использование `dependencies` в *декораторе операции пути* гарантирует выполнение зависимостей, избегая при этом предупреждений редактора кода и других инструментов.\n \n-    It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.\n+    Это также должно помочь предотвратить замешательство у начинающих разработчиков, которые видят неиспользуемые параметры в коде и могут подумать что в них нет необходимости.\n \n-!!! info\n-    In this example we use invented custom headers `X-Key` and `X-Token`.\n+!!! Дополнительная информация\n+    В этом примере мы используем выдуманные пользовательские заголовки `X-Key` и `X-Token`.\n \n-    But in real cases, when implementing security, you would get more benefits from using the integrated [Security utilities (the next chapter)](../security/index.md){.internal-link target=_blank}.\n+    Но в реальных проектах, при внедрении системы безопасности, вы получите больше пользы от использоваания такого подхода [Настройка авторизации (следующая глава)](../security/index.md){.internal-link target=_blank}.\n \n-## Dependencies errors and return values\n+## Исключения в dependencies и возвращаемые значения",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1553933116",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 11411,
        "pr_file": "docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md",
        "discussion_id": "1553933116",
        "commented_code": "@@ -26,36 +26,36 @@ It should be a `list` of `Depends()`:\n     {!> ../../../docs_src/dependencies/tutorial006_an.py!}\n     ```\n \n-=== \"Python 3.8 non-Annotated\"\n+=== \"Python 3.8 без Annotated\"\n \n-    !!! tip\n-        Prefer to use the `Annotated` version if possible.\n+    !!! Подсказка\n+        Рекомендуется использовать версию с Annotated если возможно.\n \n     ```Python hl_lines=\"17\"\n     {!> ../../../docs_src/dependencies/tutorial006.py!}\n     ```\n \n-These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your *path operation function*.\n+Зависимости из dependencies выполнятся так же, как и обычные зависимости. Но их значения (если они были) не будут переданы в *функцию операции пути*.\n \n-!!! tip\n-    Some editors check for unused function parameters, and show them as errors.\n+!!! Подсказка\n+    Некоторые редакторы кода определяют неиспользуемые параметры функций и подсвечивают их как ошибку.\n \n-    Using these `dependencies` in the *path operation decorator* you can make sure they are executed while avoiding editor/tooling errors.\n+    Использование `dependencies` в *декораторе операции пути* гарантирует выполнение зависимостей, избегая при этом предупреждений редактора кода и других инструментов.\n \n-    It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.\n+    Это также должно помочь предотвратить замешательство у начинающих разработчиков, которые видят неиспользуемые параметры в коде и могут подумать что в них нет необходимости.\n \n-!!! info\n-    In this example we use invented custom headers `X-Key` and `X-Token`.\n+!!! Дополнительная информация\n+    В этом примере мы используем выдуманные пользовательские заголовки `X-Key` и `X-Token`.\n \n-    But in real cases, when implementing security, you would get more benefits from using the integrated [Security utilities (the next chapter)](../security/index.md){.internal-link target=_blank}.\n+    Но в реальных проектах, при внедрении системы безопасности, вы получите больше пользы от использоваания такого подхода [Настройка авторизации (следующая глава)](../security/index.md){.internal-link target=_blank}.\n \n-## Dependencies errors and return values\n+## Исключения в dependencies и возвращаемые значения",
        "comment_created_at": "2024-04-05T15:59:23+00:00",
        "comment_author": "s111d",
        "comment_body": "Лучше  прямо \"ошибки\", потому что исключения в Питоне – отдельная история.",
        "pr_file_module": null
      },
      {
        "comment_id": "1554555274",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 11411,
        "pr_file": "docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md",
        "discussion_id": "1553933116",
        "commented_code": "@@ -26,36 +26,36 @@ It should be a `list` of `Depends()`:\n     {!> ../../../docs_src/dependencies/tutorial006_an.py!}\n     ```\n \n-=== \"Python 3.8 non-Annotated\"\n+=== \"Python 3.8 без Annotated\"\n \n-    !!! tip\n-        Prefer to use the `Annotated` version if possible.\n+    !!! Подсказка\n+        Рекомендуется использовать версию с Annotated если возможно.\n \n     ```Python hl_lines=\"17\"\n     {!> ../../../docs_src/dependencies/tutorial006.py!}\n     ```\n \n-These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your *path operation function*.\n+Зависимости из dependencies выполнятся так же, как и обычные зависимости. Но их значения (если они были) не будут переданы в *функцию операции пути*.\n \n-!!! tip\n-    Some editors check for unused function parameters, and show them as errors.\n+!!! Подсказка\n+    Некоторые редакторы кода определяют неиспользуемые параметры функций и подсвечивают их как ошибку.\n \n-    Using these `dependencies` in the *path operation decorator* you can make sure they are executed while avoiding editor/tooling errors.\n+    Использование `dependencies` в *декораторе операции пути* гарантирует выполнение зависимостей, избегая при этом предупреждений редактора кода и других инструментов.\n \n-    It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.\n+    Это также должно помочь предотвратить замешательство у начинающих разработчиков, которые видят неиспользуемые параметры в коде и могут подумать что в них нет необходимости.\n \n-!!! info\n-    In this example we use invented custom headers `X-Key` and `X-Token`.\n+!!! Дополнительная информация\n+    В этом примере мы используем выдуманные пользовательские заголовки `X-Key` и `X-Token`.\n \n-    But in real cases, when implementing security, you would get more benefits from using the integrated [Security utilities (the next chapter)](../security/index.md){.internal-link target=_blank}.\n+    Но в реальных проектах, при внедрении системы безопасности, вы получите больше пользы от использоваания такого подхода [Настройка авторизации (следующая глава)](../security/index.md){.internal-link target=_blank}.\n \n-## Dependencies errors and return values\n+## Исключения в dependencies и возвращаемые значения",
        "comment_created_at": "2024-04-06T09:22:40+00:00",
        "comment_author": "anton2yakovlev",
        "comment_body": "В этом разделе речь как раз таки о питоновских исключениях и их вызове с помощью `raise`.\r\n\r\n> Raise exceptions\r\n> \r\n> These dependencies can raise exceptions, the same as normal dependencies:\r\n> ```\r\n> async def verify_token(x_token: Annotated[str, Header()]):\r\n>     if x_token != \"fake-super-secret-token\":\r\n>         raise HTTPException(status_code=400, detail=\"X-Token header invalid\")\r\n> ```",
        "pr_file_module": null
      },
      {
        "comment_id": "1554632830",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 11411,
        "pr_file": "docs/ru/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md",
        "discussion_id": "1553933116",
        "commented_code": "@@ -26,36 +26,36 @@ It should be a `list` of `Depends()`:\n     {!> ../../../docs_src/dependencies/tutorial006_an.py!}\n     ```\n \n-=== \"Python 3.8 non-Annotated\"\n+=== \"Python 3.8 без Annotated\"\n \n-    !!! tip\n-        Prefer to use the `Annotated` version if possible.\n+    !!! Подсказка\n+        Рекомендуется использовать версию с Annotated если возможно.\n \n     ```Python hl_lines=\"17\"\n     {!> ../../../docs_src/dependencies/tutorial006.py!}\n     ```\n \n-These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your *path operation function*.\n+Зависимости из dependencies выполнятся так же, как и обычные зависимости. Но их значения (если они были) не будут переданы в *функцию операции пути*.\n \n-!!! tip\n-    Some editors check for unused function parameters, and show them as errors.\n+!!! Подсказка\n+    Некоторые редакторы кода определяют неиспользуемые параметры функций и подсвечивают их как ошибку.\n \n-    Using these `dependencies` in the *path operation decorator* you can make sure they are executed while avoiding editor/tooling errors.\n+    Использование `dependencies` в *декораторе операции пути* гарантирует выполнение зависимостей, избегая при этом предупреждений редактора кода и других инструментов.\n \n-    It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.\n+    Это также должно помочь предотвратить замешательство у начинающих разработчиков, которые видят неиспользуемые параметры в коде и могут подумать что в них нет необходимости.\n \n-!!! info\n-    In this example we use invented custom headers `X-Key` and `X-Token`.\n+!!! Дополнительная информация\n+    В этом примере мы используем выдуманные пользовательские заголовки `X-Key` и `X-Token`.\n \n-    But in real cases, when implementing security, you would get more benefits from using the integrated [Security utilities (the next chapter)](../security/index.md){.internal-link target=_blank}.\n+    Но в реальных проектах, при внедрении системы безопасности, вы получите больше пользы от использоваания такого подхода [Настройка авторизации (следующая глава)](../security/index.md){.internal-link target=_blank}.\n \n-## Dependencies errors and return values\n+## Исключения в dependencies и возвращаемые значения",
        "comment_created_at": "2024-04-06T16:01:07+00:00",
        "comment_author": "s111d",
        "comment_body": "Не критично.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1938240448",
    "pr_number": 13257,
    "pr_file": "docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md",
    "created_at": "2025-02-01T09:41:21+00:00",
    "commented_code": "+# yield를 사용하는 의존성\n+\n+FastAPI는 <abbr title='때로는 \"종료 코드\", \"정리 코드\", \"정리 작업 코드\", \"종료 처리 코드\", \"컨텍스트 관리자 종료 코드\" 등으로도 불립니다'>작업 완료 후 추가 단계를 수행하는</abbr> 의존성을 지원합니다.\n+\n+이를 구현하려면 `return` 대신 `yield`를 사용하고, 추가로 실행할 단계(코드)를 그 뒤에 작성하세요.\n+\n+/// tip | 팁\n+\n+각 의존성마다 `yield`는 한 번만 사용해야 합니다.\n+\n+///\n+\n+/// note | 기술 세부사항\n+\n+다음과 함께 사용할 수 있는 모든 함수:\n+\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.contextmanager`</a> 또는\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.asynccontextmanager`</a>\n+\n+는 **FastAPI**의 의존성으로 사용할 수 있습니다.\n+\n+사실, FastAPI는 내부적으로 이 두 데코레이터를 사용합니다.\n+\n+///\n+\n+## `yield`를 사용하는 데이터베이스 의존성\n+\n+예를 들어, 이 기능을 사용하면 데이터베이스 세션을 생성하고 작업이 끝난 후에 세션을 종료할 수 있습니다.\n+\n+응답을 생성하기 전에는 `yield`를 포함하여 그 이전의 코드만이 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[2:4] *}\n+\n+yield된 값은 *경로 작업* 및 다른 의존성들에 주입되는 값 입니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[4] *}\n+\n+`yield`문 다음의 코드는 응답을 생성한 후 보내기 전에 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[5:6] *}\n+\n+/// tip | 팁\n+\n+`async` 함수와 일반 함수 모두 사용할 수 있습니다.\n+\n+**FastAPI**는 일반 의존성과 마찬가지로 각각의 함수를 올바르게 처리할 것입니다.\n+\n+///\n+\n+## `yield`와 `try`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `try` 블록을 사용한다면, 의존성을 사용하는 도중 발생한 모든 예외를 받을 수 있습니다.\n+\n+예를 들어, 다른 의존성이나 *경로 작업*의 중간에 데이터베이스 트랜잭션 \"롤백\"이 발생하거나 다른 오류가 발생한다면, 해당 예외를 의존성에서 받을 수 있습니다.\n+\n+따라서, 의존성 내에서 `except SomeException`을 사용하여 특정 예외를 처리할 수 있습니다.\n+\n+마찬가지로, `finally`를 사용하여 예외 발생 여부와 관계 없이 종료 단계까 실행되도록 할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[3,5] *}\n+\n+## `yield`를 사용하는 하위 의존성\n+\n+어떤 크기와 형태의 하위 의존성과 \"하위 의존성 트리\"도 가질 수 있으며, 이들 모두가 `yield`를 사용할 수 있습니다.\n+\n+**FastAPI**는 `yield`를 사용하는 각 의존성의 \"종료 코드\"가 올바른 순서로 실행되도록 보장합니다.\n+\n+예를 들어, `dependency_c`는 `dependency_b`에 의존할 수 있고, `dependency_b`는 `dependency_a`에 의존할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}\n+\n+이들 모두는 `yield`를 사용할 수 있습니다.\n+\n+이 경우 `dependency_c`는 종료 코드를 실행하기 위해, `dependency_b`의 값 (여기서는 `dep_b`로 명명)이 여전히 사용 가능해야 합니다.\n+\n+그리고, `dependency_b`는 종료 코드를 위해 `dependency_a`의 값 (여기서는 `dep_a`로 명명) 이 사용 가능해야 합니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}\n+\n+같은 방식으로, `yield`를 사용하는 의존성과 `return`을 사용하는 의존성을 함께 사용할 수 있으며, 이들 중 일부가 다른 것들에 의존할 수 있습니다.\n+\n+그리고 `yield`를 사용하는 다른 여러 의존성을 필요로 하는 단일 의존성을 가질 수도 있습니다.\n+\n+원하는 의존성을 원하는 대로 조합할 수 있습니다.\n+\n+**FastAPI**는 모든 것이 올바른 순서로 실행되도록 보장합니다.\n+\n+/// note | 기술 세부사항\n+\n+파이썬의 <a href=“https://docs.python.org/3/library/contextlib.html” class=“external-link” target=“_blank”>Context Managers</a> 덕분에 이 기능이 작동합니다.\n+\n+**FastAPI**는 이를 내부적으로 컨텍스트 관리자를 사용하여 구현합니다.\n+\n+///\n+\n+## `yield`와 `HTTPException`를 사용하는 의존성\n+\n+`yield`와 `try` 블록이 있는 의존성을 사용하여 예외를 처리할 수 있다는 것을 알게 되었습니다.\n+\n+같은 방식으로, `yield` 이후의 종료 코드에서 `HTTPException`이나 유사한 예외를 발생시킬 수 있습니다.\n+\n+/// tip | 팁\n+\n+이것은 다소 고급 기술이며, 대부분의 경우에는 경로 작업 함수와 같은 애플리케이션 코드 내에서 직접 `HTTPException`을 포함한 예외를 발생시킬 수 있기 때문에 실제로 필요하지 않습니다.\n+\n+하지만 필요한 경우 사용할 수 있습니다. 🤓\n+\n+///\n+\n+{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}\n+\n+예외를 처리하고(또는 추가로 다른 `HTTPException`을 발생시키기 위해) 사용할 수 있는 또 다른 방법은 [사용자 정의 예외 처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}를 생성하는 것 입니다.\n+\n+## `yield`와 `except`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `except`를 사용하여 예외를 포착하고 예외를 다시 발생시키지 않거나 (또는 새 예외를 발생시키지 않으면), FastAPI는 해당 예외가 발생했는지 알 수 없습니다. 이는 일반적인 Python 방식과 동일합니다:\n+\n+{* ../../docs_src/dependencies/tutorial008c_an_py39.py hl[15:16] *}\n+\n+이 경우, HTTPException이나 유사한 예외를 발생시키지 않기 때문에 클라이언트는 HTTP 500 Internal Server Error 응답을 보게 되지만, 서버는 어떤 오류가 발생했는지에 대한 **로그**나 다른 표시를 전혀 가지지 않게 됩니다. 😱",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1938240448",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13257,
        "pr_file": "docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md",
        "discussion_id": "1938240448",
        "commented_code": "@@ -0,0 +1,275 @@\n+# yield를 사용하는 의존성\n+\n+FastAPI는 <abbr title='때로는 \"종료 코드\", \"정리 코드\", \"정리 작업 코드\", \"종료 처리 코드\", \"컨텍스트 관리자 종료 코드\" 등으로도 불립니다'>작업 완료 후 추가 단계를 수행하는</abbr> 의존성을 지원합니다.\n+\n+이를 구현하려면 `return` 대신 `yield`를 사용하고, 추가로 실행할 단계(코드)를 그 뒤에 작성하세요.\n+\n+/// tip | 팁\n+\n+각 의존성마다 `yield`는 한 번만 사용해야 합니다.\n+\n+///\n+\n+/// note | 기술 세부사항\n+\n+다음과 함께 사용할 수 있는 모든 함수:\n+\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.contextmanager`</a> 또는\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.asynccontextmanager`</a>\n+\n+는 **FastAPI**의 의존성으로 사용할 수 있습니다.\n+\n+사실, FastAPI는 내부적으로 이 두 데코레이터를 사용합니다.\n+\n+///\n+\n+## `yield`를 사용하는 데이터베이스 의존성\n+\n+예를 들어, 이 기능을 사용하면 데이터베이스 세션을 생성하고 작업이 끝난 후에 세션을 종료할 수 있습니다.\n+\n+응답을 생성하기 전에는 `yield`를 포함하여 그 이전의 코드만이 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[2:4] *}\n+\n+yield된 값은 *경로 작업* 및 다른 의존성들에 주입되는 값 입니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[4] *}\n+\n+`yield`문 다음의 코드는 응답을 생성한 후 보내기 전에 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[5:6] *}\n+\n+/// tip | 팁\n+\n+`async` 함수와 일반 함수 모두 사용할 수 있습니다.\n+\n+**FastAPI**는 일반 의존성과 마찬가지로 각각의 함수를 올바르게 처리할 것입니다.\n+\n+///\n+\n+## `yield`와 `try`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `try` 블록을 사용한다면, 의존성을 사용하는 도중 발생한 모든 예외를 받을 수 있습니다.\n+\n+예를 들어, 다른 의존성이나 *경로 작업*의 중간에 데이터베이스 트랜잭션 \"롤백\"이 발생하거나 다른 오류가 발생한다면, 해당 예외를 의존성에서 받을 수 있습니다.\n+\n+따라서, 의존성 내에서 `except SomeException`을 사용하여 특정 예외를 처리할 수 있습니다.\n+\n+마찬가지로, `finally`를 사용하여 예외 발생 여부와 관계 없이 종료 단계까 실행되도록 할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[3,5] *}\n+\n+## `yield`를 사용하는 하위 의존성\n+\n+어떤 크기와 형태의 하위 의존성과 \"하위 의존성 트리\"도 가질 수 있으며, 이들 모두가 `yield`를 사용할 수 있습니다.\n+\n+**FastAPI**는 `yield`를 사용하는 각 의존성의 \"종료 코드\"가 올바른 순서로 실행되도록 보장합니다.\n+\n+예를 들어, `dependency_c`는 `dependency_b`에 의존할 수 있고, `dependency_b`는 `dependency_a`에 의존할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}\n+\n+이들 모두는 `yield`를 사용할 수 있습니다.\n+\n+이 경우 `dependency_c`는 종료 코드를 실행하기 위해, `dependency_b`의 값 (여기서는 `dep_b`로 명명)이 여전히 사용 가능해야 합니다.\n+\n+그리고, `dependency_b`는 종료 코드를 위해 `dependency_a`의 값 (여기서는 `dep_a`로 명명) 이 사용 가능해야 합니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}\n+\n+같은 방식으로, `yield`를 사용하는 의존성과 `return`을 사용하는 의존성을 함께 사용할 수 있으며, 이들 중 일부가 다른 것들에 의존할 수 있습니다.\n+\n+그리고 `yield`를 사용하는 다른 여러 의존성을 필요로 하는 단일 의존성을 가질 수도 있습니다.\n+\n+원하는 의존성을 원하는 대로 조합할 수 있습니다.\n+\n+**FastAPI**는 모든 것이 올바른 순서로 실행되도록 보장합니다.\n+\n+/// note | 기술 세부사항\n+\n+파이썬의 <a href=“https://docs.python.org/3/library/contextlib.html” class=“external-link” target=“_blank”>Context Managers</a> 덕분에 이 기능이 작동합니다.\n+\n+**FastAPI**는 이를 내부적으로 컨텍스트 관리자를 사용하여 구현합니다.\n+\n+///\n+\n+## `yield`와 `HTTPException`를 사용하는 의존성\n+\n+`yield`와 `try` 블록이 있는 의존성을 사용하여 예외를 처리할 수 있다는 것을 알게 되었습니다.\n+\n+같은 방식으로, `yield` 이후의 종료 코드에서 `HTTPException`이나 유사한 예외를 발생시킬 수 있습니다.\n+\n+/// tip | 팁\n+\n+이것은 다소 고급 기술이며, 대부분의 경우에는 경로 작업 함수와 같은 애플리케이션 코드 내에서 직접 `HTTPException`을 포함한 예외를 발생시킬 수 있기 때문에 실제로 필요하지 않습니다.\n+\n+하지만 필요한 경우 사용할 수 있습니다. 🤓\n+\n+///\n+\n+{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}\n+\n+예외를 처리하고(또는 추가로 다른 `HTTPException`을 발생시키기 위해) 사용할 수 있는 또 다른 방법은 [사용자 정의 예외 처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}를 생성하는 것 입니다.\n+\n+## `yield`와 `except`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `except`를 사용하여 예외를 포착하고 예외를 다시 발생시키지 않거나 (또는 새 예외를 발생시키지 않으면), FastAPI는 해당 예외가 발생했는지 알 수 없습니다. 이는 일반적인 Python 방식과 동일합니다:\n+\n+{* ../../docs_src/dependencies/tutorial008c_an_py39.py hl[15:16] *}\n+\n+이 경우, HTTPException이나 유사한 예외를 발생시키지 않기 때문에 클라이언트는 HTTP 500 Internal Server Error 응답을 보게 되지만, 서버는 어떤 오류가 발생했는지에 대한 **로그**나 다른 표시를 전혀 가지지 않게 됩니다. 😱",
        "comment_created_at": "2025-02-01T09:41:21+00:00",
        "comment_author": "Zerohertz",
        "comment_body": "```suggestion\r\n이 경우, `HTTPException`이나 유사한 예외를 발생시키지 않기 때문에 클라이언트는 HTTP 500 Internal Server Error 응답을 보게 되지만, 서버는 어떤 오류가 발생했는지에 대한 **로그**나 다른 표시를 전혀 가지지 않게 됩니다. 😱\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1938241064",
    "pr_number": 13257,
    "pr_file": "docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md",
    "created_at": "2025-02-01T09:46:23+00:00",
    "commented_code": "+# yield를 사용하는 의존성\n+\n+FastAPI는 <abbr title='때로는 \"종료 코드\", \"정리 코드\", \"정리 작업 코드\", \"종료 처리 코드\", \"컨텍스트 관리자 종료 코드\" 등으로도 불립니다'>작업 완료 후 추가 단계를 수행하는</abbr> 의존성을 지원합니다.\n+\n+이를 구현하려면 `return` 대신 `yield`를 사용하고, 추가로 실행할 단계(코드)를 그 뒤에 작성하세요.\n+\n+/// tip | 팁\n+\n+각 의존성마다 `yield`는 한 번만 사용해야 합니다.\n+\n+///\n+\n+/// note | 기술 세부사항\n+\n+다음과 함께 사용할 수 있는 모든 함수:\n+\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.contextmanager`</a> 또는\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.asynccontextmanager`</a>\n+\n+는 **FastAPI**의 의존성으로 사용할 수 있습니다.\n+\n+사실, FastAPI는 내부적으로 이 두 데코레이터를 사용합니다.\n+\n+///\n+\n+## `yield`를 사용하는 데이터베이스 의존성\n+\n+예를 들어, 이 기능을 사용하면 데이터베이스 세션을 생성하고 작업이 끝난 후에 세션을 종료할 수 있습니다.\n+\n+응답을 생성하기 전에는 `yield`를 포함하여 그 이전의 코드만이 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[2:4] *}\n+\n+yield된 값은 *경로 작업* 및 다른 의존성들에 주입되는 값 입니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[4] *}\n+\n+`yield`문 다음의 코드는 응답을 생성한 후 보내기 전에 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[5:6] *}\n+\n+/// tip | 팁\n+\n+`async` 함수와 일반 함수 모두 사용할 수 있습니다.\n+\n+**FastAPI**는 일반 의존성과 마찬가지로 각각의 함수를 올바르게 처리할 것입니다.\n+\n+///\n+\n+## `yield`와 `try`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `try` 블록을 사용한다면, 의존성을 사용하는 도중 발생한 모든 예외를 받을 수 있습니다.\n+\n+예를 들어, 다른 의존성이나 *경로 작업*의 중간에 데이터베이스 트랜잭션 \"롤백\"이 발생하거나 다른 오류가 발생한다면, 해당 예외를 의존성에서 받을 수 있습니다.\n+\n+따라서, 의존성 내에서 `except SomeException`을 사용하여 특정 예외를 처리할 수 있습니다.\n+\n+마찬가지로, `finally`를 사용하여 예외 발생 여부와 관계 없이 종료 단계까 실행되도록 할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[3,5] *}\n+\n+## `yield`를 사용하는 하위 의존성\n+\n+어떤 크기와 형태의 하위 의존성과 \"하위 의존성 트리\"도 가질 수 있으며, 이들 모두가 `yield`를 사용할 수 있습니다.\n+\n+**FastAPI**는 `yield`를 사용하는 각 의존성의 \"종료 코드\"가 올바른 순서로 실행되도록 보장합니다.\n+\n+예를 들어, `dependency_c`는 `dependency_b`에 의존할 수 있고, `dependency_b`는 `dependency_a`에 의존할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}\n+\n+이들 모두는 `yield`를 사용할 수 있습니다.\n+\n+이 경우 `dependency_c`는 종료 코드를 실행하기 위해, `dependency_b`의 값 (여기서는 `dep_b`로 명명)이 여전히 사용 가능해야 합니다.\n+\n+그리고, `dependency_b`는 종료 코드를 위해 `dependency_a`의 값 (여기서는 `dep_a`로 명명) 이 사용 가능해야 합니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}\n+\n+같은 방식으로, `yield`를 사용하는 의존성과 `return`을 사용하는 의존성을 함께 사용할 수 있으며, 이들 중 일부가 다른 것들에 의존할 수 있습니다.\n+\n+그리고 `yield`를 사용하는 다른 여러 의존성을 필요로 하는 단일 의존성을 가질 수도 있습니다.\n+\n+원하는 의존성을 원하는 대로 조합할 수 있습니다.\n+\n+**FastAPI**는 모든 것이 올바른 순서로 실행되도록 보장합니다.\n+\n+/// note | 기술 세부사항\n+\n+파이썬의 <a href=“https://docs.python.org/3/library/contextlib.html” class=“external-link” target=“_blank”>Context Managers</a> 덕분에 이 기능이 작동합니다.\n+\n+**FastAPI**는 이를 내부적으로 컨텍스트 관리자를 사용하여 구현합니다.\n+\n+///\n+\n+## `yield`와 `HTTPException`를 사용하는 의존성\n+\n+`yield`와 `try` 블록이 있는 의존성을 사용하여 예외를 처리할 수 있다는 것을 알게 되었습니다.\n+\n+같은 방식으로, `yield` 이후의 종료 코드에서 `HTTPException`이나 유사한 예외를 발생시킬 수 있습니다.\n+\n+/// tip | 팁\n+\n+이것은 다소 고급 기술이며, 대부분의 경우에는 경로 작업 함수와 같은 애플리케이션 코드 내에서 직접 `HTTPException`을 포함한 예외를 발생시킬 수 있기 때문에 실제로 필요하지 않습니다.\n+\n+하지만 필요한 경우 사용할 수 있습니다. 🤓\n+\n+///\n+\n+{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}\n+\n+예외를 처리하고(또는 추가로 다른 `HTTPException`을 발생시키기 위해) 사용할 수 있는 또 다른 방법은 [사용자 정의 예외 처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}를 생성하는 것 입니다.\n+\n+## `yield`와 `except`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `except`를 사용하여 예외를 포착하고 예외를 다시 발생시키지 않거나 (또는 새 예외를 발생시키지 않으면), FastAPI는 해당 예외가 발생했는지 알 수 없습니다. 이는 일반적인 Python 방식과 동일합니다:\n+\n+{* ../../docs_src/dependencies/tutorial008c_an_py39.py hl[15:16] *}\n+\n+이 경우, HTTPException이나 유사한 예외를 발생시키지 않기 때문에 클라이언트는 HTTP 500 Internal Server Error 응답을 보게 되지만, 서버는 어떤 오류가 발생했는지에 대한 **로그**나 다른 표시를 전혀 가지지 않게 됩니다. 😱\n+\n+### `yield`와 `except`를 사용하는 의존성에서 항상 `raise` 하기\n+\n+`yield`가 있는 의존성에서 예외를 잡았을 때는 `HTTPException`이나 유사한 예외를 새로 발생시키지 않는 한, 반드시 원래의 예외를 다시 발생시켜야 합니다.\n+\n+`raise`를 사용하여 동일한 예외를 다시 발생시킬 수 있습니다:\n+\n+{* ../../docs_src/dependencies/tutorial008d_an_py39.py hl[17] *}\n+\n+이제 클라이언트는 동일한 *HTTP 500 Internal Server Error* 오류 응답을 받게 되지만, 서버 로그에는 사용자 정의 예외인 `InternalError\"가 기록됩니다. 😎\n+\n+## `yield`를 사용하는 의존성의 실행 순서\n+\n+실행 순서는 대략 다음 다이어그램과 같습니다. 시간은 위에서 아래로 흐르며, 각 열은 코드를 실행하거나 상호 작용하는 부분 중 하나입니다.\n+\n+```mermaid\n+sequenceDiagram\n+\n+participant client as Client\n+participant handler as Exception handler\n+participant dep as Dep with yield\n+participant operation as Path Operation\n+participant tasks as Background tasks\n+\n+    Note over client,operation: Can raise exceptions, including HTTPException\n+    client ->> dep: Start request\n+    Note over dep: Run code up to yield\n+    opt raise Exception\n+        dep -->> handler: Raise Exception\n+        handler -->> client: HTTP error response\n+    end\n+    dep ->> operation: Run dependency, e.g. DB session\n+    opt raise\n+        operation -->> dep: Raise Exception (e.g. HTTPException)\n+        opt handle\n+            dep -->> dep: Can catch exception, raise a new HTTPException, raise other exception\n+        end\n+        handler -->> client: HTTP error response\n+    end\n+\n+    operation ->> client: Return response to client\n+    Note over client,operation: Response is already sent, can't change it anymore\n+    opt Tasks\n+        operation -->> tasks: Send background tasks\n+    end\n+    opt Raise other exception\n+        tasks -->> tasks: Handle exceptions in the background task code\n+    end\n+```\n+\n+/// info | 정보\n+\n+클라이언트에 **하나의 응답** 만 전송됩니다. 이는 오류 응답 중 하나일 수도 있고,*경로 작업*에서 생성된 응답일 수도 있습니다.\n+\n+이러한 응답 중 하나가 전송된 후에는 다른 응답을 보낼 수 없습니다.\n+\n+///\n+\n+/// tip | 팁\n+\n+이 다이어그램은 `HTTPException`을 보여주지만, `yield`를 사용하는 의존성에서 처리한 예외나 [사용자 정의 예외처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}.를 사용하여 처리한 다른 예외도 발생시킬 수 있습니다.\n+\n+어떤 예외가 발생하든, `HTTPException`을 포함하여 yield를 사용하는 의존성으로 전달됩니다. 대부분의 경우 예외를 다시 발생시키거나 새로운 예외를 발생시켜야 합니다.\n+\n+///\n+\n+## `yield`, `HTTPException`, `except` 및 백그라운드 작업을 사용하는 의존성\n+\n+/// warning | 경고\n+\n+이러한 기술적 세부 사항은 대부분 필요하지 않으므로 이 섹션을 건너뛰고 아래에서 계속 진행해도 됩니다.\n+\n+이러한 세부 정보는 주로 FastAPI 0.106.0 이전 버전에서 `yeild`가 있는 의존성의 리소스를 백그라운드 작업에서 사용했던 경우메 유용합니다.\n+\n+///\n+\n+### `yield`와 `except`를 사용하는 의존성: 기술 세부사항\n+\n+FastAPI 0.110.0 이전에는 `yield`가 포함된 의존성을 사용한 후 해당 의존성에서 `except`가 포함된 예외를 캡처하고 다시 예외를 발생시키지 않으면 예외가 자동으로 예외 핸들러 또는 내부 서버 오류 핸들러로 발생/전달되었습니다.\n+\n+이는 처리기 없이 전달된 예외(내부 서버 오류)에서 처리되지 않은 메모리 소비를 수정하고 일반 파이썬 코드의 동작과 일치하도록 하기 위해 0.110.0 버전에서 변경되었습니다.\n+\n+### 백그라운드 작업과 `yield`를 사용하는 기술 세부사항\n+\n+FastAPI 0.106.0 이전에는 yield 이후에 예외를 발생시키는 것이 불가능했습니다. `yield`가 있는 의존성 종료 코드는 응답이 전송된 이후에 실행되었기 때문에, [예외 처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}가 이미 실행된 상태였습니다.",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1938241064",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13257,
        "pr_file": "docs/ko/docs/tutorial/dependencies/dependencies-with-yield.md",
        "discussion_id": "1938241064",
        "commented_code": "@@ -0,0 +1,275 @@\n+# yield를 사용하는 의존성\n+\n+FastAPI는 <abbr title='때로는 \"종료 코드\", \"정리 코드\", \"정리 작업 코드\", \"종료 처리 코드\", \"컨텍스트 관리자 종료 코드\" 등으로도 불립니다'>작업 완료 후 추가 단계를 수행하는</abbr> 의존성을 지원합니다.\n+\n+이를 구현하려면 `return` 대신 `yield`를 사용하고, 추가로 실행할 단계(코드)를 그 뒤에 작성하세요.\n+\n+/// tip | 팁\n+\n+각 의존성마다 `yield`는 한 번만 사용해야 합니다.\n+\n+///\n+\n+/// note | 기술 세부사항\n+\n+다음과 함께 사용할 수 있는 모든 함수:\n+\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.contextmanager`</a> 또는\n+* <a href=\"https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager\" class=\"external-link\" target=\"_blank\">`@contextlib.asynccontextmanager`</a>\n+\n+는 **FastAPI**의 의존성으로 사용할 수 있습니다.\n+\n+사실, FastAPI는 내부적으로 이 두 데코레이터를 사용합니다.\n+\n+///\n+\n+## `yield`를 사용하는 데이터베이스 의존성\n+\n+예를 들어, 이 기능을 사용하면 데이터베이스 세션을 생성하고 작업이 끝난 후에 세션을 종료할 수 있습니다.\n+\n+응답을 생성하기 전에는 `yield`를 포함하여 그 이전의 코드만이 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[2:4] *}\n+\n+yield된 값은 *경로 작업* 및 다른 의존성들에 주입되는 값 입니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[4] *}\n+\n+`yield`문 다음의 코드는 응답을 생성한 후 보내기 전에 실행됩니다:\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[5:6] *}\n+\n+/// tip | 팁\n+\n+`async` 함수와 일반 함수 모두 사용할 수 있습니다.\n+\n+**FastAPI**는 일반 의존성과 마찬가지로 각각의 함수를 올바르게 처리할 것입니다.\n+\n+///\n+\n+## `yield`와 `try`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `try` 블록을 사용한다면, 의존성을 사용하는 도중 발생한 모든 예외를 받을 수 있습니다.\n+\n+예를 들어, 다른 의존성이나 *경로 작업*의 중간에 데이터베이스 트랜잭션 \"롤백\"이 발생하거나 다른 오류가 발생한다면, 해당 예외를 의존성에서 받을 수 있습니다.\n+\n+따라서, 의존성 내에서 `except SomeException`을 사용하여 특정 예외를 처리할 수 있습니다.\n+\n+마찬가지로, `finally`를 사용하여 예외 발생 여부와 관계 없이 종료 단계까 실행되도록 할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial007.py hl[3,5] *}\n+\n+## `yield`를 사용하는 하위 의존성\n+\n+어떤 크기와 형태의 하위 의존성과 \"하위 의존성 트리\"도 가질 수 있으며, 이들 모두가 `yield`를 사용할 수 있습니다.\n+\n+**FastAPI**는 `yield`를 사용하는 각 의존성의 \"종료 코드\"가 올바른 순서로 실행되도록 보장합니다.\n+\n+예를 들어, `dependency_c`는 `dependency_b`에 의존할 수 있고, `dependency_b`는 `dependency_a`에 의존할 수 있습니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}\n+\n+이들 모두는 `yield`를 사용할 수 있습니다.\n+\n+이 경우 `dependency_c`는 종료 코드를 실행하기 위해, `dependency_b`의 값 (여기서는 `dep_b`로 명명)이 여전히 사용 가능해야 합니다.\n+\n+그리고, `dependency_b`는 종료 코드를 위해 `dependency_a`의 값 (여기서는 `dep_a`로 명명) 이 사용 가능해야 합니다.\n+\n+{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}\n+\n+같은 방식으로, `yield`를 사용하는 의존성과 `return`을 사용하는 의존성을 함께 사용할 수 있으며, 이들 중 일부가 다른 것들에 의존할 수 있습니다.\n+\n+그리고 `yield`를 사용하는 다른 여러 의존성을 필요로 하는 단일 의존성을 가질 수도 있습니다.\n+\n+원하는 의존성을 원하는 대로 조합할 수 있습니다.\n+\n+**FastAPI**는 모든 것이 올바른 순서로 실행되도록 보장합니다.\n+\n+/// note | 기술 세부사항\n+\n+파이썬의 <a href=“https://docs.python.org/3/library/contextlib.html” class=“external-link” target=“_blank”>Context Managers</a> 덕분에 이 기능이 작동합니다.\n+\n+**FastAPI**는 이를 내부적으로 컨텍스트 관리자를 사용하여 구현합니다.\n+\n+///\n+\n+## `yield`와 `HTTPException`를 사용하는 의존성\n+\n+`yield`와 `try` 블록이 있는 의존성을 사용하여 예외를 처리할 수 있다는 것을 알게 되었습니다.\n+\n+같은 방식으로, `yield` 이후의 종료 코드에서 `HTTPException`이나 유사한 예외를 발생시킬 수 있습니다.\n+\n+/// tip | 팁\n+\n+이것은 다소 고급 기술이며, 대부분의 경우에는 경로 작업 함수와 같은 애플리케이션 코드 내에서 직접 `HTTPException`을 포함한 예외를 발생시킬 수 있기 때문에 실제로 필요하지 않습니다.\n+\n+하지만 필요한 경우 사용할 수 있습니다. 🤓\n+\n+///\n+\n+{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}\n+\n+예외를 처리하고(또는 추가로 다른 `HTTPException`을 발생시키기 위해) 사용할 수 있는 또 다른 방법은 [사용자 정의 예외 처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}를 생성하는 것 입니다.\n+\n+## `yield`와 `except`를 사용하는 의존성\n+\n+`yield`를 사용하는 의존성에서 `except`를 사용하여 예외를 포착하고 예외를 다시 발생시키지 않거나 (또는 새 예외를 발생시키지 않으면), FastAPI는 해당 예외가 발생했는지 알 수 없습니다. 이는 일반적인 Python 방식과 동일합니다:\n+\n+{* ../../docs_src/dependencies/tutorial008c_an_py39.py hl[15:16] *}\n+\n+이 경우, HTTPException이나 유사한 예외를 발생시키지 않기 때문에 클라이언트는 HTTP 500 Internal Server Error 응답을 보게 되지만, 서버는 어떤 오류가 발생했는지에 대한 **로그**나 다른 표시를 전혀 가지지 않게 됩니다. 😱\n+\n+### `yield`와 `except`를 사용하는 의존성에서 항상 `raise` 하기\n+\n+`yield`가 있는 의존성에서 예외를 잡았을 때는 `HTTPException`이나 유사한 예외를 새로 발생시키지 않는 한, 반드시 원래의 예외를 다시 발생시켜야 합니다.\n+\n+`raise`를 사용하여 동일한 예외를 다시 발생시킬 수 있습니다:\n+\n+{* ../../docs_src/dependencies/tutorial008d_an_py39.py hl[17] *}\n+\n+이제 클라이언트는 동일한 *HTTP 500 Internal Server Error* 오류 응답을 받게 되지만, 서버 로그에는 사용자 정의 예외인 `InternalError\"가 기록됩니다. 😎\n+\n+## `yield`를 사용하는 의존성의 실행 순서\n+\n+실행 순서는 대략 다음 다이어그램과 같습니다. 시간은 위에서 아래로 흐르며, 각 열은 코드를 실행하거나 상호 작용하는 부분 중 하나입니다.\n+\n+```mermaid\n+sequenceDiagram\n+\n+participant client as Client\n+participant handler as Exception handler\n+participant dep as Dep with yield\n+participant operation as Path Operation\n+participant tasks as Background tasks\n+\n+    Note over client,operation: Can raise exceptions, including HTTPException\n+    client ->> dep: Start request\n+    Note over dep: Run code up to yield\n+    opt raise Exception\n+        dep -->> handler: Raise Exception\n+        handler -->> client: HTTP error response\n+    end\n+    dep ->> operation: Run dependency, e.g. DB session\n+    opt raise\n+        operation -->> dep: Raise Exception (e.g. HTTPException)\n+        opt handle\n+            dep -->> dep: Can catch exception, raise a new HTTPException, raise other exception\n+        end\n+        handler -->> client: HTTP error response\n+    end\n+\n+    operation ->> client: Return response to client\n+    Note over client,operation: Response is already sent, can't change it anymore\n+    opt Tasks\n+        operation -->> tasks: Send background tasks\n+    end\n+    opt Raise other exception\n+        tasks -->> tasks: Handle exceptions in the background task code\n+    end\n+```\n+\n+/// info | 정보\n+\n+클라이언트에 **하나의 응답** 만 전송됩니다. 이는 오류 응답 중 하나일 수도 있고,*경로 작업*에서 생성된 응답일 수도 있습니다.\n+\n+이러한 응답 중 하나가 전송된 후에는 다른 응답을 보낼 수 없습니다.\n+\n+///\n+\n+/// tip | 팁\n+\n+이 다이어그램은 `HTTPException`을 보여주지만, `yield`를 사용하는 의존성에서 처리한 예외나 [사용자 정의 예외처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}.를 사용하여 처리한 다른 예외도 발생시킬 수 있습니다.\n+\n+어떤 예외가 발생하든, `HTTPException`을 포함하여 yield를 사용하는 의존성으로 전달됩니다. 대부분의 경우 예외를 다시 발생시키거나 새로운 예외를 발생시켜야 합니다.\n+\n+///\n+\n+## `yield`, `HTTPException`, `except` 및 백그라운드 작업을 사용하는 의존성\n+\n+/// warning | 경고\n+\n+이러한 기술적 세부 사항은 대부분 필요하지 않으므로 이 섹션을 건너뛰고 아래에서 계속 진행해도 됩니다.\n+\n+이러한 세부 정보는 주로 FastAPI 0.106.0 이전 버전에서 `yeild`가 있는 의존성의 리소스를 백그라운드 작업에서 사용했던 경우메 유용합니다.\n+\n+///\n+\n+### `yield`와 `except`를 사용하는 의존성: 기술 세부사항\n+\n+FastAPI 0.110.0 이전에는 `yield`가 포함된 의존성을 사용한 후 해당 의존성에서 `except`가 포함된 예외를 캡처하고 다시 예외를 발생시키지 않으면 예외가 자동으로 예외 핸들러 또는 내부 서버 오류 핸들러로 발생/전달되었습니다.\n+\n+이는 처리기 없이 전달된 예외(내부 서버 오류)에서 처리되지 않은 메모리 소비를 수정하고 일반 파이썬 코드의 동작과 일치하도록 하기 위해 0.110.0 버전에서 변경되었습니다.\n+\n+### 백그라운드 작업과 `yield`를 사용하는 기술 세부사항\n+\n+FastAPI 0.106.0 이전에는 yield 이후에 예외를 발생시키는 것이 불가능했습니다. `yield`가 있는 의존성 종료 코드는 응답이 전송된 이후에 실행되었기 때문에, [예외 처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}가 이미 실행된 상태였습니다.",
        "comment_created_at": "2025-02-01T09:46:23+00:00",
        "comment_author": "Zerohertz",
        "comment_body": "```suggestion\r\nFastAPI 0.106.0 이전에는 `yield` 이후에 예외를 발생시키는 것이 불가능했습니다. `yield`가 있는 의존성 종료 코드는 응답이 전송된 이후에 실행되었기 때문에, [예외 처리기](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}가 이미 실행된 상태였습니다.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]