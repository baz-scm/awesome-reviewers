[
  {
    "discussion_id": "1969375502",
    "pr_number": 13412,
    "pr_file": "docs/ru/docs/tutorial/middleware.md",
    "created_at": "2025-02-25T09:37:35+00:00",
    "commented_code": "+# Middleware (Промежуточный слой)\n+\n+Вы можете добавить промежуточный слой (middleware) в ваши **FastAPI** приложения.\n+\n+\"Middleware\" это функция, которая выполняется с каждым запросом до его обработки *функцией эндпоинта*.\n+А также с каждым ответом перед его возвращением.\n+\n+\n+* Она берёт поступающий **запрос**\n+* Делает что-то с этим **запросом** или выполняет некий нужный код.\n+* Затем она передает запрос для последующей обработки в *функцию эндпоинта*\n+* Получает **ответ** от *функции эндпоинта*\n+* Что-то делает с этим **ответом** или выполняет некий нужный код\n+* И возвращает **ответ**\n+\n+/// note | Технические детали\n+\n+Если у вас зависимости с `yield`, то код выхода (exit code) будет выполняться *после* middleware.",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1969375502",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13412,
        "pr_file": "docs/ru/docs/tutorial/middleware.md",
        "discussion_id": "1969375502",
        "commented_code": "@@ -0,0 +1,74 @@\n+# Middleware (Промежуточный слой)\n+\n+Вы можете добавить промежуточный слой (middleware) в ваши **FastAPI** приложения.\n+\n+\"Middleware\" это функция, которая выполняется с каждым запросом до его обработки *функцией эндпоинта*.\n+А также с каждым ответом перед его возвращением.\n+\n+\n+* Она берёт поступающий **запрос**\n+* Делает что-то с этим **запросом** или выполняет некий нужный код.\n+* Затем она передает запрос для последующей обработки в *функцию эндпоинта*\n+* Получает **ответ** от *функции эндпоинта*\n+* Что-то делает с этим **ответом** или выполняет некий нужный код\n+* И возвращает **ответ**\n+\n+/// note | Технические детали\n+\n+Если у вас зависимости с `yield`, то код выхода (exit code) будет выполняться *после* middleware.",
        "comment_created_at": "2025-02-25T09:37:35+00:00",
        "comment_author": "Rishat-F",
        "comment_body": "Если у вас есть зависимости с `yield`, то код выхода (exit code) будет выполняться *после* middleware.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1969674993",
    "pr_number": 13412,
    "pr_file": "docs/ru/docs/tutorial/middleware.md",
    "created_at": "2025-02-25T12:28:57+00:00",
    "commented_code": "+# Middleware (Промежуточный слой)\n+\n+Вы можете добавить промежуточный слой (middleware) в **FastAPI** приложения.\n+\n+\"Middleware\" это функция, которая выполняется с каждым запросом до его обработки *функцией эндпоинта*.\n+А также с каждым ответом перед его возвращением.\n+\n+\n+* Она принимает каждый поступающий **запрос**\n+* Может что-то сделать с этим **запросом** или выполнить любой нужный код.\n+* Затем передает запрос для последующей обработки в *функцию эндпоинта*\n+* Получает **ответ** от *функции эндпоинта*\n+* Может что-то сделать с этим **ответом** или выполнить любой нужный код\n+* И возвращает **ответ**\n+\n+/// note | Технические детали\n+\n+Если у вас есть зависимости с `yield`, то код выхода (exit code) будет выполняться *после* middleware.",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1969674993",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13412,
        "pr_file": "docs/ru/docs/tutorial/middleware.md",
        "discussion_id": "1969674993",
        "commented_code": "@@ -0,0 +1,74 @@\n+# Middleware (Промежуточный слой)\n+\n+Вы можете добавить промежуточный слой (middleware) в **FastAPI** приложения.\n+\n+\"Middleware\" это функция, которая выполняется с каждым запросом до его обработки *функцией эндпоинта*.\n+А также с каждым ответом перед его возвращением.\n+\n+\n+* Она принимает каждый поступающий **запрос**\n+* Может что-то сделать с этим **запросом** или выполнить любой нужный код.\n+* Затем передает запрос для последующей обработки в *функцию эндпоинта*\n+* Получает **ответ** от *функции эндпоинта*\n+* Может что-то сделать с этим **ответом** или выполнить любой нужный код\n+* И возвращает **ответ**\n+\n+/// note | Технические детали\n+\n+Если у вас есть зависимости с `yield`, то код выхода (exit code) будет выполняться *после* middleware.",
        "comment_created_at": "2025-02-25T12:28:57+00:00",
        "comment_author": "Rishat-F",
        "comment_body": "Я же правильно понимаю, что под \"exit code\" имеется ввиду \"участок кода после `yield`\"?",
        "pr_file_module": null
      },
      {
        "comment_id": "1969687461",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13412,
        "pr_file": "docs/ru/docs/tutorial/middleware.md",
        "discussion_id": "1969674993",
        "commented_code": "@@ -0,0 +1,74 @@\n+# Middleware (Промежуточный слой)\n+\n+Вы можете добавить промежуточный слой (middleware) в **FastAPI** приложения.\n+\n+\"Middleware\" это функция, которая выполняется с каждым запросом до его обработки *функцией эндпоинта*.\n+А также с каждым ответом перед его возвращением.\n+\n+\n+* Она принимает каждый поступающий **запрос**\n+* Может что-то сделать с этим **запросом** или выполнить любой нужный код.\n+* Затем передает запрос для последующей обработки в *функцию эндпоинта*\n+* Получает **ответ** от *функции эндпоинта*\n+* Может что-то сделать с этим **ответом** или выполнить любой нужный код\n+* И возвращает **ответ**\n+\n+/// note | Технические детали\n+\n+Если у вас есть зависимости с `yield`, то код выхода (exit code) будет выполняться *после* middleware.",
        "comment_created_at": "2025-02-25T12:34:59+00:00",
        "comment_author": "Rishat-F",
        "comment_body": "Если это так, то может вместо \"кода выхода\" и \"exit code\" явно пропишем что имеется ввиду \"код после `yield`\"?",
        "pr_file_module": null
      },
      {
        "comment_id": "1969877865",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13412,
        "pr_file": "docs/ru/docs/tutorial/middleware.md",
        "discussion_id": "1969674993",
        "commented_code": "@@ -0,0 +1,74 @@\n+# Middleware (Промежуточный слой)\n+\n+Вы можете добавить промежуточный слой (middleware) в **FastAPI** приложения.\n+\n+\"Middleware\" это функция, которая выполняется с каждым запросом до его обработки *функцией эндпоинта*.\n+А также с каждым ответом перед его возвращением.\n+\n+\n+* Она принимает каждый поступающий **запрос**\n+* Может что-то сделать с этим **запросом** или выполнить любой нужный код.\n+* Затем передает запрос для последующей обработки в *функцию эндпоинта*\n+* Получает **ответ** от *функции эндпоинта*\n+* Может что-то сделать с этим **ответом** или выполнить любой нужный код\n+* И возвращает **ответ**\n+\n+/// note | Технические детали\n+\n+Если у вас есть зависимости с `yield`, то код выхода (exit code) будет выполняться *после* middleware.",
        "comment_created_at": "2025-02-25T14:19:12+00:00",
        "comment_author": "alv2017",
        "comment_body": "Например, можно так:\r\nЕсли у вас есть зависимости с `yield`, то код выхода (код после `yield`) будет выполняться *после* middleware.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1908876296",
    "pr_number": 13163,
    "pr_file": "docs/en/docs/advanced/async-tests.md",
    "created_at": "2025-01-09T14:11:55+00:00",
    "commented_code": "## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n-\n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n-\n-This is the equivalent to:\n-\n-```Python\n-response = client.get('/')\n-```\n-\n-...that we used to make our requests with the `TestClient`.\n-\n-/// tip\n-\n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n-\n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n-\n-///\n \n ## Other Asynchronous Function Calls\n \n-As the testing function is now asynchronous, you can now also call (and `await`) other `async` functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests (e.g. when using <a href=\"https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop\" class=\"external-link\" target=\"_blank\">MongoDB's MotorClient</a>), remember to instantiate objects that need an event loop only within async functions, e.g. an `'@app.on_event(\"startup\")` callback.\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n+\n+```python\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[AbstractEventLoop, None, None]:\n+    \"\"\"Overrides pytest default function scoped event loop\"\"\"\n+    policy = asyncio.get_event_loop_policy()",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1908876296",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13163,
        "pr_file": "docs/en/docs/advanced/async-tests.md",
        "discussion_id": "1908876296",
        "commented_code": "@@ -54,46 +59,31 @@ $ pytest\n \n ## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n-\n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n-\n-This is the equivalent to:\n-\n-```Python\n-response = client.get('/')\n-```\n-\n-...that we used to make our requests with the `TestClient`.\n-\n-/// tip\n-\n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n-\n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n-\n-///\n \n ## Other Asynchronous Function Calls\n \n-As the testing function is now asynchronous, you can now also call (and `await`) other `async` functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests (e.g. when using <a href=\"https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop\" class=\"external-link\" target=\"_blank\">MongoDB's MotorClient</a>), remember to instantiate objects that need an event loop only within async functions, e.g. an `'@app.on_event(\"startup\")` callback.\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n+\n+```python\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[AbstractEventLoop, None, None]:\n+    \"\"\"Overrides pytest default function scoped event loop\"\"\"\n+    policy = asyncio.get_event_loop_policy()",
        "comment_created_at": "2025-01-09T14:11:55+00:00",
        "comment_author": "graingert",
        "comment_body": "event loop policy is deprecated in 3.14 and will be removed",
        "pr_file_module": null
      },
      {
        "comment_id": "1909191086",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13163,
        "pr_file": "docs/en/docs/advanced/async-tests.md",
        "discussion_id": "1908876296",
        "commented_code": "@@ -54,46 +59,31 @@ $ pytest\n \n ## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n-\n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n-\n-This is the equivalent to:\n-\n-```Python\n-response = client.get('/')\n-```\n-\n-...that we used to make our requests with the `TestClient`.\n-\n-/// tip\n-\n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n-\n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n-\n-///\n \n ## Other Asynchronous Function Calls\n \n-As the testing function is now asynchronous, you can now also call (and `await`) other `async` functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests (e.g. when using <a href=\"https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop\" class=\"external-link\" target=\"_blank\">MongoDB's MotorClient</a>), remember to instantiate objects that need an event loop only within async functions, e.g. an `'@app.on_event(\"startup\")` callback.\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n+\n+```python\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[AbstractEventLoop, None, None]:\n+    \"\"\"Overrides pytest default function scoped event loop\"\"\"\n+    policy = asyncio.get_event_loop_policy()",
        "comment_created_at": "2025-01-09T17:19:00+00:00",
        "comment_author": "oleg-korshunov",
        "comment_body": "corrected description \r\n![image](https://github.com/user-attachments/assets/a9690aff-40a8-41d6-bd0b-d9ea80a1b7a4)\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1909240715",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13163,
        "pr_file": "docs/en/docs/advanced/async-tests.md",
        "discussion_id": "1908876296",
        "commented_code": "@@ -54,46 +59,31 @@ $ pytest\n \n ## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n-\n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n-\n-This is the equivalent to:\n-\n-```Python\n-response = client.get('/')\n-```\n-\n-...that we used to make our requests with the `TestClient`.\n-\n-/// tip\n-\n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n-\n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n-\n-///\n \n ## Other Asynchronous Function Calls\n \n-As the testing function is now asynchronous, you can now also call (and `await`) other `async` functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests (e.g. when using <a href=\"https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop\" class=\"external-link\" target=\"_blank\">MongoDB's MotorClient</a>), remember to instantiate objects that need an event loop only within async functions, e.g. an `'@app.on_event(\"startup\")` callback.\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n+\n+```python\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[AbstractEventLoop, None, None]:\n+    \"\"\"Overrides pytest default function scoped event loop\"\"\"\n+    policy = asyncio.get_event_loop_policy()",
        "comment_created_at": "2025-01-09T18:03:15+00:00",
        "comment_author": "graingert",
        "comment_body": "The deprecated event loop policy is still being used here",
        "pr_file_module": null
      },
      {
        "comment_id": "1909393805",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13163,
        "pr_file": "docs/en/docs/advanced/async-tests.md",
        "discussion_id": "1908876296",
        "commented_code": "@@ -54,46 +59,31 @@ $ pytest\n \n ## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n-\n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n-\n-This is the equivalent to:\n-\n-```Python\n-response = client.get('/')\n-```\n-\n-...that we used to make our requests with the `TestClient`.\n-\n-/// tip\n-\n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n-\n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n-\n-///\n \n ## Other Asynchronous Function Calls\n \n-As the testing function is now asynchronous, you can now also call (and `await`) other `async` functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests (e.g. when using <a href=\"https://stackoverflow.com/questions/41584243/runtimeerror-task-attached-to-a-different-loop\" class=\"external-link\" target=\"_blank\">MongoDB's MotorClient</a>), remember to instantiate objects that need an event loop only within async functions, e.g. an `'@app.on_event(\"startup\")` callback.\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n+\n+```python\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[AbstractEventLoop, None, None]:\n+    \"\"\"Overrides pytest default function scoped event loop\"\"\"\n+    policy = asyncio.get_event_loop_policy()",
        "comment_created_at": "2025-01-09T20:28:43+00:00",
        "comment_author": "oleg-korshunov",
        "comment_body": "corrected it to asyncio.Runner",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "477435684",
    "pr_number": 1945,
    "pr_file": "docs/ja/docs/tutorial/request-files.md",
    "created_at": "2020-08-26T16:35:46+00:00",
    "commented_code": "+# リクエストファイル\n+\n+クライアントがアップロードするファイルは`File`を用いて定義することができます。\n+\n+!!! info \"情報\"\n+    アップロードされたファイルを受信するには、まず<a href=\"https://andrew-d.github.io/python-multipart/\" class=\"external-link\" target=\"_blank\">`python-multipart`</a>をインポートします。\n+\n+    例えば`pip install python-multipart`のように。\n+\n+    これはアップロードされたファイルが「フォームデータ」として送信されるためです。\n+\n+## `File`のインポート\n+\n+`fastapi`から`File`と`UploadFile`をインポートします:\n+\n+```Python hl_lines=\"1\"\n+{!../../../docs_src/request_files/tutorial001.py!}\n+```\n+\n+## `File`パラメータを定義\n+\n+ファイルパラメータは`Body`や`Form`と同じように作成します:\n+\n+```Python hl_lines=\"7\"\n+{!../../../docs_src/request_files/tutorial001.py!}\n+```\n+\n+!!! info \"情報\"\n+    `File`は`Form`を直接継承するクラスです。\n+\n+    しかし、`fastapi`から`Query`や`Path`、`File`などをインポートする場合、それらは実際には特殊なクラスを返す関数であることを覚えておいてください。\n+\n+!!! tip \"豆知識\"\n+    ファイルのボディを宣言するには、`File`を使用する必要があります。なぜなら、パラメータがクエリパラメータやボディ（JSON）パラメータとして解釈されてしますからです。\n+\n+ファイルは「フォームデータ」としてアップロードされます。\n+\n+*path operation関数*のパラメータの型を`bytes`と宣言すると、**FastAPI** がファイルを読み込んで、`bytes`として内容を受け取ることになります。\n+\n+これは、全体の内容がメモリに保存されることを意味することを覚えておいてください。これは小さなファイルの場合にはうまくいくでしょう。\n+\n+`UploadFile`を使用することで恩恵を受けることができるケースがいくつかあります。\n+\n+## `UploadFile`を持つ`File`パラメータ\n+\n+`File`パラメータを`UploadFile`型で定義します:\n+\n+```Python hl_lines=\"12\"\n+{!../../../docs_src/request_files/tutorial001.py!}\n+```\n+\n+`UploadFile`を使うことは`bytes`よりもいくつかの利点があります:\n+\n+* それは「spooled」ファイルを使用しています:\n+    * サイズの上限までメモリに保存されたファイルで、上限を超えるとディスクに保存されます。\n+* 画像や動画、大きなバイナリなどの大きなファイルに対して、メモリを消費することなく動作することを意味します。\n+* アップロードされたファイルからメタデータを取得することができます。\n+* <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" class=\"external-link\" target=\"_blank\">file-like</a>`async`インターフェースを持っています。\n+* これは実際のPythonの<a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" class=\"external-link\" target=\"_blank\">`SpooledTemporaryFile`</a>オブジェクトを公開しており、ファイルライクなオブジェクトを期待する他のライブラリに直接渡すことができます。\n+\n+### `UploadFile`\n+\n+`UploadFile`は以下の属性を持っています:\n+\n+* `filename`: アップロードされた元のファイル名を持つ`str`（例：`myimage.jpg`）。\n+* `content_type`: コンテンツタイプ（MIMEタイプ・メディアタイプ）を持つ`str`（例：`image/jpeg`）。\n+* `file`: <a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" class=\"external-link\" target=\"_blank\">`SpooledTemporaryFile`</a> (<a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" class=\"external-link\" target=\"_blank\">ファイルライク</a>オブジェクト)。これが実際のPythonファイルで、「ファイルライク」オブジェクトを期待する他の関数やライブラリに直接渡すことができます。\n+\n+`UploadFile`は以下の`async`メソッドを持っています。これらはすべて（内部の`SpooledTemporaryFile`を使用して）その下にある対応するファイルメソッドを呼び出します。\n+\n+* `write(data)`: ファイルに`data`（`str`または`bytes`）を書き込む。\n+* `read(size)`: ファイルの`size`（`int`）バイト・文字を読み込む。\n+* `seek(offset)`: ファイルのバイト位置`offset`（`int`）に移動します。\n+    * 例えば、`await myfile.seek(0)`はファイルの先頭に移動します。\n+    * これは、`await myfile.read()`を一度実行した後、再度内容を読み込む必要がある場合に特に有用です。\n+* `close()`: ファイルを閉じます。\n+\n+これらのメソッドはすべて`async`メソッドなので、それらを「待機（await）」する必要があります。\n+\n+例えば、`async`*path operation関数*の内部では、以下のようにして内容を取得することができます:\n+\n+```Python\n+contents = await myfile.read()\n+```\n+\n+通常の`def`*path operation関数*の内部にある場合、例えば、以下のように`UploadFile.file`に直接アクセスすることができます:\n+\n+```Python\n+contents = myfile.file.read()\n+```\n+\n+!!! note \"`async` 技術詳細\"\n+    `async`メソッドを使用すると、**FastAPI** はファイルメソッドをスレッドプールで実行し、それらのメソッドを持ちます。",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "477435684",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 1945,
        "pr_file": "docs/ja/docs/tutorial/request-files.md",
        "discussion_id": "477435684",
        "commented_code": "@@ -0,0 +1,145 @@\n+# リクエストファイル\n+\n+クライアントがアップロードするファイルは`File`を用いて定義することができます。\n+\n+!!! info \"情報\"\n+    アップロードされたファイルを受信するには、まず<a href=\"https://andrew-d.github.io/python-multipart/\" class=\"external-link\" target=\"_blank\">`python-multipart`</a>をインポートします。\n+\n+    例えば`pip install python-multipart`のように。\n+\n+    これはアップロードされたファイルが「フォームデータ」として送信されるためです。\n+\n+## `File`のインポート\n+\n+`fastapi`から`File`と`UploadFile`をインポートします:\n+\n+```Python hl_lines=\"1\"\n+{!../../../docs_src/request_files/tutorial001.py!}\n+```\n+\n+## `File`パラメータを定義\n+\n+ファイルパラメータは`Body`や`Form`と同じように作成します:\n+\n+```Python hl_lines=\"7\"\n+{!../../../docs_src/request_files/tutorial001.py!}\n+```\n+\n+!!! info \"情報\"\n+    `File`は`Form`を直接継承するクラスです。\n+\n+    しかし、`fastapi`から`Query`や`Path`、`File`などをインポートする場合、それらは実際には特殊なクラスを返す関数であることを覚えておいてください。\n+\n+!!! tip \"豆知識\"\n+    ファイルのボディを宣言するには、`File`を使用する必要があります。なぜなら、パラメータがクエリパラメータやボディ（JSON）パラメータとして解釈されてしますからです。\n+\n+ファイルは「フォームデータ」としてアップロードされます。\n+\n+*path operation関数*のパラメータの型を`bytes`と宣言すると、**FastAPI** がファイルを読み込んで、`bytes`として内容を受け取ることになります。\n+\n+これは、全体の内容がメモリに保存されることを意味することを覚えておいてください。これは小さなファイルの場合にはうまくいくでしょう。\n+\n+`UploadFile`を使用することで恩恵を受けることができるケースがいくつかあります。\n+\n+## `UploadFile`を持つ`File`パラメータ\n+\n+`File`パラメータを`UploadFile`型で定義します:\n+\n+```Python hl_lines=\"12\"\n+{!../../../docs_src/request_files/tutorial001.py!}\n+```\n+\n+`UploadFile`を使うことは`bytes`よりもいくつかの利点があります:\n+\n+* それは「spooled」ファイルを使用しています:\n+    * サイズの上限までメモリに保存されたファイルで、上限を超えるとディスクに保存されます。\n+* 画像や動画、大きなバイナリなどの大きなファイルに対して、メモリを消費することなく動作することを意味します。\n+* アップロードされたファイルからメタデータを取得することができます。\n+* <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" class=\"external-link\" target=\"_blank\">file-like</a>`async`インターフェースを持っています。\n+* これは実際のPythonの<a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" class=\"external-link\" target=\"_blank\">`SpooledTemporaryFile`</a>オブジェクトを公開しており、ファイルライクなオブジェクトを期待する他のライブラリに直接渡すことができます。\n+\n+### `UploadFile`\n+\n+`UploadFile`は以下の属性を持っています:\n+\n+* `filename`: アップロードされた元のファイル名を持つ`str`（例：`myimage.jpg`）。\n+* `content_type`: コンテンツタイプ（MIMEタイプ・メディアタイプ）を持つ`str`（例：`image/jpeg`）。\n+* `file`: <a href=\"https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile\" class=\"external-link\" target=\"_blank\">`SpooledTemporaryFile`</a> (<a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" class=\"external-link\" target=\"_blank\">ファイルライク</a>オブジェクト)。これが実際のPythonファイルで、「ファイルライク」オブジェクトを期待する他の関数やライブラリに直接渡すことができます。\n+\n+`UploadFile`は以下の`async`メソッドを持っています。これらはすべて（内部の`SpooledTemporaryFile`を使用して）その下にある対応するファイルメソッドを呼び出します。\n+\n+* `write(data)`: ファイルに`data`（`str`または`bytes`）を書き込む。\n+* `read(size)`: ファイルの`size`（`int`）バイト・文字を読み込む。\n+* `seek(offset)`: ファイルのバイト位置`offset`（`int`）に移動します。\n+    * 例えば、`await myfile.seek(0)`はファイルの先頭に移動します。\n+    * これは、`await myfile.read()`を一度実行した後、再度内容を読み込む必要がある場合に特に有用です。\n+* `close()`: ファイルを閉じます。\n+\n+これらのメソッドはすべて`async`メソッドなので、それらを「待機（await）」する必要があります。\n+\n+例えば、`async`*path operation関数*の内部では、以下のようにして内容を取得することができます:\n+\n+```Python\n+contents = await myfile.read()\n+```\n+\n+通常の`def`*path operation関数*の内部にある場合、例えば、以下のように`UploadFile.file`に直接アクセスすることができます:\n+\n+```Python\n+contents = myfile.file.read()\n+```\n+\n+!!! note \"`async` 技術詳細\"\n+    `async`メソッドを使用すると、**FastAPI** はファイルメソッドをスレッドプールで実行し、それらのメソッドを持ちます。",
        "comment_created_at": "2020-08-26T16:35:46+00:00",
        "comment_author": "tokusumi",
        "comment_body": "`async`メソッドを使用すると、**FastAPI** はファイルメソッドをスレッドプールで実行し、それらを待機（await）します。",
        "pr_file_module": null
      }
    ]
  }
]