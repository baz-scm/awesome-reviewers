[
  {
    "discussion_id": "2149188337",
    "pr_number": 12261,
    "pr_file": "docs/fr/docs/advanced/async-tests.md",
    "created_at": "2025-06-16T07:01:38+00:00",
    "commented_code": "+# Tests Asynchrones\n+\n+Vous avez déjà vu comment tester vos applications **FastAPI** en utilisant le `TestClient` fourni. Jusqu'à présent, vous avez seulement vu comment écrire des tests synchrones, sans utiliser des fonctions `async`.\n+\n+Être capable d'utiliser des fonctions asynchrones dans vos tests peut être utile, par exemple, lorsque vous requêtez de manière asynchrone votre base de données. Imaginez que vous vouliez tester l'envoi de requête à votre application FastAPI, puis vérifier que votre backend a bien écrit la bonne donnée dans la base de données, tout en utilisant une librairie de base de données asynchrone.\n+\n+Voyons comment faire.\n+\n+## pytest.mark.anyio\n+\n+Afin de permettre l'appel de fonctions asynchrones dans nos tests, il est essentiel que nos fonctions de tests soient asynchrones. AnyIO propose un plugin soigneusement conçu pour cela, qui nous permet de spécifier que certaines fonctions de test doivent être appelées de manière asynchrone.\n+\n+## HTTPX\n+\n+Même si votre application **FastAPI** utilise des fonctions `def` normales plutôt que des `async def`, elle reste une application `async` application en dessous.\n+\n+`TestClient` utilise de la magie à l'intérieur pour appeler l'application FastAPI dans vos fonctions de test `def` normales, en utilisant un standard pytest. Mais cette magie ne marche plus lorsque vous l'utilisez dans une fonction asynchrone. En lançant nos tests de manière asynchrone, `TestClient` ne peut plus être utilisé dans nos fonctions de tests.\n+\n+`TestClient` repose <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, et par chance, on peut l'utiliser directement pour tester l'API.\n+\n+## Exemple\n+\n+Prenons un exemple simple, on considère une structure de fichier similaire à celle décrite dans [Applications plus grandes](../tutorial/bigger-applications.md){.internal-link target=_blank} et [Testing](../tutorial/testing.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   ├── main.py\n+│   └── test_main.py\n+```\n+\n+Dans le fichier `main.py` il y aurait:\n+\n+```Python\n+{!../../../docs_src/async_tests/main.py!}\n+```\n+\n+Le fichier `test_main.py` contiendrait les tests pour `main.py`, et pourrait désormais ressembler à :\n+\n+```Python\n+{!../../../docs_src/async_tests/test_main.py!}\n+```",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "2149188337",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 12261,
        "pr_file": "docs/fr/docs/advanced/async-tests.md",
        "discussion_id": "2149188337",
        "commented_code": "@@ -0,0 +1,107 @@\n+# Tests Asynchrones\n+\n+Vous avez déjà vu comment tester vos applications **FastAPI** en utilisant le `TestClient` fourni. Jusqu'à présent, vous avez seulement vu comment écrire des tests synchrones, sans utiliser des fonctions `async`.\n+\n+Être capable d'utiliser des fonctions asynchrones dans vos tests peut être utile, par exemple, lorsque vous requêtez de manière asynchrone votre base de données. Imaginez que vous vouliez tester l'envoi de requête à votre application FastAPI, puis vérifier que votre backend a bien écrit la bonne donnée dans la base de données, tout en utilisant une librairie de base de données asynchrone.\n+\n+Voyons comment faire.\n+\n+## pytest.mark.anyio\n+\n+Afin de permettre l'appel de fonctions asynchrones dans nos tests, il est essentiel que nos fonctions de tests soient asynchrones. AnyIO propose un plugin soigneusement conçu pour cela, qui nous permet de spécifier que certaines fonctions de test doivent être appelées de manière asynchrone.\n+\n+## HTTPX\n+\n+Même si votre application **FastAPI** utilise des fonctions `def` normales plutôt que des `async def`, elle reste une application `async` application en dessous.\n+\n+`TestClient` utilise de la magie à l'intérieur pour appeler l'application FastAPI dans vos fonctions de test `def` normales, en utilisant un standard pytest. Mais cette magie ne marche plus lorsque vous l'utilisez dans une fonction asynchrone. En lançant nos tests de manière asynchrone, `TestClient` ne peut plus être utilisé dans nos fonctions de tests.\n+\n+`TestClient` repose <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, et par chance, on peut l'utiliser directement pour tester l'API.\n+\n+## Exemple\n+\n+Prenons un exemple simple, on considère une structure de fichier similaire à celle décrite dans [Applications plus grandes](../tutorial/bigger-applications.md){.internal-link target=_blank} et [Testing](../tutorial/testing.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   ├── main.py\n+│   └── test_main.py\n+```\n+\n+Dans le fichier `main.py` il y aurait:\n+\n+```Python\n+{!../../../docs_src/async_tests/main.py!}\n+```\n+\n+Le fichier `test_main.py` contiendrait les tests pour `main.py`, et pourrait désormais ressembler à :\n+\n+```Python\n+{!../../../docs_src/async_tests/test_main.py!}\n+```",
        "comment_created_at": "2025-06-16T07:01:38+00:00",
        "comment_author": "YuriiMotov",
        "comment_body": "```suggestion\r\n{* ../../docs_src/async_tests/test_main.py *}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149189300",
    "pr_number": 12261,
    "pr_file": "docs/fr/docs/advanced/async-tests.md",
    "created_at": "2025-06-16T07:02:18+00:00",
    "commented_code": "+# Tests Asynchrones\n+\n+Vous avez déjà vu comment tester vos applications **FastAPI** en utilisant le `TestClient` fourni. Jusqu'à présent, vous avez seulement vu comment écrire des tests synchrones, sans utiliser des fonctions `async`.\n+\n+Être capable d'utiliser des fonctions asynchrones dans vos tests peut être utile, par exemple, lorsque vous requêtez de manière asynchrone votre base de données. Imaginez que vous vouliez tester l'envoi de requête à votre application FastAPI, puis vérifier que votre backend a bien écrit la bonne donnée dans la base de données, tout en utilisant une librairie de base de données asynchrone.\n+\n+Voyons comment faire.\n+\n+## pytest.mark.anyio\n+\n+Afin de permettre l'appel de fonctions asynchrones dans nos tests, il est essentiel que nos fonctions de tests soient asynchrones. AnyIO propose un plugin soigneusement conçu pour cela, qui nous permet de spécifier que certaines fonctions de test doivent être appelées de manière asynchrone.\n+\n+## HTTPX\n+\n+Même si votre application **FastAPI** utilise des fonctions `def` normales plutôt que des `async def`, elle reste une application `async` application en dessous.\n+\n+`TestClient` utilise de la magie à l'intérieur pour appeler l'application FastAPI dans vos fonctions de test `def` normales, en utilisant un standard pytest. Mais cette magie ne marche plus lorsque vous l'utilisez dans une fonction asynchrone. En lançant nos tests de manière asynchrone, `TestClient` ne peut plus être utilisé dans nos fonctions de tests.\n+\n+`TestClient` repose <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, et par chance, on peut l'utiliser directement pour tester l'API.\n+\n+## Exemple\n+\n+Prenons un exemple simple, on considère une structure de fichier similaire à celle décrite dans [Applications plus grandes](../tutorial/bigger-applications.md){.internal-link target=_blank} et [Testing](../tutorial/testing.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   ├── main.py\n+│   └── test_main.py\n+```\n+\n+Dans le fichier `main.py` il y aurait:\n+\n+```Python\n+{!../../../docs_src/async_tests/main.py!}\n+```\n+\n+Le fichier `test_main.py` contiendrait les tests pour `main.py`, et pourrait désormais ressembler à :\n+\n+```Python\n+{!../../../docs_src/async_tests/test_main.py!}\n+```\n+\n+## Lancez les\n+\n+Comme d'habitude, vous pouvez lancer vos tests en utilisant :\n+\n+<div class=\"termy\">\n+\n+```console\n+$ pytest\n+\n+---> 100%\n+```\n+\n+</div>\n+\n+## En Détail\n+\n+Le marqueur `@pytest.mark.anyio` informe pytest que la fonction de test doit être appelée de manière asynchrone:\n+\n+```Python hl_lines=\"7\"\n+{!../../../docs_src/async_tests/test_main.py!}\n+```",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "2149189300",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 12261,
        "pr_file": "docs/fr/docs/advanced/async-tests.md",
        "discussion_id": "2149189300",
        "commented_code": "@@ -0,0 +1,107 @@\n+# Tests Asynchrones\n+\n+Vous avez déjà vu comment tester vos applications **FastAPI** en utilisant le `TestClient` fourni. Jusqu'à présent, vous avez seulement vu comment écrire des tests synchrones, sans utiliser des fonctions `async`.\n+\n+Être capable d'utiliser des fonctions asynchrones dans vos tests peut être utile, par exemple, lorsque vous requêtez de manière asynchrone votre base de données. Imaginez que vous vouliez tester l'envoi de requête à votre application FastAPI, puis vérifier que votre backend a bien écrit la bonne donnée dans la base de données, tout en utilisant une librairie de base de données asynchrone.\n+\n+Voyons comment faire.\n+\n+## pytest.mark.anyio\n+\n+Afin de permettre l'appel de fonctions asynchrones dans nos tests, il est essentiel que nos fonctions de tests soient asynchrones. AnyIO propose un plugin soigneusement conçu pour cela, qui nous permet de spécifier que certaines fonctions de test doivent être appelées de manière asynchrone.\n+\n+## HTTPX\n+\n+Même si votre application **FastAPI** utilise des fonctions `def` normales plutôt que des `async def`, elle reste une application `async` application en dessous.\n+\n+`TestClient` utilise de la magie à l'intérieur pour appeler l'application FastAPI dans vos fonctions de test `def` normales, en utilisant un standard pytest. Mais cette magie ne marche plus lorsque vous l'utilisez dans une fonction asynchrone. En lançant nos tests de manière asynchrone, `TestClient` ne peut plus être utilisé dans nos fonctions de tests.\n+\n+`TestClient` repose <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, et par chance, on peut l'utiliser directement pour tester l'API.\n+\n+## Exemple\n+\n+Prenons un exemple simple, on considère une structure de fichier similaire à celle décrite dans [Applications plus grandes](../tutorial/bigger-applications.md){.internal-link target=_blank} et [Testing](../tutorial/testing.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   ├── main.py\n+│   └── test_main.py\n+```\n+\n+Dans le fichier `main.py` il y aurait:\n+\n+```Python\n+{!../../../docs_src/async_tests/main.py!}\n+```\n+\n+Le fichier `test_main.py` contiendrait les tests pour `main.py`, et pourrait désormais ressembler à :\n+\n+```Python\n+{!../../../docs_src/async_tests/test_main.py!}\n+```\n+\n+## Lancez les\n+\n+Comme d'habitude, vous pouvez lancer vos tests en utilisant :\n+\n+<div class=\"termy\">\n+\n+```console\n+$ pytest\n+\n+---> 100%\n+```\n+\n+</div>\n+\n+## En Détail\n+\n+Le marqueur `@pytest.mark.anyio` informe pytest que la fonction de test doit être appelée de manière asynchrone:\n+\n+```Python hl_lines=\"7\"\n+{!../../../docs_src/async_tests/test_main.py!}\n+```",
        "comment_created_at": "2025-06-16T07:02:18+00:00",
        "comment_author": "YuriiMotov",
        "comment_body": "```suggestion\r\n{* ../../docs_src/async_tests/test_main.py hl[7] *}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149190287",
    "pr_number": 12261,
    "pr_file": "docs/fr/docs/advanced/async-tests.md",
    "created_at": "2025-06-16T07:03:01+00:00",
    "commented_code": "+# Tests Asynchrones\n+\n+Vous avez déjà vu comment tester vos applications **FastAPI** en utilisant le `TestClient` fourni. Jusqu'à présent, vous avez seulement vu comment écrire des tests synchrones, sans utiliser des fonctions `async`.\n+\n+Être capable d'utiliser des fonctions asynchrones dans vos tests peut être utile, par exemple, lorsque vous requêtez de manière asynchrone votre base de données. Imaginez que vous vouliez tester l'envoi de requête à votre application FastAPI, puis vérifier que votre backend a bien écrit la bonne donnée dans la base de données, tout en utilisant une librairie de base de données asynchrone.\n+\n+Voyons comment faire.\n+\n+## pytest.mark.anyio\n+\n+Afin de permettre l'appel de fonctions asynchrones dans nos tests, il est essentiel que nos fonctions de tests soient asynchrones. AnyIO propose un plugin soigneusement conçu pour cela, qui nous permet de spécifier que certaines fonctions de test doivent être appelées de manière asynchrone.\n+\n+## HTTPX\n+\n+Même si votre application **FastAPI** utilise des fonctions `def` normales plutôt que des `async def`, elle reste une application `async` application en dessous.\n+\n+`TestClient` utilise de la magie à l'intérieur pour appeler l'application FastAPI dans vos fonctions de test `def` normales, en utilisant un standard pytest. Mais cette magie ne marche plus lorsque vous l'utilisez dans une fonction asynchrone. En lançant nos tests de manière asynchrone, `TestClient` ne peut plus être utilisé dans nos fonctions de tests.\n+\n+`TestClient` repose <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, et par chance, on peut l'utiliser directement pour tester l'API.\n+\n+## Exemple\n+\n+Prenons un exemple simple, on considère une structure de fichier similaire à celle décrite dans [Applications plus grandes](../tutorial/bigger-applications.md){.internal-link target=_blank} et [Testing](../tutorial/testing.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   ├── main.py\n+│   └── test_main.py\n+```\n+\n+Dans le fichier `main.py` il y aurait:\n+\n+```Python\n+{!../../../docs_src/async_tests/main.py!}\n+```\n+\n+Le fichier `test_main.py` contiendrait les tests pour `main.py`, et pourrait désormais ressembler à :\n+\n+```Python\n+{!../../../docs_src/async_tests/test_main.py!}\n+```\n+\n+## Lancez les\n+\n+Comme d'habitude, vous pouvez lancer vos tests en utilisant :\n+\n+<div class=\"termy\">\n+\n+```console\n+$ pytest\n+\n+---> 100%\n+```\n+\n+</div>\n+\n+## En Détail\n+\n+Le marqueur `@pytest.mark.anyio` informe pytest que la fonction de test doit être appelée de manière asynchrone:\n+\n+```Python hl_lines=\"7\"\n+{!../../../docs_src/async_tests/test_main.py!}\n+```\n+\n+/// tip\n+\n+Notez que la fonction de test est maintenant une `async def` plutôt qu'une simple `def` comme précédemment lorsqu'on utilisait `TestClient`.\n+\n+///\n+\n+Puis on crée un `AsyncClient` avec l'application, et on lui envoie des requêtes, en utilisant `await`.\n+\n+```Python hl_lines=\"9-12\"\n+{!../../../docs_src/async_tests/test_main.py!}\n+```",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "2149190287",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 12261,
        "pr_file": "docs/fr/docs/advanced/async-tests.md",
        "discussion_id": "2149190287",
        "commented_code": "@@ -0,0 +1,107 @@\n+# Tests Asynchrones\n+\n+Vous avez déjà vu comment tester vos applications **FastAPI** en utilisant le `TestClient` fourni. Jusqu'à présent, vous avez seulement vu comment écrire des tests synchrones, sans utiliser des fonctions `async`.\n+\n+Être capable d'utiliser des fonctions asynchrones dans vos tests peut être utile, par exemple, lorsque vous requêtez de manière asynchrone votre base de données. Imaginez que vous vouliez tester l'envoi de requête à votre application FastAPI, puis vérifier que votre backend a bien écrit la bonne donnée dans la base de données, tout en utilisant une librairie de base de données asynchrone.\n+\n+Voyons comment faire.\n+\n+## pytest.mark.anyio\n+\n+Afin de permettre l'appel de fonctions asynchrones dans nos tests, il est essentiel que nos fonctions de tests soient asynchrones. AnyIO propose un plugin soigneusement conçu pour cela, qui nous permet de spécifier que certaines fonctions de test doivent être appelées de manière asynchrone.\n+\n+## HTTPX\n+\n+Même si votre application **FastAPI** utilise des fonctions `def` normales plutôt que des `async def`, elle reste une application `async` application en dessous.\n+\n+`TestClient` utilise de la magie à l'intérieur pour appeler l'application FastAPI dans vos fonctions de test `def` normales, en utilisant un standard pytest. Mais cette magie ne marche plus lorsque vous l'utilisez dans une fonction asynchrone. En lançant nos tests de manière asynchrone, `TestClient` ne peut plus être utilisé dans nos fonctions de tests.\n+\n+`TestClient` repose <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, et par chance, on peut l'utiliser directement pour tester l'API.\n+\n+## Exemple\n+\n+Prenons un exemple simple, on considère une structure de fichier similaire à celle décrite dans [Applications plus grandes](../tutorial/bigger-applications.md){.internal-link target=_blank} et [Testing](../tutorial/testing.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   ├── main.py\n+│   └── test_main.py\n+```\n+\n+Dans le fichier `main.py` il y aurait:\n+\n+```Python\n+{!../../../docs_src/async_tests/main.py!}\n+```\n+\n+Le fichier `test_main.py` contiendrait les tests pour `main.py`, et pourrait désormais ressembler à :\n+\n+```Python\n+{!../../../docs_src/async_tests/test_main.py!}\n+```\n+\n+## Lancez les\n+\n+Comme d'habitude, vous pouvez lancer vos tests en utilisant :\n+\n+<div class=\"termy\">\n+\n+```console\n+$ pytest\n+\n+---> 100%\n+```\n+\n+</div>\n+\n+## En Détail\n+\n+Le marqueur `@pytest.mark.anyio` informe pytest que la fonction de test doit être appelée de manière asynchrone:\n+\n+```Python hl_lines=\"7\"\n+{!../../../docs_src/async_tests/test_main.py!}\n+```\n+\n+/// tip\n+\n+Notez que la fonction de test est maintenant une `async def` plutôt qu'une simple `def` comme précédemment lorsqu'on utilisait `TestClient`.\n+\n+///\n+\n+Puis on crée un `AsyncClient` avec l'application, et on lui envoie des requêtes, en utilisant `await`.\n+\n+```Python hl_lines=\"9-12\"\n+{!../../../docs_src/async_tests/test_main.py!}\n+```",
        "comment_created_at": "2025-06-16T07:03:01+00:00",
        "comment_author": "YuriiMotov",
        "comment_body": "```suggestion\r\n{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2149165665",
    "pr_number": 12201,
    "pr_file": "docs/fr/docs/tutorial/testing.md",
    "created_at": "2025-06-16T06:46:20+00:00",
    "commented_code": "+# Testing\n+\n+<a href=\"https://www.starlette.io/testclient/\" class=\"external-link\" target=\"_blank\">Starlette</a> rend le test des applications **FastAPI** facile et agréable.\n+\n+Il est basé sur <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, qui est lui-même basé sur Request, ce qui le rend très compréhensible et intuitif.\n+\n+Cela vous permet d'utiliser directement <a href=\"https://docs.pytest.org/\" class=\"external-link\" target=\"_blank\">pytest</a> avec **FastAPI**.\n+\n+## Utiliser `TestClient`\n+\n+/// info\n+\n+Pour utiliser `TestClient`, installez d'abord <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">`httpx`</a>.\n+\n+Assurez-vous de créez un [environnement virtuel](../virtual-environments.md){.internal-link target=_blank}, activez-le, puis installez-le, par exemple:\n+\n+```console\n+$ pip install httpx\n+```\n+\n+///\n+\n+Importez `TestClient`.\n+\n+Créez un `TestClient` en y passant votre application **FastAPI**.\n+\n+Créez des fonctions ayant un nom commençant par `test_` (c'est une convention standard de `pytest`).\n+\n+Utilisez l'objet `TestClient` comme vous le faites avec `httpx`.\n+\n+Rédigez des `assert` simples avec les expressions Python standards que vous devez vérifier (encore une fois, un standard `pytest`).\n+\n+```Python hl_lines=\"2  12  15-18\"\n+{!../../../docs_src/app_testing/tutorial001.py!}\n+```\n+\n+/// tip\n+\n+Remarquez que les fonctions de test sont des `def` normaux, pas des `async def`.\n+\n+Et que les appels au client sont également des appels normaux, n'utilisant pas `await`.\n+\n+Cela vous permet d'utiliser `pytest` directement sans complications.\n+\n+///\n+\n+/// note | \"Technical Details\"\n+\n+Vous pouvez également utiliser `from starlette.testclient import TestClient`.\n+\n+**FastAPI** fournit à la fois `starlette.testclient` ainsi que `fastapi.testclient` par commodité pour vous, le développeur. Mais il vient directement de Starlette.\n+\n+///\n+\n+/// tip\n+\n+Si vous souhaitez appeler des fonctions `async` dans vos tests en plus des requêtes à votre application **FastAPI** (comme par exemple des fonctions de base de données asynchrones), jetez un coup d'œil à [Tests Asynchrones](../advanced/async-tests.md){.internal-link target=_blank} dans le tutoriel avancé.\n+\n+///\n+\n+## Séparer les tests\n+\n+Dans une application réelle, il est probable que vous aurez vos tests dans des fichiers distincts.\n+\n+Et votre application **FastAPI** pourrait aussi être composée de plusieurs fichiers/modules, etc.\n+\n+### Fichier de l'application **FastAPI**\n+\n+Disons que vous avez une structure de fichier comme décrite dans [Applications plus grandes](bigger-applications.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   └── main.py\n+```\n+\n+Dans le fichier `main.py` vous avez votre app **FastAPI**:\n+\n+\n+```Python\n+{!../../../docs_src/app_testing/main.py!}\n+```",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "2149165665",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 12201,
        "pr_file": "docs/fr/docs/tutorial/testing.md",
        "discussion_id": "2149165665",
        "commented_code": "@@ -0,0 +1,250 @@\n+# Testing\n+\n+<a href=\"https://www.starlette.io/testclient/\" class=\"external-link\" target=\"_blank\">Starlette</a> rend le test des applications **FastAPI** facile et agréable.\n+\n+Il est basé sur <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">HTTPX</a>, qui est lui-même basé sur Request, ce qui le rend très compréhensible et intuitif.\n+\n+Cela vous permet d'utiliser directement <a href=\"https://docs.pytest.org/\" class=\"external-link\" target=\"_blank\">pytest</a> avec **FastAPI**.\n+\n+## Utiliser `TestClient`\n+\n+/// info\n+\n+Pour utiliser `TestClient`, installez d'abord <a href=\"https://www.python-httpx.org\" class=\"external-link\" target=\"_blank\">`httpx`</a>.\n+\n+Assurez-vous de créez un [environnement virtuel](../virtual-environments.md){.internal-link target=_blank}, activez-le, puis installez-le, par exemple:\n+\n+```console\n+$ pip install httpx\n+```\n+\n+///\n+\n+Importez `TestClient`.\n+\n+Créez un `TestClient` en y passant votre application **FastAPI**.\n+\n+Créez des fonctions ayant un nom commençant par `test_` (c'est une convention standard de `pytest`).\n+\n+Utilisez l'objet `TestClient` comme vous le faites avec `httpx`.\n+\n+Rédigez des `assert` simples avec les expressions Python standards que vous devez vérifier (encore une fois, un standard `pytest`).\n+\n+```Python hl_lines=\"2  12  15-18\"\n+{!../../../docs_src/app_testing/tutorial001.py!}\n+```\n+\n+/// tip\n+\n+Remarquez que les fonctions de test sont des `def` normaux, pas des `async def`.\n+\n+Et que les appels au client sont également des appels normaux, n'utilisant pas `await`.\n+\n+Cela vous permet d'utiliser `pytest` directement sans complications.\n+\n+///\n+\n+/// note | \"Technical Details\"\n+\n+Vous pouvez également utiliser `from starlette.testclient import TestClient`.\n+\n+**FastAPI** fournit à la fois `starlette.testclient` ainsi que `fastapi.testclient` par commodité pour vous, le développeur. Mais il vient directement de Starlette.\n+\n+///\n+\n+/// tip\n+\n+Si vous souhaitez appeler des fonctions `async` dans vos tests en plus des requêtes à votre application **FastAPI** (comme par exemple des fonctions de base de données asynchrones), jetez un coup d'œil à [Tests Asynchrones](../advanced/async-tests.md){.internal-link target=_blank} dans le tutoriel avancé.\n+\n+///\n+\n+## Séparer les tests\n+\n+Dans une application réelle, il est probable que vous aurez vos tests dans des fichiers distincts.\n+\n+Et votre application **FastAPI** pourrait aussi être composée de plusieurs fichiers/modules, etc.\n+\n+### Fichier de l'application **FastAPI**\n+\n+Disons que vous avez une structure de fichier comme décrite dans [Applications plus grandes](bigger-applications.md){.internal-link target=_blank}:\n+\n+```\n+.\n+├── app\n+│   ├── __init__.py\n+│   └── main.py\n+```\n+\n+Dans le fichier `main.py` vous avez votre app **FastAPI**:\n+\n+\n+```Python\n+{!../../../docs_src/app_testing/main.py!}\n+```",
        "comment_created_at": "2025-06-16T06:46:20+00:00",
        "comment_author": "YuriiMotov",
        "comment_body": "```suggestion\r\n{* ../../docs_src/app_testing/main.py *}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1909417220",
    "pr_number": 13163,
    "pr_file": "docs/en/docs/advanced/async-tests.md",
    "created_at": "2025-01-09T20:52:16+00:00",
    "commented_code": "## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n-\n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n-\n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-This is the equivalent to:\n \n-```Python\n-response = client.get('/')\n-```\n+## Other Asynchronous Function Calls\n \n-...that we used to make our requests with the `TestClient`.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n \n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n+```python\n+import asyncio\n+import pytest\n+from collections.abc import Generator\n \n-///\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1909417220",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13163,
        "pr_file": "docs/en/docs/advanced/async-tests.md",
        "discussion_id": "1909417220",
        "commented_code": "@@ -54,46 +59,34 @@ $ pytest\n \n ## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n-\n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n-\n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-This is the equivalent to:\n \n-```Python\n-response = client.get('/')\n-```\n+## Other Asynchronous Function Calls\n \n-...that we used to make our requests with the `TestClient`.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n \n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n+```python\n+import asyncio\n+import pytest\n+from collections.abc import Generator\n \n-///\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:",
        "comment_created_at": "2025-01-09T20:52:16+00:00",
        "comment_author": "graingert",
        "comment_body": "This just scopes the same loop for the whole session, each test function should get a fresh loop. The only way to fix this issue is to fix the underlying code that uses a global database connection to make it in lifespan_context",
        "pr_file_module": null
      },
      {
        "comment_id": "1909477574",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13163,
        "pr_file": "docs/en/docs/advanced/async-tests.md",
        "discussion_id": "1909417220",
        "commented_code": "@@ -54,46 +59,34 @@ $ pytest\n \n ## In Detail\n \n-The marker `@pytest.mark.anyio` tells pytest that this test function should be called asynchronously:\n+The lifespan function demonstrates how to manage the lifecycle of application-wide resources. During the app's lifespan, we open a resource (`some_state_open`) at startup and clean it up (`some_state_close`) during shutdown.\n \n-{* ../../docs_src/async_tests/test_main.py hl[7] *}\n+We use **ASGITransport** from **HTTPX** to interact directly with the **FastAPI** app in an async test environment.\n \n-/// tip\n-\n-Note that the test function is now `async def` instead of just `def` as before when using the `TestClient`.\n-\n-///\n-\n-Then we can create an `AsyncClient` with the app, and send async requests to it, using `await`.\n+When testing **FastAPI** apps with a custom lifespan, it's critical to manually trigger it in the test context to ensure proper setup and teardown of resources.\n \n-{* ../../docs_src/async_tests/test_main.py hl[9:12] *}\n+If you observe issues with state initialization or teardown in your tests, ensure that the lifespan is correctly invoked, and verify the app's state before and after requests.\n \n-This is the equivalent to:\n \n-```Python\n-response = client.get('/')\n-```\n+## Other Asynchronous Function Calls\n \n-...that we used to make our requests with the `TestClient`.\n+As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code.\n \n /// tip\n \n-Note that we're using async/await with the new `AsyncClient` - the request is asynchronous.\n-\n-///\n-\n-/// warning\n+If you encounter a `RuntimeError: Task attached to a different loop` when integrating asynchronous function calls in your tests, you can override the default pytest event loop using the following fixture:\n \n-If your application relies on lifespan events, the `AsyncClient` won't trigger these events. To ensure they are triggered, use `LifespanManager` from <a href=\"https://github.com/florimondmanca/asgi-lifespan#usage\" class=\"external-link\" target=\"_blank\">florimondmanca/asgi-lifespan</a>.\n+```python\n+import asyncio\n+import pytest\n+from collections.abc import Generator\n \n-///\n+@pytest.fixture(scope=\"session\")\n+def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:",
        "comment_created_at": "2025-01-09T21:56:45+00:00",
        "comment_author": "oleg-korshunov",
        "comment_body": "Yes, you are absolutely right, I specifically used this option as it is simpler, I made the code in accordance with your review, and also added a note about a simpler setup",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921052593",
    "pr_number": 13227,
    "pr_file": "docs/ru/docs/advanced/async-tests.md",
    "created_at": "2025-01-18T12:03:13+00:00",
    "commented_code": "+# Асинхронное тестирование\n+\n+Вы уже видели как тестировать **FastAPI** приложение, используя имеющийся класс `TestClient`. К этому моменту вы видели только как писать тесты в синхронном стиле без использования `async` функций.\n+\n+Возможность использования асинхронных функций в ваших тестах может быть полезно, например, когда вы асинхронно обращаетесь к вашей базе данных. Представьте, что вы хотите отправить запросы в ваше FastAPI приложение, а затем при помощи асинхронной библиотеки для работы с базой данных удостовериться, что ваш бекэнд корректно записал данные в базу данных.",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1921052593",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13227,
        "pr_file": "docs/ru/docs/advanced/async-tests.md",
        "discussion_id": "1921052593",
        "commented_code": "@@ -0,0 +1,99 @@\n+# Асинхронное тестирование\n+\n+Вы уже видели как тестировать **FastAPI** приложение, используя имеющийся класс `TestClient`. К этому моменту вы видели только как писать тесты в синхронном стиле без использования `async` функций.\n+\n+Возможность использования асинхронных функций в ваших тестах может быть полезно, например, когда вы асинхронно обращаетесь к вашей базе данных. Представьте, что вы хотите отправить запросы в ваше FastAPI приложение, а затем при помощи асинхронной библиотеки для работы с базой данных удостовериться, что ваш бекэнд корректно записал данные в базу данных.",
        "comment_created_at": "2025-01-18T12:03:13+00:00",
        "comment_author": "alv2017",
        "comment_body": "```suggestion\r\nВозможность использования асинхронных функций в ваших тестах может быть полезнa, когда, например, вы асинхронно обращаетесь к вашей базе данных. Представьте, что вы хотите отправить запросы в ваше FastAPI приложение, а затем при помощи асинхронной библиотеки для работы с базой данных удостовериться, что ваш бекэнд корректно записал данные в базу данных.\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1929679235",
    "pr_number": 13227,
    "pr_file": "docs/ru/docs/advanced/async-tests.md",
    "created_at": "2025-01-26T07:13:40+00:00",
    "commented_code": "+# Асинхронное тестирование\n+\n+Вы уже видели как тестировать **FastAPI** приложение, используя имеющийся класс `TestClient`. К этому моменту вы видели только как писать тесты в синхронном стиле без использования `async` функций.\n+\n+Возможность использования асинхронных функций в ваших тестах может быть полезнa, когда, например, вы асинхронно обращаетесь к вашей базе данных. Представьте, что вы хотите отправить запросы в ваше FastAPI приложение, а затем при помощи асинхронной библиотеки для работы с базой данных удостовериться, что ваш бекэнд корректно записал данные в базу данных.\n+\n+Давайте рассмотрим, как мы можем это реализовать.\n+\n+## pytest.mark.anyio",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1929679235",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13227,
        "pr_file": "docs/ru/docs/advanced/async-tests.md",
        "discussion_id": "1929679235",
        "commented_code": "@@ -0,0 +1,99 @@\n+# Асинхронное тестирование\n+\n+Вы уже видели как тестировать **FastAPI** приложение, используя имеющийся класс `TestClient`. К этому моменту вы видели только как писать тесты в синхронном стиле без использования `async` функций.\n+\n+Возможность использования асинхронных функций в ваших тестах может быть полезнa, когда, например, вы асинхронно обращаетесь к вашей базе данных. Представьте, что вы хотите отправить запросы в ваше FastAPI приложение, а затем при помощи асинхронной библиотеки для работы с базой данных удостовериться, что ваш бекэнд корректно записал данные в базу данных.\n+\n+Давайте рассмотрим, как мы можем это реализовать.\n+\n+## pytest.mark.anyio",
        "comment_created_at": "2025-01-26T07:13:40+00:00",
        "comment_author": "Xewus",
        "comment_body": "Какая-то устаревшая информация. Не нужно как-то специально помечать асинхронные тесты...",
        "pr_file_module": null
      },
      {
        "comment_id": "1929769035",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13227,
        "pr_file": "docs/ru/docs/advanced/async-tests.md",
        "discussion_id": "1929679235",
        "commented_code": "@@ -0,0 +1,99 @@\n+# Асинхронное тестирование\n+\n+Вы уже видели как тестировать **FastAPI** приложение, используя имеющийся класс `TestClient`. К этому моменту вы видели только как писать тесты в синхронном стиле без использования `async` функций.\n+\n+Возможность использования асинхронных функций в ваших тестах может быть полезнa, когда, например, вы асинхронно обращаетесь к вашей базе данных. Представьте, что вы хотите отправить запросы в ваше FastAPI приложение, а затем при помощи асинхронной библиотеки для работы с базой данных удостовериться, что ваш бекэнд корректно записал данные в базу данных.\n+\n+Давайте рассмотрим, как мы можем это реализовать.\n+\n+## pytest.mark.anyio",
        "comment_created_at": "2025-01-26T13:08:36+00:00",
        "comment_author": "alv2017",
        "comment_body": "Если асинхронные тесты не помечать, то они будут пропускаться:\r\n\r\n```\r\nPytestUnhandledCoroutineWarning: async def functions are not natively supported and have been skipped.\r\n  You need to install a suitable plugin for your async framework, for example:\r\n    - anyio\r\n    - pytest-asyncio\r\n    - pytest-tornasync\r\n    - pytest-trio\r\n    - pytest-twisted\r\n    warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))\r\n\r\n-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html\r\n\r\n```\r\n\r\nPytest не поддерживает выполнение асинхронных тестов. Для поддержки асинхронных тестов нужно устанавливать доп. плагины (см. выше), под каждый плагин нужны свои настройки. Для `anyio` это одна из опций.\r\n",
        "pr_file_module": null
      }
    ]
  }
]