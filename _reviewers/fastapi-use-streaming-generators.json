[
  {
    "discussion_id": "1949458219",
    "pr_number": 13063,
    "pr_file": "docs/ko/docs/tutorial/extra-models.md",
    "created_at": "2025-02-10T16:21:26+00:00",
    "commented_code": "+# 추가 모델\n+\n+지난 예제에 이어서, 연관된 모델을 여러개 갖는 것은 흔한 일입니다.\n+\n+특히 유저 모델의 경우에 그러한데, 왜냐하면:\n+\n+* **입력 모델** 은 비밀번호를 가져야 합니다.\n+* **출력 모델** 은 비밀번호를 가지면 안됩니다.\n+* **데이터베이스 모델** 은 해시처리된 비밀번호를 가질 것입니다.\n+\n+/// danger | 위험\n+\n+절대 유저의 비밀번호를 평문으로 저장하지 마세요. 항상 이후에 검증 가능한 \"안전한 해시(secure hash)\"로 저장하세요.\n+\n+만약 이게 무엇인지 모르겠다면, [security chapters](security/simple-oauth2.md#password-hashing){.internal-link target=_blank}.에서 비밀번호 해시에 대해 배울 수 있습니다.\n+\n+///\n+\n+## 다중 모델\n+\n+아래는 비밀번호 필드와 해당 필드가 사용되는 위치를 포함하여, 각 모델들이 어떤 형태를 가질 수 있는지 전반적인 예시입니다:\n+\n+{* ../../docs_src/extra_models/tutorial001_py310.py hl[7,9,14,20,22,27:28,31:33,38:39] *}\n+\n+\n+/// info | 정보\n+\n+Pydantic v1에서는 해당 메서드가 `.dict()`로 불렸으며, Pydantic v2에서는 `.model_dump()`로 이름이 변경되었습니다. `.dict()`는 여전히 지원되지만 더 이상 권장되지 않습니다.\n+\n+여기에서 사용하는 예제는 Pydantic v1과의 호환성을 위해 `.dict()`를 사용하지만, Pydantic v2를 사용할 수 있다면 `.model_dump()`를 사용하는 것이 좋습니다.\n+\n+///\n+\n+### `**user_in.dict()` 에 대하여\n+\n+#### Pydantic의 `.dict()`\n+\n+`user_in`은 Pydantic 모델 클래스인 `UserIn`입니다.\n+\n+Pydantic 모델은 모델 데이터를 포함한 `dict`를 반환하는 `.dict()` 메서드를 제공합니다.\n+\n+따라서, 다음과 같이 Pydantic 객체 `user_in`을 생성할 수 있습니다:\n+\n+```Python\n+user_in = UserIn(username=\"john\", password=\"secret\", email=\"john.doe@example.com\")\n+```\n+\n+그 다음, 다음과 같이 호출합니다:\n+\n+```Python\n+user_dict = user_in.dict()\n+```\n+\n+이제 변수 `user_dict`에 데이터가 포함된 `dict`를 가지게 됩니다(이는 Pydantic 모델 객체가 아닌 `dict`입니다).\n+\n+그리고 다음과 같이 호출하면:\n+\n+```Python\n+print(user_dict)\n+```\n+\n+Python의 `dict`가 다음과 같이 출력됩니다:\n+\n+```Python\n+{\n+    'username': 'john',\n+    'password': 'secret',\n+    'email': 'john.doe@example.com',\n+    'full_name': None,\n+}\n+```\n+\n+#### `dict` 언래핑(Unwrapping)\n+\n+`user_dict`와 같은 `dict`를 함수(또는 클래스)에 `**user_dict`로 전달하면, Python은 이를 \"언랩(unwrap)\"합니다. 이 과정에서 `user_dict`의 키와 값을 각각 키-값 인자로 직접 전달합니다.\n+\n+따라서, 위에서 생성한 `user_dict`를 사용하여 다음과 같이 작성하면:\n+\n+```Python\n+UserInDB(**user_dict)\n+```\n+\n+다음과 같은 결과를 생성합니다:\n+\n+```Python\n+UserInDB(\n+    username=\"john\",\n+    password=\"secret\",\n+    email=\"john.doe@example.com\",\n+    full_name=None,\n+)\n+```\n+\n+혹은 더 정확히 말하자면, `user_dict`를 직접 사용하여, 미래에 어떤 내용이 포함되더라도:\n+\n+```Python\n+UserInDB(\n+    username = user_dict[\"username\"],\n+    password = user_dict[\"password\"],\n+    email = user_dict[\"email\"],\n+    full_name = user_dict[\"full_name\"],\n+)\n+```\n+\n+#### 다른 Pydantic 모델의 데이터를 활용한 Pydantic 모델 생성\n+\n+위의 예제에서 `user_in.dict()`로부터 `user_dict`를 생성한 것처럼, 아래 코드는:\n+\n+```Python\n+user_dict = user_in.dict()\n+UserInDB(**user_dict)\n+```\n+\n+다음과 동일합니다:\n+\n+```Python\n+UserInDB(**user_in.dict())\n+```\n+\n+...왜냐하면 `user_in.dict()`는 `dict`이며, 이를 `**`로 Python이 \"언랩(unwrap)\"하도록 하여 `UserInDB`에 전달하기 때문입니다.\n+\n+따라서, 다른 Pydantic 모델의 데이터를 사용하여 새로운 Pydantic 모델을 생성할 수 있습니다.\n+\n+#### `dict` 언래핑(Unwrapping)과 추가 키워드\n+\n+그리고 다음과 같이 추가 키워드 인자 `hashed_password=hashed_password`를 포함하면:\n+\n+```Python\n+UserInDB(**user_in.dict(), hashed_password=hashed_password)\n+```\n+\n+다음과 같은 결과를 생성합니다:\n+\n+```Python\n+UserInDB(\n+    username = user_dict[\"username\"],\n+    password = user_dict[\"password\"],\n+    email = user_dict[\"email\"],\n+    full_name = user_dict[\"full_name\"],\n+    hashed_password = hashed_password,\n+)\n+```\n+\n+/// warning | 경고\n+\n+추가적으로 제공된 함수 `fake_password_hasher`와 `fake_save_user`는 데이터 흐름을 시연하기 위한 예제일 뿐이며, 실제 보안을 제공하지 않습니다.\n+\n+///\n+\n+## 중복 줄이기\n+\n+코드 중복을 줄이는 것은 **FastAPI**의 핵심 아이디어 중 하나입니다.\n+\n+코드 중복은 버그, 보안 문제, 코드 비동기화 문제(한 곳은 업데이트되었지만 다른 곳은 업데이트되지 않는 문제) 등의 가능성을 증가시킵니다.\n+\n+그리고 이 모델들은 많은 데이터를 공유하면서 속성 이름과 타입을 중복하고 있습니다.\n+\n+더 나은 방법이 있습니다.\n+\n+`UserBase` 모델을 선언하여 다른 모델들의 기본(base)으로 사용할 수 있습니다. 그런 다음 이 모델을 상속받아 속성과 타입 선언(유형 선언, 검증 등)을 상속하는 서브클래스를 만들 수 있습니다.\n+\n+모든 데이터 변환, 검증, 문서화 등은 정상적으로 작동할 것입니다.\n+\n+이렇게 하면 각 모델 간의 차이점만 선언할 수 있습니다(평문 `password`가 있는 경우, `hashed_password`만 있는 경우, 혹은 비밀번호가 없는 경우):\n+\n+{* ../../docs_src/extra_models/tutorial002_py310.py hl[7,13:14,17:18,21:22] *}\n+\n+## `Union` 또는 `anyOf`\n+\n+두 가지 이상의 타입을 포함하는 `Union`으로 응답을 선언할 수 있습니다. 이는 응답이 그 중 하나의 타입일 수 있음을 의미합니다.\n+\n+OpenAPI에서는 이를 `anyOf`로 정의합니다.\n+\n+이를 위해 표준 Python 타입 힌트인 <a href=\"https://docs.python.org/3/library/typing.html#typing.Union\" class=\"external-link\" target=\"_blank\">`typing.Union`</a>을 사용할 수 있습니다:\n+\n+/// note | 참고\n+\n+<a href=\"https://docs.pydantic.dev/latest/concepts/types/#unions\" class=\"external-link\" target=\"_blank\">`Union`</a>을 정의할때는 더 구체적인 타입을 먼저 포함하고, 덜 구체적인 타입을 그 뒤에 나열해야합니다. 아래 예제에서는 `Union[PlaneItem, CarItem]` 를 보면, 더 구체적인 `PlaneItem`이 `CarItem`보다 앞에 위치합니다.\n+\n+///\n+\n+{* ../../docs_src/extra_models/tutorial003_py310.py hl[1,14:15,18:20,33] *}\n+\n+\n+### Python 3.10에서 `Union`\n+\n+위의 예제에서는 `response_model` 인자 값으로 `Union[PlaneItem, CarItem]`을 전달합니다.\n+\n+이 경우, 이를 **타입 주석(type annotation)** 이 아닌 **인자 값(argument value)** 으로 전달하고 있기 때문에 Python 3.10에서도 `Union`을 사용해야 합니다.\n+\n+만약 타입 주석에 사용한다면, 다음과 같이 수직 막대(|)를 사용할 수 있습니다:\n+\n+```Python\n+some_variable: PlaneItem | CarItem\n+```\n+\n+하지만 이를 `response_model=PlaneItem | CarItem`과 같이 할당하면 에러가 발생합니다. 이는 Python이 이를 타입 주석으로 해석하지 않고, `PlaneItem`과 `CarItem` 사이의 **잘못된 연산(invalid operation)**을 시도하기 때문입니다",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1949458219",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13063,
        "pr_file": "docs/ko/docs/tutorial/extra-models.md",
        "discussion_id": "1949458219",
        "commented_code": "@@ -0,0 +1,223 @@\n+# 추가 모델\n+\n+지난 예제에 이어서, 연관된 모델을 여러개 갖는 것은 흔한 일입니다.\n+\n+특히 유저 모델의 경우에 그러한데, 왜냐하면:\n+\n+* **입력 모델** 은 비밀번호를 가져야 합니다.\n+* **출력 모델** 은 비밀번호를 가지면 안됩니다.\n+* **데이터베이스 모델** 은 해시처리된 비밀번호를 가질 것입니다.\n+\n+/// danger | 위험\n+\n+절대 유저의 비밀번호를 평문으로 저장하지 마세요. 항상 이후에 검증 가능한 \"안전한 해시(secure hash)\"로 저장하세요.\n+\n+만약 이게 무엇인지 모르겠다면, [security chapters](security/simple-oauth2.md#password-hashing){.internal-link target=_blank}.에서 비밀번호 해시에 대해 배울 수 있습니다.\n+\n+///\n+\n+## 다중 모델\n+\n+아래는 비밀번호 필드와 해당 필드가 사용되는 위치를 포함하여, 각 모델들이 어떤 형태를 가질 수 있는지 전반적인 예시입니다:\n+\n+{* ../../docs_src/extra_models/tutorial001_py310.py hl[7,9,14,20,22,27:28,31:33,38:39] *}\n+\n+\n+/// info | 정보\n+\n+Pydantic v1에서는 해당 메서드가 `.dict()`로 불렸으며, Pydantic v2에서는 `.model_dump()`로 이름이 변경되었습니다. `.dict()`는 여전히 지원되지만 더 이상 권장되지 않습니다.\n+\n+여기에서 사용하는 예제는 Pydantic v1과의 호환성을 위해 `.dict()`를 사용하지만, Pydantic v2를 사용할 수 있다면 `.model_dump()`를 사용하는 것이 좋습니다.\n+\n+///\n+\n+### `**user_in.dict()` 에 대하여\n+\n+#### Pydantic의 `.dict()`\n+\n+`user_in`은 Pydantic 모델 클래스인 `UserIn`입니다.\n+\n+Pydantic 모델은 모델 데이터를 포함한 `dict`를 반환하는 `.dict()` 메서드를 제공합니다.\n+\n+따라서, 다음과 같이 Pydantic 객체 `user_in`을 생성할 수 있습니다:\n+\n+```Python\n+user_in = UserIn(username=\"john\", password=\"secret\", email=\"john.doe@example.com\")\n+```\n+\n+그 다음, 다음과 같이 호출합니다:\n+\n+```Python\n+user_dict = user_in.dict()\n+```\n+\n+이제 변수 `user_dict`에 데이터가 포함된 `dict`를 가지게 됩니다(이는 Pydantic 모델 객체가 아닌 `dict`입니다).\n+\n+그리고 다음과 같이 호출하면:\n+\n+```Python\n+print(user_dict)\n+```\n+\n+Python의 `dict`가 다음과 같이 출력됩니다:\n+\n+```Python\n+{\n+    'username': 'john',\n+    'password': 'secret',\n+    'email': 'john.doe@example.com',\n+    'full_name': None,\n+}\n+```\n+\n+#### `dict` 언래핑(Unwrapping)\n+\n+`user_dict`와 같은 `dict`를 함수(또는 클래스)에 `**user_dict`로 전달하면, Python은 이를 \"언랩(unwrap)\"합니다. 이 과정에서 `user_dict`의 키와 값을 각각 키-값 인자로 직접 전달합니다.\n+\n+따라서, 위에서 생성한 `user_dict`를 사용하여 다음과 같이 작성하면:\n+\n+```Python\n+UserInDB(**user_dict)\n+```\n+\n+다음과 같은 결과를 생성합니다:\n+\n+```Python\n+UserInDB(\n+    username=\"john\",\n+    password=\"secret\",\n+    email=\"john.doe@example.com\",\n+    full_name=None,\n+)\n+```\n+\n+혹은 더 정확히 말하자면, `user_dict`를 직접 사용하여, 미래에 어떤 내용이 포함되더라도:\n+\n+```Python\n+UserInDB(\n+    username = user_dict[\"username\"],\n+    password = user_dict[\"password\"],\n+    email = user_dict[\"email\"],\n+    full_name = user_dict[\"full_name\"],\n+)\n+```\n+\n+#### 다른 Pydantic 모델의 데이터를 활용한 Pydantic 모델 생성\n+\n+위의 예제에서 `user_in.dict()`로부터 `user_dict`를 생성한 것처럼, 아래 코드는:\n+\n+```Python\n+user_dict = user_in.dict()\n+UserInDB(**user_dict)\n+```\n+\n+다음과 동일합니다:\n+\n+```Python\n+UserInDB(**user_in.dict())\n+```\n+\n+...왜냐하면 `user_in.dict()`는 `dict`이며, 이를 `**`로 Python이 \"언랩(unwrap)\"하도록 하여 `UserInDB`에 전달하기 때문입니다.\n+\n+따라서, 다른 Pydantic 모델의 데이터를 사용하여 새로운 Pydantic 모델을 생성할 수 있습니다.\n+\n+#### `dict` 언래핑(Unwrapping)과 추가 키워드\n+\n+그리고 다음과 같이 추가 키워드 인자 `hashed_password=hashed_password`를 포함하면:\n+\n+```Python\n+UserInDB(**user_in.dict(), hashed_password=hashed_password)\n+```\n+\n+다음과 같은 결과를 생성합니다:\n+\n+```Python\n+UserInDB(\n+    username = user_dict[\"username\"],\n+    password = user_dict[\"password\"],\n+    email = user_dict[\"email\"],\n+    full_name = user_dict[\"full_name\"],\n+    hashed_password = hashed_password,\n+)\n+```\n+\n+/// warning | 경고\n+\n+추가적으로 제공된 함수 `fake_password_hasher`와 `fake_save_user`는 데이터 흐름을 시연하기 위한 예제일 뿐이며, 실제 보안을 제공하지 않습니다.\n+\n+///\n+\n+## 중복 줄이기\n+\n+코드 중복을 줄이는 것은 **FastAPI**의 핵심 아이디어 중 하나입니다.\n+\n+코드 중복은 버그, 보안 문제, 코드 비동기화 문제(한 곳은 업데이트되었지만 다른 곳은 업데이트되지 않는 문제) 등의 가능성을 증가시킵니다.\n+\n+그리고 이 모델들은 많은 데이터를 공유하면서 속성 이름과 타입을 중복하고 있습니다.\n+\n+더 나은 방법이 있습니다.\n+\n+`UserBase` 모델을 선언하여 다른 모델들의 기본(base)으로 사용할 수 있습니다. 그런 다음 이 모델을 상속받아 속성과 타입 선언(유형 선언, 검증 등)을 상속하는 서브클래스를 만들 수 있습니다.\n+\n+모든 데이터 변환, 검증, 문서화 등은 정상적으로 작동할 것입니다.\n+\n+이렇게 하면 각 모델 간의 차이점만 선언할 수 있습니다(평문 `password`가 있는 경우, `hashed_password`만 있는 경우, 혹은 비밀번호가 없는 경우):\n+\n+{* ../../docs_src/extra_models/tutorial002_py310.py hl[7,13:14,17:18,21:22] *}\n+\n+## `Union` 또는 `anyOf`\n+\n+두 가지 이상의 타입을 포함하는 `Union`으로 응답을 선언할 수 있습니다. 이는 응답이 그 중 하나의 타입일 수 있음을 의미합니다.\n+\n+OpenAPI에서는 이를 `anyOf`로 정의합니다.\n+\n+이를 위해 표준 Python 타입 힌트인 <a href=\"https://docs.python.org/3/library/typing.html#typing.Union\" class=\"external-link\" target=\"_blank\">`typing.Union`</a>을 사용할 수 있습니다:\n+\n+/// note | 참고\n+\n+<a href=\"https://docs.pydantic.dev/latest/concepts/types/#unions\" class=\"external-link\" target=\"_blank\">`Union`</a>을 정의할때는 더 구체적인 타입을 먼저 포함하고, 덜 구체적인 타입을 그 뒤에 나열해야합니다. 아래 예제에서는 `Union[PlaneItem, CarItem]` 를 보면, 더 구체적인 `PlaneItem`이 `CarItem`보다 앞에 위치합니다.\n+\n+///\n+\n+{* ../../docs_src/extra_models/tutorial003_py310.py hl[1,14:15,18:20,33] *}\n+\n+\n+### Python 3.10에서 `Union`\n+\n+위의 예제에서는 `response_model` 인자 값으로 `Union[PlaneItem, CarItem]`을 전달합니다.\n+\n+이 경우, 이를 **타입 주석(type annotation)** 이 아닌 **인자 값(argument value)** 으로 전달하고 있기 때문에 Python 3.10에서도 `Union`을 사용해야 합니다.\n+\n+만약 타입 주석에 사용한다면, 다음과 같이 수직 막대(|)를 사용할 수 있습니다:\n+\n+```Python\n+some_variable: PlaneItem | CarItem\n+```\n+\n+하지만 이를 `response_model=PlaneItem | CarItem`과 같이 할당하면 에러가 발생합니다. 이는 Python이 이를 타입 주석으로 해석하지 않고, `PlaneItem`과 `CarItem` 사이의 **잘못된 연산(invalid operation)**을 시도하기 때문입니다",
        "comment_created_at": "2025-02-10T16:21:26+00:00",
        "comment_author": "yes0ng",
        "comment_body": "```suggestion\r\n하지만 이를 `response_model=PlaneItem | CarItem`과 같이 할당하면 에러가 발생합니다. 이는 Python이 이를 타입 어노테이션으로 해석하지 않고, `PlaneItem`과 `CarItem` 사이의 **잘못된 연산(invalid operation)**을 시도하기 때문입니다\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1953079269",
    "pr_number": 13265,
    "pr_file": "docs/ko/docs/advanced/custom-response.md",
    "created_at": "2025-02-12T17:09:20+00:00",
    "commented_code": "+# 사용자 정의 응답 - HTML, Stream, 파일, 기타\n+\n+기본적으로, **FastAPI** 응답을 `JSONResponse`를 사용하여 반환합니다.\n+\n+이를 재정의 하려면 [응답을 직접 반환하기](response-directly.md){.internal-link target=_blank}에서 본 것처럼 `Response`를 직접 반환하면 됩니다.\n+\n+그러나 `Response` (또는 `JSONResponse`와 같은 하위 클래스)를 직접 반환하면, 데이터가 자동으로 변환되지 않으며 (심지어 `response_model`을 선언했더라도), 문서화가 자동으로 생성되지 않습니다(예를 들어, 생성된 OpenAPI의 일부로 HTTP 헤더 `Content-Type`에 특정 \"미디어 타입\"을 포함하는 경우).\n+\n+하지만 *경로 작업 데코레이터*에서 `response_class` 매개변수를 사용하여 원하는 `Response`(예: 모든 `Response` 하위 클래스)를 선언할 수도 있습니다.\n+\n+*경로 작업 함수*에서 반환하는 내용은 해당 `Response`안에 포함됩니다.\n+\n+그리고 만약 그 `Response`가 `JSONResponse`와 `UJSONResponse`의 경우 처럼 JSON 미디어 타입(`application/json`)을 가지고 있다면, *경로 작업 데코레이터*에서 선언한 Pydantic의 `response_model`을 사용해 자동으로 변환(및 필터링) 됩니다.\n+\n+/// note | 참고\n+\n+미디어 타입이 없는 응답 클래스를 사용하는 경우, FastAPI는 응답에 내용이 없을 것으로 예상하므로 생성된 OpenAPI 문서에서 응답 형식을 문서화하지 않습니다.\n+\n+///\n+\n+## `ORJSONResponse` 사용하기\n+\n+예를 들어, 성능을 극대화하려는 경우, <a href=\"https://github.com/ijl/orjson\" class=\"external-link\" target=\"_blank\">orjson</a>을 설치하여 사용하고 응답을 `ORJSONResponse`로 설정할 수 있습니다.\n+\n+사용하고자 하는 `Response` 클래스(하위 클래스)를 임포트한 후, **경로 작업 데코레이터*에서 선언하세요.\n+\n+대규모 응답의 경우, 사전을 반환하는 것보다 `Response`를 반환하는 것이 훨씬 빠릅니다.\n+\n+이유는 기본적으로, FastAPI가 내부의 모든 항목을 검사하고 JSON으로 직렬화할 수 있는지 확인하기 때문입니다. 이는 사용자 안내서에서 설명된 [JSON 호환 가능 인코더](../tutorial/encoder.md){.internal-link target=_blank}를 사용하는 방식과 동일합니다. 이를 통해 데이터베이스 모델과 같은 **임의의 객체**를 반환할 수 있습니다.\n+\n+하지만 반환하는 내용이 **JSON으로 직렬화 가능**하다고 확신하는 경우, 해당 내용을 응답 클래스에 직접 전달할 수 있으며, FastAPI가 반환 내용을 `jsonable_encoder`를 통해 처리한 뒤 응답 클래스에 전달하는 오버헤드를 피할 수 있습니다.\n+\n+{* ../../docs_src/custom_response/tutorial001b.py hl[2,7] *}\n+\n+/// info | 정보\n+\n+`response_class` 매개변수는 응답의 \"미디어 타입\"을 정의하는 데에도 사용됩니다.\n+\n+이 경우, HTTP 헤더 `Content-Type`은 `application/json`으로 설정됩니다.\n+\n+그리고 이는 OpenAPI에 그대로 문서화됩니다.\n+\n+///\n+\n+/// tip | 팁\n+\n+`ORJSONResponse`는 FastAPI에서만 사용할 수 있고 Starlette에서는 사용할 수 없습니다.\n+\n+///\n+\n+## HTML 응답\n+\n+**FastAPI**에서 HTML 응답을 직접 반환하려면 `HTMLResponse`를 사용하세요.\n+\n+* `HTMLResponse`를 임포트 합니다.\n+* *경로 작업 데코레이터*의 `response_class` 매개변수로 `HTMLResponse`를 전달합니다.\n+\n+{* ../../docs_src/custom_response/tutorial002.py hl[2,7] *}\n+\n+/// info | 정보\n+\n+`response_class` 매개변수는 응답의 \"미디어 타입\"을 정의하는 데에도 사용됩니다.\n+\n+이 경우, HTTP 헤더 `Content-Type`은 `text/html`로 설정됩니다.\n+\n+그리고 이는 OpenAPI에 그대로 문서화 됩니다.\n+\n+///\n+\n+### `Response` 반환하기\n+\n+[응답을 직접 반환하기](response-directly.md){.internal-link target=_blank}에서 본 것 처럼, *경로 작업*에서 응답을 직접 반환하여 재정의할 수도 있습니다.\n+\n+위의 예제와 동일하게 `HTMLResponse`를 반환하는 코드는 다음과 같을 수 있습니다:\n+\n+{* ../../docs_src/custom_response/tutorial003.py hl[2,7,19] *}\n+\n+/// warning | 경고\n+\n+*경로 작업 함수*에서 직접 반환된 `Response`는 OpenAPI에 문서화되지 않습니다(예를들어, `Content-Type`이 문서화되지 않음) 자동 대화형 문서에서도 표시되지 않습니다.\n+\n+///\n+\n+/// info | 정보\n+\n+물론 실제 `Content-Type` 헤더, 상태 코드 등은 반환된 `Response` 객체에서 가져옵니다.\n+\n+///\n+\n+### OpenAPI에 문서화하고 `Response` 재정의 하기\n+\n+함수 내부에서 응답을 재정의하면서 동시에 OpenAPI에서 \"미디어 타입\"을 문서화하고 싶다면, `response_class` 매게변수를 사용하면서 `Response` 객체를 반환할 수 있습니다.\n+\n+이 경우 `response_class`는 OpenAPI *경로 작업*을 문서화하는 데만 사용되고, 실제로는 여러분이 반환한 `Response`가 그대로 사용됩니다.\n+\n+### `HTMLResponse`직접 반환하기\n+\n+예를 들어, 다음과 같이 작성할 수 있습니다:\n+\n+{* ../../docs_src/custom_response/tutorial004.py hl[7,21,23] *}\n+\n+이 예제에서, `generate_html_response()` 함수는 HTML을 `str`로 반환하는 대신 이미 `Response`를 생헝하고 반환합니다.\n+\n+`generate_html_response()`를 호출한 결과를 반환함으로써, 기본적인 **FastAPI** 기본 동작을 재정의 하는 `Response`를 이미 반환하고 있습니다.\n+\n+하지만 `response_class`에 `HTMLResponse`를 함께 전달했기 때문에, FastAPI는 이를 OpenAPI 및 대화형 문서에서 `text/html`로 HTML을 문서화 하는 방법을 알 수 있습니다.\n+\n+<img src=\"/img/tutorial/custom-response/image01.png\">\n+\n+## 사용 가능한 응답들\n+\n+다음은 사용할 수 있는 몇가지 응답들 입니다.\n+\n+`Response`를 사용하여 다른 어떤 것도 반환 할수 있으며, 직접 하위 클래스를 만들 수도 있습니다.\n+\n+/// note | 기술 세부사항\n+\n+`from starlette.responses import HTMLResponse`를 사용할 수도 있습니다.\n+\n+**FastAPI**는 개발자인 여러분의 편의를 위해 `starlette.responses`를 `fastapi.responses`로 제공 하지만, 대부분의 사용 가능한 응답은 Starlette에서 직접 가져옵니다.\n+\n+///\n+\n+### `Response`\n+\n+기본 `Response` 클래스는 다른 모든 응답 클래스의 부모 클래스 입니다.\n+\n+이 클래스를 직접 반환할 수 있습니다.\n+\n+다음 매개변수를 받을 수 있습니다:\n+\n+* `content` - `str` 또는 `bytes`.\n+* `status_code` - HTTP 상태코드를 나타내는  `int`.\n+* `headers` - 문자열로 이루어진 `dict`.\n+* `media_type` - 미디어 타입을 나타내는 `str` 예: `\"text/html\"`.\n+\n+FastAPI (실제로는 Starlette)가 자동으로 `Content-Length` 헤더를 포함시킵니다. 또한 `media_type`에 기반하여 `Content-Type` 헤더를 포함하며, 텍스트 타입의 경우 문자 집합을 추가 합니다.\n+\n+{* ../../docs_src/response_directly/tutorial002.py hl[1,18] *}\n+\n+### `HTMLResponse`\n+\n+텍스트 또는 바이트를 받아 HTML 응답을 반환합니다. 위에서 설명한 내용과 같습니다.\n+\n+### `PlainTextResponse`\n+\n+텍스트 또는 바이트를 받아 일반 텍스트 응답을 반환합니다.\n+\n+{* ../../docs_src/custom_response/tutorial005.py hl[2,7,9] *}\n+\n+### `JSONResponse`\n+\n+데이터를 받아 `application/json`으로 인코딩된 응답을 반환합니다.\n+\n+이는 위에서 설명했듯이 **FastAPI**에서 기본적으로 사용되는 응답 형식입니다.\n+\n+### `ORJSONResponse`\n+\n+ <a href=\"https://github.com/ijl/orjson\" class=\"external-link\" target=\"_blank\">`orjson`</a>을 사용하여 빠른 JSON 응답을 제공하는 대안입니다. 위에서 설명한 내용과 같습니다.\n+\n+/// info | 정보\n+\n+이를 사용하려면 `orjson`을 설치해야합니다. 예: `pip install orjson`.\n+\n+///\n+\n+### `UJSONResponse`\n+\n+<a href=\"https://github.com/ultrajson/ultrajson\" class=\"external-link\" target=\"_blank\">`ujson`</a>을 사용한 또 다른 JSON 응답 형식입니다.\n+\n+/// info | 정보\n+\n+이 응답을 사용하려면 `ujson`을 설치해야합니다. 예: 'pip install ujson`.\n+\n+///\n+\n+/// warning | 경고\n+\n+`ujson` 은 Python 내장 구현보다 일부 예외 경우를 처리하는 데 있어 덜 엄격합니다.\n+\n+///\n+\n+{* ../../docs_src/custom_response/tutorial001.py hl[2,7] *}\n+\n+/// tip | 팁\n+\n+`ORJSONResponse`가 더 빠른 대안일 가능성이 있습니다.\n+\n+///\n+\n+### `RedirectResponse`\n+\n+HTTP 리디렉션 응답을 반환합니다. 기본적으로 상태 코드는 307(임시 리디렉션)으로 설정됩니다.\n+\n+`RedirectResponse`를 직접 반환할 수 있습니다.\n+\n+{* ../../docs_src/custom_response/tutorial006.py hl[2,9] *}\n+\n+---\n+\n+또는 `response_class` 매개변수에서 사용할 수도 있습니다:\n+\n+\n+{* ../../docs_src/custom_response/tutorial006b.py hl[2,7,9] *}\n+\n+이 경우, *경로 작업* 함수에서 URL을 직접 반환할 수 있습니다.\n+\n+이 경우, 사용되는 `status_code`는 `RedirectResponse`의 기본값인 `307` 입니다.\n+\n+---\n+\n+`status_code` 매개변수를 `response_class` 매개변수와 함께 사용할 수도 있습니다:\n+\n+{* ../../docs_src/custom_response/tutorial006c.py hl[2,7,9] *}\n+\n+### `StreamingResponse`\n+\n+비동기 생성기 또는 일반 생성기/이터레이터를 받아 응답 본문을 스트리밍 합니다.\n+\n+{* ../../docs_src/custom_response/tutorial007.py hl[2,14] *}\n+\n+#### 파일과 같은 객체를 사용한 `StreamingResponse`\n+\n+파일과 같은 객체(예: `open()`으로 반환된 객체)가 있는 경우, 해당 파일과 같은 객체를 반복(iterate)하는 생성기 함수를 만들 수 있습니다.",
    "repo_full_name": "fastapi/fastapi",
    "discussion_comments": [
      {
        "comment_id": "1953079269",
        "repo_full_name": "fastapi/fastapi",
        "pr_number": 13265,
        "pr_file": "docs/ko/docs/advanced/custom-response.md",
        "discussion_id": "1953079269",
        "commented_code": "@@ -0,0 +1,313 @@\n+# 사용자 정의 응답 - HTML, Stream, 파일, 기타\n+\n+기본적으로, **FastAPI** 응답을 `JSONResponse`를 사용하여 반환합니다.\n+\n+이를 재정의 하려면 [응답을 직접 반환하기](response-directly.md){.internal-link target=_blank}에서 본 것처럼 `Response`를 직접 반환하면 됩니다.\n+\n+그러나 `Response` (또는 `JSONResponse`와 같은 하위 클래스)를 직접 반환하면, 데이터가 자동으로 변환되지 않으며 (심지어 `response_model`을 선언했더라도), 문서화가 자동으로 생성되지 않습니다(예를 들어, 생성된 OpenAPI의 일부로 HTTP 헤더 `Content-Type`에 특정 \"미디어 타입\"을 포함하는 경우).\n+\n+하지만 *경로 작업 데코레이터*에서 `response_class` 매개변수를 사용하여 원하는 `Response`(예: 모든 `Response` 하위 클래스)를 선언할 수도 있습니다.\n+\n+*경로 작업 함수*에서 반환하는 내용은 해당 `Response`안에 포함됩니다.\n+\n+그리고 만약 그 `Response`가 `JSONResponse`와 `UJSONResponse`의 경우 처럼 JSON 미디어 타입(`application/json`)을 가지고 있다면, *경로 작업 데코레이터*에서 선언한 Pydantic의 `response_model`을 사용해 자동으로 변환(및 필터링) 됩니다.\n+\n+/// note | 참고\n+\n+미디어 타입이 없는 응답 클래스를 사용하는 경우, FastAPI는 응답에 내용이 없을 것으로 예상하므로 생성된 OpenAPI 문서에서 응답 형식을 문서화하지 않습니다.\n+\n+///\n+\n+## `ORJSONResponse` 사용하기\n+\n+예를 들어, 성능을 극대화하려는 경우, <a href=\"https://github.com/ijl/orjson\" class=\"external-link\" target=\"_blank\">orjson</a>을 설치하여 사용하고 응답을 `ORJSONResponse`로 설정할 수 있습니다.\n+\n+사용하고자 하는 `Response` 클래스(하위 클래스)를 임포트한 후, **경로 작업 데코레이터*에서 선언하세요.\n+\n+대규모 응답의 경우, 사전을 반환하는 것보다 `Response`를 반환하는 것이 훨씬 빠릅니다.\n+\n+이유는 기본적으로, FastAPI가 내부의 모든 항목을 검사하고 JSON으로 직렬화할 수 있는지 확인하기 때문입니다. 이는 사용자 안내서에서 설명된 [JSON 호환 가능 인코더](../tutorial/encoder.md){.internal-link target=_blank}를 사용하는 방식과 동일합니다. 이를 통해 데이터베이스 모델과 같은 **임의의 객체**를 반환할 수 있습니다.\n+\n+하지만 반환하는 내용이 **JSON으로 직렬화 가능**하다고 확신하는 경우, 해당 내용을 응답 클래스에 직접 전달할 수 있으며, FastAPI가 반환 내용을 `jsonable_encoder`를 통해 처리한 뒤 응답 클래스에 전달하는 오버헤드를 피할 수 있습니다.\n+\n+{* ../../docs_src/custom_response/tutorial001b.py hl[2,7] *}\n+\n+/// info | 정보\n+\n+`response_class` 매개변수는 응답의 \"미디어 타입\"을 정의하는 데에도 사용됩니다.\n+\n+이 경우, HTTP 헤더 `Content-Type`은 `application/json`으로 설정됩니다.\n+\n+그리고 이는 OpenAPI에 그대로 문서화됩니다.\n+\n+///\n+\n+/// tip | 팁\n+\n+`ORJSONResponse`는 FastAPI에서만 사용할 수 있고 Starlette에서는 사용할 수 없습니다.\n+\n+///\n+\n+## HTML 응답\n+\n+**FastAPI**에서 HTML 응답을 직접 반환하려면 `HTMLResponse`를 사용하세요.\n+\n+* `HTMLResponse`를 임포트 합니다.\n+* *경로 작업 데코레이터*의 `response_class` 매개변수로 `HTMLResponse`를 전달합니다.\n+\n+{* ../../docs_src/custom_response/tutorial002.py hl[2,7] *}\n+\n+/// info | 정보\n+\n+`response_class` 매개변수는 응답의 \"미디어 타입\"을 정의하는 데에도 사용됩니다.\n+\n+이 경우, HTTP 헤더 `Content-Type`은 `text/html`로 설정됩니다.\n+\n+그리고 이는 OpenAPI에 그대로 문서화 됩니다.\n+\n+///\n+\n+### `Response` 반환하기\n+\n+[응답을 직접 반환하기](response-directly.md){.internal-link target=_blank}에서 본 것 처럼, *경로 작업*에서 응답을 직접 반환하여 재정의할 수도 있습니다.\n+\n+위의 예제와 동일하게 `HTMLResponse`를 반환하는 코드는 다음과 같을 수 있습니다:\n+\n+{* ../../docs_src/custom_response/tutorial003.py hl[2,7,19] *}\n+\n+/// warning | 경고\n+\n+*경로 작업 함수*에서 직접 반환된 `Response`는 OpenAPI에 문서화되지 않습니다(예를들어, `Content-Type`이 문서화되지 않음) 자동 대화형 문서에서도 표시되지 않습니다.\n+\n+///\n+\n+/// info | 정보\n+\n+물론 실제 `Content-Type` 헤더, 상태 코드 등은 반환된 `Response` 객체에서 가져옵니다.\n+\n+///\n+\n+### OpenAPI에 문서화하고 `Response` 재정의 하기\n+\n+함수 내부에서 응답을 재정의하면서 동시에 OpenAPI에서 \"미디어 타입\"을 문서화하고 싶다면, `response_class` 매게변수를 사용하면서 `Response` 객체를 반환할 수 있습니다.\n+\n+이 경우 `response_class`는 OpenAPI *경로 작업*을 문서화하는 데만 사용되고, 실제로는 여러분이 반환한 `Response`가 그대로 사용됩니다.\n+\n+### `HTMLResponse`직접 반환하기\n+\n+예를 들어, 다음과 같이 작성할 수 있습니다:\n+\n+{* ../../docs_src/custom_response/tutorial004.py hl[7,21,23] *}\n+\n+이 예제에서, `generate_html_response()` 함수는 HTML을 `str`로 반환하는 대신 이미 `Response`를 생헝하고 반환합니다.\n+\n+`generate_html_response()`를 호출한 결과를 반환함으로써, 기본적인 **FastAPI** 기본 동작을 재정의 하는 `Response`를 이미 반환하고 있습니다.\n+\n+하지만 `response_class`에 `HTMLResponse`를 함께 전달했기 때문에, FastAPI는 이를 OpenAPI 및 대화형 문서에서 `text/html`로 HTML을 문서화 하는 방법을 알 수 있습니다.\n+\n+<img src=\"/img/tutorial/custom-response/image01.png\">\n+\n+## 사용 가능한 응답들\n+\n+다음은 사용할 수 있는 몇가지 응답들 입니다.\n+\n+`Response`를 사용하여 다른 어떤 것도 반환 할수 있으며, 직접 하위 클래스를 만들 수도 있습니다.\n+\n+/// note | 기술 세부사항\n+\n+`from starlette.responses import HTMLResponse`를 사용할 수도 있습니다.\n+\n+**FastAPI**는 개발자인 여러분의 편의를 위해 `starlette.responses`를 `fastapi.responses`로 제공 하지만, 대부분의 사용 가능한 응답은 Starlette에서 직접 가져옵니다.\n+\n+///\n+\n+### `Response`\n+\n+기본 `Response` 클래스는 다른 모든 응답 클래스의 부모 클래스 입니다.\n+\n+이 클래스를 직접 반환할 수 있습니다.\n+\n+다음 매개변수를 받을 수 있습니다:\n+\n+* `content` - `str` 또는 `bytes`.\n+* `status_code` - HTTP 상태코드를 나타내는  `int`.\n+* `headers` - 문자열로 이루어진 `dict`.\n+* `media_type` - 미디어 타입을 나타내는 `str` 예: `\"text/html\"`.\n+\n+FastAPI (실제로는 Starlette)가 자동으로 `Content-Length` 헤더를 포함시킵니다. 또한 `media_type`에 기반하여 `Content-Type` 헤더를 포함하며, 텍스트 타입의 경우 문자 집합을 추가 합니다.\n+\n+{* ../../docs_src/response_directly/tutorial002.py hl[1,18] *}\n+\n+### `HTMLResponse`\n+\n+텍스트 또는 바이트를 받아 HTML 응답을 반환합니다. 위에서 설명한 내용과 같습니다.\n+\n+### `PlainTextResponse`\n+\n+텍스트 또는 바이트를 받아 일반 텍스트 응답을 반환합니다.\n+\n+{* ../../docs_src/custom_response/tutorial005.py hl[2,7,9] *}\n+\n+### `JSONResponse`\n+\n+데이터를 받아 `application/json`으로 인코딩된 응답을 반환합니다.\n+\n+이는 위에서 설명했듯이 **FastAPI**에서 기본적으로 사용되는 응답 형식입니다.\n+\n+### `ORJSONResponse`\n+\n+ <a href=\"https://github.com/ijl/orjson\" class=\"external-link\" target=\"_blank\">`orjson`</a>을 사용하여 빠른 JSON 응답을 제공하는 대안입니다. 위에서 설명한 내용과 같습니다.\n+\n+/// info | 정보\n+\n+이를 사용하려면 `orjson`을 설치해야합니다. 예: `pip install orjson`.\n+\n+///\n+\n+### `UJSONResponse`\n+\n+<a href=\"https://github.com/ultrajson/ultrajson\" class=\"external-link\" target=\"_blank\">`ujson`</a>을 사용한 또 다른 JSON 응답 형식입니다.\n+\n+/// info | 정보\n+\n+이 응답을 사용하려면 `ujson`을 설치해야합니다. 예: 'pip install ujson`.\n+\n+///\n+\n+/// warning | 경고\n+\n+`ujson` 은 Python 내장 구현보다 일부 예외 경우를 처리하는 데 있어 덜 엄격합니다.\n+\n+///\n+\n+{* ../../docs_src/custom_response/tutorial001.py hl[2,7] *}\n+\n+/// tip | 팁\n+\n+`ORJSONResponse`가 더 빠른 대안일 가능성이 있습니다.\n+\n+///\n+\n+### `RedirectResponse`\n+\n+HTTP 리디렉션 응답을 반환합니다. 기본적으로 상태 코드는 307(임시 리디렉션)으로 설정됩니다.\n+\n+`RedirectResponse`를 직접 반환할 수 있습니다.\n+\n+{* ../../docs_src/custom_response/tutorial006.py hl[2,9] *}\n+\n+---\n+\n+또는 `response_class` 매개변수에서 사용할 수도 있습니다:\n+\n+\n+{* ../../docs_src/custom_response/tutorial006b.py hl[2,7,9] *}\n+\n+이 경우, *경로 작업* 함수에서 URL을 직접 반환할 수 있습니다.\n+\n+이 경우, 사용되는 `status_code`는 `RedirectResponse`의 기본값인 `307` 입니다.\n+\n+---\n+\n+`status_code` 매개변수를 `response_class` 매개변수와 함께 사용할 수도 있습니다:\n+\n+{* ../../docs_src/custom_response/tutorial006c.py hl[2,7,9] *}\n+\n+### `StreamingResponse`\n+\n+비동기 생성기 또는 일반 생성기/이터레이터를 받아 응답 본문을 스트리밍 합니다.\n+\n+{* ../../docs_src/custom_response/tutorial007.py hl[2,14] *}\n+\n+#### 파일과 같은 객체를 사용한 `StreamingResponse`\n+\n+파일과 같은 객체(예: `open()`으로 반환된 객체)가 있는 경우, 해당 파일과 같은 객체를 반복(iterate)하는 생성기 함수를 만들 수 있습니다.",
        "comment_created_at": "2025-02-12T17:09:20+00:00",
        "comment_author": "yes0ng",
        "comment_body": "```suggestion\r\n파일과 같은 객체(예: `open()`으로 반환된 객체)가 있는 경우, 해당 파일과 같은 객체를 반복(iterate)하는 제너레이터 함수를 만들 수 있습니다.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]