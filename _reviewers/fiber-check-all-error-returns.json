[
  {
    "discussion_id": "2101497102",
    "pr_number": 3467,
    "pr_file": "middleware/proxy/proxy_test.go",
    "created_at": "2025-05-22T02:40:31+00:00",
    "commented_code": "return createProxyTestServer(t, handler, fiber.NetworkTCP6, \"[::1]:0\")\n }\n \n+func createRedirectServer(t *testing.T) (*fiber.App, string) {\n+\tt.Helper()\n+\tapp := fiber.New()\n+\n+\tvar addr string\n+\tapp.Get(\"/\", func(c fiber.Ctx) error {\n+\t\tc.Location(\"http://\" + addr + \"/final\")\n+\t\treturn c.Status(fiber.StatusMovedPermanently).SendString(\"redirect\")\n+\t})\n+\tapp.Get(\"/final\", func(c fiber.Ctx) error {\n+\t\treturn c.SendString(\"final\")\n+\t})\n+\n+\tln, err := net.Listen(fiber.NetworkTCP4, \"127.0.0.1:0\")\n+\trequire.NoError(t, err)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "2101511514",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3467,
        "pr_file": "middleware/proxy/proxy_test.go",
        "discussion_id": "2101497102",
        "commented_code": "@@ -55,6 +55,28 @@ func createProxyTestServerIPv6(t *testing.T, handler fiber.Handler) (*fiber.App,\n \treturn createProxyTestServer(t, handler, fiber.NetworkTCP6, \"[::1]:0\")\n }\n \n+func createRedirectServer(t *testing.T) (*fiber.App, string) {\n+\tt.Helper()\n+\tapp := fiber.New()\n+\n+\tvar addr string\n+\tapp.Get(\"/\", func(c fiber.Ctx) error {\n+\t\tc.Location(\"http://\" + addr + \"/final\")\n+\t\treturn c.Status(fiber.StatusMovedPermanently).SendString(\"redirect\")\n+\t})\n+\tapp.Get(\"/final\", func(c fiber.Ctx) error {\n+\t\treturn c.SendString(\"final\")\n+\t})\n+\n+\tln, err := net.Listen(fiber.NetworkTCP4, \"127.0.0.1:0\")\n+\trequire.NoError(t, err)",
        "comment_created_at": "2025-05-22T02:40:31+00:00",
        "comment_author": "gaby",
        "comment_body": "@copilot the error code from ln.Close() needs to be check",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1899516073",
    "pr_number": 3235,
    "pr_file": "binder/mapping.go",
    "created_at": "2024-12-30T12:36:28+00:00",
    "commented_code": "}\n \treturn content\n }\n+\n+func formatBindData(out any, data map[string][]string, key, value string, enableSplitting, supportBracketNotation bool) error { //nolint:revive // it's okay\n+\tvar err error\n+\tif supportBracketNotation && strings.Contains(key, \"[\") {\n+\t\tkey, err = parseParamSquareBrackets(key)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1899516073",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3235,
        "pr_file": "binder/mapping.go",
        "discussion_id": "1899516073",
        "commented_code": "@@ -249,3 +249,21 @@ func FilterFlags(content string) string {\n \t}\n \treturn content\n }\n+\n+func formatBindData(out any, data map[string][]string, key, value string, enableSplitting, supportBracketNotation bool) error { //nolint:revive // it's okay\n+\tvar err error\n+\tif supportBracketNotation && strings.Contains(key, \"[\") {\n+\t\tkey, err = parseParamSquareBrackets(key)",
        "comment_created_at": "2024-12-30T12:36:28+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "add early error return, otherwise it do the rest ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1619785319",
    "pr_number": 3016,
    "pr_file": "middleware/csrf/session_manager.go",
    "created_at": "2024-05-30T03:12:29+00:00",
    "commented_code": "// get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {\n-\tsess, err := m.session.Get(c)\n-\tif err != nil {\n-\t\treturn nil\n+\tsess := session.FromContext(c)\n+\tvar token Token\n+\tvar ok bool\n+\n+\tif sess != nil {\n+\t\ttoken, ok = sess.Get(m.key).(Token)\n+\t} else {\n+\t\t// Try to get the session from the store\n+\t\tstoreSess, err := m.session.Get(c)\n+\t\tif err != nil {\n+\t\t\t// Handle error\n+\t\t\treturn nil\n+\t\t}",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1619785319",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1619785319",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {\n-\tsess, err := m.session.Get(c)\n-\tif err != nil {\n-\t\treturn nil\n+\tsess := session.FromContext(c)\n+\tvar token Token\n+\tvar ok bool\n+\n+\tif sess != nil {\n+\t\ttoken, ok = sess.Get(m.key).(Token)\n+\t} else {\n+\t\t// Try to get the session from the store\n+\t\tstoreSess, err := m.session.Get(c)\n+\t\tif err != nil {\n+\t\t\t// Handle error\n+\t\t\treturn nil\n+\t\t}",
        "comment_created_at": "2024-05-30T03:12:29+00:00",
        "comment_author": "renanbastos93",
        "comment_body": "sounds not so good. Why do you ignore error?",
        "pr_file_module": null
      },
      {
        "comment_id": "1621102385",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1619785319",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {\n-\tsess, err := m.session.Get(c)\n-\tif err != nil {\n-\t\treturn nil\n+\tsess := session.FromContext(c)\n+\tvar token Token\n+\tvar ok bool\n+\n+\tif sess != nil {\n+\t\ttoken, ok = sess.Get(m.key).(Token)\n+\t} else {\n+\t\t// Try to get the session from the store\n+\t\tstoreSess, err := m.session.Get(c)\n+\t\tif err != nil {\n+\t\t\t// Handle error\n+\t\t\treturn nil\n+\t\t}",
        "comment_created_at": "2024-05-30T17:02:35+00:00",
        "comment_author": "sixcolors",
        "comment_body": "The CSRF middleware lacks a mechanism to handle that error beyond failing the CSRF check. A refactor of the CSRF middleware would be necessary to address this issue.",
        "pr_file_module": null
      },
      {
        "comment_id": "1621204685",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1619785319",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {\n-\tsess, err := m.session.Get(c)\n-\tif err != nil {\n-\t\treturn nil\n+\tsess := session.FromContext(c)\n+\tvar token Token\n+\tvar ok bool\n+\n+\tif sess != nil {\n+\t\ttoken, ok = sess.Get(m.key).(Token)\n+\t} else {\n+\t\t// Try to get the session from the store\n+\t\tstoreSess, err := m.session.Get(c)\n+\t\tif err != nil {\n+\t\t\t// Handle error\n+\t\t\treturn nil\n+\t\t}",
        "comment_created_at": "2024-05-30T17:48:13+00:00",
        "comment_author": "renanbastos93",
        "comment_body": "It's okay, can you open this issue for us?",
        "pr_file_module": null
      },
      {
        "comment_id": "1621208717",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1619785319",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {\n-\tsess, err := m.session.Get(c)\n-\tif err != nil {\n-\t\treturn nil\n+\tsess := session.FromContext(c)\n+\tvar token Token\n+\tvar ok bool\n+\n+\tif sess != nil {\n+\t\ttoken, ok = sess.Get(m.key).(Token)\n+\t} else {\n+\t\t// Try to get the session from the store\n+\t\tstoreSess, err := m.session.Get(c)\n+\t\tif err != nil {\n+\t\t\t// Handle error\n+\t\t\treturn nil\n+\t\t}",
        "comment_created_at": "2024-05-30T17:52:11+00:00",
        "comment_author": "sixcolors",
        "comment_body": "@coderabbitai open an issue to improve error handling in the middleware/csrf/session_manager.go and middleware/csrf/storage_manager.go files as discussed here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1621436662",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1619785319",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {\n-\tsess, err := m.session.Get(c)\n-\tif err != nil {\n-\t\treturn nil\n+\tsess := session.FromContext(c)\n+\tvar token Token\n+\tvar ok bool\n+\n+\tif sess != nil {\n+\t\ttoken, ok = sess.Get(m.key).(Token)\n+\t} else {\n+\t\t// Try to get the session from the store\n+\t\tstoreSess, err := m.session.Get(c)\n+\t\tif err != nil {\n+\t\t\t// Handle error\n+\t\t\treturn nil\n+\t\t}",
        "comment_created_at": "2024-05-30T21:14:16+00:00",
        "comment_author": "renanbastos93",
        "comment_body": "@sixcolors https://github.com/gofiber/fiber/pull/3021",
        "pr_file_module": null
      },
      {
        "comment_id": "1621705952",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1619785319",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {\n-\tsess, err := m.session.Get(c)\n-\tif err != nil {\n-\t\treturn nil\n+\tsess := session.FromContext(c)\n+\tvar token Token\n+\tvar ok bool\n+\n+\tif sess != nil {\n+\t\ttoken, ok = sess.Get(m.key).(Token)\n+\t} else {\n+\t\t// Try to get the session from the store\n+\t\tstoreSess, err := m.session.Get(c)\n+\t\tif err != nil {\n+\t\t\t// Handle error\n+\t\t\treturn nil\n+\t\t}",
        "comment_created_at": "2024-05-31T04:46:08+00:00",
        "comment_author": "sixcolors",
        "comment_body": "> @sixcolors #3021\r\n\r\nI\u2019ll take a look tomorrow ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460947828",
    "pr_number": 1986,
    "pr_file": "client/client.go",
    "created_at": "2024-01-21T15:29:15+00:00",
    "commented_code": "+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1460947828",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 1986,
        "pr_file": "client/client.go",
        "discussion_id": "1460947828",
        "commented_code": "@@ -0,0 +1,768 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c",
        "comment_created_at": "2024-01-21T15:29:15+00:00",
        "comment_author": "gaby",
        "comment_body": "We should log the error here and return the error not the client without a CA set",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460956804",
    "pr_number": 1986,
    "pr_file": "client/client.go",
    "created_at": "2024-01-21T15:47:18+00:00",
    "commented_code": "+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\tdefer func() {\n+\t\t_ = file.Close() //nolint:errcheck // It is fine to ignore the error here\n+\t}()\n+\tpem, err := io.ReadAll(file)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\n+\tconfig := c.TLSConfig()\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM(pem)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1460956804",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 1986,
        "pr_file": "client/client.go",
        "discussion_id": "1460956804",
        "commented_code": "@@ -0,0 +1,768 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\tdefer func() {\n+\t\t_ = file.Close() //nolint:errcheck // It is fine to ignore the error here\n+\t}()\n+\tpem, err := io.ReadAll(file)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\n+\tconfig := c.TLSConfig()\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM(pem)",
        "comment_created_at": "2024-01-21T15:47:18+00:00",
        "comment_author": "gaby",
        "comment_body": "Missing error check:\r\n\r\n```\r\nif !config.RootCAs.AppendCertsFromPEM(certData) {\r\n    return errors.New(\"failed to append certificate\")\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460956892",
    "pr_number": 1986,
    "pr_file": "client/client.go",
    "created_at": "2024-01-21T15:47:26+00:00",
    "commented_code": "+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\tdefer func() {\n+\t\t_ = file.Close() //nolint:errcheck // It is fine to ignore the error here\n+\t}()\n+\tpem, err := io.ReadAll(file)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\n+\tconfig := c.TLSConfig()\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM(pem)\n+\n+\treturn c\n+}\n+\n+// SetRootCertificateFromString method adds one or more root certificates into client.\n+func (c *Client) SetRootCertificateFromString(pem string) *Client {\n+\tconfig := c.TLSConfig()\n+\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM([]byte(pem))",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1460956892",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 1986,
        "pr_file": "client/client.go",
        "discussion_id": "1460956892",
        "commented_code": "@@ -0,0 +1,768 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\tdefer func() {\n+\t\t_ = file.Close() //nolint:errcheck // It is fine to ignore the error here\n+\t}()\n+\tpem, err := io.ReadAll(file)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\n+\tconfig := c.TLSConfig()\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM(pem)\n+\n+\treturn c\n+}\n+\n+// SetRootCertificateFromString method adds one or more root certificates into client.\n+func (c *Client) SetRootCertificateFromString(pem string) *Client {\n+\tconfig := c.TLSConfig()\n+\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM([]byte(pem))",
        "comment_created_at": "2024-01-21T15:47:26+00:00",
        "comment_author": "gaby",
        "comment_body": "Missing error check:\r\n\r\n```\r\nif !config.RootCAs.AppendCertsFromPEM(certData) {\r\n    return errors.New(\"failed to append certificate\")\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1125463239",
    "pr_number": 2340,
    "pr_file": "utils/http_test.go",
    "created_at": "2023-03-04T13:15:41+00:00",
    "commented_code": "res = GetMIME(\"unknown\")\n \tAssertEqual(t, MIMEOctetStream, res)\n+\n+\tif err := mime.AddExtensionType(\".mjs\", \"application/javascript\"); err == nil {\n+\t\tres = GetMIME(\".mjs\")\n+\t\tAssertEqual(t, \"application/javascript\", res)\n+\t} else {\n+\t\tt.Logf(\"failed to add extension type, err: %v\", err)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1125463239",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2340,
        "pr_file": "utils/http_test.go",
        "discussion_id": "1125463239",
        "commented_code": "@@ -23,6 +23,14 @@ func Test_GetMIME(t *testing.T) {\n \n \tres = GetMIME(\"unknown\")\n \tAssertEqual(t, MIMEOctetStream, res)\n+\n+\tif err := mime.AddExtensionType(\".mjs\", \"application/javascript\"); err == nil {\n+\t\tres = GetMIME(\".mjs\")\n+\t\tAssertEqual(t, \"application/javascript\", res)\n+\t} else {\n+\t\tt.Logf(\"failed to add extension type, err: %v\", err)",
        "comment_created_at": "2023-03-04T13:15:41+00:00",
        "comment_author": "leonklingele",
        "comment_body": "This must also never fail -- use `AssertEqual(t, nil, err)` here instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "1126225700",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2340,
        "pr_file": "utils/http_test.go",
        "discussion_id": "1125463239",
        "commented_code": "@@ -23,6 +23,14 @@ func Test_GetMIME(t *testing.T) {\n \n \tres = GetMIME(\"unknown\")\n \tAssertEqual(t, MIMEOctetStream, res)\n+\n+\tif err := mime.AddExtensionType(\".mjs\", \"application/javascript\"); err == nil {\n+\t\tres = GetMIME(\".mjs\")\n+\t\tAssertEqual(t, \"application/javascript\", res)\n+\t} else {\n+\t\tt.Logf(\"failed to add extension type, err: %v\", err)",
        "comment_created_at": "2023-03-06T10:38:31+00:00",
        "comment_author": "derkan",
        "comment_body": "@leonklingele thanks for reviewing. done",
        "pr_file_module": null
      }
    ]
  }
]