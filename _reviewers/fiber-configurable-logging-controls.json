[
  {
    "discussion_id": "1780003242",
    "pr_number": 3016,
    "pr_file": "middleware/session/middleware.go",
    "created_at": "2024-09-29T09:56:49+00:00",
    "commented_code": "+// Package session provides session management middleware for Fiber.\n+// This middleware handles user sessions, including storing session data in the store.\n+package session\n+\n+import (\n+\t\"errors\"\n+\t\"sync\"\n+\n+\t\"github.com/gofiber/fiber/v3\"\n+\t\"github.com/gofiber/fiber/v3/log\"\n+)\n+\n+// Middleware holds session data and configuration.\n+type Middleware struct {\n+\tSession   *Session\n+\tctx       *fiber.Ctx\n+\tconfig    Config\n+\tmu        sync.RWMutex\n+\tdestroyed bool\n+}\n+\n+// Context key for session middleware lookup.\n+type middlewareKey int\n+\n+const (\n+\t// middlewareContextKey is the key used to store the *Middleware in the context locals.\n+\tmiddlewareContextKey middlewareKey = iota\n+)\n+\n+var (\n+\t// ErrTypeAssertionFailed occurs when a type assertion fails.\n+\tErrTypeAssertionFailed = errors.New(\"failed to type-assert to *Middleware\")\n+\n+\t// Pool for reusing middleware instances.\n+\tmiddlewarePool = &sync.Pool{\n+\t\tNew: func() any {\n+\t\t\treturn &Middleware{}\n+\t\t},\n+\t}\n+)\n+\n+// New initializes session middleware with optional configuration.\n+//\n+// Parameters:\n+//   - config: Variadic parameter to override default config.\n+//\n+// Returns:\n+//   - fiber.Handler: The Fiber handler for the session middleware.\n+//\n+// Usage:\n+//\n+//\tapp.Use(session.New())\n+//\n+// Usage:\n+//\n+//\tapp.Use(session.New())\n+func New(config ...Config) fiber.Handler {\n+\tif len(config) > 0 {\n+\t\thandler, _ := NewWithStore(config[0])\n+\t\treturn handler\n+\t}\n+\thandler, _ := NewWithStore()\n+\treturn handler\n+}\n+\n+// NewWithStore creates session middleware with an optional custom store.\n+//\n+// Parameters:\n+//   - config: Variadic parameter to override default config.\n+//\n+// Returns:\n+//   - fiber.Handler: The Fiber handler for the session middleware.\n+//   - *Store: The session store.\n+//\n+// Usage:\n+//\n+//\thandler, store := session.NewWithStore()\n+func NewWithStore(config ...Config) (fiber.Handler, *Store) {\n+\tcfg := configDefault(config...)\n+\n+\tif cfg.Store == nil {\n+\t\tcfg.Store = NewStore(cfg)\n+\t}\n+\n+\thandler := func(c fiber.Ctx) error {\n+\t\tif cfg.Next != nil && cfg.Next(c) {\n+\t\t\treturn c.Next()\n+\t\t}\n+\n+\t\t// Acquire session middleware\n+\t\tm := acquireMiddleware()\n+\t\tm.initialize(c, cfg)\n+\n+\t\tstackErr := c.Next()\n+\n+\t\tm.mu.RLock()\n+\t\tdestroyed := m.destroyed\n+\t\tm.mu.RUnlock()\n+\n+\t\tif !destroyed {\n+\t\t\tm.saveSession()\n+\t\t}\n+\n+\t\treleaseMiddleware(m)\n+\t\treturn stackErr\n+\t}\n+\n+\treturn handler, cfg.Store\n+}\n+\n+// initialize sets up middleware for the request.\n+func (m *Middleware) initialize(c fiber.Ctx, cfg Config) {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\n+\tsession, err := cfg.Store.getSession(c)\n+\tif err != nil {\n+\t\tpanic(err) // handle or log this error appropriately in production\n+\t}\n+\n+\tm.config = cfg\n+\tm.Session = session\n+\tm.ctx = &c\n+\n+\tc.Locals(middlewareContextKey, m)\n+}\n+\n+// saveSession handles session saving and error management after the response.\n+func (m *Middleware) saveSession() {\n+\tif err := m.Session.saveSession(); err != nil {\n+\t\tif m.config.ErrorHandler != nil {\n+\t\t\tm.config.ErrorHandler(m.ctx, err)\n+\t\t} else {\n+\t\t\tDefaultErrorHandler(m.ctx, err)\n+\t\t}\n+\t}\n+\n+\treleaseSession(m.Session)\n+}\n+\n+// acquireMiddleware retrieves a middleware instance from the pool.\n+func acquireMiddleware() *Middleware {\n+\tm, ok := middlewarePool.Get().(*Middleware)\n+\tif !ok {\n+\t\tpanic(ErrTypeAssertionFailed.Error())\n+\t}\n+\treturn m\n+}\n+\n+// releaseMiddleware resets and returns middleware to the pool.\n+//\n+// Parameters:\n+//   - m: The middleware object to release.\n+//\n+// Usage:\n+//\n+//\treleaseMiddleware(m)\n+func releaseMiddleware(m *Middleware) {\n+\tm.mu.Lock()\n+\tm.config = Config{}\n+\tm.Session = nil\n+\tm.ctx = nil\n+\tm.destroyed = false\n+\tm.mu.Unlock()\n+\tmiddlewarePool.Put(m)\n+}\n+\n+// FromContext returns the Middleware from the Fiber context.\n+//\n+// Parameters:\n+//   - c: The Fiber context.\n+//\n+// Returns:\n+//   - *Middleware: The middleware object if found, otherwise nil.\n+//\n+// Usage:\n+//\n+//\tm := session.FromContext(c)\n+func FromContext(c fiber.Ctx) *Middleware {\n+\tm, ok := c.Locals(middlewareContextKey).(*Middleware)\n+\tif !ok {\n+\t\t// TODO: since this may be called we may not want to log this except in debug mode?\n+\t\tlog.Warn(\"session: Session middleware not registered. See https://docs.gofiber.io/middleware/session\")",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1780003242",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/session/middleware.go",
        "discussion_id": "1780003242",
        "commented_code": "@@ -0,0 +1,304 @@\n+// Package session provides session management middleware for Fiber.\n+// This middleware handles user sessions, including storing session data in the store.\n+package session\n+\n+import (\n+\t\"errors\"\n+\t\"sync\"\n+\n+\t\"github.com/gofiber/fiber/v3\"\n+\t\"github.com/gofiber/fiber/v3/log\"\n+)\n+\n+// Middleware holds session data and configuration.\n+type Middleware struct {\n+\tSession   *Session\n+\tctx       *fiber.Ctx\n+\tconfig    Config\n+\tmu        sync.RWMutex\n+\tdestroyed bool\n+}\n+\n+// Context key for session middleware lookup.\n+type middlewareKey int\n+\n+const (\n+\t// middlewareContextKey is the key used to store the *Middleware in the context locals.\n+\tmiddlewareContextKey middlewareKey = iota\n+)\n+\n+var (\n+\t// ErrTypeAssertionFailed occurs when a type assertion fails.\n+\tErrTypeAssertionFailed = errors.New(\"failed to type-assert to *Middleware\")\n+\n+\t// Pool for reusing middleware instances.\n+\tmiddlewarePool = &sync.Pool{\n+\t\tNew: func() any {\n+\t\t\treturn &Middleware{}\n+\t\t},\n+\t}\n+)\n+\n+// New initializes session middleware with optional configuration.\n+//\n+// Parameters:\n+//   - config: Variadic parameter to override default config.\n+//\n+// Returns:\n+//   - fiber.Handler: The Fiber handler for the session middleware.\n+//\n+// Usage:\n+//\n+//\tapp.Use(session.New())\n+//\n+// Usage:\n+//\n+//\tapp.Use(session.New())\n+func New(config ...Config) fiber.Handler {\n+\tif len(config) > 0 {\n+\t\thandler, _ := NewWithStore(config[0])\n+\t\treturn handler\n+\t}\n+\thandler, _ := NewWithStore()\n+\treturn handler\n+}\n+\n+// NewWithStore creates session middleware with an optional custom store.\n+//\n+// Parameters:\n+//   - config: Variadic parameter to override default config.\n+//\n+// Returns:\n+//   - fiber.Handler: The Fiber handler for the session middleware.\n+//   - *Store: The session store.\n+//\n+// Usage:\n+//\n+//\thandler, store := session.NewWithStore()\n+func NewWithStore(config ...Config) (fiber.Handler, *Store) {\n+\tcfg := configDefault(config...)\n+\n+\tif cfg.Store == nil {\n+\t\tcfg.Store = NewStore(cfg)\n+\t}\n+\n+\thandler := func(c fiber.Ctx) error {\n+\t\tif cfg.Next != nil && cfg.Next(c) {\n+\t\t\treturn c.Next()\n+\t\t}\n+\n+\t\t// Acquire session middleware\n+\t\tm := acquireMiddleware()\n+\t\tm.initialize(c, cfg)\n+\n+\t\tstackErr := c.Next()\n+\n+\t\tm.mu.RLock()\n+\t\tdestroyed := m.destroyed\n+\t\tm.mu.RUnlock()\n+\n+\t\tif !destroyed {\n+\t\t\tm.saveSession()\n+\t\t}\n+\n+\t\treleaseMiddleware(m)\n+\t\treturn stackErr\n+\t}\n+\n+\treturn handler, cfg.Store\n+}\n+\n+// initialize sets up middleware for the request.\n+func (m *Middleware) initialize(c fiber.Ctx, cfg Config) {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\n+\tsession, err := cfg.Store.getSession(c)\n+\tif err != nil {\n+\t\tpanic(err) // handle or log this error appropriately in production\n+\t}\n+\n+\tm.config = cfg\n+\tm.Session = session\n+\tm.ctx = &c\n+\n+\tc.Locals(middlewareContextKey, m)\n+}\n+\n+// saveSession handles session saving and error management after the response.\n+func (m *Middleware) saveSession() {\n+\tif err := m.Session.saveSession(); err != nil {\n+\t\tif m.config.ErrorHandler != nil {\n+\t\t\tm.config.ErrorHandler(m.ctx, err)\n+\t\t} else {\n+\t\t\tDefaultErrorHandler(m.ctx, err)\n+\t\t}\n+\t}\n+\n+\treleaseSession(m.Session)\n+}\n+\n+// acquireMiddleware retrieves a middleware instance from the pool.\n+func acquireMiddleware() *Middleware {\n+\tm, ok := middlewarePool.Get().(*Middleware)\n+\tif !ok {\n+\t\tpanic(ErrTypeAssertionFailed.Error())\n+\t}\n+\treturn m\n+}\n+\n+// releaseMiddleware resets and returns middleware to the pool.\n+//\n+// Parameters:\n+//   - m: The middleware object to release.\n+//\n+// Usage:\n+//\n+//\treleaseMiddleware(m)\n+func releaseMiddleware(m *Middleware) {\n+\tm.mu.Lock()\n+\tm.config = Config{}\n+\tm.Session = nil\n+\tm.ctx = nil\n+\tm.destroyed = false\n+\tm.mu.Unlock()\n+\tmiddlewarePool.Put(m)\n+}\n+\n+// FromContext returns the Middleware from the Fiber context.\n+//\n+// Parameters:\n+//   - c: The Fiber context.\n+//\n+// Returns:\n+//   - *Middleware: The middleware object if found, otherwise nil.\n+//\n+// Usage:\n+//\n+//\tm := session.FromContext(c)\n+func FromContext(c fiber.Ctx) *Middleware {\n+\tm, ok := c.Locals(middlewareContextKey).(*Middleware)\n+\tif !ok {\n+\t\t// TODO: since this may be called we may not want to log this except in debug mode?\n+\t\tlog.Warn(\"session: Session middleware not registered. See https://docs.gofiber.io/middleware/session\")",
        "comment_created_at": "2024-09-29T09:56:49+00:00",
        "comment_author": "efectn",
        "comment_body": "I think the log is useful. Anyway, it might be still worth to add a config field to enable/disable logging",
        "pr_file_module": null
      },
      {
        "comment_id": "1782970504",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/session/middleware.go",
        "discussion_id": "1780003242",
        "commented_code": "@@ -0,0 +1,304 @@\n+// Package session provides session management middleware for Fiber.\n+// This middleware handles user sessions, including storing session data in the store.\n+package session\n+\n+import (\n+\t\"errors\"\n+\t\"sync\"\n+\n+\t\"github.com/gofiber/fiber/v3\"\n+\t\"github.com/gofiber/fiber/v3/log\"\n+)\n+\n+// Middleware holds session data and configuration.\n+type Middleware struct {\n+\tSession   *Session\n+\tctx       *fiber.Ctx\n+\tconfig    Config\n+\tmu        sync.RWMutex\n+\tdestroyed bool\n+}\n+\n+// Context key for session middleware lookup.\n+type middlewareKey int\n+\n+const (\n+\t// middlewareContextKey is the key used to store the *Middleware in the context locals.\n+\tmiddlewareContextKey middlewareKey = iota\n+)\n+\n+var (\n+\t// ErrTypeAssertionFailed occurs when a type assertion fails.\n+\tErrTypeAssertionFailed = errors.New(\"failed to type-assert to *Middleware\")\n+\n+\t// Pool for reusing middleware instances.\n+\tmiddlewarePool = &sync.Pool{\n+\t\tNew: func() any {\n+\t\t\treturn &Middleware{}\n+\t\t},\n+\t}\n+)\n+\n+// New initializes session middleware with optional configuration.\n+//\n+// Parameters:\n+//   - config: Variadic parameter to override default config.\n+//\n+// Returns:\n+//   - fiber.Handler: The Fiber handler for the session middleware.\n+//\n+// Usage:\n+//\n+//\tapp.Use(session.New())\n+//\n+// Usage:\n+//\n+//\tapp.Use(session.New())\n+func New(config ...Config) fiber.Handler {\n+\tif len(config) > 0 {\n+\t\thandler, _ := NewWithStore(config[0])\n+\t\treturn handler\n+\t}\n+\thandler, _ := NewWithStore()\n+\treturn handler\n+}\n+\n+// NewWithStore creates session middleware with an optional custom store.\n+//\n+// Parameters:\n+//   - config: Variadic parameter to override default config.\n+//\n+// Returns:\n+//   - fiber.Handler: The Fiber handler for the session middleware.\n+//   - *Store: The session store.\n+//\n+// Usage:\n+//\n+//\thandler, store := session.NewWithStore()\n+func NewWithStore(config ...Config) (fiber.Handler, *Store) {\n+\tcfg := configDefault(config...)\n+\n+\tif cfg.Store == nil {\n+\t\tcfg.Store = NewStore(cfg)\n+\t}\n+\n+\thandler := func(c fiber.Ctx) error {\n+\t\tif cfg.Next != nil && cfg.Next(c) {\n+\t\t\treturn c.Next()\n+\t\t}\n+\n+\t\t// Acquire session middleware\n+\t\tm := acquireMiddleware()\n+\t\tm.initialize(c, cfg)\n+\n+\t\tstackErr := c.Next()\n+\n+\t\tm.mu.RLock()\n+\t\tdestroyed := m.destroyed\n+\t\tm.mu.RUnlock()\n+\n+\t\tif !destroyed {\n+\t\t\tm.saveSession()\n+\t\t}\n+\n+\t\treleaseMiddleware(m)\n+\t\treturn stackErr\n+\t}\n+\n+\treturn handler, cfg.Store\n+}\n+\n+// initialize sets up middleware for the request.\n+func (m *Middleware) initialize(c fiber.Ctx, cfg Config) {\n+\tm.mu.Lock()\n+\tdefer m.mu.Unlock()\n+\n+\tsession, err := cfg.Store.getSession(c)\n+\tif err != nil {\n+\t\tpanic(err) // handle or log this error appropriately in production\n+\t}\n+\n+\tm.config = cfg\n+\tm.Session = session\n+\tm.ctx = &c\n+\n+\tc.Locals(middlewareContextKey, m)\n+}\n+\n+// saveSession handles session saving and error management after the response.\n+func (m *Middleware) saveSession() {\n+\tif err := m.Session.saveSession(); err != nil {\n+\t\tif m.config.ErrorHandler != nil {\n+\t\t\tm.config.ErrorHandler(m.ctx, err)\n+\t\t} else {\n+\t\t\tDefaultErrorHandler(m.ctx, err)\n+\t\t}\n+\t}\n+\n+\treleaseSession(m.Session)\n+}\n+\n+// acquireMiddleware retrieves a middleware instance from the pool.\n+func acquireMiddleware() *Middleware {\n+\tm, ok := middlewarePool.Get().(*Middleware)\n+\tif !ok {\n+\t\tpanic(ErrTypeAssertionFailed.Error())\n+\t}\n+\treturn m\n+}\n+\n+// releaseMiddleware resets and returns middleware to the pool.\n+//\n+// Parameters:\n+//   - m: The middleware object to release.\n+//\n+// Usage:\n+//\n+//\treleaseMiddleware(m)\n+func releaseMiddleware(m *Middleware) {\n+\tm.mu.Lock()\n+\tm.config = Config{}\n+\tm.Session = nil\n+\tm.ctx = nil\n+\tm.destroyed = false\n+\tm.mu.Unlock()\n+\tmiddlewarePool.Put(m)\n+}\n+\n+// FromContext returns the Middleware from the Fiber context.\n+//\n+// Parameters:\n+//   - c: The Fiber context.\n+//\n+// Returns:\n+//   - *Middleware: The middleware object if found, otherwise nil.\n+//\n+// Usage:\n+//\n+//\tm := session.FromContext(c)\n+func FromContext(c fiber.Ctx) *Middleware {\n+\tm, ok := c.Locals(middlewareContextKey).(*Middleware)\n+\tif !ok {\n+\t\t// TODO: since this may be called we may not want to log this except in debug mode?\n+\t\tlog.Warn(\"session: Session middleware not registered. See https://docs.gofiber.io/middleware/session\")",
        "comment_created_at": "2024-10-01T14:27:33+00:00",
        "comment_author": "sixcolors",
        "comment_body": "log removed, logic for this: middleware that supports both legacy (Store) session API and Middleware API will need to check this and the log will be misleading and spammy.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1197709023",
    "pr_number": 2469,
    "pr_file": "helpers.go",
    "created_at": "2023-05-18T11:30:31+00:00",
    "commented_code": "\"path/filepath\"\n \t\"reflect\"\n \t\"strings\"\n+\t\"sync\"\n \t\"time\"\n-\t\"unsafe\"\n+\t\"unsafe\" //nolint:depguard // unsafe is used for better performance\n \n \t\"github.com/gofiber/fiber/v2/utils\"\n \n \t\"github.com/valyala/bytebufferpool\"\n \t\"github.com/valyala/fasthttp\"\n )\n \n+// Guards overwrites to os.Stdout and os.Stderr\n+var osStdVarMu sync.RWMutex",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1197709023",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2469,
        "pr_file": "helpers.go",
        "discussion_id": "1197709023",
        "commented_code": "@@ -16,15 +16,19 @@ import (\n \t\"path/filepath\"\n \t\"reflect\"\n \t\"strings\"\n+\t\"sync\"\n \t\"time\"\n-\t\"unsafe\"\n+\t\"unsafe\" //nolint:depguard // unsafe is used for better performance\n \n \t\"github.com/gofiber/fiber/v2/utils\"\n \n \t\"github.com/valyala/bytebufferpool\"\n \t\"github.com/valyala/fasthttp\"\n )\n \n+// Guards overwrites to os.Stdout and os.Stderr\n+var osStdVarMu sync.RWMutex",
        "comment_created_at": "2023-05-18T11:30:31+00:00",
        "comment_author": "leonklingele",
        "comment_body": "I'd love to not use this, but currently required to capture the output to stdout and stderr in two test files.\r\n\r\nInstead of overwriting `os.Stdout` and `os.Stderr`, we should use a proper logging mechanism which doesn't use these two globals.",
        "pr_file_module": null
      }
    ]
  }
]