[
  {
    "discussion_id": "1618163645",
    "pr_number": 3016,
    "pr_file": "middleware/csrf/session_manager.go",
    "created_at": "2024-05-29T04:32:43+00:00",
    "commented_code": "// get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1618163645",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1618163645",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {",
        "comment_created_at": "2024-05-29T04:32:43+00:00",
        "comment_author": "gaby",
        "comment_body": "Do we need the Mutex Locks here too?",
        "pr_file_module": null
      },
      {
        "comment_id": "1621157669",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/csrf/session_manager.go",
        "discussion_id": "1618163645",
        "commented_code": "@@ -27,11 +27,22 @@ func newSessionManager(s *session.Store, k string) *sessionManager {\n \n // get token from session\n func (m *sessionManager) getRaw(c fiber.Ctx, key string, raw []byte) []byte {",
        "comment_created_at": "2024-05-30T17:21:33+00:00",
        "comment_author": "sixcolors",
        "comment_body": "The mu mutex in the Middleware struct is used to ensure thread-safety when modifying the Session and hasChanged fields of the Middleware instance. This is necessary because the Middleware instance could potentially be accessed by multiple goroutines concurrently.\r\n\r\nHowever, since the Session struct itself already ensures thread-safety in its methods (i.e., it uses its own mutexes to protect its data), then the mu mutex in the Middleware struct might be redundant for operations on the Session.\r\n\r\nBut, the mu mutex is still necessary for the Session and hasChanged field. If this field is accessed concurrently without a mutex, it could lead to race conditions.\r\n\r\nI will update.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1657097299",
    "pr_number": 3017,
    "pr_file": "app.go",
    "created_at": "2024-06-27T13:01:05+00:00",
    "commented_code": "configured Config\n \t// customConstraints is a list of external constraints\n \tcustomConstraints []CustomConstraint\n+\t// sendfiles stores configurations for handling ctx.SendFile operations\n+\tsendfiles      []*sendFileStore\n+\tsendfilesMutex sync.RWMutex",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1657097299",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3017,
        "pr_file": "app.go",
        "discussion_id": "1657097299",
        "commented_code": "@@ -123,6 +123,9 @@ type App struct {\n \tconfigured Config\n \t// customConstraints is a list of external constraints\n \tcustomConstraints []CustomConstraint\n+\t// sendfiles stores configurations for handling ctx.SendFile operations\n+\tsendfiles      []*sendFileStore\n+\tsendfilesMutex sync.RWMutex",
        "comment_created_at": "2024-06-27T13:01:05+00:00",
        "comment_author": "gaby",
        "comment_body": "add comment for `sendfilesMutex`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1198782206",
    "pr_number": 2469,
    "pr_file": "middleware/monitor/monitor.go",
    "created_at": "2023-05-19T10:03:21+00:00",
    "commented_code": "}\n \t\tif c.Get(fiber.HeaderAccept) == fiber.MIMEApplicationJSON || cfg.APIOnly {\n \t\t\tmutex.Lock()\n+\t\t\tdefer mutex.Unlock()",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1198782206",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2469,
        "pr_file": "middleware/monitor/monitor.go",
        "discussion_id": "1198782206",
        "commented_code": "@@ -84,6 +84,7 @@ func New(config ...Config) fiber.Handler {\n \t\t}\n \t\tif c.Get(fiber.HeaderAccept) == fiber.MIMEApplicationJSON || cfg.APIOnly {\n \t\t\tmutex.Lock()\n+\t\t\tdefer mutex.Unlock()",
        "comment_created_at": "2023-05-19T10:03:21+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "why do we close the mutext so late? after writing the status and the json? \r\nbesides, in previous benchmarks it had turned out that the defer calls are slower",
        "pr_file_module": null
      },
      {
        "comment_id": "1199844250",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2469,
        "pr_file": "middleware/monitor/monitor.go",
        "discussion_id": "1198782206",
        "commented_code": "@@ -84,6 +84,7 @@ func New(config ...Config) fiber.Handler {\n \t\t}\n \t\tif c.Get(fiber.HeaderAccept) == fiber.MIMEApplicationJSON || cfg.APIOnly {\n \t\t\tmutex.Lock()\n+\t\t\tdefer mutex.Unlock()",
        "comment_created_at": "2023-05-21T23:23:06+00:00",
        "comment_author": "leonklingele",
        "comment_body": "Otherwise line 97 (`return c.Status(fiber.StatusOK).JSON(data)`) has a race condition where it reads the shared `data` variable.\r\n\r\nTrue, `defer`-ed functions run a tad slower, but since one of the more recent Go releases it's negligible (and will probably be reduced further in the future).\r\n\r\nInstead of using `defer` here, we could also make a deep copy of `data` while still having the mutex locked.",
        "pr_file_module": null
      },
      {
        "comment_id": "1200007064",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2469,
        "pr_file": "middleware/monitor/monitor.go",
        "discussion_id": "1198782206",
        "commented_code": "@@ -84,6 +84,7 @@ func New(config ...Config) fiber.Handler {\n \t\t}\n \t\tif c.Get(fiber.HeaderAccept) == fiber.MIMEApplicationJSON || cfg.APIOnly {\n \t\t\tmutex.Lock()\n+\t\t\tdefer mutex.Unlock()",
        "comment_created_at": "2023-05-22T06:26:31+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "ok it can stay",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1349702918",
    "pr_number": 2669,
    "pr_file": "internal/storage/memory/memory.go",
    "created_at": "2023-10-08T14:08:37+00:00",
    "commented_code": "}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1349702918",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-08T14:08:37+00:00",
        "comment_author": "gaby",
        "comment_body": "This is an interface, we shouldn't rename it to avoid breaking changes.",
        "pr_file_module": null
      },
      {
        "comment_id": "1349765885",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-08T19:33:41+00:00",
        "comment_author": "Hrily",
        "comment_body": "@gaby What interface does this implement?\r\n\r\nI can see the earlier `Conn` method only on this struct\r\nhttps://sourcegraph.com/search?q=context:global+repo:https://github.com/gofiber/fiber/+%22Conn()%22&patternType=standard&sm=1&groupBy=repo",
        "pr_file_module": null
      },
      {
        "comment_id": "1349767060",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-08T19:43:24+00:00",
        "comment_author": "gaby",
        "comment_body": "https://github.com/gofiber/storage/blob/main/storage.go\r\n\r\nWe may need to discuss this, since it's implemented differently in multiple places \ud83e\udd14",
        "pr_file_module": null
      },
      {
        "comment_id": "1350290733",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-09T13:11:39+00:00",
        "comment_author": "Hrily",
        "comment_body": "As far as I understand, this method is only provided by `memory.Storage`, because I don't think any other storage will return a `Conn` of type  `map[string]entry`.",
        "pr_file_module": null
      },
      {
        "comment_id": "1351572415",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-10T06:13:25+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "no this method is provided by all adapters\r\nhttps://github.com/search?q=repo%3Agofiber%2Fstorage%20conn&type=code",
        "pr_file_module": null
      },
      {
        "comment_id": "1351599261",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-10T06:21:08+00:00",
        "comment_author": "Hrily",
        "comment_body": "I see\r\n\r\nI think we can make `Storage.db` a `sync.Map` so we can return it as it is from `Conn()`, without worrying about thread safety.\r\n\r\nThoughts @gaby , @ReneWerner87 ?\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1359805921",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-15T07:53:42+00:00",
        "comment_author": "Hrily",
        "comment_body": "A ping on this in case it was missed. @gaby @ReneWerner87 ",
        "pr_file_module": null
      },
      {
        "comment_id": "1360199852",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-16T07:01:56+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "sync.Map is ok, but slower or ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1360224807",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-16T07:27:17+00:00",
        "comment_author": "Hrily",
        "comment_body": "I can run the `Benchmark_Storage_Memory` and see if it's better or worse.",
        "pr_file_module": null
      },
      {
        "comment_id": "1360912547",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2669,
        "pr_file": "internal/storage/memory/memory.go",
        "discussion_id": "1349702918",
        "commented_code": "@@ -137,9 +137,9 @@ func (s *Storage) gc() {\n \t}\n }\n \n-// Return database client\n-func (s *Storage) Conn() map[string]entry {\n-\ts.mux.RLock()\n-\tdefer s.mux.RUnlock()\n-\treturn s.db\n+// ConnLocked can be used to access the underlying db in a thread-safe manner.\n+func (s *Storage) ConnLocked(f func(map[string]entry)) {",
        "comment_created_at": "2023-10-16T16:08:49+00:00",
        "comment_author": "Hrily",
        "comment_body": "@ReneWerner87 `sync.Map` based implementation is slower than existing implementation for `Benchmark_Storage_Memory`:\r\n\r\nExisting Implementation Results:\r\n\r\n![Screenshot 2023-10-16 at 9 20 21 PM](https://github.com/gofiber/fiber/assets/13836720/27a26105-48a9-40ca-a8a1-4d2d4f0506c8)\r\n\r\n`sync.Map` based implementation Results:\r\n\r\n![Screenshot 2023-10-16 at 9 20 36 PM](https://github.com/gofiber/fiber/assets/13836720/a075e765-7a97-4fea-a6cd-effdb1440add)\r\n\r\nBut our choice should not depend on the benchmark we have. From [sync.Map Documentation](https://pkg.go.dev/sync#Map):\r\n\r\n> The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.\r\n\r\nSo if `Storage`'s use case aligns with one of the above two points, we can go ahead and use `sync.Map`. Else we can have another interface layer on top of vanilla map with RWMutex which we can return from `Conn()`\r\n",
        "pr_file_module": null
      }
    ]
  }
]