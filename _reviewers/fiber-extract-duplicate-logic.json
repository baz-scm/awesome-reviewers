[
  {
    "discussion_id": "1682707629",
    "pr_number": 3076,
    "pr_file": "redirect.go",
    "created_at": "2024-07-18T11:52:20+00:00",
    "commented_code": "// If you want to send queries or params to route, you should use config parameter.\n func (r *Redirect) Route(name string, config ...RedirectConfig) error {\n \t// Check config\n-\tcfg := RedirectConfig{}\n+\tcfg := RedirectConfig{CookieConfig: CookieConfigDefault}\n+\n \tif len(config) > 0 {\n \t\tcfg = config[0]\n \t}\n \n+\tif cfg.CookieConfig == (CookieConfig{}) {\n+\t\tcfg.CookieConfig = CookieConfigDefault\n+\t}\n+\n+\tif cfg.CookieConfig.Name == \"\" {\n+\t\tcfg.CookieConfig.Name = CookieConfigDefault.Name\n+\t}\n+\n+\tif cfg.CookieConfig.SameSite == \"\" {\n+\t\tcfg.CookieConfig.SameSite = CookieConfigDefault.SameSite\n+\t}\n+\n+\t// RFC6265: If SameSite=None, the Secure attribute must be set\n+\t// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-14#name-storage-model\n+\t// Section 5.6.19\n+\tif utils.ToLower(cfg.CookieConfig.SameSite) == \"none\" {\n+\t\tcfg.CookieConfig.Secure = true // Ensure Secure is true if SameSite=None\n+\t}\n+\n+\t// Set the cookie configuration in the Redirect struct\n+\tr.cookieConfig = cfg.CookieConfig",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1682707629",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3076,
        "pr_file": "redirect.go",
        "discussion_id": "1682707629",
        "commented_code": "@@ -191,11 +205,34 @@ func (r *Redirect) To(location string) error {\n // If you want to send queries or params to route, you should use config parameter.\n func (r *Redirect) Route(name string, config ...RedirectConfig) error {\n \t// Check config\n-\tcfg := RedirectConfig{}\n+\tcfg := RedirectConfig{CookieConfig: CookieConfigDefault}\n+\n \tif len(config) > 0 {\n \t\tcfg = config[0]\n \t}\n \n+\tif cfg.CookieConfig == (CookieConfig{}) {\n+\t\tcfg.CookieConfig = CookieConfigDefault\n+\t}\n+\n+\tif cfg.CookieConfig.Name == \"\" {\n+\t\tcfg.CookieConfig.Name = CookieConfigDefault.Name\n+\t}\n+\n+\tif cfg.CookieConfig.SameSite == \"\" {\n+\t\tcfg.CookieConfig.SameSite = CookieConfigDefault.SameSite\n+\t}\n+\n+\t// RFC6265: If SameSite=None, the Secure attribute must be set\n+\t// https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-14#name-storage-model\n+\t// Section 5.6.19\n+\tif utils.ToLower(cfg.CookieConfig.SameSite) == \"none\" {\n+\t\tcfg.CookieConfig.Secure = true // Ensure Secure is true if SameSite=None\n+\t}\n+\n+\t// Set the cookie configuration in the Redirect struct\n+\tr.cookieConfig = cfg.CookieConfig",
        "comment_created_at": "2024-07-18T11:52:20+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "since the part with the configurations has become larger, we can move this to a private function for creating the configuration, so that it becomes more usable again",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2094521977",
    "pr_number": 3434,
    "pr_file": "app.go",
    "created_at": "2025-05-18T13:18:48+00:00",
    "commented_code": "// Override colors\n \tapp.config.ColorScheme = defaultColors(app.config.ColorScheme)\n \n+\t// If the app is configured to use services,\n+\t// register a post shutdown hook to shutdown them after the server is closed.\n+\tif app.hasConfiguredServices() {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "2094521977",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3434,
        "pr_file": "app.go",
        "discussion_id": "2094521977",
        "commented_code": "@@ -603,6 +618,21 @@ func New(config ...Config) *App {\n \t// Override colors\n \tapp.config.ColorScheme = defaultColors(app.config.ColorScheme)\n \n+\t// If the app is configured to use services,\n+\t// register a post shutdown hook to shutdown them after the server is closed.\n+\tif app.hasConfiguredServices() {",
        "comment_created_at": "2025-05-18T13:18:48+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "Can we do the process in the `init` function ?\r\nAnd can you outsource this whole block in a function called\r\n`initServices`\r\ni like short functions (CleanCode disciple)  and we blow up the `New` or `init` function with this whole block\r\n\r\nLater\r\n\r\n```go\r\nfunc (app *App) init() *App {\r\n\t// lock application\r\n\tapp.mutex.Lock()\r\n\t\r\n\tapp.initServices()\r\n\t...\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2095120805",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3434,
        "pr_file": "app.go",
        "discussion_id": "2094521977",
        "commented_code": "@@ -603,6 +618,21 @@ func New(config ...Config) *App {\n \t// Override colors\n \tapp.config.ColorScheme = defaultColors(app.config.ColorScheme)\n \n+\t// If the app is configured to use services,\n+\t// register a post shutdown hook to shutdown them after the server is closed.\n+\tif app.hasConfiguredServices() {",
        "comment_created_at": "2025-05-19T08:15:25+00:00",
        "comment_author": "mdelapenya",
        "comment_body": "@ReneWerner87 I applied your suggestion in [0a75429](https://github.com/gofiber/fiber/pull/3434/commits/0a75429d9a8168595c18dc3941e5a72616f2bd34). It' even greater, as it allowed me to write unit tests for that function easier. Thanks for the suggestion.",
        "pr_file_module": null
      },
      {
        "comment_id": "2095123198",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3434,
        "pr_file": "app.go",
        "discussion_id": "2094521977",
        "commented_code": "@@ -603,6 +618,21 @@ func New(config ...Config) *App {\n \t// Override colors\n \tapp.config.ColorScheme = defaultColors(app.config.ColorScheme)\n \n+\t// If the app is configured to use services,\n+\t// register a post shutdown hook to shutdown them after the server is closed.\n+\tif app.hasConfiguredServices() {",
        "comment_created_at": "2025-05-19T08:16:44+00:00",
        "comment_author": "mdelapenya",
        "comment_body": "> Can we do the process in the init function ?\r\n\r\nI'm sorry but I don't get this part: what process do you refer? \ud83d\ude4f ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1894594352",
    "pr_number": 3231,
    "pr_file": "bind.go",
    "created_at": "2024-12-21T09:53:29+00:00",
    "commented_code": "// RespHeader binds the response header strings into the struct, map[string]string and map[string][]string.\n func (b *Bind) RespHeader(out any) error {\n-\tif err := b.returnErr(binder.RespHeaderBinder.Bind(b.ctx.Response(), out)); err != nil {\n+\tbind := binder.GetFromThePool[*binder.RespHeaderBinding](&binder.RespHeaderBinderPool)\n+\tbind.EnableSplitting = b.ctx.App().config.EnableSplittingOnParsers\n+\n+\t// Reset & put binder\n+\tdefer func() {\n+\t\tbind.EnableSplitting = false",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1894594352",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3231,
        "pr_file": "bind.go",
        "discussion_id": "1894594352",
        "commented_code": "@@ -86,7 +95,16 @@ func (b *Bind) Header(out any) error {\n \n // RespHeader binds the response header strings into the struct, map[string]string and map[string][]string.\n func (b *Bind) RespHeader(out any) error {\n-\tif err := b.returnErr(binder.RespHeaderBinder.Bind(b.ctx.Response(), out)); err != nil {\n+\tbind := binder.GetFromThePool[*binder.RespHeaderBinding](&binder.RespHeaderBinderPool)\n+\tbind.EnableSplitting = b.ctx.App().config.EnableSplittingOnParsers\n+\n+\t// Reset & put binder\n+\tdefer func() {\n+\t\tbind.EnableSplitting = false",
        "comment_created_at": "2024-12-21T09:53:29+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "can we add a reset method\r\nits better than handling every option separat",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1898912771",
    "pr_number": 3235,
    "pr_file": "binder/form.go",
    "created_at": "2024-12-28T14:15:40+00:00",
    "commented_code": "return err\n \t}\n \n-\treturn parse(b.Name(), out, data.Value)\n+\ttemp := make(map[string][]string)\n+\tfor key, values := range data.Value {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1898912771",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3235,
        "pr_file": "binder/form.go",
        "discussion_id": "1898912771",
        "commented_code": "@@ -66,7 +66,27 @@ func (b *FormBinding) bindMultipart(req *fasthttp.Request, out any) error {\n \t\treturn err\n \t}\n \n-\treturn parse(b.Name(), out, data.Value)\n+\ttemp := make(map[string][]string)\n+\tfor key, values := range data.Value {",
        "comment_created_at": "2024-12-28T14:15:40+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "this part looks almost identical to the other square bracket parsings, if it were possible it would be cool if we could move this into another function and use it in all three places\r\n\r\nquery params\r\nhttps://github.com/gofiber/fiber/blob/775e0a73f3fc0eba0940488e2accd3b87ab245ee/binder/query.go#L34-L45\r\nform params urlencoded\r\nhttps://github.com/gofiber/fiber/blob/775e0a73f3fc0eba0940488e2accd3b87ab245ee/binder/form.go#L41-L52",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1453162688",
    "pr_number": 2776,
    "pr_file": "ctx.go",
    "created_at": "2024-01-16T09:36:19+00:00",
    "commented_code": "return m\n }\n \n-// QueryInt returns integer value of key string parameter in the url.\n-// Default to empty or invalid key is 0.\n+// Query Retrieves the value of a query parameter from the request's URI.\n+// The function is generic and can handle query parameter values of different types.\n+// It takes the following parameters:\n+// - c: The context object representing the current request.\n+// - key: The name of the query parameter.\n+// - defaultValue: (Optional) The default value to return in case the query parameter is not found or cannot be parsed.\n+// The function performs the following steps:\n+//  1. Type-asserts the context object to *DefaultCtx.\n+//  2. Retrieves the raw query parameter value from the request's URI.\n+//  3. Parses the raw value into the appropriate type based on the generic type parameter V.\n+//     If parsing fails, the function checks if a default value is provided. If so, it returns the default value.\n+//  4. Returns the parsed value.\n //\n-//\tGET /?name=alex&wanna_cake=2&id=\n-//\tQueryInt(\"wanna_cake\", 1) == 2\n-//\tQueryInt(\"name\", 1) == 1\n-//\tQueryInt(\"id\", 1) == 1\n-//\tQueryInt(\"id\") == 0\n-func (c *DefaultCtx) QueryInt(key string, defaultValue ...int) int {\n-\t// Use Atoi to convert the param to an int or return zero and an error\n-\tvalue, err := strconv.Atoi(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n-\tif err != nil {\n-\t\tif len(defaultValue) > 0 {\n-\t\t\treturn defaultValue[0]\n-\t\t}\n-\t\treturn 0\n+// If the generic type cannot be matched to a supported type, the function returns the default value (if provided) or the zero value of type V.\n+//\n+// Example usage:\n+//\n+//\tGET /?search=john&age=8\n+//\tname := Query[string](c, \"search\") // Returns \"john\"\n+//\tage := Query[int](c, \"age\") // Returns 8\n+//\tunknown := Query[string](c, \"unknown\", \"default\") // Returns \"default\" since the query parameter \"unknown\" is not found\n+func Query[V QueryType](c Ctx, key string, defaultValue ...V) V {\n+\tctx, ok := c.(*DefaultCtx)\n+\tif !ok {\n+\t\tpanic(fmt.Errorf(\"failed to type-assert to *DefaultCtx\"))\n \t}\n+\tvar v V\n+\tq := ctx.app.getString(ctx.fasthttp.QueryArgs().Peek(key))\n \n-\treturn value\n-}\n-\n-// QueryBool returns bool value of key string parameter in the url.\n-// Default to empty or invalid key is true.\n-//\n-//\tGet /?name=alex&want_pizza=false&id=\n-//\tQueryBool(\"want_pizza\") == false\n-//\tQueryBool(\"want_pizza\", true) == false\n-//\tQueryBool(\"name\") == false\n-//\tQueryBool(\"name\", true) == true\n-//\tQueryBool(\"id\") == false\n-//\tQueryBool(\"id\", true) == true\n-func (c *DefaultCtx) QueryBool(key string, defaultValue ...bool) bool {\n-\tvalue, err := strconv.ParseBool(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n-\tif err != nil {\n+\tswitch any(v).(type) {\n+\tcase int:\n+\t\tresult, err := strconv.ParseInt(q, 10, 32)\n+\t\tif err != nil {\n+\t\t\tif len(defaultValue) > 0 {\n+\t\t\t\treturn defaultValue[0]\n+\t\t\t}\n+\t\t\treturn v\n+\t\t}",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1453162688",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2776,
        "pr_file": "ctx.go",
        "discussion_id": "1453162688",
        "commented_code": "@@ -1037,67 +1037,197 @@ func (c *DefaultCtx) Queries() map[string]string {\n \treturn m\n }\n \n-// QueryInt returns integer value of key string parameter in the url.\n-// Default to empty or invalid key is 0.\n+// Query Retrieves the value of a query parameter from the request's URI.\n+// The function is generic and can handle query parameter values of different types.\n+// It takes the following parameters:\n+// - c: The context object representing the current request.\n+// - key: The name of the query parameter.\n+// - defaultValue: (Optional) The default value to return in case the query parameter is not found or cannot be parsed.\n+// The function performs the following steps:\n+//  1. Type-asserts the context object to *DefaultCtx.\n+//  2. Retrieves the raw query parameter value from the request's URI.\n+//  3. Parses the raw value into the appropriate type based on the generic type parameter V.\n+//     If parsing fails, the function checks if a default value is provided. If so, it returns the default value.\n+//  4. Returns the parsed value.\n //\n-//\tGET /?name=alex&wanna_cake=2&id=\n-//\tQueryInt(\"wanna_cake\", 1) == 2\n-//\tQueryInt(\"name\", 1) == 1\n-//\tQueryInt(\"id\", 1) == 1\n-//\tQueryInt(\"id\") == 0\n-func (c *DefaultCtx) QueryInt(key string, defaultValue ...int) int {\n-\t// Use Atoi to convert the param to an int or return zero and an error\n-\tvalue, err := strconv.Atoi(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n-\tif err != nil {\n-\t\tif len(defaultValue) > 0 {\n-\t\t\treturn defaultValue[0]\n-\t\t}\n-\t\treturn 0\n+// If the generic type cannot be matched to a supported type, the function returns the default value (if provided) or the zero value of type V.\n+//\n+// Example usage:\n+//\n+//\tGET /?search=john&age=8\n+//\tname := Query[string](c, \"search\") // Returns \"john\"\n+//\tage := Query[int](c, \"age\") // Returns 8\n+//\tunknown := Query[string](c, \"unknown\", \"default\") // Returns \"default\" since the query parameter \"unknown\" is not found\n+func Query[V QueryType](c Ctx, key string, defaultValue ...V) V {\n+\tctx, ok := c.(*DefaultCtx)\n+\tif !ok {\n+\t\tpanic(fmt.Errorf(\"failed to type-assert to *DefaultCtx\"))\n \t}\n+\tvar v V\n+\tq := ctx.app.getString(ctx.fasthttp.QueryArgs().Peek(key))\n \n-\treturn value\n-}\n-\n-// QueryBool returns bool value of key string parameter in the url.\n-// Default to empty or invalid key is true.\n-//\n-//\tGet /?name=alex&want_pizza=false&id=\n-//\tQueryBool(\"want_pizza\") == false\n-//\tQueryBool(\"want_pizza\", true) == false\n-//\tQueryBool(\"name\") == false\n-//\tQueryBool(\"name\", true) == true\n-//\tQueryBool(\"id\") == false\n-//\tQueryBool(\"id\", true) == true\n-func (c *DefaultCtx) QueryBool(key string, defaultValue ...bool) bool {\n-\tvalue, err := strconv.ParseBool(c.app.getString(c.fasthttp.QueryArgs().Peek(key)))\n-\tif err != nil {\n+\tswitch any(v).(type) {\n+\tcase int:\n+\t\tresult, err := strconv.ParseInt(q, 10, 32)\n+\t\tif err != nil {\n+\t\t\tif len(defaultValue) > 0 {\n+\t\t\t\treturn defaultValue[0]\n+\t\t\t}\n+\t\t\treturn v\n+\t\t}",
        "comment_created_at": "2024-01-16T09:36:19+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "this part is always the same, can you outsource it, e.g. make a break if there is an error and handle this part under the switch or outsource it to another methodic\r\n\r\nplease check the benchmark again afterwards",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1104165179",
    "pr_number": 2332,
    "pr_file": "middleware/proxy/proxy.go",
    "created_at": "2023-02-13T09:01:12+00:00",
    "commented_code": "return nil\n }\n \n+func DoRedirects(c *fiber.Ctx, addr string, maxRedirectsCount int, clients ...*fasthttp.Client) error {\n+\tvar cli *fasthttp.Client\n+\tif len(clients) != 0 {\n+\t\t// Set local client\n+\t\tcli = clients[0]\n+\t} else {\n+\t\t// Set global client\n+\t\tlock.RLock()\n+\t\tcli = client\n+\t\tlock.RUnlock()\n+\t}\n+\treq := c.Request()\n+\tres := c.Response()\n+\toriginalURL := utils.CopyString(c.OriginalURL())\n+\tdefer req.SetRequestURI(originalURL)\n+\n+\tcopiedURL := utils.CopyString(addr)\n+\treq.SetRequestURI(copiedURL)\n+\t// NOTE: if req.isTLS is true, SetRequestURI keeps the scheme as https.\n+\t// issue reference:\n+\t// https://github.com/gofiber/fiber/issues/1762\n+\tif scheme := getScheme(utils.UnsafeBytes(copiedURL)); len(scheme) > 0 {\n+\t\treq.URI().SetSchemeBytes(scheme)\n+\t}\n+\n+\treq.Header.Del(fiber.HeaderConnection)\n+\tif err := cli.DoRedirects(req, res, maxRedirectsCount); err != nil {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1104165179",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2332,
        "pr_file": "middleware/proxy/proxy.go",
        "discussion_id": "1104165179",
        "commented_code": "@@ -171,6 +171,39 @@ func Do(c *fiber.Ctx, addr string, clients ...*fasthttp.Client) error {\n \treturn nil\n }\n \n+func DoRedirects(c *fiber.Ctx, addr string, maxRedirectsCount int, clients ...*fasthttp.Client) error {\n+\tvar cli *fasthttp.Client\n+\tif len(clients) != 0 {\n+\t\t// Set local client\n+\t\tcli = clients[0]\n+\t} else {\n+\t\t// Set global client\n+\t\tlock.RLock()\n+\t\tcli = client\n+\t\tlock.RUnlock()\n+\t}\n+\treq := c.Request()\n+\tres := c.Response()\n+\toriginalURL := utils.CopyString(c.OriginalURL())\n+\tdefer req.SetRequestURI(originalURL)\n+\n+\tcopiedURL := utils.CopyString(addr)\n+\treq.SetRequestURI(copiedURL)\n+\t// NOTE: if req.isTLS is true, SetRequestURI keeps the scheme as https.\n+\t// issue reference:\n+\t// https://github.com/gofiber/fiber/issues/1762\n+\tif scheme := getScheme(utils.UnsafeBytes(copiedURL)); len(scheme) > 0 {\n+\t\treq.URI().SetSchemeBytes(scheme)\n+\t}\n+\n+\treq.Header.Del(fiber.HeaderConnection)\n+\tif err := cli.DoRedirects(req, res, maxRedirectsCount); err != nil {",
        "comment_created_at": "2023-02-13T09:01:12+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "![image](https://user-images.githubusercontent.com/7063188/218414669-630eefa6-f831-4227-8569-d09922bb21b9.png)\r\nlooks like it is a complete copy of the other method\r\n\r\ncan we improve this by swapping the core of these methods into a new one and only ever swap the action method ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1104175911",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2332,
        "pr_file": "middleware/proxy/proxy.go",
        "discussion_id": "1104165179",
        "commented_code": "@@ -171,6 +171,39 @@ func Do(c *fiber.Ctx, addr string, clients ...*fasthttp.Client) error {\n \treturn nil\n }\n \n+func DoRedirects(c *fiber.Ctx, addr string, maxRedirectsCount int, clients ...*fasthttp.Client) error {\n+\tvar cli *fasthttp.Client\n+\tif len(clients) != 0 {\n+\t\t// Set local client\n+\t\tcli = clients[0]\n+\t} else {\n+\t\t// Set global client\n+\t\tlock.RLock()\n+\t\tcli = client\n+\t\tlock.RUnlock()\n+\t}\n+\treq := c.Request()\n+\tres := c.Response()\n+\toriginalURL := utils.CopyString(c.OriginalURL())\n+\tdefer req.SetRequestURI(originalURL)\n+\n+\tcopiedURL := utils.CopyString(addr)\n+\treq.SetRequestURI(copiedURL)\n+\t// NOTE: if req.isTLS is true, SetRequestURI keeps the scheme as https.\n+\t// issue reference:\n+\t// https://github.com/gofiber/fiber/issues/1762\n+\tif scheme := getScheme(utils.UnsafeBytes(copiedURL)); len(scheme) > 0 {\n+\t\treq.URI().SetSchemeBytes(scheme)\n+\t}\n+\n+\treq.Header.Del(fiber.HeaderConnection)\n+\tif err := cli.DoRedirects(req, res, maxRedirectsCount); err != nil {",
        "comment_created_at": "2023-02-13T09:11:03+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "```go\r\nfunc Do(c *fiber.Ctx, addr string, clients ...*fasthttp.Client) error {\r\n\treturn do(c, addr, func(cli *fasthttp.Client, req *fasthttp.Request, resp *fasthttp.Response) error {\r\n\t\treturn cli.Do(req, resp)\r\n\t}, clients)\r\n}\r\n\r\nfunc DoRedirects(c *fiber.Ctx, addr string, maxRedirectsCount int, clients ...*fasthttp.Client) error {\r\n\treturn do(c, addr, func(cli *fasthttp.Client, req *fasthttp.Request, resp *fasthttp.Response) error {\r\n\t\treturn cli.DoRedirects(req, resp, maxRedirectsCount)\r\n\t}, clients...)\r\n}\r\n\r\nfunc DoDeadline(c *fiber.Ctx, addr string, deadline time.Time, clients ...*fasthttp.Client) error {\r\n\treturn do(c, addr, func(cli *fasthttp.Client, req *fasthttp.Request, resp *fasthttp.Response) error {\r\n\t\treturn cli.DoDeadline(req, resp, deadline)\r\n\t}, clients...)\r\n}\r\n\r\nfunc DoTimeout(c *fiber.Ctx, addr string,timeout time.Duration, clients ...*fasthttp.Client) error {\r\n\treturn do(c, addr, func(cli *fasthttp.Client, req *fasthttp.Request, resp *fasthttp.Response) error {\r\n\t\treturn cli.DoTimeout(req, resp, timeout)\r\n\t}, clients...)\r\n}\r\n\r\nfunc do(\r\n\tc *fiber.Ctx,\r\n\taddr string,\r\n\taction func(cli *fasthttp.Client, req *fasthttp.Request, resp *fasthttp.Response) error,\r\n\tclients ...*fasthttp.Client,\r\n) error {\r\n\tvar client *fasthttp.Client\r\n\tif len(clients) != 0 {\r\n\t\t// Set local client\r\n\t\tclient = clients[0]\r\n\t} else {\r\n\t\t// Set global client\r\n\t\tlock.RLock()\r\n\t\tclient = client\r\n\t\tlock.RUnlock()\r\n\t}\r\n\r\n\treq := c.Request()\r\n\tres := c.Response()\r\n\toriginalURL := utils.CopyString(c.OriginalURL())\r\n\tdefer req.SetRequestURI(originalURL)\r\n\r\n\tcopiedURL := utils.CopyString(addr)\r\n\treq.SetRequestURI(copiedURL)\r\n\t// NOTE: if req.isTLS is true, SetRequestURI keeps the scheme as https.\r\n\t// issue reference:\r\n\t// https://github.com/gofiber/fiber/issues/1762\r\n\tif scheme := getScheme(utils.UnsafeBytes(copiedURL)); len(scheme) > 0 {\r\n\t\treq.URI().SetSchemeBytes(scheme)\r\n\t}\r\n\r\n\treq.Header.Del(fiber.HeaderConnection)\r\n\tif err := action(client, req, res); err != nil {\r\n\t\treturn err\r\n\t}\r\n\tres.Header.Del(fiber.HeaderConnection)\r\n\treturn nil\r\n}\r\n```\r\nsomething like this, but better",
        "pr_file_module": null
      },
      {
        "comment_id": "1105856971",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2332,
        "pr_file": "middleware/proxy/proxy.go",
        "discussion_id": "1104165179",
        "commented_code": "@@ -171,6 +171,39 @@ func Do(c *fiber.Ctx, addr string, clients ...*fasthttp.Client) error {\n \treturn nil\n }\n \n+func DoRedirects(c *fiber.Ctx, addr string, maxRedirectsCount int, clients ...*fasthttp.Client) error {\n+\tvar cli *fasthttp.Client\n+\tif len(clients) != 0 {\n+\t\t// Set local client\n+\t\tcli = clients[0]\n+\t} else {\n+\t\t// Set global client\n+\t\tlock.RLock()\n+\t\tcli = client\n+\t\tlock.RUnlock()\n+\t}\n+\treq := c.Request()\n+\tres := c.Response()\n+\toriginalURL := utils.CopyString(c.OriginalURL())\n+\tdefer req.SetRequestURI(originalURL)\n+\n+\tcopiedURL := utils.CopyString(addr)\n+\treq.SetRequestURI(copiedURL)\n+\t// NOTE: if req.isTLS is true, SetRequestURI keeps the scheme as https.\n+\t// issue reference:\n+\t// https://github.com/gofiber/fiber/issues/1762\n+\tif scheme := getScheme(utils.UnsafeBytes(copiedURL)); len(scheme) > 0 {\n+\t\treq.URI().SetSchemeBytes(scheme)\n+\t}\n+\n+\treq.Header.Del(fiber.HeaderConnection)\n+\tif err := cli.DoRedirects(req, res, maxRedirectsCount); err != nil {",
        "comment_created_at": "2023-02-14T13:56:50+00:00",
        "comment_author": "gaby",
        "comment_body": "@ReneWerner87 Do we want to add `DoTimeout` and `DoDeadline` to this PR? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1107222754",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2332,
        "pr_file": "middleware/proxy/proxy.go",
        "discussion_id": "1104165179",
        "commented_code": "@@ -171,6 +171,39 @@ func Do(c *fiber.Ctx, addr string, clients ...*fasthttp.Client) error {\n \treturn nil\n }\n \n+func DoRedirects(c *fiber.Ctx, addr string, maxRedirectsCount int, clients ...*fasthttp.Client) error {\n+\tvar cli *fasthttp.Client\n+\tif len(clients) != 0 {\n+\t\t// Set local client\n+\t\tcli = clients[0]\n+\t} else {\n+\t\t// Set global client\n+\t\tlock.RLock()\n+\t\tcli = client\n+\t\tlock.RUnlock()\n+\t}\n+\treq := c.Request()\n+\tres := c.Response()\n+\toriginalURL := utils.CopyString(c.OriginalURL())\n+\tdefer req.SetRequestURI(originalURL)\n+\n+\tcopiedURL := utils.CopyString(addr)\n+\treq.SetRequestURI(copiedURL)\n+\t// NOTE: if req.isTLS is true, SetRequestURI keeps the scheme as https.\n+\t// issue reference:\n+\t// https://github.com/gofiber/fiber/issues/1762\n+\tif scheme := getScheme(utils.UnsafeBytes(copiedURL)); len(scheme) > 0 {\n+\t\treq.URI().SetSchemeBytes(scheme)\n+\t}\n+\n+\treq.Header.Del(fiber.HeaderConnection)\n+\tif err := cli.DoRedirects(req, res, maxRedirectsCount); err != nil {",
        "comment_created_at": "2023-02-15T14:47:08+00:00",
        "comment_author": "gaby",
        "comment_body": "@ReneWerner87 Implementef the changes for DoTimeout and DoDeadlind. Having a hard time writing the unit-tests. Seems like I need to reuse the `createProxyServer` since `app.Test()` is returning 404 unless I use a real domain name.",
        "pr_file_module": null
      },
      {
        "comment_id": "1109918197",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2332,
        "pr_file": "middleware/proxy/proxy.go",
        "discussion_id": "1104165179",
        "commented_code": "@@ -171,6 +171,39 @@ func Do(c *fiber.Ctx, addr string, clients ...*fasthttp.Client) error {\n \treturn nil\n }\n \n+func DoRedirects(c *fiber.Ctx, addr string, maxRedirectsCount int, clients ...*fasthttp.Client) error {\n+\tvar cli *fasthttp.Client\n+\tif len(clients) != 0 {\n+\t\t// Set local client\n+\t\tcli = clients[0]\n+\t} else {\n+\t\t// Set global client\n+\t\tlock.RLock()\n+\t\tcli = client\n+\t\tlock.RUnlock()\n+\t}\n+\treq := c.Request()\n+\tres := c.Response()\n+\toriginalURL := utils.CopyString(c.OriginalURL())\n+\tdefer req.SetRequestURI(originalURL)\n+\n+\tcopiedURL := utils.CopyString(addr)\n+\treq.SetRequestURI(copiedURL)\n+\t// NOTE: if req.isTLS is true, SetRequestURI keeps the scheme as https.\n+\t// issue reference:\n+\t// https://github.com/gofiber/fiber/issues/1762\n+\tif scheme := getScheme(utils.UnsafeBytes(copiedURL)); len(scheme) > 0 {\n+\t\treq.URI().SetSchemeBytes(scheme)\n+\t}\n+\n+\treq.Header.Del(fiber.HeaderConnection)\n+\tif err := cli.DoRedirects(req, res, maxRedirectsCount); err != nil {",
        "comment_created_at": "2023-02-17T14:49:44+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "@gaby \r\nit is not absolutely necessary to offer the other methods as well\r\nfor me it was only important that we do not duplicate the code although the core is the same",
        "pr_file_module": null
      }
    ]
  }
]