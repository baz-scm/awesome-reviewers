[
  {
    "discussion_id": "2217926714",
    "pr_number": 3610,
    "pr_file": "ctx.go",
    "created_at": "2025-07-20T19:19:59+00:00",
    "commented_code": "cookie.Path = \"/\"\n \t}\n \n+\tif utils.ToLower(cookie.SameSite) == CookieSameSiteNoneMode && !cookie.Secure {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "2217926714",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3610,
        "pr_file": "ctx.go",
        "discussion_id": "2217926714",
        "commented_code": "@@ -425,6 +425,10 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n \t\tcookie.Path = \"/\"\n \t}\n \n+\tif utils.ToLower(cookie.SameSite) == CookieSameSiteNoneMode && !cookie.Secure {",
        "comment_created_at": "2025-07-20T19:19:59+00:00",
        "comment_author": "sixcolors",
        "comment_body": "To avoid allocations, you should use utils.EqualFold instead.",
        "pr_file_module": null
      },
      {
        "comment_id": "2217926929",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3610,
        "pr_file": "ctx.go",
        "discussion_id": "2217926714",
        "commented_code": "@@ -425,6 +425,10 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n \t\tcookie.Path = \"/\"\n \t}\n \n+\tif utils.ToLower(cookie.SameSite) == CookieSameSiteNoneMode && !cookie.Secure {",
        "comment_created_at": "2025-07-20T19:20:33+00:00",
        "comment_author": "sixcolors",
        "comment_body": "Also related #3608 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2217930227",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3610,
        "pr_file": "ctx.go",
        "discussion_id": "2217926714",
        "commented_code": "@@ -425,6 +425,10 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n \t\tcookie.Path = \"/\"\n \t}\n \n+\tif utils.ToLower(cookie.SameSite) == CookieSameSiteNoneMode && !cookie.Secure {",
        "comment_created_at": "2025-07-20T19:33:08+00:00",
        "comment_author": "gaby",
        "comment_body": "@sixcolors I'm closing this PR then.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2001849914",
    "pr_number": 3360,
    "pr_file": "state.go",
    "created_at": "2025-03-18T19:29:00+00:00",
    "commented_code": "+package fiber\n+\n+import (\n+\t\"sync\"\n+)\n+\n+// State is a key-value store for Fiber's app in order to be used as a global storage for the app's dependencies.\n+// It's a thread-safe implementation of a map[string]any, using sync.Map.\n+type State struct {\n+\tdependencies sync.Map\n+}\n+\n+// NewState creates a new instance of State.\n+func newState() *State {\n+\treturn &State{\n+\t\tdependencies: sync.Map{},\n+\t}\n+}\n+\n+// Set sets a key-value pair in the State.\n+func (s *State) Set(key string, value any) {\n+\ts.dependencies.Store(key, value)\n+}\n+\n+// Get retrieves a value from the State.\n+func (s *State) Get(key string) (any, bool) {\n+\treturn s.dependencies.Load(key)\n+}\n+\n+// GetString retrieves a string value from the State.\n+func (s *State) GetString(key string) (string, bool) {\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepString, okCast := dep.(string)\n+\t\treturn depString, okCast\n+\t}\n+\n+\treturn \"\", false\n+}\n+\n+// GetInt retrieves an int value from the State.\n+func (s *State) GetInt(key string) (int, bool) {\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepInt, okCast := dep.(int)\n+\t\treturn depInt, okCast\n+\t}\n+\n+\treturn 0, false\n+}\n+\n+// GetBool retrieves a bool value from the State.\n+func (s *State) GetBool(key string) (value, ok bool) { //nolint:nonamedreturns // Better idea to use named returns here\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepBool, okCast := dep.(bool)\n+\t\treturn depBool, okCast\n+\t}\n+\n+\treturn false, false\n+}\n+\n+// GetFloat64 retrieves a float64 value from the State.\n+func (s *State) GetFloat64(key string) (float64, bool) {\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepFloat64, okCast := dep.(float64)\n+\t\treturn depFloat64, okCast\n+\t}\n+\n+\treturn 0, false\n+}\n+\n+// MustGet retrieves a value from the State and panics if the key is not found.\n+func (s *State) MustGet(key string) any {\n+\tif dep, ok := s.Get(key); ok {\n+\t\treturn dep\n+\t}\n+\n+\tpanic(\"state: dependency not found!\")\n+}\n+\n+// MustGetString retrieves a string value from the State and panics if the key is not found.\n+func (s *State) Delete(key string) {\n+\ts.dependencies.Delete(key)\n+}\n+\n+// Reset resets the State.\n+func (s *State) Clear() {\n+\ts.dependencies.Clear()\n+}\n+\n+// Keys retrieves all the keys from the State.\n+func (s *State) Keys() []string {\n+\tkeys := make([]string, 0)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "2001849914",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3360,
        "pr_file": "state.go",
        "discussion_id": "2001849914",
        "commented_code": "@@ -0,0 +1,141 @@\n+package fiber\n+\n+import (\n+\t\"sync\"\n+)\n+\n+// State is a key-value store for Fiber's app in order to be used as a global storage for the app's dependencies.\n+// It's a thread-safe implementation of a map[string]any, using sync.Map.\n+type State struct {\n+\tdependencies sync.Map\n+}\n+\n+// NewState creates a new instance of State.\n+func newState() *State {\n+\treturn &State{\n+\t\tdependencies: sync.Map{},\n+\t}\n+}\n+\n+// Set sets a key-value pair in the State.\n+func (s *State) Set(key string, value any) {\n+\ts.dependencies.Store(key, value)\n+}\n+\n+// Get retrieves a value from the State.\n+func (s *State) Get(key string) (any, bool) {\n+\treturn s.dependencies.Load(key)\n+}\n+\n+// GetString retrieves a string value from the State.\n+func (s *State) GetString(key string) (string, bool) {\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepString, okCast := dep.(string)\n+\t\treturn depString, okCast\n+\t}\n+\n+\treturn \"\", false\n+}\n+\n+// GetInt retrieves an int value from the State.\n+func (s *State) GetInt(key string) (int, bool) {\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepInt, okCast := dep.(int)\n+\t\treturn depInt, okCast\n+\t}\n+\n+\treturn 0, false\n+}\n+\n+// GetBool retrieves a bool value from the State.\n+func (s *State) GetBool(key string) (value, ok bool) { //nolint:nonamedreturns // Better idea to use named returns here\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepBool, okCast := dep.(bool)\n+\t\treturn depBool, okCast\n+\t}\n+\n+\treturn false, false\n+}\n+\n+// GetFloat64 retrieves a float64 value from the State.\n+func (s *State) GetFloat64(key string) (float64, bool) {\n+\tdep, ok := s.Get(key)\n+\tif ok {\n+\t\tdepFloat64, okCast := dep.(float64)\n+\t\treturn depFloat64, okCast\n+\t}\n+\n+\treturn 0, false\n+}\n+\n+// MustGet retrieves a value from the State and panics if the key is not found.\n+func (s *State) MustGet(key string) any {\n+\tif dep, ok := s.Get(key); ok {\n+\t\treturn dep\n+\t}\n+\n+\tpanic(\"state: dependency not found!\")\n+}\n+\n+// MustGetString retrieves a string value from the State and panics if the key is not found.\n+func (s *State) Delete(key string) {\n+\ts.dependencies.Delete(key)\n+}\n+\n+// Reset resets the State.\n+func (s *State) Clear() {\n+\ts.dependencies.Clear()\n+}\n+\n+// Keys retrieves all the keys from the State.\n+func (s *State) Keys() []string {\n+\tkeys := make([]string, 0)",
        "comment_created_at": "2025-03-18T19:29:00+00:00",
        "comment_author": "efectn",
        "comment_body": "Here we can preallocate the keys slice using `s.Len()` to reduce the memory allocation; however, it will make the method a little bit slower.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1976448248",
    "pr_number": 3335,
    "pr_file": "path.go",
    "created_at": "2025-03-01T16:30:53+00:00",
    "commented_code": "pattern = \"/\" + pattern\n \t}\n \n-\tpatternPretty := pattern\n+\tpatternPretty := []byte(pattern)\n \n \t// Case-sensitive routing, all to lowercase\n \tif !config.CaseSensitive {\n-\t\tpatternPretty = utils.ToLower(patternPretty)\n+\t\tpatternPretty = utils.ToLowerBytes(patternPretty)\n \t\tpath = utils.ToLower(path)\n \t}\n \t// Strict routing, remove trailing slashes\n \tif !config.StrictRouting && len(patternPretty) > 1 {\n \t\tpatternPretty = utils.TrimRight(patternPretty, '/')\n \t}\n \n-\tparser := parseRoute(patternPretty)\n+\tparser := parseRoute(string(patternPretty))\n \n-\tif patternPretty == \"/\" && path == \"/\" {\n+\tif string(patternPretty) == \"/\" && path == \"/\" {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1976448248",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3335,
        "pr_file": "path.go",
        "discussion_id": "1976448248",
        "commented_code": "@@ -152,24 +152,24 @@ func RoutePatternMatch(path, pattern string, cfg ...Config) bool {\n \t\tpattern = \"/\" + pattern\n \t}\n \n-\tpatternPretty := pattern\n+\tpatternPretty := []byte(pattern)\n \n \t// Case-sensitive routing, all to lowercase\n \tif !config.CaseSensitive {\n-\t\tpatternPretty = utils.ToLower(patternPretty)\n+\t\tpatternPretty = utils.ToLowerBytes(patternPretty)\n \t\tpath = utils.ToLower(path)\n \t}\n \t// Strict routing, remove trailing slashes\n \tif !config.StrictRouting && len(patternPretty) > 1 {\n \t\tpatternPretty = utils.TrimRight(patternPretty, '/')\n \t}\n \n-\tparser := parseRoute(patternPretty)\n+\tparser := parseRoute(string(patternPretty))\n \n-\tif patternPretty == \"/\" && path == \"/\" {\n+\tif string(patternPretty) == \"/\" && path == \"/\" {",
        "comment_created_at": "2025-03-01T16:30:53+00:00",
        "comment_author": "gaby",
        "comment_body": "Why not wrap \"/\" in bytes? Instead of converting patternPretty to a string",
        "pr_file_module": null
      },
      {
        "comment_id": "1976448688",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3335,
        "pr_file": "path.go",
        "discussion_id": "1976448248",
        "commented_code": "@@ -152,24 +152,24 @@ func RoutePatternMatch(path, pattern string, cfg ...Config) bool {\n \t\tpattern = \"/\" + pattern\n \t}\n \n-\tpatternPretty := pattern\n+\tpatternPretty := []byte(pattern)\n \n \t// Case-sensitive routing, all to lowercase\n \tif !config.CaseSensitive {\n-\t\tpatternPretty = utils.ToLower(patternPretty)\n+\t\tpatternPretty = utils.ToLowerBytes(patternPretty)\n \t\tpath = utils.ToLower(path)\n \t}\n \t// Strict routing, remove trailing slashes\n \tif !config.StrictRouting && len(patternPretty) > 1 {\n \t\tpatternPretty = utils.TrimRight(patternPretty, '/')\n \t}\n \n-\tparser := parseRoute(patternPretty)\n+\tparser := parseRoute(string(patternPretty))\n \n-\tif patternPretty == \"/\" && path == \"/\" {\n+\tif string(patternPretty) == \"/\" && path == \"/\" {",
        "comment_created_at": "2025-03-01T16:32:29+00:00",
        "comment_author": "gaby",
        "comment_body": "Same with calling string(patternPretty) multiple times in the same function",
        "pr_file_module": null
      },
      {
        "comment_id": "1976456533",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3335,
        "pr_file": "path.go",
        "discussion_id": "1976448248",
        "commented_code": "@@ -152,24 +152,24 @@ func RoutePatternMatch(path, pattern string, cfg ...Config) bool {\n \t\tpattern = \"/\" + pattern\n \t}\n \n-\tpatternPretty := pattern\n+\tpatternPretty := []byte(pattern)\n \n \t// Case-sensitive routing, all to lowercase\n \tif !config.CaseSensitive {\n-\t\tpatternPretty = utils.ToLower(patternPretty)\n+\t\tpatternPretty = utils.ToLowerBytes(patternPretty)\n \t\tpath = utils.ToLower(path)\n \t}\n \t// Strict routing, remove trailing slashes\n \tif !config.StrictRouting && len(patternPretty) > 1 {\n \t\tpatternPretty = utils.TrimRight(patternPretty, '/')\n \t}\n \n-\tparser := parseRoute(patternPretty)\n+\tparser := parseRoute(string(patternPretty))\n \n-\tif patternPretty == \"/\" && path == \"/\" {\n+\tif string(patternPretty) == \"/\" && path == \"/\" {",
        "comment_created_at": "2025-03-01T17:10:26+00:00",
        "comment_author": "ksw2000",
        "comment_body": "Go compiler optimizes `[]byte` to `string` comparison to avoid extra memory allocation.\r\n\r\n```go\r\nfunc BenchmarkStringCompare(b *testing.B) {\r\n\tx := \"foo\"\r\n\ty := []byte(\"foo\")\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tif x != string(y) {\r\n\t\t\tb.Fail()\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkStringCompare2(b *testing.B) {\r\n\tx := []byte(\"foo\")\r\n\ty := []byte(\"foo\")\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tif !bytes.Equal(x, y) {\r\n\t\t\tb.Fail()\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunc BenchmarkStringCompare3(b *testing.B) {\r\n\tx := \"foo\"\r\n\ty := []byte(\"foo\")\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\tz := string(y)\r\n\t\tif x != z {\r\n\t\t\tb.Fail()\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n```\r\ngoos: windows\r\ngoarch: amd64\r\npkg: github.com/gofiber/fiber/v3\r\ncpu: Intel(R) Core(TM) i5-8250U CPU @ 1.60GHz\r\nBenchmarkStringCompare-8        1000000000               0.4974 ns/op          0 B/op          0 allocs/op\r\nBenchmarkStringCompare2-8       1000000000               0.5041 ns/op          0 B/op          0 allocs/op\r\nBenchmarkStringCompare3-8       87384075                12.57 ns/op            0 B/op          0 allocs/op\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1921084877",
    "pr_number": 3283,
    "pr_file": "middleware/cache/cache.go",
    "created_at": "2025-01-18T14:47:11+00:00",
    "commented_code": "\"Content-Encoding\":    nil, // already stored explicitly by the cache manager\n }\n \n+var cacheableStatusCodes = []int{",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1921084877",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3283,
        "pr_file": "middleware/cache/cache.go",
        "discussion_id": "1921084877",
        "commented_code": "@@ -48,6 +48,13 @@ var ignoreHeaders = map[string]any{\n \t\"Content-Encoding\":    nil, // already stored explicitly by the cache manager\n }\n \n+var cacheableStatusCodes = []int{",
        "comment_created_at": "2025-01-18T14:47:11+00:00",
        "comment_author": "gaby",
        "comment_body": "This should be a map, for o(1) lookups. Ex:\r\n\r\n```go\r\nvar cacheableStatusCodes = map[int]bool{\r\n    fiber.StatusOK:                          true,\r\n    fiber.StatusNonAuthoritativeInformation: true,\r\n    // etc...\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1921098614",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3283,
        "pr_file": "middleware/cache/cache.go",
        "discussion_id": "1921084877",
        "commented_code": "@@ -48,6 +48,13 @@ var ignoreHeaders = map[string]any{\n \t\"Content-Encoding\":    nil, // already stored explicitly by the cache manager\n }\n \n+var cacheableStatusCodes = []int{",
        "comment_created_at": "2025-01-18T16:10:34+00:00",
        "comment_author": "miyamo2",
        "comment_body": "Replaced to map instead of slice.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1780003888",
    "pr_number": 3016,
    "pr_file": "middleware/session/session.go",
    "created_at": "2024-09-29T10:00:14+00:00",
    "commented_code": "\"github.com/valyala/fasthttp\"\n )\n \n+// Session represents a user session.\n type Session struct {\n-\tctx        fiber.Ctx     // fiber context\n-\tconfig     *Store        // store configuration\n-\tdata       *data         // key value data\n-\tbyteBuffer *bytes.Buffer // byte buffer for the en- and decode\n-\tid         string        // session id\n-\texp        time.Duration // expiration of this session\n-\tmu         sync.RWMutex  // Mutex to protect non-data fields\n-\tfresh      bool          // if new session\n+\tctx         fiber.Ctx     // fiber context\n+\tconfig      *Store        // store configuration\n+\tdata        *data         // key value data\n+\tbyteBuffer  *bytes.Buffer // byte buffer for encoding/decoding",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1780003888",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/session/session.go",
        "discussion_id": "1780003888",
        "commented_code": "@@ -12,39 +12,78 @@ import (\n \t\"github.com/valyala/fasthttp\"\n )\n \n+// Session represents a user session.\n type Session struct {\n-\tctx        fiber.Ctx     // fiber context\n-\tconfig     *Store        // store configuration\n-\tdata       *data         // key value data\n-\tbyteBuffer *bytes.Buffer // byte buffer for the en- and decode\n-\tid         string        // session id\n-\texp        time.Duration // expiration of this session\n-\tmu         sync.RWMutex  // Mutex to protect non-data fields\n-\tfresh      bool          // if new session\n+\tctx         fiber.Ctx     // fiber context\n+\tconfig      *Store        // store configuration\n+\tdata        *data         // key value data\n+\tbyteBuffer  *bytes.Buffer // byte buffer for encoding/decoding",
        "comment_created_at": "2024-09-29T10:00:14+00:00",
        "comment_author": "efectn",
        "comment_body": "can we use bytebufferpool instead?",
        "pr_file_module": null
      },
      {
        "comment_id": "1782955710",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/session/session.go",
        "discussion_id": "1780003888",
        "commented_code": "@@ -12,39 +12,78 @@ import (\n \t\"github.com/valyala/fasthttp\"\n )\n \n+// Session represents a user session.\n type Session struct {\n-\tctx        fiber.Ctx     // fiber context\n-\tconfig     *Store        // store configuration\n-\tdata       *data         // key value data\n-\tbyteBuffer *bytes.Buffer // byte buffer for the en- and decode\n-\tid         string        // session id\n-\texp        time.Duration // expiration of this session\n-\tmu         sync.RWMutex  // Mutex to protect non-data fields\n-\tfresh      bool          // if new session\n+\tctx         fiber.Ctx     // fiber context\n+\tconfig      *Store        // store configuration\n+\tdata        *data         // key value data\n+\tbyteBuffer  *bytes.Buffer // byte buffer for encoding/decoding",
        "comment_created_at": "2024-10-01T14:19:11+00:00",
        "comment_author": "sixcolors",
        "comment_body": "*bytebufferpool.ByteBuffer does not implement io.Reader, so I would have to add a wrapper, however Session never releases the bytes.Buffer and simple calls Reset when it puts it in the Session sync.Pool, so I'm not sure it would be of significant advantage.",
        "pr_file_module": null
      },
      {
        "comment_id": "1784577189",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/session/session.go",
        "discussion_id": "1780003888",
        "commented_code": "@@ -12,39 +12,78 @@ import (\n \t\"github.com/valyala/fasthttp\"\n )\n \n+// Session represents a user session.\n type Session struct {\n-\tctx        fiber.Ctx     // fiber context\n-\tconfig     *Store        // store configuration\n-\tdata       *data         // key value data\n-\tbyteBuffer *bytes.Buffer // byte buffer for the en- and decode\n-\tid         string        // session id\n-\texp        time.Duration // expiration of this session\n-\tmu         sync.RWMutex  // Mutex to protect non-data fields\n-\tfresh      bool          // if new session\n+\tctx         fiber.Ctx     // fiber context\n+\tconfig      *Store        // store configuration\n+\tdata        *data         // key value data\n+\tbyteBuffer  *bytes.Buffer // byte buffer for encoding/decoding",
        "comment_created_at": "2024-10-02T13:55:12+00:00",
        "comment_author": "efectn",
        "comment_body": "> *bytebufferpool.ByteBuffer does not implement io.Reader, so I would have to add a wrapper, however Session never releases the bytes.Buffer and simple calls Reset when it puts it in the Session sync.Pool, so I'm not sure it would be of significant advantage.\r\n\r\nYeah but it's a little bit weird since it's a field of a struct. I think separate pool would be cleaner than making it a struct property",
        "pr_file_module": null
      },
      {
        "comment_id": "1784967581",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3016,
        "pr_file": "middleware/session/session.go",
        "discussion_id": "1780003888",
        "commented_code": "@@ -12,39 +12,78 @@ import (\n \t\"github.com/valyala/fasthttp\"\n )\n \n+// Session represents a user session.\n type Session struct {\n-\tctx        fiber.Ctx     // fiber context\n-\tconfig     *Store        // store configuration\n-\tdata       *data         // key value data\n-\tbyteBuffer *bytes.Buffer // byte buffer for the en- and decode\n-\tid         string        // session id\n-\texp        time.Duration // expiration of this session\n-\tmu         sync.RWMutex  // Mutex to protect non-data fields\n-\tfresh      bool          // if new session\n+\tctx         fiber.Ctx     // fiber context\n+\tconfig      *Store        // store configuration\n+\tdata        *data         // key value data\n+\tbyteBuffer  *bytes.Buffer // byte buffer for encoding/decoding",
        "comment_created_at": "2024-10-02T17:49:23+00:00",
        "comment_author": "sixcolors",
        "comment_body": "I removed the code from the Session struct and added a byteBufferPool for encoding and decoding operations. Since not every session will be stored (e.g. new sessions), this change saves time and memory. Tests comparing the old commit with the new one show approximately a 2.17% performance improvement on related benchmarks using this method. Thanks for the review!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1219281205",
    "pr_number": 2486,
    "pr_file": "helpers.go",
    "created_at": "2023-06-06T09:31:38+00:00",
    "commented_code": "return offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1219281205",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2486,
        "pr_file": "helpers.go",
        "discussion_id": "1219281205",
        "commented_code": "@@ -267,29 +268,111 @@ func getOffer(header string, isAccepted func(spec, offer string) bool, offers ..\n \t\treturn offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)",
        "comment_created_at": "2023-06-06T09:31:38+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "can we use syncPool to optimize the initialization?",
        "pr_file_module": null
      },
      {
        "comment_id": "1220387514",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2486,
        "pr_file": "helpers.go",
        "discussion_id": "1219281205",
        "commented_code": "@@ -267,29 +268,111 @@ func getOffer(header string, isAccepted func(spec, offer string) bool, offers ..\n \t\treturn offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)",
        "comment_created_at": "2023-06-06T21:25:46+00:00",
        "comment_author": "sixcolors",
        "comment_body": "It's slower and adds 2 allocs:\r\n\r\n<details>\r\n<summary>syncPool</summary>\r\n```console\r\n~/Documents/GitHub/sixcolors/fiber (2387-ctx-accepts-get-offer-q-and-specificity*) \u00bb go test -v -run=^$ -bench=Benchmark_Ctx_Accepts -benchmem -count=4\r\ngoos: darwin\r\ngoarch: arm64\r\npkg: github.com/gofiber/fiber/v2\r\nBenchmark_Ctx_Accepts\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            3662680               308.6 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            3888830               307.4 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            3836806               306.3 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            3864616               308.3 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     3338768               350.2 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     3397196               351.2 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     3334743               353.5 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     3366334               352.8 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             3876166               310.0 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             3752412               307.9 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             3703234               309.1 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             3796650               311.3 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets\r\nBenchmark_Ctx_AcceptsCharsets-12                                                         4684959               251.0 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets-12                                                         4563364               254.2 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets-12                                                         4649942               251.3 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets-12                                                         4701276               252.6 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings\r\nBenchmark_Ctx_AcceptsEncodings-12                                                        4154277               282.1 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings-12                                                        4155589               283.1 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings-12                                                        4226884               285.7 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings-12                                                        4220952               284.2 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        3340310               350.9 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        3328549               350.6 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        3369895               353.3 ns/op           920 B/op          2 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        3324868               352.1 ns/op           920 B/op          2 allocs/op\r\nPASS\r\nok      github.com/gofiber/fiber/v2     36.191s\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>`acceptedTypes := make([]acceptedType, 0, 20)`:</summary>\r\n```console\r\ngoos: darwin\r\ngoarch: arm64\r\npkg: github.com/gofiber/fiber/v2\r\nBenchmark_Ctx_Accepts\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            7756831               141.6 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            8427858               140.9 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            8356838               156.3 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\".xml\"}-12            8602822               139.1 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     6509782               183.1 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     6445286               184.8 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     6444319               184.9 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"json\",_\"xml\"}-12     6491694               185.3 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             8612815               139.2 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             8531341               139.0 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             8657082               141.0 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_Accepts/run-[]string{\"application/json\",_\"application/xml\"}-12             8553763               139.5 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets\r\nBenchmark_Ctx_AcceptsCharsets-12                                                        14816422                74.18 ns/op            0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets-12                                                        16124913                81.23 ns/op            0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets-12                                                        15506538                80.20 ns/op            0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsCharsets-12                                                        15934032                75.11 ns/op            0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings\r\nBenchmark_Ctx_AcceptsEncodings-12                                                       10669336               108.5 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings-12                                                       10658364               117.1 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings-12                                                       10817725               108.8 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsEncodings-12                                                       10624474               108.7 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        6412471               181.4 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        6546268               180.5 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        6572288               180.2 ns/op             0 B/op          0 allocs/op\r\nBenchmark_Ctx_AcceptsLanguages-12                                                        6550489               183.7 ns/op             0 B/op          0 allocs/op\r\nPASS\r\nok      github.com/gofiber/fiber/v2     32.400s\r\n```\r\n</details>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1219286853",
    "pr_number": 2486,
    "pr_file": "helpers.go",
    "created_at": "2023-06-06T09:34:43+00:00",
    "commented_code": "return offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)\n+\tfor len(header) > 0 {\n+\t\torder++\n+\n+\t\t// Skip spaces\n+\t\theader = utils.TrimLeft(header, ' ')\n+\n+\t\t// Get spec\n+\t\tcommaPos = strings.IndexByte(header, ',')\n+\t\tif commaPos != -1 {\n+\t\t\tspec = utils.Trim(header[:commaPos], ' ')\n+\t\t} else {\n+\t\t\tspec = utils.TrimLeft(header, ' ')\n+\t\t}\n+\n+\t\t// Get quality\n+\t\tquality := 1.0\n+\t\tif factorSign := strings.IndexByte(spec, ';'); factorSign != -1 {\n+\t\t\tfactor := utils.Trim(spec[factorSign+1:], ' ')\n+\t\t\tif strings.HasPrefix(factor, \"q=\") {\n+\t\t\t\tif q, err := strconv.ParseFloat(factor[2:], 64); err == nil {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1219286853",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2486,
        "pr_file": "helpers.go",
        "discussion_id": "1219286853",
        "commented_code": "@@ -267,29 +268,111 @@ func getOffer(header string, isAccepted func(spec, offer string) bool, offers ..\n \t\treturn offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)\n+\tfor len(header) > 0 {\n+\t\torder++\n+\n+\t\t// Skip spaces\n+\t\theader = utils.TrimLeft(header, ' ')\n+\n+\t\t// Get spec\n+\t\tcommaPos = strings.IndexByte(header, ',')\n+\t\tif commaPos != -1 {\n+\t\t\tspec = utils.Trim(header[:commaPos], ' ')\n+\t\t} else {\n+\t\t\tspec = utils.TrimLeft(header, ' ')\n+\t\t}\n+\n+\t\t// Get quality\n+\t\tquality := 1.0\n+\t\tif factorSign := strings.IndexByte(spec, ';'); factorSign != -1 {\n+\t\t\tfactor := utils.Trim(spec[factorSign+1:], ' ')\n+\t\t\tif strings.HasPrefix(factor, \"q=\") {\n+\t\t\t\tif q, err := strconv.ParseFloat(factor[2:], 64); err == nil {",
        "comment_created_at": "2023-06-06T09:34:43+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "can you test this\r\n\r\nhttps://github.com/valyala/fasthttp/blob/f0865d4aabbbea51a81d56ab31a3de2dfc5a9b05/bytesconv.go#LL201C15-L201C15\r\n\r\nmaybe its faster",
        "pr_file_module": null
      },
      {
        "comment_id": "1220149681",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2486,
        "pr_file": "helpers.go",
        "discussion_id": "1219286853",
        "commented_code": "@@ -267,29 +268,111 @@ func getOffer(header string, isAccepted func(spec, offer string) bool, offers ..\n \t\treturn offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)\n+\tfor len(header) > 0 {\n+\t\torder++\n+\n+\t\t// Skip spaces\n+\t\theader = utils.TrimLeft(header, ' ')\n+\n+\t\t// Get spec\n+\t\tcommaPos = strings.IndexByte(header, ',')\n+\t\tif commaPos != -1 {\n+\t\t\tspec = utils.Trim(header[:commaPos], ' ')\n+\t\t} else {\n+\t\t\tspec = utils.TrimLeft(header, ' ')\n+\t\t}\n+\n+\t\t// Get quality\n+\t\tquality := 1.0\n+\t\tif factorSign := strings.IndexByte(spec, ';'); factorSign != -1 {\n+\t\t\tfactor := utils.Trim(spec[factorSign+1:], ' ')\n+\t\t\tif strings.HasPrefix(factor, \"q=\") {\n+\t\t\t\tif q, err := strconv.ParseFloat(factor[2:], 64); err == nil {",
        "comment_created_at": "2023-06-06T18:49:21+00:00",
        "comment_author": "sixcolors",
        "comment_body": "seems to be",
        "pr_file_module": null
      },
      {
        "comment_id": "1220376566",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2486,
        "pr_file": "helpers.go",
        "discussion_id": "1219286853",
        "commented_code": "@@ -267,29 +268,111 @@ func getOffer(header string, isAccepted func(spec, offer string) bool, offers ..\n \t\treturn offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)\n+\tfor len(header) > 0 {\n+\t\torder++\n+\n+\t\t// Skip spaces\n+\t\theader = utils.TrimLeft(header, ' ')\n+\n+\t\t// Get spec\n+\t\tcommaPos = strings.IndexByte(header, ',')\n+\t\tif commaPos != -1 {\n+\t\t\tspec = utils.Trim(header[:commaPos], ' ')\n+\t\t} else {\n+\t\t\tspec = utils.TrimLeft(header, ' ')\n+\t\t}\n+\n+\t\t// Get quality\n+\t\tquality := 1.0\n+\t\tif factorSign := strings.IndexByte(spec, ';'); factorSign != -1 {\n+\t\t\tfactor := utils.Trim(spec[factorSign+1:], ' ')\n+\t\t\tif strings.HasPrefix(factor, \"q=\") {\n+\t\t\t\tif q, err := strconv.ParseFloat(factor[2:], 64); err == nil {",
        "comment_created_at": "2023-06-06T21:16:19+00:00",
        "comment_author": "ReneWerner87",
        "comment_body": "Can you try https://github.com/gofiber/fiber/blob/master/utils/convert_s2b_new.go#L11\n\nUnsafeBytes method instead of the other convert before you use the fasthttp method ",
        "pr_file_module": null
      },
      {
        "comment_id": "1220437815",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2486,
        "pr_file": "helpers.go",
        "discussion_id": "1219286853",
        "commented_code": "@@ -267,29 +268,111 @@ func getOffer(header string, isAccepted func(spec, offer string) bool, offers ..\n \t\treturn offers[0]\n \t}\n \n-\tfor _, offer := range offers {\n-\t\tif len(offer) == 0 {\n-\t\t\tcontinue\n+\ttype acceptedType struct {\n+\t\tspec        string\n+\t\tquality     float64\n+\t\tspecificity int\n+\t\torder       int\n+\t}\n+\n+\t// Parse header and get accepted types with their quality and specificity\n+\t// See: https://www.rfc-editor.org/rfc/rfc9110#name-content-negotiation-fields\n+\tspec, commaPos, order := \"\", 0, 0\n+\tacceptedTypes := make([]acceptedType, 0, 20)\n+\tfor len(header) > 0 {\n+\t\torder++\n+\n+\t\t// Skip spaces\n+\t\theader = utils.TrimLeft(header, ' ')\n+\n+\t\t// Get spec\n+\t\tcommaPos = strings.IndexByte(header, ',')\n+\t\tif commaPos != -1 {\n+\t\t\tspec = utils.Trim(header[:commaPos], ' ')\n+\t\t} else {\n+\t\t\tspec = utils.TrimLeft(header, ' ')\n+\t\t}\n+\n+\t\t// Get quality\n+\t\tquality := 1.0\n+\t\tif factorSign := strings.IndexByte(spec, ';'); factorSign != -1 {\n+\t\t\tfactor := utils.Trim(spec[factorSign+1:], ' ')\n+\t\t\tif strings.HasPrefix(factor, \"q=\") {\n+\t\t\t\tif q, err := strconv.ParseFloat(factor[2:], 64); err == nil {",
        "comment_created_at": "2023-06-06T22:08:26+00:00",
        "comment_author": "sixcolors",
        "comment_body": "UnsafeBytes works great!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1504281629",
    "pr_number": 2864,
    "pr_file": "middleware/cors/utils.go",
    "created_at": "2024-02-27T14:00:00+00:00",
    "commented_code": "package cors\n \n import (\n+\t\"net/url\"\n \t\"strings\"\n )\n \n+// matchScheme compares the scheme of the domain and pattern\n func matchScheme(domain, pattern string) bool {\n \tdidx := strings.Index(domain, \":\")\n \tpidx := strings.Index(pattern, \":\")\n \treturn didx != -1 && pidx != -1 && domain[:didx] == pattern[:pidx]\n }\n \n-// matchSubdomain compares authority with wildcard\n-func matchSubdomain(domain, pattern string) bool {\n-\tif !matchScheme(domain, pattern) {\n-\t\treturn false\n+// validateDomain checks if the domain matches the pattern\n+func validateDomain(domain, pattern string) bool {\n+\t// Directly compare the domain and pattern for an exact match.\n+\tif domain == pattern {\n+\t\treturn true\n \t}\n-\tdidx := strings.Index(domain, \"://\")\n-\tpidx := strings.Index(pattern, \"://\")\n-\tif didx == -1 || pidx == -1 {\n-\t\treturn false\n+\n+\t// Normalize domain and pattern to exclude schemes and ports for matching purposes\n+\tnormalizedDomain := normalizeDomain(domain)\n+\tnormalizedPattern := normalizeDomain(pattern)\n+\n+\t// Handling the case where pattern is a wildcard subdomain pattern.\n+\tif strings.HasPrefix(normalizedPattern, \"*.\") {\n+\t\t// Trim leading \"*.\" from pattern for comparison.\n+\t\ttrimmedPattern := normalizedPattern[2:]\n+\n+\t\t// Check if the domain ends with the trimmed pattern.\n+\t\tif strings.HasSuffix(normalizedDomain, trimmedPattern) {\n+\t\t\t// Ensure that the domain is not exactly the base domain.\n+\t\t\tif normalizedDomain != trimmedPattern {\n+\t\t\t\t// Special handling to prevent \"example.com\" matching \"*.example.com\".\n+\t\t\t\tif strings.TrimSuffix(normalizedDomain, trimmedPattern) != \"\" {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n-\tdomAuth := domain[didx+3:]\n-\t// to avoid long loop by invalid long domain\n-\tconst maxDomainLen = 253\n-\tif len(domAuth) > maxDomainLen {\n-\t\treturn false\n+\n+\treturn false\n+}\n+\n+// normalizeDomain removes the scheme and port from the input domain\n+func normalizeDomain(input string) string {\n+\t// Remove scheme\n+\tinput = strings.TrimPrefix(strings.TrimPrefix(input, \"http://\"), \"https://\")\n+\n+\t// Find and remove port, if present\n+\tif len(input) > 0 && input[0] != '[' {\n+\t\tif portIndex := strings.Index(input, \":\"); portIndex != -1 {\n+\t\t\tinput = input[:portIndex]\n+\t\t}\n \t}\n-\tpatAuth := pattern[pidx+3:]\n-\n-\tdomComp := strings.Split(domAuth, \".\")\n-\tpatComp := strings.Split(patAuth, \".\")\n-\tconst divHalf = 2\n-\tfor i := len(domComp)/divHalf - 1; i >= 0; i-- {\n-\t\topp := len(domComp) - 1 - i\n-\t\tdomComp[i], domComp[opp] = domComp[opp], domComp[i]\n+\n+\treturn input\n+}\n+\n+// normalizeOrigin checks if the provided origin is in a correct format\n+// and normalizes it by removing any path or trailing slash.\n+// It returns a boolean indicating whether the origin is valid\n+// and the normalized origin.\n+func normalizeOrigin(origin string) (bool, string) {\n+\tparsedOrigin, err := url.Parse(origin)\n+\tif err != nil {\n+\t\treturn false, \"\"\n \t}\n-\tfor i := len(patComp)/divHalf - 1; i >= 0; i-- {\n-\t\topp := len(patComp) - 1 - i\n-\t\tpatComp[i], patComp[opp] = patComp[opp], patComp[i]\n+\n+\t// Validate the scheme is either http or https\n+\tif parsedOrigin.Scheme != \"http\" && parsedOrigin.Scheme != \"https\" {\n+\t\treturn false, \"\"\n \t}\n \n-\tfor i, v := range domComp {\n-\t\tif len(patComp) <= i {\n-\t\t\treturn false\n-\t\t}\n-\t\tp := patComp[i]\n-\t\tif p == \"*\" {\n-\t\t\treturn true\n-\t\t}\n-\t\tif p != v {\n-\t\t\treturn false\n-\t\t}\n+\t// Validate there is a host present. The presence of a path, query, or fragment components\n+\t// is checked, but a trailing \"/\" (indicative of the root) is allowed for the path and will be normalized\n+\tif parsedOrigin.Host == \"\" || (parsedOrigin.Path != \"\" && parsedOrigin.Path != \"/\") || parsedOrigin.RawQuery != \"\" || parsedOrigin.Fragment != \"\" {\n+\t\treturn false, \"\"\n \t}\n-\treturn false\n+\n+\t// Normalize the origin by constructing it from the scheme and host.\n+\t// The path or trailing slash is not included in the normalized origin.\n+\treturn true, strings.ToLower(parsedOrigin.Scheme) + \"://\" + strings.ToLower(parsedOrigin.Host)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1504281629",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2864,
        "pr_file": "middleware/cors/utils.go",
        "discussion_id": "1504281629",
        "commented_code": "@@ -1,56 +1,85 @@\n package cors\n \n import (\n+\t\"net/url\"\n \t\"strings\"\n )\n \n+// matchScheme compares the scheme of the domain and pattern\n func matchScheme(domain, pattern string) bool {\n \tdidx := strings.Index(domain, \":\")\n \tpidx := strings.Index(pattern, \":\")\n \treturn didx != -1 && pidx != -1 && domain[:didx] == pattern[:pidx]\n }\n \n-// matchSubdomain compares authority with wildcard\n-func matchSubdomain(domain, pattern string) bool {\n-\tif !matchScheme(domain, pattern) {\n-\t\treturn false\n+// validateDomain checks if the domain matches the pattern\n+func validateDomain(domain, pattern string) bool {\n+\t// Directly compare the domain and pattern for an exact match.\n+\tif domain == pattern {\n+\t\treturn true\n \t}\n-\tdidx := strings.Index(domain, \"://\")\n-\tpidx := strings.Index(pattern, \"://\")\n-\tif didx == -1 || pidx == -1 {\n-\t\treturn false\n+\n+\t// Normalize domain and pattern to exclude schemes and ports for matching purposes\n+\tnormalizedDomain := normalizeDomain(domain)\n+\tnormalizedPattern := normalizeDomain(pattern)\n+\n+\t// Handling the case where pattern is a wildcard subdomain pattern.\n+\tif strings.HasPrefix(normalizedPattern, \"*.\") {\n+\t\t// Trim leading \"*.\" from pattern for comparison.\n+\t\ttrimmedPattern := normalizedPattern[2:]\n+\n+\t\t// Check if the domain ends with the trimmed pattern.\n+\t\tif strings.HasSuffix(normalizedDomain, trimmedPattern) {\n+\t\t\t// Ensure that the domain is not exactly the base domain.\n+\t\t\tif normalizedDomain != trimmedPattern {\n+\t\t\t\t// Special handling to prevent \"example.com\" matching \"*.example.com\".\n+\t\t\t\tif strings.TrimSuffix(normalizedDomain, trimmedPattern) != \"\" {\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n-\tdomAuth := domain[didx+3:]\n-\t// to avoid long loop by invalid long domain\n-\tconst maxDomainLen = 253\n-\tif len(domAuth) > maxDomainLen {\n-\t\treturn false\n+\n+\treturn false\n+}\n+\n+// normalizeDomain removes the scheme and port from the input domain\n+func normalizeDomain(input string) string {\n+\t// Remove scheme\n+\tinput = strings.TrimPrefix(strings.TrimPrefix(input, \"http://\"), \"https://\")\n+\n+\t// Find and remove port, if present\n+\tif len(input) > 0 && input[0] != '[' {\n+\t\tif portIndex := strings.Index(input, \":\"); portIndex != -1 {\n+\t\t\tinput = input[:portIndex]\n+\t\t}\n \t}\n-\tpatAuth := pattern[pidx+3:]\n-\n-\tdomComp := strings.Split(domAuth, \".\")\n-\tpatComp := strings.Split(patAuth, \".\")\n-\tconst divHalf = 2\n-\tfor i := len(domComp)/divHalf - 1; i >= 0; i-- {\n-\t\topp := len(domComp) - 1 - i\n-\t\tdomComp[i], domComp[opp] = domComp[opp], domComp[i]\n+\n+\treturn input\n+}\n+\n+// normalizeOrigin checks if the provided origin is in a correct format\n+// and normalizes it by removing any path or trailing slash.\n+// It returns a boolean indicating whether the origin is valid\n+// and the normalized origin.\n+func normalizeOrigin(origin string) (bool, string) {\n+\tparsedOrigin, err := url.Parse(origin)\n+\tif err != nil {\n+\t\treturn false, \"\"\n \t}\n-\tfor i := len(patComp)/divHalf - 1; i >= 0; i-- {\n-\t\topp := len(patComp) - 1 - i\n-\t\tpatComp[i], patComp[opp] = patComp[opp], patComp[i]\n+\n+\t// Validate the scheme is either http or https\n+\tif parsedOrigin.Scheme != \"http\" && parsedOrigin.Scheme != \"https\" {\n+\t\treturn false, \"\"\n \t}\n \n-\tfor i, v := range domComp {\n-\t\tif len(patComp) <= i {\n-\t\t\treturn false\n-\t\t}\n-\t\tp := patComp[i]\n-\t\tif p == \"*\" {\n-\t\t\treturn true\n-\t\t}\n-\t\tif p != v {\n-\t\t\treturn false\n-\t\t}\n+\t// Validate there is a host present. The presence of a path, query, or fragment components\n+\t// is checked, but a trailing \"/\" (indicative of the root) is allowed for the path and will be normalized\n+\tif parsedOrigin.Host == \"\" || (parsedOrigin.Path != \"\" && parsedOrigin.Path != \"/\") || parsedOrigin.RawQuery != \"\" || parsedOrigin.Fragment != \"\" {\n+\t\treturn false, \"\"\n \t}\n-\treturn false\n+\n+\t// Normalize the origin by constructing it from the scheme and host.\n+\t// The path or trailing slash is not included in the normalized origin.\n+\treturn true, strings.ToLower(parsedOrigin.Scheme) + \"://\" + strings.ToLower(parsedOrigin.Host)",
        "comment_created_at": "2024-02-27T14:00:00+00:00",
        "comment_author": "renanbastos93",
        "comment_body": "Here we can reduce processing from the CPU.\r\n```suggestion\r\n\treturn true, strings.ToLower(parsedOrigin.Scheme + \"://\" + parsedOrigin.Host)\r\n```\r\n\r\nbenchmark:\r\n```\r\n// BenchmarkBothLower-8   \t16690329\t        62.00 ns/op\t      32 B/op\t       1 allocs/op\r\n// BenchmarkOneLower-8   \t22892752\t        50.97 ns/op\t       0 B/op\t       0 allocs/op\r\n```\r\n\r\ncode\r\n```go\r\nfunc bothLower(scheme, domain string) string {\r\n\treturn strings.ToLower(scheme) + \"://\" + strings.ToLower(domain)\r\n}\r\n\r\nfunc oneLower(scheme, domain string) string {\r\n\treturn strings.ToLower(scheme + \"://\" + domain)\r\n}\r\n\r\nfunc BenchmarkBothLower(b *testing.B) {\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t_ = bothLower(\"https\", \"renanbastos.com.br\")\r\n\t}\r\n}\r\n\r\nfunc BenchmarkOneLower(b *testing.B) {\r\n\tb.ResetTimer()\r\n\tfor i := 0; i < b.N; i++ {\r\n\t\t_ = oneLower(\"https\", \"renanbastos.com.br\")\r\n\t}\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1429596923",
    "pr_number": 2766,
    "pr_file": "ctx.go",
    "created_at": "2023-12-18T07:30:30+00:00",
    "commented_code": "return &c.fasthttp.Response\n }\n \n+type Fmt struct {\n+\tMediaType string\n+\tHandler   func(Ctx) error\n+}\n+\n // Format performs content-negotiation on the Accept HTTP header.\n+// It uses Accepts to select a proper format and calls the matching\n+// user-provided handler function.\n+// If no accepted format is found, and a format with MediaType \"default\" is given,\n+// that default handler is called. If no format is found and no default is given,\n+// StatusNotAcceptable is sent.\n+func (c *DefaultCtx) Format(handlers ...Fmt) error {\n+\tif len(handlers) == 0 {\n+\t\tpanic(\"Format requires at least one handler\")\n+\t}\n+\n+\tif c.Get(HeaderAccept) == \"\" {\n+\t\tc.Response().Header.SetContentType(handlers[0].MediaType)\n+\t\treturn handlers[0].Handler(c)\n+\t}\n+\n+\ttypes := make([]string, 0, 8)",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1429596923",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2766,
        "pr_file": "ctx.go",
        "discussion_id": "1429596923",
        "commented_code": "@@ -370,10 +371,60 @@ func (c *DefaultCtx) Response() *fasthttp.Response {\n \treturn &c.fasthttp.Response\n }\n \n+type Fmt struct {\n+\tMediaType string\n+\tHandler   func(Ctx) error\n+}\n+\n // Format performs content-negotiation on the Accept HTTP header.\n+// It uses Accepts to select a proper format and calls the matching\n+// user-provided handler function.\n+// If no accepted format is found, and a format with MediaType \"default\" is given,\n+// that default handler is called. If no format is found and no default is given,\n+// StatusNotAcceptable is sent.\n+func (c *DefaultCtx) Format(handlers ...Fmt) error {\n+\tif len(handlers) == 0 {\n+\t\tpanic(\"Format requires at least one handler\")\n+\t}\n+\n+\tif c.Get(HeaderAccept) == \"\" {\n+\t\tc.Response().Header.SetContentType(handlers[0].MediaType)\n+\t\treturn handlers[0].Handler(c)\n+\t}\n+\n+\ttypes := make([]string, 0, 8)",
        "comment_created_at": "2023-12-18T07:30:30+00:00",
        "comment_author": "efectn",
        "comment_body": "Why was capacity set as 8?",
        "pr_file_module": null
      },
      {
        "comment_id": "1430343720",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2766,
        "pr_file": "ctx.go",
        "discussion_id": "1429596923",
        "commented_code": "@@ -370,10 +371,60 @@ func (c *DefaultCtx) Response() *fasthttp.Response {\n \treturn &c.fasthttp.Response\n }\n \n+type Fmt struct {\n+\tMediaType string\n+\tHandler   func(Ctx) error\n+}\n+\n // Format performs content-negotiation on the Accept HTTP header.\n+// It uses Accepts to select a proper format and calls the matching\n+// user-provided handler function.\n+// If no accepted format is found, and a format with MediaType \"default\" is given,\n+// that default handler is called. If no format is found and no default is given,\n+// StatusNotAcceptable is sent.\n+func (c *DefaultCtx) Format(handlers ...Fmt) error {\n+\tif len(handlers) == 0 {\n+\t\tpanic(\"Format requires at least one handler\")\n+\t}\n+\n+\tif c.Get(HeaderAccept) == \"\" {\n+\t\tc.Response().Header.SetContentType(handlers[0].MediaType)\n+\t\treturn handlers[0].Handler(c)\n+\t}\n+\n+\ttypes := make([]string, 0, 8)",
        "comment_created_at": "2023-12-18T15:57:45+00:00",
        "comment_author": "sixcolors",
        "comment_body": "My guess to avoid runtime allocs if it's under 8, which is probably a reasonable limit",
        "pr_file_module": null
      },
      {
        "comment_id": "1430386080",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2766,
        "pr_file": "ctx.go",
        "discussion_id": "1429596923",
        "commented_code": "@@ -370,10 +371,60 @@ func (c *DefaultCtx) Response() *fasthttp.Response {\n \treturn &c.fasthttp.Response\n }\n \n+type Fmt struct {\n+\tMediaType string\n+\tHandler   func(Ctx) error\n+}\n+\n // Format performs content-negotiation on the Accept HTTP header.\n+// It uses Accepts to select a proper format and calls the matching\n+// user-provided handler function.\n+// If no accepted format is found, and a format with MediaType \"default\" is given,\n+// that default handler is called. If no format is found and no default is given,\n+// StatusNotAcceptable is sent.\n+func (c *DefaultCtx) Format(handlers ...Fmt) error {\n+\tif len(handlers) == 0 {\n+\t\tpanic(\"Format requires at least one handler\")\n+\t}\n+\n+\tif c.Get(HeaderAccept) == \"\" {\n+\t\tc.Response().Header.SetContentType(handlers[0].MediaType)\n+\t\treturn handlers[0].Handler(c)\n+\t}\n+\n+\ttypes := make([]string, 0, 8)",
        "comment_created_at": "2023-12-18T16:34:00+00:00",
        "comment_author": "efectn",
        "comment_body": "> My guess to avoid runtime allocs if it's under 8, which is probably a reasonable limit\r\n\r\nYeah probably. It would be really nice if he adds a comment.",
        "pr_file_module": null
      },
      {
        "comment_id": "1430437750",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2766,
        "pr_file": "ctx.go",
        "discussion_id": "1429596923",
        "commented_code": "@@ -370,10 +371,60 @@ func (c *DefaultCtx) Response() *fasthttp.Response {\n \treturn &c.fasthttp.Response\n }\n \n+type Fmt struct {\n+\tMediaType string\n+\tHandler   func(Ctx) error\n+}\n+\n // Format performs content-negotiation on the Accept HTTP header.\n+// It uses Accepts to select a proper format and calls the matching\n+// user-provided handler function.\n+// If no accepted format is found, and a format with MediaType \"default\" is given,\n+// that default handler is called. If no format is found and no default is given,\n+// StatusNotAcceptable is sent.\n+func (c *DefaultCtx) Format(handlers ...Fmt) error {\n+\tif len(handlers) == 0 {\n+\t\tpanic(\"Format requires at least one handler\")\n+\t}\n+\n+\tif c.Get(HeaderAccept) == \"\" {\n+\t\tc.Response().Header.SetContentType(handlers[0].MediaType)\n+\t\treturn handlers[0].Handler(c)\n+\t}\n+\n+\ttypes := make([]string, 0, 8)",
        "comment_created_at": "2023-12-18T17:09:04+00:00",
        "comment_author": "nickajacks1",
        "comment_body": "using a static size allows stack allocation, and 8 is an approximation of how many content types a user might use. The number was selected completely arbitrarily.  Even though it's stack allocated, making the slice bigger makes it slower in general.  I'll add this info as a comment as suggested",
        "pr_file_module": null
      }
    ]
  }
]