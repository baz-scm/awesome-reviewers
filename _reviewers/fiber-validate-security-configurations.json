[
  {
    "discussion_id": "2217080815",
    "pr_number": 3598,
    "pr_file": "docs/middleware/csrf.md",
    "created_at": "2025-07-19T14:05:38+00:00",
    "commented_code": "# CSRF\n \n-The CSRF middleware for [Fiber](https://github.com/gofiber/fiber) provides protection against [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) (CSRF) attacks. Requests made using methods other than those defined as 'safe' by [RFC9110#section-9.2.1](https://datatracker.ietf.org/doc/html/rfc9110.html#section-9.2.1) (GET, HEAD, OPTIONS, and TRACE) are validated using tokens. If a potential attack is detected, the middleware will return a default 403 Forbidden error.\n+The CSRF middleware provides protection against [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks. It validates tokens on unsafe HTTP methods (POST, PUT, DELETE, etc.) and returns 403 Forbidden if an attack is detected.\n \n-This middleware offers two [Token Validation Patterns](#token-validation-patterns): the [Double Submit Cookie Pattern (default)](#double-submit-cookie-pattern-default), and the [Synchronizer Token Pattern (with Session)](#synchronizer-token-pattern-with-session).\n-\n-As a [Defense In Depth](#defense-in-depth) measure, this middleware performs [Referer Checking](#referer-checking) for HTTPS requests.\n-\n-## How to use Fiber's CSRF Middleware\n-\n-## Examples\n-\n-Import the middleware package that is part of the Fiber web framework:\n+## Quick Start\n \n ```go\n import (\n     \"github.com/gofiber/fiber/v3\"\n     \"github.com/gofiber/fiber/v3/middleware/csrf\"\n )\n+\n+// Default config (development only)\n+app.Use(csrf.New())\n+\n+// Production config\n+app.Use(csrf.New(csrf.Config{\n+    CookieName:        \"__Host-csrf_\",\n+    CookieSecure:      true,\n+    CookieHTTPOnly:    true,  // false for SPAs\n+    CookieSameSite:    \"Lax\",\n+    CookieSessionOnly: true,\n+    Extractor:         csrf.FromHeader(\"X-Csrf-Token\"),",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "2217327974",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3598,
        "pr_file": "docs/middleware/csrf.md",
        "discussion_id": "2217080815",
        "commented_code": "@@ -4,209 +4,318 @@ id: csrf\n \n # CSRF\n \n-The CSRF middleware for [Fiber](https://github.com/gofiber/fiber) provides protection against [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) (CSRF) attacks. Requests made using methods other than those defined as 'safe' by [RFC9110#section-9.2.1](https://datatracker.ietf.org/doc/html/rfc9110.html#section-9.2.1) (GET, HEAD, OPTIONS, and TRACE) are validated using tokens. If a potential attack is detected, the middleware will return a default 403 Forbidden error.\n+The CSRF middleware provides protection against [Cross-Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks. It validates tokens on unsafe HTTP methods (POST, PUT, DELETE, etc.) and returns 403 Forbidden if an attack is detected.\n \n-This middleware offers two [Token Validation Patterns](#token-validation-patterns): the [Double Submit Cookie Pattern (default)](#double-submit-cookie-pattern-default), and the [Synchronizer Token Pattern (with Session)](#synchronizer-token-pattern-with-session).\n-\n-As a [Defense In Depth](#defense-in-depth) measure, this middleware performs [Referer Checking](#referer-checking) for HTTPS requests.\n-\n-## How to use Fiber's CSRF Middleware\n-\n-## Examples\n-\n-Import the middleware package that is part of the Fiber web framework:\n+## Quick Start\n \n ```go\n import (\n     \"github.com/gofiber/fiber/v3\"\n     \"github.com/gofiber/fiber/v3/middleware/csrf\"\n )\n+\n+// Default config (development only)\n+app.Use(csrf.New())\n+\n+// Production config\n+app.Use(csrf.New(csrf.Config{\n+    CookieName:        \"__Host-csrf_\",\n+    CookieSecure:      true,\n+    CookieHTTPOnly:    true,  // false for SPAs\n+    CookieSameSite:    \"Lax\",\n+    CookieSessionOnly: true,\n+    Extractor:         csrf.FromHeader(\"X-Csrf-Token\"),",
        "comment_created_at": "2025-07-19T14:05:38+00:00",
        "comment_author": "sixcolors",
        "comment_body": "no because `fiber.CookieSameSiteLaxMode == \"lax\"` not `\"Lax\"`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1661061051",
    "pr_number": 3056,
    "pr_file": "docs/middleware/encryptcookie.md",
    "created_at": "2024-07-01T13:30:18+00:00",
    "commented_code": "// Intitializes the middleware\n func New(config ...Config) fiber.Handler\n \n-// Returns a random 32 character long string\n-func GenerateKey() string\n+// Returns a random 16, 24, 32 bytes encoded string\n+func GenerateKey(length) string",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1661061051",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3056,
        "pr_file": "docs/middleware/encryptcookie.md",
        "discussion_id": "1661061051",
        "commented_code": "@@ -16,8 +16,8 @@ This middleware encrypts cookie values and not the cookie names.\n // Intitializes the middleware\n func New(config ...Config) fiber.Handler\n \n-// Returns a random 32 character long string\n-func GenerateKey() string\n+// Returns a random 16, 24, 32 bytes encoded string\n+func GenerateKey(length) string",
        "comment_created_at": "2024-07-01T13:30:18+00:00",
        "comment_author": "sixcolors",
        "comment_body": "\n```suggestion\n// GenerateKey returns a random string of 16, 24, or 32 bytes.\n// The length of the key determines the AES encryption algorithm used:\n// 16 bytes for AES-128, 24 bytes for AES-192, and 32 bytes for AES-256-GCM.\nfunc GenerateKey(length) string\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1661064695",
    "pr_number": 3056,
    "pr_file": "docs/middleware/encryptcookie.md",
    "created_at": "2024-07-01T13:32:37+00:00",
    "commented_code": "```\n \n :::note\n-`Key` must be a 32 character string. It's used to encrypt the values, so make sure it is random and keep it secret.\n-You can run `openssl rand -base64 32` or call `encryptcookie.GenerateKey()` to create a random key for you.\n-Make sure not to set `Key` to `encryptcookie.GenerateKey()` because that will create a new key every run.\n+`Key` must be a 16, 24, or 32 bytes encoded string. It's used to encrypt the values, so make sure it is random and keep it secret.\n+For example, you can run `openssl rand -base64 32` or call `encryptcookie.GenerateKey(32)` to create a random key for you.\n+Make sure not to set `Key` to `encryptcookie.GenerateKey(32)` because that will create a new key every run of the application.\n :::",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1661064695",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3056,
        "pr_file": "docs/middleware/encryptcookie.md",
        "discussion_id": "1661064695",
        "commented_code": "@@ -55,9 +55,9 @@ app.Post(\"/\", func(c fiber.Ctx) error {\n ```\n \n :::note\n-`Key` must be a 32 character string. It's used to encrypt the values, so make sure it is random and keep it secret.\n-You can run `openssl rand -base64 32` or call `encryptcookie.GenerateKey()` to create a random key for you.\n-Make sure not to set `Key` to `encryptcookie.GenerateKey()` because that will create a new key every run.\n+`Key` must be a 16, 24, or 32 bytes encoded string. It's used to encrypt the values, so make sure it is random and keep it secret.\n+For example, you can run `openssl rand -base64 32` or call `encryptcookie.GenerateKey(32)` to create a random key for you.\n+Make sure not to set `Key` to `encryptcookie.GenerateKey(32)` because that will create a new key every run of the application.\n :::",
        "comment_created_at": "2024-07-01T13:32:37+00:00",
        "comment_author": "sixcolors",
        "comment_body": "\n```suggestion\n:::note\nThe `Key` parameter requires an encoded string of 16, 24, or 32 bytes for encryption, corresponding to AES-128, AES-192, and AES-256-GCM standards, respectively. Ensure the key is randomly generated and securely stored.\n\nTo generate a 32 char key, use `openssl rand -base64 32` or `encryptcookie.GenerateKey(32)`. Avoid dynamically generating a new `Key` with `encryptcookie.GenerateKey(32)` at each application startup to prevent rendering previously encrypted data inaccessible.\n:::\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1527175617",
    "pr_number": 2915,
    "pr_file": "docs/api/middleware/cors.md",
    "created_at": "2024-03-16T14:05:12+00:00",
    "commented_code": "MaxAge:           0,\n }\n ```\n+\n+## Subdomain Matching  \n+\n+The `AllowOrigins` configuration supports matching subdomains at any level. This means you can use a value like `\"https://*.example.com\"` to allow any subdomain of `example.com` to submit requests, including multiple subdomain levels such as `\"https://sub.sub.example.com\"`.\n+\n+### Example  \n+\n+If you want to allow CORS requests from any subdomain of `example.com`, including nested subdomains, you can configure the `AllowOrigins` like so:",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1527178355",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2915,
        "pr_file": "docs/api/middleware/cors.md",
        "discussion_id": "1527175617",
        "commented_code": "@@ -101,3 +83,71 @@\n \tMaxAge:           0,\n }\n ```\n+\n+## Subdomain Matching  \n+\n+The `AllowOrigins` configuration supports matching subdomains at any level. This means you can use a value like `\"https://*.example.com\"` to allow any subdomain of `example.com` to submit requests, including multiple subdomain levels such as `\"https://sub.sub.example.com\"`.\n+\n+### Example  \n+\n+If you want to allow CORS requests from any subdomain of `example.com`, including nested subdomains, you can configure the `AllowOrigins` like so:  ",
        "comment_created_at": "2024-03-16T14:05:12+00:00",
        "comment_author": "sixcolors",
        "comment_body": "The example I removed was the AllowOriginsFunc example",
        "pr_file_module": null
      },
      {
        "comment_id": "1527182005",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2915,
        "pr_file": "docs/api/middleware/cors.md",
        "discussion_id": "1527175617",
        "commented_code": "@@ -101,3 +83,71 @@\n \tMaxAge:           0,\n }\n ```\n+\n+## Subdomain Matching  \n+\n+The `AllowOrigins` configuration supports matching subdomains at any level. This means you can use a value like `\"https://*.example.com\"` to allow any subdomain of `example.com` to submit requests, including multiple subdomain levels such as `\"https://sub.sub.example.com\"`.\n+\n+### Example  \n+\n+If you want to allow CORS requests from any subdomain of `example.com`, including nested subdomains, you can configure the `AllowOrigins` like so:  ",
        "comment_created_at": "2024-03-16T14:33:12+00:00",
        "comment_author": "sixcolors",
        "comment_body": "The example I removed would create an effective wildcard match, which would bypass the prohibition on wildcard origins with AllowCredentials = true.\r\n\r\n ```go\r\n app.Use(cors.New())\r\n\r\n app.Use(cors.New(cors.Config{\r\n     AllowOriginsFunc: func(origin string) bool {\r\n         return os.Getenv(\"ENVIRONMENT\") == \"development\"\r\n     },\r\n }))\r\n ```\r\n \r\nIn my opinion, the AllowOriginsFunc is a dangerous feature, and only individuals with specific needs and a thorough understanding of its implications should use it. The security considerations outlined in the documentation, along with the notes in the configuration options, should be enough to caution users about the potential dangers. Including a basic example of this feature, especially an insecure one, will cause more harm than good.\r\n\r\nUsing a database to look up the origins is a more secure example and a valid use case for this feature. However, including too much information in the documentation can be overwhelming for junior developers and cause them to miss more important notes.",
        "pr_file_module": null
      },
      {
        "comment_id": "1527182341",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2915,
        "pr_file": "docs/api/middleware/cors.md",
        "discussion_id": "1527175617",
        "commented_code": "@@ -101,3 +83,71 @@\n \tMaxAge:           0,\n }\n ```\n+\n+## Subdomain Matching  \n+\n+The `AllowOrigins` configuration supports matching subdomains at any level. This means you can use a value like `\"https://*.example.com\"` to allow any subdomain of `example.com` to submit requests, including multiple subdomain levels such as `\"https://sub.sub.example.com\"`.\n+\n+### Example  \n+\n+If you want to allow CORS requests from any subdomain of `example.com`, including nested subdomains, you can configure the `AllowOrigins` like so:  ",
        "comment_created_at": "2024-03-16T14:35:57+00:00",
        "comment_author": "sixcolors",
        "comment_body": "Sure, suggest an example for using the AllowOriginsFunc using a DB to match AllowedOrigins, make sure it's secure and not overwhelming.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1504271605",
    "pr_number": 2864,
    "pr_file": "docs/api/middleware/encryptcookie.md",
    "created_at": "2024-02-27T13:53:30+00:00",
    "commented_code": "})\n ```\n \n+:::note\n+`Key` must be a 32 character string. It's used to encrypt the values, so make sure it is random and keep it secret.\n+You can run `openssl rand -base64 32` or call `encryptcookie.GenerateKey()` to create a random key for you.\n+Make sure not to set `Key` to `encryptcookie.GenerateKey()` because that will create a new key every run.\n+:::\n+\n ## Config\n \n-<<<<<<< HEAD:middleware/encryptcookie/README.md\n-```go\n-type Config struct {\n-\t// Next defines a function to skip this middleware when returned true.\n-\t//\n-\t// Optional. Default: nil\n-\tNext func(c fiber.Ctx) bool\n-\n-\t// Array of cookie keys that should not be encrypted.\n-\t//\n-\t// Optional. Default: [\"csrf_\"]\n-\tExcept []string\n-\n-\t// Base64 encoded unique key to encode & decode cookies.\n-\t//\n-\t// Required. The key should be 32 bytes of random data in base64-encoded form.\n-\t// You may run `openssl rand -base64 32` or use `encryptcookie.GenerateKey()` to generate a new key.\n-\tKey string\n-\n-\t// Custom function to encrypt cookies.\n-\t//\n-\t// Optional. Default: EncryptCookie\n-\tEncryptor func(decryptedString, key string) (string, error)\n-\n-\t// Custom function to decrypt cookies.\n-\t//\n-\t// Optional. Default: DecryptCookie\n-\tDecryptor func(encryptedString, key string) (string, error)\n-}\n-```\n-=======\n-| Property  | Type                                                | Description                                                                                         | Default                      |\n-|:----------|:----------------------------------------------------|:----------------------------------------------------------------------------------------------------|:-----------------------------|\n-| Next      | `func(fiber.Ctx) bool`                             | Next defines a function to skip this middleware when returned true.                                 | `nil`                        |\n-| Except    | `[]string`                                          | Array of cookie keys that should not be encrypted.                                                  | `[]`                         |\n-| Key       | `string`                                            | Base64 encoded unique key to encode & decode cookies. Required. Key length should be 32 characters. | (No default, required field) |\n-| Encryptor | `func(decryptedString, key string) (string, error)` | Custom function to encrypt cookies.                                                                 | `EncryptCookie`              |\n-| Decryptor | `func(encryptedString, key string) (string, error)` | Custom function to decrypt cookies.                                                                 | `DecryptCookie`              |\n->>>>>>> origin/master:docs/api/middleware/encryptcookie.md\n+| Property  | Type                                                | Description                                                                                           | Default                      |\n+|:----------|:----------------------------------------------------|:------------------------------------------------------------------------------------------------------|:-----------------------------|\n+| Next      | `func(fiber.Ctx) bool`                             | A function to skip this middleware when returned true.                                                | `nil`                        |\n+| Except    | `[]string`                                          | Array of cookie keys that should not be encrypted.                                                    | `[]`                         |\n+| Key       | `string`                                            | A base64-encoded unique key to encode & decode cookies. Required. Key length should be 32 characters. | (No default, required field) |\n+| Encryptor | `func(decryptedString, key string) (string, error)` | A custom function to encrypt cookies.                                                                 | `EncryptCookie`              |\n+| Decryptor | `func(encryptedString, key string) (string, error)` | A custom function to decrypt cookies.                                                                 | `DecryptCookie`              |\n \n ## Default Config\n \n ```go\n var ConfigDefault = Config{\n \tNext:      nil,\n-\tExcept:    []string{\"csrf_\"},\n+\tExcept:    []string{},\n \tKey:       \"\",\n \tEncryptor: EncryptCookie,\n \tDecryptor: DecryptCookie,\n }\n ```\n \n-## Usage of CSRF and Encryptcookie Middlewares with Custom Cookie Names\n-Normally, encryptcookie middleware skips `csrf_` cookies. However, it won't work when you use custom cookie names for CSRF. You should update `Except` config to avoid this problem. For example:\n+## Usage With Other Middlewares That Reads Or Modify Cookies\n+Place the encryptcookie middleware before any other middleware that reads or modifies cookies. For example, if you are using the CSRF middleware, ensure that the encryptcookie middleware is placed before it. Failure to do so may prevent the CSRF middleware from reading the encrypted cookie.",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1504271605",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 2864,
        "pr_file": "docs/api/middleware/encryptcookie.md",
        "discussion_id": "1504271605",
        "commented_code": "@@ -53,71 +54,48 @@ app.Post(\"/\", func(c fiber.Ctx) error {\n })\n ```\n \n+:::note\n+`Key` must be a 32 character string. It's used to encrypt the values, so make sure it is random and keep it secret.\n+You can run `openssl rand -base64 32` or call `encryptcookie.GenerateKey()` to create a random key for you.\n+Make sure not to set `Key` to `encryptcookie.GenerateKey()` because that will create a new key every run.\n+:::\n+\n ## Config\n \n-<<<<<<< HEAD:middleware/encryptcookie/README.md\n-```go\n-type Config struct {\n-\t// Next defines a function to skip this middleware when returned true.\n-\t//\n-\t// Optional. Default: nil\n-\tNext func(c fiber.Ctx) bool\n-\n-\t// Array of cookie keys that should not be encrypted.\n-\t//\n-\t// Optional. Default: [\"csrf_\"]\n-\tExcept []string\n-\n-\t// Base64 encoded unique key to encode & decode cookies.\n-\t//\n-\t// Required. The key should be 32 bytes of random data in base64-encoded form.\n-\t// You may run `openssl rand -base64 32` or use `encryptcookie.GenerateKey()` to generate a new key.\n-\tKey string\n-\n-\t// Custom function to encrypt cookies.\n-\t//\n-\t// Optional. Default: EncryptCookie\n-\tEncryptor func(decryptedString, key string) (string, error)\n-\n-\t// Custom function to decrypt cookies.\n-\t//\n-\t// Optional. Default: DecryptCookie\n-\tDecryptor func(encryptedString, key string) (string, error)\n-}\n-```\n-=======\n-| Property  | Type                                                | Description                                                                                         | Default                      |\n-|:----------|:----------------------------------------------------|:----------------------------------------------------------------------------------------------------|:-----------------------------|\n-| Next      | `func(fiber.Ctx) bool`                             | Next defines a function to skip this middleware when returned true.                                 | `nil`                        |\n-| Except    | `[]string`                                          | Array of cookie keys that should not be encrypted.                                                  | `[]`                         |\n-| Key       | `string`                                            | Base64 encoded unique key to encode & decode cookies. Required. Key length should be 32 characters. | (No default, required field) |\n-| Encryptor | `func(decryptedString, key string) (string, error)` | Custom function to encrypt cookies.                                                                 | `EncryptCookie`              |\n-| Decryptor | `func(encryptedString, key string) (string, error)` | Custom function to decrypt cookies.                                                                 | `DecryptCookie`              |\n->>>>>>> origin/master:docs/api/middleware/encryptcookie.md\n+| Property  | Type                                                | Description                                                                                           | Default                      |\n+|:----------|:----------------------------------------------------|:------------------------------------------------------------------------------------------------------|:-----------------------------|\n+| Next      | `func(fiber.Ctx) bool`                             | A function to skip this middleware when returned true.                                                | `nil`                        |\n+| Except    | `[]string`                                          | Array of cookie keys that should not be encrypted.                                                    | `[]`                         |\n+| Key       | `string`                                            | A base64-encoded unique key to encode & decode cookies. Required. Key length should be 32 characters. | (No default, required field) |\n+| Encryptor | `func(decryptedString, key string) (string, error)` | A custom function to encrypt cookies.                                                                 | `EncryptCookie`              |\n+| Decryptor | `func(encryptedString, key string) (string, error)` | A custom function to decrypt cookies.                                                                 | `DecryptCookie`              |\n \n ## Default Config\n \n ```go\n var ConfigDefault = Config{\n \tNext:      nil,\n-\tExcept:    []string{\"csrf_\"},\n+\tExcept:    []string{},\n \tKey:       \"\",\n \tEncryptor: EncryptCookie,\n \tDecryptor: DecryptCookie,\n }\n ```\n \n-## Usage of CSRF and Encryptcookie Middlewares with Custom Cookie Names\n-Normally, encryptcookie middleware skips `csrf_` cookies. However, it won't work when you use custom cookie names for CSRF. You should update `Except` config to avoid this problem. For example:\n+## Usage With Other Middlewares That Reads Or Modify Cookies\n+Place the encryptcookie middleware before any other middleware that reads or modifies cookies. For example, if you are using the CSRF middleware, ensure that the encryptcookie middleware is placed before it. Failure to do so may prevent the CSRF middleware from reading the encrypted cookie.",
        "comment_created_at": "2024-02-27T13:53:30+00:00",
        "comment_author": "renanbastos93",
        "comment_body": "```suggestion\r\nPlace the `encryptcookie` middleware before any other middleware that reads or modifies cookies. For example, if you are using the CSRF middleware, ensure that the `encryptcookie` middleware is placed before it. Failure to do so may prevent the CSRF middleware from reading the encrypted cookie.\r\n```",
        "pr_file_module": null
      }
    ]
  }
]