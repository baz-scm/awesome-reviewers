[
  {
    "discussion_id": "2019893540",
    "pr_number": 3379,
    "pr_file": "ctx.go",
    "created_at": "2025-03-29T17:49:24+00:00",
    "commented_code": "// The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {\n+\tvar result strings.Builder\n+\tresult.Grow(len(v))\n+\tinvalidChars := make(map[byte]struct{})\n+\n+\tfor i := 0; i < len(v); i++ {\n+\t\tb := v[i]\n+\t\tif c.validCookieValueByte(b) {\n+\t\t\tresult.WriteByte(b)\n+\t\t} else {\n+\t\t\tinvalidChars[b] = struct{}{}\n+\t\t}\n+\t}\n+\n+\tif len(invalidChars) > 0 {\n+\t\tvar chars []string\n+\t\tfor b := range invalidChars {\n+\t\t\tchars = append(chars, fmt.Sprintf(\"'%c'\", b))\n+\t\t}\n+\t\tlog.Warn(\"invalid byte(s) %s in Cookie.Value; dropping invalid bytes\",",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "2019893540",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3379,
        "pr_file": "ctx.go",
        "discussion_id": "2019893540",
        "commented_code": "@@ -450,7 +451,48 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n // The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {\n+\tvar result strings.Builder\n+\tresult.Grow(len(v))\n+\tinvalidChars := make(map[byte]struct{})\n+\n+\tfor i := 0; i < len(v); i++ {\n+\t\tb := v[i]\n+\t\tif c.validCookieValueByte(b) {\n+\t\t\tresult.WriteByte(b)\n+\t\t} else {\n+\t\t\tinvalidChars[b] = struct{}{}\n+\t\t}\n+\t}\n+\n+\tif len(invalidChars) > 0 {\n+\t\tvar chars []string\n+\t\tfor b := range invalidChars {\n+\t\t\tchars = append(chars, fmt.Sprintf(\"'%c'\", b))\n+\t\t}\n+\t\tlog.Warn(\"invalid byte(s) %s in Cookie.Value; dropping invalid bytes\",",
        "comment_created_at": "2025-03-29T17:49:24+00:00",
        "comment_author": "gaby",
        "comment_body": "I feel like this could be abused for DoS by sending big values via cookies",
        "pr_file_module": null
      },
      {
        "comment_id": "2019894912",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3379,
        "pr_file": "ctx.go",
        "discussion_id": "2019893540",
        "commented_code": "@@ -450,7 +451,48 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n // The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {\n+\tvar result strings.Builder\n+\tresult.Grow(len(v))\n+\tinvalidChars := make(map[byte]struct{})\n+\n+\tfor i := 0; i < len(v); i++ {\n+\t\tb := v[i]\n+\t\tif c.validCookieValueByte(b) {\n+\t\t\tresult.WriteByte(b)\n+\t\t} else {\n+\t\t\tinvalidChars[b] = struct{}{}\n+\t\t}\n+\t}\n+\n+\tif len(invalidChars) > 0 {\n+\t\tvar chars []string\n+\t\tfor b := range invalidChars {\n+\t\t\tchars = append(chars, fmt.Sprintf(\"'%c'\", b))\n+\t\t}\n+\t\tlog.Warn(\"invalid byte(s) %s in Cookie.Value; dropping invalid bytes\",",
        "comment_created_at": "2025-03-29T17:51:30+00:00",
        "comment_author": "gaby",
        "comment_body": "It might be better to log a generic message with the cookie name, instead of logging the whole cookie value. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2019896303",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3379,
        "pr_file": "ctx.go",
        "discussion_id": "2019893540",
        "commented_code": "@@ -450,7 +451,48 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n // The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {\n+\tvar result strings.Builder\n+\tresult.Grow(len(v))\n+\tinvalidChars := make(map[byte]struct{})\n+\n+\tfor i := 0; i < len(v); i++ {\n+\t\tb := v[i]\n+\t\tif c.validCookieValueByte(b) {\n+\t\t\tresult.WriteByte(b)\n+\t\t} else {\n+\t\t\tinvalidChars[b] = struct{}{}\n+\t\t}\n+\t}\n+\n+\tif len(invalidChars) > 0 {\n+\t\tvar chars []string\n+\t\tfor b := range invalidChars {\n+\t\t\tchars = append(chars, fmt.Sprintf(\"'%c'\", b))\n+\t\t}\n+\t\tlog.Warn(\"invalid byte(s) %s in Cookie.Value; dropping invalid bytes\",",
        "comment_created_at": "2025-03-29T17:53:06+00:00",
        "comment_author": "c00kie17",
        "comment_body": "I can add a size check, 4kb should be good ?",
        "pr_file_module": null
      },
      {
        "comment_id": "2019904120",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3379,
        "pr_file": "ctx.go",
        "discussion_id": "2019893540",
        "commented_code": "@@ -450,7 +451,48 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n // The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {\n+\tvar result strings.Builder\n+\tresult.Grow(len(v))\n+\tinvalidChars := make(map[byte]struct{})\n+\n+\tfor i := 0; i < len(v); i++ {\n+\t\tb := v[i]\n+\t\tif c.validCookieValueByte(b) {\n+\t\t\tresult.WriteByte(b)\n+\t\t} else {\n+\t\t\tinvalidChars[b] = struct{}{}\n+\t\t}\n+\t}\n+\n+\tif len(invalidChars) > 0 {\n+\t\tvar chars []string\n+\t\tfor b := range invalidChars {\n+\t\t\tchars = append(chars, fmt.Sprintf(\"'%c'\", b))\n+\t\t}\n+\t\tlog.Warn(\"invalid byte(s) %s in Cookie.Value; dropping invalid bytes\",",
        "comment_created_at": "2025-03-29T18:04:30+00:00",
        "comment_author": "gaby",
        "comment_body": "Just add a comment for now in the code. Do not log it.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2022968690",
    "pr_number": 3379,
    "pr_file": "ctx.go",
    "created_at": "2025-04-01T14:21:54+00:00",
    "commented_code": "// The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\t// If the value looks like binary data, return it as-is\n+\tif len(value) > 0 && !utf8.ValidString(value) {\n+\t\treturn value\n+\t}\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "2022968690",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3379,
        "pr_file": "ctx.go",
        "discussion_id": "2022968690",
        "commented_code": "@@ -450,7 +451,49 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n // The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\t// If the value looks like binary data, return it as-is\n+\tif len(value) > 0 && !utf8.ValidString(value) {\n+\t\treturn value\n+\t}\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {",
        "comment_created_at": "2025-04-01T14:21:54+00:00",
        "comment_author": "gaby",
        "comment_body": "@gofiber/maintainers Is the correct approach to \"clean\" the cookie for the user. Or should we return HTTP 400?\r\n\r\n@c00kie17 how does net/http handle this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2022996986",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 3379,
        "pr_file": "ctx.go",
        "discussion_id": "2022968690",
        "commented_code": "@@ -450,7 +451,49 @@ func (c *DefaultCtx) Cookie(cookie *Cookie) {\n // The returned value is only valid within the handler. Do not store any references.\n // Make copies or use the Immutable setting to use the value outside the Handler.\n func (c *DefaultCtx) Cookies(key string, defaultValue ...string) string {\n-\treturn defaultString(c.app.getString(c.fasthttp.Request.Header.Cookie(key)), defaultValue)\n+\tvalue := c.app.getString(c.fasthttp.Request.Header.Cookie(key))\n+\t// If the value looks like binary data, return it as-is\n+\tif len(value) > 0 && !utf8.ValidString(value) {\n+\t\treturn value\n+\t}\n+\treturn defaultString(c.sanitizeCookieValue(value), defaultValue)\n+}\n+\n+// sanitizeCookieValue sanitizes a cookie value according to RFC 6265.\n+// It removes invalid characters from the cookie value, similar to how\n+// Go's standard library handles cookie values.\n+func (c *DefaultCtx) sanitizeCookieValue(v string) string {",
        "comment_created_at": "2025-04-01T14:36:42+00:00",
        "comment_author": "c00kie17",
        "comment_body": "https://github.com/golang/go/blob/7177f2400995901b666b1ed94d87c15c8c410fab/src/net/http/cookie.go#L516 \r\n\r\nhttps://github.com/golang/go/blob/7177f2400995901b666b1ed94d87c15c8c410fab/src/net/http/cookie.go#L333\r\n\r\nThese are the two function that have the main logic. I can copy `parseCookieValue` and just use that instead ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1460951400",
    "pr_number": 1986,
    "pr_file": "client/client.go",
    "created_at": "2024-01-21T15:36:16+00:00",
    "commented_code": "+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\tdefer func() {\n+\t\t_ = file.Close() //nolint:errcheck // It is fine to ignore the error here\n+\t}()\n+\tpem, err := io.ReadAll(file)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\n+\tconfig := c.TLSConfig()\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM(pem)\n+\n+\treturn c\n+}\n+\n+// SetRootCertificateFromString method adds one or more root certificates into client.\n+func (c *Client) SetRootCertificateFromString(pem string) *Client {\n+\tconfig := c.TLSConfig()\n+\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM([]byte(pem))\n+\n+\treturn c\n+}\n+\n+// SetProxyURL sets proxy url in client. It will apply via core to hostclient.\n+func (c *Client) SetProxyURL(proxyURL string) *Client {\n+\tpURL, err := urlPkg.Parse(proxyURL)\n+\tif err != nil {\n+\t\tlog.Errorf(\"%v\", err)\n+\n+\t\treturn c\n+\t}\n+\tc.proxyURL = pURL.String()",
    "repo_full_name": "gofiber/fiber",
    "discussion_comments": [
      {
        "comment_id": "1460951400",
        "repo_full_name": "gofiber/fiber",
        "pr_number": 1986,
        "pr_file": "client/client.go",
        "discussion_id": "1460951400",
        "commented_code": "@@ -0,0 +1,768 @@\n+package client\n+\n+import (\n+\t\"context\"\n+\t\"crypto/tls\"\n+\t\"crypto/x509\"\n+\t\"encoding/json\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\turlPkg \"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"github.com/gofiber/fiber/v3/log\"\n+\t\"github.com/gofiber/utils/v2\"\n+\n+\t\"github.com/valyala/fasthttp\"\n+)\n+\n+// Define the logger interface so that users can\n+// use different log implements to output logs.\n+type Logger interface {\n+\t// The log with error level\n+\tErrorf(format string, v ...any)\n+\n+\t// The log with warn level\n+\tWarnf(format string, v ...any)\n+\n+\t// The log with info level\n+\tInfof(format string, v ...any)\n+\n+\t// The log with debug level\n+\tDebugf(format string, v ...any)\n+}\n+\n+var _ (Logger) = (*disableLogger)(nil)\n+\n+// Implement a Logger interface.\n+// All logs are turned off by default.\n+type disableLogger struct{}\n+\n+func (*disableLogger) Errorf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Warnf(_ string, _ ...any) {}\n+\n+func (*disableLogger) Infof(_ string, _ ...any) {}\n+\n+func (*disableLogger) Debugf(_ string, _ ...any) {}\n+\n+// The Client is used to create a Fiber Client with\n+// client-level settings that apply to all requests\n+// raise from the client.\n+//\n+// Fiber Client also provides an option to override\n+// or merge most of the client settings at the request.\n+type Client struct {\n+\tmu sync.RWMutex\n+\n+\tbaseURL   string\n+\tuserAgent string\n+\treferer   string\n+\theader    *Header\n+\tparams    *QueryParam\n+\tcookies   *Cookie\n+\tpath      *PathParam\n+\n+\tdebug  bool\n+\tlogger Logger\n+\n+\ttimeout time.Duration\n+\n+\t// user defined request hooks\n+\tuserRequestHooks []RequestHook\n+\n+\t// client package defined request hooks\n+\tbuiltinRequestHooks []RequestHook\n+\n+\t// user defined response hooks\n+\tuserResponseHooks []ResponseHook\n+\n+\t// client package defined response hooks\n+\tbuiltinResponseHooks []ResponseHook\n+\n+\tjsonMarshal   utils.JSONMarshal\n+\tjsonUnmarshal utils.JSONUnmarshal\n+\txmlMarshal    utils.XMLMarshal\n+\txmlUnmarshal  utils.XMLUnmarshal\n+\n+\tcookieJar *CookieJar\n+\n+\t// tls config\n+\ttlsConfig *tls.Config\n+\n+\t// proxy\n+\tproxyURL string\n+\n+\t// retry\n+\tretryConfig *RetryConfig\n+}\n+\n+// R raise a request from the client.\n+func (c *Client) R() *Request {\n+\treturn AcquireRequest().SetClient(c)\n+}\n+\n+// Request returns user-defined request hooks.\n+func (c *Client) RequestHook() []RequestHook {\n+\treturn c.userRequestHooks\n+}\n+\n+// Add user-defined request hooks.\n+func (c *Client) AddRequestHook(h ...RequestHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userRequestHooks = append(c.userRequestHooks, h...)\n+\treturn c\n+}\n+\n+// ResponseHook return user-define response hooks.\n+func (c *Client) ResponseHook() []ResponseHook {\n+\treturn c.userResponseHooks\n+}\n+\n+// Add user-defined response hooks.\n+func (c *Client) AddResponseHook(h ...ResponseHook) *Client {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()\n+\n+\tc.userResponseHooks = append(c.userResponseHooks, h...)\n+\treturn c\n+}\n+\n+// JSONMarshal returns json marshal function in Core.\n+func (c *Client) JSONMarshal() utils.JSONMarshal {\n+\treturn c.jsonMarshal\n+}\n+\n+// Set json encoder.\n+func (c *Client) SetJSONMarshal(f utils.JSONMarshal) *Client {\n+\tc.jsonMarshal = f\n+\treturn c\n+}\n+\n+// JSONUnmarshal returns json unmarshal function in Core.\n+func (c *Client) JSONUnmarshal() utils.JSONUnmarshal {\n+\treturn c.jsonUnmarshal\n+}\n+\n+// Set json decoder.\n+func (c *Client) SetJSONUnmarshal(f utils.JSONUnmarshal) *Client {\n+\tc.jsonUnmarshal = f\n+\treturn c\n+}\n+\n+// XMLMarshal returns xml marshal function in Core.\n+func (c *Client) XMLMarshal() utils.XMLMarshal {\n+\treturn c.xmlMarshal\n+}\n+\n+// Set xml encoder.\n+func (c *Client) SetXMLMarshal(f utils.XMLMarshal) *Client {\n+\tc.xmlMarshal = f\n+\treturn c\n+}\n+\n+// XMLUnmarshal returns xml unmarshal function in Core.\n+func (c *Client) XMLUnmarshal() utils.XMLUnmarshal {\n+\treturn c.xmlUnmarshal\n+}\n+\n+// Set xml decoder.\n+func (c *Client) SetXMLUnmarshal(f utils.XMLUnmarshal) *Client {\n+\tc.xmlUnmarshal = f\n+\treturn c\n+}\n+\n+// TLSConfig returns tlsConfig in client.\n+// If client don't have tlsConfig, this function will init it.\n+func (c *Client) TLSConfig() *tls.Config {\n+\tif c.tlsConfig == nil {\n+\t\tc.tlsConfig = &tls.Config{\n+\t\t\tMinVersion: tls.VersionTLS12,\n+\t\t}\n+\t}\n+\n+\treturn c.tlsConfig\n+}\n+\n+// SetTLSConfig sets tlsConfig in client.\n+func (c *Client) SetTLSConfig(config *tls.Config) *Client {\n+\tc.tlsConfig = config\n+\treturn c\n+}\n+\n+// SetCertificates method sets client certificates into client.\n+func (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n+\tconfig := c.TLSConfig()\n+\tconfig.Certificates = append(config.Certificates, certs...)\n+\treturn c\n+}\n+\n+// SetRootCertificate adds one or more root certificates into client.\n+func (c *Client) SetRootCertificate(path string) *Client {\n+\tcleanPath := filepath.Clean(path)\n+\tfile, err := os.Open(cleanPath)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\tdefer func() {\n+\t\t_ = file.Close() //nolint:errcheck // It is fine to ignore the error here\n+\t}()\n+\tpem, err := io.ReadAll(file)\n+\tif err != nil {\n+\t\treturn c\n+\t}\n+\n+\tconfig := c.TLSConfig()\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM(pem)\n+\n+\treturn c\n+}\n+\n+// SetRootCertificateFromString method adds one or more root certificates into client.\n+func (c *Client) SetRootCertificateFromString(pem string) *Client {\n+\tconfig := c.TLSConfig()\n+\n+\tif config.RootCAs == nil {\n+\t\tconfig.RootCAs = x509.NewCertPool()\n+\t}\n+\tconfig.RootCAs.AppendCertsFromPEM([]byte(pem))\n+\n+\treturn c\n+}\n+\n+// SetProxyURL sets proxy url in client. It will apply via core to hostclient.\n+func (c *Client) SetProxyURL(proxyURL string) *Client {\n+\tpURL, err := urlPkg.Parse(proxyURL)\n+\tif err != nil {\n+\t\tlog.Errorf(\"%v\", err)\n+\n+\t\treturn c\n+\t}\n+\tc.proxyURL = pURL.String()",
        "comment_created_at": "2024-01-21T15:36:16+00:00",
        "comment_author": "gaby",
        "comment_body": "Before this line we should add something like this to validate the proxies are http/https.\r\n\r\n```go\r\n    // Validate the URL scheme\r\n    if pURL.Scheme != \"http\" && pURL.Scheme != \"https\" {\r\n        return errors.New(\"unsupported proxy scheme\")\r\n    }\r\n```",
        "pr_file_module": null
      }
    ]
  }
]