[
  {
    "discussion_id": "2302125490",
    "pr_number": 173324,
    "pr_file": "packages/flutter/lib/src/material/slider_parts.dart",
    "created_at": "2025-08-26T20:55:16+00:00",
    "commented_code": "sizeWithOverflow: sizeWithOverflow,\n       backgroundPaintColor: sliderTheme.valueIndicatorColor!,\n       strokePaintColor: sliderTheme.valueIndicatorStrokeColor,\n+      sliderTheme: sliderTheme,\n     );\n   }\n }\n \n+/// Utility class for processing multiline text in value indicators.\n+class _ValueIndicatorTextProcessor {\n+  const _ValueIndicatorTextProcessor._();\n+\n+  /// Processes multiline text for value indicators, handling maxLines\n+  /// truncation and ellipsis.\n+  ///\n+  /// Returns the appropriate TextPainter based on the multiline configuration.\n+  /// The caller is responsible for disposing the returned TextPainter\n+  /// if it differs from the original.\n+  static TextPainter processMultilineText({\n+    required TextPainter originalPainter,\n+    required ValueIndicatorMultilineConfig multilineConfig,\n+    required double textScaleFactor,\n+  }) {\n+    final String labelText = originalPainter.text?.toPlainText() ?? '';\n+\n+    if (!multilineConfig.enabled || multilineConfig.maxLines == null) {\n+      return originalPainter;\n+    }\n+\n+    final TextPainter truncatedPainter = TextPainter(\n+      text: originalPainter.text,\n+      textDirection: originalPainter.textDirection,\n+      textScaleFactor: textScaleFactor,\n+      maxLines: multilineConfig.maxLines,\n+    )..layout();\n+\n+    if (!truncatedPainter.didExceedMaxLines) {\n+      return truncatedPainter;\n+    }\n+\n+    truncatedPainter.dispose();\n+    return _createTextPainterWithEllipsis(\n+      originalPainter: originalPainter,\n+      originalText: labelText,\n+      maxLines: multilineConfig.maxLines!,\n+      textScaleFactor: textScaleFactor,\n+    );\n+  }\n+\n+  /// Safely disposes a TextPainter if it was created by processMultilineText.\n+  /// Does nothing if the painter is the same as the original.\n+  static void disposeIfCreated(TextPainter painter, TextPainter original) {\n+    if (painter != original) {\n+      painter.dispose();\n+    }\n+  }\n+}\n+\n+/// Creates a TextPainter with ellipsis when text exceeds maxLines.\n+TextPainter _createTextPainterWithEllipsis({",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2302125490",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173324,
        "pr_file": "packages/flutter/lib/src/material/slider_parts.dart",
        "discussion_id": "2302125490",
        "commented_code": "@@ -830,10 +830,79 @@ class DropSliderValueIndicatorShape extends SliderComponentShape {\n       sizeWithOverflow: sizeWithOverflow,\n       backgroundPaintColor: sliderTheme.valueIndicatorColor!,\n       strokePaintColor: sliderTheme.valueIndicatorStrokeColor,\n+      sliderTheme: sliderTheme,\n     );\n   }\n }\n \n+/// Utility class for processing multiline text in value indicators.\n+class _ValueIndicatorTextProcessor {\n+  const _ValueIndicatorTextProcessor._();\n+\n+  /// Processes multiline text for value indicators, handling maxLines\n+  /// truncation and ellipsis.\n+  ///\n+  /// Returns the appropriate TextPainter based on the multiline configuration.\n+  /// The caller is responsible for disposing the returned TextPainter\n+  /// if it differs from the original.\n+  static TextPainter processMultilineText({\n+    required TextPainter originalPainter,\n+    required ValueIndicatorMultilineConfig multilineConfig,\n+    required double textScaleFactor,\n+  }) {\n+    final String labelText = originalPainter.text?.toPlainText() ?? '';\n+\n+    if (!multilineConfig.enabled || multilineConfig.maxLines == null) {\n+      return originalPainter;\n+    }\n+\n+    final TextPainter truncatedPainter = TextPainter(\n+      text: originalPainter.text,\n+      textDirection: originalPainter.textDirection,\n+      textScaleFactor: textScaleFactor,\n+      maxLines: multilineConfig.maxLines,\n+    )..layout();\n+\n+    if (!truncatedPainter.didExceedMaxLines) {\n+      return truncatedPainter;\n+    }\n+\n+    truncatedPainter.dispose();\n+    return _createTextPainterWithEllipsis(\n+      originalPainter: originalPainter,\n+      originalText: labelText,\n+      maxLines: multilineConfig.maxLines!,\n+      textScaleFactor: textScaleFactor,\n+    );\n+  }\n+\n+  /// Safely disposes a TextPainter if it was created by processMultilineText.\n+  /// Does nothing if the painter is the same as the original.\n+  static void disposeIfCreated(TextPainter painter, TextPainter original) {\n+    if (painter != original) {\n+      painter.dispose();\n+    }\n+  }\n+}\n+\n+/// Creates a TextPainter with ellipsis when text exceeds maxLines.\n+TextPainter _createTextPainterWithEllipsis({",
        "comment_created_at": "2025-08-26T20:55:16+00:00",
        "comment_author": "justinmc",
        "comment_body": "I think this should be a private static method on _ValueIndicatorTextProcessor.",
        "pr_file_module": null
      },
      {
        "comment_id": "2309666664",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173324,
        "pr_file": "packages/flutter/lib/src/material/slider_parts.dart",
        "discussion_id": "2302125490",
        "commented_code": "@@ -830,10 +830,79 @@ class DropSliderValueIndicatorShape extends SliderComponentShape {\n       sizeWithOverflow: sizeWithOverflow,\n       backgroundPaintColor: sliderTheme.valueIndicatorColor!,\n       strokePaintColor: sliderTheme.valueIndicatorStrokeColor,\n+      sliderTheme: sliderTheme,\n     );\n   }\n }\n \n+/// Utility class for processing multiline text in value indicators.\n+class _ValueIndicatorTextProcessor {\n+  const _ValueIndicatorTextProcessor._();\n+\n+  /// Processes multiline text for value indicators, handling maxLines\n+  /// truncation and ellipsis.\n+  ///\n+  /// Returns the appropriate TextPainter based on the multiline configuration.\n+  /// The caller is responsible for disposing the returned TextPainter\n+  /// if it differs from the original.\n+  static TextPainter processMultilineText({\n+    required TextPainter originalPainter,\n+    required ValueIndicatorMultilineConfig multilineConfig,\n+    required double textScaleFactor,\n+  }) {\n+    final String labelText = originalPainter.text?.toPlainText() ?? '';\n+\n+    if (!multilineConfig.enabled || multilineConfig.maxLines == null) {\n+      return originalPainter;\n+    }\n+\n+    final TextPainter truncatedPainter = TextPainter(\n+      text: originalPainter.text,\n+      textDirection: originalPainter.textDirection,\n+      textScaleFactor: textScaleFactor,\n+      maxLines: multilineConfig.maxLines,\n+    )..layout();\n+\n+    if (!truncatedPainter.didExceedMaxLines) {\n+      return truncatedPainter;\n+    }\n+\n+    truncatedPainter.dispose();\n+    return _createTextPainterWithEllipsis(\n+      originalPainter: originalPainter,\n+      originalText: labelText,\n+      maxLines: multilineConfig.maxLines!,\n+      textScaleFactor: textScaleFactor,\n+    );\n+  }\n+\n+  /// Safely disposes a TextPainter if it was created by processMultilineText.\n+  /// Does nothing if the painter is the same as the original.\n+  static void disposeIfCreated(TextPainter painter, TextPainter original) {\n+    if (painter != original) {\n+      painter.dispose();\n+    }\n+  }\n+}\n+\n+/// Creates a TextPainter with ellipsis when text exceeds maxLines.\n+TextPainter _createTextPainterWithEllipsis({",
        "comment_created_at": "2025-08-29T09:26:24+00:00",
        "comment_author": "huycozy",
        "comment_body": "Great suggestion!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2308714710",
    "pr_number": 173324,
    "pr_file": "packages/flutter/lib/src/material/slider_parts.dart",
    "created_at": "2025-08-28T22:55:36+00:00",
    "commented_code": "required Size sizeWithOverflow,\n     required Color backgroundPaintColor,\n     Color? strokePaintColor,\n+    required SliderThemeData sliderTheme,\n   }) {\n     if (scale == 0.0) {\n       // Zero scale essentially means \"do not draw anything\", so it's safe to just return.\n       return;\n     }\n     assert(!sizeWithOverflow.isEmpty);\n-    final double rectangleWidth = _upperRectangleWidth(labelPainter, scale);\n+\n+    final ValueIndicatorMultilineConfig multilineConfig =\n+        sliderTheme.valueIndicatorMultilineConfig ?? const ValueIndicatorMultilineConfig();\n+\n+    // Handle maxLines truncation if multiline is enabled from theme configuration.\n+    final String labelText = labelPainter.text?.toPlainText() ?? '';\n+    final TextPainter finalLabelPainter = _ValueIndicatorTextProcessor.processMultilineText(\n+      originalPainter: labelPainter,\n+      multilineConfig: multilineConfig,\n+      textScaleFactor: textScaleFactor,\n+    );\n+\n+    final double rectangleWidth = _upperRectangleWidth(finalLabelPainter, scale);\n     final double horizontalShift = getHorizontalShift(\n       parentBox: parentBox,\n       center: center,\n-      labelPainter: labelPainter,\n+      labelPainter: finalLabelPainter,\n       textScaleFactor: textScaleFactor,\n       sizeWithOverflow: sizeWithOverflow,\n       scale: scale,\n     );\n-    final Rect upperRect = Rect.fromLTWH(\n-      -rectangleWidth / 2 + horizontalShift,\n-      -_rectYOffset - _minRectHeight,\n-      rectangleWidth,\n-      _minRectHeight,\n-    );\n+\n+    final bool hasNewline = multilineConfig.enabled && (labelText.contains('\n'));\n+\n+    final Rect upperRect;\n+    if (hasNewline) {\n+      // For multiline text, the rectangle should be positioned to accommodate\n+      // the text with proper padding.\n+      final double rectHeight = finalLabelPainter.height + (_labelPadding * 2);\n+      // Position rectangle above the triangle, with the triangle connecting to the bottom center.\n+      upperRect = Rect.fromLTWH(\n+        -rectangleWidth / 2 + horizontalShift,\n+        -_triangleHeight - rectHeight,\n+        rectangleWidth,\n+        rectHeight,\n+      );\n+    } else {\n+      // Original single-line calculation.\n+      upperRect = Rect.fromLTWH(\n+        -rectangleWidth / 2 + horizontalShift,\n+        -_rectYOffset - _minRectHeight,\n+        rectangleWidth,\n+        _minRectHeight,\n+      );\n+    }\n \n     final Paint fillPaint = Paint()..color = backgroundPaintColor;\n \n     canvas.save();\n     canvas.translate(center.dx, center.dy - _bottomTipYOffset);\n     canvas.scale(scale, scale);\n \n-    final BorderRadius adjustedBorderRadius = _adjustBorderRadius(upperRect);\n-    final RRect borderRect = adjustedBorderRadius\n-        .resolve(labelPainter.textDirection)\n-        .toRRect(upperRect);\n-    final Path trianglePath = Path()\n-      ..lineTo(-_triangleHeight, -_triangleHeight)\n-      ..lineTo(_triangleHeight, -_triangleHeight)\n-      ..close();\n-    trianglePath.addRRect(borderRect);\n+    final Path path;\n+    if (hasNewline) {",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2308714710",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173324,
        "pr_file": "packages/flutter/lib/src/material/slider_parts.dart",
        "discussion_id": "2308714710",
        "commented_code": "@@ -913,62 +994,169 @@ class _DropSliderValueIndicatorPathPainter {\n     required Size sizeWithOverflow,\n     required Color backgroundPaintColor,\n     Color? strokePaintColor,\n+    required SliderThemeData sliderTheme,\n   }) {\n     if (scale == 0.0) {\n       // Zero scale essentially means \"do not draw anything\", so it's safe to just return.\n       return;\n     }\n     assert(!sizeWithOverflow.isEmpty);\n-    final double rectangleWidth = _upperRectangleWidth(labelPainter, scale);\n+\n+    final ValueIndicatorMultilineConfig multilineConfig =\n+        sliderTheme.valueIndicatorMultilineConfig ?? const ValueIndicatorMultilineConfig();\n+\n+    // Handle maxLines truncation if multiline is enabled from theme configuration.\n+    final String labelText = labelPainter.text?.toPlainText() ?? '';\n+    final TextPainter finalLabelPainter = _ValueIndicatorTextProcessor.processMultilineText(\n+      originalPainter: labelPainter,\n+      multilineConfig: multilineConfig,\n+      textScaleFactor: textScaleFactor,\n+    );\n+\n+    final double rectangleWidth = _upperRectangleWidth(finalLabelPainter, scale);\n     final double horizontalShift = getHorizontalShift(\n       parentBox: parentBox,\n       center: center,\n-      labelPainter: labelPainter,\n+      labelPainter: finalLabelPainter,\n       textScaleFactor: textScaleFactor,\n       sizeWithOverflow: sizeWithOverflow,\n       scale: scale,\n     );\n-    final Rect upperRect = Rect.fromLTWH(\n-      -rectangleWidth / 2 + horizontalShift,\n-      -_rectYOffset - _minRectHeight,\n-      rectangleWidth,\n-      _minRectHeight,\n-    );\n+\n+    final bool hasNewline = multilineConfig.enabled && (labelText.contains('\\n'));\n+\n+    final Rect upperRect;\n+    if (hasNewline) {\n+      // For multiline text, the rectangle should be positioned to accommodate\n+      // the text with proper padding.\n+      final double rectHeight = finalLabelPainter.height + (_labelPadding * 2);\n+      // Position rectangle above the triangle, with the triangle connecting to the bottom center.\n+      upperRect = Rect.fromLTWH(\n+        -rectangleWidth / 2 + horizontalShift,\n+        -_triangleHeight - rectHeight,\n+        rectangleWidth,\n+        rectHeight,\n+      );\n+    } else {\n+      // Original single-line calculation.\n+      upperRect = Rect.fromLTWH(\n+        -rectangleWidth / 2 + horizontalShift,\n+        -_rectYOffset - _minRectHeight,\n+        rectangleWidth,\n+        _minRectHeight,\n+      );\n+    }\n \n     final Paint fillPaint = Paint()..color = backgroundPaintColor;\n \n     canvas.save();\n     canvas.translate(center.dx, center.dy - _bottomTipYOffset);\n     canvas.scale(scale, scale);\n \n-    final BorderRadius adjustedBorderRadius = _adjustBorderRadius(upperRect);\n-    final RRect borderRect = adjustedBorderRadius\n-        .resolve(labelPainter.textDirection)\n-        .toRRect(upperRect);\n-    final Path trianglePath = Path()\n-      ..lineTo(-_triangleHeight, -_triangleHeight)\n-      ..lineTo(_triangleHeight, -_triangleHeight)\n-      ..close();\n-    trianglePath.addRRect(borderRect);\n+    final Path path;\n+    if (hasNewline) {",
        "comment_created_at": "2025-08-28T22:55:36+00:00",
        "comment_author": "justinmc",
        "comment_body": "Nit: Just an idea to split up this big `if/else`. You could create two new private methods, one for the case that hasNewline is true and one for false, that create and return the Path.",
        "pr_file_module": null
      },
      {
        "comment_id": "2309669149",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173324,
        "pr_file": "packages/flutter/lib/src/material/slider_parts.dart",
        "discussion_id": "2308714710",
        "commented_code": "@@ -913,62 +994,169 @@ class _DropSliderValueIndicatorPathPainter {\n     required Size sizeWithOverflow,\n     required Color backgroundPaintColor,\n     Color? strokePaintColor,\n+    required SliderThemeData sliderTheme,\n   }) {\n     if (scale == 0.0) {\n       // Zero scale essentially means \"do not draw anything\", so it's safe to just return.\n       return;\n     }\n     assert(!sizeWithOverflow.isEmpty);\n-    final double rectangleWidth = _upperRectangleWidth(labelPainter, scale);\n+\n+    final ValueIndicatorMultilineConfig multilineConfig =\n+        sliderTheme.valueIndicatorMultilineConfig ?? const ValueIndicatorMultilineConfig();\n+\n+    // Handle maxLines truncation if multiline is enabled from theme configuration.\n+    final String labelText = labelPainter.text?.toPlainText() ?? '';\n+    final TextPainter finalLabelPainter = _ValueIndicatorTextProcessor.processMultilineText(\n+      originalPainter: labelPainter,\n+      multilineConfig: multilineConfig,\n+      textScaleFactor: textScaleFactor,\n+    );\n+\n+    final double rectangleWidth = _upperRectangleWidth(finalLabelPainter, scale);\n     final double horizontalShift = getHorizontalShift(\n       parentBox: parentBox,\n       center: center,\n-      labelPainter: labelPainter,\n+      labelPainter: finalLabelPainter,\n       textScaleFactor: textScaleFactor,\n       sizeWithOverflow: sizeWithOverflow,\n       scale: scale,\n     );\n-    final Rect upperRect = Rect.fromLTWH(\n-      -rectangleWidth / 2 + horizontalShift,\n-      -_rectYOffset - _minRectHeight,\n-      rectangleWidth,\n-      _minRectHeight,\n-    );\n+\n+    final bool hasNewline = multilineConfig.enabled && (labelText.contains('\\n'));\n+\n+    final Rect upperRect;\n+    if (hasNewline) {\n+      // For multiline text, the rectangle should be positioned to accommodate\n+      // the text with proper padding.\n+      final double rectHeight = finalLabelPainter.height + (_labelPadding * 2);\n+      // Position rectangle above the triangle, with the triangle connecting to the bottom center.\n+      upperRect = Rect.fromLTWH(\n+        -rectangleWidth / 2 + horizontalShift,\n+        -_triangleHeight - rectHeight,\n+        rectangleWidth,\n+        rectHeight,\n+      );\n+    } else {\n+      // Original single-line calculation.\n+      upperRect = Rect.fromLTWH(\n+        -rectangleWidth / 2 + horizontalShift,\n+        -_rectYOffset - _minRectHeight,\n+        rectangleWidth,\n+        _minRectHeight,\n+      );\n+    }\n \n     final Paint fillPaint = Paint()..color = backgroundPaintColor;\n \n     canvas.save();\n     canvas.translate(center.dx, center.dy - _bottomTipYOffset);\n     canvas.scale(scale, scale);\n \n-    final BorderRadius adjustedBorderRadius = _adjustBorderRadius(upperRect);\n-    final RRect borderRect = adjustedBorderRadius\n-        .resolve(labelPainter.textDirection)\n-        .toRRect(upperRect);\n-    final Path trianglePath = Path()\n-      ..lineTo(-_triangleHeight, -_triangleHeight)\n-      ..lineTo(_triangleHeight, -_triangleHeight)\n-      ..close();\n-    trianglePath.addRRect(borderRect);\n+    final Path path;\n+    if (hasNewline) {",
        "comment_created_at": "2025-08-29T09:27:34+00:00",
        "comment_author": "huycozy",
        "comment_body": "Yes, looks cleaner!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205668653",
    "pr_number": 168834,
    "pr_file": "packages/flutter/lib/src/material/reorderable_list.dart",
    "created_at": "2025-07-14T19:39:45+00:00",
    "commented_code": "final Widget item = widget.itemBuilder(context, index);\n     assert(() {\n       if (item.key == null) {\n-        throw FlutterError('Every item of ReorderableListView must have a key.');\n+        // Separators built by widget.itemBuilder (when widget.separatorBuilder is non-null and index is odd)\n+        // might not have keys or might have non-GlobalKeys.\n+        // This assertion should only apply to actual reorderable items.\n+        if (widget.separatorBuilder == null || index.isEven) {\n+          throw FlutterError('Every item of ReorderableListView must have a key.');\n+        }\n       }\n       return true;\n     }());\n \n+    // If using .separated, separators are at odd indices.\n+    // We only want drag handles and specific keys for actual items (even indices).\n+    final bool isSeparator = widget.separatorBuilder != null && index.isOdd;",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2205668653",
        "repo_full_name": "flutter/flutter",
        "pr_number": 168834,
        "pr_file": "packages/flutter/lib/src/material/reorderable_list.dart",
        "discussion_id": "2205668653",
        "commented_code": "@@ -323,11 +414,35 @@ class _ReorderableListViewState extends State<ReorderableListView> {\n     final Widget item = widget.itemBuilder(context, index);\n     assert(() {\n       if (item.key == null) {\n-        throw FlutterError('Every item of ReorderableListView must have a key.');\n+        // Separators built by widget.itemBuilder (when widget.separatorBuilder is non-null and index is odd)\n+        // might not have keys or might have non-GlobalKeys.\n+        // This assertion should only apply to actual reorderable items.\n+        if (widget.separatorBuilder == null || index.isEven) {\n+          throw FlutterError('Every item of ReorderableListView must have a key.');\n+        }\n       }\n       return true;\n     }());\n \n+    // If using .separated, separators are at odd indices.\n+    // We only want drag handles and specific keys for actual items (even indices).\n+    final bool isSeparator = widget.separatorBuilder != null && index.isOdd;",
        "comment_created_at": "2025-07-14T19:39:45+00:00",
        "comment_author": "dkwingsmt",
        "comment_body": "This pattern have been occurring a lot and I suggest extracting them as separate getters:\r\n```dart\r\n  bool get hasSeparators => widget.separatorBuilder != null;\r\n```\r\n(Feel free to come up with a better name)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2307770601",
    "pr_number": 174463,
    "pr_file": "engine/src/flutter/impeller/renderer/renderer_unittests.cc",
    "created_at": "2025-08-28T15:21:59+00:00",
    "commented_code": "context->GetPipelineLibrary()->GetPipeline(pipeline_descriptor).Get();\n   ASSERT_TRUE(pipeline && pipeline->IsValid());\n \n-  auto host_buffer = HostBuffer::Create(\n-      context->GetResourceAllocator(), context->GetIdleWaiter(),\n-      context->GetCapabilities()->GetMinimumUniformAlignment());\n+  auto data_host_buffer = HostBuffer::Create(\n+      GetContext()->GetResourceAllocator(), GetContext()->GetIdleWaiter(),\n+      GetContext()->GetCapabilities()->GetMinimumUniformAlignment());\n+  auto indexes_host_buffer =\n+      GetContext()->GetCapabilities()->NeedsPartitionedHostBuffer()\n+          ? HostBuffer::Create(\n+                GetContext()->GetResourceAllocator(),\n+                GetContext()->GetIdleWaiter(),\n+                GetContext()->GetCapabilities()->GetMinimumUniformAlignment())\n+          : data_host_buffer;",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2307770601",
        "repo_full_name": "flutter/flutter",
        "pr_number": 174463,
        "pr_file": "engine/src/flutter/impeller/renderer/renderer_unittests.cc",
        "discussion_id": "2307770601",
        "commented_code": "@@ -1040,9 +1060,16 @@ TEST_P(RendererTest, ArrayUniforms) {\n       context->GetPipelineLibrary()->GetPipeline(pipeline_descriptor).Get();\n   ASSERT_TRUE(pipeline && pipeline->IsValid());\n \n-  auto host_buffer = HostBuffer::Create(\n-      context->GetResourceAllocator(), context->GetIdleWaiter(),\n-      context->GetCapabilities()->GetMinimumUniformAlignment());\n+  auto data_host_buffer = HostBuffer::Create(\n+      GetContext()->GetResourceAllocator(), GetContext()->GetIdleWaiter(),\n+      GetContext()->GetCapabilities()->GetMinimumUniformAlignment());\n+  auto indexes_host_buffer =\n+      GetContext()->GetCapabilities()->NeedsPartitionedHostBuffer()\n+          ? HostBuffer::Create(\n+                GetContext()->GetResourceAllocator(),\n+                GetContext()->GetIdleWaiter(),\n+                GetContext()->GetCapabilities()->GetMinimumUniformAlignment())\n+          : data_host_buffer;",
        "comment_created_at": "2025-08-28T15:21:59+00:00",
        "comment_author": "gaaclarke",
        "comment_body": "nit: We can probably pull this into a function since it happens a fair bit.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2298694387",
    "pr_number": 174169,
    "pr_file": "packages/flutter/lib/src/widgets/expansible.dart",
    "created_at": "2025-08-25T17:29:39+00:00",
    "commented_code": "widget.controller.removeListener(_toggleExpansion);\n     _animationController.dispose();\n     _heightFactor.dispose();\n+    _timer?.cancel();\n+    _timer = null;\n     super.dispose();\n   }\n \n+  void _announceSemantics() {\n+    if (!MediaQuery.supportsAnnounceOf(context)) {\n+      return;\n+    }\n+    final WidgetsLocalizations localizations = WidgetsLocalizations.of(context);\n+    final String stateHint = widget.controller.isExpanded",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2298694387",
        "repo_full_name": "flutter/flutter",
        "pr_number": 174169,
        "pr_file": "packages/flutter/lib/src/widgets/expansible.dart",
        "discussion_id": "2298694387",
        "commented_code": "@@ -340,9 +349,34 @@ class _ExpansibleState extends State<Expansible> with SingleTickerProviderStateM\n     widget.controller.removeListener(_toggleExpansion);\n     _animationController.dispose();\n     _heightFactor.dispose();\n+    _timer?.cancel();\n+    _timer = null;\n     super.dispose();\n   }\n \n+  void _announceSemantics() {\n+    if (!MediaQuery.supportsAnnounceOf(context)) {\n+      return;\n+    }\n+    final WidgetsLocalizations localizations = WidgetsLocalizations.of(context);\n+    final String stateHint = widget.controller.isExpanded",
        "comment_created_at": "2025-08-25T17:29:39+00:00",
        "comment_author": "chunhtai",
        "comment_body": "Consider pass-in the boolean or message directly. or refactor out something like\r\n```\r\nbool get _effectiveExpanded => widget.controller.isExpanded;\r\n```\r\nin case we change how we decide _effectiveExpanded later",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2261611088",
    "pr_number": 169720,
    "pr_file": "packages/flutter/lib/src/widgets/editable_text.dart",
    "created_at": "2025-08-07T23:02:38+00:00",
    "commented_code": "}\n \n   /// Toggles the visibility of the toolbar.\n+  @override\n   void toggleToolbar([bool hideHandles = true]) {\n     final TextSelectionOverlay selectionOverlay = _selectionOverlay ??= _createSelectionOverlay();\n     if (selectionOverlay.toolbarIsVisible) {\n       hideToolbar(hideHandles);\n     } else {\n+      if (_hideSystemToolbarLastTimestamp != null &&\n+          _systemToolbarToggleDebounceThreshold != null &&\n+          (SchedulerBinding.instance.currentSystemFrameTimeStamp -\n+                  _hideSystemToolbarLastTimestamp!) <\n+              _systemToolbarToggleDebounceThreshold!) {",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2261611088",
        "repo_full_name": "flutter/flutter",
        "pr_number": 169720,
        "pr_file": "packages/flutter/lib/src/widgets/editable_text.dart",
        "discussion_id": "2261611088",
        "commented_code": "@@ -4993,11 +5004,37 @@ class EditableTextState extends State<EditableText>\n   }\n \n   /// Toggles the visibility of the toolbar.\n+  @override\n   void toggleToolbar([bool hideHandles = true]) {\n     final TextSelectionOverlay selectionOverlay = _selectionOverlay ??= _createSelectionOverlay();\n     if (selectionOverlay.toolbarIsVisible) {\n       hideToolbar(hideHandles);\n     } else {\n+      if (_hideSystemToolbarLastTimestamp != null &&\n+          _systemToolbarToggleDebounceThreshold != null &&\n+          (SchedulerBinding.instance.currentSystemFrameTimeStamp -\n+                  _hideSystemToolbarLastTimestamp!) <\n+              _systemToolbarToggleDebounceThreshold!) {",
        "comment_created_at": "2025-08-07T23:02:38+00:00",
        "comment_author": "justinmc",
        "comment_body": "Nit: Maybe make this a private method? Or assign it to a variable.",
        "pr_file_module": null
      }
    ]
  }
]