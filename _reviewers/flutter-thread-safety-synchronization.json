[
  {
    "discussion_id": "2289424909",
    "pr_number": 173610,
    "pr_file": "engine/src/flutter/shell/common/shell.cc",
    "created_at": "2025-08-20T22:18:21+00:00",
    "commented_code": "<< \"Unexpected request to remove the implicit view #\"\n       << kFlutterImplicitViewId << \". This view should never be removed.\";\n \n-  expected_frame_sizes_.erase(view_id);\n+  expected_frame_constraints_.erase(view_id);",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2289424909",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173610,
        "pr_file": "engine/src/flutter/shell/common/shell.cc",
        "discussion_id": "2289424909",
        "commented_code": "@@ -2168,7 +2214,7 @@ void Shell::OnPlatformViewRemoveView(int64_t view_id,\n       << \"Unexpected request to remove the implicit view #\"\n       << kFlutterImplicitViewId << \". This view should never be removed.\";\n \n-  expected_frame_sizes_.erase(view_id);\n+  expected_frame_constraints_.erase(view_id);",
        "comment_created_at": "2025-08-20T22:18:21+00:00",
        "comment_author": "loic-sharma",
        "comment_body": "I believe this needs to be protected by `std::scoped_lock<std::mutex> lock(resize_mutex_);`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2283749706",
    "pr_number": 173715,
    "pr_file": "packages/flutter/lib/src/widgets/_window_win32.dart",
    "created_at": "2025-08-19T00:16:36+00:00",
    "commented_code": "+// Copyright 2014 The Flutter Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// Do not import this file in production applications or packages published\n+// to pub.dev. Flutter will make breaking changes to this file, even in patch\n+// versions.\n+//\n+// All APIs in this file must be private or must:\n+//\n+// 1. Have the `@internal` attribute.\n+// 2. Throw an `UnsupportedError` if `isWindowingEnabled`\n+//    is `false.\n+//\n+// See: https://github.com/flutter/flutter/issues/30701.\n+\n+import 'dart:ffi' as ffi;\n+import 'dart:io';\n+import 'dart:typed_data';\n+import 'dart:ui' show Display, FlutterView;\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/rendering.dart';\n+\n+import '_window.dart';\n+\n+/// A Win32 window handle.\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+@internal\n+typedef HWND = ffi.Pointer<ffi.Void>;\n+\n+const int _WM_SIZE = 0x0005;\n+const int _WM_ACTIVATE = 0x0006;\n+const int _WM_CLOSE = 0x0010;\n+\n+const int _SW_RESTORE = 9;\n+const int _SW_MAXIMIZE = 3;\n+const int _SW_MINIMIZE = 6;\n+\n+/// Abstract handler class for Windows messages.\n+///\n+/// Implementations of this class should register with\n+/// [WindowingOwnerWin32.addMessageHandler] to begin receiving messages.\n+/// When finished handling messages, implementations should deregister\n+/// themselves with [WindowingOwnerWin32.removeMessageHandler].\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+///\n+/// See also:\n+///\n+///  * [WindowingOwnerWin32], the class that manages these handlers.\n+@internal\n+abstract class WindowsMessageHandler {\n+  /// Handles a window message.\n+  ///\n+  /// Returned value, if not null will be returned to the system as LRESULT\n+  /// and will stop all other handlers from being called. See\n+  /// https://learn.microsoft.com/en-us/windows/win32/api/winuser/nc-winuser-wndproc\n+  /// for more information.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  @internal\n+  int? handleWindowsMessage(\n+    FlutterView view,\n+    HWND windowHandle,\n+    int message,\n+    int wParam,\n+    int lParam,\n+  );\n+}\n+\n+/// [WindowingOwner] implementation for Windows.\n+///\n+/// If [Platform.isWindows] is false, then the constructor will throw an\n+/// [UnsupportedError].\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+///\n+/// See also:\n+///\n+///  * [WindowingOwner], the abstract class that manages native windows.\n+@internal\n+class WindowingOwnerWin32 extends WindowingOwner {\n+  /// Creates a new [WindowingOwnerWin32] instance.\n+  ///\n+  /// If [Platform.isWindows] is false, then this constructor will throw an\n+  /// [UnsupportedError]\n+  ///\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [WindowingOwner], the abstract class that manages native windows.\n+  @internal\n+  WindowingOwnerWin32() : allocator = _CallocAllocator._() {\n+    if (!Platform.isWindows) {\n+      throw UnsupportedError('Only available on the Win32 platform');\n+    }\n+\n+    final ffi.Pointer<_WindowingInitRequest> request = allocator<_WindowingInitRequest>()\n+      ..ref.onMessage =\n+          ffi.NativeCallable<ffi.Void Function(ffi.Pointer<_WindowsMessage>)>.isolateLocal(\n+            _onMessage,\n+          ).nativeFunction;\n+    _Win32PlatformInterface.initializeWindowing(PlatformDispatcher.instance.engineId!, request);\n+    allocator.free(request);\n+  }\n+\n+  final List<WindowsMessageHandler> _messageHandlers = <WindowsMessageHandler>[];\n+\n+  /// The [Allocator] used for allocating native memory in this owner.\n+  ///\n+  /// This can be overridden via the [WindowingOwnerWin32.test] constructor.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  @internal\n+  final ffi.Allocator allocator;\n+\n+  @internal\n+  @override\n+  RegularWindowController createRegularWindowController({\n+    Size? preferredSize,\n+    BoxConstraints? preferredConstraints,\n+    String? title,\n+    required RegularWindowControllerDelegate delegate,\n+  }) {\n+    return RegularWindowControllerWin32(\n+      owner: this,\n+      delegate: delegate,\n+      preferredSize: preferredSize,\n+      preferredConstraints: preferredConstraints,\n+      title: title,\n+    );\n+  }\n+\n+  /// Register a new [WindowsMessageHandler].\n+  ///\n+  /// The handler will be triggered for unhandled messages for all top level\n+  /// windows.\n+  ///\n+  /// Adding a handler multiple times has no effect.\n+  ///\n+  /// Handlers are called in the order that they are added.\n+  ///\n+  /// Callers must remove their message handlers using\n+  /// [WindowingOwnerWin32.removeMessageHandler].\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [WindowsMessageHandler], the interface for message handlers.\n+  ///  * [WindowingOwnerWin32.removeMessageHandler], to remove message handlers.\n+  @internal\n+  void addMessageHandler(WindowsMessageHandler handler) {\n+    if (_messageHandlers.contains(handler)) {\n+      return;\n+    }\n+\n+    _messageHandlers.add(handler);\n+  }\n+\n+  /// Unregister a [WindowsMessageHandler].\n+  ///\n+  /// If the handler has not been registered, this method has no effect.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [WindowsMessageHandler], the interface for message handlers.\n+  ///  * [WindowingOwnerWin32.addMessageHandler], to register message handlers.\n+  @internal\n+  void removeMessageHandler(WindowsMessageHandler handler) {\n+    _messageHandlers.remove(handler);\n+  }\n+\n+  void _onMessage(ffi.Pointer<_WindowsMessage> message) {\n+    final List<WindowsMessageHandler> handlers = List<WindowsMessageHandler>.from(_messageHandlers);\n+    final FlutterView flutterView = PlatformDispatcher.instance.views.firstWhere(\n+      (FlutterView view) => view.viewId == message.ref.viewId,\n+    );\n+    for (final WindowsMessageHandler handler in handlers) {\n+      final int? result = handler.handleWindowsMessage(\n+        flutterView,\n+        message.ref.windowHandle,\n+        message.ref.message,\n+        message.ref.wParam,\n+        message.ref.lParam,\n+      );\n+      if (result != null) {\n+        message.ref.handled = true;\n+        message.ref.lResult = result;\n+        return;\n+      }\n+    }\n+  }\n+\n+  @internal\n+  @override\n+  bool hasTopLevelWindows() {\n+    return _Win32PlatformInterface.hasTopLevelWindows(PlatformDispatcher.instance.engineId!);\n+  }\n+}\n+\n+/// Implementation of [RegularWindowController] for the Windows platform.\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+///\n+/// See also:\n+///\n+///  * [RegularWindowController], the base class for regular windows.\n+class RegularWindowControllerWin32 extends RegularWindowController\n+    implements WindowsMessageHandler {\n+  /// Creates a new regular window controller for Win32.\n+  ///\n+  /// When this constructor completes the native window has been created and\n+  /// has a view associated with it.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [RegularWindowController], the base class for regular windows.\n+  @internal\n+  RegularWindowControllerWin32({\n+    required WindowingOwnerWin32 owner,\n+    required RegularWindowControllerDelegate delegate,\n+    Size? preferredSize,\n+    BoxConstraints? preferredConstraints,\n+    String? title,\n+  }) : _owner = owner,\n+       _delegate = delegate,\n+       super.empty() {\n+    owner.addMessageHandler(this);\n+    final ffi.Pointer<_WindowCreationRequest> request = owner.allocator<_WindowCreationRequest>()\n+      ..ref.preferredSize.from(preferredSize)\n+      ..ref.preferredConstraints.from(preferredConstraints)\n+      ..ref.title = (title ?? 'Regular window').toNativeUtf16(allocator: _owner.allocator);\n+    final int viewId = _Win32PlatformInterface.createWindow(\n+      PlatformDispatcher.instance.engineId!,\n+      request,\n+    );\n+    owner.allocator.free(request);\n+    final FlutterView flutterView = PlatformDispatcher.instance.views.firstWhere(\n+      (FlutterView view) => view.viewId == viewId,\n+    );\n+    rootView = flutterView;\n+  }\n+\n+  final WindowingOwnerWin32 _owner;\n+  final RegularWindowControllerDelegate _delegate;\n+  bool _destroyed = false;\n+\n+  @override\n+  @internal\n+  Size get contentSize {\n+    _ensureNotDestroyed();\n+    final _ActualContentSize size = _Win32PlatformInterface.getWindowContentSize(getWindowHandle());\n+    final Size result = Size(size.width, size.height);\n+    return result;\n+  }\n+\n+  @override\n+  @internal\n+  String get title {\n+    _ensureNotDestroyed();\n+    final int length = _Win32PlatformInterface.getWindowTextLength(getWindowHandle());\n+    if (length == 0) {\n+      return '';\n+    }\n+\n+    final ffi.Pointer<ffi.Uint16> data = _owner.allocator<ffi.Uint16>(length + 1);\n+    try {\n+      final ffi.Pointer<_Utf16> buffer = data.cast<_Utf16>();\n+      _Win32PlatformInterface.getWindowText(getWindowHandle(), buffer, length + 1);\n+      return buffer.toDartString();\n+    } finally {\n+      _owner.allocator.free(data);\n+    }\n+  }\n+\n+  @override\n+  @internal\n+  bool get isActivated {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.getForegroundWindow() == getWindowHandle();\n+  }\n+\n+  @override\n+  @internal\n+  bool get isMaximized {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.isZoomed(getWindowHandle()) != 0;\n+  }\n+\n+  @override\n+  @internal\n+  bool get isMinimized {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.isIconic(getWindowHandle()) != 0;\n+  }\n+\n+  @override\n+  @internal\n+  bool get isFullscreen {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.getFullscreen(getWindowHandle());\n+  }\n+\n+  @override\n+  @internal\n+  void setSize(Size? size) {\n+    _ensureNotDestroyed();\n+    final ffi.Pointer<_WindowSizeRequest> request = _owner.allocator<_WindowSizeRequest>();\n+    request.ref.hasSize = size != null;\n+    request.ref.width = size?.width ?? 0;\n+    request.ref.height = size?.height ?? 0;\n+    _Win32PlatformInterface.setWindowContentSize(getWindowHandle(), request);\n+    _owner.allocator.free(request);\n+  }\n+\n+  @override\n+  @internal\n+  void setConstraints(BoxConstraints constraints) {\n+    _ensureNotDestroyed();\n+    final ffi.Pointer<_WindowConstraintsRequest> request = _owner\n+        .allocator<_WindowConstraintsRequest>();\n+    request.ref.from(constraints);\n+    _Win32PlatformInterface.setWindowConstraints(getWindowHandle(), request);\n+    _owner.allocator.free(request);\n+\n+    notifyListeners();\n+  }\n+\n+  @override\n+  @internal\n+  void setTitle(String title) {\n+    _ensureNotDestroyed();\n+    final ffi.Pointer<_Utf16> titlePointer = title.toNativeUtf16(allocator: _owner.allocator);\n+    _Win32PlatformInterface.setWindowTitle(getWindowHandle(), titlePointer);\n+    _owner.allocator.free(titlePointer);\n+\n+    notifyListeners();\n+  }\n+\n+  @override\n+  @internal\n+  void activate() {\n+    _ensureNotDestroyed();\n+    _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_RESTORE);\n+  }\n+\n+  @override\n+  @internal\n+  void setMaximized(bool maximized) {\n+    _ensureNotDestroyed();\n+    if (maximized) {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_MAXIMIZE);\n+    } else {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_RESTORE);\n+    }\n+  }\n+\n+  @override\n+  @internal\n+  void setMinimized(bool minimized) {\n+    _ensureNotDestroyed();\n+    if (minimized) {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_MINIMIZE);\n+    } else {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_RESTORE);\n+    }\n+  }\n+\n+  @override\n+  @internal\n+  void setFullscreen(bool fullscreen, {Display? display}) {\n+    final ffi.Pointer<_WindowFullscreenRequest> request = _owner\n+        .allocator<_WindowFullscreenRequest>();\n+    request.ref.hasDisplayId = false;\n+    request.ref.displayId = display?.id ?? 0;\n+    request.ref.fullscreen = fullscreen;\n+    _Win32PlatformInterface.setFullscreen(getWindowHandle(), request);\n+    _owner.allocator.free(request);\n+  }\n+\n+  /// Returns HWND pointer to the top level window.\n+  @internal\n+  HWND getWindowHandle() {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.getWindowHandle(\n+      PlatformDispatcher.instance.engineId!,\n+      rootView.viewId,\n+    );\n+  }\n+\n+  void _ensureNotDestroyed() {\n+    if (_destroyed) {\n+      throw StateError('Window has been destroyed.');\n+    }\n+  }\n+\n+  @override\n+  void destroy() {\n+    if (_destroyed) {\n+      return;\n+    }\n+    _Win32PlatformInterface.destroyWindow(getWindowHandle());\n+    _destroyed = true;\n+    _delegate.onWindowDestroyed();\n+    _owner.removeMessageHandler(this);",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2283749706",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173715,
        "pr_file": "packages/flutter/lib/src/widgets/_window_win32.dart",
        "discussion_id": "2283749706",
        "commented_code": "@@ -0,0 +1,760 @@\n+// Copyright 2014 The Flutter Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+// Do not import this file in production applications or packages published\n+// to pub.dev. Flutter will make breaking changes to this file, even in patch\n+// versions.\n+//\n+// All APIs in this file must be private or must:\n+//\n+// 1. Have the `@internal` attribute.\n+// 2. Throw an `UnsupportedError` if `isWindowingEnabled`\n+//    is `false.\n+//\n+// See: https://github.com/flutter/flutter/issues/30701.\n+\n+import 'dart:ffi' as ffi;\n+import 'dart:io';\n+import 'dart:typed_data';\n+import 'dart:ui' show Display, FlutterView;\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter/rendering.dart';\n+\n+import '_window.dart';\n+\n+/// A Win32 window handle.\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+@internal\n+typedef HWND = ffi.Pointer<ffi.Void>;\n+\n+const int _WM_SIZE = 0x0005;\n+const int _WM_ACTIVATE = 0x0006;\n+const int _WM_CLOSE = 0x0010;\n+\n+const int _SW_RESTORE = 9;\n+const int _SW_MAXIMIZE = 3;\n+const int _SW_MINIMIZE = 6;\n+\n+/// Abstract handler class for Windows messages.\n+///\n+/// Implementations of this class should register with\n+/// [WindowingOwnerWin32.addMessageHandler] to begin receiving messages.\n+/// When finished handling messages, implementations should deregister\n+/// themselves with [WindowingOwnerWin32.removeMessageHandler].\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+///\n+/// See also:\n+///\n+///  * [WindowingOwnerWin32], the class that manages these handlers.\n+@internal\n+abstract class WindowsMessageHandler {\n+  /// Handles a window message.\n+  ///\n+  /// Returned value, if not null will be returned to the system as LRESULT\n+  /// and will stop all other handlers from being called. See\n+  /// https://learn.microsoft.com/en-us/windows/win32/api/winuser/nc-winuser-wndproc\n+  /// for more information.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  @internal\n+  int? handleWindowsMessage(\n+    FlutterView view,\n+    HWND windowHandle,\n+    int message,\n+    int wParam,\n+    int lParam,\n+  );\n+}\n+\n+/// [WindowingOwner] implementation for Windows.\n+///\n+/// If [Platform.isWindows] is false, then the constructor will throw an\n+/// [UnsupportedError].\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+///\n+/// See also:\n+///\n+///  * [WindowingOwner], the abstract class that manages native windows.\n+@internal\n+class WindowingOwnerWin32 extends WindowingOwner {\n+  /// Creates a new [WindowingOwnerWin32] instance.\n+  ///\n+  /// If [Platform.isWindows] is false, then this constructor will throw an\n+  /// [UnsupportedError]\n+  ///\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [WindowingOwner], the abstract class that manages native windows.\n+  @internal\n+  WindowingOwnerWin32() : allocator = _CallocAllocator._() {\n+    if (!Platform.isWindows) {\n+      throw UnsupportedError('Only available on the Win32 platform');\n+    }\n+\n+    final ffi.Pointer<_WindowingInitRequest> request = allocator<_WindowingInitRequest>()\n+      ..ref.onMessage =\n+          ffi.NativeCallable<ffi.Void Function(ffi.Pointer<_WindowsMessage>)>.isolateLocal(\n+            _onMessage,\n+          ).nativeFunction;\n+    _Win32PlatformInterface.initializeWindowing(PlatformDispatcher.instance.engineId!, request);\n+    allocator.free(request);\n+  }\n+\n+  final List<WindowsMessageHandler> _messageHandlers = <WindowsMessageHandler>[];\n+\n+  /// The [Allocator] used for allocating native memory in this owner.\n+  ///\n+  /// This can be overridden via the [WindowingOwnerWin32.test] constructor.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  @internal\n+  final ffi.Allocator allocator;\n+\n+  @internal\n+  @override\n+  RegularWindowController createRegularWindowController({\n+    Size? preferredSize,\n+    BoxConstraints? preferredConstraints,\n+    String? title,\n+    required RegularWindowControllerDelegate delegate,\n+  }) {\n+    return RegularWindowControllerWin32(\n+      owner: this,\n+      delegate: delegate,\n+      preferredSize: preferredSize,\n+      preferredConstraints: preferredConstraints,\n+      title: title,\n+    );\n+  }\n+\n+  /// Register a new [WindowsMessageHandler].\n+  ///\n+  /// The handler will be triggered for unhandled messages for all top level\n+  /// windows.\n+  ///\n+  /// Adding a handler multiple times has no effect.\n+  ///\n+  /// Handlers are called in the order that they are added.\n+  ///\n+  /// Callers must remove their message handlers using\n+  /// [WindowingOwnerWin32.removeMessageHandler].\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [WindowsMessageHandler], the interface for message handlers.\n+  ///  * [WindowingOwnerWin32.removeMessageHandler], to remove message handlers.\n+  @internal\n+  void addMessageHandler(WindowsMessageHandler handler) {\n+    if (_messageHandlers.contains(handler)) {\n+      return;\n+    }\n+\n+    _messageHandlers.add(handler);\n+  }\n+\n+  /// Unregister a [WindowsMessageHandler].\n+  ///\n+  /// If the handler has not been registered, this method has no effect.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [WindowsMessageHandler], the interface for message handlers.\n+  ///  * [WindowingOwnerWin32.addMessageHandler], to register message handlers.\n+  @internal\n+  void removeMessageHandler(WindowsMessageHandler handler) {\n+    _messageHandlers.remove(handler);\n+  }\n+\n+  void _onMessage(ffi.Pointer<_WindowsMessage> message) {\n+    final List<WindowsMessageHandler> handlers = List<WindowsMessageHandler>.from(_messageHandlers);\n+    final FlutterView flutterView = PlatformDispatcher.instance.views.firstWhere(\n+      (FlutterView view) => view.viewId == message.ref.viewId,\n+    );\n+    for (final WindowsMessageHandler handler in handlers) {\n+      final int? result = handler.handleWindowsMessage(\n+        flutterView,\n+        message.ref.windowHandle,\n+        message.ref.message,\n+        message.ref.wParam,\n+        message.ref.lParam,\n+      );\n+      if (result != null) {\n+        message.ref.handled = true;\n+        message.ref.lResult = result;\n+        return;\n+      }\n+    }\n+  }\n+\n+  @internal\n+  @override\n+  bool hasTopLevelWindows() {\n+    return _Win32PlatformInterface.hasTopLevelWindows(PlatformDispatcher.instance.engineId!);\n+  }\n+}\n+\n+/// Implementation of [RegularWindowController] for the Windows platform.\n+///\n+/// {@macro flutter.widgets.windowing.experimental}\n+///\n+/// See also:\n+///\n+///  * [RegularWindowController], the base class for regular windows.\n+class RegularWindowControllerWin32 extends RegularWindowController\n+    implements WindowsMessageHandler {\n+  /// Creates a new regular window controller for Win32.\n+  ///\n+  /// When this constructor completes the native window has been created and\n+  /// has a view associated with it.\n+  ///\n+  /// {@macro flutter.widgets.windowing.experimental}\n+  ///\n+  /// See also:\n+  ///\n+  ///  * [RegularWindowController], the base class for regular windows.\n+  @internal\n+  RegularWindowControllerWin32({\n+    required WindowingOwnerWin32 owner,\n+    required RegularWindowControllerDelegate delegate,\n+    Size? preferredSize,\n+    BoxConstraints? preferredConstraints,\n+    String? title,\n+  }) : _owner = owner,\n+       _delegate = delegate,\n+       super.empty() {\n+    owner.addMessageHandler(this);\n+    final ffi.Pointer<_WindowCreationRequest> request = owner.allocator<_WindowCreationRequest>()\n+      ..ref.preferredSize.from(preferredSize)\n+      ..ref.preferredConstraints.from(preferredConstraints)\n+      ..ref.title = (title ?? 'Regular window').toNativeUtf16(allocator: _owner.allocator);\n+    final int viewId = _Win32PlatformInterface.createWindow(\n+      PlatformDispatcher.instance.engineId!,\n+      request,\n+    );\n+    owner.allocator.free(request);\n+    final FlutterView flutterView = PlatformDispatcher.instance.views.firstWhere(\n+      (FlutterView view) => view.viewId == viewId,\n+    );\n+    rootView = flutterView;\n+  }\n+\n+  final WindowingOwnerWin32 _owner;\n+  final RegularWindowControllerDelegate _delegate;\n+  bool _destroyed = false;\n+\n+  @override\n+  @internal\n+  Size get contentSize {\n+    _ensureNotDestroyed();\n+    final _ActualContentSize size = _Win32PlatformInterface.getWindowContentSize(getWindowHandle());\n+    final Size result = Size(size.width, size.height);\n+    return result;\n+  }\n+\n+  @override\n+  @internal\n+  String get title {\n+    _ensureNotDestroyed();\n+    final int length = _Win32PlatformInterface.getWindowTextLength(getWindowHandle());\n+    if (length == 0) {\n+      return '';\n+    }\n+\n+    final ffi.Pointer<ffi.Uint16> data = _owner.allocator<ffi.Uint16>(length + 1);\n+    try {\n+      final ffi.Pointer<_Utf16> buffer = data.cast<_Utf16>();\n+      _Win32PlatformInterface.getWindowText(getWindowHandle(), buffer, length + 1);\n+      return buffer.toDartString();\n+    } finally {\n+      _owner.allocator.free(data);\n+    }\n+  }\n+\n+  @override\n+  @internal\n+  bool get isActivated {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.getForegroundWindow() == getWindowHandle();\n+  }\n+\n+  @override\n+  @internal\n+  bool get isMaximized {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.isZoomed(getWindowHandle()) != 0;\n+  }\n+\n+  @override\n+  @internal\n+  bool get isMinimized {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.isIconic(getWindowHandle()) != 0;\n+  }\n+\n+  @override\n+  @internal\n+  bool get isFullscreen {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.getFullscreen(getWindowHandle());\n+  }\n+\n+  @override\n+  @internal\n+  void setSize(Size? size) {\n+    _ensureNotDestroyed();\n+    final ffi.Pointer<_WindowSizeRequest> request = _owner.allocator<_WindowSizeRequest>();\n+    request.ref.hasSize = size != null;\n+    request.ref.width = size?.width ?? 0;\n+    request.ref.height = size?.height ?? 0;\n+    _Win32PlatformInterface.setWindowContentSize(getWindowHandle(), request);\n+    _owner.allocator.free(request);\n+  }\n+\n+  @override\n+  @internal\n+  void setConstraints(BoxConstraints constraints) {\n+    _ensureNotDestroyed();\n+    final ffi.Pointer<_WindowConstraintsRequest> request = _owner\n+        .allocator<_WindowConstraintsRequest>();\n+    request.ref.from(constraints);\n+    _Win32PlatformInterface.setWindowConstraints(getWindowHandle(), request);\n+    _owner.allocator.free(request);\n+\n+    notifyListeners();\n+  }\n+\n+  @override\n+  @internal\n+  void setTitle(String title) {\n+    _ensureNotDestroyed();\n+    final ffi.Pointer<_Utf16> titlePointer = title.toNativeUtf16(allocator: _owner.allocator);\n+    _Win32PlatformInterface.setWindowTitle(getWindowHandle(), titlePointer);\n+    _owner.allocator.free(titlePointer);\n+\n+    notifyListeners();\n+  }\n+\n+  @override\n+  @internal\n+  void activate() {\n+    _ensureNotDestroyed();\n+    _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_RESTORE);\n+  }\n+\n+  @override\n+  @internal\n+  void setMaximized(bool maximized) {\n+    _ensureNotDestroyed();\n+    if (maximized) {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_MAXIMIZE);\n+    } else {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_RESTORE);\n+    }\n+  }\n+\n+  @override\n+  @internal\n+  void setMinimized(bool minimized) {\n+    _ensureNotDestroyed();\n+    if (minimized) {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_MINIMIZE);\n+    } else {\n+      _Win32PlatformInterface.showWindow(getWindowHandle(), _SW_RESTORE);\n+    }\n+  }\n+\n+  @override\n+  @internal\n+  void setFullscreen(bool fullscreen, {Display? display}) {\n+    final ffi.Pointer<_WindowFullscreenRequest> request = _owner\n+        .allocator<_WindowFullscreenRequest>();\n+    request.ref.hasDisplayId = false;\n+    request.ref.displayId = display?.id ?? 0;\n+    request.ref.fullscreen = fullscreen;\n+    _Win32PlatformInterface.setFullscreen(getWindowHandle(), request);\n+    _owner.allocator.free(request);\n+  }\n+\n+  /// Returns HWND pointer to the top level window.\n+  @internal\n+  HWND getWindowHandle() {\n+    _ensureNotDestroyed();\n+    return _Win32PlatformInterface.getWindowHandle(\n+      PlatformDispatcher.instance.engineId!,\n+      rootView.viewId,\n+    );\n+  }\n+\n+  void _ensureNotDestroyed() {\n+    if (_destroyed) {\n+      throw StateError('Window has been destroyed.');\n+    }\n+  }\n+\n+  @override\n+  void destroy() {\n+    if (_destroyed) {\n+      return;\n+    }\n+    _Win32PlatformInterface.destroyWindow(getWindowHandle());\n+    _destroyed = true;\n+    _delegate.onWindowDestroyed();\n+    _owner.removeMessageHandler(this);",
        "comment_created_at": "2025-08-19T00:16:36+00:00",
        "comment_author": "loic-sharma",
        "comment_body": "Should we unregister ourself before destroying our self? This ensures we don't get into problems like us receiving messages in the middle of destroying ourself.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2287452036",
    "pr_number": 173881,
    "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
    "created_at": "2025-08-20T08:48:18+00:00",
    "commented_code": "slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2287452036",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-20T08:48:18+00:00",
        "comment_author": "flar",
        "comment_body": "I don't understand this change, if the has_content flag is true, then shouldn't the showOverlay method have been called in the showIfNeeded call?",
        "pr_file_module": null
      },
      {
        "comment_id": "2287453497",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-20T08:48:54+00:00",
        "comment_author": "flar",
        "comment_body": "Doesn't this result in an extra JNI dispatch to \"showOverlaySurface2\"?",
        "pr_file_module": null
      },
      {
        "comment_id": "2288861755",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-20T17:36:41+00:00",
        "comment_author": "gmackall",
        "comment_body": "> I don't understand this change, if the has_content flag is true, then shouldn't the showOverlay method have been called in the showIfNeeded call?\r\n\r\nYes, this was always the case. The reason I added it is that if it isn't true, before we would still have called dispatched to `showOverlaySurface2` when we have the following two frames:\r\n\r\none with\r\n1. NO PVs visible\r\n2. YES Overlay content to display\r\n\r\nfollowed by a frame with\r\n1. YES PVs visible\r\n2. NO Overlay content to display\r\n\r\nBut in this case we still don't want to display the overlay surface (it would result in the same bug that the PR is fixing in the first place). So this addition guards against that",
        "pr_file_module": null
      },
      {
        "comment_id": "2288873317",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-20T17:42:15+00:00",
        "comment_author": "gmackall",
        "comment_body": "Adding an and to the if statement doesn't result in an extra call, as it only makes the dispatch to `showOverlaySurface2` happen less often.\r\n\r\nBut before this change, and still after, we will get a double dispatch if we get two frames in a row with the following properties:\r\n1. NO PVs visible\r\n2. NO overlay content to display\r\n\r\nfollowed by\r\n1. YES PVs visible \r\n2. YES Overlay content to display",
        "pr_file_module": null
      },
      {
        "comment_id": "2291846983",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T18:34:43+00:00",
        "comment_author": "gmackall",
        "comment_body": "Let me know if any of this needs clarifying",
        "pr_file_module": null
      },
      {
        "comment_id": "2292185063",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T21:36:11+00:00",
        "comment_author": "flar",
        "comment_body": "What confuses me is that the only way that \"overlay_layer_has_content_\" can become true (the only assignment to it that sets it to true) is right after the ShowIfNeeded method calls `showOverlaySurface2()`.\r\n\r\nSo, if the variable being true means absolutely that someone called `showOverlaySurface2` then why does it need to be called here?\r\n\r\nOh, hey, there is a call in this file to hideOverlaySurface2 that doesn't go through the new methods. I think this might be cleaner if we made the private methods to hide and show it while setting the status variable true/false be the only way that we call those jni_facade methods.",
        "pr_file_module": null
      },
      {
        "comment_id": "2292186799",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T21:37:28+00:00",
        "comment_author": "flar",
        "comment_body": "See lines 76/77.",
        "pr_file_module": null
      },
      {
        "comment_id": "2292194086",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T21:41:29+00:00",
        "comment_author": "flar",
        "comment_body": "We might be able to also get rid of the prev_frame_no_pvs variable as well.\r\n\r\nUp top, if we don't have anything to process, then call the internal hideIfNeeded method.\r\n\r\nThen we show it if overlay_frame isn't null, or we show it in the callback, but only one of those should be needed, shouldn't it?\r\n\r\nAlso, is that PostTask run in a different thread? If it is, then we might want to think about whether the first case of noticing no more platform views shouldn't also be delegated to a Posted Task.",
        "pr_file_module": null
      },
      {
        "comment_id": "2292195109",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T21:42:10+00:00",
        "comment_author": "flar",
        "comment_body": "We need to either always call it in this method, or always call it in a posted task on the other thread. Having it called by either thread could lead to race conditions.",
        "pr_file_module": null
      },
      {
        "comment_id": "2292231473",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T22:03:47+00:00",
        "comment_author": "gmackall",
        "comment_body": "> Up top, if we don't have anything to process, then call the internal hideIfNeeded method.\r\n>\r\n> Then we show it if overlay_frame isn't null, or we show it in the callback, but only one of those should be needed, shouldn't it?\r\n\r\nI don't believe this would work. The problem is that the visibility of the overlay frame is a function of: 1. if we have overlay content to display and 2. if the platform view layer has platform views to display\r\n\r\nwe can't model this with just one boolean/calls to the method that set just one boolean.",
        "pr_file_module": null
      },
      {
        "comment_id": "2292242307",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T22:13:14+00:00",
        "comment_author": "gmackall",
        "comment_body": "Hmm maybe it would actually work, perhaps we can just remove the call that this comment is on and rely on the earlier call. Give me a moment to try it out",
        "pr_file_module": null
      },
      {
        "comment_id": "2292292264",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T22:53:15+00:00",
        "comment_author": "gmackall",
        "comment_body": "I've changed to something like you suggested. I'm a bit apprehensive about the approach, as if the state gets out of sync with the actual visibility of the surface the problems are more persistent now. But can go with this approach if you prefer. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2292305620",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T23:04:55+00:00",
        "comment_author": "flar",
        "comment_body": "A - do we really need an overlay\r\nB - are we currently showing the overlay\r\nC - who toggles B based on A.\r\n\r\nA - I think the main discovery here is that we had 2 places where we decided whether or not overlay was needed - one at the top of the method, and then another in/after the loop where we think we might need overlays, but we might also be wrong and we only know as we run through the loop entries. So, cleaning up the decision about whether this frame should have an overlay was a good aspect of this fix.\r\n\r\nB - Also, consolidating the JNI hide/show calls with a boolean that only makes the call if the state is different makes it easier to deploy the actual calls without conflict with each other's state.\r\n\r\nC - But, we also have \"who should do the actual JNI hide/show for best consistency and thread safety\" and finding a good place for those \"hide/showIfNeeded\" calls - that's I think where we are right now. It looks like there is another thread involved - thus the PostTask - so we should make that thread be the one that makes the actual toggle of the overlay surface based on the information determined in A.",
        "pr_file_module": null
      },
      {
        "comment_id": "2292321011",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T23:21:02+00:00",
        "comment_author": "gmackall",
        "comment_body": "I've swapped to toggling the visibility in the thread, PTAL",
        "pr_file_module": null
      },
      {
        "comment_id": "2292354738",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T23:38:58+00:00",
        "comment_author": "flar",
        "comment_body": "We still do it in 2 different threads. The one at the top of SubmitFlutterView is doing it in the calling thread. The one in the PostTask is doing it in the thread that processes those tasks. I'm not sure when this method is called and by which thread so I'm not familiar with whether or not that causes a conflict.\r\n\r\n@reidbaker Are you familiar with these threading issues?",
        "pr_file_module": null
      },
      {
        "comment_id": "2292359314",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T23:40:41+00:00",
        "comment_author": "gmackall",
        "comment_body": "Hmm, this was always the case though. The way in which these threads are used is identical before and after the PR. Do you have a reason to suspect there was an issue with the threading model that Jonah originally wrote?",
        "pr_file_module": null
      },
      {
        "comment_id": "2292364018",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-21T23:43:32+00:00",
        "comment_author": "gmackall",
        "comment_body": "And also if so, do you think it should be addressed in this PR? It sounds to me like that would be an independent problem from the one this PR is solving, given that this pr does not modify the threading approach.",
        "pr_file_module": null
      },
      {
        "comment_id": "2292420315",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-22T00:34:30+00:00",
        "comment_author": "flar",
        "comment_body": "I think we are no worse than we were before on this front, it's more of a \"as long as we are cleaning this up, let's try to deal with other issues that might arise\". I'll approve and if @reidbaker has any suspicions about the threading here we can open up a new issue.",
        "pr_file_module": null
      },
      {
        "comment_id": "2293975753",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-22T14:59:18+00:00",
        "comment_author": "reidbaker",
        "comment_body": "@flar at this point @gmackall understands this code more deeply than I do. Threading issues are tough and if we think we have found a race condition that would cause issues I support gmackall working on a change to that model. If you think that we are in no worse of a condition then I support landing this pr as it is an improvement. \r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2294620298",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-22T20:08:12+00:00",
        "comment_author": "flar",
        "comment_body": "I don't think we are worse than we were before wrt threading. We fixed the bookkeeping, but the calls are still potentially spread between 2 threads. I would suggest to submit a new issue about this, but without a reproducible test case I'm not sure what value that would have. Is there anyone else around who understands the threading of the embedders?",
        "pr_file_module": null
      },
      {
        "comment_id": "2294715121",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-22T20:45:21+00:00",
        "comment_author": "gmackall",
        "comment_body": "This code was mostly written by Jonah and reviewed by John McCutchan iirc. I don't think there is anyone who knows why it was written this way. \n\nI think in the absence of a known issue with it we'd (android team) prefer to avoid make changes here. But if you have a repro of a problem caused by the threading model I'd happily take a look. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2298204652",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T14:04:37+00:00",
        "comment_author": "reidbaker",
        "comment_body": "@gmackall I dont think someone else is going to dig into a repro condition for us. I think we now own this code and the likely issues we will see will be race conditions which will be hard to debug. \r\n\r\nConsider adding a comment in the code about the thread model and maybe we spend some time this week drawing a diagram and figuring out if we think there is an issue. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2298803911",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T18:23:57+00:00",
        "comment_author": "flar",
        "comment_body": "In particular, the thing I suppose might happen here is that a thread might be processing the rendering of a previous frame and show the overlay while another thread is processing a new frame without overlays and hide it. Those 2 threads would be in a race condition.\r\n\r\nBut, at least if we always us the new methods to hide/show the overlay then we have accurate state tracking and once we get an overlay for more than one frame, or it goes away for more than one frame, then we will catch up and it will appear or disappear on the second frame when both threads are now processing frames that both need or don't need the overlay. We might have the wrong state for a frame, but not permanently like we had before.\r\n\r\nIt's still possible in the worst case that the setting of the boolean and the call to change the state get interleaved on the two threads. We can't really solve that without adding the overhead of a mutex.",
        "pr_file_module": null
      },
      {
        "comment_id": "2298819670",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T18:32:25+00:00",
        "comment_author": "reidbaker",
        "comment_body": "@flar how much overhead would a mutex be if we didnt interleave the calls very often? Basically since we know this is called from different threads and there is a boolean should we lock a mutex just to be safe? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2298822563",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T18:33:47+00:00",
        "comment_author": "reidbaker",
        "comment_body": "I am guessing that a possible frame stutter would be the consequence instead of the wrong content which is probably a reasonable trade off if it only happened when we did interleave calls. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2298975141",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T19:46:24+00:00",
        "comment_author": "gmackall",
        "comment_body": "I don't think we should add a mutex here. If we suspect there is an actual issue here, and we want to make a change I would think we would modify lines 73-79:\r\nhttps://github.com/flutter/flutter/blob/master/engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc#L73-L79\r\n\r\nto be something like\r\n```c++\r\n  if (!FrameHasPlatformLayers()) {\r\n    frame->Submit();\r\n    task_runners_.GetPlatformTaskRunner()->PostTask(fml::MakeCopyable(\r\n        [&, jni_facade = jni_facade_]() {\r\n          HideOverlayLayerIfNeeded();\r\n          jni_facade->applyTransaction();\r\n        }));\r\n    return;\r\n  }\r\n```\r\n\r\nso that all work is done on the platform thread. I believe all jni work is intended to be done on the platform thread anyways, based on \r\nhttps://github.com/flutter/flutter/blob/master/engine/src/flutter/shell/platform/android/jni/platform_view_android_jni.h#L31-L36",
        "pr_file_module": null
      },
      {
        "comment_id": "2298999322",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T19:59:24+00:00",
        "comment_author": "flar",
        "comment_body": "I think we'd only need it if the state is actually changing, so the performance impact would be negligible, but it only solves the relatively rare case of mismatched boolean/overlay state which would require an extremely fine race condition.\r\n\r\nThe \"wrong for a frame\" issue has a much higher potential due to a higher chance for bad ordering and solving that would probably require fixing the threading issue which would obviate the need for the mutex.\r\n\r\nI also feel like we have 3 asynchronous time frames here that might interfere and that maybe we need a better architecture.\r\n\r\nOne place in the code calls `SurfaceFrame::Submit` and then directly hides/shows the overlay. How do those interleave given our threading model?\r\n\r\nAnother place in the code calls `SurfaceFrame::Submit` and then posts a task to hide/show the overlay. How do those interleave? And, on top of how the Submit call compares to the posted task, how does the thread that processes the submitted frame compare to the posted task? Are those guaranteed to be back to back?\r\n\r\nIt feels like we need a way to say \"Submit this frame, and when you do, call this other callback when you are finished with processing the submitted frame\" to guarantee that the code that shows/hides the overlay is directly executed while processing a Submit call.",
        "pr_file_module": null
      },
      {
        "comment_id": "2299001878",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T20:00:39+00:00",
        "comment_author": "flar",
        "comment_body": "Or, for all I know, is `SubmitFrame` synchronous? I somehow feel that it isn't because why then post the task after submitting it in the second case?",
        "pr_file_module": null
      },
      {
        "comment_id": "2299007985",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T20:03:59+00:00",
        "comment_author": "flar",
        "comment_body": "Back to @gmackall - yes I think that using a posted task in both cases is safer.\r\n\r\nBut I still wonder how the timing of processing a call to Submit compares to processing a posted task. I feel like this should be `SubmitAnd(callback-to-be-called-when-the-actual-submit-finishes)`.\r\n\r\nThere used to be a concept of skipping a frame that was posted, but I'm not sure if that happens upstream of this code or downstream from it. It's in the rasterizer somewhere and in some cases trying to process a frame can return \"do that again\" or \"skip that one and go on to the next\" and I'm not sure if the separated \"submit vs posttask\" processing here survives those exceptional conditions.",
        "pr_file_module": null
      },
      {
        "comment_id": "2299012652",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T20:06:41+00:00",
        "comment_author": "flar",
        "comment_body": "(See `DrawStatus` and `DrawSurfaceStatus` in rasterizer.h)",
        "pr_file_module": null
      },
      {
        "comment_id": "2299040977",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-25T20:21:52+00:00",
        "comment_author": "flar",
        "comment_body": "It looks like the `Submit` calls simply call callbacks that were supplied when some implementation of `Surface` constructed a `SurfaceFrame` inside its `AcquireFrame` method. In some cases the callbacks just return true. In other cases they make a platform call with non-obvious threading and/or synchronicity implications.\r\n\r\nIt's not clear how the actions of those submit callbacks relate to either further code in the same thread, or in code posted as a task.",
        "pr_file_module": null
      },
      {
        "comment_id": "2301902947",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-26T19:13:05+00:00",
        "comment_author": "gmackall",
        "comment_body": "Ok I spent more time looking in to this and am somewhat more confused, but it seems we maybe don't have a threading problem here? It definitely looks to me like the call to hideOverlaySurface isn't being made on the platform thread, but the method that it calls:\r\nhttps://github.com/flutter/flutter/blob/master/engine/src/flutter/shell/platform/android/io/flutter/embedding/engine/FlutterJNI.java#L1338\r\nIs annotated as being callable only on the ui thread.\r\n\r\nAnd even if I locally add a line to ensure this:\r\n```java\r\n  @SuppressLint(\"NewApi\")\r\n  @UiThread\r\n  public void hideOverlaySurface2() {\r\n    ensureRunningOnMainThread(); // <-- new line here\r\n    if (platformViewsController2 == null) {\r\n      throw new RuntimeException(\r\n          \"platformViewsController must be set before attempting to destroy an overlay surface\");\r\n    }\r\n    platformViewsController2.hideOverlaySurface();\r\n  }\r\n```\r\n\r\nI still don't get an error, which tells me this must be running on the platform (ui) thread. This is extra confusing, because if I log from the c++ side:\r\n```c++\r\n  if (!FrameHasPlatformLayers()) {\r\n    frame->Submit();\r\n    // If the previous frame had platform views, hide the overlay surface.\r\n    HideOverlayLayerIfNeeded();\r\n    FML_LOG(ERROR) << \"HI GRAY, hiding overlay layer because no platform views and current thread is \"\r\n                   << (task_runners_.GetPlatformTaskRunner()->RunsTasksOnCurrentThread()\r\n                           ? \"platform\"\r\n                           : \"not platform\");\r\n    jni_facade_->applyTransaction();\r\n    return;\r\n  }\r\n```\r\nI get logs:\r\n```\r\nHI GRAY, hiding overlay layer because no platform views and current thread is not platform\r\n```\r\n\r\nWhich is extremely confusing! But my takeaway here is that we must eventually be passing this call to the platform thread, as otherwise we would be failing the call to `ensureRunningOnMainThread();`\r\n\r\nSo I think we don't have a race condition here (because it seems everything is being done on the platform thread), even if I don't understand the internals of why that is the case.",
        "pr_file_module": null
      },
      {
        "comment_id": "2302072473",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-26T20:30:22+00:00",
        "comment_author": "flar",
        "comment_body": "Perhaps we could even move both calls out of the posted task back into the main method?",
        "pr_file_module": null
      },
      {
        "comment_id": "2302079051",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173881,
        "pr_file": "engine/src/flutter/shell/platform/android/external_view_embedder/external_view_embedder_2.cc",
        "discussion_id": "2287452036",
        "commented_code": "@@ -167,7 +161,7 @@ void AndroidExternalViewEmbedder2::SubmitFlutterView(\n        slices = std::move(slices_), prev_frame_no_platform_views]() -> void {\n         jni_facade->swapTransaction();\n \n-        if (prev_frame_no_platform_views) {\n+        if (prev_frame_no_platform_views && overlay_layer_has_content_) {",
        "comment_created_at": "2025-08-26T20:33:59+00:00",
        "comment_author": "gmackall",
        "comment_body": "Yeah, I had that thought as well but when I tried that for the task that we are posting below I DID get an error for making a call not on the platform thread:\r\n```\r\nE/flutter ( 7330): [ERROR:flutter/fml/platform/android/jni_util.cc(206)] java.lang.RuntimeException: Methods marked with @UiThread must be executed on the main thread. Current thread: 1.raster\r\nE/flutter ( 7330): \tat io.flutter.embedding.engine.FlutterJNI.ensureRunningOnMainThread(FlutterJNI.java:1607)\r\nE/flutter ( 7330): \tat io.flutter.embedding.engine.FlutterJNI.onDisplayPlatformView2(FlutterJNI.java:1373)\r\n```\r\n\r\nAgain, very strange because it implies we are only passing the hideOverlaySurface calls but not the calls done in the task below. I really don't understand why that would be the case.",
        "pr_file_module": null
      }
    ]
  }
]