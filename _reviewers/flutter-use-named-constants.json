[
  {
    "discussion_id": "2288390516",
    "pr_number": 173359,
    "pr_file": "engine/src/flutter/shell/platform/android/io/flutter/embedding/engine/loader/FlutterLoader.java",
    "created_at": "2025-08-20T14:36:21+00:00",
    "commented_code": "}\n   }\n \n+  /**\n+   * Returns the AOT shared library name flag with the canonical path to the library that the engine\n+   * will use to load application's Dart code if it lives within a path we consider safe, which is a\n+   * path within the application's internal storage. Otherwise, returns null.\n+   *\n+   * <p>If the library lives within the application's internal storage, this means that the\n+   * application developer either explicitly placed the library there or set the Android Gradle\n+   * Plugin jniLibs packaging option {@code useLegacyPackaging} to true; see\n+   * https://developer.android.com/build/releases/past-releases/agp-4-2-0-release-notes#compress-native-libs-dsl\n+   * for more information.\n+   */\n+  private String getSafeAotSharedLibraryNameFlag(\n+      @NonNull Context applicationContext, @NonNull String aotSharedLibraryNameArg)\n+      throws IOException {\n+    // Isolate AOT shared library path.\n+    String prefix = \"--aot-shared-library-name=\";",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2288390516",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173359,
        "pr_file": "engine/src/flutter/shell/platform/android/io/flutter/embedding/engine/loader/FlutterLoader.java",
        "discussion_id": "2288390516",
        "commented_code": "@@ -445,6 +470,47 @@ public void ensureInitializationComplete(\n     }\n   }\n \n+  /**\n+   * Returns the AOT shared library name flag with the canonical path to the library that the engine\n+   * will use to load application's Dart code if it lives within a path we consider safe, which is a\n+   * path within the application's internal storage. Otherwise, returns null.\n+   *\n+   * <p>If the library lives within the application's internal storage, this means that the\n+   * application developer either explicitly placed the library there or set the Android Gradle\n+   * Plugin jniLibs packaging option {@code useLegacyPackaging} to true; see\n+   * https://developer.android.com/build/releases/past-releases/agp-4-2-0-release-notes#compress-native-libs-dsl\n+   * for more information.\n+   */\n+  private String getSafeAotSharedLibraryNameFlag(\n+      @NonNull Context applicationContext, @NonNull String aotSharedLibraryNameArg)\n+      throws IOException {\n+    // Isolate AOT shared library path.\n+    String prefix = \"--aot-shared-library-name=\";",
        "comment_created_at": "2025-08-20T14:36:21+00:00",
        "comment_author": "reidbaker",
        "comment_body": "Use class constant here. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288417801",
    "pr_number": 173359,
    "pr_file": "engine/src/flutter/shell/platform/android/test/io/flutter/embedding/engine/loader/FlutterLoaderTest.java",
    "created_at": "2025-08-20T14:44:36+00:00",
    "commented_code": "List<String> arguments = Arrays.asList(shellArgsCaptor.getValue());\n     assertTrue(arguments.contains(shaderModeArg));\n   }\n+\n+  @Test\n+  public void itSetsAotSharedLibraryNameIfPathIsInInternalStorage() throws IOException {\n+    FlutterJNI mockFlutterJNI = mock(FlutterJNI.class);\n+    FlutterLoader flutterLoader = spy(new FlutterLoader(mockFlutterJNI));\n+    Context mockApplicationContext = mock(Context.class);\n+    File internalStorageDir = ctx.getFilesDir();\n+    Path internalStorageDirAsPathObj = internalStorageDir.toPath();\n+\n+    ctx.getApplicationInfo().nativeLibraryDir =\n+        Paths.get(\"some\", \"path\", \"doesnt\", \"matter\").toString();\n+    assertFalse(flutterLoader.initialized());\n+    flutterLoader.startInitialization(ctx);\n+\n+    // Test paths for library living within internal storage.\n+    Path pathWithDirectInternalStoragePath = internalStorageDirAsPathObj.resolve(\"library.so\");\n+    Path pathWithNestedInternalStoragePath =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"some\", \"directories\", \"library.so\"));\n+    Path pathWithIndirectInternalStoragePath1 =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"someDirectory\", \"..\", \"library.so\"));\n+    Path pathWithIndirectInternalStoragePath2 =\n+        internalStorageDirAsPathObj.resolve(\n+            Paths.get(\"some\", \"directory\", \"..\", \"..\", \"library.so\"));\n+    Path pathWithIndirectInternalStoragePath3 =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"some\", \"directory\", \"..\", \"library.so\"));\n+\n+    Path[] pathsToTest = {\n+      pathWithDirectInternalStoragePath,\n+      pathWithNestedInternalStoragePath,\n+      pathWithIndirectInternalStoragePath1,\n+      pathWithIndirectInternalStoragePath2,\n+      pathWithIndirectInternalStoragePath3\n+    };\n+    String aotSharedNameArgPrefix = \"--aot-shared-library-name=\";\n+\n+    for (Path testPath : pathsToTest) {\n+      String path = testPath.toString();\n+      String aotSharedLibraryNameArg = aotSharedNameArgPrefix + path;\n+      String[] args = {aotSharedLibraryNameArg};\n+      flutterLoader.ensureInitializationComplete(ctx, args);\n+      shadowOf(getMainLooper()).idle();\n+\n+      ArgumentCaptor<String[]> shellArgsCaptor = ArgumentCaptor.forClass(String[].class);\n+      verify(mockFlutterJNI)\n+          .init(\n+              eq(ctx),\n+              shellArgsCaptor.capture(),\n+              anyString(),\n+              anyString(),\n+              anyString(),\n+              anyLong(),\n+              anyInt());\n+\n+      List<String> actualArgs = Arrays.asList(shellArgsCaptor.getValue());\n+\n+      // This check works because the tests run in debug mode. If run in release (or JIT release)\n+      // mode, actualArgs would contain the default arguments for AOT shared library name on top\n+      // of aotSharedLibraryNameArg.\n+      String canonicalTestPath = testPath.toFile().getCanonicalPath();\n+      String canonicalAotSharedLibraryNameArg = aotSharedNameArgPrefix + canonicalTestPath;\n+      assertTrue(\n+          \"Args sent to FlutterJni.init incorrectly did not include path \" + path,\n+          actualArgs.contains(canonicalAotSharedLibraryNameArg));\n+\n+      // Reset FlutterLoader and mockFlutterJNI to make more calls to\n+      // FlutterLoader.ensureInitialized and mockFlutterJNI.init for testing.\n+      flutterLoader.initialized = false;\n+      clearInvocations(mockFlutterJNI);\n+    }\n+  }\n+\n+  @Test\n+  public void itDoesNotSetAotSharedLibraryNameIfPathOutsideInternalStorage() throws IOException {\n+    FlutterJNI mockFlutterJNI = mock(FlutterJNI.class);\n+    FlutterLoader flutterLoader = spy(new FlutterLoader(mockFlutterJNI));\n+    Context mockApplicationContext = mock(Context.class);\n+    File internalStorageDir = ctx.getFilesDir();\n+    Path internalStorageDirAsPathObj = internalStorageDir.toPath();\n+    String internalStorageDirPath = internalStorageDir.getCanonicalPath();\n+\n+    ctx.getApplicationInfo().nativeLibraryDir =\n+        Paths.get(\"some\", \"path\", \"doesnt\", \"matter\").toString();\n+    assertFalse(flutterLoader.initialized());\n+    flutterLoader.startInitialization(ctx);\n+\n+    // Test paths for library living outside internal storage.\n+    Path pathThatIsCompletelyUnrelated = Paths.get(\"please\", \"dont\", \"fail\");\n+    Path pathWithIndirectOutsideInternalStorage =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"..\", \"library.so\"));\n+    Path pathWithMoreIndirectOutsideInternalStorage =\n+        internalStorageDirAsPathObj.resolve(\n+            Paths.get(\"some\", \"directory\", \"..\", \"..\", \"..\", \"library.so\"));\n+    Path pathWithoutSoFile =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"library.somethingElse\"));\n+    Path pathWithPartialInternalStoragePath =\n+        internalStorageDirAsPathObj.getParent().resolve(\"library.so\");",
    "repo_full_name": "flutter/flutter",
    "discussion_comments": [
      {
        "comment_id": "2288417801",
        "repo_full_name": "flutter/flutter",
        "pr_number": 173359,
        "pr_file": "engine/src/flutter/shell/platform/android/test/io/flutter/embedding/engine/loader/FlutterLoaderTest.java",
        "discussion_id": "2288417801",
        "commented_code": "@@ -399,4 +405,151 @@ public void itSetsShaderInitModeFromMetaData() {\n     List<String> arguments = Arrays.asList(shellArgsCaptor.getValue());\n     assertTrue(arguments.contains(shaderModeArg));\n   }\n+\n+  @Test\n+  public void itSetsAotSharedLibraryNameIfPathIsInInternalStorage() throws IOException {\n+    FlutterJNI mockFlutterJNI = mock(FlutterJNI.class);\n+    FlutterLoader flutterLoader = spy(new FlutterLoader(mockFlutterJNI));\n+    Context mockApplicationContext = mock(Context.class);\n+    File internalStorageDir = ctx.getFilesDir();\n+    Path internalStorageDirAsPathObj = internalStorageDir.toPath();\n+\n+    ctx.getApplicationInfo().nativeLibraryDir =\n+        Paths.get(\"some\", \"path\", \"doesnt\", \"matter\").toString();\n+    assertFalse(flutterLoader.initialized());\n+    flutterLoader.startInitialization(ctx);\n+\n+    // Test paths for library living within internal storage.\n+    Path pathWithDirectInternalStoragePath = internalStorageDirAsPathObj.resolve(\"library.so\");\n+    Path pathWithNestedInternalStoragePath =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"some\", \"directories\", \"library.so\"));\n+    Path pathWithIndirectInternalStoragePath1 =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"someDirectory\", \"..\", \"library.so\"));\n+    Path pathWithIndirectInternalStoragePath2 =\n+        internalStorageDirAsPathObj.resolve(\n+            Paths.get(\"some\", \"directory\", \"..\", \"..\", \"library.so\"));\n+    Path pathWithIndirectInternalStoragePath3 =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"some\", \"directory\", \"..\", \"library.so\"));\n+\n+    Path[] pathsToTest = {\n+      pathWithDirectInternalStoragePath,\n+      pathWithNestedInternalStoragePath,\n+      pathWithIndirectInternalStoragePath1,\n+      pathWithIndirectInternalStoragePath2,\n+      pathWithIndirectInternalStoragePath3\n+    };\n+    String aotSharedNameArgPrefix = \"--aot-shared-library-name=\";\n+\n+    for (Path testPath : pathsToTest) {\n+      String path = testPath.toString();\n+      String aotSharedLibraryNameArg = aotSharedNameArgPrefix + path;\n+      String[] args = {aotSharedLibraryNameArg};\n+      flutterLoader.ensureInitializationComplete(ctx, args);\n+      shadowOf(getMainLooper()).idle();\n+\n+      ArgumentCaptor<String[]> shellArgsCaptor = ArgumentCaptor.forClass(String[].class);\n+      verify(mockFlutterJNI)\n+          .init(\n+              eq(ctx),\n+              shellArgsCaptor.capture(),\n+              anyString(),\n+              anyString(),\n+              anyString(),\n+              anyLong(),\n+              anyInt());\n+\n+      List<String> actualArgs = Arrays.asList(shellArgsCaptor.getValue());\n+\n+      // This check works because the tests run in debug mode. If run in release (or JIT release)\n+      // mode, actualArgs would contain the default arguments for AOT shared library name on top\n+      // of aotSharedLibraryNameArg.\n+      String canonicalTestPath = testPath.toFile().getCanonicalPath();\n+      String canonicalAotSharedLibraryNameArg = aotSharedNameArgPrefix + canonicalTestPath;\n+      assertTrue(\n+          \"Args sent to FlutterJni.init incorrectly did not include path \" + path,\n+          actualArgs.contains(canonicalAotSharedLibraryNameArg));\n+\n+      // Reset FlutterLoader and mockFlutterJNI to make more calls to\n+      // FlutterLoader.ensureInitialized and mockFlutterJNI.init for testing.\n+      flutterLoader.initialized = false;\n+      clearInvocations(mockFlutterJNI);\n+    }\n+  }\n+\n+  @Test\n+  public void itDoesNotSetAotSharedLibraryNameIfPathOutsideInternalStorage() throws IOException {\n+    FlutterJNI mockFlutterJNI = mock(FlutterJNI.class);\n+    FlutterLoader flutterLoader = spy(new FlutterLoader(mockFlutterJNI));\n+    Context mockApplicationContext = mock(Context.class);\n+    File internalStorageDir = ctx.getFilesDir();\n+    Path internalStorageDirAsPathObj = internalStorageDir.toPath();\n+    String internalStorageDirPath = internalStorageDir.getCanonicalPath();\n+\n+    ctx.getApplicationInfo().nativeLibraryDir =\n+        Paths.get(\"some\", \"path\", \"doesnt\", \"matter\").toString();\n+    assertFalse(flutterLoader.initialized());\n+    flutterLoader.startInitialization(ctx);\n+\n+    // Test paths for library living outside internal storage.\n+    Path pathThatIsCompletelyUnrelated = Paths.get(\"please\", \"dont\", \"fail\");\n+    Path pathWithIndirectOutsideInternalStorage =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"..\", \"library.so\"));\n+    Path pathWithMoreIndirectOutsideInternalStorage =\n+        internalStorageDirAsPathObj.resolve(\n+            Paths.get(\"some\", \"directory\", \"..\", \"..\", \"..\", \"library.so\"));\n+    Path pathWithoutSoFile =\n+        internalStorageDirAsPathObj.resolve(Paths.get(\"library.somethingElse\"));\n+    Path pathWithPartialInternalStoragePath =\n+        internalStorageDirAsPathObj.getParent().resolve(\"library.so\");",
        "comment_created_at": "2025-08-20T14:44:36+00:00",
        "comment_author": "reidbaker",
        "comment_body": "Consider extracting \"library.so\" to a const defaultLibraryName",
        "pr_file_module": null
      }
    ]
  }
]