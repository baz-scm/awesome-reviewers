[
  {
    "discussion_id": "2062481251",
    "pr_number": 4771,
    "pr_file": "pkg/vnet/controller.go",
    "created_at": "2025-04-27T07:06:36+00:00",
    "commented_code": "// Client connection read loop\n func (c *Controller) readLoopClient(ctx context.Context, conn io.ReadWriteCloser) {\n \txl := xlog.FromContextSafe(ctx)\n+\tdefer func() {\n+\t\t// Remove the route when read loop ends (connection closed)\n+\t\tc.clientRouter.removeConnRoute(conn)\n+\t\tconn.Close()\n+\t}()\n+",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "2062481251",
        "repo_full_name": "fatedier/frp",
        "pr_number": 4771,
        "pr_file": "pkg/vnet/controller.go",
        "discussion_id": "2062481251",
        "commented_code": "@@ -137,6 +137,12 @@\n // Client connection read loop\n func (c *Controller) readLoopClient(ctx context.Context, conn io.ReadWriteCloser) {\n \txl := xlog.FromContextSafe(ctx)\n+\tdefer func() {\n+\t\t// Remove the route when read loop ends (connection closed)\n+\t\tc.clientRouter.removeConnRoute(conn)\n+\t\tconn.Close()\n+\t}()\n+",
        "comment_created_at": "2025-04-27T07:06:36+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Missing context-cancellation check may keep the goroutine alive indefinitely**\n\nThe new defer block correctly cleans up the route and closes the connection, \ud83d\udc4d.  \nHowever, the `for` loop never observes `ctx.Done()`. If the caller cancels the context while the connection is still alive (e.g. the remote peer goes silent), this goroutine will never exit because `ReadMessage` will continue to block.\n\n```diff\n for {\n+    // Honor caller cancellation to avoid goroutine leaks\n+    select {\n+    case <-ctx.Done():\n+        xl.Debug(\"readLoopClient cancelled\")\n+        return\n+    default:\n+    }\n     data, err := ReadMessage(conn)\n```\n\nAdding a non-blocking check at the top of the loop is inexpensive and prevents leaks, especially when many virtual-net clients reconnect frequently.\n\n\n\n> Committable suggestion skipped: line range outside the PR's diff.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1756798656",
    "pr_number": 4431,
    "pr_file": "pkg/transport/message.go",
    "created_at": "2024-09-12T12:51:04+00:00",
    "commented_code": "func (impl *transporterImpl) Send(m msg.Message) error {",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "1756798656",
        "repo_full_name": "fatedier/frp",
        "pr_number": 4431,
        "pr_file": "pkg/transport/message.go",
        "discussion_id": "1756798656",
        "commented_code": "@@ -54,7 +54,7 @@ type transporterImpl struct {\n \n func (impl *transporterImpl) Send(m msg.Message) error {",
        "comment_created_at": "2024-09-12T12:51:04+00:00",
        "comment_author": "fatedier",
        "comment_body": "I intend to add a context parameter similar to the Do function to allow cancellation of sending.\r\n\r\nOne case is when the user exits manually, which can be canceled through this mechanism, and another case is for potential scenarios where a timeout might be set later.",
        "pr_file_module": null
      },
      {
        "comment_id": "1758150971",
        "repo_full_name": "fatedier/frp",
        "pr_number": 4431,
        "pr_file": "pkg/transport/message.go",
        "discussion_id": "1756798656",
        "commented_code": "@@ -54,7 +54,7 @@ type transporterImpl struct {\n \n func (impl *transporterImpl) Send(m msg.Message) error {",
        "comment_created_at": "2024-09-13T04:13:43+00:00",
        "comment_author": "ivanszl",
        "comment_body": "Adding context parameters would be a better solution.\r\nIn other cases, adding a timeout is indeed a viable solution, and I have considered using this pattern before",
        "pr_file_module": null
      }
    ]
  }
]