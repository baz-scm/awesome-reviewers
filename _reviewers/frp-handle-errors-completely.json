[
  {
    "discussion_id": "2062481244",
    "pr_number": 4771,
    "pr_file": "pkg/plugin/visitor/virtual_net.go",
    "created_at": "2025-04-27T07:06:36+00:00",
    "commented_code": "reconnectDelay := 10 * time.Second\n \n \tfor {\n-\t\t// Create a signal channel for this connection attempt\n \t\tcurrentCloseSignal := make(chan struct{})\n \n-\t\t// Store the signal channel under lock\n \t\tp.mu.Lock()\n \t\tp.closeSignal = currentCloseSignal\n \t\tp.mu.Unlock()\n \n \t\tselect {\n \t\tcase <-p.ctx.Done():\n \t\t\txl.Infof(\"VirtualNetPlugin run loop for visitor [%s] stopping (context cancelled before pipe creation).\", p.pluginCtx.Name)\n-\t\t\t// Ensure controllerConn from previous loop is cleaned up if necessary\n \t\t\tp.cleanupControllerConn(xl)\n \t\t\treturn\n \t\tdefault:\n \t\t}\n \n \t\tcontrollerConn, pluginConn := net.Pipe()\n \n-\t\t// Store controllerConn under lock for cleanup purposes\n \t\tp.mu.Lock()\n \t\tp.controllerConn = controllerConn\n \t\tp.mu.Unlock()\n \n-\t\t// Wrap pluginConn using CloseNotifyConn\n \t\tpluginNotifyConn := netutil.WrapCloseNotifyConn(pluginConn, func() {\n-\t\t\tclose(currentCloseSignal) // Signal the run loop\n+\t\t\tclose(currentCloseSignal) // Signal the run loop on close.\n \t\t})\n \n-\t\txl.Infof(\"Attempting to register client route for visitor [%s]\", p.pluginCtx.Name)\n-\t\terr := p.pluginCtx.VnetController.RegisterClientRoute(p.ctx, p.pluginCtx.Name, p.routes, controllerConn)\n-\t\tif err != nil {\n-\t\t\txl.Errorf(\"Failed to register client route for visitor [%s]: %v. Retrying after %v\", p.pluginCtx.Name, err, reconnectDelay)\n-\t\t\tp.cleanupPipePair(xl, controllerConn, pluginConn) // Close both ends on registration failure\n-\n-\t\t\t// Wait before retrying registration, unless context is cancelled\n-\t\t\tselect {\n-\t\t\tcase <-time.After(reconnectDelay):\n-\t\t\t\tcontinue // Retry the loop\n-\t\t\tcase <-p.ctx.Done():\n-\t\t\t\txl.Infof(\"VirtualNetPlugin registration retry wait interrupted for visitor [%s]\", p.pluginCtx.Name)\n-\t\t\t\treturn // Exit loop if context is cancelled during wait\n-\t\t\t}\n-\t\t}\n-\n-\t\txl.Infof(\"Successfully registered client route for visitor [%s]. Starting connection handler with CloseNotifyConn.\", p.pluginCtx.Name)\n+\t\txl.Infof(\"attempting to register client route for visitor [%s]\", p.pluginCtx.Name)\n+\t\tp.pluginCtx.VnetController.RegisterClientRoute(p.ctx, p.pluginCtx.Name, p.routes, controllerConn)\n+\t\txl.Infof(\"successfully registered client route for visitor [%s]. Starting connection handler with CloseNotifyConn.\", p.pluginCtx.Name)",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "2062481244",
        "repo_full_name": "fatedier/frp",
        "pr_number": 4771,
        "pr_file": "pkg/plugin/visitor/virtual_net.go",
        "discussion_id": "2062481244",
        "commented_code": "@@ -101,84 +101,59 @@ func (p *VirtualNetPlugin) run() {\n \treconnectDelay := 10 * time.Second\n \n \tfor {\n-\t\t// Create a signal channel for this connection attempt\n \t\tcurrentCloseSignal := make(chan struct{})\n \n-\t\t// Store the signal channel under lock\n \t\tp.mu.Lock()\n \t\tp.closeSignal = currentCloseSignal\n \t\tp.mu.Unlock()\n \n \t\tselect {\n \t\tcase <-p.ctx.Done():\n \t\t\txl.Infof(\"VirtualNetPlugin run loop for visitor [%s] stopping (context cancelled before pipe creation).\", p.pluginCtx.Name)\n-\t\t\t// Ensure controllerConn from previous loop is cleaned up if necessary\n \t\t\tp.cleanupControllerConn(xl)\n \t\t\treturn\n \t\tdefault:\n \t\t}\n \n \t\tcontrollerConn, pluginConn := net.Pipe()\n \n-\t\t// Store controllerConn under lock for cleanup purposes\n \t\tp.mu.Lock()\n \t\tp.controllerConn = controllerConn\n \t\tp.mu.Unlock()\n \n-\t\t// Wrap pluginConn using CloseNotifyConn\n \t\tpluginNotifyConn := netutil.WrapCloseNotifyConn(pluginConn, func() {\n-\t\t\tclose(currentCloseSignal) // Signal the run loop\n+\t\t\tclose(currentCloseSignal) // Signal the run loop on close.\n \t\t})\n \n-\t\txl.Infof(\"Attempting to register client route for visitor [%s]\", p.pluginCtx.Name)\n-\t\terr := p.pluginCtx.VnetController.RegisterClientRoute(p.ctx, p.pluginCtx.Name, p.routes, controllerConn)\n-\t\tif err != nil {\n-\t\t\txl.Errorf(\"Failed to register client route for visitor [%s]: %v. Retrying after %v\", p.pluginCtx.Name, err, reconnectDelay)\n-\t\t\tp.cleanupPipePair(xl, controllerConn, pluginConn) // Close both ends on registration failure\n-\n-\t\t\t// Wait before retrying registration, unless context is cancelled\n-\t\t\tselect {\n-\t\t\tcase <-time.After(reconnectDelay):\n-\t\t\t\tcontinue // Retry the loop\n-\t\t\tcase <-p.ctx.Done():\n-\t\t\t\txl.Infof(\"VirtualNetPlugin registration retry wait interrupted for visitor [%s]\", p.pluginCtx.Name)\n-\t\t\t\treturn // Exit loop if context is cancelled during wait\n-\t\t\t}\n-\t\t}\n-\n-\t\txl.Infof(\"Successfully registered client route for visitor [%s]. Starting connection handler with CloseNotifyConn.\", p.pluginCtx.Name)\n+\t\txl.Infof(\"attempting to register client route for visitor [%s]\", p.pluginCtx.Name)\n+\t\tp.pluginCtx.VnetController.RegisterClientRoute(p.ctx, p.pluginCtx.Name, p.routes, controllerConn)\n+\t\txl.Infof(\"successfully registered client route for visitor [%s]. Starting connection handler with CloseNotifyConn.\", p.pluginCtx.Name)\n ",
        "comment_created_at": "2025-04-27T07:06:36+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udca1 Verification agent_\n\n<details>\n<summary>\ud83e\udde9 Analysis chain</summary>\n\n**Missing failure-handling & back-off for `RegisterClientRoute`**\n\n`RegisterClientRoute` is invoked optimistically and any failure (e.g. controller not yet initialised or duplicate name) will go unnoticed, causing the loop to proceed as if the route were in place.  \nA transient error will not close either end of the pipe, so the plugin will stall instead of retrying.\n\nConsider:\n\n```diff\n- p.pluginCtx.VnetController.RegisterClientRoute(p.ctx, p.pluginCtx.Name, p.routes, controllerConn)\n+ if err := p.pluginCtx.VnetController.RegisterClientRoute(\n+     p.ctx, p.pluginCtx.Name, p.routes, controllerConn); err != nil {\n+     xl.Warnf(\"register client route for visitor [%s] failed: %v\", p.pluginCtx.Name, err)\n+     p.cleanupControllerConn(xl)\n+     time.Sleep(reconnectDelay)\n+     continue\n+ }\n```\n\nIf the controller API was intentionally changed to return no error, at least add a boolean / callback that signals refusal so that the plugin knows it must tear down and retry.  \nOtherwise the reconnection logic below is never triggered.\n\n---\n\nI\u2019d like to confirm the signature of `RegisterClientRoute` to see whether it returns an error we can handle. Running a quick search:\n\n---\n\n\ud83c\udfc1 Script executed:\n\n```shell\n#!/bin/bash\nrg --context 3 \"RegisterClientRoute\" -n pkg\n```\n\nLength of output: 1243\n\n---\n\n\n\n</details>\n\n**Add error return to RegisterClientRoute and handle failures**  \nThe controller\u2019s `RegisterClientRoute` currently returns nothing, so the plugin has no way to detect or back off on failures. To avoid silent stalls, update the controller API to return an error (or boolean) and then handle it in the plugin\u2019s retry loop:\n\n\u2013 In `pkg/vnet/controller.go` around line 241, change the signature:  \n```go\n- func (c *Controller) RegisterClientRoute(ctx context.Context, name string, routes []net.IPNet, conn io.ReadWriteCloser) {\n+ func (c *Controller) RegisterClientRoute(ctx context.Context, name string, routes []net.IPNet, conn io.ReadWriteCloser) error {\n     c.clientRouter.addRoute(name, routes, conn)\n     go c.readLoopClient(ctx, conn)\n+    return nil // or any failure from addRoute\n}\n```\n\n\u2013 In `pkg/plugin/visitor/virtual_net.go` lines 128\u2013131, handle the returned error and implement a back-off loop:  \n```diff\n-   p.pluginCtx.VnetController.RegisterClientRoute(p.ctx, p.pluginCtx.Name, p.routes, controllerConn)\n+   if err := p.pluginCtx.VnetController.RegisterClientRoute(\n+       p.ctx, p.pluginCtx.Name, p.routes, controllerConn); err != nil {\n+       xl.Warnf(\"register client route for visitor [%s] failed: %v\", p.pluginCtx.Name, err)\n+       p.cleanupControllerConn(xl)\n+       time.Sleep(reconnectDelay)\n+       continue\n+   }\n```\n\nThis ensures transient errors don\u2019t leave the plugin stalled.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1087437404",
    "pr_number": 3271,
    "pr_file": "pkg/config/proxy.go",
    "created_at": "2023-01-26T04:48:01+00:00",
    "commented_code": "cfg.ProxyType = pMsg.ProxyType\n \tcfg.UseEncryption = pMsg.UseEncryption\n \tcfg.UseCompression = pMsg.UseCompression\n+\tcfg.BandwidthLimit, _ = NewBandwidthQuantity(pMsg.BandwidthLimit)",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "1087437404",
        "repo_full_name": "fatedier/frp",
        "pr_number": 3271,
        "pr_file": "pkg/config/proxy.go",
        "discussion_id": "1087437404",
        "commented_code": "@@ -399,6 +400,7 @@ func (cfg *BaseProxyConf) unmarshalFromMsg(pMsg *msg.NewProxy) {\n \tcfg.ProxyType = pMsg.ProxyType\n \tcfg.UseEncryption = pMsg.UseEncryption\n \tcfg.UseCompression = pMsg.UseCompression\n+\tcfg.BandwidthLimit, _ = NewBandwidthQuantity(pMsg.BandwidthLimit)",
        "comment_created_at": "2023-01-26T04:48:01+00:00",
        "comment_author": "cbodonnell",
        "comment_body": "will result in an empty bandwidth limit if `NewBandwidthQuantity(...)` returns an error.  can use the other method `MustBandwidthQuantity(...)`, but it will require that the plugin sets a valid `bandwidth_limit` or else it will cause frps to panic.",
        "pr_file_module": null
      },
      {
        "comment_id": "1092731399",
        "repo_full_name": "fatedier/frp",
        "pr_number": 3271,
        "pr_file": "pkg/config/proxy.go",
        "discussion_id": "1087437404",
        "commented_code": "@@ -399,6 +400,7 @@ func (cfg *BaseProxyConf) unmarshalFromMsg(pMsg *msg.NewProxy) {\n \tcfg.ProxyType = pMsg.ProxyType\n \tcfg.UseEncryption = pMsg.UseEncryption\n \tcfg.UseCompression = pMsg.UseCompression\n+\tcfg.BandwidthLimit, _ = NewBandwidthQuantity(pMsg.BandwidthLimit)",
        "comment_created_at": "2023-02-01T03:33:08+00:00",
        "comment_author": "cbodonnell",
        "comment_body": "~Same for `bandwidth_limit_mode` below.  Defaults to `\"client\"` even if there is an error, so we can ignore and take the default if we want.~\r\n\r\n**Edit:** this no longer relevant for `bandwidth_limit_mode`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "384675444",
    "pr_number": 1666,
    "pr_file": "server/service.go",
    "created_at": "2020-02-26T18:18:45+00:00",
    "commented_code": "// Check auth.\n \tif err := svr.authVerifier.VerifyNewWorkConn(newMsg); err != nil {\n \t\txl.Warn(\"Invalid authentication in NewWorkConn message on run id [%s]\", newMsg.RunId)\n+\t\tmsg.WriteMsg(workConn, &msg.StartWorkConn{",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "384675444",
        "repo_full_name": "fatedier/frp",
        "pr_number": 1666,
        "pr_file": "server/service.go",
        "discussion_id": "384675444",
        "commented_code": "@@ -438,6 +438,9 @@ func (svr *Service) RegisterWorkConn(workConn net.Conn, newMsg *msg.NewWorkConn)\n \t// Check auth.\n \tif err := svr.authVerifier.VerifyNewWorkConn(newMsg); err != nil {\n \t\txl.Warn(\"Invalid authentication in NewWorkConn message on run id [%s]\", newMsg.RunId)\n+\t\tmsg.WriteMsg(workConn, &msg.StartWorkConn{",
        "comment_created_at": "2020-02-26T18:18:45+00:00",
        "comment_author": "fatedier",
        "comment_body": "I maybe forgot to close workConn after an error occurred.\r\n\r\nIt seems better to return an error here and close workConn if err isn't nil.\r\n\r\n```go\r\n...\r\nswitch {\r\n    case *msg.NewWorkConn:\r\n        if err := svr.RegisterWorkConn(conn, m); err != nil {\r\n            conn.Close()\r\n        }\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "382985380",
    "pr_number": 1661,
    "pr_file": "server/proxy/tcphttptunnel.go",
    "created_at": "2020-02-23T09:01:54+00:00",
    "commented_code": "+// Copyright 2020 guylewin, guy@lewin.co.il\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package proxy\n+\n+import (\n+\t\"github.com/fatedier/frp/models/config\"\n+\t\"github.com/fatedier/frp/utils/util\"\n+\t\"github.com/fatedier/frp/utils/vhost\"\n+\t\"strings\"\n+)\n+\n+type TcpHttpTunnelProxy struct {\n+\t*BaseProxy\n+\tcfg *config.TcpHttpTunnelProxyConf\n+\n+\trealPort int\n+}\n+\n+func (pxy *TcpHttpTunnelProxy) Run() (remoteAddr string, err error) {\n+\txl := pxy.xl\n+\trouteConfig := &vhost.VhostRouteConfig{}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tpxy.Close()\n+\t\t}\n+\t}()\n+\taddrs := make([]string, 0)\n+\tfor _, domain := range pxy.cfg.CustomDomains {",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "382985380",
        "repo_full_name": "fatedier/frp",
        "pr_number": 1661,
        "pr_file": "server/proxy/tcphttptunnel.go",
        "discussion_id": "382985380",
        "commented_code": "@@ -0,0 +1,83 @@\n+// Copyright 2020 guylewin, guy@lewin.co.il\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package proxy\n+\n+import (\n+\t\"github.com/fatedier/frp/models/config\"\n+\t\"github.com/fatedier/frp/utils/util\"\n+\t\"github.com/fatedier/frp/utils/vhost\"\n+\t\"strings\"\n+)\n+\n+type TcpHttpTunnelProxy struct {\n+\t*BaseProxy\n+\tcfg *config.TcpHttpTunnelProxyConf\n+\n+\trealPort int\n+}\n+\n+func (pxy *TcpHttpTunnelProxy) Run() (remoteAddr string, err error) {\n+\txl := pxy.xl\n+\trouteConfig := &vhost.VhostRouteConfig{}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tpxy.Close()\n+\t\t}\n+\t}()\n+\taddrs := make([]string, 0)\n+\tfor _, domain := range pxy.cfg.CustomDomains {",
        "comment_created_at": "2020-02-23T09:01:54+00:00",
        "comment_author": "mpeterson",
        "comment_body": "Inside this `for` you start listening in several ports. If the function succeeds all is good, but what happens if you `return` on an error? Shouldn't you clean up after you on all listeners that you started? ",
        "pr_file_module": null
      },
      {
        "comment_id": "387333632",
        "repo_full_name": "fatedier/frp",
        "pr_number": 1661,
        "pr_file": "server/proxy/tcphttptunnel.go",
        "discussion_id": "382985380",
        "commented_code": "@@ -0,0 +1,83 @@\n+// Copyright 2020 guylewin, guy@lewin.co.il\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package proxy\n+\n+import (\n+\t\"github.com/fatedier/frp/models/config\"\n+\t\"github.com/fatedier/frp/utils/util\"\n+\t\"github.com/fatedier/frp/utils/vhost\"\n+\t\"strings\"\n+)\n+\n+type TcpHttpTunnelProxy struct {\n+\t*BaseProxy\n+\tcfg *config.TcpHttpTunnelProxyConf\n+\n+\trealPort int\n+}\n+\n+func (pxy *TcpHttpTunnelProxy) Run() (remoteAddr string, err error) {\n+\txl := pxy.xl\n+\trouteConfig := &vhost.VhostRouteConfig{}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tpxy.Close()\n+\t\t}\n+\t}()\n+\taddrs := make([]string, 0)\n+\tfor _, domain := range pxy.cfg.CustomDomains {",
        "comment_created_at": "2020-03-03T22:29:15+00:00",
        "comment_author": "GuyLewin",
        "comment_body": "If there's an error (`err != nil`) `pxy.Close()` will be called, which calls l.Close() on every listener in the array.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2062481250",
    "pr_number": 4771,
    "pr_file": "pkg/vnet/controller.go",
    "created_at": "2025-04-27T07:06:36+00:00",
    "commented_code": "}\n \n // Server connection read loop\n-func (c *Controller) readLoopServer(ctx context.Context, conn io.ReadWriteCloser) {\n+func (c *Controller) readLoopServer(ctx context.Context, conn io.ReadWriteCloser, onClose func()) {\n \txl := xlog.FromContextSafe(ctx)\n+\tdefer func() {\n+\t\t// Clean up all IP mappings associated with this connection when it closes\n+\t\tc.serverRouter.cleanupConnIPs(conn)\n+\t\t// Call the provided callback upon closure\n+\t\tif onClose != nil {\n+\t\t\tonClose()\n+\t\t}\n+\t\tconn.Close()\n+\t}()\n+",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "2062481250",
        "repo_full_name": "fatedier/frp",
        "pr_number": 4771,
        "pr_file": "pkg/vnet/controller.go",
        "discussion_id": "2062481250",
        "commented_code": "@@ -181,8 +187,18 @@ func (c *Controller) readLoopClient(ctx context.Context, conn io.ReadWriteCloser\n }\n \n // Server connection read loop\n-func (c *Controller) readLoopServer(ctx context.Context, conn io.ReadWriteCloser) {\n+func (c *Controller) readLoopServer(ctx context.Context, conn io.ReadWriteCloser, onClose func()) {\n \txl := xlog.FromContextSafe(ctx)\n+\tdefer func() {\n+\t\t// Clean up all IP mappings associated with this connection when it closes\n+\t\tc.serverRouter.cleanupConnIPs(conn)\n+\t\t// Call the provided callback upon closure\n+\t\tif onClose != nil {\n+\t\t\tonClose()\n+\t\t}\n+\t\tconn.Close()\n+\t}()\n+",
        "comment_created_at": "2025-04-27T07:06:36+00:00",
        "comment_author": "coderabbitai[bot]",
        "comment_body": "_\ud83d\udee0\ufe0f Refactor suggestion_\n\n**Defer chain is sound, but wrap `onClose` and honour `ctx.Done()`**\n\n1. `onClose()` could panic if the callback itself encounters an unexpected state.  \n2. Similar to the client loop, the server loop will outlive its parent `ctx` if the connection is half-open.\n\n```diff\n-    if onClose != nil {\n-        onClose()\n-    }\n+    if onClose != nil {\n+        // Protect caller from accidental panics inside the callback\n+        func() {\n+            defer func() {\n+                if r := recover(); r != nil {\n+                    xl.Warnf(\"onClose callback panicked: %v\", r)\n+                }\n+            }()\n+            onClose()\n+        }()\n+    }\n```\n\nand inside the main loop:\n\n```diff\n for {\n+    select {\n+    case <-ctx.Done():\n+        xl.Debug(\"readLoopServer cancelled\")\n+        return\n+    default:\n+    }\n```\n\nThese two tweaks make the read loop more robust against both external cancellation and buggy callbacks.\n\n<!-- This is an auto-generated comment by CodeRabbit -->",
        "pr_file_module": null
      }
    ]
  }
]