[
  {
    "discussion_id": "1087437404",
    "pr_number": 3271,
    "pr_file": "pkg/config/proxy.go",
    "created_at": "2023-01-26T04:48:01+00:00",
    "commented_code": "cfg.ProxyType = pMsg.ProxyType\n \tcfg.UseEncryption = pMsg.UseEncryption\n \tcfg.UseCompression = pMsg.UseCompression\n+\tcfg.BandwidthLimit, _ = NewBandwidthQuantity(pMsg.BandwidthLimit)",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "1087437404",
        "repo_full_name": "fatedier/frp",
        "pr_number": 3271,
        "pr_file": "pkg/config/proxy.go",
        "discussion_id": "1087437404",
        "commented_code": "@@ -399,6 +400,7 @@ func (cfg *BaseProxyConf) unmarshalFromMsg(pMsg *msg.NewProxy) {\n \tcfg.ProxyType = pMsg.ProxyType\n \tcfg.UseEncryption = pMsg.UseEncryption\n \tcfg.UseCompression = pMsg.UseCompression\n+\tcfg.BandwidthLimit, _ = NewBandwidthQuantity(pMsg.BandwidthLimit)",
        "comment_created_at": "2023-01-26T04:48:01+00:00",
        "comment_author": "cbodonnell",
        "comment_body": "will result in an empty bandwidth limit if `NewBandwidthQuantity(...)` returns an error.  can use the other method `MustBandwidthQuantity(...)`, but it will require that the plugin sets a valid `bandwidth_limit` or else it will cause frps to panic.",
        "pr_file_module": null
      },
      {
        "comment_id": "1092731399",
        "repo_full_name": "fatedier/frp",
        "pr_number": 3271,
        "pr_file": "pkg/config/proxy.go",
        "discussion_id": "1087437404",
        "commented_code": "@@ -399,6 +400,7 @@ func (cfg *BaseProxyConf) unmarshalFromMsg(pMsg *msg.NewProxy) {\n \tcfg.ProxyType = pMsg.ProxyType\n \tcfg.UseEncryption = pMsg.UseEncryption\n \tcfg.UseCompression = pMsg.UseCompression\n+\tcfg.BandwidthLimit, _ = NewBandwidthQuantity(pMsg.BandwidthLimit)",
        "comment_created_at": "2023-02-01T03:33:08+00:00",
        "comment_author": "cbodonnell",
        "comment_body": "~Same for `bandwidth_limit_mode` below.  Defaults to `\"client\"` even if there is an error, so we can ignore and take the default if we want.~\r\n\r\n**Edit:** this no longer relevant for `bandwidth_limit_mode`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "384675444",
    "pr_number": 1666,
    "pr_file": "server/service.go",
    "created_at": "2020-02-26T18:18:45+00:00",
    "commented_code": "// Check auth.\n \tif err := svr.authVerifier.VerifyNewWorkConn(newMsg); err != nil {\n \t\txl.Warn(\"Invalid authentication in NewWorkConn message on run id [%s]\", newMsg.RunId)\n+\t\tmsg.WriteMsg(workConn, &msg.StartWorkConn{",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "384675444",
        "repo_full_name": "fatedier/frp",
        "pr_number": 1666,
        "pr_file": "server/service.go",
        "discussion_id": "384675444",
        "commented_code": "@@ -438,6 +438,9 @@ func (svr *Service) RegisterWorkConn(workConn net.Conn, newMsg *msg.NewWorkConn)\n \t// Check auth.\n \tif err := svr.authVerifier.VerifyNewWorkConn(newMsg); err != nil {\n \t\txl.Warn(\"Invalid authentication in NewWorkConn message on run id [%s]\", newMsg.RunId)\n+\t\tmsg.WriteMsg(workConn, &msg.StartWorkConn{",
        "comment_created_at": "2020-02-26T18:18:45+00:00",
        "comment_author": "fatedier",
        "comment_body": "I maybe forgot to close workConn after an error occurred.\r\n\r\nIt seems better to return an error here and close workConn if err isn't nil.\r\n\r\n```go\r\n...\r\nswitch {\r\n    case *msg.NewWorkConn:\r\n        if err := svr.RegisterWorkConn(conn, m); err != nil {\r\n            conn.Close()\r\n        }\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "382985380",
    "pr_number": 1661,
    "pr_file": "server/proxy/tcphttptunnel.go",
    "created_at": "2020-02-23T09:01:54+00:00",
    "commented_code": "+// Copyright 2020 guylewin, guy@lewin.co.il\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package proxy\n+\n+import (\n+\t\"github.com/fatedier/frp/models/config\"\n+\t\"github.com/fatedier/frp/utils/util\"\n+\t\"github.com/fatedier/frp/utils/vhost\"\n+\t\"strings\"\n+)\n+\n+type TcpHttpTunnelProxy struct {\n+\t*BaseProxy\n+\tcfg *config.TcpHttpTunnelProxyConf\n+\n+\trealPort int\n+}\n+\n+func (pxy *TcpHttpTunnelProxy) Run() (remoteAddr string, err error) {\n+\txl := pxy.xl\n+\trouteConfig := &vhost.VhostRouteConfig{}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tpxy.Close()\n+\t\t}\n+\t}()\n+\taddrs := make([]string, 0)\n+\tfor _, domain := range pxy.cfg.CustomDomains {",
    "repo_full_name": "fatedier/frp",
    "discussion_comments": [
      {
        "comment_id": "382985380",
        "repo_full_name": "fatedier/frp",
        "pr_number": 1661,
        "pr_file": "server/proxy/tcphttptunnel.go",
        "discussion_id": "382985380",
        "commented_code": "@@ -0,0 +1,83 @@\n+// Copyright 2020 guylewin, guy@lewin.co.il\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package proxy\n+\n+import (\n+\t\"github.com/fatedier/frp/models/config\"\n+\t\"github.com/fatedier/frp/utils/util\"\n+\t\"github.com/fatedier/frp/utils/vhost\"\n+\t\"strings\"\n+)\n+\n+type TcpHttpTunnelProxy struct {\n+\t*BaseProxy\n+\tcfg *config.TcpHttpTunnelProxyConf\n+\n+\trealPort int\n+}\n+\n+func (pxy *TcpHttpTunnelProxy) Run() (remoteAddr string, err error) {\n+\txl := pxy.xl\n+\trouteConfig := &vhost.VhostRouteConfig{}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tpxy.Close()\n+\t\t}\n+\t}()\n+\taddrs := make([]string, 0)\n+\tfor _, domain := range pxy.cfg.CustomDomains {",
        "comment_created_at": "2020-02-23T09:01:54+00:00",
        "comment_author": "mpeterson",
        "comment_body": "Inside this `for` you start listening in several ports. If the function succeeds all is good, but what happens if you `return` on an error? Shouldn't you clean up after you on all listeners that you started? ",
        "pr_file_module": null
      },
      {
        "comment_id": "387333632",
        "repo_full_name": "fatedier/frp",
        "pr_number": 1661,
        "pr_file": "server/proxy/tcphttptunnel.go",
        "discussion_id": "382985380",
        "commented_code": "@@ -0,0 +1,83 @@\n+// Copyright 2020 guylewin, guy@lewin.co.il\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package proxy\n+\n+import (\n+\t\"github.com/fatedier/frp/models/config\"\n+\t\"github.com/fatedier/frp/utils/util\"\n+\t\"github.com/fatedier/frp/utils/vhost\"\n+\t\"strings\"\n+)\n+\n+type TcpHttpTunnelProxy struct {\n+\t*BaseProxy\n+\tcfg *config.TcpHttpTunnelProxyConf\n+\n+\trealPort int\n+}\n+\n+func (pxy *TcpHttpTunnelProxy) Run() (remoteAddr string, err error) {\n+\txl := pxy.xl\n+\trouteConfig := &vhost.VhostRouteConfig{}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tpxy.Close()\n+\t\t}\n+\t}()\n+\taddrs := make([]string, 0)\n+\tfor _, domain := range pxy.cfg.CustomDomains {",
        "comment_created_at": "2020-03-03T22:29:15+00:00",
        "comment_author": "GuyLewin",
        "comment_body": "If there's an error (`err != nil`) `pxy.Close()` will be called, which calls l.Close() on every listener in the array.",
        "pr_file_module": null
      }
    ]
  }
]