[
  {
    "discussion_id": "2183014852",
    "pr_number": 1805,
    "pr_file": "packages/core/src/core/subagent.ts",
    "created_at": "2025-07-03T14:59:53+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getFolderStructure } from '../utils/getFolderStructure.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+import { ReadManyFilesTool } from '../tools/read-many-files.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;\n+  /** A list of expected output objects and the variables they should emit. */\n+  outputs: Record<string, string>;\n+  /** A list of tool names (in the tool registry) or full function declarations that the subagent is permitted to use. */\n+  tools: Array<string | FunctionDeclaration>;\n+}\n+\n+/**\n+ * Configures the generative model parameters for the subagent.\n+ * This interface specifies the model to be used and its associated generation settings,\n+ * such as temperature and top-p values, which influence the creativity and diversity of the model's output.\n+ */\n+export interface ModelConfig {\n+  /** The name or identifier of the model to be used. */\n+  model: string;\n+  /** The temperature for the model's sampling process. */\n+  temp: number;\n+  /** The top-p value for nucleus sampling. */\n+  top_p: number;\n+}\n+\n+/**\n+ * Configures the execution environment and constraints for the subagent.\n+ * This interface defines parameters that control the subagent's runtime behavior,\n+ * such as maximum execution time, to prevent infinite loops or excessive resource consumption.\n+ */\n+export interface RunConfig {\n+  /** The maximum execution time for the subagent in minutes. */\n+  max_time_minutes: number;\n+}\n+\n+/**\n+ * Manages the runtime context state for the subagent.\n+ * This class provides a mechanism to store and retrieve key-value pairs\n+ * that represent the dynamic state and variables accessible to the subagent\n+ * during its execution.\n+ */\n+export class ContextState {\n+  private state: Record<string, unknown> = {};\n+\n+  /**\n+   * Retrieves a value from the context state.\n+   *\n+   * @param key - The key of the value to retrieve.\n+   * @returns The value associated with the key, or undefined if the key is not found.\n+   */\n+  get(key: string): unknown {\n+    return this.state[key];\n+  }\n+\n+  /**\n+   * Sets a value in the context state.\n+   *\n+   * @param key - The key to set the value under.\n+   * @param value - The value to set.\n+   */\n+  set(key: string, value: unknown): void {\n+    this.state[key] = value;\n+  }\n+\n+  /**\n+   * Retrieves all keys in the context state.\n+   *\n+   * @returns An array of all keys in the context state.\n+   */\n+  get_keys(): string[] {\n+    return Object.keys(this.state);\n+  }\n+}\n+\n+/**\n+ * Replaces `${...}` placeholders in a template string with values from a context.\n+ *\n+ * This function identifies all placeholders in the format `${key}`, validates that\n+ * each key exists in the provided `ContextState`, and then performs the substitution.\n+ *\n+ * @param template The template string containing placeholders.\n+ * @param context The `ContextState` object providing placeholder values.\n+ * @returns The populated string with all placeholders replaced.\n+ * @throws {Error} if any placeholder key is not found in the context.\n+ */\n+function templateString(template: string, context: ContextState): string {\n+  const placeholderRegex = /\\$\\{(\\w+)\\}/g;\n+\n+  // First, find all unique keys required by the template.\n+  const requiredKeys = new Set(\n+    Array.from(template.matchAll(placeholderRegex), (match) => match[1]),\n+  );\n+\n+  // Check if all required keys exist in the context.\n+  const contextKeys = new Set(context.get_keys());\n+  const missingKeys = Array.from(requiredKeys).filter(\n+    (key) => !contextKeys.has(key),\n+  );\n+\n+  if (missingKeys.length > 0) {\n+    throw new Error(\n+      `Missing context values for the following keys: ${missingKeys.join(\n+        ', ',\n+      )}`,\n+    );\n+  }\n+\n+  // Perform the replacement using a replacer function.\n+  return template.replace(placeholderRegex, (_match, key) =>\n+    String(context.get(key)),\n+  );\n+}\n+\n+/**\n+ * Represents the scope and execution environment for a subagent.\n+ * This class orchestrates the subagent's lifecycle, managing its chat interactions,\n+ * runtime context, and the collection of its outputs.\n+ */\n+export class SubAgentScope {\n+  output: OutputObject = {\n+    terminate_reason: SubagentTerminateMode.ERROR,\n+    emitted_vars: {},\n+  };\n+\n+  /**\n+   * Constructs a new SubAgentScope instance.\n+   * @param runtimeContext - The shared runtime configuration and services.\n+   * @param promptConfig - Configuration for the subagent's prompt and behavior.\n+   * @param modelConfig - Configuration for the generative model parameters.\n+   * @param runConfig - Configuration for the subagent's execution environment and constraints.\n+   */\n+  constructor(\n+    readonly runtimeContext: Config,\n+    private readonly promptConfig: PromptConfig,\n+    private readonly modelConfig: ModelConfig,\n+    private readonly runConfig: RunConfig,\n+  ) {}\n+\n+  /**\n+   * Runs the subagent in a non-interactive mode.\n+   * This method orchestrates the subagent's execution loop, including prompt templating,\n+   * tool execution, and termination conditions. It manages the chat history, handles\n+   * tool calls, and determines when the subagent's goals are met or if a timeout occurs.\n+   * @param {ContextState} context - The current context state containing variables for prompt templating.\n+   * @returns {Promise<void>} A promise that resolves when the subagent has completed its execution.\n+   */\n+  async runNonInteractive(context: ContextState): Promise<void> {\n+    const chat = await this.createChatObject();\n+\n+    if (!chat) {\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      return;\n+    }\n+\n+    const abortController = new AbortController();\n+    const toolRegistry: ToolRegistry =\n+      await this.runtimeContext.getToolRegistry();\n+\n+    // Prepare the list of tools available to the subagent.\n+    const tools_to_load: string[] = [];\n+    const toolsList: FunctionDeclaration[] = [];\n+    for (const toolName of this.promptConfig.tools) {\n+      if (typeof toolName === 'string') {\n+        tools_to_load.push(toolName);\n+      } else {\n+        toolsList.push(toolName);\n+      }\n+    }\n+\n+    toolsList.push(\n+      ...toolRegistry.getFunctionDeclarationsFiltered(tools_to_load),\n+    );\n+    toolsList.push(...this.getScopeLocalFuncDefs());\n+\n+    chat.setSystemInstruction(this.buildChatSystemPrompt(context, toolsList));\n+\n+    let currentMessages: Content[] = [\n+      { role: 'user', parts: [{ text: 'Get Started!' }] },\n+    ];\n+\n+    const startTime = Date.now();\n+    try {\n+      while (true) {\n+        // Check for timeout.\n+        const duration = Date.now() - startTime;\n+        const durationMin = duration / (1000 * 60);\n+        if (durationMin >= this.runConfig.max_time_minutes) {\n+          this.output.terminate_reason = SubagentTerminateMode.TIMEOUT;\n+          break;\n+        }\n+\n+        const messageParams = {\n+          message: currentMessages[0]?.parts || [],\n+          config: {\n+            abortSignal: abortController.signal,\n+            tools: [{ functionDeclarations: toolsList }],\n+          },\n+        };\n+\n+        // Send the message to the GeminiChat object, which will manage its own history\n+        const responseStream = await chat.sendMessageStream(messageParams);\n+\n+        // Combine all chunks in stream for proper processing.\n+        const functionCalls: FunctionCall[] = [];\n+        for await (const resp of responseStream) {\n+          if (abortController.signal.aborted) {\n+            console.error('Operation cancelled.');\n+            return;\n+          }\n+\n+          const calls = resp.functionCalls;\n+          if (calls) {\n+            functionCalls.push(...calls);\n+          }\n+        }\n+\n+        if (functionCalls.length > 0) {\n+          currentMessages = await this.processFunctionCalls(\n+            functionCalls,\n+            toolRegistry,\n+            abortController,\n+            currentMessages,\n+          );\n+        } else {\n+          // The model has stopped calling tools, which signals completion.\n+          // Verify that all expected output variables have been emitted.\n+          const remainingVars = Object.keys(this.promptConfig.outputs).filter(\n+            (key) => !(key in this.output.emitted_vars),\n+          );\n+\n+          if (remainingVars.length === 0) {\n+            this.output.terminate_reason = SubagentTerminateMode.GOAL;\n+            break;\n+          }\n+\n+          // If variables are missing, the loop continues, relying on the\n+          // system prompt to guide the model to call self.emitvalue.\n+          console.debug(\n+            'Variables appear to be missing. Relying on model to call EmitValue.',\n+          );\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error during subagent execution:', error);\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Processes a list of function calls, executing each one and collecting their responses.\n+   * This method iterates through the provided function calls, executes them using the\n+   * `executeToolCall` function (or handles `self.emitvalue` internally), and aggregates\n+   * their results. It also manages error reporting for failed tool executions.\n+   * @param {FunctionCall[]} functionCalls - An array of `FunctionCall` objects to process.\n+   * @param {ToolRegistry} toolRegistry - The tool registry to look up and execute tools.\n+   * @param {AbortController} abortController - An `AbortController` to signal cancellation of tool executions.\n+   * @param {Content[]} currentMessages - The current list of messages in the chat history, which will be updated with tool responses.\n+   * @returns {Promise<Content[]>} A promise that resolves to an array of `Content` parts representing the tool responses,\n+   *          which are then used to update the chat history.\n+   */\n+  private async processFunctionCalls(\n+    functionCalls: FunctionCall[],\n+    toolRegistry: ToolRegistry,\n+    abortController: AbortController,\n+    currentMessages: Content[],\n+  ) {\n+    const toolResponseParts: Part[] = [];\n+\n+    for (const functionCall of functionCalls) {\n+      const callId = functionCall.id ?? `${functionCall.name}-${Date.now()}`;\n+      const requestInfo: ToolCallRequestInfo = {\n+        callId,\n+        name: functionCall.name as string,\n+        args: (functionCall.args ?? {}) as Record<string, unknown>,\n+        isClientInitiated: true,\n+      };\n+\n+      let toolResponse;\n+\n+      // Handle scope-local tools first.\n+      if (callId.startsWith('self.emitvalue')) {\n+        const valName = String(requestInfo.args['emit_variable_name']);\n+        const valVal = String(requestInfo.args['emit_variable_value']);\n+        this.output.emitted_vars[valName] = valVal;\n+\n+        toolResponse = {\n+          callId,\n+          responseParts: `Emitted variable ${valName} successfully`,\n+          resultDisplay: `Emitted variable ${valName} successfully`,\n+          error: undefined,\n+        };\n+      } else {\n+        toolResponse = await executeToolCall(\n+          this.runtimeContext,\n+          requestInfo,\n+          toolRegistry,\n+          abortController.signal,\n+        );\n+      }\n+\n+      if (toolResponse.error) {\n+        console.error(\n+          `Error executing tool ${functionCall.name}: ${toolResponse.resultDisplay || toolResponse.error.message}`,\n+        );\n+        // Continue to the next tool call instead of halting execution.\n+        continue;\n+      }\n+\n+      if (toolResponse.responseParts) {\n+        const parts = Array.isArray(toolResponse.responseParts)\n+          ? toolResponse.responseParts\n+          : [toolResponse.responseParts];\n+        for (const part of parts) {\n+          if (typeof part === 'string') {\n+            toolResponseParts.push({ text: part });\n+          } else if (part) {\n+            toolResponseParts.push(part);\n+          }\n+        }\n+      }\n+    }\n+    currentMessages = [{ role: 'user', parts: toolResponseParts }];\n+    return currentMessages;\n+  }\n+\n+  /**\n+   * Creates an instance of `GeminiChat` unique for the subagent's purposes.\n+   * It initializes the chat with environment variables and configures the content generator.\n+   * @param {Content[]} [extraHistory] - Optional additional chat history to include.\n+   * @returns {Promise<GeminiChat | undefined>} A promise that resolves to a `GeminiChat` instance, or undefined if creation fails.\n+   */\n+  private async createChatObject(extraHistory?: Content[]) {\n+    const envParts = await this.getEnvironment();\n+    const initialHistory: Content[] = [\n+      {\n+        role: 'user',\n+        parts: envParts,\n+      },\n+      {\n+        role: 'model',\n+        parts: [{ text: 'Got it. Thanks for the context!' }],\n+      },\n+    ];\n+\n+    const start_history = [...initialHistory, ...(extraHistory ?? [])];\n+\n+    // The system instruction is set dynamically within the run loop to allow\n+    // for context-based templating.\n+    const systemInstruction = '';\n+\n+    try {\n+      const targetContentConfig: GenerateContentConfig = {\n+        temperature: this.modelConfig.temp,\n+        topP: this.modelConfig.top_p,\n+      };\n+\n+      const generationConfig = {\n+        systemInstruction,\n+        ...targetContentConfig,\n+      };\n+\n+      const contentGenerator = await createContentGenerator(\n+        this.runtimeContext.getContentGeneratorConfig(),\n+      );\n+\n+      this.runtimeContext.setModel(this.modelConfig.model);\n+\n+      return new GeminiChat(\n+        this.runtimeContext,\n+        contentGenerator,\n+        generationConfig,\n+        start_history,\n+      );\n+    } catch (error) {\n+      await reportError(\n+        error,\n+        'Error initializing Gemini chat session.',\n+        start_history,\n+        'startChat',\n+      );\n+      // The calling function will handle the undefined return.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Retrieves environment-related information to be included in the chat context.\n+   * This includes the current working directory, date, operating system, and folder structure.\n+   * Optionally, it can also include the full file context if enabled.\n+   * @returns A promise that resolves to an array of `Part` objects containing environment information.\n+   */\n+  private async getEnvironment(): Promise<Part[]> {\n+    const cwd = this.runtimeContext.getWorkingDir();\n+    const today = new Date().toLocaleDateString(undefined, {\n+      weekday: 'long',\n+      year: 'numeric',\n+      month: 'long',\n+      day: 'numeric',\n+    });\n+    const platform = process.platform;\n+    const folderStructure = await getFolderStructure(cwd, {\n+      fileService: this.runtimeContext.getFileService(),\n+    });\n+    const context = `\n+  Okay, just setting up the context for our chat.\n+  Today is ${today}.\n+  My operating system is: ${platform}\n+  I'm currently working in the directory: ${cwd}\n+  ${folderStructure}\n+          `.trim();\n+\n+    const initialParts: Part[] = [{ text: context }];\n+    const toolRegistry = await this.runtimeContext.getToolRegistry();\n+\n+    // Add full file context if the flag is set\n+    if (this.runtimeContext.getFullContext()) {\n+      try {\n+        const readManyFilesTool = toolRegistry.getTool(\n+          'read_many_files',\n+        ) as ReadManyFilesTool;\n+        if (readManyFilesTool) {\n+          // Read all files in the target directory\n+          const result = await readManyFilesTool.execute(\n+            {\n+              paths: ['**/*'], // Read everything recursively\n+              useDefaultExcludes: true, // Use default excludes\n+            },\n+            AbortSignal.timeout(30000),\n+          );\n+          if (result.llmContent) {\n+            initialParts.push({\n+              text: `\n--- Full File Context ---\n${result.llmContent}`,\n+            });\n+          } else {\n+            console.warn(\n+              'Full context requested, but read_many_files returned no content.',\n+            );\n+          }\n+        }\n+      } catch (error) {\n+        // This error is logged but doesn't halt the process, as full context is optional.\n+        console.error('Error reading full file context:', error);\n+        initialParts.push({\n+          text: '\n--- Error reading full file context ---',\n+        });\n+      }\n+    }\n+\n+    return initialParts;\n+  }\n+\n+  /**\n+   * Returns an array of FunctionDeclaration objects for tools that are local to the subagent's scope.\n+   * Currently, this includes the `self.emitvalue` tool for emitting variables.\n+   * @returns An array of `FunctionDeclaration` objects.\n+   */\n+  private getScopeLocalFuncDefs() {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2183014852",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1805,
        "pr_file": "packages/core/src/core/subagent.ts",
        "discussion_id": "2183014852",
        "commented_code": "@@ -0,0 +1,599 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getFolderStructure } from '../utils/getFolderStructure.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+import { ReadManyFilesTool } from '../tools/read-many-files.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;\n+  /** A list of expected output objects and the variables they should emit. */\n+  outputs: Record<string, string>;\n+  /** A list of tool names (in the tool registry) or full function declarations that the subagent is permitted to use. */\n+  tools: Array<string | FunctionDeclaration>;\n+}\n+\n+/**\n+ * Configures the generative model parameters for the subagent.\n+ * This interface specifies the model to be used and its associated generation settings,\n+ * such as temperature and top-p values, which influence the creativity and diversity of the model's output.\n+ */\n+export interface ModelConfig {\n+  /** The name or identifier of the model to be used. */\n+  model: string;\n+  /** The temperature for the model's sampling process. */\n+  temp: number;\n+  /** The top-p value for nucleus sampling. */\n+  top_p: number;\n+}\n+\n+/**\n+ * Configures the execution environment and constraints for the subagent.\n+ * This interface defines parameters that control the subagent's runtime behavior,\n+ * such as maximum execution time, to prevent infinite loops or excessive resource consumption.\n+ */\n+export interface RunConfig {\n+  /** The maximum execution time for the subagent in minutes. */\n+  max_time_minutes: number;\n+}\n+\n+/**\n+ * Manages the runtime context state for the subagent.\n+ * This class provides a mechanism to store and retrieve key-value pairs\n+ * that represent the dynamic state and variables accessible to the subagent\n+ * during its execution.\n+ */\n+export class ContextState {\n+  private state: Record<string, unknown> = {};\n+\n+  /**\n+   * Retrieves a value from the context state.\n+   *\n+   * @param key - The key of the value to retrieve.\n+   * @returns The value associated with the key, or undefined if the key is not found.\n+   */\n+  get(key: string): unknown {\n+    return this.state[key];\n+  }\n+\n+  /**\n+   * Sets a value in the context state.\n+   *\n+   * @param key - The key to set the value under.\n+   * @param value - The value to set.\n+   */\n+  set(key: string, value: unknown): void {\n+    this.state[key] = value;\n+  }\n+\n+  /**\n+   * Retrieves all keys in the context state.\n+   *\n+   * @returns An array of all keys in the context state.\n+   */\n+  get_keys(): string[] {\n+    return Object.keys(this.state);\n+  }\n+}\n+\n+/**\n+ * Replaces `${...}` placeholders in a template string with values from a context.\n+ *\n+ * This function identifies all placeholders in the format `${key}`, validates that\n+ * each key exists in the provided `ContextState`, and then performs the substitution.\n+ *\n+ * @param template The template string containing placeholders.\n+ * @param context The `ContextState` object providing placeholder values.\n+ * @returns The populated string with all placeholders replaced.\n+ * @throws {Error} if any placeholder key is not found in the context.\n+ */\n+function templateString(template: string, context: ContextState): string {\n+  const placeholderRegex = /\\$\\{(\\w+)\\}/g;\n+\n+  // First, find all unique keys required by the template.\n+  const requiredKeys = new Set(\n+    Array.from(template.matchAll(placeholderRegex), (match) => match[1]),\n+  );\n+\n+  // Check if all required keys exist in the context.\n+  const contextKeys = new Set(context.get_keys());\n+  const missingKeys = Array.from(requiredKeys).filter(\n+    (key) => !contextKeys.has(key),\n+  );\n+\n+  if (missingKeys.length > 0) {\n+    throw new Error(\n+      `Missing context values for the following keys: ${missingKeys.join(\n+        ', ',\n+      )}`,\n+    );\n+  }\n+\n+  // Perform the replacement using a replacer function.\n+  return template.replace(placeholderRegex, (_match, key) =>\n+    String(context.get(key)),\n+  );\n+}\n+\n+/**\n+ * Represents the scope and execution environment for a subagent.\n+ * This class orchestrates the subagent's lifecycle, managing its chat interactions,\n+ * runtime context, and the collection of its outputs.\n+ */\n+export class SubAgentScope {\n+  output: OutputObject = {\n+    terminate_reason: SubagentTerminateMode.ERROR,\n+    emitted_vars: {},\n+  };\n+\n+  /**\n+   * Constructs a new SubAgentScope instance.\n+   * @param runtimeContext - The shared runtime configuration and services.\n+   * @param promptConfig - Configuration for the subagent's prompt and behavior.\n+   * @param modelConfig - Configuration for the generative model parameters.\n+   * @param runConfig - Configuration for the subagent's execution environment and constraints.\n+   */\n+  constructor(\n+    readonly runtimeContext: Config,\n+    private readonly promptConfig: PromptConfig,\n+    private readonly modelConfig: ModelConfig,\n+    private readonly runConfig: RunConfig,\n+  ) {}\n+\n+  /**\n+   * Runs the subagent in a non-interactive mode.\n+   * This method orchestrates the subagent's execution loop, including prompt templating,\n+   * tool execution, and termination conditions. It manages the chat history, handles\n+   * tool calls, and determines when the subagent's goals are met or if a timeout occurs.\n+   * @param {ContextState} context - The current context state containing variables for prompt templating.\n+   * @returns {Promise<void>} A promise that resolves when the subagent has completed its execution.\n+   */\n+  async runNonInteractive(context: ContextState): Promise<void> {\n+    const chat = await this.createChatObject();\n+\n+    if (!chat) {\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      return;\n+    }\n+\n+    const abortController = new AbortController();\n+    const toolRegistry: ToolRegistry =\n+      await this.runtimeContext.getToolRegistry();\n+\n+    // Prepare the list of tools available to the subagent.\n+    const tools_to_load: string[] = [];\n+    const toolsList: FunctionDeclaration[] = [];\n+    for (const toolName of this.promptConfig.tools) {\n+      if (typeof toolName === 'string') {\n+        tools_to_load.push(toolName);\n+      } else {\n+        toolsList.push(toolName);\n+      }\n+    }\n+\n+    toolsList.push(\n+      ...toolRegistry.getFunctionDeclarationsFiltered(tools_to_load),\n+    );\n+    toolsList.push(...this.getScopeLocalFuncDefs());\n+\n+    chat.setSystemInstruction(this.buildChatSystemPrompt(context, toolsList));\n+\n+    let currentMessages: Content[] = [\n+      { role: 'user', parts: [{ text: 'Get Started!' }] },\n+    ];\n+\n+    const startTime = Date.now();\n+    try {\n+      while (true) {\n+        // Check for timeout.\n+        const duration = Date.now() - startTime;\n+        const durationMin = duration / (1000 * 60);\n+        if (durationMin >= this.runConfig.max_time_minutes) {\n+          this.output.terminate_reason = SubagentTerminateMode.TIMEOUT;\n+          break;\n+        }\n+\n+        const messageParams = {\n+          message: currentMessages[0]?.parts || [],\n+          config: {\n+            abortSignal: abortController.signal,\n+            tools: [{ functionDeclarations: toolsList }],\n+          },\n+        };\n+\n+        // Send the message to the GeminiChat object, which will manage its own history\n+        const responseStream = await chat.sendMessageStream(messageParams);\n+\n+        // Combine all chunks in stream for proper processing.\n+        const functionCalls: FunctionCall[] = [];\n+        for await (const resp of responseStream) {\n+          if (abortController.signal.aborted) {\n+            console.error('Operation cancelled.');\n+            return;\n+          }\n+\n+          const calls = resp.functionCalls;\n+          if (calls) {\n+            functionCalls.push(...calls);\n+          }\n+        }\n+\n+        if (functionCalls.length > 0) {\n+          currentMessages = await this.processFunctionCalls(\n+            functionCalls,\n+            toolRegistry,\n+            abortController,\n+            currentMessages,\n+          );\n+        } else {\n+          // The model has stopped calling tools, which signals completion.\n+          // Verify that all expected output variables have been emitted.\n+          const remainingVars = Object.keys(this.promptConfig.outputs).filter(\n+            (key) => !(key in this.output.emitted_vars),\n+          );\n+\n+          if (remainingVars.length === 0) {\n+            this.output.terminate_reason = SubagentTerminateMode.GOAL;\n+            break;\n+          }\n+\n+          // If variables are missing, the loop continues, relying on the\n+          // system prompt to guide the model to call self.emitvalue.\n+          console.debug(\n+            'Variables appear to be missing. Relying on model to call EmitValue.',\n+          );\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error during subagent execution:', error);\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Processes a list of function calls, executing each one and collecting their responses.\n+   * This method iterates through the provided function calls, executes them using the\n+   * `executeToolCall` function (or handles `self.emitvalue` internally), and aggregates\n+   * their results. It also manages error reporting for failed tool executions.\n+   * @param {FunctionCall[]} functionCalls - An array of `FunctionCall` objects to process.\n+   * @param {ToolRegistry} toolRegistry - The tool registry to look up and execute tools.\n+   * @param {AbortController} abortController - An `AbortController` to signal cancellation of tool executions.\n+   * @param {Content[]} currentMessages - The current list of messages in the chat history, which will be updated with tool responses.\n+   * @returns {Promise<Content[]>} A promise that resolves to an array of `Content` parts representing the tool responses,\n+   *          which are then used to update the chat history.\n+   */\n+  private async processFunctionCalls(\n+    functionCalls: FunctionCall[],\n+    toolRegistry: ToolRegistry,\n+    abortController: AbortController,\n+    currentMessages: Content[],\n+  ) {\n+    const toolResponseParts: Part[] = [];\n+\n+    for (const functionCall of functionCalls) {\n+      const callId = functionCall.id ?? `${functionCall.name}-${Date.now()}`;\n+      const requestInfo: ToolCallRequestInfo = {\n+        callId,\n+        name: functionCall.name as string,\n+        args: (functionCall.args ?? {}) as Record<string, unknown>,\n+        isClientInitiated: true,\n+      };\n+\n+      let toolResponse;\n+\n+      // Handle scope-local tools first.\n+      if (callId.startsWith('self.emitvalue')) {\n+        const valName = String(requestInfo.args['emit_variable_name']);\n+        const valVal = String(requestInfo.args['emit_variable_value']);\n+        this.output.emitted_vars[valName] = valVal;\n+\n+        toolResponse = {\n+          callId,\n+          responseParts: `Emitted variable ${valName} successfully`,\n+          resultDisplay: `Emitted variable ${valName} successfully`,\n+          error: undefined,\n+        };\n+      } else {\n+        toolResponse = await executeToolCall(\n+          this.runtimeContext,\n+          requestInfo,\n+          toolRegistry,\n+          abortController.signal,\n+        );\n+      }\n+\n+      if (toolResponse.error) {\n+        console.error(\n+          `Error executing tool ${functionCall.name}: ${toolResponse.resultDisplay || toolResponse.error.message}`,\n+        );\n+        // Continue to the next tool call instead of halting execution.\n+        continue;\n+      }\n+\n+      if (toolResponse.responseParts) {\n+        const parts = Array.isArray(toolResponse.responseParts)\n+          ? toolResponse.responseParts\n+          : [toolResponse.responseParts];\n+        for (const part of parts) {\n+          if (typeof part === 'string') {\n+            toolResponseParts.push({ text: part });\n+          } else if (part) {\n+            toolResponseParts.push(part);\n+          }\n+        }\n+      }\n+    }\n+    currentMessages = [{ role: 'user', parts: toolResponseParts }];\n+    return currentMessages;\n+  }\n+\n+  /**\n+   * Creates an instance of `GeminiChat` unique for the subagent's purposes.\n+   * It initializes the chat with environment variables and configures the content generator.\n+   * @param {Content[]} [extraHistory] - Optional additional chat history to include.\n+   * @returns {Promise<GeminiChat | undefined>} A promise that resolves to a `GeminiChat` instance, or undefined if creation fails.\n+   */\n+  private async createChatObject(extraHistory?: Content[]) {\n+    const envParts = await this.getEnvironment();\n+    const initialHistory: Content[] = [\n+      {\n+        role: 'user',\n+        parts: envParts,\n+      },\n+      {\n+        role: 'model',\n+        parts: [{ text: 'Got it. Thanks for the context!' }],\n+      },\n+    ];\n+\n+    const start_history = [...initialHistory, ...(extraHistory ?? [])];\n+\n+    // The system instruction is set dynamically within the run loop to allow\n+    // for context-based templating.\n+    const systemInstruction = '';\n+\n+    try {\n+      const targetContentConfig: GenerateContentConfig = {\n+        temperature: this.modelConfig.temp,\n+        topP: this.modelConfig.top_p,\n+      };\n+\n+      const generationConfig = {\n+        systemInstruction,\n+        ...targetContentConfig,\n+      };\n+\n+      const contentGenerator = await createContentGenerator(\n+        this.runtimeContext.getContentGeneratorConfig(),\n+      );\n+\n+      this.runtimeContext.setModel(this.modelConfig.model);\n+\n+      return new GeminiChat(\n+        this.runtimeContext,\n+        contentGenerator,\n+        generationConfig,\n+        start_history,\n+      );\n+    } catch (error) {\n+      await reportError(\n+        error,\n+        'Error initializing Gemini chat session.',\n+        start_history,\n+        'startChat',\n+      );\n+      // The calling function will handle the undefined return.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Retrieves environment-related information to be included in the chat context.\n+   * This includes the current working directory, date, operating system, and folder structure.\n+   * Optionally, it can also include the full file context if enabled.\n+   * @returns A promise that resolves to an array of `Part` objects containing environment information.\n+   */\n+  private async getEnvironment(): Promise<Part[]> {\n+    const cwd = this.runtimeContext.getWorkingDir();\n+    const today = new Date().toLocaleDateString(undefined, {\n+      weekday: 'long',\n+      year: 'numeric',\n+      month: 'long',\n+      day: 'numeric',\n+    });\n+    const platform = process.platform;\n+    const folderStructure = await getFolderStructure(cwd, {\n+      fileService: this.runtimeContext.getFileService(),\n+    });\n+    const context = `\n+  Okay, just setting up the context for our chat.\n+  Today is ${today}.\n+  My operating system is: ${platform}\n+  I'm currently working in the directory: ${cwd}\n+  ${folderStructure}\n+          `.trim();\n+\n+    const initialParts: Part[] = [{ text: context }];\n+    const toolRegistry = await this.runtimeContext.getToolRegistry();\n+\n+    // Add full file context if the flag is set\n+    if (this.runtimeContext.getFullContext()) {\n+      try {\n+        const readManyFilesTool = toolRegistry.getTool(\n+          'read_many_files',\n+        ) as ReadManyFilesTool;\n+        if (readManyFilesTool) {\n+          // Read all files in the target directory\n+          const result = await readManyFilesTool.execute(\n+            {\n+              paths: ['**/*'], // Read everything recursively\n+              useDefaultExcludes: true, // Use default excludes\n+            },\n+            AbortSignal.timeout(30000),\n+          );\n+          if (result.llmContent) {\n+            initialParts.push({\n+              text: `\\n--- Full File Context ---\\n${result.llmContent}`,\n+            });\n+          } else {\n+            console.warn(\n+              'Full context requested, but read_many_files returned no content.',\n+            );\n+          }\n+        }\n+      } catch (error) {\n+        // This error is logged but doesn't halt the process, as full context is optional.\n+        console.error('Error reading full file context:', error);\n+        initialParts.push({\n+          text: '\\n--- Error reading full file context ---',\n+        });\n+      }\n+    }\n+\n+    return initialParts;\n+  }\n+\n+  /**\n+   * Returns an array of FunctionDeclaration objects for tools that are local to the subagent's scope.\n+   * Currently, this includes the `self.emitvalue` tool for emitting variables.\n+   * @returns An array of `FunctionDeclaration` objects.\n+   */\n+  private getScopeLocalFuncDefs() {",
        "comment_created_at": "2025-07-03T14:59:53+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "I'd create a new tool that looks like the existing tools to capture schema. In the end all tools should be re-usable everywhere IMO.",
        "pr_file_module": null
      },
      {
        "comment_id": "2188274778",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1805,
        "pr_file": "packages/core/src/core/subagent.ts",
        "discussion_id": "2183014852",
        "commented_code": "@@ -0,0 +1,599 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getFolderStructure } from '../utils/getFolderStructure.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+import { ReadManyFilesTool } from '../tools/read-many-files.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;\n+  /** A list of expected output objects and the variables they should emit. */\n+  outputs: Record<string, string>;\n+  /** A list of tool names (in the tool registry) or full function declarations that the subagent is permitted to use. */\n+  tools: Array<string | FunctionDeclaration>;\n+}\n+\n+/**\n+ * Configures the generative model parameters for the subagent.\n+ * This interface specifies the model to be used and its associated generation settings,\n+ * such as temperature and top-p values, which influence the creativity and diversity of the model's output.\n+ */\n+export interface ModelConfig {\n+  /** The name or identifier of the model to be used. */\n+  model: string;\n+  /** The temperature for the model's sampling process. */\n+  temp: number;\n+  /** The top-p value for nucleus sampling. */\n+  top_p: number;\n+}\n+\n+/**\n+ * Configures the execution environment and constraints for the subagent.\n+ * This interface defines parameters that control the subagent's runtime behavior,\n+ * such as maximum execution time, to prevent infinite loops or excessive resource consumption.\n+ */\n+export interface RunConfig {\n+  /** The maximum execution time for the subagent in minutes. */\n+  max_time_minutes: number;\n+}\n+\n+/**\n+ * Manages the runtime context state for the subagent.\n+ * This class provides a mechanism to store and retrieve key-value pairs\n+ * that represent the dynamic state and variables accessible to the subagent\n+ * during its execution.\n+ */\n+export class ContextState {\n+  private state: Record<string, unknown> = {};\n+\n+  /**\n+   * Retrieves a value from the context state.\n+   *\n+   * @param key - The key of the value to retrieve.\n+   * @returns The value associated with the key, or undefined if the key is not found.\n+   */\n+  get(key: string): unknown {\n+    return this.state[key];\n+  }\n+\n+  /**\n+   * Sets a value in the context state.\n+   *\n+   * @param key - The key to set the value under.\n+   * @param value - The value to set.\n+   */\n+  set(key: string, value: unknown): void {\n+    this.state[key] = value;\n+  }\n+\n+  /**\n+   * Retrieves all keys in the context state.\n+   *\n+   * @returns An array of all keys in the context state.\n+   */\n+  get_keys(): string[] {\n+    return Object.keys(this.state);\n+  }\n+}\n+\n+/**\n+ * Replaces `${...}` placeholders in a template string with values from a context.\n+ *\n+ * This function identifies all placeholders in the format `${key}`, validates that\n+ * each key exists in the provided `ContextState`, and then performs the substitution.\n+ *\n+ * @param template The template string containing placeholders.\n+ * @param context The `ContextState` object providing placeholder values.\n+ * @returns The populated string with all placeholders replaced.\n+ * @throws {Error} if any placeholder key is not found in the context.\n+ */\n+function templateString(template: string, context: ContextState): string {\n+  const placeholderRegex = /\\$\\{(\\w+)\\}/g;\n+\n+  // First, find all unique keys required by the template.\n+  const requiredKeys = new Set(\n+    Array.from(template.matchAll(placeholderRegex), (match) => match[1]),\n+  );\n+\n+  // Check if all required keys exist in the context.\n+  const contextKeys = new Set(context.get_keys());\n+  const missingKeys = Array.from(requiredKeys).filter(\n+    (key) => !contextKeys.has(key),\n+  );\n+\n+  if (missingKeys.length > 0) {\n+    throw new Error(\n+      `Missing context values for the following keys: ${missingKeys.join(\n+        ', ',\n+      )}`,\n+    );\n+  }\n+\n+  // Perform the replacement using a replacer function.\n+  return template.replace(placeholderRegex, (_match, key) =>\n+    String(context.get(key)),\n+  );\n+}\n+\n+/**\n+ * Represents the scope and execution environment for a subagent.\n+ * This class orchestrates the subagent's lifecycle, managing its chat interactions,\n+ * runtime context, and the collection of its outputs.\n+ */\n+export class SubAgentScope {\n+  output: OutputObject = {\n+    terminate_reason: SubagentTerminateMode.ERROR,\n+    emitted_vars: {},\n+  };\n+\n+  /**\n+   * Constructs a new SubAgentScope instance.\n+   * @param runtimeContext - The shared runtime configuration and services.\n+   * @param promptConfig - Configuration for the subagent's prompt and behavior.\n+   * @param modelConfig - Configuration for the generative model parameters.\n+   * @param runConfig - Configuration for the subagent's execution environment and constraints.\n+   */\n+  constructor(\n+    readonly runtimeContext: Config,\n+    private readonly promptConfig: PromptConfig,\n+    private readonly modelConfig: ModelConfig,\n+    private readonly runConfig: RunConfig,\n+  ) {}\n+\n+  /**\n+   * Runs the subagent in a non-interactive mode.\n+   * This method orchestrates the subagent's execution loop, including prompt templating,\n+   * tool execution, and termination conditions. It manages the chat history, handles\n+   * tool calls, and determines when the subagent's goals are met or if a timeout occurs.\n+   * @param {ContextState} context - The current context state containing variables for prompt templating.\n+   * @returns {Promise<void>} A promise that resolves when the subagent has completed its execution.\n+   */\n+  async runNonInteractive(context: ContextState): Promise<void> {\n+    const chat = await this.createChatObject();\n+\n+    if (!chat) {\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      return;\n+    }\n+\n+    const abortController = new AbortController();\n+    const toolRegistry: ToolRegistry =\n+      await this.runtimeContext.getToolRegistry();\n+\n+    // Prepare the list of tools available to the subagent.\n+    const tools_to_load: string[] = [];\n+    const toolsList: FunctionDeclaration[] = [];\n+    for (const toolName of this.promptConfig.tools) {\n+      if (typeof toolName === 'string') {\n+        tools_to_load.push(toolName);\n+      } else {\n+        toolsList.push(toolName);\n+      }\n+    }\n+\n+    toolsList.push(\n+      ...toolRegistry.getFunctionDeclarationsFiltered(tools_to_load),\n+    );\n+    toolsList.push(...this.getScopeLocalFuncDefs());\n+\n+    chat.setSystemInstruction(this.buildChatSystemPrompt(context, toolsList));\n+\n+    let currentMessages: Content[] = [\n+      { role: 'user', parts: [{ text: 'Get Started!' }] },\n+    ];\n+\n+    const startTime = Date.now();\n+    try {\n+      while (true) {\n+        // Check for timeout.\n+        const duration = Date.now() - startTime;\n+        const durationMin = duration / (1000 * 60);\n+        if (durationMin >= this.runConfig.max_time_minutes) {\n+          this.output.terminate_reason = SubagentTerminateMode.TIMEOUT;\n+          break;\n+        }\n+\n+        const messageParams = {\n+          message: currentMessages[0]?.parts || [],\n+          config: {\n+            abortSignal: abortController.signal,\n+            tools: [{ functionDeclarations: toolsList }],\n+          },\n+        };\n+\n+        // Send the message to the GeminiChat object, which will manage its own history\n+        const responseStream = await chat.sendMessageStream(messageParams);\n+\n+        // Combine all chunks in stream for proper processing.\n+        const functionCalls: FunctionCall[] = [];\n+        for await (const resp of responseStream) {\n+          if (abortController.signal.aborted) {\n+            console.error('Operation cancelled.');\n+            return;\n+          }\n+\n+          const calls = resp.functionCalls;\n+          if (calls) {\n+            functionCalls.push(...calls);\n+          }\n+        }\n+\n+        if (functionCalls.length > 0) {\n+          currentMessages = await this.processFunctionCalls(\n+            functionCalls,\n+            toolRegistry,\n+            abortController,\n+            currentMessages,\n+          );\n+        } else {\n+          // The model has stopped calling tools, which signals completion.\n+          // Verify that all expected output variables have been emitted.\n+          const remainingVars = Object.keys(this.promptConfig.outputs).filter(\n+            (key) => !(key in this.output.emitted_vars),\n+          );\n+\n+          if (remainingVars.length === 0) {\n+            this.output.terminate_reason = SubagentTerminateMode.GOAL;\n+            break;\n+          }\n+\n+          // If variables are missing, the loop continues, relying on the\n+          // system prompt to guide the model to call self.emitvalue.\n+          console.debug(\n+            'Variables appear to be missing. Relying on model to call EmitValue.',\n+          );\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error during subagent execution:', error);\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Processes a list of function calls, executing each one and collecting their responses.\n+   * This method iterates through the provided function calls, executes them using the\n+   * `executeToolCall` function (or handles `self.emitvalue` internally), and aggregates\n+   * their results. It also manages error reporting for failed tool executions.\n+   * @param {FunctionCall[]} functionCalls - An array of `FunctionCall` objects to process.\n+   * @param {ToolRegistry} toolRegistry - The tool registry to look up and execute tools.\n+   * @param {AbortController} abortController - An `AbortController` to signal cancellation of tool executions.\n+   * @param {Content[]} currentMessages - The current list of messages in the chat history, which will be updated with tool responses.\n+   * @returns {Promise<Content[]>} A promise that resolves to an array of `Content` parts representing the tool responses,\n+   *          which are then used to update the chat history.\n+   */\n+  private async processFunctionCalls(\n+    functionCalls: FunctionCall[],\n+    toolRegistry: ToolRegistry,\n+    abortController: AbortController,\n+    currentMessages: Content[],\n+  ) {\n+    const toolResponseParts: Part[] = [];\n+\n+    for (const functionCall of functionCalls) {\n+      const callId = functionCall.id ?? `${functionCall.name}-${Date.now()}`;\n+      const requestInfo: ToolCallRequestInfo = {\n+        callId,\n+        name: functionCall.name as string,\n+        args: (functionCall.args ?? {}) as Record<string, unknown>,\n+        isClientInitiated: true,\n+      };\n+\n+      let toolResponse;\n+\n+      // Handle scope-local tools first.\n+      if (callId.startsWith('self.emitvalue')) {\n+        const valName = String(requestInfo.args['emit_variable_name']);\n+        const valVal = String(requestInfo.args['emit_variable_value']);\n+        this.output.emitted_vars[valName] = valVal;\n+\n+        toolResponse = {\n+          callId,\n+          responseParts: `Emitted variable ${valName} successfully`,\n+          resultDisplay: `Emitted variable ${valName} successfully`,\n+          error: undefined,\n+        };\n+      } else {\n+        toolResponse = await executeToolCall(\n+          this.runtimeContext,\n+          requestInfo,\n+          toolRegistry,\n+          abortController.signal,\n+        );\n+      }\n+\n+      if (toolResponse.error) {\n+        console.error(\n+          `Error executing tool ${functionCall.name}: ${toolResponse.resultDisplay || toolResponse.error.message}`,\n+        );\n+        // Continue to the next tool call instead of halting execution.\n+        continue;\n+      }\n+\n+      if (toolResponse.responseParts) {\n+        const parts = Array.isArray(toolResponse.responseParts)\n+          ? toolResponse.responseParts\n+          : [toolResponse.responseParts];\n+        for (const part of parts) {\n+          if (typeof part === 'string') {\n+            toolResponseParts.push({ text: part });\n+          } else if (part) {\n+            toolResponseParts.push(part);\n+          }\n+        }\n+      }\n+    }\n+    currentMessages = [{ role: 'user', parts: toolResponseParts }];\n+    return currentMessages;\n+  }\n+\n+  /**\n+   * Creates an instance of `GeminiChat` unique for the subagent's purposes.\n+   * It initializes the chat with environment variables and configures the content generator.\n+   * @param {Content[]} [extraHistory] - Optional additional chat history to include.\n+   * @returns {Promise<GeminiChat | undefined>} A promise that resolves to a `GeminiChat` instance, or undefined if creation fails.\n+   */\n+  private async createChatObject(extraHistory?: Content[]) {\n+    const envParts = await this.getEnvironment();\n+    const initialHistory: Content[] = [\n+      {\n+        role: 'user',\n+        parts: envParts,\n+      },\n+      {\n+        role: 'model',\n+        parts: [{ text: 'Got it. Thanks for the context!' }],\n+      },\n+    ];\n+\n+    const start_history = [...initialHistory, ...(extraHistory ?? [])];\n+\n+    // The system instruction is set dynamically within the run loop to allow\n+    // for context-based templating.\n+    const systemInstruction = '';\n+\n+    try {\n+      const targetContentConfig: GenerateContentConfig = {\n+        temperature: this.modelConfig.temp,\n+        topP: this.modelConfig.top_p,\n+      };\n+\n+      const generationConfig = {\n+        systemInstruction,\n+        ...targetContentConfig,\n+      };\n+\n+      const contentGenerator = await createContentGenerator(\n+        this.runtimeContext.getContentGeneratorConfig(),\n+      );\n+\n+      this.runtimeContext.setModel(this.modelConfig.model);\n+\n+      return new GeminiChat(\n+        this.runtimeContext,\n+        contentGenerator,\n+        generationConfig,\n+        start_history,\n+      );\n+    } catch (error) {\n+      await reportError(\n+        error,\n+        'Error initializing Gemini chat session.',\n+        start_history,\n+        'startChat',\n+      );\n+      // The calling function will handle the undefined return.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Retrieves environment-related information to be included in the chat context.\n+   * This includes the current working directory, date, operating system, and folder structure.\n+   * Optionally, it can also include the full file context if enabled.\n+   * @returns A promise that resolves to an array of `Part` objects containing environment information.\n+   */\n+  private async getEnvironment(): Promise<Part[]> {\n+    const cwd = this.runtimeContext.getWorkingDir();\n+    const today = new Date().toLocaleDateString(undefined, {\n+      weekday: 'long',\n+      year: 'numeric',\n+      month: 'long',\n+      day: 'numeric',\n+    });\n+    const platform = process.platform;\n+    const folderStructure = await getFolderStructure(cwd, {\n+      fileService: this.runtimeContext.getFileService(),\n+    });\n+    const context = `\n+  Okay, just setting up the context for our chat.\n+  Today is ${today}.\n+  My operating system is: ${platform}\n+  I'm currently working in the directory: ${cwd}\n+  ${folderStructure}\n+          `.trim();\n+\n+    const initialParts: Part[] = [{ text: context }];\n+    const toolRegistry = await this.runtimeContext.getToolRegistry();\n+\n+    // Add full file context if the flag is set\n+    if (this.runtimeContext.getFullContext()) {\n+      try {\n+        const readManyFilesTool = toolRegistry.getTool(\n+          'read_many_files',\n+        ) as ReadManyFilesTool;\n+        if (readManyFilesTool) {\n+          // Read all files in the target directory\n+          const result = await readManyFilesTool.execute(\n+            {\n+              paths: ['**/*'], // Read everything recursively\n+              useDefaultExcludes: true, // Use default excludes\n+            },\n+            AbortSignal.timeout(30000),\n+          );\n+          if (result.llmContent) {\n+            initialParts.push({\n+              text: `\\n--- Full File Context ---\\n${result.llmContent}`,\n+            });\n+          } else {\n+            console.warn(\n+              'Full context requested, but read_many_files returned no content.',\n+            );\n+          }\n+        }\n+      } catch (error) {\n+        // This error is logged but doesn't halt the process, as full context is optional.\n+        console.error('Error reading full file context:', error);\n+        initialParts.push({\n+          text: '\\n--- Error reading full file context ---',\n+        });\n+      }\n+    }\n+\n+    return initialParts;\n+  }\n+\n+  /**\n+   * Returns an array of FunctionDeclaration objects for tools that are local to the subagent's scope.\n+   * Currently, this includes the `self.emitvalue` tool for emitting variables.\n+   * @returns An array of `FunctionDeclaration` objects.\n+   */\n+  private getScopeLocalFuncDefs() {",
        "comment_created_at": "2025-07-06T13:24:42+00:00",
        "comment_author": "mainroach",
        "comment_body": "We can do that - my hesitation with that path, originally was that it might cause more confusion in the codebase?\r\n\r\n- The top-level MonoAgent doesn't entertain the concept of EmitValues - this is a subagent-only idea.\r\n\r\n- The current codebase doesn't allow for the calling instance pointer to be passed into the tool execution, thus we have to manually filter this tool call inside the SubAgentScope::run function, and handle the variable storage there.\r\n\r\n- As such, EmitValuesTool shouldn't follow the same pattern as existing tools - It shouldn't be initialized in config.ts (since it's not a global singleton, it's scope-local to the calling subagent), and if it was, the `execute` function would be stubbed out (since that execution happens inside the subagent) which means that if someone did accidentally use it outside of the SubAgentScope class, it would lead to undefined results. \r\n\r\nIf you'd like EmitValuesTool to follow the same syntax as other tools, we would need to make a _larger change_ such that we didn't have to stub out the ::execute function : \r\n- modify the ToolBase::execute function definition to **also** accept a dict object of _instance specific variables_ which could be used in the execute loop. \r\n- These values would be provided by the runtime, not the LLM (like the current params are).  \r\n- This way, when a tool is called, it can be passed the calling GeminiChat object, the calling scope (if applicable) or any other instance local variables which may be required for execution or prompt rendering. \r\n\r\nThis would allow EmitValues to be a globally defined tools (like all the other tools are) but allow for invocation specific scoping variables to do execution on. You can see a bunch of scenarios where scope-specific variables are needed, that the runtime manages, not the LLM.\r\n\r\nWDYT?",
        "pr_file_module": null
      },
      {
        "comment_id": "2188458367",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1805,
        "pr_file": "packages/core/src/core/subagent.ts",
        "discussion_id": "2183014852",
        "commented_code": "@@ -0,0 +1,599 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getFolderStructure } from '../utils/getFolderStructure.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+import { ReadManyFilesTool } from '../tools/read-many-files.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;\n+  /** A list of expected output objects and the variables they should emit. */\n+  outputs: Record<string, string>;\n+  /** A list of tool names (in the tool registry) or full function declarations that the subagent is permitted to use. */\n+  tools: Array<string | FunctionDeclaration>;\n+}\n+\n+/**\n+ * Configures the generative model parameters for the subagent.\n+ * This interface specifies the model to be used and its associated generation settings,\n+ * such as temperature and top-p values, which influence the creativity and diversity of the model's output.\n+ */\n+export interface ModelConfig {\n+  /** The name or identifier of the model to be used. */\n+  model: string;\n+  /** The temperature for the model's sampling process. */\n+  temp: number;\n+  /** The top-p value for nucleus sampling. */\n+  top_p: number;\n+}\n+\n+/**\n+ * Configures the execution environment and constraints for the subagent.\n+ * This interface defines parameters that control the subagent's runtime behavior,\n+ * such as maximum execution time, to prevent infinite loops or excessive resource consumption.\n+ */\n+export interface RunConfig {\n+  /** The maximum execution time for the subagent in minutes. */\n+  max_time_minutes: number;\n+}\n+\n+/**\n+ * Manages the runtime context state for the subagent.\n+ * This class provides a mechanism to store and retrieve key-value pairs\n+ * that represent the dynamic state and variables accessible to the subagent\n+ * during its execution.\n+ */\n+export class ContextState {\n+  private state: Record<string, unknown> = {};\n+\n+  /**\n+   * Retrieves a value from the context state.\n+   *\n+   * @param key - The key of the value to retrieve.\n+   * @returns The value associated with the key, or undefined if the key is not found.\n+   */\n+  get(key: string): unknown {\n+    return this.state[key];\n+  }\n+\n+  /**\n+   * Sets a value in the context state.\n+   *\n+   * @param key - The key to set the value under.\n+   * @param value - The value to set.\n+   */\n+  set(key: string, value: unknown): void {\n+    this.state[key] = value;\n+  }\n+\n+  /**\n+   * Retrieves all keys in the context state.\n+   *\n+   * @returns An array of all keys in the context state.\n+   */\n+  get_keys(): string[] {\n+    return Object.keys(this.state);\n+  }\n+}\n+\n+/**\n+ * Replaces `${...}` placeholders in a template string with values from a context.\n+ *\n+ * This function identifies all placeholders in the format `${key}`, validates that\n+ * each key exists in the provided `ContextState`, and then performs the substitution.\n+ *\n+ * @param template The template string containing placeholders.\n+ * @param context The `ContextState` object providing placeholder values.\n+ * @returns The populated string with all placeholders replaced.\n+ * @throws {Error} if any placeholder key is not found in the context.\n+ */\n+function templateString(template: string, context: ContextState): string {\n+  const placeholderRegex = /\\$\\{(\\w+)\\}/g;\n+\n+  // First, find all unique keys required by the template.\n+  const requiredKeys = new Set(\n+    Array.from(template.matchAll(placeholderRegex), (match) => match[1]),\n+  );\n+\n+  // Check if all required keys exist in the context.\n+  const contextKeys = new Set(context.get_keys());\n+  const missingKeys = Array.from(requiredKeys).filter(\n+    (key) => !contextKeys.has(key),\n+  );\n+\n+  if (missingKeys.length > 0) {\n+    throw new Error(\n+      `Missing context values for the following keys: ${missingKeys.join(\n+        ', ',\n+      )}`,\n+    );\n+  }\n+\n+  // Perform the replacement using a replacer function.\n+  return template.replace(placeholderRegex, (_match, key) =>\n+    String(context.get(key)),\n+  );\n+}\n+\n+/**\n+ * Represents the scope and execution environment for a subagent.\n+ * This class orchestrates the subagent's lifecycle, managing its chat interactions,\n+ * runtime context, and the collection of its outputs.\n+ */\n+export class SubAgentScope {\n+  output: OutputObject = {\n+    terminate_reason: SubagentTerminateMode.ERROR,\n+    emitted_vars: {},\n+  };\n+\n+  /**\n+   * Constructs a new SubAgentScope instance.\n+   * @param runtimeContext - The shared runtime configuration and services.\n+   * @param promptConfig - Configuration for the subagent's prompt and behavior.\n+   * @param modelConfig - Configuration for the generative model parameters.\n+   * @param runConfig - Configuration for the subagent's execution environment and constraints.\n+   */\n+  constructor(\n+    readonly runtimeContext: Config,\n+    private readonly promptConfig: PromptConfig,\n+    private readonly modelConfig: ModelConfig,\n+    private readonly runConfig: RunConfig,\n+  ) {}\n+\n+  /**\n+   * Runs the subagent in a non-interactive mode.\n+   * This method orchestrates the subagent's execution loop, including prompt templating,\n+   * tool execution, and termination conditions. It manages the chat history, handles\n+   * tool calls, and determines when the subagent's goals are met or if a timeout occurs.\n+   * @param {ContextState} context - The current context state containing variables for prompt templating.\n+   * @returns {Promise<void>} A promise that resolves when the subagent has completed its execution.\n+   */\n+  async runNonInteractive(context: ContextState): Promise<void> {\n+    const chat = await this.createChatObject();\n+\n+    if (!chat) {\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      return;\n+    }\n+\n+    const abortController = new AbortController();\n+    const toolRegistry: ToolRegistry =\n+      await this.runtimeContext.getToolRegistry();\n+\n+    // Prepare the list of tools available to the subagent.\n+    const tools_to_load: string[] = [];\n+    const toolsList: FunctionDeclaration[] = [];\n+    for (const toolName of this.promptConfig.tools) {\n+      if (typeof toolName === 'string') {\n+        tools_to_load.push(toolName);\n+      } else {\n+        toolsList.push(toolName);\n+      }\n+    }\n+\n+    toolsList.push(\n+      ...toolRegistry.getFunctionDeclarationsFiltered(tools_to_load),\n+    );\n+    toolsList.push(...this.getScopeLocalFuncDefs());\n+\n+    chat.setSystemInstruction(this.buildChatSystemPrompt(context, toolsList));\n+\n+    let currentMessages: Content[] = [\n+      { role: 'user', parts: [{ text: 'Get Started!' }] },\n+    ];\n+\n+    const startTime = Date.now();\n+    try {\n+      while (true) {\n+        // Check for timeout.\n+        const duration = Date.now() - startTime;\n+        const durationMin = duration / (1000 * 60);\n+        if (durationMin >= this.runConfig.max_time_minutes) {\n+          this.output.terminate_reason = SubagentTerminateMode.TIMEOUT;\n+          break;\n+        }\n+\n+        const messageParams = {\n+          message: currentMessages[0]?.parts || [],\n+          config: {\n+            abortSignal: abortController.signal,\n+            tools: [{ functionDeclarations: toolsList }],\n+          },\n+        };\n+\n+        // Send the message to the GeminiChat object, which will manage its own history\n+        const responseStream = await chat.sendMessageStream(messageParams);\n+\n+        // Combine all chunks in stream for proper processing.\n+        const functionCalls: FunctionCall[] = [];\n+        for await (const resp of responseStream) {\n+          if (abortController.signal.aborted) {\n+            console.error('Operation cancelled.');\n+            return;\n+          }\n+\n+          const calls = resp.functionCalls;\n+          if (calls) {\n+            functionCalls.push(...calls);\n+          }\n+        }\n+\n+        if (functionCalls.length > 0) {\n+          currentMessages = await this.processFunctionCalls(\n+            functionCalls,\n+            toolRegistry,\n+            abortController,\n+            currentMessages,\n+          );\n+        } else {\n+          // The model has stopped calling tools, which signals completion.\n+          // Verify that all expected output variables have been emitted.\n+          const remainingVars = Object.keys(this.promptConfig.outputs).filter(\n+            (key) => !(key in this.output.emitted_vars),\n+          );\n+\n+          if (remainingVars.length === 0) {\n+            this.output.terminate_reason = SubagentTerminateMode.GOAL;\n+            break;\n+          }\n+\n+          // If variables are missing, the loop continues, relying on the\n+          // system prompt to guide the model to call self.emitvalue.\n+          console.debug(\n+            'Variables appear to be missing. Relying on model to call EmitValue.',\n+          );\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error during subagent execution:', error);\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Processes a list of function calls, executing each one and collecting their responses.\n+   * This method iterates through the provided function calls, executes them using the\n+   * `executeToolCall` function (or handles `self.emitvalue` internally), and aggregates\n+   * their results. It also manages error reporting for failed tool executions.\n+   * @param {FunctionCall[]} functionCalls - An array of `FunctionCall` objects to process.\n+   * @param {ToolRegistry} toolRegistry - The tool registry to look up and execute tools.\n+   * @param {AbortController} abortController - An `AbortController` to signal cancellation of tool executions.\n+   * @param {Content[]} currentMessages - The current list of messages in the chat history, which will be updated with tool responses.\n+   * @returns {Promise<Content[]>} A promise that resolves to an array of `Content` parts representing the tool responses,\n+   *          which are then used to update the chat history.\n+   */\n+  private async processFunctionCalls(\n+    functionCalls: FunctionCall[],\n+    toolRegistry: ToolRegistry,\n+    abortController: AbortController,\n+    currentMessages: Content[],\n+  ) {\n+    const toolResponseParts: Part[] = [];\n+\n+    for (const functionCall of functionCalls) {\n+      const callId = functionCall.id ?? `${functionCall.name}-${Date.now()}`;\n+      const requestInfo: ToolCallRequestInfo = {\n+        callId,\n+        name: functionCall.name as string,\n+        args: (functionCall.args ?? {}) as Record<string, unknown>,\n+        isClientInitiated: true,\n+      };\n+\n+      let toolResponse;\n+\n+      // Handle scope-local tools first.\n+      if (callId.startsWith('self.emitvalue')) {\n+        const valName = String(requestInfo.args['emit_variable_name']);\n+        const valVal = String(requestInfo.args['emit_variable_value']);\n+        this.output.emitted_vars[valName] = valVal;\n+\n+        toolResponse = {\n+          callId,\n+          responseParts: `Emitted variable ${valName} successfully`,\n+          resultDisplay: `Emitted variable ${valName} successfully`,\n+          error: undefined,\n+        };\n+      } else {\n+        toolResponse = await executeToolCall(\n+          this.runtimeContext,\n+          requestInfo,\n+          toolRegistry,\n+          abortController.signal,\n+        );\n+      }\n+\n+      if (toolResponse.error) {\n+        console.error(\n+          `Error executing tool ${functionCall.name}: ${toolResponse.resultDisplay || toolResponse.error.message}`,\n+        );\n+        // Continue to the next tool call instead of halting execution.\n+        continue;\n+      }\n+\n+      if (toolResponse.responseParts) {\n+        const parts = Array.isArray(toolResponse.responseParts)\n+          ? toolResponse.responseParts\n+          : [toolResponse.responseParts];\n+        for (const part of parts) {\n+          if (typeof part === 'string') {\n+            toolResponseParts.push({ text: part });\n+          } else if (part) {\n+            toolResponseParts.push(part);\n+          }\n+        }\n+      }\n+    }\n+    currentMessages = [{ role: 'user', parts: toolResponseParts }];\n+    return currentMessages;\n+  }\n+\n+  /**\n+   * Creates an instance of `GeminiChat` unique for the subagent's purposes.\n+   * It initializes the chat with environment variables and configures the content generator.\n+   * @param {Content[]} [extraHistory] - Optional additional chat history to include.\n+   * @returns {Promise<GeminiChat | undefined>} A promise that resolves to a `GeminiChat` instance, or undefined if creation fails.\n+   */\n+  private async createChatObject(extraHistory?: Content[]) {\n+    const envParts = await this.getEnvironment();\n+    const initialHistory: Content[] = [\n+      {\n+        role: 'user',\n+        parts: envParts,\n+      },\n+      {\n+        role: 'model',\n+        parts: [{ text: 'Got it. Thanks for the context!' }],\n+      },\n+    ];\n+\n+    const start_history = [...initialHistory, ...(extraHistory ?? [])];\n+\n+    // The system instruction is set dynamically within the run loop to allow\n+    // for context-based templating.\n+    const systemInstruction = '';\n+\n+    try {\n+      const targetContentConfig: GenerateContentConfig = {\n+        temperature: this.modelConfig.temp,\n+        topP: this.modelConfig.top_p,\n+      };\n+\n+      const generationConfig = {\n+        systemInstruction,\n+        ...targetContentConfig,\n+      };\n+\n+      const contentGenerator = await createContentGenerator(\n+        this.runtimeContext.getContentGeneratorConfig(),\n+      );\n+\n+      this.runtimeContext.setModel(this.modelConfig.model);\n+\n+      return new GeminiChat(\n+        this.runtimeContext,\n+        contentGenerator,\n+        generationConfig,\n+        start_history,\n+      );\n+    } catch (error) {\n+      await reportError(\n+        error,\n+        'Error initializing Gemini chat session.',\n+        start_history,\n+        'startChat',\n+      );\n+      // The calling function will handle the undefined return.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Retrieves environment-related information to be included in the chat context.\n+   * This includes the current working directory, date, operating system, and folder structure.\n+   * Optionally, it can also include the full file context if enabled.\n+   * @returns A promise that resolves to an array of `Part` objects containing environment information.\n+   */\n+  private async getEnvironment(): Promise<Part[]> {\n+    const cwd = this.runtimeContext.getWorkingDir();\n+    const today = new Date().toLocaleDateString(undefined, {\n+      weekday: 'long',\n+      year: 'numeric',\n+      month: 'long',\n+      day: 'numeric',\n+    });\n+    const platform = process.platform;\n+    const folderStructure = await getFolderStructure(cwd, {\n+      fileService: this.runtimeContext.getFileService(),\n+    });\n+    const context = `\n+  Okay, just setting up the context for our chat.\n+  Today is ${today}.\n+  My operating system is: ${platform}\n+  I'm currently working in the directory: ${cwd}\n+  ${folderStructure}\n+          `.trim();\n+\n+    const initialParts: Part[] = [{ text: context }];\n+    const toolRegistry = await this.runtimeContext.getToolRegistry();\n+\n+    // Add full file context if the flag is set\n+    if (this.runtimeContext.getFullContext()) {\n+      try {\n+        const readManyFilesTool = toolRegistry.getTool(\n+          'read_many_files',\n+        ) as ReadManyFilesTool;\n+        if (readManyFilesTool) {\n+          // Read all files in the target directory\n+          const result = await readManyFilesTool.execute(\n+            {\n+              paths: ['**/*'], // Read everything recursively\n+              useDefaultExcludes: true, // Use default excludes\n+            },\n+            AbortSignal.timeout(30000),\n+          );\n+          if (result.llmContent) {\n+            initialParts.push({\n+              text: `\\n--- Full File Context ---\\n${result.llmContent}`,\n+            });\n+          } else {\n+            console.warn(\n+              'Full context requested, but read_many_files returned no content.',\n+            );\n+          }\n+        }\n+      } catch (error) {\n+        // This error is logged but doesn't halt the process, as full context is optional.\n+        console.error('Error reading full file context:', error);\n+        initialParts.push({\n+          text: '\\n--- Error reading full file context ---',\n+        });\n+      }\n+    }\n+\n+    return initialParts;\n+  }\n+\n+  /**\n+   * Returns an array of FunctionDeclaration objects for tools that are local to the subagent's scope.\n+   * Currently, this includes the `self.emitvalue` tool for emitting variables.\n+   * @returns An array of `FunctionDeclaration` objects.\n+   */\n+  private getScopeLocalFuncDefs() {",
        "comment_created_at": "2025-07-06T16:37:44+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "I see hmmm. Let me ask maybe a dumb question. What if we were to move away from the variable functions entirely and instead relied on 1 final schema binding request that would take all of the history and fill out a given schema object? That way there wouldn't be individual tools that the LLM would need to invoke each step of the way, we'd have a guaranteed output and it'd ensure that the entire scope of the conversation was considered when deriving final outputs.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190471569",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1805,
        "pr_file": "packages/core/src/core/subagent.ts",
        "discussion_id": "2183014852",
        "commented_code": "@@ -0,0 +1,599 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getFolderStructure } from '../utils/getFolderStructure.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+import { ReadManyFilesTool } from '../tools/read-many-files.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;\n+  /** A list of expected output objects and the variables they should emit. */\n+  outputs: Record<string, string>;\n+  /** A list of tool names (in the tool registry) or full function declarations that the subagent is permitted to use. */\n+  tools: Array<string | FunctionDeclaration>;\n+}\n+\n+/**\n+ * Configures the generative model parameters for the subagent.\n+ * This interface specifies the model to be used and its associated generation settings,\n+ * such as temperature and top-p values, which influence the creativity and diversity of the model's output.\n+ */\n+export interface ModelConfig {\n+  /** The name or identifier of the model to be used. */\n+  model: string;\n+  /** The temperature for the model's sampling process. */\n+  temp: number;\n+  /** The top-p value for nucleus sampling. */\n+  top_p: number;\n+}\n+\n+/**\n+ * Configures the execution environment and constraints for the subagent.\n+ * This interface defines parameters that control the subagent's runtime behavior,\n+ * such as maximum execution time, to prevent infinite loops or excessive resource consumption.\n+ */\n+export interface RunConfig {\n+  /** The maximum execution time for the subagent in minutes. */\n+  max_time_minutes: number;\n+}\n+\n+/**\n+ * Manages the runtime context state for the subagent.\n+ * This class provides a mechanism to store and retrieve key-value pairs\n+ * that represent the dynamic state and variables accessible to the subagent\n+ * during its execution.\n+ */\n+export class ContextState {\n+  private state: Record<string, unknown> = {};\n+\n+  /**\n+   * Retrieves a value from the context state.\n+   *\n+   * @param key - The key of the value to retrieve.\n+   * @returns The value associated with the key, or undefined if the key is not found.\n+   */\n+  get(key: string): unknown {\n+    return this.state[key];\n+  }\n+\n+  /**\n+   * Sets a value in the context state.\n+   *\n+   * @param key - The key to set the value under.\n+   * @param value - The value to set.\n+   */\n+  set(key: string, value: unknown): void {\n+    this.state[key] = value;\n+  }\n+\n+  /**\n+   * Retrieves all keys in the context state.\n+   *\n+   * @returns An array of all keys in the context state.\n+   */\n+  get_keys(): string[] {\n+    return Object.keys(this.state);\n+  }\n+}\n+\n+/**\n+ * Replaces `${...}` placeholders in a template string with values from a context.\n+ *\n+ * This function identifies all placeholders in the format `${key}`, validates that\n+ * each key exists in the provided `ContextState`, and then performs the substitution.\n+ *\n+ * @param template The template string containing placeholders.\n+ * @param context The `ContextState` object providing placeholder values.\n+ * @returns The populated string with all placeholders replaced.\n+ * @throws {Error} if any placeholder key is not found in the context.\n+ */\n+function templateString(template: string, context: ContextState): string {\n+  const placeholderRegex = /\\$\\{(\\w+)\\}/g;\n+\n+  // First, find all unique keys required by the template.\n+  const requiredKeys = new Set(\n+    Array.from(template.matchAll(placeholderRegex), (match) => match[1]),\n+  );\n+\n+  // Check if all required keys exist in the context.\n+  const contextKeys = new Set(context.get_keys());\n+  const missingKeys = Array.from(requiredKeys).filter(\n+    (key) => !contextKeys.has(key),\n+  );\n+\n+  if (missingKeys.length > 0) {\n+    throw new Error(\n+      `Missing context values for the following keys: ${missingKeys.join(\n+        ', ',\n+      )}`,\n+    );\n+  }\n+\n+  // Perform the replacement using a replacer function.\n+  return template.replace(placeholderRegex, (_match, key) =>\n+    String(context.get(key)),\n+  );\n+}\n+\n+/**\n+ * Represents the scope and execution environment for a subagent.\n+ * This class orchestrates the subagent's lifecycle, managing its chat interactions,\n+ * runtime context, and the collection of its outputs.\n+ */\n+export class SubAgentScope {\n+  output: OutputObject = {\n+    terminate_reason: SubagentTerminateMode.ERROR,\n+    emitted_vars: {},\n+  };\n+\n+  /**\n+   * Constructs a new SubAgentScope instance.\n+   * @param runtimeContext - The shared runtime configuration and services.\n+   * @param promptConfig - Configuration for the subagent's prompt and behavior.\n+   * @param modelConfig - Configuration for the generative model parameters.\n+   * @param runConfig - Configuration for the subagent's execution environment and constraints.\n+   */\n+  constructor(\n+    readonly runtimeContext: Config,\n+    private readonly promptConfig: PromptConfig,\n+    private readonly modelConfig: ModelConfig,\n+    private readonly runConfig: RunConfig,\n+  ) {}\n+\n+  /**\n+   * Runs the subagent in a non-interactive mode.\n+   * This method orchestrates the subagent's execution loop, including prompt templating,\n+   * tool execution, and termination conditions. It manages the chat history, handles\n+   * tool calls, and determines when the subagent's goals are met or if a timeout occurs.\n+   * @param {ContextState} context - The current context state containing variables for prompt templating.\n+   * @returns {Promise<void>} A promise that resolves when the subagent has completed its execution.\n+   */\n+  async runNonInteractive(context: ContextState): Promise<void> {\n+    const chat = await this.createChatObject();\n+\n+    if (!chat) {\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      return;\n+    }\n+\n+    const abortController = new AbortController();\n+    const toolRegistry: ToolRegistry =\n+      await this.runtimeContext.getToolRegistry();\n+\n+    // Prepare the list of tools available to the subagent.\n+    const tools_to_load: string[] = [];\n+    const toolsList: FunctionDeclaration[] = [];\n+    for (const toolName of this.promptConfig.tools) {\n+      if (typeof toolName === 'string') {\n+        tools_to_load.push(toolName);\n+      } else {\n+        toolsList.push(toolName);\n+      }\n+    }\n+\n+    toolsList.push(\n+      ...toolRegistry.getFunctionDeclarationsFiltered(tools_to_load),\n+    );\n+    toolsList.push(...this.getScopeLocalFuncDefs());\n+\n+    chat.setSystemInstruction(this.buildChatSystemPrompt(context, toolsList));\n+\n+    let currentMessages: Content[] = [\n+      { role: 'user', parts: [{ text: 'Get Started!' }] },\n+    ];\n+\n+    const startTime = Date.now();\n+    try {\n+      while (true) {\n+        // Check for timeout.\n+        const duration = Date.now() - startTime;\n+        const durationMin = duration / (1000 * 60);\n+        if (durationMin >= this.runConfig.max_time_minutes) {\n+          this.output.terminate_reason = SubagentTerminateMode.TIMEOUT;\n+          break;\n+        }\n+\n+        const messageParams = {\n+          message: currentMessages[0]?.parts || [],\n+          config: {\n+            abortSignal: abortController.signal,\n+            tools: [{ functionDeclarations: toolsList }],\n+          },\n+        };\n+\n+        // Send the message to the GeminiChat object, which will manage its own history\n+        const responseStream = await chat.sendMessageStream(messageParams);\n+\n+        // Combine all chunks in stream for proper processing.\n+        const functionCalls: FunctionCall[] = [];\n+        for await (const resp of responseStream) {\n+          if (abortController.signal.aborted) {\n+            console.error('Operation cancelled.');\n+            return;\n+          }\n+\n+          const calls = resp.functionCalls;\n+          if (calls) {\n+            functionCalls.push(...calls);\n+          }\n+        }\n+\n+        if (functionCalls.length > 0) {\n+          currentMessages = await this.processFunctionCalls(\n+            functionCalls,\n+            toolRegistry,\n+            abortController,\n+            currentMessages,\n+          );\n+        } else {\n+          // The model has stopped calling tools, which signals completion.\n+          // Verify that all expected output variables have been emitted.\n+          const remainingVars = Object.keys(this.promptConfig.outputs).filter(\n+            (key) => !(key in this.output.emitted_vars),\n+          );\n+\n+          if (remainingVars.length === 0) {\n+            this.output.terminate_reason = SubagentTerminateMode.GOAL;\n+            break;\n+          }\n+\n+          // If variables are missing, the loop continues, relying on the\n+          // system prompt to guide the model to call self.emitvalue.\n+          console.debug(\n+            'Variables appear to be missing. Relying on model to call EmitValue.',\n+          );\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error during subagent execution:', error);\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Processes a list of function calls, executing each one and collecting their responses.\n+   * This method iterates through the provided function calls, executes them using the\n+   * `executeToolCall` function (or handles `self.emitvalue` internally), and aggregates\n+   * their results. It also manages error reporting for failed tool executions.\n+   * @param {FunctionCall[]} functionCalls - An array of `FunctionCall` objects to process.\n+   * @param {ToolRegistry} toolRegistry - The tool registry to look up and execute tools.\n+   * @param {AbortController} abortController - An `AbortController` to signal cancellation of tool executions.\n+   * @param {Content[]} currentMessages - The current list of messages in the chat history, which will be updated with tool responses.\n+   * @returns {Promise<Content[]>} A promise that resolves to an array of `Content` parts representing the tool responses,\n+   *          which are then used to update the chat history.\n+   */\n+  private async processFunctionCalls(\n+    functionCalls: FunctionCall[],\n+    toolRegistry: ToolRegistry,\n+    abortController: AbortController,\n+    currentMessages: Content[],\n+  ) {\n+    const toolResponseParts: Part[] = [];\n+\n+    for (const functionCall of functionCalls) {\n+      const callId = functionCall.id ?? `${functionCall.name}-${Date.now()}`;\n+      const requestInfo: ToolCallRequestInfo = {\n+        callId,\n+        name: functionCall.name as string,\n+        args: (functionCall.args ?? {}) as Record<string, unknown>,\n+        isClientInitiated: true,\n+      };\n+\n+      let toolResponse;\n+\n+      // Handle scope-local tools first.\n+      if (callId.startsWith('self.emitvalue')) {\n+        const valName = String(requestInfo.args['emit_variable_name']);\n+        const valVal = String(requestInfo.args['emit_variable_value']);\n+        this.output.emitted_vars[valName] = valVal;\n+\n+        toolResponse = {\n+          callId,\n+          responseParts: `Emitted variable ${valName} successfully`,\n+          resultDisplay: `Emitted variable ${valName} successfully`,\n+          error: undefined,\n+        };\n+      } else {\n+        toolResponse = await executeToolCall(\n+          this.runtimeContext,\n+          requestInfo,\n+          toolRegistry,\n+          abortController.signal,\n+        );\n+      }\n+\n+      if (toolResponse.error) {\n+        console.error(\n+          `Error executing tool ${functionCall.name}: ${toolResponse.resultDisplay || toolResponse.error.message}`,\n+        );\n+        // Continue to the next tool call instead of halting execution.\n+        continue;\n+      }\n+\n+      if (toolResponse.responseParts) {\n+        const parts = Array.isArray(toolResponse.responseParts)\n+          ? toolResponse.responseParts\n+          : [toolResponse.responseParts];\n+        for (const part of parts) {\n+          if (typeof part === 'string') {\n+            toolResponseParts.push({ text: part });\n+          } else if (part) {\n+            toolResponseParts.push(part);\n+          }\n+        }\n+      }\n+    }\n+    currentMessages = [{ role: 'user', parts: toolResponseParts }];\n+    return currentMessages;\n+  }\n+\n+  /**\n+   * Creates an instance of `GeminiChat` unique for the subagent's purposes.\n+   * It initializes the chat with environment variables and configures the content generator.\n+   * @param {Content[]} [extraHistory] - Optional additional chat history to include.\n+   * @returns {Promise<GeminiChat | undefined>} A promise that resolves to a `GeminiChat` instance, or undefined if creation fails.\n+   */\n+  private async createChatObject(extraHistory?: Content[]) {\n+    const envParts = await this.getEnvironment();\n+    const initialHistory: Content[] = [\n+      {\n+        role: 'user',\n+        parts: envParts,\n+      },\n+      {\n+        role: 'model',\n+        parts: [{ text: 'Got it. Thanks for the context!' }],\n+      },\n+    ];\n+\n+    const start_history = [...initialHistory, ...(extraHistory ?? [])];\n+\n+    // The system instruction is set dynamically within the run loop to allow\n+    // for context-based templating.\n+    const systemInstruction = '';\n+\n+    try {\n+      const targetContentConfig: GenerateContentConfig = {\n+        temperature: this.modelConfig.temp,\n+        topP: this.modelConfig.top_p,\n+      };\n+\n+      const generationConfig = {\n+        systemInstruction,\n+        ...targetContentConfig,\n+      };\n+\n+      const contentGenerator = await createContentGenerator(\n+        this.runtimeContext.getContentGeneratorConfig(),\n+      );\n+\n+      this.runtimeContext.setModel(this.modelConfig.model);\n+\n+      return new GeminiChat(\n+        this.runtimeContext,\n+        contentGenerator,\n+        generationConfig,\n+        start_history,\n+      );\n+    } catch (error) {\n+      await reportError(\n+        error,\n+        'Error initializing Gemini chat session.',\n+        start_history,\n+        'startChat',\n+      );\n+      // The calling function will handle the undefined return.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Retrieves environment-related information to be included in the chat context.\n+   * This includes the current working directory, date, operating system, and folder structure.\n+   * Optionally, it can also include the full file context if enabled.\n+   * @returns A promise that resolves to an array of `Part` objects containing environment information.\n+   */\n+  private async getEnvironment(): Promise<Part[]> {\n+    const cwd = this.runtimeContext.getWorkingDir();\n+    const today = new Date().toLocaleDateString(undefined, {\n+      weekday: 'long',\n+      year: 'numeric',\n+      month: 'long',\n+      day: 'numeric',\n+    });\n+    const platform = process.platform;\n+    const folderStructure = await getFolderStructure(cwd, {\n+      fileService: this.runtimeContext.getFileService(),\n+    });\n+    const context = `\n+  Okay, just setting up the context for our chat.\n+  Today is ${today}.\n+  My operating system is: ${platform}\n+  I'm currently working in the directory: ${cwd}\n+  ${folderStructure}\n+          `.trim();\n+\n+    const initialParts: Part[] = [{ text: context }];\n+    const toolRegistry = await this.runtimeContext.getToolRegistry();\n+\n+    // Add full file context if the flag is set\n+    if (this.runtimeContext.getFullContext()) {\n+      try {\n+        const readManyFilesTool = toolRegistry.getTool(\n+          'read_many_files',\n+        ) as ReadManyFilesTool;\n+        if (readManyFilesTool) {\n+          // Read all files in the target directory\n+          const result = await readManyFilesTool.execute(\n+            {\n+              paths: ['**/*'], // Read everything recursively\n+              useDefaultExcludes: true, // Use default excludes\n+            },\n+            AbortSignal.timeout(30000),\n+          );\n+          if (result.llmContent) {\n+            initialParts.push({\n+              text: `\\n--- Full File Context ---\\n${result.llmContent}`,\n+            });\n+          } else {\n+            console.warn(\n+              'Full context requested, but read_many_files returned no content.',\n+            );\n+          }\n+        }\n+      } catch (error) {\n+        // This error is logged but doesn't halt the process, as full context is optional.\n+        console.error('Error reading full file context:', error);\n+        initialParts.push({\n+          text: '\\n--- Error reading full file context ---',\n+        });\n+      }\n+    }\n+\n+    return initialParts;\n+  }\n+\n+  /**\n+   * Returns an array of FunctionDeclaration objects for tools that are local to the subagent's scope.\n+   * Currently, this includes the `self.emitvalue` tool for emitting variables.\n+   * @returns An array of `FunctionDeclaration` objects.\n+   */\n+  private getScopeLocalFuncDefs() {",
        "comment_created_at": "2025-07-07T15:55:35+00:00",
        "comment_author": "mainroach",
        "comment_body": "If I understand your comment, you're suggesting:\r\n- Removing the EmitVariableTool (which emits a single variable, and can be called multiple times for multiple variables)\r\n- When a subagent loop is completed, the subagent would call the `geminiClient::generateJson` function (or similar) to fill out all the target emission variables (if applicable).\r\n  -  Once that call returns, parse the json, and fill out the emittedVariables map so that the calling system can fetch them.\r\n\r\n\r\nIf that's correct (?), I think that would be a fine pivot in order to remove the confusion regarding how this tool works... however, I'd provide the following observations:\r\n- There's non-zero chances that the SubAgent claims work is finished, w/o doing the work required to fill out the target variables. In that case, the above emission would either most likely hallucinate a value, which would be incorrect vs. the work done.\r\n- If the model does not fill out the right final variables, it would be ideal to enter back into the Agentic loop, to force it to do the extra work for that variable data. If we're doing a single call at the end, we'd loose this ability, since we've exited the agentic loop at this point - We'd have to re-enter the execution loop with an augmented message, targeting to self-heal the missing data.  \r\n  - When you look at multiple failures, you're effectively back at being in the core of the Agentic loop... (e.g. we'd need an inner Agentic loop, and then an out \"check if variables were properly emitted\" loop). \r\n- Your proposal would suffice for short work - however if there's any history consolidation (e.g. tryCompressChat) it may remove the data from the history that would be needed to fill out the final JSON. That would move us back into the situation of the above two bulletpoints.\r\n\r\nCompletely do-able, if you'd prefer to go that route.\r\n\r\nMay I provide an alternate suggestion for consideration?\r\n- Assume that SubAgent existence may lead to other tools which start to think in the space of wanting to do contextual scoped changes, rather than global ones - thus tools needing access to the calling AgentScope during `execute(..)` would be needed. So, this is not a 1-off situation.\r\n- This could be supported with minimal code changes to `BaseTool::execute(..)` to accept an optional \"runtimeContext:Record<string, any>\" variable. Any existing tools would not need to be modified at all, and the subagent can fill out this packet when invoking the tools.\r\n- EmitValueTool then gets upgraded to a _proper_ tool, as per your original request. \r\n\r\nWDYT?\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2191558520",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1805,
        "pr_file": "packages/core/src/core/subagent.ts",
        "discussion_id": "2183014852",
        "commented_code": "@@ -0,0 +1,599 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getFolderStructure } from '../utils/getFolderStructure.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+import { ReadManyFilesTool } from '../tools/read-many-files.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;\n+  /** A list of expected output objects and the variables they should emit. */\n+  outputs: Record<string, string>;\n+  /** A list of tool names (in the tool registry) or full function declarations that the subagent is permitted to use. */\n+  tools: Array<string | FunctionDeclaration>;\n+}\n+\n+/**\n+ * Configures the generative model parameters for the subagent.\n+ * This interface specifies the model to be used and its associated generation settings,\n+ * such as temperature and top-p values, which influence the creativity and diversity of the model's output.\n+ */\n+export interface ModelConfig {\n+  /** The name or identifier of the model to be used. */\n+  model: string;\n+  /** The temperature for the model's sampling process. */\n+  temp: number;\n+  /** The top-p value for nucleus sampling. */\n+  top_p: number;\n+}\n+\n+/**\n+ * Configures the execution environment and constraints for the subagent.\n+ * This interface defines parameters that control the subagent's runtime behavior,\n+ * such as maximum execution time, to prevent infinite loops or excessive resource consumption.\n+ */\n+export interface RunConfig {\n+  /** The maximum execution time for the subagent in minutes. */\n+  max_time_minutes: number;\n+}\n+\n+/**\n+ * Manages the runtime context state for the subagent.\n+ * This class provides a mechanism to store and retrieve key-value pairs\n+ * that represent the dynamic state and variables accessible to the subagent\n+ * during its execution.\n+ */\n+export class ContextState {\n+  private state: Record<string, unknown> = {};\n+\n+  /**\n+   * Retrieves a value from the context state.\n+   *\n+   * @param key - The key of the value to retrieve.\n+   * @returns The value associated with the key, or undefined if the key is not found.\n+   */\n+  get(key: string): unknown {\n+    return this.state[key];\n+  }\n+\n+  /**\n+   * Sets a value in the context state.\n+   *\n+   * @param key - The key to set the value under.\n+   * @param value - The value to set.\n+   */\n+  set(key: string, value: unknown): void {\n+    this.state[key] = value;\n+  }\n+\n+  /**\n+   * Retrieves all keys in the context state.\n+   *\n+   * @returns An array of all keys in the context state.\n+   */\n+  get_keys(): string[] {\n+    return Object.keys(this.state);\n+  }\n+}\n+\n+/**\n+ * Replaces `${...}` placeholders in a template string with values from a context.\n+ *\n+ * This function identifies all placeholders in the format `${key}`, validates that\n+ * each key exists in the provided `ContextState`, and then performs the substitution.\n+ *\n+ * @param template The template string containing placeholders.\n+ * @param context The `ContextState` object providing placeholder values.\n+ * @returns The populated string with all placeholders replaced.\n+ * @throws {Error} if any placeholder key is not found in the context.\n+ */\n+function templateString(template: string, context: ContextState): string {\n+  const placeholderRegex = /\\$\\{(\\w+)\\}/g;\n+\n+  // First, find all unique keys required by the template.\n+  const requiredKeys = new Set(\n+    Array.from(template.matchAll(placeholderRegex), (match) => match[1]),\n+  );\n+\n+  // Check if all required keys exist in the context.\n+  const contextKeys = new Set(context.get_keys());\n+  const missingKeys = Array.from(requiredKeys).filter(\n+    (key) => !contextKeys.has(key),\n+  );\n+\n+  if (missingKeys.length > 0) {\n+    throw new Error(\n+      `Missing context values for the following keys: ${missingKeys.join(\n+        ', ',\n+      )}`,\n+    );\n+  }\n+\n+  // Perform the replacement using a replacer function.\n+  return template.replace(placeholderRegex, (_match, key) =>\n+    String(context.get(key)),\n+  );\n+}\n+\n+/**\n+ * Represents the scope and execution environment for a subagent.\n+ * This class orchestrates the subagent's lifecycle, managing its chat interactions,\n+ * runtime context, and the collection of its outputs.\n+ */\n+export class SubAgentScope {\n+  output: OutputObject = {\n+    terminate_reason: SubagentTerminateMode.ERROR,\n+    emitted_vars: {},\n+  };\n+\n+  /**\n+   * Constructs a new SubAgentScope instance.\n+   * @param runtimeContext - The shared runtime configuration and services.\n+   * @param promptConfig - Configuration for the subagent's prompt and behavior.\n+   * @param modelConfig - Configuration for the generative model parameters.\n+   * @param runConfig - Configuration for the subagent's execution environment and constraints.\n+   */\n+  constructor(\n+    readonly runtimeContext: Config,\n+    private readonly promptConfig: PromptConfig,\n+    private readonly modelConfig: ModelConfig,\n+    private readonly runConfig: RunConfig,\n+  ) {}\n+\n+  /**\n+   * Runs the subagent in a non-interactive mode.\n+   * This method orchestrates the subagent's execution loop, including prompt templating,\n+   * tool execution, and termination conditions. It manages the chat history, handles\n+   * tool calls, and determines when the subagent's goals are met or if a timeout occurs.\n+   * @param {ContextState} context - The current context state containing variables for prompt templating.\n+   * @returns {Promise<void>} A promise that resolves when the subagent has completed its execution.\n+   */\n+  async runNonInteractive(context: ContextState): Promise<void> {\n+    const chat = await this.createChatObject();\n+\n+    if (!chat) {\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      return;\n+    }\n+\n+    const abortController = new AbortController();\n+    const toolRegistry: ToolRegistry =\n+      await this.runtimeContext.getToolRegistry();\n+\n+    // Prepare the list of tools available to the subagent.\n+    const tools_to_load: string[] = [];\n+    const toolsList: FunctionDeclaration[] = [];\n+    for (const toolName of this.promptConfig.tools) {\n+      if (typeof toolName === 'string') {\n+        tools_to_load.push(toolName);\n+      } else {\n+        toolsList.push(toolName);\n+      }\n+    }\n+\n+    toolsList.push(\n+      ...toolRegistry.getFunctionDeclarationsFiltered(tools_to_load),\n+    );\n+    toolsList.push(...this.getScopeLocalFuncDefs());\n+\n+    chat.setSystemInstruction(this.buildChatSystemPrompt(context, toolsList));\n+\n+    let currentMessages: Content[] = [\n+      { role: 'user', parts: [{ text: 'Get Started!' }] },\n+    ];\n+\n+    const startTime = Date.now();\n+    try {\n+      while (true) {\n+        // Check for timeout.\n+        const duration = Date.now() - startTime;\n+        const durationMin = duration / (1000 * 60);\n+        if (durationMin >= this.runConfig.max_time_minutes) {\n+          this.output.terminate_reason = SubagentTerminateMode.TIMEOUT;\n+          break;\n+        }\n+\n+        const messageParams = {\n+          message: currentMessages[0]?.parts || [],\n+          config: {\n+            abortSignal: abortController.signal,\n+            tools: [{ functionDeclarations: toolsList }],\n+          },\n+        };\n+\n+        // Send the message to the GeminiChat object, which will manage its own history\n+        const responseStream = await chat.sendMessageStream(messageParams);\n+\n+        // Combine all chunks in stream for proper processing.\n+        const functionCalls: FunctionCall[] = [];\n+        for await (const resp of responseStream) {\n+          if (abortController.signal.aborted) {\n+            console.error('Operation cancelled.');\n+            return;\n+          }\n+\n+          const calls = resp.functionCalls;\n+          if (calls) {\n+            functionCalls.push(...calls);\n+          }\n+        }\n+\n+        if (functionCalls.length > 0) {\n+          currentMessages = await this.processFunctionCalls(\n+            functionCalls,\n+            toolRegistry,\n+            abortController,\n+            currentMessages,\n+          );\n+        } else {\n+          // The model has stopped calling tools, which signals completion.\n+          // Verify that all expected output variables have been emitted.\n+          const remainingVars = Object.keys(this.promptConfig.outputs).filter(\n+            (key) => !(key in this.output.emitted_vars),\n+          );\n+\n+          if (remainingVars.length === 0) {\n+            this.output.terminate_reason = SubagentTerminateMode.GOAL;\n+            break;\n+          }\n+\n+          // If variables are missing, the loop continues, relying on the\n+          // system prompt to guide the model to call self.emitvalue.\n+          console.debug(\n+            'Variables appear to be missing. Relying on model to call EmitValue.',\n+          );\n+        }\n+      }\n+    } catch (error) {\n+      console.error('Error during subagent execution:', error);\n+      this.output.terminate_reason = SubagentTerminateMode.ERROR;\n+      throw error;\n+    }\n+  }\n+\n+  /**\n+   * Processes a list of function calls, executing each one and collecting their responses.\n+   * This method iterates through the provided function calls, executes them using the\n+   * `executeToolCall` function (or handles `self.emitvalue` internally), and aggregates\n+   * their results. It also manages error reporting for failed tool executions.\n+   * @param {FunctionCall[]} functionCalls - An array of `FunctionCall` objects to process.\n+   * @param {ToolRegistry} toolRegistry - The tool registry to look up and execute tools.\n+   * @param {AbortController} abortController - An `AbortController` to signal cancellation of tool executions.\n+   * @param {Content[]} currentMessages - The current list of messages in the chat history, which will be updated with tool responses.\n+   * @returns {Promise<Content[]>} A promise that resolves to an array of `Content` parts representing the tool responses,\n+   *          which are then used to update the chat history.\n+   */\n+  private async processFunctionCalls(\n+    functionCalls: FunctionCall[],\n+    toolRegistry: ToolRegistry,\n+    abortController: AbortController,\n+    currentMessages: Content[],\n+  ) {\n+    const toolResponseParts: Part[] = [];\n+\n+    for (const functionCall of functionCalls) {\n+      const callId = functionCall.id ?? `${functionCall.name}-${Date.now()}`;\n+      const requestInfo: ToolCallRequestInfo = {\n+        callId,\n+        name: functionCall.name as string,\n+        args: (functionCall.args ?? {}) as Record<string, unknown>,\n+        isClientInitiated: true,\n+      };\n+\n+      let toolResponse;\n+\n+      // Handle scope-local tools first.\n+      if (callId.startsWith('self.emitvalue')) {\n+        const valName = String(requestInfo.args['emit_variable_name']);\n+        const valVal = String(requestInfo.args['emit_variable_value']);\n+        this.output.emitted_vars[valName] = valVal;\n+\n+        toolResponse = {\n+          callId,\n+          responseParts: `Emitted variable ${valName} successfully`,\n+          resultDisplay: `Emitted variable ${valName} successfully`,\n+          error: undefined,\n+        };\n+      } else {\n+        toolResponse = await executeToolCall(\n+          this.runtimeContext,\n+          requestInfo,\n+          toolRegistry,\n+          abortController.signal,\n+        );\n+      }\n+\n+      if (toolResponse.error) {\n+        console.error(\n+          `Error executing tool ${functionCall.name}: ${toolResponse.resultDisplay || toolResponse.error.message}`,\n+        );\n+        // Continue to the next tool call instead of halting execution.\n+        continue;\n+      }\n+\n+      if (toolResponse.responseParts) {\n+        const parts = Array.isArray(toolResponse.responseParts)\n+          ? toolResponse.responseParts\n+          : [toolResponse.responseParts];\n+        for (const part of parts) {\n+          if (typeof part === 'string') {\n+            toolResponseParts.push({ text: part });\n+          } else if (part) {\n+            toolResponseParts.push(part);\n+          }\n+        }\n+      }\n+    }\n+    currentMessages = [{ role: 'user', parts: toolResponseParts }];\n+    return currentMessages;\n+  }\n+\n+  /**\n+   * Creates an instance of `GeminiChat` unique for the subagent's purposes.\n+   * It initializes the chat with environment variables and configures the content generator.\n+   * @param {Content[]} [extraHistory] - Optional additional chat history to include.\n+   * @returns {Promise<GeminiChat | undefined>} A promise that resolves to a `GeminiChat` instance, or undefined if creation fails.\n+   */\n+  private async createChatObject(extraHistory?: Content[]) {\n+    const envParts = await this.getEnvironment();\n+    const initialHistory: Content[] = [\n+      {\n+        role: 'user',\n+        parts: envParts,\n+      },\n+      {\n+        role: 'model',\n+        parts: [{ text: 'Got it. Thanks for the context!' }],\n+      },\n+    ];\n+\n+    const start_history = [...initialHistory, ...(extraHistory ?? [])];\n+\n+    // The system instruction is set dynamically within the run loop to allow\n+    // for context-based templating.\n+    const systemInstruction = '';\n+\n+    try {\n+      const targetContentConfig: GenerateContentConfig = {\n+        temperature: this.modelConfig.temp,\n+        topP: this.modelConfig.top_p,\n+      };\n+\n+      const generationConfig = {\n+        systemInstruction,\n+        ...targetContentConfig,\n+      };\n+\n+      const contentGenerator = await createContentGenerator(\n+        this.runtimeContext.getContentGeneratorConfig(),\n+      );\n+\n+      this.runtimeContext.setModel(this.modelConfig.model);\n+\n+      return new GeminiChat(\n+        this.runtimeContext,\n+        contentGenerator,\n+        generationConfig,\n+        start_history,\n+      );\n+    } catch (error) {\n+      await reportError(\n+        error,\n+        'Error initializing Gemini chat session.',\n+        start_history,\n+        'startChat',\n+      );\n+      // The calling function will handle the undefined return.\n+      return undefined;\n+    }\n+  }\n+\n+  /**\n+   * Retrieves environment-related information to be included in the chat context.\n+   * This includes the current working directory, date, operating system, and folder structure.\n+   * Optionally, it can also include the full file context if enabled.\n+   * @returns A promise that resolves to an array of `Part` objects containing environment information.\n+   */\n+  private async getEnvironment(): Promise<Part[]> {\n+    const cwd = this.runtimeContext.getWorkingDir();\n+    const today = new Date().toLocaleDateString(undefined, {\n+      weekday: 'long',\n+      year: 'numeric',\n+      month: 'long',\n+      day: 'numeric',\n+    });\n+    const platform = process.platform;\n+    const folderStructure = await getFolderStructure(cwd, {\n+      fileService: this.runtimeContext.getFileService(),\n+    });\n+    const context = `\n+  Okay, just setting up the context for our chat.\n+  Today is ${today}.\n+  My operating system is: ${platform}\n+  I'm currently working in the directory: ${cwd}\n+  ${folderStructure}\n+          `.trim();\n+\n+    const initialParts: Part[] = [{ text: context }];\n+    const toolRegistry = await this.runtimeContext.getToolRegistry();\n+\n+    // Add full file context if the flag is set\n+    if (this.runtimeContext.getFullContext()) {\n+      try {\n+        const readManyFilesTool = toolRegistry.getTool(\n+          'read_many_files',\n+        ) as ReadManyFilesTool;\n+        if (readManyFilesTool) {\n+          // Read all files in the target directory\n+          const result = await readManyFilesTool.execute(\n+            {\n+              paths: ['**/*'], // Read everything recursively\n+              useDefaultExcludes: true, // Use default excludes\n+            },\n+            AbortSignal.timeout(30000),\n+          );\n+          if (result.llmContent) {\n+            initialParts.push({\n+              text: `\\n--- Full File Context ---\\n${result.llmContent}`,\n+            });\n+          } else {\n+            console.warn(\n+              'Full context requested, but read_many_files returned no content.',\n+            );\n+          }\n+        }\n+      } catch (error) {\n+        // This error is logged but doesn't halt the process, as full context is optional.\n+        console.error('Error reading full file context:', error);\n+        initialParts.push({\n+          text: '\\n--- Error reading full file context ---',\n+        });\n+      }\n+    }\n+\n+    return initialParts;\n+  }\n+\n+  /**\n+   * Returns an array of FunctionDeclaration objects for tools that are local to the subagent's scope.\n+   * Currently, this includes the `self.emitvalue` tool for emitting variables.\n+   * @returns An array of `FunctionDeclaration` objects.\n+   */\n+  private getScopeLocalFuncDefs() {",
        "comment_created_at": "2025-07-08T06:03:46+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "> May I provide an alternate suggestion for consideration?\r\n\r\nYa I think this could work too. My comment was less about the coding aspects of the tool implementations though and more around the lines of ensuring an output. That being said I imagine evals could also help define which path is better here (I don't feel strongly). Your suggestion seems reasonable though.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2229344865",
    "pr_number": 1805,
    "pr_file": "packages/core/src/core/subagent.ts",
    "created_at": "2025-07-24T19:07:59+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getEnvironmentContext } from '../utils/environmentContext.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2229344865",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1805,
        "pr_file": "packages/core/src/core/subagent.ts",
        "discussion_id": "2229344865",
        "commented_code": "@@ -0,0 +1,588 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { reportError } from '../utils/errorReporting.js';\n+import { ToolRegistry } from '../tools/tool-registry.js';\n+import { Config } from '../config/config.js';\n+import { ToolCallRequestInfo } from './turn.js';\n+import { executeToolCall } from './nonInteractiveToolExecutor.js';\n+import { createContentGenerator } from './contentGenerator.js';\n+import { getEnvironmentContext } from '../utils/environmentContext.js';\n+import {\n+  Content,\n+  Part,\n+  FunctionCall,\n+  GenerateContentConfig,\n+  FunctionDeclaration,\n+  Type,\n+} from '@google/genai';\n+import { GeminiChat } from './geminiChat.js';\n+\n+/**\n+ * @fileoverview Defines the configuration interfaces for a subagent.\n+ *\n+ * These interfaces specify the structure for defining the subagent's prompt,\n+ * the model parameters, and the execution settings.\n+ */\n+\n+/**\n+ * Describes the possible termination modes for a subagent.\n+ * This enum provides a clear indication of why a subagent's execution might have ended.\n+ */\n+export enum SubagentTerminateMode {\n+  /**\n+   * Indicates that the subagent's execution terminated due to an unrecoverable error.\n+   */\n+  ERROR = 'ERROR',\n+  /**\n+   * Indicates that the subagent's execution terminated because it exceeded the maximum allowed working time.\n+   */\n+  TIMEOUT = 'TIMEOUT',\n+  /**\n+   * Indicates that the subagent's execution successfully completed all its defined goals.\n+   */\n+  GOAL = 'GOAL',\n+}\n+\n+/**\n+ * Represents the output structure of a subagent's execution.\n+ * This interface defines the data that a subagent will return upon completion,\n+ * including any emitted variables and the reason for its termination.\n+ */\n+export interface OutputObject {\n+  /**\n+   * A record of key-value pairs representing variables emitted by the subagent\n+   * during its execution. These variables can be used by the calling agent.\n+   */\n+  emitted_vars: Record<string, string>;\n+  /**\n+   * The reason for the subagent's termination, indicating whether it completed\n+   * successfully, timed out, or encountered an error.\n+   */\n+  terminate_reason: SubagentTerminateMode;\n+}\n+\n+/**\n+ * Configures the prompt and expected behavior of the subagent.\n+ * This interface defines the essential parameters that guide the subagent's\n+ * interaction and task execution, including its plan, goals, and available tools.\n+ */\n+export interface PromptConfig {\n+  /** A high-level plan or strategy for the subagent to follow. */\n+  plan: string;\n+  /** The specific goals the subagent is expected to achieve. */\n+  goals: string;",
        "comment_created_at": "2025-07-24T19:07:59+00:00",
        "comment_author": "allenhutchison",
        "comment_body": "I think you might be better off and more flexible in defining this as a single system prompt string, and an array of chat pairs (user, model). That would allow for any use case where someone wants to setup a subagent and keeps this interface consistent with what you see if you are using the SDKs natively. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2220173195",
    "pr_number": 4519,
    "pr_file": "packages/vscode-ide-companion/src/diff-manager.ts",
    "created_at": "2025-07-21T19:59:04+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as vscode from 'vscode';\n+import * as path from 'node:path';\n+import { DiffContentProvider } from './diff-content-provider';\n+import { DIFF_SCHEME } from './extension';\n+import { type JSONRPCNotification } from '@modelcontextprotocol/sdk/types.js';\n+\n+// Information about a diff view that is currently open.\n+interface DiffInfo {\n+  originalFilePath: string;\n+  newContent: string;\n+  rightDocUri: vscode.Uri;\n+}\n+\n+/**\n+ * Manages the state and lifecycle of diff views within the IDE.\n+ */\n+export class DiffManager {\n+  private diffDocuments = new Map<string, DiffInfo>();\n+\n+  constructor(\n+    private readonly logger: vscode.OutputChannel,\n+    private readonly diffContentProvider: DiffContentProvider,\n+    private readonly broadcastNotification: (\n+      notification: JSONRPCNotification,\n+    ) => void,\n+  ) {}\n+\n+  /**\n+   * Creates and shows a new diff view.\n+   *\n+   * This is typically called by a tool from the MCP server.\n+   */\n+  async showDiff(filePath: string, newContent: string) {\n+    const fileUri = vscode.Uri.file(filePath);\n+\n+    let fileExists = true;\n+    try {\n+      await vscode.workspace.fs.stat(fileUri);\n+    } catch {\n+      fileExists = false;\n+    }\n+\n+    if (fileExists) {\n+      const modifiedContent = newContent ?? '';\n+      const rightDocUri = vscode.Uri.from({\n+        scheme: DIFF_SCHEME,\n+        path: filePath,\n+        query: `rand=${Math.random()}`,\n+      });\n+      this.diffContentProvider.setContent(rightDocUri, modifiedContent);\n+\n+      this.addDiffDocument(rightDocUri, {\n+        originalFilePath: filePath,\n+        newContent: modifiedContent,\n+        rightDocUri,\n+      });\n+\n+      const diffTitle = `${path.basename(filePath)} \u2194 Modified`;\n+      await vscode.commands.executeCommand(\n+        'setContext',\n+        'gemini.diff.isVisible',\n+        true,\n+      );\n+      await vscode.commands.executeCommand(\n+        'vscode.diff',\n+        fileUri,\n+        rightDocUri,\n+        diffTitle,\n+      );\n+    } else {\n+      // If the file doesn't exist, we create it and show it directly\n+      // instead of showing a diff.\n+      const workspaceEdit = new vscode.WorkspaceEdit();\n+      workspaceEdit.createFile(fileUri, { ignoreIfExists: true });\n+      workspaceEdit.insert(\n+        fileUri,\n+        new vscode.Position(0, 0),\n+        newContent ?? '',\n+      );\n+      await vscode.workspace.applyEdit(workspaceEdit);\n+      await vscode.window.showTextDocument(fileUri);\n+    }\n+  }\n+\n+  /**\n+   * Called when a user accepts the changes in a diff view.\n+   */\n+  async acceptDiff(rightDocUri: vscode.Uri) {\n+    const diffInfo = this.diffDocuments.get(rightDocUri.toString());\n+    if (!diffInfo) {\n+      this.logger.appendLine(\n+        `No diff info found for ${rightDocUri.toString()}`,\n+      );\n+      return;\n+    }\n+\n+    const rightDoc = await vscode.workspace.openTextDocument(rightDocUri);\n+    const modifiedContent = rightDoc.getText();\n+\n+    const workspaceEdit = new vscode.WorkspaceEdit();\n+    const fileUri = vscode.Uri.file(diffInfo.originalFilePath);\n+    const doc = await vscode.workspace.openTextDocument(fileUri);\n+    const lastLine = doc.lineAt(doc.lineCount - 1);\n+    const fullRange = new vscode.Range(\n+      new vscode.Position(0, 0),\n+      lastLine.range.end,\n+    );\n+    workspaceEdit.replace(fileUri, fullRange, modifiedContent);\n+    await vscode.workspace.applyEdit(workspaceEdit);\n+\n+    await doc.save();\n+\n+    await this.closeDiffEditor(rightDocUri);\n+    vscode.window.showInformationMessage('Changes applied and saved.');\n+\n+    this.broadcastNotification({\n+      jsonrpc: '2.0',\n+      method: 'ide/diffAccepted',\n+      params: {\n+        filePath: diffInfo.originalFilePath,\n+        content: modifiedContent,\n+      },\n+    });\n+  }\n+\n+  /**\n+   * Called when a user cancels a diff view.\n+   */\n+  async cancelDiff(rightDocUri: vscode.Uri) {\n+    const diffInfo = this.diffDocuments.get(rightDocUri.toString());\n+    await this.closeDiffEditor(rightDocUri);\n+    vscode.window.showInformationMessage('Changes canceled.');\n+\n+    if (diffInfo) {\n+      this.broadcastNotification({\n+        jsonrpc: '2.0',\n+        method: 'ide/diffClosed',\n+        params: { filePath: diffInfo.originalFilePath },\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Called when the text document for a diff view is closed.\n+   */\n+  onDidCloseTextDocument(document: vscode.TextDocument) {\n+    const closedUriString = document.uri.toString();\n+    if (this.diffDocuments.has(closedUriString)) {\n+      const diffInfo = this.diffDocuments.get(closedUriString);\n+      if (diffInfo) {\n+        this.broadcastNotification({\n+          jsonrpc: '2.0',\n+          method: 'ide/diffClosed',",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2220173195",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4519,
        "pr_file": "packages/vscode-ide-companion/src/diff-manager.ts",
        "discussion_id": "2220173195",
        "commented_code": "@@ -0,0 +1,205 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as vscode from 'vscode';\n+import * as path from 'node:path';\n+import { DiffContentProvider } from './diff-content-provider';\n+import { DIFF_SCHEME } from './extension';\n+import { type JSONRPCNotification } from '@modelcontextprotocol/sdk/types.js';\n+\n+// Information about a diff view that is currently open.\n+interface DiffInfo {\n+  originalFilePath: string;\n+  newContent: string;\n+  rightDocUri: vscode.Uri;\n+}\n+\n+/**\n+ * Manages the state and lifecycle of diff views within the IDE.\n+ */\n+export class DiffManager {\n+  private diffDocuments = new Map<string, DiffInfo>();\n+\n+  constructor(\n+    private readonly logger: vscode.OutputChannel,\n+    private readonly diffContentProvider: DiffContentProvider,\n+    private readonly broadcastNotification: (\n+      notification: JSONRPCNotification,\n+    ) => void,\n+  ) {}\n+\n+  /**\n+   * Creates and shows a new diff view.\n+   *\n+   * This is typically called by a tool from the MCP server.\n+   */\n+  async showDiff(filePath: string, newContent: string) {\n+    const fileUri = vscode.Uri.file(filePath);\n+\n+    let fileExists = true;\n+    try {\n+      await vscode.workspace.fs.stat(fileUri);\n+    } catch {\n+      fileExists = false;\n+    }\n+\n+    if (fileExists) {\n+      const modifiedContent = newContent ?? '';\n+      const rightDocUri = vscode.Uri.from({\n+        scheme: DIFF_SCHEME,\n+        path: filePath,\n+        query: `rand=${Math.random()}`,\n+      });\n+      this.diffContentProvider.setContent(rightDocUri, modifiedContent);\n+\n+      this.addDiffDocument(rightDocUri, {\n+        originalFilePath: filePath,\n+        newContent: modifiedContent,\n+        rightDocUri,\n+      });\n+\n+      const diffTitle = `${path.basename(filePath)} \u2194 Modified`;\n+      await vscode.commands.executeCommand(\n+        'setContext',\n+        'gemini.diff.isVisible',\n+        true,\n+      );\n+      await vscode.commands.executeCommand(\n+        'vscode.diff',\n+        fileUri,\n+        rightDocUri,\n+        diffTitle,\n+      );\n+    } else {\n+      // If the file doesn't exist, we create it and show it directly\n+      // instead of showing a diff.\n+      const workspaceEdit = new vscode.WorkspaceEdit();\n+      workspaceEdit.createFile(fileUri, { ignoreIfExists: true });\n+      workspaceEdit.insert(\n+        fileUri,\n+        new vscode.Position(0, 0),\n+        newContent ?? '',\n+      );\n+      await vscode.workspace.applyEdit(workspaceEdit);\n+      await vscode.window.showTextDocument(fileUri);\n+    }\n+  }\n+\n+  /**\n+   * Called when a user accepts the changes in a diff view.\n+   */\n+  async acceptDiff(rightDocUri: vscode.Uri) {\n+    const diffInfo = this.diffDocuments.get(rightDocUri.toString());\n+    if (!diffInfo) {\n+      this.logger.appendLine(\n+        `No diff info found for ${rightDocUri.toString()}`,\n+      );\n+      return;\n+    }\n+\n+    const rightDoc = await vscode.workspace.openTextDocument(rightDocUri);\n+    const modifiedContent = rightDoc.getText();\n+\n+    const workspaceEdit = new vscode.WorkspaceEdit();\n+    const fileUri = vscode.Uri.file(diffInfo.originalFilePath);\n+    const doc = await vscode.workspace.openTextDocument(fileUri);\n+    const lastLine = doc.lineAt(doc.lineCount - 1);\n+    const fullRange = new vscode.Range(\n+      new vscode.Position(0, 0),\n+      lastLine.range.end,\n+    );\n+    workspaceEdit.replace(fileUri, fullRange, modifiedContent);\n+    await vscode.workspace.applyEdit(workspaceEdit);\n+\n+    await doc.save();\n+\n+    await this.closeDiffEditor(rightDocUri);\n+    vscode.window.showInformationMessage('Changes applied and saved.');\n+\n+    this.broadcastNotification({\n+      jsonrpc: '2.0',\n+      method: 'ide/diffAccepted',\n+      params: {\n+        filePath: diffInfo.originalFilePath,\n+        content: modifiedContent,\n+      },\n+    });\n+  }\n+\n+  /**\n+   * Called when a user cancels a diff view.\n+   */\n+  async cancelDiff(rightDocUri: vscode.Uri) {\n+    const diffInfo = this.diffDocuments.get(rightDocUri.toString());\n+    await this.closeDiffEditor(rightDocUri);\n+    vscode.window.showInformationMessage('Changes canceled.');\n+\n+    if (diffInfo) {\n+      this.broadcastNotification({\n+        jsonrpc: '2.0',\n+        method: 'ide/diffClosed',\n+        params: { filePath: diffInfo.originalFilePath },\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Called when the text document for a diff view is closed.\n+   */\n+  onDidCloseTextDocument(document: vscode.TextDocument) {\n+    const closedUriString = document.uri.toString();\n+    if (this.diffDocuments.has(closedUriString)) {\n+      const diffInfo = this.diffDocuments.get(closedUriString);\n+      if (diffInfo) {\n+        this.broadcastNotification({\n+          jsonrpc: '2.0',\n+          method: 'ide/diffClosed',",
        "comment_created_at": "2025-07-21T19:59:04+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "Non-blocking, food for future thought: All these methods of ide/diffClosed etc. these should probably be part of a protocol library or something that our ide integration in GC surfaces so that IDE integrators don't need to hardcode the protocol layer.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217469111",
    "pr_number": 4511,
    "pr_file": "packages/cli/src/ui/commands/types.ts",
    "created_at": "2025-07-19T21:25:45+00:00",
    "commented_code": "| OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';\n+\n+  /** The primary behavior of the command. 'Custom' is for commands with unique,\n+   * hard-coded logic (e.g., opening a dialog).\n+   */\n+  behavior: 'Custom'; // `| 'Prompt'` will be added in next PR for Custom Commands.\n+\n+  /** The absolute path to the definition file, if applicable. */\n+  // TODO: filePath?: string;\n+}\n+\n+export interface SlashCommandDefinition {\n+  name: string;\n+  altName?: string;\n+  description?: string;\n+\n+  // The action to run. Optional for parent commands that only group sub-commands.\n+  action?: (\n+    context: CommandContext,\n+    args: string,\n+  ) =>\n+    | void\n+    | SlashCommandActionReturn\n+    | Promise<void | SlashCommandActionReturn>;\n+\n+  // Provides argument completion (e.g., completing a tag for `/chat resume <tag>`).\n+  completion?: (\n+    context: CommandContext,\n+    partialArg: string,\n+  ) => Promise<string[]>;\n+\n+  subCommands?: readonly SlashCommandDefinition[];\n+}\n+\n // The standardized contract for any command in the system.\n+// This version is separated from SlashCommandDefinition as it requires metadata.\n export interface SlashCommand {\n   name: string;\n   altName?: string;\n   description?: string;\n \n+  metadata: SlashCommandMetadata;",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2217469111",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217469111",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';\n+\n+  /** The primary behavior of the command. 'Custom' is for commands with unique,\n+   * hard-coded logic (e.g., opening a dialog).\n+   */\n+  behavior: 'Custom'; // `| 'Prompt'` will be added in next PR for Custom Commands.\n+\n+  /** The absolute path to the definition file, if applicable. */\n+  // TODO: filePath?: string;\n+}\n+\n+export interface SlashCommandDefinition {\n+  name: string;\n+  altName?: string;\n+  description?: string;\n+\n+  // The action to run. Optional for parent commands that only group sub-commands.\n+  action?: (\n+    context: CommandContext,\n+    args: string,\n+  ) =>\n+    | void\n+    | SlashCommandActionReturn\n+    | Promise<void | SlashCommandActionReturn>;\n+\n+  // Provides argument completion (e.g., completing a tag for `/chat resume <tag>`).\n+  completion?: (\n+    context: CommandContext,\n+    partialArg: string,\n+  ) => Promise<string[]>;\n+\n+  subCommands?: readonly SlashCommandDefinition[];\n+}\n+\n // The standardized contract for any command in the system.\n+// This version is separated from SlashCommandDefinition as it requires metadata.\n export interface SlashCommand {\n   name: string;\n   altName?: string;\n   description?: string;\n \n+  metadata: SlashCommandMetadata;",
        "comment_created_at": "2025-07-19T21:25:45+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "I'll be curious to see how metadata plays out. I could see a world where slash commands just have a \"kind\" property built into them by default",
        "pr_file_module": null
      },
      {
        "comment_id": "2217519570",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217469111",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';\n+\n+  /** The primary behavior of the command. 'Custom' is for commands with unique,\n+   * hard-coded logic (e.g., opening a dialog).\n+   */\n+  behavior: 'Custom'; // `| 'Prompt'` will be added in next PR for Custom Commands.\n+\n+  /** The absolute path to the definition file, if applicable. */\n+  // TODO: filePath?: string;\n+}\n+\n+export interface SlashCommandDefinition {\n+  name: string;\n+  altName?: string;\n+  description?: string;\n+\n+  // The action to run. Optional for parent commands that only group sub-commands.\n+  action?: (\n+    context: CommandContext,\n+    args: string,\n+  ) =>\n+    | void\n+    | SlashCommandActionReturn\n+    | Promise<void | SlashCommandActionReturn>;\n+\n+  // Provides argument completion (e.g., completing a tag for `/chat resume <tag>`).\n+  completion?: (\n+    context: CommandContext,\n+    partialArg: string,\n+  ) => Promise<string[]>;\n+\n+  subCommands?: readonly SlashCommandDefinition[];\n+}\n+\n // The standardized contract for any command in the system.\n+// This version is separated from SlashCommandDefinition as it requires metadata.\n export interface SlashCommand {\n   name: string;\n   altName?: string;\n   description?: string;\n \n+  metadata: SlashCommandMetadata;",
        "comment_created_at": "2025-07-20T00:53:30+00:00",
        "comment_author": "abhipatel12",
        "comment_body": "Originally I had considered a single top-level property but then decided to use this pattern instead. The built-in commands could define themselves, but i intended to separate the command's business logic from the command's context within the application. So a `/chat` command doesn't necessarily care that its built-in and neither should the author of the next built-in command. The loader adds the metadata for it to help describe the command to the rest of the system.\r\n\r\nIf this is YAGNI, we can replace it with a `kind` property as well!",
        "pr_file_module": null
      },
      {
        "comment_id": "2217902370",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217469111",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';\n+\n+  /** The primary behavior of the command. 'Custom' is for commands with unique,\n+   * hard-coded logic (e.g., opening a dialog).\n+   */\n+  behavior: 'Custom'; // `| 'Prompt'` will be added in next PR for Custom Commands.\n+\n+  /** The absolute path to the definition file, if applicable. */\n+  // TODO: filePath?: string;\n+}\n+\n+export interface SlashCommandDefinition {\n+  name: string;\n+  altName?: string;\n+  description?: string;\n+\n+  // The action to run. Optional for parent commands that only group sub-commands.\n+  action?: (\n+    context: CommandContext,\n+    args: string,\n+  ) =>\n+    | void\n+    | SlashCommandActionReturn\n+    | Promise<void | SlashCommandActionReturn>;\n+\n+  // Provides argument completion (e.g., completing a tag for `/chat resume <tag>`).\n+  completion?: (\n+    context: CommandContext,\n+    partialArg: string,\n+  ) => Promise<string[]>;\n+\n+  subCommands?: readonly SlashCommandDefinition[];\n+}\n+\n // The standardized contract for any command in the system.\n+// This version is separated from SlashCommandDefinition as it requires metadata.\n export interface SlashCommand {\n   name: string;\n   altName?: string;\n   description?: string;\n \n+  metadata: SlashCommandMetadata;",
        "comment_created_at": "2025-07-20T17:54:45+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "I think I'd recommend against metadata. Primary reason is that it's loose information that expects consumers to know magic strings in order to make sense of it (a bit of an anti-pattern). For similar reasons to [this](https://github.com/google-gemini/gemini-cli/pull/4511#discussion_r2217901663) if we don't need it yet I'd recommend removing",
        "pr_file_module": null
      },
      {
        "comment_id": "2217938118",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217469111",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';\n+\n+  /** The primary behavior of the command. 'Custom' is for commands with unique,\n+   * hard-coded logic (e.g., opening a dialog).\n+   */\n+  behavior: 'Custom'; // `| 'Prompt'` will be added in next PR for Custom Commands.\n+\n+  /** The absolute path to the definition file, if applicable. */\n+  // TODO: filePath?: string;\n+}\n+\n+export interface SlashCommandDefinition {\n+  name: string;\n+  altName?: string;\n+  description?: string;\n+\n+  // The action to run. Optional for parent commands that only group sub-commands.\n+  action?: (\n+    context: CommandContext,\n+    args: string,\n+  ) =>\n+    | void\n+    | SlashCommandActionReturn\n+    | Promise<void | SlashCommandActionReturn>;\n+\n+  // Provides argument completion (e.g., completing a tag for `/chat resume <tag>`).\n+  completion?: (\n+    context: CommandContext,\n+    partialArg: string,\n+  ) => Promise<string[]>;\n+\n+  subCommands?: readonly SlashCommandDefinition[];\n+}\n+\n // The standardized contract for any command in the system.\n+// This version is separated from SlashCommandDefinition as it requires metadata.\n export interface SlashCommand {\n   name: string;\n   altName?: string;\n   description?: string;\n \n+  metadata: SlashCommandMetadata;",
        "comment_created_at": "2025-07-20T19:58:54+00:00",
        "comment_author": "abhipatel12",
        "comment_body": "Dropping `metadata` and we can add it back later if there's a need for it!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2210842097",
    "pr_number": 4176,
    "pr_file": "packages/cli/src/ui/commands/mcpCommand.ts",
    "created_at": "2025-07-16T15:57:19+00:00",
    "commented_code": "// Use cyan color for the tool name even when not showing descriptions\n           message += `  - ${COLOR_CYAN}${tool.name}${RESET_COLOR}\n`;\n         }\n-        if (showSchema && tool.parameterSchema) {\n+        const parameters =",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2210842097",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4176,
        "pr_file": "packages/cli/src/ui/commands/mcpCommand.ts",
        "discussion_id": "2210842097",
        "commented_code": "@@ -170,11 +170,13 @@ const getMcpStatus = async (\n           // Use cyan color for the tool name even when not showing descriptions\n           message += `  - ${COLOR_CYAN}${tool.name}${RESET_COLOR}\\n`;\n         }\n-        if (showSchema && tool.parameterSchema) {\n+        const parameters =",
        "comment_created_at": "2025-07-16T15:57:19+00:00",
        "comment_author": "wanlin31",
        "comment_body": "schema is a BaseTool property ([ref](https://github.com/google-gemini/gemini-cli/blob/f4cd0055fd7fcb86bc7dddfd72aa8c6ed78a923e/packages/core/src/tools/tools.ts#L34)) and it can be populated differently, may be more stable than parameterSchema ([ref](https://github.com/google-gemini/gemini-cli/blob/f4cd0055fd7fcb86bc7dddfd72aa8c6ed78a923e/packages/core/src/tools/tools.ts#L100)), which is a transient value to populated the schema field.  ",
        "pr_file_module": null
      }
    ]
  }
]