[
  {
    "discussion_id": "2212061163",
    "pr_number": 3569,
    "pr_file": "packages/core/src/mcp/oauth-provider.ts",
    "created_at": "2025-07-17T03:18:07+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as http from 'node:http';\n+import * as crypto from 'node:crypto';\n+import { URL } from 'node:url';\n+import open from 'open';\n+import { MCPOAuthToken, MCPOAuthTokenStorage } from './oauth-token-storage.js';\n+import { getErrorMessage } from '../utils/errors.js';\n+import { OAuthUtils } from './oauth-utils.js';\n+\n+/**\n+ * OAuth configuration for an MCP server.\n+ */\n+export interface MCPOAuthConfig {\n+  enabled?: boolean; // Whether OAuth is enabled for this server\n+  clientId?: string;\n+  clientSecret?: string;\n+  authorizationUrl?: string;\n+  tokenUrl?: string;\n+  scopes?: string[];\n+  redirectUri?: string;\n+  tokenParamName?: string; // For SSE connections, specifies the query parameter name for the token\n+}\n+\n+/**\n+ * OAuth authorization response.\n+ */\n+export interface OAuthAuthorizationResponse {\n+  code: string;\n+  state: string;\n+}\n+\n+/**\n+ * OAuth token response from the authorization server.\n+ */\n+export interface OAuthTokenResponse {\n+  access_token: string;\n+  token_type: string;\n+  expires_in?: number;\n+  refresh_token?: string;\n+  scope?: string;\n+}\n+\n+/**\n+ * Dynamic client registration request.\n+ */\n+export interface OAuthClientRegistrationRequest {\n+  client_name: string;\n+  redirect_uris: string[];\n+  grant_types: string[];\n+  response_types: string[];\n+  token_endpoint_auth_method: string;\n+  code_challenge_method?: string[];\n+  scope?: string;\n+}\n+\n+/**\n+ * Dynamic client registration response.\n+ */\n+export interface OAuthClientRegistrationResponse {\n+  client_id: string;\n+  client_secret?: string;\n+  client_id_issued_at?: number;\n+  client_secret_expires_at?: number;\n+  redirect_uris: string[];\n+  grant_types: string[];\n+  response_types: string[];\n+  token_endpoint_auth_method: string;\n+  code_challenge_method?: string[];\n+  scope?: string;\n+}\n+\n+/**\n+ * PKCE (Proof Key for Code Exchange) parameters.\n+ */\n+interface PKCEParams {\n+  codeVerifier: string;\n+  codeChallenge: string;\n+  state: string;\n+}\n+\n+/**\n+ * Provider for handling OAuth authentication for MCP servers.\n+ */\n+export class MCPOAuthProvider {\n+  private static readonly REDIRECT_PORT = 7777;",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2212061163",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3569,
        "pr_file": "packages/core/src/mcp/oauth-provider.ts",
        "discussion_id": "2212061163",
        "commented_code": "@@ -0,0 +1,698 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as http from 'node:http';\n+import * as crypto from 'node:crypto';\n+import { URL } from 'node:url';\n+import open from 'open';\n+import { MCPOAuthToken, MCPOAuthTokenStorage } from './oauth-token-storage.js';\n+import { getErrorMessage } from '../utils/errors.js';\n+import { OAuthUtils } from './oauth-utils.js';\n+\n+/**\n+ * OAuth configuration for an MCP server.\n+ */\n+export interface MCPOAuthConfig {\n+  enabled?: boolean; // Whether OAuth is enabled for this server\n+  clientId?: string;\n+  clientSecret?: string;\n+  authorizationUrl?: string;\n+  tokenUrl?: string;\n+  scopes?: string[];\n+  redirectUri?: string;\n+  tokenParamName?: string; // For SSE connections, specifies the query parameter name for the token\n+}\n+\n+/**\n+ * OAuth authorization response.\n+ */\n+export interface OAuthAuthorizationResponse {\n+  code: string;\n+  state: string;\n+}\n+\n+/**\n+ * OAuth token response from the authorization server.\n+ */\n+export interface OAuthTokenResponse {\n+  access_token: string;\n+  token_type: string;\n+  expires_in?: number;\n+  refresh_token?: string;\n+  scope?: string;\n+}\n+\n+/**\n+ * Dynamic client registration request.\n+ */\n+export interface OAuthClientRegistrationRequest {\n+  client_name: string;\n+  redirect_uris: string[];\n+  grant_types: string[];\n+  response_types: string[];\n+  token_endpoint_auth_method: string;\n+  code_challenge_method?: string[];\n+  scope?: string;\n+}\n+\n+/**\n+ * Dynamic client registration response.\n+ */\n+export interface OAuthClientRegistrationResponse {\n+  client_id: string;\n+  client_secret?: string;\n+  client_id_issued_at?: number;\n+  client_secret_expires_at?: number;\n+  redirect_uris: string[];\n+  grant_types: string[];\n+  response_types: string[];\n+  token_endpoint_auth_method: string;\n+  code_challenge_method?: string[];\n+  scope?: string;\n+}\n+\n+/**\n+ * PKCE (Proof Key for Code Exchange) parameters.\n+ */\n+interface PKCEParams {\n+  codeVerifier: string;\n+  codeChallenge: string;\n+  state: string;\n+}\n+\n+/**\n+ * Provider for handling OAuth authentication for MCP servers.\n+ */\n+export class MCPOAuthProvider {\n+  private static readonly REDIRECT_PORT = 7777;",
        "comment_created_at": "2025-07-17T03:18:07+00:00",
        "comment_author": "cornmander",
        "comment_body": "If the port is static, what happens if multiple gemini cli instances are running? Or any other reason why the port may be in-use. I believe if you leave the port un-specified node will automatically choose a random port, which would not run into this problem:\r\n\r\nhttps://nodejs.org/api/net.html#serverlistenport-host-backlog-callback",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181632484",
    "pr_number": 2526,
    "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
    "created_at": "2025-07-03T04:17:53+00:00",
    "commented_code": "this.flushToClearcut();\n   }\n \n+  getProxyAgent() {\n+    const proxyUrl = this.config?.getProxy();\n+    if (!proxyUrl) return undefined;\n+    if (proxyUrl.startsWith('socks')) {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2181632484",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2181632484",
        "commented_code": "@@ -389,6 +399,20 @@ export class ClearcutLogger {\n     this.flushToClearcut();\n   }\n \n+  getProxyAgent() {\n+    const proxyUrl = this.config?.getProxy();\n+    if (!proxyUrl) return undefined;\n+    if (proxyUrl.startsWith('socks')) {",
        "comment_created_at": "2025-07-03T04:17:53+00:00",
        "comment_author": "Dcatfly",
        "comment_body": "1. Both http and https protocols can be handled in HttpsProxyAgent\r\n2. The `ProxyAgent` provided by `undici` currently does not support the socks type. If you want to add support for the socks type proxy, it is not enough to handle it here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2181738078",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2181632484",
        "commented_code": "@@ -389,6 +399,20 @@ export class ClearcutLogger {\n     this.flushToClearcut();\n   }\n \n+  getProxyAgent() {\n+    const proxyUrl = this.config?.getProxy();\n+    if (!proxyUrl) return undefined;\n+    if (proxyUrl.startsWith('socks')) {",
        "comment_created_at": "2025-07-03T05:09:10+00:00",
        "comment_author": "warjiang",
        "comment_body": "thanks for pointing that~(got the new usage of HttpsProxyAgent and HttpProxyAgent \ud83d\udc4d )\r\nhere use `https` seems not very good, the reason I add the implementation of socks5 protocol here is that, I think the `clearcut-logger` is an isolated implementation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2181956765",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2181632484",
        "commented_code": "@@ -389,6 +399,20 @@ export class ClearcutLogger {\n     this.flushToClearcut();\n   }\n \n+  getProxyAgent() {\n+    const proxyUrl = this.config?.getProxy();\n+    if (!proxyUrl) return undefined;\n+    if (proxyUrl.startsWith('socks')) {",
        "comment_created_at": "2025-07-03T06:24:12+00:00",
        "comment_author": "Dcatfly",
        "comment_body": "Thanks for your reply.\r\nWhat I mean is, if `socks` support is to be added, then all requests within the CLI should support `socks` proxy, as their proxy source is the same.",
        "pr_file_module": null
      },
      {
        "comment_id": "2182097363",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2181632484",
        "commented_code": "@@ -389,6 +399,20 @@ export class ClearcutLogger {\n     this.flushToClearcut();\n   }\n \n+  getProxyAgent() {\n+    const proxyUrl = this.config?.getProxy();\n+    if (!proxyUrl) return undefined;\n+    if (proxyUrl.startsWith('socks')) {",
        "comment_created_at": "2025-07-03T07:44:53+00:00",
        "comment_author": "warjiang",
        "comment_body": "@Dcatfly  Agree with you, so I co-authored with you to re-use `https-proxy-agent` for `http/https` proxy protocol, for `socks` related protocol,  it will report the unsupported error \r\n\r\nrelated commit=> https://github.com/google-gemini/gemini-cli/pull/2526/commits/e13ef756f5ed224a5a55969c91770682c04b58ed#diff-053150b640a7ce75eff69d1a22cae7f0f94ad64ce9a855db544dda0929316519",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181635740",
    "pr_number": 2526,
    "pr_file": "packages/core/src/tools/web-fetch.ts",
    "created_at": "2025-07-03T04:22:02+00:00",
    "commented_code": "type: 'object',\n       },\n     );\n+    if (config.getProxy()) {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2181635740",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/tools/web-fetch.ts",
        "discussion_id": "2181635740",
        "commented_code": "@@ -80,6 +81,9 @@ export class WebFetchTool extends BaseTool<WebFetchToolParams, ToolResult> {\n         type: 'object',\n       },\n     );\n+    if (config.getProxy()) {",
        "comment_created_at": "2025-07-03T04:22:02+00:00",
        "comment_author": "Dcatfly",
        "comment_body": "`setGlobalDispatcher` will intercept all node fetches in the current program.\r\n`setGlobalDispatcher` has already been called in [core/client.ts](https://github.com/google-gemini/gemini-cli/blob/85a1d814a7e6cba15de59505c82bf96798807eaf/packages/core/src/core/client.ts#L62), and the timing is early enough. Therefore, the undici-based proxy agent in this PR might be unnecessary.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2181682386",
    "pr_number": 2526,
    "pr_file": "packages/core/src/code_assist/oauth2.ts",
    "created_at": "2025-07-03T04:40:43+00:00",
    "commented_code": "loginCompletePromise: Promise<void>;\n }\n \n-export async function getOauthClient(): Promise<OAuth2Client> {\n+export async function getOauthClient(\n+  proxy?: string | undefined,\n+): Promise<OAuth2Client> {\n   const client = new OAuth2Client({\n     clientId: OAUTH_CLIENT_ID,\n     clientSecret: OAUTH_CLIENT_SECRET,\n+    transporter: new Gaxios({",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2181682386",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/code_assist/oauth2.ts",
        "discussion_id": "2181682386",
        "commented_code": "@@ -53,10 +54,15 @@ export interface OauthWebLogin {\n   loginCompletePromise: Promise<void>;\n }\n \n-export async function getOauthClient(): Promise<OAuth2Client> {\n+export async function getOauthClient(\n+  proxy?: string | undefined,\n+): Promise<OAuth2Client> {\n   const client = new OAuth2Client({\n     clientId: OAUTH_CLIENT_ID,\n     clientSecret: OAUTH_CLIENT_SECRET,\n+    transporter: new Gaxios({",
        "comment_created_at": "2025-07-03T04:40:43+00:00",
        "comment_author": "Dcatfly",
        "comment_body": "If `transporter` is not set, `OAuth2Client` will actually automatically read proxy settings from the environment. Both methods only support http(s).",
        "pr_file_module": null
      },
      {
        "comment_id": "2181779915",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/code_assist/oauth2.ts",
        "discussion_id": "2181682386",
        "commented_code": "@@ -53,10 +54,15 @@ export interface OauthWebLogin {\n   loginCompletePromise: Promise<void>;\n }\n \n-export async function getOauthClient(): Promise<OAuth2Client> {\n+export async function getOauthClient(\n+  proxy?: string | undefined,\n+): Promise<OAuth2Client> {\n   const client = new OAuth2Client({\n     clientId: OAUTH_CLIENT_ID,\n     clientSecret: OAUTH_CLIENT_SECRET,\n+    transporter: new Gaxios({",
        "comment_created_at": "2025-07-03T05:28:17+00:00",
        "comment_author": "warjiang",
        "comment_body": "`OAuth2Client` extends `AuthClient`, the `transporter` is set in the `AuthClient`:\r\n\r\n\r\nhttps://github.com/googleapis/google-auth-library-nodejs/blob/bd7e4e3465567bba6f2599f63ac8ed62c0027de9/src/auth/authclient.ts#L246-L275\r\n![image](https://github.com/user-attachments/assets/f9a6af81-8d30-4d26-ac0f-ed98e2018f99)\r\n\r\nif unset `transporter` for `OAuth2Client `, it will init a brand new instance using `new Gaxios(opts.transporterOptions)`, but in `Gaxios` it will not use environment variable directly. \r\n\r\n\r\nhttps://github.com/googleapis/gaxios/blob/cdef1bb3f4f382d4581e21ebebfae2aca2f34029/src/gaxios.ts#L70-L76\r\n![image](https://github.com/user-attachments/assets/fd13abbe-6e2e-43e3-b0cd-37396fc42f53)\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2181964705",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2526,
        "pr_file": "packages/core/src/code_assist/oauth2.ts",
        "discussion_id": "2181682386",
        "commented_code": "@@ -53,10 +54,15 @@ export interface OauthWebLogin {\n   loginCompletePromise: Promise<void>;\n }\n \n-export async function getOauthClient(): Promise<OAuth2Client> {\n+export async function getOauthClient(\n+  proxy?: string | undefined,\n+): Promise<OAuth2Client> {\n   const client = new OAuth2Client({\n     clientId: OAUTH_CLIENT_ID,\n     clientSecret: OAUTH_CLIENT_SECRET,\n+    transporter: new Gaxios({",
        "comment_created_at": "2025-07-03T06:29:44+00:00",
        "comment_author": "Dcatfly",
        "comment_body": "In the official doc for the [google-auth-library](https://github.com/googleapis/google-auth-library-nodejs?tab=readme-ov-file#using-a-proxy), it is mentioned that proxy settings are obtained from the environment.\r\n<img width=\"864\" alt=\"image\" src=\"https://github.com/user-attachments/assets/fabe4fd8-046c-4bb2-b348-b92a6a1e73a4\" />\r\n\r\nThe specific code implementation is likely located around [here](https://github.com/googleapis/gaxios/blob/cdef1bb3f4f382d4581e21ebebfae2aca2f34029/src/gaxios.ts#L494).",
        "pr_file_module": null
      }
    ]
  }
]