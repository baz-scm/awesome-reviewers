[
  {
    "discussion_id": "2218339424",
    "pr_number": 4572,
    "pr_file": "packages/cli/src/services/FileCommandLoader.ts",
    "created_at": "2025-07-21T06:49:05+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { promises as fs } from 'fs';\n+import path from 'path';\n+import toml from '@iarna/toml';\n+import {\n+  Config,\n+  getProjectCommandsDir,\n+  getUserCommandsDir,\n+} from '@google/gemini-cli-core';\n+import { ICommandLoader } from './types.js';\n+import { CommandKind, SlashCommand } from '../ui/commands/types.js';\n+\n+/**\n+ * Defines the structure of a valid command definition within a .toml file.\n+ * This is the raw shape of the data after being parsed from TOML.\n+ */\n+interface TomlCommandDef {\n+  prompt: string;\n+  description?: string;\n+}\n+\n+/**\n+ * A type guard to safely validate that a parsed TOML object conforms to our\n+ * required command definition structure.\n+ *\n+ * @param obj The unknown object parsed from a TOML file.\n+ * @returns True if the object is a valid TomlCommandDef, false otherwise.\n+ */\n+function isTomlCommandDef(obj: unknown): obj is TomlCommandDef {\n+  // Basic check for an object-like structure.\n+  if (typeof obj !== 'object' || obj === null) {\n+    return false;\n+  }\n+\n+  // Check that 'prompt' is a non-empty string.\n+  const hasPrompt =\n+    'prompt' in obj && typeof (obj as TomlCommandDef).prompt === 'string';\n+\n+  // Check that 'description', if it exists, is a string.\n+  const hasValidDescription =\n+    !('description' in obj) ||\n+    typeof (obj as TomlCommandDef).description === 'string';\n+\n+  return hasPrompt && hasValidDescription;\n+}\n+\n+function isErrnoException(error: unknown): error is NodeJS.ErrnoException {\n+  return error instanceof Error && 'code' in error;\n+}\n+\n+/**\n+ * Discovers and loads custom slash commands from .toml files in both the\n+ * user's global config directory and the current project's directory.\n+ *\n+ * This loader is responsible for:\n+ * - Recursively scanning command directories.\n+ * - Parsing and validating TOML files.\n+ * - Adapting valid definitions into executable SlashCommand objects.\n+ * - Handling file system errors and malformed files gracefully.\n+ */\n+export class FileCommandLoader implements ICommandLoader {\n+  private readonly projectRoot: string;\n+\n+  constructor(private readonly config: Config | null) {\n+    this.projectRoot = config?.getProjectRoot() || process.cwd();\n+  }\n+\n+  /**\n+   * Loads all commands, applying the precedence rule where project-level\n+   * commands override user-level commands with the same name.\n+   * @param signal An AbortSignal to cancel the loading process.\n+   * @returns A promise that resolves to an array of loaded SlashCommands.\n+   */\n+  async loadCommands(signal?: AbortSignal): Promise<SlashCommand[]> {\n+    const userDir = getUserCommandsDir();\n+    const projectDir = getProjectCommandsDir(this.projectRoot);\n+\n+    const [userCommands, projectCommands] = await Promise.all([\n+      this.loadCommandsFromDir(userDir, userDir, signal),\n+      this.loadCommandsFromDir(projectDir, projectDir, signal),\n+    ]);\n+\n+    const commandMap = new Map<string, SlashCommand>();\n+    for (const cmd of userCommands) {\n+      commandMap.set(cmd.name, cmd);\n+    }\n+    for (const cmd of projectCommands) {\n+      commandMap.set(cmd.name, cmd);\n+    }\n+\n+    return Array.from(commandMap.values());\n+  }\n+\n+  /**\n+   * Recursively scans a directory for .toml files and adapts them into commands.\n+   * @param baseDir The root command directory (e.g., ~/.gemini/commands) used\n+   *   to calculate the command's relative path name.\n+   * @param currentDir The directory currently being scanned.\n+   * @param signal An AbortSignal to cancel the loading process.\n+   * @returns A promise resolving to an array of commands found in the directory.\n+   */\n+  private async loadCommandsFromDir(\n+    baseDir: string,\n+    currentDir: string,\n+    signal?: AbortSignal,\n+  ): Promise<SlashCommand[]> {\n+    if (signal?.aborted) {\n+      return [];\n+    }\n+\n+    try {\n+      const entries = await fs.readdir(currentDir, { withFileTypes: true });\n+      const commands: SlashCommand[] = [];\n+\n+      for (const entry of entries) {\n+        if (signal?.aborted) break;\n+\n+        const fullPath = path.join(currentDir, entry.name);\n+        if (entry.isDirectory()) {\n+          const subCommands = await this.loadCommandsFromDir(",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2218339424",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4572,
        "pr_file": "packages/cli/src/services/FileCommandLoader.ts",
        "discussion_id": "2218339424",
        "commented_code": "@@ -0,0 +1,215 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { promises as fs } from 'fs';\n+import path from 'path';\n+import toml from '@iarna/toml';\n+import {\n+  Config,\n+  getProjectCommandsDir,\n+  getUserCommandsDir,\n+} from '@google/gemini-cli-core';\n+import { ICommandLoader } from './types.js';\n+import { CommandKind, SlashCommand } from '../ui/commands/types.js';\n+\n+/**\n+ * Defines the structure of a valid command definition within a .toml file.\n+ * This is the raw shape of the data after being parsed from TOML.\n+ */\n+interface TomlCommandDef {\n+  prompt: string;\n+  description?: string;\n+}\n+\n+/**\n+ * A type guard to safely validate that a parsed TOML object conforms to our\n+ * required command definition structure.\n+ *\n+ * @param obj The unknown object parsed from a TOML file.\n+ * @returns True if the object is a valid TomlCommandDef, false otherwise.\n+ */\n+function isTomlCommandDef(obj: unknown): obj is TomlCommandDef {\n+  // Basic check for an object-like structure.\n+  if (typeof obj !== 'object' || obj === null) {\n+    return false;\n+  }\n+\n+  // Check that 'prompt' is a non-empty string.\n+  const hasPrompt =\n+    'prompt' in obj && typeof (obj as TomlCommandDef).prompt === 'string';\n+\n+  // Check that 'description', if it exists, is a string.\n+  const hasValidDescription =\n+    !('description' in obj) ||\n+    typeof (obj as TomlCommandDef).description === 'string';\n+\n+  return hasPrompt && hasValidDescription;\n+}\n+\n+function isErrnoException(error: unknown): error is NodeJS.ErrnoException {\n+  return error instanceof Error && 'code' in error;\n+}\n+\n+/**\n+ * Discovers and loads custom slash commands from .toml files in both the\n+ * user's global config directory and the current project's directory.\n+ *\n+ * This loader is responsible for:\n+ * - Recursively scanning command directories.\n+ * - Parsing and validating TOML files.\n+ * - Adapting valid definitions into executable SlashCommand objects.\n+ * - Handling file system errors and malformed files gracefully.\n+ */\n+export class FileCommandLoader implements ICommandLoader {\n+  private readonly projectRoot: string;\n+\n+  constructor(private readonly config: Config | null) {\n+    this.projectRoot = config?.getProjectRoot() || process.cwd();\n+  }\n+\n+  /**\n+   * Loads all commands, applying the precedence rule where project-level\n+   * commands override user-level commands with the same name.\n+   * @param signal An AbortSignal to cancel the loading process.\n+   * @returns A promise that resolves to an array of loaded SlashCommands.\n+   */\n+  async loadCommands(signal?: AbortSignal): Promise<SlashCommand[]> {\n+    const userDir = getUserCommandsDir();\n+    const projectDir = getProjectCommandsDir(this.projectRoot);\n+\n+    const [userCommands, projectCommands] = await Promise.all([\n+      this.loadCommandsFromDir(userDir, userDir, signal),\n+      this.loadCommandsFromDir(projectDir, projectDir, signal),\n+    ]);\n+\n+    const commandMap = new Map<string, SlashCommand>();\n+    for (const cmd of userCommands) {\n+      commandMap.set(cmd.name, cmd);\n+    }\n+    for (const cmd of projectCommands) {\n+      commandMap.set(cmd.name, cmd);\n+    }\n+\n+    return Array.from(commandMap.values());\n+  }\n+\n+  /**\n+   * Recursively scans a directory for .toml files and adapts them into commands.\n+   * @param baseDir The root command directory (e.g., ~/.gemini/commands) used\n+   *   to calculate the command's relative path name.\n+   * @param currentDir The directory currently being scanned.\n+   * @param signal An AbortSignal to cancel the loading process.\n+   * @returns A promise resolving to an array of commands found in the directory.\n+   */\n+  private async loadCommandsFromDir(\n+    baseDir: string,\n+    currentDir: string,\n+    signal?: AbortSignal,\n+  ): Promise<SlashCommand[]> {\n+    if (signal?.aborted) {\n+      return [];\n+    }\n+\n+    try {\n+      const entries = await fs.readdir(currentDir, { withFileTypes: true });\n+      const commands: SlashCommand[] = [];\n+\n+      for (const entry of entries) {\n+        if (signal?.aborted) break;\n+\n+        const fullPath = path.join(currentDir, entry.name);\n+        if (entry.isDirectory()) {\n+          const subCommands = await this.loadCommandsFromDir(",
        "comment_created_at": "2025-07-21T06:49:05+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "Instead of recursively doing this we have fast-glob or the glob tool to find all these if you want \ud83d\ude04 . There's also the tech that the read many file tool utilizes",
        "pr_file_module": null
      },
      {
        "comment_id": "2220750372",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4572,
        "pr_file": "packages/cli/src/services/FileCommandLoader.ts",
        "discussion_id": "2218339424",
        "commented_code": "@@ -0,0 +1,215 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { promises as fs } from 'fs';\n+import path from 'path';\n+import toml from '@iarna/toml';\n+import {\n+  Config,\n+  getProjectCommandsDir,\n+  getUserCommandsDir,\n+} from '@google/gemini-cli-core';\n+import { ICommandLoader } from './types.js';\n+import { CommandKind, SlashCommand } from '../ui/commands/types.js';\n+\n+/**\n+ * Defines the structure of a valid command definition within a .toml file.\n+ * This is the raw shape of the data after being parsed from TOML.\n+ */\n+interface TomlCommandDef {\n+  prompt: string;\n+  description?: string;\n+}\n+\n+/**\n+ * A type guard to safely validate that a parsed TOML object conforms to our\n+ * required command definition structure.\n+ *\n+ * @param obj The unknown object parsed from a TOML file.\n+ * @returns True if the object is a valid TomlCommandDef, false otherwise.\n+ */\n+function isTomlCommandDef(obj: unknown): obj is TomlCommandDef {\n+  // Basic check for an object-like structure.\n+  if (typeof obj !== 'object' || obj === null) {\n+    return false;\n+  }\n+\n+  // Check that 'prompt' is a non-empty string.\n+  const hasPrompt =\n+    'prompt' in obj && typeof (obj as TomlCommandDef).prompt === 'string';\n+\n+  // Check that 'description', if it exists, is a string.\n+  const hasValidDescription =\n+    !('description' in obj) ||\n+    typeof (obj as TomlCommandDef).description === 'string';\n+\n+  return hasPrompt && hasValidDescription;\n+}\n+\n+function isErrnoException(error: unknown): error is NodeJS.ErrnoException {\n+  return error instanceof Error && 'code' in error;\n+}\n+\n+/**\n+ * Discovers and loads custom slash commands from .toml files in both the\n+ * user's global config directory and the current project's directory.\n+ *\n+ * This loader is responsible for:\n+ * - Recursively scanning command directories.\n+ * - Parsing and validating TOML files.\n+ * - Adapting valid definitions into executable SlashCommand objects.\n+ * - Handling file system errors and malformed files gracefully.\n+ */\n+export class FileCommandLoader implements ICommandLoader {\n+  private readonly projectRoot: string;\n+\n+  constructor(private readonly config: Config | null) {\n+    this.projectRoot = config?.getProjectRoot() || process.cwd();\n+  }\n+\n+  /**\n+   * Loads all commands, applying the precedence rule where project-level\n+   * commands override user-level commands with the same name.\n+   * @param signal An AbortSignal to cancel the loading process.\n+   * @returns A promise that resolves to an array of loaded SlashCommands.\n+   */\n+  async loadCommands(signal?: AbortSignal): Promise<SlashCommand[]> {\n+    const userDir = getUserCommandsDir();\n+    const projectDir = getProjectCommandsDir(this.projectRoot);\n+\n+    const [userCommands, projectCommands] = await Promise.all([\n+      this.loadCommandsFromDir(userDir, userDir, signal),\n+      this.loadCommandsFromDir(projectDir, projectDir, signal),\n+    ]);\n+\n+    const commandMap = new Map<string, SlashCommand>();\n+    for (const cmd of userCommands) {\n+      commandMap.set(cmd.name, cmd);\n+    }\n+    for (const cmd of projectCommands) {\n+      commandMap.set(cmd.name, cmd);\n+    }\n+\n+    return Array.from(commandMap.values());\n+  }\n+\n+  /**\n+   * Recursively scans a directory for .toml files and adapts them into commands.\n+   * @param baseDir The root command directory (e.g., ~/.gemini/commands) used\n+   *   to calculate the command's relative path name.\n+   * @param currentDir The directory currently being scanned.\n+   * @param signal An AbortSignal to cancel the loading process.\n+   * @returns A promise resolving to an array of commands found in the directory.\n+   */\n+  private async loadCommandsFromDir(\n+    baseDir: string,\n+    currentDir: string,\n+    signal?: AbortSignal,\n+  ): Promise<SlashCommand[]> {\n+    if (signal?.aborted) {\n+      return [];\n+    }\n+\n+    try {\n+      const entries = await fs.readdir(currentDir, { withFileTypes: true });\n+      const commands: SlashCommand[] = [];\n+\n+      for (const entry of entries) {\n+        if (signal?.aborted) break;\n+\n+        const fullPath = path.join(currentDir, entry.name);\n+        if (entry.isDirectory()) {\n+          const subCommands = await this.loadCommandsFromDir(",
        "comment_created_at": "2025-07-22T01:31:05+00:00",
        "comment_author": "abhipatel12",
        "comment_body": "Good point! Made the change and `glob` is much cleaner. Removed the `loadCommandsFromDir` helper. Thanks for the catch!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2205934970",
    "pr_number": 3957,
    "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
    "created_at": "2025-07-14T22:33:09+00:00",
    "commented_code": "// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Clearcut expects this format.\n   enqueueLogEvent(event: any): void {\n+    // Prevent unbounded memory growth by limiting event queue size\n+    if (this.events.length >= this.max_events) {\n+      // Remove oldest events (FIFO) to make room for new ones\n+      const eventsToRemove = this.events.length - this.max_events + 1;\n+      this.events.splice(0, eventsToRemove);",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2205934970",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3957,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2205934970",
        "commented_code": "@@ -62,6 +66,19 @@ export class ClearcutLogger {\n \n   // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Clearcut expects this format.\n   enqueueLogEvent(event: any): void {\n+    // Prevent unbounded memory growth by limiting event queue size\n+    if (this.events.length >= this.max_events) {\n+      // Remove oldest events (FIFO) to make room for new ones\n+      const eventsToRemove = this.events.length - this.max_events + 1;\n+      this.events.splice(0, eventsToRemove);",
        "comment_created_at": "2025-07-14T22:33:09+00:00",
        "comment_author": "jacob314",
        "comment_body": "same comment as bellow about useing\r\nhttps://yomguithereal.github.io/mnemonist/fixed-deque\r\nor a doubly linked list to avoid O(events.length) operations. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2206631241",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3957,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2205934970",
        "commented_code": "@@ -62,6 +66,19 @@ export class ClearcutLogger {\n \n   // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Clearcut expects this format.\n   enqueueLogEvent(event: any): void {\n+    // Prevent unbounded memory growth by limiting event queue size\n+    if (this.events.length >= this.max_events) {\n+      // Remove oldest events (FIFO) to make room for new ones\n+      const eventsToRemove = this.events.length - this.max_events + 1;\n+      this.events.splice(0, eventsToRemove);",
        "comment_created_at": "2025-07-15T07:20:42+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "This has been addressed by the FixedDeque implementation in commit 6dc81703. The enqueueLogEvent method now uses FixedDeque which automatically handles FIFO overflow without any O(n) operations - no need for manual splice(0, eventsToRemove) calls.\r\n\r\nThe FixedDeque constructor takes the capacity (1000) and automatically removes the oldest elements when new ones are added beyond capacity, all in O(1) time.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216943689",
    "pr_number": 3957,
    "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
    "created_at": "2025-07-18T21:30:44+00:00",
    "commented_code": "// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Clearcut expects this format.\n   enqueueLogEvent(event: any): void {\n-    this.events.push([\n-      {\n-        event_time_ms: Date.now(),\n-        source_extension_json: safeJsonStringify(event),\n-      },\n-    ]);\n+    try {\n+      // Manually handle overflow for FixedDeque, which throws when full.\n+      const wasAtCapacity = this.events.size >= this.max_events;\n+\n+      if (wasAtCapacity) {\n+        this.events.shift(); // Evict oldest element to make space.",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2216946098",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3957,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2216943689",
        "commented_code": "@@ -67,12 +77,31 @@ export class ClearcutLogger {\n \n   // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Clearcut expects this format.\n   enqueueLogEvent(event: any): void {\n-    this.events.push([\n-      {\n-        event_time_ms: Date.now(),\n-        source_extension_json: safeJsonStringify(event),\n-      },\n-    ]);\n+    try {\n+      // Manually handle overflow for FixedDeque, which throws when full.\n+      const wasAtCapacity = this.events.size >= this.max_events;\n+\n+      if (wasAtCapacity) {\n+        this.events.shift(); // Evict oldest element to make space.",
        "comment_created_at": "2025-07-18T21:30:44+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "@gemini-code-assist The mnemonist FixedDeque is specifically designed for efficient operations at both\r\n  ends of the deque. It implements shift() with O(1) time complexity using a circular buffer internally.\r\n  This is one of the reasons we chose this data structure over a regular array.\r\n\r\n  From the mnemonist documentation, FixedDeque provides:\r\n  - O(1) push/pop operations (tail)\r\n  - O(1) shift/unshift operations (head)\r\n  - Fixed memory allocation (no dynamic resizing)\r\n\r\n  So performance is not a concern here. The shift() operation will remain performant even under memory\r\n  pressure conditions, which is exactly what we need for this use case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188134447",
    "pr_number": 2780,
    "pr_file": "packages/core/src/tools/shell.ts",
    "created_at": "2025-07-06T09:47:29+00:00",
    "commented_code": ".pop(); // take last part and return command root (or undefined if previous line was empty)\n   }\n \n+  matchesAllowPattern(command: string, pattern: string): boolean {\n+    // Check if pattern is a regex (starts with / and ends with /)\n+    if (pattern.startsWith('/') && pattern.endsWith('/')) {\n+      try {\n+        const regexStr = pattern.slice(1, -1);\n+\n+        // Check if regex is safe from ReDoS attacks\n+        if (!safeRegex(regexStr)) {\n+          console.warn(\n+            `Potentially unsafe regex pattern detected (ReDoS risk): ${pattern}`,\n+          );\n+          return false;\n+        }\n+\n+        const regex = new RegExp(regexStr);\n+        return regex.test(command);\n+      } catch (_e) {\n+        // Invalid regex, treat as literal string\n+        console.warn(`Invalid regex pattern: ${pattern}`);\n+        return false;\n+      }\n+    }\n+\n+    // Check for glob-like patterns (contains * or ?)\n+    if (pattern.includes('*') || pattern.includes('?')) {\n+      // Convert glob to regex\n+      const regexPattern = pattern\n+        .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape regex special chars except * and ?",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2188134447",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2780,
        "pr_file": "packages/core/src/tools/shell.ts",
        "discussion_id": "2188134447",
        "commented_code": "@@ -98,6 +103,82 @@ Process Group PGID: Process group started or \\`(none)\\``,\n       .pop(); // take last part and return command root (or undefined if previous line was empty)\n   }\n \n+  matchesAllowPattern(command: string, pattern: string): boolean {\n+    // Check if pattern is a regex (starts with / and ends with /)\n+    if (pattern.startsWith('/') && pattern.endsWith('/')) {\n+      try {\n+        const regexStr = pattern.slice(1, -1);\n+\n+        // Check if regex is safe from ReDoS attacks\n+        if (!safeRegex(regexStr)) {\n+          console.warn(\n+            `Potentially unsafe regex pattern detected (ReDoS risk): ${pattern}`,\n+          );\n+          return false;\n+        }\n+\n+        const regex = new RegExp(regexStr);\n+        return regex.test(command);\n+      } catch (_e) {\n+        // Invalid regex, treat as literal string\n+        console.warn(`Invalid regex pattern: ${pattern}`);\n+        return false;\n+      }\n+    }\n+\n+    // Check for glob-like patterns (contains * or ?)\n+    if (pattern.includes('*') || pattern.includes('?')) {\n+      // Convert glob to regex\n+      const regexPattern = pattern\n+        .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape regex special chars except * and ?",
        "comment_created_at": "2025-07-06T09:47:29+00:00",
        "comment_author": "aspiers",
        "comment_body": "This is not correct; `foo[0-9]` and `foo{bar,baz}` are both valid glob patterns as previously mentioned in https://github.com/google-gemini/gemini-cli/issues/2417#issuecomment-3019600412",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188135912",
    "pr_number": 2780,
    "pr_file": "packages/core/src/tools/shell.ts",
    "created_at": "2025-07-06T09:52:41+00:00",
    "commented_code": ".pop(); // take last part and return command root (or undefined if previous line was empty)\n   }\n \n+  matchesAllowPattern(command: string, pattern: string): boolean {\n+    // Check if pattern is a regex (starts with / and ends with /)\n+    if (pattern.startsWith('/') && pattern.endsWith('/')) {\n+      try {\n+        const regexStr = pattern.slice(1, -1);\n+\n+        // Check if regex is safe from ReDoS attacks\n+        if (!safeRegex(regexStr)) {\n+          console.warn(\n+            `Potentially unsafe regex pattern detected (ReDoS risk): ${pattern}`,\n+          );\n+          return false;\n+        }\n+\n+        const regex = new RegExp(regexStr);\n+        return regex.test(command);\n+      } catch (_e) {\n+        // Invalid regex, treat as literal string\n+        console.warn(`Invalid regex pattern: ${pattern}`);\n+        return false;\n+      }\n+    }\n+\n+    // Check for glob-like patterns (contains * or ?)\n+    if (pattern.includes('*') || pattern.includes('?')) {\n+      // Convert glob to regex\n+      const regexPattern = pattern\n+        .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape regex special chars except * and ?\n+        .replace(/\\*/g, '.*') // * matches any characters\n+        .replace(/\\?/g, '.'); // ? matches single character",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2188135912",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2780,
        "pr_file": "packages/core/src/tools/shell.ts",
        "discussion_id": "2188135912",
        "commented_code": "@@ -98,6 +103,82 @@ Process Group PGID: Process group started or \\`(none)\\``,\n       .pop(); // take last part and return command root (or undefined if previous line was empty)\n   }\n \n+  matchesAllowPattern(command: string, pattern: string): boolean {\n+    // Check if pattern is a regex (starts with / and ends with /)\n+    if (pattern.startsWith('/') && pattern.endsWith('/')) {\n+      try {\n+        const regexStr = pattern.slice(1, -1);\n+\n+        // Check if regex is safe from ReDoS attacks\n+        if (!safeRegex(regexStr)) {\n+          console.warn(\n+            `Potentially unsafe regex pattern detected (ReDoS risk): ${pattern}`,\n+          );\n+          return false;\n+        }\n+\n+        const regex = new RegExp(regexStr);\n+        return regex.test(command);\n+      } catch (_e) {\n+        // Invalid regex, treat as literal string\n+        console.warn(`Invalid regex pattern: ${pattern}`);\n+        return false;\n+      }\n+    }\n+\n+    // Check for glob-like patterns (contains * or ?)\n+    if (pattern.includes('*') || pattern.includes('?')) {\n+      // Convert glob to regex\n+      const regexPattern = pattern\n+        .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape regex special chars except * and ?\n+        .replace(/\\*/g, '.*') // * matches any characters\n+        .replace(/\\?/g, '.'); // ? matches single character",
        "comment_created_at": "2025-07-06T09:52:41+00:00",
        "comment_author": "aspiers",
        "comment_body": "[The original plan was to use `minimatch`](https://github.com/google-gemini/gemini-cli/issues/2417#issuecomment-3032901481); curious why this is no longer being followed?  There may be good reasons (e.g. `*` behaves differently to `**` which shows that globbing is intended for path matching), but I would definitely question not supporting `[...]` character classes at least as this is very standard syntax in any globbing context.",
        "pr_file_module": null
      },
      {
        "comment_id": "2188324010",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2780,
        "pr_file": "packages/core/src/tools/shell.ts",
        "discussion_id": "2188135912",
        "commented_code": "@@ -98,6 +103,82 @@ Process Group PGID: Process group started or \\`(none)\\``,\n       .pop(); // take last part and return command root (or undefined if previous line was empty)\n   }\n \n+  matchesAllowPattern(command: string, pattern: string): boolean {\n+    // Check if pattern is a regex (starts with / and ends with /)\n+    if (pattern.startsWith('/') && pattern.endsWith('/')) {\n+      try {\n+        const regexStr = pattern.slice(1, -1);\n+\n+        // Check if regex is safe from ReDoS attacks\n+        if (!safeRegex(regexStr)) {\n+          console.warn(\n+            `Potentially unsafe regex pattern detected (ReDoS risk): ${pattern}`,\n+          );\n+          return false;\n+        }\n+\n+        const regex = new RegExp(regexStr);\n+        return regex.test(command);\n+      } catch (_e) {\n+        // Invalid regex, treat as literal string\n+        console.warn(`Invalid regex pattern: ${pattern}`);\n+        return false;\n+      }\n+    }\n+\n+    // Check for glob-like patterns (contains * or ?)\n+    if (pattern.includes('*') || pattern.includes('?')) {\n+      // Convert glob to regex\n+      const regexPattern = pattern\n+        .replace(/[.+^${}()|[\\]\\\\]/g, '\\\\$&') // Escape regex special chars except * and ?\n+        .replace(/\\*/g, '.*') // * matches any characters\n+        .replace(/\\?/g, '.'); // ? matches single character",
        "comment_created_at": "2025-07-06T14:03:08+00:00",
        "comment_author": "palladius",
        "comment_body": "+1 on this. @heartyguy  can you please address this?",
        "pr_file_module": null
      }
    ]
  }
]