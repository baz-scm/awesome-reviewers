[
  {
    "discussion_id": "2229085602",
    "pr_number": 4790,
    "pr_file": "packages/cli/src/ui/App.tsx",
    "created_at": "2025-07-24T17:05:55+00:00",
    "commented_code": "[handleSlashCommand],\n   );\n \n+  const keystrokeHandlers = useMemo<KeystrokeHandler[]>(\n+    () => [\n+      {\n+        input: 'o',\n+        ctrl: true,\n+        handler: () => setShowErrorDetails((prev) => !prev),\n+      },\n+      {\n+        input: 't',\n+        ctrl: true,\n+        handler: () => {\n+          const newValue = !showToolDescriptions;\n+          setShowToolDescriptions(newValue);\n+\n+          const mcpServers = config.getMcpServers();\n+          if (Object.keys(mcpServers || {}).length > 0) {\n+            handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n+          }\n+        },\n+      },\n+      {\n+        input: 'e',\n+        ctrl: true,\n+        condition: () => !!ideContext,\n+        handler: () => setShowIDEContextDetail((prev) => !prev),\n+      },\n+      {\n+        input: ['c', 'C'],",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2229085602",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4790,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2229085602",
        "commented_code": "@@ -447,6 +454,76 @@ const App = ({ config, settings, startupWarnings = [], version }: AppProps) => {\n     [handleSlashCommand],\n   );\n \n+  const keystrokeHandlers = useMemo<KeystrokeHandler[]>(\n+    () => [\n+      {\n+        input: 'o',\n+        ctrl: true,\n+        handler: () => setShowErrorDetails((prev) => !prev),\n+      },\n+      {\n+        input: 't',\n+        ctrl: true,\n+        handler: () => {\n+          const newValue = !showToolDescriptions;\n+          setShowToolDescriptions(newValue);\n+\n+          const mcpServers = config.getMcpServers();\n+          if (Object.keys(mcpServers || {}).length > 0) {\n+            handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n+          }\n+        },\n+      },\n+      {\n+        input: 'e',\n+        ctrl: true,\n+        condition: () => !!ideContext,\n+        handler: () => setShowIDEContextDetail((prev) => !prev),\n+      },\n+      {\n+        input: ['c', 'C'],",
        "comment_created_at": "2025-07-24T17:05:55+00:00",
        "comment_author": "jacob314",
        "comment_body": "to align with how things will look in the future when we align the input processing with what is in text-buffer.ts I think we should change this to allowing the command both with and without shift. rather than allowing both 'c' and 'C'",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2196205418",
    "pr_number": 3712,
    "pr_file": "packages/cli/src/ui/App.tsx",
    "created_at": "2025-07-10T00:00:00+00:00",
    "commented_code": "const handleFinalSubmit = useCallback(\n     (submittedValue: string) => {\n       const trimmedValue = submittedValue.trim();\n+\n+      // Handle special queue clearing signal\n+      if (trimmedValue === '__CLEAR_QUEUE__') {\n+        setQueuedInput(null);\n+        return;\n+      }",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2196217869",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3712,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2196205418",
        "commented_code": "@@ -494,11 +495,24 @@ const App = ({ config, settings, startupWarnings = [] }: AppProps) => {\n   const handleFinalSubmit = useCallback(\n     (submittedValue: string) => {\n       const trimmedValue = submittedValue.trim();\n+\n+      // Handle special queue clearing signal\n+      if (trimmedValue === '__CLEAR_QUEUE__') {\n+        setQueuedInput(null);\n+        return;\n+      }",
        "comment_created_at": "2025-07-10T00:00:00+00:00",
        "comment_author": "suvam-jaiswal",
        "comment_body": "Addressing magic string feedback (comment 2196205418):\r\nResolved! Moved the magic string to CLEAR_QUEUE_SIGNAL constant in constants.ts and updated both files to import and use the shared constant.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2213043058",
    "pr_number": 4369,
    "pr_file": "packages/cli/src/gemini.tsx",
    "created_at": "2025-07-17T11:06:14+00:00",
    "commented_code": "process.exit(1);\n   }\n \n-  const prompt_id = Math.random().toString(16).slice(2);\n+  const promptMetadata = new PromptMetadata(\n+    Math.random().toString(16).slice(2),",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2213043058",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4369,
        "pr_file": "packages/cli/src/gemini.tsx",
        "discussion_id": "2213043058",
        "commented_code": "@@ -227,12 +228,15 @@ export async function main() {\n     process.exit(1);\n   }\n \n-  const prompt_id = Math.random().toString(16).slice(2);\n+  const promptMetadata = new PromptMetadata(\n+    Math.random().toString(16).slice(2),",
        "comment_created_at": "2025-07-17T11:06:14+00:00",
        "comment_author": "owenofbrien",
        "comment_body": "Is the session id not available here? It would be nice to use a consistent prompt id format.",
        "pr_file_module": null
      },
      {
        "comment_id": "2213349310",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4369,
        "pr_file": "packages/cli/src/gemini.tsx",
        "discussion_id": "2213043058",
        "commented_code": "@@ -227,12 +228,15 @@ export async function main() {\n     process.exit(1);\n   }\n \n-  const prompt_id = Math.random().toString(16).slice(2);\n+  const promptMetadata = new PromptMetadata(\n+    Math.random().toString(16).slice(2),",
        "comment_created_at": "2025-07-17T13:27:07+00:00",
        "comment_author": "uttamkanodia14",
        "comment_body": "Done changed it to just session_id here as prompt_count is not needed here.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216810756",
    "pr_number": 4462,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
    "created_at": "2025-07-18T19:40:23+00:00",
    "commented_code": "setShellModeActive,\n }) => {\n   const [justNavigatedHistory, setJustNavigatedHistory] = useState(false);\n+\n+  // Check if cursor is after @ or / without spaces\n+  const isCursorAfterCommandWithoutSpace = useCallback(() => {\n+    const text = buffer.text;\n+    const [row, col] = buffer.cursor;\n+\n+    // Calculate offset from row/col (same logic as in text-buffer.ts)\n+    let offset = 0;\n+    for (let i = 0; i < row; i++) {\n+      offset += buffer.lines[i].length + 1; // +1 for newline\n+    }\n+    offset += col;\n+\n+    // Search backwards from cursor position\n+    for (let i = offset - 1; i >= 0; i--) {\n+      const char = text[i];\n+      if (char === ' ' || char === '\n') {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2216810756",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4462,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2216810756",
        "commented_code": "@@ -58,10 +58,46 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n   setShellModeActive,\n }) => {\n   const [justNavigatedHistory, setJustNavigatedHistory] = useState(false);\n+\n+  // Check if cursor is after @ or / without spaces\n+  const isCursorAfterCommandWithoutSpace = useCallback(() => {\n+    const text = buffer.text;\n+    const [row, col] = buffer.cursor;\n+\n+    // Calculate offset from row/col (same logic as in text-buffer.ts)\n+    let offset = 0;\n+    for (let i = 0; i < row; i++) {\n+      offset += buffer.lines[i].length + 1; // +1 for newline\n+    }\n+    offset += col;\n+\n+    // Search backwards from cursor position\n+    for (let i = offset - 1; i >= 0; i--) {\n+      const char = text[i];\n+      if (char === ' ' || char === '\\n') {",
        "comment_created_at": "2025-07-18T19:40:23+00:00",
        "comment_author": "jacob314",
        "comment_body": "also need to handle escaped spaces in paths. check the existing logic for autocomplete for file paths to make sure the logic is aligned.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2201813583",
    "pr_number": 3895,
    "pr_file": "packages/cli/src/ui/components/shared/RadioButtonSelect.tsx",
    "created_at": "2025-07-11T20:45:03+00:00",
    "commented_code": "* SPDX-License-Identifier: Apache-2.0\n  */\n \n-import React from 'react';\n-import { Text, Box } from 'ink';\n-import SelectInput, {\n-  type ItemProps as InkSelectItemProps,\n-  type IndicatorProps as InkSelectIndicatorProps,\n-} from 'ink-select-input';\n+import React, { useEffect, useState } from 'react';\n+import { Text, Box, useInput } from 'ink';\n import { Colors } from '../../colors.js';\n \n-/**\n- * Represents a single option for the RadioButtonSelect.\n- * Requires a label for display and a value to be returned on selection.\n- */\n export interface RadioSelectItem<T> {\n   label: string;\n   value: T;\n   disabled?: boolean;\n+  themeNameDisplay?: string;\n+  themeTypeDisplay?: string;\n }\n \n-/**\n- * Props for the RadioButtonSelect component.\n- * @template T The type of the value associated with each radio item.\n- */\n export interface RadioButtonSelectProps<T> {\n-  /** An array of items to display as radio options. */\n-  items: Array<\n-    RadioSelectItem<T> & {\n-      themeNameDisplay?: string;\n-      themeTypeDisplay?: string;\n-    }\n-  >;\n-\n-  /** The initial index selected */\n+  items: Array<RadioSelectItem<T>>;\n   initialIndex?: number;\n-\n-  /** Function called when an item is selected. Receives the `value` of the selected item. */\n   onSelect: (value: T) => void;\n-\n-  /** Function called when an item is highlighted. Receives the `value` of the selected item. */\n   onHighlight?: (value: T) => void;\n-\n-  /** Whether this select input is currently focused and should respond to input. */\n   isFocused?: boolean;\n+  showScrollArrows?: boolean;\n+  maxItemsToShow?: number;\n }\n \n-/**\n- * A specialized SelectInput component styled to look like radio buttons.\n- * It uses '\u25c9' for selected and '\u25cb' for unselected items.\n- *\n- * @template T The type of the value associated with each radio item.\n- */\n export function RadioButtonSelect<T>({\n   items,\n-  initialIndex,\n+  initialIndex = 0,\n   onSelect,\n   onHighlight,\n-  isFocused, // This prop indicates if the current RadioButtonSelect group is focused\n+  isFocused,\n+  showScrollArrows = true,\n+  maxItemsToShow = 10,\n }: RadioButtonSelectProps<T>): React.JSX.Element {\n-  const handleSelect = (item: RadioSelectItem<T>) => {\n-    onSelect(item.value);\n-  };\n-  const handleHighlight = (item: RadioSelectItem<T>) => {\n-    if (onHighlight) {\n-      onHighlight(item.value);\n-    }\n-  };\n+  const [activeIndex, setActiveIndex] = useState(initialIndex);\n+  const [scrollOffset, setScrollOffset] = useState(0);\n \n-  /**\n-   * Custom indicator component displaying radio button style (\u25c9/\u25cb).\n-   * Color changes based on whether the item is selected and if its group is focused.\n-   */\n-  function DynamicRadioIndicator({\n-    isSelected = false,\n-  }: InkSelectIndicatorProps): React.JSX.Element {\n-    return (\n-      <Box minWidth={2} flexShrink={0}>\n-        <Text color={isSelected ? Colors.AccentGreen : Colors.Foreground}>\n-          {isSelected ? '\u25cf' : '\u25cb'}\n-        </Text>\n-      </Box>\n+  useEffect(() => {\n+    const newScrollOffset = Math.max(\n+      0,\n+      Math.min(activeIndex - maxItemsToShow + 1, items.length - maxItemsToShow),\n     );\n-  }\n+    if (activeIndex < scrollOffset) {\n+      setScrollOffset(activeIndex);\n+    } else if (activeIndex >= scrollOffset + maxItemsToShow) {\n+      setScrollOffset(newScrollOffset);\n+    }\n+  }, [activeIndex, items.length, scrollOffset, maxItemsToShow]);\n \n-  /**\n-   * Custom item component for displaying the label.\n-   * Color changes based on whether the item is selected and if its group is focused.\n-   * Now also handles displaying theme type with custom color.\n-   */\n-  function CustomThemeItemComponent(\n-    props: InkSelectItemProps,\n-  ): React.JSX.Element {\n-    const { isSelected = false, label } = props;\n-    const itemWithThemeProps = props as typeof props & {\n-      themeNameDisplay?: string;\n-      themeTypeDisplay?: string;\n-      disabled?: boolean;\n-    };\n+  useInput(\n+    (input, key) => {\n+      if (key.upArrow) {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2201813583",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3895,
        "pr_file": "packages/cli/src/ui/components/shared/RadioButtonSelect.tsx",
        "discussion_id": "2201813583",
        "commented_code": "@@ -4,139 +4,122 @@\n  * SPDX-License-Identifier: Apache-2.0\n  */\n \n-import React from 'react';\n-import { Text, Box } from 'ink';\n-import SelectInput, {\n-  type ItemProps as InkSelectItemProps,\n-  type IndicatorProps as InkSelectIndicatorProps,\n-} from 'ink-select-input';\n+import React, { useEffect, useState } from 'react';\n+import { Text, Box, useInput } from 'ink';\n import { Colors } from '../../colors.js';\n \n-/**\n- * Represents a single option for the RadioButtonSelect.\n- * Requires a label for display and a value to be returned on selection.\n- */\n export interface RadioSelectItem<T> {\n   label: string;\n   value: T;\n   disabled?: boolean;\n+  themeNameDisplay?: string;\n+  themeTypeDisplay?: string;\n }\n \n-/**\n- * Props for the RadioButtonSelect component.\n- * @template T The type of the value associated with each radio item.\n- */\n export interface RadioButtonSelectProps<T> {\n-  /** An array of items to display as radio options. */\n-  items: Array<\n-    RadioSelectItem<T> & {\n-      themeNameDisplay?: string;\n-      themeTypeDisplay?: string;\n-    }\n-  >;\n-\n-  /** The initial index selected */\n+  items: Array<RadioSelectItem<T>>;\n   initialIndex?: number;\n-\n-  /** Function called when an item is selected. Receives the `value` of the selected item. */\n   onSelect: (value: T) => void;\n-\n-  /** Function called when an item is highlighted. Receives the `value` of the selected item. */\n   onHighlight?: (value: T) => void;\n-\n-  /** Whether this select input is currently focused and should respond to input. */\n   isFocused?: boolean;\n+  showScrollArrows?: boolean;\n+  maxItemsToShow?: number;\n }\n \n-/**\n- * A specialized SelectInput component styled to look like radio buttons.\n- * It uses '\u25c9' for selected and '\u25cb' for unselected items.\n- *\n- * @template T The type of the value associated with each radio item.\n- */\n export function RadioButtonSelect<T>({\n   items,\n-  initialIndex,\n+  initialIndex = 0,\n   onSelect,\n   onHighlight,\n-  isFocused, // This prop indicates if the current RadioButtonSelect group is focused\n+  isFocused,\n+  showScrollArrows = true,\n+  maxItemsToShow = 10,\n }: RadioButtonSelectProps<T>): React.JSX.Element {\n-  const handleSelect = (item: RadioSelectItem<T>) => {\n-    onSelect(item.value);\n-  };\n-  const handleHighlight = (item: RadioSelectItem<T>) => {\n-    if (onHighlight) {\n-      onHighlight(item.value);\n-    }\n-  };\n+  const [activeIndex, setActiveIndex] = useState(initialIndex);\n+  const [scrollOffset, setScrollOffset] = useState(0);\n \n-  /**\n-   * Custom indicator component displaying radio button style (\u25c9/\u25cb).\n-   * Color changes based on whether the item is selected and if its group is focused.\n-   */\n-  function DynamicRadioIndicator({\n-    isSelected = false,\n-  }: InkSelectIndicatorProps): React.JSX.Element {\n-    return (\n-      <Box minWidth={2} flexShrink={0}>\n-        <Text color={isSelected ? Colors.AccentGreen : Colors.Foreground}>\n-          {isSelected ? '\u25cf' : '\u25cb'}\n-        </Text>\n-      </Box>\n+  useEffect(() => {\n+    const newScrollOffset = Math.max(\n+      0,\n+      Math.min(activeIndex - maxItemsToShow + 1, items.length - maxItemsToShow),\n     );\n-  }\n+    if (activeIndex < scrollOffset) {\n+      setScrollOffset(activeIndex);\n+    } else if (activeIndex >= scrollOffset + maxItemsToShow) {\n+      setScrollOffset(newScrollOffset);\n+    }\n+  }, [activeIndex, items.length, scrollOffset, maxItemsToShow]);\n \n-  /**\n-   * Custom item component for displaying the label.\n-   * Color changes based on whether the item is selected and if its group is focused.\n-   * Now also handles displaying theme type with custom color.\n-   */\n-  function CustomThemeItemComponent(\n-    props: InkSelectItemProps,\n-  ): React.JSX.Element {\n-    const { isSelected = false, label } = props;\n-    const itemWithThemeProps = props as typeof props & {\n-      themeNameDisplay?: string;\n-      themeTypeDisplay?: string;\n-      disabled?: boolean;\n-    };\n+  useInput(\n+    (input, key) => {\n+      if (key.upArrow) {",
        "comment_created_at": "2025-07-11T20:45:03+00:00",
        "comment_author": "jacob314",
        "comment_body": "nit: can you add support for 'j' and 'k' to match the existing ink library we were previously using?",
        "pr_file_module": null
      }
    ]
  }
]