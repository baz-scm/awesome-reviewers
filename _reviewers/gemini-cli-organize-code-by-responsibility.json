[
  {
    "discussion_id": "2223366958",
    "pr_number": 4453,
    "pr_file": "packages/cli/src/ui/App.tsx",
    "created_at": "2025-07-22T17:49:00+00:00",
    "commented_code": "setConstrainHeight(true);\n     }\n \n-    if (key.ctrl && input === 'o') {\n+    if (key.escape) {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2223366958",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4453,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2223366958",
        "commented_code": "@@ -454,7 +465,24 @@ const App = ({ config, settings, startupWarnings = [], version }: AppProps) => {\n       setConstrainHeight(true);\n     }\n \n-    if (key.ctrl && input === 'o') {\n+    if (key.escape) {",
        "comment_created_at": "2025-07-22T17:49:00+00:00",
        "comment_author": "jacob314",
        "comment_body": "can you move this escape logic into InputPrompt rather than having App.tsx deal with functionality that is focused on input prompt?",
        "pr_file_module": null
      },
      {
        "comment_id": "2227164987",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4453,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2223366958",
        "commented_code": "@@ -454,7 +465,24 @@ const App = ({ config, settings, startupWarnings = [], version }: AppProps) => {\n       setConstrainHeight(true);\n     }\n \n-    if (key.ctrl && input === 'o') {\n+    if (key.escape) {",
        "comment_created_at": "2025-07-24T02:19:02+00:00",
        "comment_author": "lifefloating",
        "comment_body": "https://github.com/google-gemini/gemini-cli/pull/4453#issuecomment-3109549641",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2223917713",
    "pr_number": 4686,
    "pr_file": "packages/cli/src/ui/App.tsx",
    "created_at": "2025-07-22T22:07:18+00:00",
    "commented_code": "version: string;\n }\n \n+function handleAutoUpdate(",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2223917713",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4686,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2223917713",
        "commented_code": "@@ -94,6 +95,76 @@ interface AppProps {\n   version: string;\n }\n \n+function handleAutoUpdate(",
        "comment_created_at": "2025-07-22T22:07:18+00:00",
        "comment_author": "jacob314",
        "comment_body": "can you move this out of App.tsx and into a separate file? I'd also suggest considering making this method be less coupled from react. After you sync to the latest you might want to check out how 'unhandledRejection' is now dealing with a similar case in gemini.tsx You could then start the process of checking for updates in gemini.tsx before the react app is even started using the same mechanism to send events to the app notifying it that updates have been accepted.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2227011352",
    "pr_number": 4686,
    "pr_file": "packages/cli/src/gemini.tsx",
    "created_at": "2025-07-24T00:26:29+00:00",
    "commented_code": "finalConfig,\n   );\n }\n+\n+function handleAutoUpdate(",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2227011352",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4686,
        "pr_file": "packages/cli/src/gemini.tsx",
        "discussion_id": "2227011352",
        "commented_code": "@@ -325,3 +332,61 @@ async function loadNonInteractiveConfig(\n     finalConfig,\n   );\n }\n+\n+function handleAutoUpdate(",
        "comment_created_at": "2025-07-24T00:26:29+00:00",
        "comment_author": "jacob314",
        "comment_body": "nit: can you move this out of gemini into autoUpdate.ts or similar. could make testing easier and gemini.tsx is one of the tragedy of the commons files like app.tsx that it would be nice to try to keep small.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2202864938",
    "pr_number": 3967,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
    "created_at": "2025-07-12T18:32:23+00:00",
    "commented_code": "return;\n       }\n \n+      if (key.name === 'home') {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2202864938",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3967,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2202864938",
        "commented_code": "@@ -341,6 +341,16 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n         return;\n       }\n \n+      if (key.name === 'home') {",
        "comment_created_at": "2025-07-12T18:32:23+00:00",
        "comment_author": "jacob314",
        "comment_body": "please add these to TextBuffer rather than InputPrompt as nothing about this is specific to the InputPrompt",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2231713798",
    "pr_number": 4790,
    "pr_file": "packages/cli/src/ui/App.tsx",
    "created_at": "2025-07-25T17:54:40+00:00",
    "commented_code": "setConstrainHeight(true);\n     }\n \n-    if (key.ctrl && input === 'o') {\n-      setShowErrorDetails((prev) => !prev);\n-    } else if (key.ctrl && input === 't') {\n-      const newValue = !showToolDescriptions;\n-      setShowToolDescriptions(newValue);\n+    const context = { enteringConstrainHeightMode };\n \n-      const mcpServers = config.getMcpServers();\n-      if (Object.keys(mcpServers || {}).length > 0) {\n-        handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n-      }\n-    } else if (key.ctrl && (input === 'c' || input === 'C')) {\n-      handleExit(ctrlCPressedOnce, setCtrlCPressedOnce, ctrlCTimerRef);\n-    } else if (key.ctrl && (input === 'd' || input === 'D')) {\n-      if (buffer.text.length > 0) {\n-        // Do nothing if there is text in the input.\n-        return;\n+    const handler = keystrokeHandlers.find((h) => {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2231713798",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4790,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2231713798",
        "commented_code": "@@ -455,26 +531,20 @@ const App = ({ config, settings, startupWarnings = [], version }: AppProps) => {\n       setConstrainHeight(true);\n     }\n \n-    if (key.ctrl && input === 'o') {\n-      setShowErrorDetails((prev) => !prev);\n-    } else if (key.ctrl && input === 't') {\n-      const newValue = !showToolDescriptions;\n-      setShowToolDescriptions(newValue);\n+    const context = { enteringConstrainHeightMode };\n \n-      const mcpServers = config.getMcpServers();\n-      if (Object.keys(mcpServers || {}).length > 0) {\n-        handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n-      }\n-    } else if (key.ctrl && (input === 'c' || input === 'C')) {\n-      handleExit(ctrlCPressedOnce, setCtrlCPressedOnce, ctrlCTimerRef);\n-    } else if (key.ctrl && (input === 'd' || input === 'D')) {\n-      if (buffer.text.length > 0) {\n-        // Do nothing if there is text in the input.\n-        return;\n+    const handler = keystrokeHandlers.find((h) => {",
        "comment_created_at": "2025-07-25T17:54:40+00:00",
        "comment_author": "jacob314",
        "comment_body": "this logic to execute the keystroke handlers seems independent on app. I would move it to keystrokeHandler.ts (also please rename that file to align with naming schemes for non tsx files in this project.\nWould then be nice to add a basic unittest for it that verifies cases such as if key.shift  and key.ctrl are handled correctly. seems like right now key.shift is ignored.",
        "pr_file_module": null
      },
      {
        "comment_id": "2231772382",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4790,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2231713798",
        "commented_code": "@@ -455,26 +531,20 @@ const App = ({ config, settings, startupWarnings = [], version }: AppProps) => {\n       setConstrainHeight(true);\n     }\n \n-    if (key.ctrl && input === 'o') {\n-      setShowErrorDetails((prev) => !prev);\n-    } else if (key.ctrl && input === 't') {\n-      const newValue = !showToolDescriptions;\n-      setShowToolDescriptions(newValue);\n+    const context = { enteringConstrainHeightMode };\n \n-      const mcpServers = config.getMcpServers();\n-      if (Object.keys(mcpServers || {}).length > 0) {\n-        handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n-      }\n-    } else if (key.ctrl && (input === 'c' || input === 'C')) {\n-      handleExit(ctrlCPressedOnce, setCtrlCPressedOnce, ctrlCTimerRef);\n-    } else if (key.ctrl && (input === 'd' || input === 'D')) {\n-      if (buffer.text.length > 0) {\n-        // Do nothing if there is text in the input.\n-        return;\n+    const handler = keystrokeHandlers.find((h) => {",
        "comment_created_at": "2025-07-25T18:29:45+00:00",
        "comment_author": "cornmander",
        "comment_body": "+1 to this. would add a method like findHandler(input, key). I also think it's worth having a class that would allow registering the handlers since it would let you add validation to prevent two handlers being registered on the same key:\r\n\r\nKeystrokeHandlerRegistry(handlers: KeystrokeHandler[])\r\nKeystrokeHandlerRegistry.findHandler(...) -> Optional<KeystrokeHandler>",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2228836910",
    "pr_number": 4682,
    "pr_file": "packages/cli/src/ui/App.tsx",
    "created_at": "2025-07-24T15:20:30+00:00",
    "commented_code": "if (Object.keys(mcpServers || {}).length > 0) {\n         handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n       }\n+    } else if (key.ctrl && input === 'e' && ideContext) {\n+      setShowIDEContextDetail((prev) => !prev);\n     } else if (key.ctrl && (input === 'c' || input === 'C')) {\n       handleExit(ctrlCPressedOnce, setCtrlCPressedOnce, ctrlCTimerRef);\n     } else if (key.ctrl && (input === 'd' || input === 'D')) {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2228836910",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4682,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2228836910",
        "commented_code": "@@ -465,6 +468,8 @@ const App = ({ config, settings, startupWarnings = [], version }: AppProps) => {\n       if (Object.keys(mcpServers || {}).length > 0) {\n         handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n       }\n+    } else if (key.ctrl && input === 'e' && ideContext) {\n+      setShowIDEContextDetail((prev) => !prev);\n     } else if (key.ctrl && (input === 'c' || input === 'C')) {\n       handleExit(ctrlCPressedOnce, setCtrlCPressedOnce, ctrlCTimerRef);\n     } else if (key.ctrl && (input === 'd' || input === 'D')) {",
        "comment_created_at": "2025-07-24T15:20:30+00:00",
        "comment_author": "cornmander",
        "comment_body": "Can we refactor this input handler so that you can register a keystroke handler? This is starting to get unwieldly. It's ok to do this in a followup.",
        "pr_file_module": null
      },
      {
        "comment_id": "2228853328",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4682,
        "pr_file": "packages/cli/src/ui/App.tsx",
        "discussion_id": "2228836910",
        "commented_code": "@@ -465,6 +468,8 @@ const App = ({ config, settings, startupWarnings = [], version }: AppProps) => {\n       if (Object.keys(mcpServers || {}).length > 0) {\n         handleSlashCommand(newValue ? '/mcp desc' : '/mcp nodesc');\n       }\n+    } else if (key.ctrl && input === 'e' && ideContext) {\n+      setShowIDEContextDetail((prev) => !prev);\n     } else if (key.ctrl && (input === 'c' || input === 'C')) {\n       handleExit(ctrlCPressedOnce, setCtrlCPressedOnce, ctrlCTimerRef);\n     } else if (key.ctrl && (input === 'd' || input === 'D')) {",
        "comment_created_at": "2025-07-24T15:26:53+00:00",
        "comment_author": "chrstnb",
        "comment_body": "yep! will do right after",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167816444",
    "pr_number": 1656,
    "pr_file": "packages/cli/src/ui/components/messages/ToolMessage.tsx",
    "created_at": "2025-06-25T23:42:53+00:00",
    "commented_code": "<Text color={nameColor} bold>\n           {name}\n         </Text>{' '}\n-        <Text color={Colors.Gray}>{description}</Text>\n+        <Text color={theme.colors.Gray}>{description}</Text>\n       </Text>\n     </Box>\n   );\n };\n \n-const TrailingIndicator: React.FC = () => (\n-  <Text color={Colors.Foreground} wrap=\"truncate\">\n-    {' '}\n-    \u2190\n-  </Text>\n-);\n+const TrailingIndicator: React.FC = () => {\n+  const theme = themeManager.getActiveTheme();\n+  return (\n+    <Text color={theme.colors.Foreground} wrap=\"truncate\">",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2167816444",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1656,
        "pr_file": "packages/cli/src/ui/components/messages/ToolMessage.tsx",
        "discussion_id": "2167816444",
        "commented_code": "@@ -180,15 +185,18 @@ const ToolInfo: React.FC<ToolInfo> = ({\n         <Text color={nameColor} bold>\n           {name}\n         </Text>{' '}\n-        <Text color={Colors.Gray}>{description}</Text>\n+        <Text color={theme.colors.Gray}>{description}</Text>\n       </Text>\n     </Box>\n   );\n };\n \n-const TrailingIndicator: React.FC = () => (\n-  <Text color={Colors.Foreground} wrap=\"truncate\">\n-    {' '}\n-    \u2190\n-  </Text>\n-);\n+const TrailingIndicator: React.FC = () => {\n+  const theme = themeManager.getActiveTheme();\n+  return (\n+    <Text color={theme.colors.Foreground} wrap=\"truncate\">",
        "comment_created_at": "2025-06-25T23:42:53+00:00",
        "comment_author": "jacob314",
        "comment_body": "grabbing the theme from the theme manager is making all of this code a bit more complex and isn't needed as colors.ts is actually doing this behind the scenes in each getter.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167826741",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1656,
        "pr_file": "packages/cli/src/ui/components/messages/ToolMessage.tsx",
        "discussion_id": "2167816444",
        "commented_code": "@@ -180,15 +185,18 @@ const ToolInfo: React.FC<ToolInfo> = ({\n         <Text color={nameColor} bold>\n           {name}\n         </Text>{' '}\n-        <Text color={Colors.Gray}>{description}</Text>\n+        <Text color={theme.colors.Gray}>{description}</Text>\n       </Text>\n     </Box>\n   );\n };\n \n-const TrailingIndicator: React.FC = () => (\n-  <Text color={Colors.Foreground} wrap=\"truncate\">\n-    {' '}\n-    \u2190\n-  </Text>\n-);\n+const TrailingIndicator: React.FC = () => {\n+  const theme = themeManager.getActiveTheme();\n+  return (\n+    <Text color={theme.colors.Foreground} wrap=\"truncate\">",
        "comment_created_at": "2025-06-25T23:56:13+00:00",
        "comment_author": "acoliver",
        "comment_body": "Then it must not be working because no theme colors were applied in the ToolMessages. Looking into this maybe there were other parts that were hardcoded. There are/were hardcoded ansi codes in some places.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167903394",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1656,
        "pr_file": "packages/cli/src/ui/components/messages/ToolMessage.tsx",
        "discussion_id": "2167816444",
        "commented_code": "@@ -180,15 +185,18 @@ const ToolInfo: React.FC<ToolInfo> = ({\n         <Text color={nameColor} bold>\n           {name}\n         </Text>{' '}\n-        <Text color={Colors.Gray}>{description}</Text>\n+        <Text color={theme.colors.Gray}>{description}</Text>\n       </Text>\n     </Box>\n   );\n };\n \n-const TrailingIndicator: React.FC = () => (\n-  <Text color={Colors.Foreground} wrap=\"truncate\">\n-    {' '}\n-    \u2190\n-  </Text>\n-);\n+const TrailingIndicator: React.FC = () => {\n+  const theme = themeManager.getActiveTheme();\n+  return (\n+    <Text color={theme.colors.Foreground} wrap=\"truncate\">",
        "comment_created_at": "2025-06-26T01:18:52+00:00",
        "comment_author": "acoliver",
        "comment_body": "@jacob314 this should be resolved - I also found other places with hardcoded ansi codes. In addition, I swapped some of those to use chalk (since it was already was a dependency of ink) and extended the colors utility to work outside of the react parts. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198870838",
    "pr_number": 3554,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
    "created_at": "2025-07-10T22:18:33+00:00",
    "commented_code": "return;\n       }\n \n+      // Undo/Redo",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2198870838",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3554,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2198870838",
        "commented_code": "@@ -308,6 +308,16 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n         return;\n       }\n \n+      // Undo/Redo",
        "comment_created_at": "2025-07-10T22:18:33+00:00",
        "comment_author": "jacob314",
        "comment_body": "this logic should go one level deeper in TextBuffer rather than InputPrompt as it does not require any of the additional data (e.g. autocomplete) that InputPrompt has.",
        "pr_file_module": null
      },
      {
        "comment_id": "2202886451",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3554,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2198870838",
        "commented_code": "@@ -308,6 +308,16 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n         return;\n       }\n \n+      // Undo/Redo",
        "comment_created_at": "2025-07-12T19:34:44+00:00",
        "comment_author": "masiafrest",
        "comment_body": "thanks for the review, once i got time, maybe next week will address those.",
        "pr_file_module": null
      },
      {
        "comment_id": "2214641636",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3554,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2198870838",
        "commented_code": "@@ -308,6 +308,16 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n         return;\n       }\n \n+      // Undo/Redo",
        "comment_created_at": "2025-07-18T01:19:28+00:00",
        "comment_author": "jacob314",
        "comment_body": "Thank you! Please let me know if there is anything I can do to help. Could really use this functionality",
        "pr_file_module": null
      },
      {
        "comment_id": "2216424481",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3554,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2198870838",
        "commented_code": "@@ -308,6 +308,16 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n         return;\n       }\n \n+      // Undo/Redo",
        "comment_created_at": "2025-07-18T16:14:33+00:00",
        "comment_author": "masiafrest",
        "comment_body": "Hey @jacob314, sorry for the delay this week! I've been a bit swamped but will definitely review this evening or tomorrow.\r\n\r\nBefore I forget, I had a couple of question for some of those request changes, and I'd appreciate your input:\r\n\r\n* In `InputPrompt.test`, already has a mocked undo/redo. That's why I called them directly within `InputPrompt` (treating it somewhat like a view layer) and then tested that they were called. We could let the default handler in `TextBuffer` manage the actual undo/redo logic since its implementation is already tested there.\r\n* using **`ctrl + y` is for yolo mode**, so to avoid conflict, so i opted **`ctrl + r` as a redo** \ud83d\ude43 \r\n* I initially tried **`Ctrl + Shift + Z`** but ran into an odd issue where it didn't seem to be picked up. I even used the debug tool to check the input state, but no luck. I'm wondering if the terminal might be filtering those inputs.\r\n\r\n---\r\n\r\nMy native language is Spanish so is there some misspelling on English please tell me to improve \ud83d\ude47",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167738214",
    "pr_number": 1580,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
    "created_at": "2025-06-25T22:20:11+00:00",
    "commented_code": "<Text color={Colors.Gray}>{placeholder}</Text>\n             )\n           ) : (\n-            linesToRender.map((lineText, visualIdxInRenderedSet) => {\n-              const cursorVisualRow = cursorVisualRowAbsolute - scrollVisualRow;\n-              let display = cpSlice(lineText, 0, inputWidth);\n-              const currentVisualWidth = stringWidth(display);\n-              if (currentVisualWidth < inputWidth) {\n-                display = display + ' '.repeat(inputWidth - currentVisualWidth);\n-              }\n-\n-              if (visualIdxInRenderedSet === cursorVisualRow) {\n-                const relativeVisualColForHighlight = cursorVisualColAbsolute;\n-                if (relativeVisualColForHighlight >= 0) {\n-                  if (relativeVisualColForHighlight < cpLen(display)) {\n-                    const charToHighlight =\n-                      cpSlice(\n-                        display,\n-                        relativeVisualColForHighlight,\n-                        relativeVisualColForHighlight + 1,\n-                      ) || ' ';\n-                    const highlighted = chalk.inverse(charToHighlight);\n-                    display =\n-                      cpSlice(display, 0, relativeVisualColForHighlight) +\n-                      highlighted +\n-                      cpSlice(display, relativeVisualColForHighlight + 1);\n-                  } else if (\n-                    relativeVisualColForHighlight === cpLen(display) &&\n-                    cpLen(display) === inputWidth\n-                  ) {\n-                    display = display + chalk.inverse(' ');\n+            (() => {\n+              // Count images across all lines to maintain sequential numbering",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2167738214",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1580,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2167738214",
        "commented_code": "@@ -384,41 +433,73 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n               <Text color={Colors.Gray}>{placeholder}</Text>\n             )\n           ) : (\n-            linesToRender.map((lineText, visualIdxInRenderedSet) => {\n-              const cursorVisualRow = cursorVisualRowAbsolute - scrollVisualRow;\n-              let display = cpSlice(lineText, 0, inputWidth);\n-              const currentVisualWidth = stringWidth(display);\n-              if (currentVisualWidth < inputWidth) {\n-                display = display + ' '.repeat(inputWidth - currentVisualWidth);\n-              }\n-\n-              if (visualIdxInRenderedSet === cursorVisualRow) {\n-                const relativeVisualColForHighlight = cursorVisualColAbsolute;\n-                if (relativeVisualColForHighlight >= 0) {\n-                  if (relativeVisualColForHighlight < cpLen(display)) {\n-                    const charToHighlight =\n-                      cpSlice(\n-                        display,\n-                        relativeVisualColForHighlight,\n-                        relativeVisualColForHighlight + 1,\n-                      ) || ' ';\n-                    const highlighted = chalk.inverse(charToHighlight);\n-                    display =\n-                      cpSlice(display, 0, relativeVisualColForHighlight) +\n-                      highlighted +\n-                      cpSlice(display, relativeVisualColForHighlight + 1);\n-                  } else if (\n-                    relativeVisualColForHighlight === cpLen(display) &&\n-                    cpLen(display) === inputWidth\n-                  ) {\n-                    display = display + chalk.inverse(' ');\n+            (() => {\n+              // Count images across all lines to maintain sequential numbering",
        "comment_created_at": "2025-06-25T22:20:11+00:00",
        "comment_author": "jacob314",
        "comment_body": "this logic should move to text-buffer.ts and operate on the lines before wrapping.\r\nlets also be sure to implement this in a way that we can support highlighting blocks like [Image 1] with custom colors in the future. I'd suggest we move these complex changes to a second PR and land this first just supporting paste that adds a user visible `@some/path/to/image.png` in the input prompt.",
        "pr_file_module": null
      },
      {
        "comment_id": "2167738623",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1580,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.tsx",
        "discussion_id": "2167738214",
        "commented_code": "@@ -384,41 +433,73 @@ export const InputPrompt: React.FC<InputPromptProps> = ({\n               <Text color={Colors.Gray}>{placeholder}</Text>\n             )\n           ) : (\n-            linesToRender.map((lineText, visualIdxInRenderedSet) => {\n-              const cursorVisualRow = cursorVisualRowAbsolute - scrollVisualRow;\n-              let display = cpSlice(lineText, 0, inputWidth);\n-              const currentVisualWidth = stringWidth(display);\n-              if (currentVisualWidth < inputWidth) {\n-                display = display + ' '.repeat(inputWidth - currentVisualWidth);\n-              }\n-\n-              if (visualIdxInRenderedSet === cursorVisualRow) {\n-                const relativeVisualColForHighlight = cursorVisualColAbsolute;\n-                if (relativeVisualColForHighlight >= 0) {\n-                  if (relativeVisualColForHighlight < cpLen(display)) {\n-                    const charToHighlight =\n-                      cpSlice(\n-                        display,\n-                        relativeVisualColForHighlight,\n-                        relativeVisualColForHighlight + 1,\n-                      ) || ' ';\n-                    const highlighted = chalk.inverse(charToHighlight);\n-                    display =\n-                      cpSlice(display, 0, relativeVisualColForHighlight) +\n-                      highlighted +\n-                      cpSlice(display, relativeVisualColForHighlight + 1);\n-                  } else if (\n-                    relativeVisualColForHighlight === cpLen(display) &&\n-                    cpLen(display) === inputWidth\n-                  ) {\n-                    display = display + chalk.inverse(' ');\n+            (() => {\n+              // Count images across all lines to maintain sequential numbering",
        "comment_created_at": "2025-06-25T22:20:40+00:00",
        "comment_author": "jacob314",
        "comment_body": "moving to text-buffer.ts will also make it easy to test this as that part of the code base has reasonable unit tests.",
        "pr_file_module": null
      }
    ]
  }
]