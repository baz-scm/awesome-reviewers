[
  {
    "discussion_id": "2201720673",
    "pr_number": 3868,
    "pr_file": "docs/design/declarative-keybindings.md",
    "created_at": "2025-07-11T19:51:16+00:00",
    "commented_code": "+# **Declarative Keybindings**\n+\n+This high-level design document outlines a significant change to the Gemini\n+CLI codebase. It is intended to facilitate collaboration between human\n+developers, domain experts, code reviewers, and AI coding assistants to ensure\n+a safe and correct implementation.\n+\n+## **Process**\n+\n+The process begins by seeding this document with high-level prompts. These\n+prompts will be shared with both coding assistants and human technical leads\n+to establish a mutual understanding of the project requirements.\n+\n+The coding assistant will then update this document with a detailed overview\n+of the recommended approach, including risks, alternatives considered, and a\n+step-by-step plan for implementing and testing the changes.\n+\n+We will share this document with human reviewers early in the process to\n+gather feedback from experts on this area of the Gemini CLI codebase.\n+\n+After implementation, this document will be retained as a record of the design\n+process and serve as a reference for future projects.\n+\n+After completion of this project, this document should no longer be materially\n+updated, though it can be appended with a record of related subsequent work if\n+that proves useful.\n+\n+## **Initial Prompt**\n+\n+We're going to work on a large project together to make it easier to add,\n+update, and discover keybindings for gemini-cli.\n+\n+I anticipate that the best approach will be to rewrite the code that handles\n+specific keybindings. Instead of hardcoded logic, this code will create and\n+call a internal new API. This API will allow different parts of the\n+application to declare named callbacks, which will be recorded in a central\n+registry. A separate configuration file will then map specific keystrokes to\n+these named callbacks.\n+\n+This approach will make keybindings discoverable, either by reading the\n+configuration file or by introspecting the registry at runtime. It will also\n+make it easier to detect conflicting key assignments.\n+\n+This will be a major project. I want you to thoroughly analyze the problem,\n+understand the existing code and current implementations of keybindings within\n+the codebase, and help us decide whether this project is feasible.\n+\n+In particular, I'd like to know if we can reimplement _all_ existing logic\n+without making breaking changes. I don't want to get partway down this path\n+only to discover during a rewrite that some critical existing piece of\n+functionality will no longer work.\n+\n+We should use this as an opportunity to write very clean code and use the\n+process itself as an example for others.\n+\n+## **Preliminary Discovery by Gemini**\n+\n+### **1. Overview**\n+\n+The current implementation of keybindings in the Gemini CLI relies on the\n+`useInput` hook from the `ink` library. This hook is used in various\n+components to handle keyboard input. The main application component,\n+`App.tsx`, handles global keybindings, while other components (like dialogs)\n+handle their own specific key events. This decentralized approach makes it\n+difficult to discover, manage, and update keybindings. It also increases the\n+risk of conflicting key assignments.\n+\n+The proposed refactoring will introduce a centralized keybinding system. This\n+system will consist of:\n+\n+- **A Keybinding Registry:** A central registry will store all available\n+  keybinding actions. Each action will have a unique name, a description, and\n+  a callback function.\n+- **A Configuration File:** A configuration file (e.g., `keybindings.json`)\n+  will map specific key combinations to the named actions in the registry.\n+  This will allow users to customize their keybindings.\n+- **A Keybinding Service:** A service will be responsible for reading the\n+  configuration file, listening for key presses, and invoking the appropriate\n+  callbacks from the registry.\n+\n+### **2. Plan**\n+\n+1. **Create the Keybinding Registry:**\n+   - Define a `Keybinding` interface with properties like `name`,\n+     `description`, `callback`, and `defaultKey`.\n+   - Implement a `KeybindingRegistry` class with methods to `register` and\n+     `get` keybindings.\n+   - The registry will be a singleton, accessible throughout the application.\n+\n+1. **Implement the Keybinding Service:**\n+   - Create a `KeybindingService` that reads the keybinding configuration from\n+     a file.\n+   - The service will use a single `useInput` hook at the top level of the",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2201720673",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3868,
        "pr_file": "docs/design/declarative-keybindings.md",
        "discussion_id": "2201720673",
        "commented_code": "@@ -0,0 +1,137 @@\n+# **Declarative Keybindings**\n+\n+This high-level design document outlines a significant change to the Gemini\n+CLI codebase. It is intended to facilitate collaboration between human\n+developers, domain experts, code reviewers, and AI coding assistants to ensure\n+a safe and correct implementation.\n+\n+## **Process**\n+\n+The process begins by seeding this document with high-level prompts. These\n+prompts will be shared with both coding assistants and human technical leads\n+to establish a mutual understanding of the project requirements.\n+\n+The coding assistant will then update this document with a detailed overview\n+of the recommended approach, including risks, alternatives considered, and a\n+step-by-step plan for implementing and testing the changes.\n+\n+We will share this document with human reviewers early in the process to\n+gather feedback from experts on this area of the Gemini CLI codebase.\n+\n+After implementation, this document will be retained as a record of the design\n+process and serve as a reference for future projects.\n+\n+After completion of this project, this document should no longer be materially\n+updated, though it can be appended with a record of related subsequent work if\n+that proves useful.\n+\n+## **Initial Prompt**\n+\n+We're going to work on a large project together to make it easier to add,\n+update, and discover keybindings for gemini-cli.\n+\n+I anticipate that the best approach will be to rewrite the code that handles\n+specific keybindings. Instead of hardcoded logic, this code will create and\n+call a internal new API. This API will allow different parts of the\n+application to declare named callbacks, which will be recorded in a central\n+registry. A separate configuration file will then map specific keystrokes to\n+these named callbacks.\n+\n+This approach will make keybindings discoverable, either by reading the\n+configuration file or by introspecting the registry at runtime. It will also\n+make it easier to detect conflicting key assignments.\n+\n+This will be a major project. I want you to thoroughly analyze the problem,\n+understand the existing code and current implementations of keybindings within\n+the codebase, and help us decide whether this project is feasible.\n+\n+In particular, I'd like to know if we can reimplement _all_ existing logic\n+without making breaking changes. I don't want to get partway down this path\n+only to discover during a rewrite that some critical existing piece of\n+functionality will no longer work.\n+\n+We should use this as an opportunity to write very clean code and use the\n+process itself as an example for others.\n+\n+## **Preliminary Discovery by Gemini**\n+\n+### **1. Overview**\n+\n+The current implementation of keybindings in the Gemini CLI relies on the\n+`useInput` hook from the `ink` library. This hook is used in various\n+components to handle keyboard input. The main application component,\n+`App.tsx`, handles global keybindings, while other components (like dialogs)\n+handle their own specific key events. This decentralized approach makes it\n+difficult to discover, manage, and update keybindings. It also increases the\n+risk of conflicting key assignments.\n+\n+The proposed refactoring will introduce a centralized keybinding system. This\n+system will consist of:\n+\n+- **A Keybinding Registry:** A central registry will store all available\n+  keybinding actions. Each action will have a unique name, a description, and\n+  a callback function.\n+- **A Configuration File:** A configuration file (e.g., `keybindings.json`)\n+  will map specific key combinations to the named actions in the registry.\n+  This will allow users to customize their keybindings.\n+- **A Keybinding Service:** A service will be responsible for reading the\n+  configuration file, listening for key presses, and invoking the appropriate\n+  callbacks from the registry.\n+\n+### **2. Plan**\n+\n+1. **Create the Keybinding Registry:**\n+   - Define a `Keybinding` interface with properties like `name`,\n+     `description`, `callback`, and `defaultKey`.\n+   - Implement a `KeybindingRegistry` class with methods to `register` and\n+     `get` keybindings.\n+   - The registry will be a singleton, accessible throughout the application.\n+\n+1. **Implement the Keybinding Service:**\n+   - Create a `KeybindingService` that reads the keybinding configuration from\n+     a file.\n+   - The service will use a single `useInput` hook at the top level of the",
        "comment_created_at": "2025-07-11T19:51:16+00:00",
        "comment_author": "jacob314",
        "comment_body": "this doesn't seem very algined with existing code with useInput calls throughout the application and InputPrompt that does its own non-ink standard keyboard processing. Given that I would suggest a solution that is lighter weight and instead allows callers to resolve whether specific input matches a specific keybinding rather than a solution that requires taking control of all useInput in the application.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2224315836",
    "pr_number": 4702,
    "pr_file": "docs/cli/commands.md",
    "created_at": "2025-07-23T04:28:42+00:00",
    "commented_code": "- `description` (String): A brief, one-line description of what the command does. This text will be displayed next to your command in the `/help` menu. **If you omit this field, a generic description will be generated from the filename.**\n \n+#### Handling Arguments\n+\n+Custom commands support two powerful, low-friction methods for handling arguments. The CLI automatically chooses the correct method based on the content of your command's `prompt`.\n+\n+##### 1. Shorthand Injection with `{{args}}`\n+\n+If your `prompt` contains the special placeholder `{{args}}`, the CLI will replace that exact placeholder with all the text the user typed after the command name. This is perfect for simple, deterministic commands where you need to inject user input into a specific place in a larger prompt template.\n+\n+**Example (`git/fix.toml`):**\n+\n+```toml\n+# In: ~/.gemini/commands/git/fix.toml\n+# Invoked via: /git:fix \"Button is misaligned on mobile\"\n+\n+description = \"Generates a fix for a given GitHub issue.\"\n+prompt = \"Please analyze the staged git changes and provide a code fix for the issue described here: {{args}}.\"\n+```\n+\n+The model will receive the final prompt: `Please analyze the staged git changes and provide a code fix for the issue described here: \"Button is misaligned on mobile\".`\n+\n+##### 2. Model-led Interpretation\n+\n+If your `prompt` does **not** contain `{{args}}`, the CLI assumes the model is smart enough to parse the arguments itself. It will prepend the _entire command the user typed_ to the top of your prompt, separated by a Markdown horizontal rule (`---`), providing the model with the full context to execute.",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2224315836",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4702,
        "pr_file": "docs/cli/commands.md",
        "discussion_id": "2224315836",
        "commented_code": "@@ -129,6 +129,65 @@ Your command definition files must be written in the TOML format and use the `.t\n \n - `description` (String): A brief, one-line description of what the command does. This text will be displayed next to your command in the `/help` menu. **If you omit this field, a generic description will be generated from the filename.**\n \n+#### Handling Arguments\n+\n+Custom commands support two powerful, low-friction methods for handling arguments. The CLI automatically chooses the correct method based on the content of your command's `prompt`.\n+\n+##### 1. Shorthand Injection with `{{args}}`\n+\n+If your `prompt` contains the special placeholder `{{args}}`, the CLI will replace that exact placeholder with all the text the user typed after the command name. This is perfect for simple, deterministic commands where you need to inject user input into a specific place in a larger prompt template.\n+\n+**Example (`git/fix.toml`):**\n+\n+```toml\n+# In: ~/.gemini/commands/git/fix.toml\n+# Invoked via: /git:fix \"Button is misaligned on mobile\"\n+\n+description = \"Generates a fix for a given GitHub issue.\"\n+prompt = \"Please analyze the staged git changes and provide a code fix for the issue described here: {{args}}.\"\n+```\n+\n+The model will receive the final prompt: `Please analyze the staged git changes and provide a code fix for the issue described here: \"Button is misaligned on mobile\".`\n+\n+##### 2. Model-led Interpretation\n+\n+If your `prompt` does **not** contain `{{args}}`, the CLI assumes the model is smart enough to parse the arguments itself. It will prepend the _entire command the user typed_ to the top of your prompt, separated by a Markdown horizontal rule (`---`), providing the model with the full context to execute.",
        "comment_created_at": "2025-07-23T04:28:42+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "the `---` separation piece is a bit arcane. What if we were to take the simple route and just append any content to the end? This way it feels more like a prompt where the template is there and any mutation to the invocation itself is seen as additional instructions after the primary template?\r\n\r\n```\r\n... The prompt ...\r\n... whatever was passed ...\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2225868013",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4702,
        "pr_file": "docs/cli/commands.md",
        "discussion_id": "2224315836",
        "commented_code": "@@ -129,6 +129,65 @@ Your command definition files must be written in the TOML format and use the `.t\n \n - `description` (String): A brief, one-line description of what the command does. This text will be displayed next to your command in the `/help` menu. **If you omit this field, a generic description will be generated from the filename.**\n \n+#### Handling Arguments\n+\n+Custom commands support two powerful, low-friction methods for handling arguments. The CLI automatically chooses the correct method based on the content of your command's `prompt`.\n+\n+##### 1. Shorthand Injection with `{{args}}`\n+\n+If your `prompt` contains the special placeholder `{{args}}`, the CLI will replace that exact placeholder with all the text the user typed after the command name. This is perfect for simple, deterministic commands where you need to inject user input into a specific place in a larger prompt template.\n+\n+**Example (`git/fix.toml`):**\n+\n+```toml\n+# In: ~/.gemini/commands/git/fix.toml\n+# Invoked via: /git:fix \"Button is misaligned on mobile\"\n+\n+description = \"Generates a fix for a given GitHub issue.\"\n+prompt = \"Please analyze the staged git changes and provide a code fix for the issue described here: {{args}}.\"\n+```\n+\n+The model will receive the final prompt: `Please analyze the staged git changes and provide a code fix for the issue described here: \"Button is misaligned on mobile\".`\n+\n+##### 2. Model-led Interpretation\n+\n+If your `prompt` does **not** contain `{{args}}`, the CLI assumes the model is smart enough to parse the arguments itself. It will prepend the _entire command the user typed_ to the top of your prompt, separated by a Markdown horizontal rule (`---`), providing the model with the full context to execute.",
        "comment_created_at": "2025-07-23T14:55:35+00:00",
        "comment_author": "abhipatel12",
        "comment_body": "Sounds good! Made changes to the doc and implementation.",
        "pr_file_module": null
      }
    ]
  }
]