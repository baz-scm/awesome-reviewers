[
  {
    "discussion_id": "2223984411",
    "pr_number": 3936,
    "pr_file": "packages/cli/src/ui/hooks/vim.ts",
    "created_at": "2025-07-22T23:02:13+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useState, useRef, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+/**\n+ * Vim hook that handles all vim mode functionality including:\n+ * - Mode switching between INSERT and NORMAL modes\n+ * - Navigation commands (h, j, k, l, w, b, e, 0, $, ^, g, G, I, A) with count support\n+ * - Editing commands (x, a, i, o, O, d, c, D, C) with count support\n+ * - Complex commands (dd, cc, dw, cw, db, cb, de, ce, gg, etc.)\n+ * - Repeat last command (.)\n+ * - Settings persistence (vim mode state survives app restart)\n+ * - Escape behavior (move cursor left when exiting INSERT mode, clear pending operations)\n+ * - Consolidated input handling to eliminate race conditions\n+ * - Direct handleInput exposure for integration with InputPrompt\n+ */\n+export function useVim(\n+  buffer: TextBuffer,\n+  config: { getVimMode(): boolean },\n+  settings: LoadedSettings,\n+  onSubmit?: (value: string) => void,\n+) {\n+  const [mode, setMode] = useState<VimMode>('NORMAL');\n+  const modeRef = useRef<VimMode>('NORMAL');\n+  const [count, setCount] = useState<number>(0);\n+  const [pendingG, setPendingG] = useState(false);\n+  const [pendingD, setPendingD] = useState(false);\n+  const [pendingC, setPendingC] = useState(false);\n+  const lastCommandRef = useRef<(() => void) | null>(null);\n+  const lastCommandDataRef = useRef<{ type: string; count: number } | null>(\n+    null,\n+  );\n+  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);\n+  const [runtimeVimModeOverride, setRuntimeVimModeOverride] = useState<\n+    boolean | null\n+  >(null);\n+\n+  // Keep mode ref in sync with state\n+  useEffect(() => {\n+    modeRef.current = mode;\n+  }, [mode]);\n+\n+  // Helper to update both state and ref immediately\n+  const setModeImmediate = useCallback((newMode: VimMode) => {\n+    modeRef.current = newMode;\n+    setMode(newMode);\n+  }, []);\n+\n+  const getCurrentCount = useCallback(() => count || 1, [count]);\n+\n+  const clearCount = useCallback(() => {\n+    setCount(0);\n+  }, []);\n+\n+  const findNextWordStart = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      if (i >= text.length) return i;\n+\n+      const currentChar = text[i];\n+\n+      // Skip current word/sequence based on character type\n+      if (/\\w/.test(currentChar)) {\n+        // Skip current word characters\n+        while (i < text.length && /\\w/.test(text[i])) {\n+          i++;\n+        }\n+      } else if (!/\\s/.test(currentChar)) {\n+        // Skip current non-word, non-whitespace characters (like \"/\", \".\", etc.)\n+        while (i < text.length && !/\\w/.test(text[i]) && !/\\s/.test(text[i])) {\n+          i++;\n+        }\n+      }\n+\n+      // Skip whitespace\n+      while (i < text.length && /\\s/.test(text[i])) {\n+        i++;\n+      }\n+\n+      // If we reached the end of text and there's no next word,\n+      // vim behavior for dw is to delete to the end of the current word\n+      if (i >= text.length) {\n+        // Go back to find the end of the last word\n+        let endOfLastWord = text.length - 1;\n+        while (endOfLastWord >= 0 && /\\s/.test(text[endOfLastWord])) {\n+          endOfLastWord--;\n+        }\n+        // For dw on last word, return position AFTER the last character to delete entire word\n+        return Math.max(currentOffset + 1, endOfLastWord + 1);\n+      }\n+\n+      return i;\n+    },\n+    [],\n+  );\n+\n+  const findPrevWordStart = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      // If at beginning of text, return current position\n+      if (i <= 0) {\n+        return currentOffset;\n+      }\n+\n+      // Move back one character to start searching\n+      i--;\n+\n+      // Skip whitespace moving backwards\n+      while (\n+        i >= 0 &&\n+        (text[i] === ' ' || text[i] === '\\t' || text[i] === '\n')\n+      ) {\n+        i--;\n+      }\n+\n+      if (i < 0) {\n+        return 0; // Reached beginning of text\n+      }\n+\n+      const charAtI = text[i];\n+\n+      if (/\\w/.test(charAtI)) {\n+        // We're in a word, move to its beginning\n+        while (i >= 0 && /\\w/.test(text[i])) {\n+          i--;\n+        }\n+        return i + 1; // Return first character of word\n+      } else {\n+        // We're in punctuation, move to its beginning\n+        while (\n+          i >= 0 &&\n+          !/\\w/.test(text[i]) &&\n+          text[i] !== ' ' &&\n+          text[i] !== '\\t' &&\n+          text[i] !== '\n'\n+        ) {\n+          i--;\n+        }\n+        return i + 1; // Return first character of punctuation sequence\n+      }\n+    },\n+    [],\n+  );\n+\n+  const findWordEnd = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      // If we're not on a word character, find the next word\n+      if (!/\\w/.test(text[i])) {\n+        while (i < text.length && !/\\w/.test(text[i])) {\n+          i++;\n+        }\n+      }\n+\n+      // Move to end of current word\n+      while (i < text.length && /\\w/.test(text[i])) {\n+        i++;\n+      }\n+\n+      // Move back one to be on the last character of the word\n+      return Math.max(currentOffset, i - 1);\n+    },\n+    [],\n+  );\n+\n+  const getCurrentOffset = useCallback(() => {\n+    const lines = buffer.lines;\n+    const [row, col] = buffer.cursor;\n+    let offset = 0;\n+\n+    for (let i = 0; i < row; i++) {\n+      offset += lines[i].length + 1; // +1 for newline\n+    }\n+    offset += col;\n+\n+    return offset;\n+  }, [buffer]);\n+\n+  const setOffsetPosition = useCallback(\n+    (offset: number) => {\n+      buffer.moveToOffset(offset);\n+    },\n+    [buffer],\n+  );\n+\n+  const getEffectiveVimMode = useCallback(\n+    () =>\n+      runtimeVimModeOverride !== null\n+        ? runtimeVimModeOverride\n+        : config.getVimMode(),\n+    [runtimeVimModeOverride, config],\n+  );\n+\n+  const toggleVimMode = useCallback(() => {\n+    const currentMode = getEffectiveVimMode();\n+    const newMode = !currentMode;\n+\n+    // Persist the new vim mode setting\n+    settings.setValue(SettingScope.User, 'vimMode', newMode);\n+\n+    // Update runtime override to reflect the change immediately\n+    setRuntimeVimModeOverride(newMode);\n+\n+    // If disabling vim mode while in INSERT, switch to NORMAL first\n+    if (currentMode && mode === 'INSERT') {\n+      setMode('NORMAL');\n+    }\n+  }, [getEffectiveVimMode, mode, settings]);\n+\n+  const handleInputRef = useRef<((key: Key) => boolean) | null>(null);\n+\n+  const handleInput = useCallback(\n+    (key: Key): boolean => {\n+      if (!getEffectiveVimMode()) {\n+        return false; // Let InputPrompt handle it\n+      }\n+\n+      // Clear any existing debounce timer\n+      if (debounceTimerRef.current !== null) {\n+        clearTimeout(debounceTimerRef.current as NodeJS.Timeout);\n+        debounceTimerRef.current = null;\n+      }\n+\n+      // Handle INSERT mode\n+      if (modeRef.current === 'INSERT') {\n+        // Handle escape key OR escape sequence (ESC+key pressed quickly)\n+        // Only treat as escape if:\n+        // 1. Actual escape key (key.name === 'escape'), OR\n+        // 2. Escape sequence that's NOT an arrow key or function key (doesn't start with \\u001b[)\n+        const isEscapeToNormal =\n+          key.name === 'escape' ||\n+          (key.sequence &&\n+            key.sequence.startsWith('\\u001b') &&\n+            !key.sequence.startsWith('\\u001b[') &&\n+            key.sequence.length > 1);\n+\n+        if (isEscapeToNormal) {\n+          // In vim, exiting INSERT mode moves cursor one position left\n+          // but only if cursor is at the end of the line (past the last character)\n+          const currentRow = buffer.cursor[0];\n+          const currentCol = buffer.cursor[1];\n+          const currentLine = buffer.lines[currentRow] || '';\n+\n+          // Only move left if cursor is at the end of the line (past the last character)\n+          if (currentCol > 0 && currentCol >= currentLine.length) {\n+            buffer.move('left');\n+          }\n+\n+          // Update both state and ref immediately\n+          setModeImmediate('NORMAL');\n+          clearCount();\n+          setPendingD(false);\n+          setPendingC(false);\n+          setPendingG(false);\n+\n+          // If this was an escape sequence (ESC+key), process the key part in NORMAL mode\n+          if (\n+            key.sequence &&\n+            key.sequence.startsWith('\\u001b') &&\n+            !key.sequence.startsWith('\\u001b[') &&\n+            key.sequence.length > 1\n+          ) {\n+            const remainingSequence = key.sequence.substring(1); // Remove the \\u001b part\n+            if (remainingSequence) {\n+              // Create a new key object for the remaining part\n+              const normalModeKey: Key = {\n+                name: remainingSequence.length === 1 ? '' : key.name,\n+                sequence: remainingSequence,\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: false,\n+              };\n+              // Process this key immediately in NORMAL mode by calling ourselves recursively\n+              return handleInputRef.current?.(normalModeKey) ?? false;\n+            } else {\n+              return true; // Just escape, nothing more to process\n+            }\n+          } else {\n+            return true; // Just escape, nothing more to process\n+          }\n+        }\n+\n+        // In INSERT mode, let InputPrompt handle completion keys and special commands\n+        if (\n+          key.name === 'tab' ||\n+          (key.name === 'return' && !key.ctrl) ||\n+          key.name === 'up' ||\n+          key.name === 'down'\n+        ) {\n+          return false; // Let InputPrompt handle completion\n+        }\n+\n+        // Let InputPrompt handle Ctrl+V for clipboard image pasting\n+        if (key.ctrl && key.name === 'v') {\n+          return false; // Let InputPrompt handle clipboard functionality\n+        }\n+\n+        // Special handling for Enter key to allow command submission (lower priority than completion)\n+        if (key.name === 'return' && !key.ctrl && !key.meta) {\n+          if (buffer.text.trim() && onSubmit) {\n+            // Handle command submission directly\n+            const submittedValue = buffer.text;\n+            buffer.setText('');\n+            onSubmit(submittedValue);\n+            return true;\n+          }\n+          return true; // Handled by vim (even if no onSubmit callback)\n+        }\n+\n+        // useKeypress already provides the correct format for TextBuffer\n+        buffer.handleInput(key);\n+        return true; // Handled by vim\n+      }\n+\n+      // Handle NORMAL mode\n+      if (modeRef.current === 'NORMAL') {\n+        // Handle Escape key in NORMAL mode - clear all pending states\n+        if (key.name === 'escape') {\n+          clearCount();\n+          setPendingD(false);\n+          setPendingC(false);\n+          setPendingG(false);\n+          return true; // Handled by vim\n+        }\n+\n+        // Handle count input (numbers 1-9, and 0 if count > 0)\n+        if (\n+          /^[1-9]$/.test(key.sequence) ||\n+          (key.sequence === '0' && count > 0)\n+        ) {\n+          setCount((prev) => prev * 10 + parseInt(key.sequence, 10));\n+          return true; // Handled by vim\n+        }\n+\n+        const repeatCount = getCurrentCount();\n+        const text = buffer.text;\n+        const currentOffset = getCurrentOffset();\n+\n+        switch (key.sequence) {\n+          case 'h': {\n+            // Check if this is part of a change command (ch)\n+            if (pendingC) {\n+              const commandRepeatCount = getCurrentCount();\n+              const executeChCommand = () => {\n+                // Change N characters to the left\n+                for (let i = 0; i < commandRepeatCount; i++) {\n+                  const _currentRow = buffer.cursor[0];\n+                  const currentCol = buffer.cursor[1];\n+                  if (currentCol > 0) {\n+                    buffer.move('left');\n+                    buffer.del();\n+                  }\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+\n+              clearCount();\n+              executeChCommand();\n+\n+              // Record this command for repeat\n+              lastCommandRef.current = executeChCommand;\n+              setPendingC(false);\n+              return true;\n+            }\n+\n+            // Normal left movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              const currentRow = buffer.cursor[0];\n+              const currentCol = buffer.cursor[1];\n+              if (currentCol > 0) {\n+                buffer.move('left');\n+              } else if (currentRow > 0) {\n+                // Move to end of previous line\n+                buffer.move('up');\n+                buffer.move('end');\n+              }\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'j': {\n+            // Check if this is part of a change command (cj)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change from current line down N lines\n+              const currentRow = buffer.cursor[0];\n+              const totalLines = buffer.lines.length;\n+              const linesToChange = Math.min(\n+                repeatCount + 1,\n+                totalLines - currentRow,\n+              ); // +1 to include current line\n+\n+              if (totalLines === 1) {\n+                // Single line - clear the content but keep the line\n+                const currentLine = buffer.lines[0] || '';\n+                buffer.replaceRangeByOffset(0, currentLine.length, '');\n+              } else {\n+                // Multi-line - change N lines including newlines\n+                let startOffset = 0;\n+                for (let row = 0; row < currentRow; row++) {\n+                  startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                }\n+\n+                let endOffset = startOffset;\n+                for (let i = 0; i < linesToChange; i++) {\n+                  if (currentRow + i < totalLines) {\n+                    endOffset += buffer.lines[currentRow + i].length;\n+                    if (currentRow + i < totalLines - 1) {\n+                      endOffset += 1; // +1 for newline, except for last line\n+                    }\n+                  }\n+                }\n+\n+                buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                const currentRow = buffer.cursor[0];\n+                const totalLines = buffer.lines.length;\n+                const linesToChange = Math.min(\n+                  commandRepeatCount + 1,\n+                  totalLines - currentRow,\n+                ); // +1 to include current line\n+\n+                if (totalLines === 1) {\n+                  // Single line - clear the content but keep the line\n+                  const currentLine = buffer.lines[0] || '';\n+                  buffer.replaceRangeByOffset(0, currentLine.length, '');\n+                } else {\n+                  // Multi-line - change N lines including newlines\n+                  let startOffset = 0;\n+                  for (let row = 0; row < currentRow; row++) {\n+                    startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                  }\n+\n+                  let endOffset = startOffset;\n+                  for (let i = 0; i < linesToChange; i++) {\n+                    if (currentRow + i < totalLines) {\n+                      endOffset += buffer.lines[currentRow + i].length;\n+                      if (currentRow + i < totalLines - 1) {\n+                        endOffset += 1; // +1 for newline, except for last line\n+                      }\n+                    }\n+                  }\n+\n+                  buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal down movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              buffer.move('down');\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'k': {\n+            // Check if this is part of a change command (ck)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change from current line up N lines\n+              const currentRow = buffer.cursor[0];\n+              const linesToChange = Math.min(repeatCount + 1, currentRow + 1); // +1 to include current line\n+              const startRow = currentRow - repeatCount;\n+\n+              if (buffer.lines.length === 1) {\n+                // Single line - clear the content but keep the line\n+                const currentLine = buffer.lines[0] || '';\n+                buffer.replaceRangeByOffset(0, currentLine.length, '');\n+              } else {\n+                // Multi-line - change N lines including newlines\n+                let startOffset = 0;\n+                for (let row = 0; row < Math.max(0, startRow); row++) {\n+                  startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                }\n+\n+                let endOffset = startOffset;\n+                for (let i = 0; i < linesToChange; i++) {\n+                  const rowIndex = Math.max(0, startRow) + i;\n+                  if (rowIndex < buffer.lines.length) {\n+                    endOffset += buffer.lines[rowIndex].length;\n+                    if (rowIndex < buffer.lines.length - 1) {\n+                      endOffset += 1; // +1 for newline, except for last line\n+                    }\n+                  }\n+                }\n+\n+                buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                // Move cursor to start of changed area\n+                buffer.moveToOffset(startOffset);\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                const currentRow = buffer.cursor[0];\n+                const linesToChange = Math.min(\n+                  commandRepeatCount + 1,\n+                  currentRow + 1,\n+                ); // +1 to include current line\n+                const startRow = currentRow - commandRepeatCount;\n+\n+                if (buffer.lines.length === 1) {\n+                  // Single line - clear the content but keep the line\n+                  const currentLine = buffer.lines[0] || '';\n+                  buffer.replaceRangeByOffset(0, currentLine.length, '');\n+                } else {\n+                  // Multi-line - change N lines including newlines\n+                  let startOffset = 0;\n+                  for (let row = 0; row < Math.max(0, startRow); row++) {\n+                    startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                  }\n+\n+                  let endOffset = startOffset;\n+                  for (let i = 0; i < linesToChange; i++) {\n+                    const lineIndex = Math.max(0, startRow) + i;\n+                    if (lineIndex < buffer.lines.length) {\n+                      endOffset += buffer.lines[lineIndex].length;\n+                      if (lineIndex < buffer.lines.length - 1) {\n+                        endOffset += 1; // +1 for newline\n+                      } else if (\n+                        Math.max(0, startRow) > 0 &&\n+                        lineIndex === buffer.lines.length - 1\n+                      ) {\n+                        // Last line - include the newline before it instead\n+                        startOffset -= 1;\n+                      }\n+                    }\n+                  }\n+\n+                  buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal up movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              buffer.move('up');\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'l': {\n+            // Check if this is part of a change command (cl)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change N characters to the right\n+              for (let i = 0; i < repeatCount; i++) {\n+                buffer.del();\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                // Change N characters to the right\n+                for (let i = 0; i < commandRepeatCount; i++) {\n+                  const currentRow = buffer.cursor[0];\n+                  const currentCol = buffer.cursor[1];\n+                  const currentLine = buffer.lines[currentRow] || '';\n+\n+                  if (currentCol < currentLine.length) {\n+                    buffer.del();\n+                  }\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal right movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              const currentRow = buffer.cursor[0];\n+              const currentCol = buffer.cursor[1];\n+              const currentLine = buffer.lines[currentRow] || '';\n+\n+              // Don't move past the last character of the line\n+              if (currentCol < currentLine.length - 1) {\n+                buffer.move('right');\n+              } else if (currentRow < buffer.lines.length - 1) {\n+                // Move to beginning of next line\n+                buffer.move('down');\n+                buffer.move('home');\n+              }\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'w': {\n+            // Check if this is part of a delete command (dw)\n+            if (pendingD) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              const text = buffer.text;\n+              const currentOffset = getCurrentOffset();\n+              let endOffset = currentOffset;\n+\n+              // Delete from cursor through N words using findNextWordStart for consistency\n+              let searchOffset = currentOffset;\n+              for (let i = 0; i < repeatCount; i++) {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2223984411",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2223984411",
        "commented_code": "@@ -0,0 +1,1571 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useState, useRef, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+/**\n+ * Vim hook that handles all vim mode functionality including:\n+ * - Mode switching between INSERT and NORMAL modes\n+ * - Navigation commands (h, j, k, l, w, b, e, 0, $, ^, g, G, I, A) with count support\n+ * - Editing commands (x, a, i, o, O, d, c, D, C) with count support\n+ * - Complex commands (dd, cc, dw, cw, db, cb, de, ce, gg, etc.)\n+ * - Repeat last command (.)\n+ * - Settings persistence (vim mode state survives app restart)\n+ * - Escape behavior (move cursor left when exiting INSERT mode, clear pending operations)\n+ * - Consolidated input handling to eliminate race conditions\n+ * - Direct handleInput exposure for integration with InputPrompt\n+ */\n+export function useVim(\n+  buffer: TextBuffer,\n+  config: { getVimMode(): boolean },\n+  settings: LoadedSettings,\n+  onSubmit?: (value: string) => void,\n+) {\n+  const [mode, setMode] = useState<VimMode>('NORMAL');\n+  const modeRef = useRef<VimMode>('NORMAL');\n+  const [count, setCount] = useState<number>(0);\n+  const [pendingG, setPendingG] = useState(false);\n+  const [pendingD, setPendingD] = useState(false);\n+  const [pendingC, setPendingC] = useState(false);\n+  const lastCommandRef = useRef<(() => void) | null>(null);\n+  const lastCommandDataRef = useRef<{ type: string; count: number } | null>(\n+    null,\n+  );\n+  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);\n+  const [runtimeVimModeOverride, setRuntimeVimModeOverride] = useState<\n+    boolean | null\n+  >(null);\n+\n+  // Keep mode ref in sync with state\n+  useEffect(() => {\n+    modeRef.current = mode;\n+  }, [mode]);\n+\n+  // Helper to update both state and ref immediately\n+  const setModeImmediate = useCallback((newMode: VimMode) => {\n+    modeRef.current = newMode;\n+    setMode(newMode);\n+  }, []);\n+\n+  const getCurrentCount = useCallback(() => count || 1, [count]);\n+\n+  const clearCount = useCallback(() => {\n+    setCount(0);\n+  }, []);\n+\n+  const findNextWordStart = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      if (i >= text.length) return i;\n+\n+      const currentChar = text[i];\n+\n+      // Skip current word/sequence based on character type\n+      if (/\\w/.test(currentChar)) {\n+        // Skip current word characters\n+        while (i < text.length && /\\w/.test(text[i])) {\n+          i++;\n+        }\n+      } else if (!/\\s/.test(currentChar)) {\n+        // Skip current non-word, non-whitespace characters (like \"/\", \".\", etc.)\n+        while (i < text.length && !/\\w/.test(text[i]) && !/\\s/.test(text[i])) {\n+          i++;\n+        }\n+      }\n+\n+      // Skip whitespace\n+      while (i < text.length && /\\s/.test(text[i])) {\n+        i++;\n+      }\n+\n+      // If we reached the end of text and there's no next word,\n+      // vim behavior for dw is to delete to the end of the current word\n+      if (i >= text.length) {\n+        // Go back to find the end of the last word\n+        let endOfLastWord = text.length - 1;\n+        while (endOfLastWord >= 0 && /\\s/.test(text[endOfLastWord])) {\n+          endOfLastWord--;\n+        }\n+        // For dw on last word, return position AFTER the last character to delete entire word\n+        return Math.max(currentOffset + 1, endOfLastWord + 1);\n+      }\n+\n+      return i;\n+    },\n+    [],\n+  );\n+\n+  const findPrevWordStart = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      // If at beginning of text, return current position\n+      if (i <= 0) {\n+        return currentOffset;\n+      }\n+\n+      // Move back one character to start searching\n+      i--;\n+\n+      // Skip whitespace moving backwards\n+      while (\n+        i >= 0 &&\n+        (text[i] === ' ' || text[i] === '\\t' || text[i] === '\\n')\n+      ) {\n+        i--;\n+      }\n+\n+      if (i < 0) {\n+        return 0; // Reached beginning of text\n+      }\n+\n+      const charAtI = text[i];\n+\n+      if (/\\w/.test(charAtI)) {\n+        // We're in a word, move to its beginning\n+        while (i >= 0 && /\\w/.test(text[i])) {\n+          i--;\n+        }\n+        return i + 1; // Return first character of word\n+      } else {\n+        // We're in punctuation, move to its beginning\n+        while (\n+          i >= 0 &&\n+          !/\\w/.test(text[i]) &&\n+          text[i] !== ' ' &&\n+          text[i] !== '\\t' &&\n+          text[i] !== '\\n'\n+        ) {\n+          i--;\n+        }\n+        return i + 1; // Return first character of punctuation sequence\n+      }\n+    },\n+    [],\n+  );\n+\n+  const findWordEnd = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      // If we're not on a word character, find the next word\n+      if (!/\\w/.test(text[i])) {\n+        while (i < text.length && !/\\w/.test(text[i])) {\n+          i++;\n+        }\n+      }\n+\n+      // Move to end of current word\n+      while (i < text.length && /\\w/.test(text[i])) {\n+        i++;\n+      }\n+\n+      // Move back one to be on the last character of the word\n+      return Math.max(currentOffset, i - 1);\n+    },\n+    [],\n+  );\n+\n+  const getCurrentOffset = useCallback(() => {\n+    const lines = buffer.lines;\n+    const [row, col] = buffer.cursor;\n+    let offset = 0;\n+\n+    for (let i = 0; i < row; i++) {\n+      offset += lines[i].length + 1; // +1 for newline\n+    }\n+    offset += col;\n+\n+    return offset;\n+  }, [buffer]);\n+\n+  const setOffsetPosition = useCallback(\n+    (offset: number) => {\n+      buffer.moveToOffset(offset);\n+    },\n+    [buffer],\n+  );\n+\n+  const getEffectiveVimMode = useCallback(\n+    () =>\n+      runtimeVimModeOverride !== null\n+        ? runtimeVimModeOverride\n+        : config.getVimMode(),\n+    [runtimeVimModeOverride, config],\n+  );\n+\n+  const toggleVimMode = useCallback(() => {\n+    const currentMode = getEffectiveVimMode();\n+    const newMode = !currentMode;\n+\n+    // Persist the new vim mode setting\n+    settings.setValue(SettingScope.User, 'vimMode', newMode);\n+\n+    // Update runtime override to reflect the change immediately\n+    setRuntimeVimModeOverride(newMode);\n+\n+    // If disabling vim mode while in INSERT, switch to NORMAL first\n+    if (currentMode && mode === 'INSERT') {\n+      setMode('NORMAL');\n+    }\n+  }, [getEffectiveVimMode, mode, settings]);\n+\n+  const handleInputRef = useRef<((key: Key) => boolean) | null>(null);\n+\n+  const handleInput = useCallback(\n+    (key: Key): boolean => {\n+      if (!getEffectiveVimMode()) {\n+        return false; // Let InputPrompt handle it\n+      }\n+\n+      // Clear any existing debounce timer\n+      if (debounceTimerRef.current !== null) {\n+        clearTimeout(debounceTimerRef.current as NodeJS.Timeout);\n+        debounceTimerRef.current = null;\n+      }\n+\n+      // Handle INSERT mode\n+      if (modeRef.current === 'INSERT') {\n+        // Handle escape key OR escape sequence (ESC+key pressed quickly)\n+        // Only treat as escape if:\n+        // 1. Actual escape key (key.name === 'escape'), OR\n+        // 2. Escape sequence that's NOT an arrow key or function key (doesn't start with \\u001b[)\n+        const isEscapeToNormal =\n+          key.name === 'escape' ||\n+          (key.sequence &&\n+            key.sequence.startsWith('\\u001b') &&\n+            !key.sequence.startsWith('\\u001b[') &&\n+            key.sequence.length > 1);\n+\n+        if (isEscapeToNormal) {\n+          // In vim, exiting INSERT mode moves cursor one position left\n+          // but only if cursor is at the end of the line (past the last character)\n+          const currentRow = buffer.cursor[0];\n+          const currentCol = buffer.cursor[1];\n+          const currentLine = buffer.lines[currentRow] || '';\n+\n+          // Only move left if cursor is at the end of the line (past the last character)\n+          if (currentCol > 0 && currentCol >= currentLine.length) {\n+            buffer.move('left');\n+          }\n+\n+          // Update both state and ref immediately\n+          setModeImmediate('NORMAL');\n+          clearCount();\n+          setPendingD(false);\n+          setPendingC(false);\n+          setPendingG(false);\n+\n+          // If this was an escape sequence (ESC+key), process the key part in NORMAL mode\n+          if (\n+            key.sequence &&\n+            key.sequence.startsWith('\\u001b') &&\n+            !key.sequence.startsWith('\\u001b[') &&\n+            key.sequence.length > 1\n+          ) {\n+            const remainingSequence = key.sequence.substring(1); // Remove the \\u001b part\n+            if (remainingSequence) {\n+              // Create a new key object for the remaining part\n+              const normalModeKey: Key = {\n+                name: remainingSequence.length === 1 ? '' : key.name,\n+                sequence: remainingSequence,\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: false,\n+              };\n+              // Process this key immediately in NORMAL mode by calling ourselves recursively\n+              return handleInputRef.current?.(normalModeKey) ?? false;\n+            } else {\n+              return true; // Just escape, nothing more to process\n+            }\n+          } else {\n+            return true; // Just escape, nothing more to process\n+          }\n+        }\n+\n+        // In INSERT mode, let InputPrompt handle completion keys and special commands\n+        if (\n+          key.name === 'tab' ||\n+          (key.name === 'return' && !key.ctrl) ||\n+          key.name === 'up' ||\n+          key.name === 'down'\n+        ) {\n+          return false; // Let InputPrompt handle completion\n+        }\n+\n+        // Let InputPrompt handle Ctrl+V for clipboard image pasting\n+        if (key.ctrl && key.name === 'v') {\n+          return false; // Let InputPrompt handle clipboard functionality\n+        }\n+\n+        // Special handling for Enter key to allow command submission (lower priority than completion)\n+        if (key.name === 'return' && !key.ctrl && !key.meta) {\n+          if (buffer.text.trim() && onSubmit) {\n+            // Handle command submission directly\n+            const submittedValue = buffer.text;\n+            buffer.setText('');\n+            onSubmit(submittedValue);\n+            return true;\n+          }\n+          return true; // Handled by vim (even if no onSubmit callback)\n+        }\n+\n+        // useKeypress already provides the correct format for TextBuffer\n+        buffer.handleInput(key);\n+        return true; // Handled by vim\n+      }\n+\n+      // Handle NORMAL mode\n+      if (modeRef.current === 'NORMAL') {\n+        // Handle Escape key in NORMAL mode - clear all pending states\n+        if (key.name === 'escape') {\n+          clearCount();\n+          setPendingD(false);\n+          setPendingC(false);\n+          setPendingG(false);\n+          return true; // Handled by vim\n+        }\n+\n+        // Handle count input (numbers 1-9, and 0 if count > 0)\n+        if (\n+          /^[1-9]$/.test(key.sequence) ||\n+          (key.sequence === '0' && count > 0)\n+        ) {\n+          setCount((prev) => prev * 10 + parseInt(key.sequence, 10));\n+          return true; // Handled by vim\n+        }\n+\n+        const repeatCount = getCurrentCount();\n+        const text = buffer.text;\n+        const currentOffset = getCurrentOffset();\n+\n+        switch (key.sequence) {\n+          case 'h': {\n+            // Check if this is part of a change command (ch)\n+            if (pendingC) {\n+              const commandRepeatCount = getCurrentCount();\n+              const executeChCommand = () => {\n+                // Change N characters to the left\n+                for (let i = 0; i < commandRepeatCount; i++) {\n+                  const _currentRow = buffer.cursor[0];\n+                  const currentCol = buffer.cursor[1];\n+                  if (currentCol > 0) {\n+                    buffer.move('left');\n+                    buffer.del();\n+                  }\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+\n+              clearCount();\n+              executeChCommand();\n+\n+              // Record this command for repeat\n+              lastCommandRef.current = executeChCommand;\n+              setPendingC(false);\n+              return true;\n+            }\n+\n+            // Normal left movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              const currentRow = buffer.cursor[0];\n+              const currentCol = buffer.cursor[1];\n+              if (currentCol > 0) {\n+                buffer.move('left');\n+              } else if (currentRow > 0) {\n+                // Move to end of previous line\n+                buffer.move('up');\n+                buffer.move('end');\n+              }\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'j': {\n+            // Check if this is part of a change command (cj)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change from current line down N lines\n+              const currentRow = buffer.cursor[0];\n+              const totalLines = buffer.lines.length;\n+              const linesToChange = Math.min(\n+                repeatCount + 1,\n+                totalLines - currentRow,\n+              ); // +1 to include current line\n+\n+              if (totalLines === 1) {\n+                // Single line - clear the content but keep the line\n+                const currentLine = buffer.lines[0] || '';\n+                buffer.replaceRangeByOffset(0, currentLine.length, '');\n+              } else {\n+                // Multi-line - change N lines including newlines\n+                let startOffset = 0;\n+                for (let row = 0; row < currentRow; row++) {\n+                  startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                }\n+\n+                let endOffset = startOffset;\n+                for (let i = 0; i < linesToChange; i++) {\n+                  if (currentRow + i < totalLines) {\n+                    endOffset += buffer.lines[currentRow + i].length;\n+                    if (currentRow + i < totalLines - 1) {\n+                      endOffset += 1; // +1 for newline, except for last line\n+                    }\n+                  }\n+                }\n+\n+                buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                const currentRow = buffer.cursor[0];\n+                const totalLines = buffer.lines.length;\n+                const linesToChange = Math.min(\n+                  commandRepeatCount + 1,\n+                  totalLines - currentRow,\n+                ); // +1 to include current line\n+\n+                if (totalLines === 1) {\n+                  // Single line - clear the content but keep the line\n+                  const currentLine = buffer.lines[0] || '';\n+                  buffer.replaceRangeByOffset(0, currentLine.length, '');\n+                } else {\n+                  // Multi-line - change N lines including newlines\n+                  let startOffset = 0;\n+                  for (let row = 0; row < currentRow; row++) {\n+                    startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                  }\n+\n+                  let endOffset = startOffset;\n+                  for (let i = 0; i < linesToChange; i++) {\n+                    if (currentRow + i < totalLines) {\n+                      endOffset += buffer.lines[currentRow + i].length;\n+                      if (currentRow + i < totalLines - 1) {\n+                        endOffset += 1; // +1 for newline, except for last line\n+                      }\n+                    }\n+                  }\n+\n+                  buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal down movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              buffer.move('down');\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'k': {\n+            // Check if this is part of a change command (ck)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change from current line up N lines\n+              const currentRow = buffer.cursor[0];\n+              const linesToChange = Math.min(repeatCount + 1, currentRow + 1); // +1 to include current line\n+              const startRow = currentRow - repeatCount;\n+\n+              if (buffer.lines.length === 1) {\n+                // Single line - clear the content but keep the line\n+                const currentLine = buffer.lines[0] || '';\n+                buffer.replaceRangeByOffset(0, currentLine.length, '');\n+              } else {\n+                // Multi-line - change N lines including newlines\n+                let startOffset = 0;\n+                for (let row = 0; row < Math.max(0, startRow); row++) {\n+                  startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                }\n+\n+                let endOffset = startOffset;\n+                for (let i = 0; i < linesToChange; i++) {\n+                  const rowIndex = Math.max(0, startRow) + i;\n+                  if (rowIndex < buffer.lines.length) {\n+                    endOffset += buffer.lines[rowIndex].length;\n+                    if (rowIndex < buffer.lines.length - 1) {\n+                      endOffset += 1; // +1 for newline, except for last line\n+                    }\n+                  }\n+                }\n+\n+                buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                // Move cursor to start of changed area\n+                buffer.moveToOffset(startOffset);\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                const currentRow = buffer.cursor[0];\n+                const linesToChange = Math.min(\n+                  commandRepeatCount + 1,\n+                  currentRow + 1,\n+                ); // +1 to include current line\n+                const startRow = currentRow - commandRepeatCount;\n+\n+                if (buffer.lines.length === 1) {\n+                  // Single line - clear the content but keep the line\n+                  const currentLine = buffer.lines[0] || '';\n+                  buffer.replaceRangeByOffset(0, currentLine.length, '');\n+                } else {\n+                  // Multi-line - change N lines including newlines\n+                  let startOffset = 0;\n+                  for (let row = 0; row < Math.max(0, startRow); row++) {\n+                    startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                  }\n+\n+                  let endOffset = startOffset;\n+                  for (let i = 0; i < linesToChange; i++) {\n+                    const lineIndex = Math.max(0, startRow) + i;\n+                    if (lineIndex < buffer.lines.length) {\n+                      endOffset += buffer.lines[lineIndex].length;\n+                      if (lineIndex < buffer.lines.length - 1) {\n+                        endOffset += 1; // +1 for newline\n+                      } else if (\n+                        Math.max(0, startRow) > 0 &&\n+                        lineIndex === buffer.lines.length - 1\n+                      ) {\n+                        // Last line - include the newline before it instead\n+                        startOffset -= 1;\n+                      }\n+                    }\n+                  }\n+\n+                  buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal up movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              buffer.move('up');\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'l': {\n+            // Check if this is part of a change command (cl)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change N characters to the right\n+              for (let i = 0; i < repeatCount; i++) {\n+                buffer.del();\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                // Change N characters to the right\n+                for (let i = 0; i < commandRepeatCount; i++) {\n+                  const currentRow = buffer.cursor[0];\n+                  const currentCol = buffer.cursor[1];\n+                  const currentLine = buffer.lines[currentRow] || '';\n+\n+                  if (currentCol < currentLine.length) {\n+                    buffer.del();\n+                  }\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal right movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              const currentRow = buffer.cursor[0];\n+              const currentCol = buffer.cursor[1];\n+              const currentLine = buffer.lines[currentRow] || '';\n+\n+              // Don't move past the last character of the line\n+              if (currentCol < currentLine.length - 1) {\n+                buffer.move('right');\n+              } else if (currentRow < buffer.lines.length - 1) {\n+                // Move to beginning of next line\n+                buffer.move('down');\n+                buffer.move('home');\n+              }\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'w': {\n+            // Check if this is part of a delete command (dw)\n+            if (pendingD) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              const text = buffer.text;\n+              const currentOffset = getCurrentOffset();\n+              let endOffset = currentOffset;\n+\n+              // Delete from cursor through N words using findNextWordStart for consistency\n+              let searchOffset = currentOffset;\n+              for (let i = 0; i < repeatCount; i++) {",
        "comment_created_at": "2025-07-22T23:02:13+00:00",
        "comment_author": "jacob314",
        "comment_body": "this logic is not safe to perform here. instead use the existing api in text-buffer.ts or create one. that. is crucial to make sure this logic runs inside the reducer in text-buffer that ensures commands are executed properly and in order even when multiple key strokes are executed in the same react loop. the same concern applies to all of the other cases here that modify the state of the text. buffer. they need to instead call a method on text-buffer.ts to apply the transformation desired rather than reading the possibly stale state of the text buffer and performing operations on it.\nsorry this part of how text-buffer works is a little surprising but it is better than the alternatives where it becomes really difficult to be confident that react is dealing with the correct state.",
        "pr_file_module": null
      },
      {
        "comment_id": "2224805973",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2223984411",
        "commented_code": "@@ -0,0 +1,1571 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useState, useRef, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+/**\n+ * Vim hook that handles all vim mode functionality including:\n+ * - Mode switching between INSERT and NORMAL modes\n+ * - Navigation commands (h, j, k, l, w, b, e, 0, $, ^, g, G, I, A) with count support\n+ * - Editing commands (x, a, i, o, O, d, c, D, C) with count support\n+ * - Complex commands (dd, cc, dw, cw, db, cb, de, ce, gg, etc.)\n+ * - Repeat last command (.)\n+ * - Settings persistence (vim mode state survives app restart)\n+ * - Escape behavior (move cursor left when exiting INSERT mode, clear pending operations)\n+ * - Consolidated input handling to eliminate race conditions\n+ * - Direct handleInput exposure for integration with InputPrompt\n+ */\n+export function useVim(\n+  buffer: TextBuffer,\n+  config: { getVimMode(): boolean },\n+  settings: LoadedSettings,\n+  onSubmit?: (value: string) => void,\n+) {\n+  const [mode, setMode] = useState<VimMode>('NORMAL');\n+  const modeRef = useRef<VimMode>('NORMAL');\n+  const [count, setCount] = useState<number>(0);\n+  const [pendingG, setPendingG] = useState(false);\n+  const [pendingD, setPendingD] = useState(false);\n+  const [pendingC, setPendingC] = useState(false);\n+  const lastCommandRef = useRef<(() => void) | null>(null);\n+  const lastCommandDataRef = useRef<{ type: string; count: number } | null>(\n+    null,\n+  );\n+  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);\n+  const [runtimeVimModeOverride, setRuntimeVimModeOverride] = useState<\n+    boolean | null\n+  >(null);\n+\n+  // Keep mode ref in sync with state\n+  useEffect(() => {\n+    modeRef.current = mode;\n+  }, [mode]);\n+\n+  // Helper to update both state and ref immediately\n+  const setModeImmediate = useCallback((newMode: VimMode) => {\n+    modeRef.current = newMode;\n+    setMode(newMode);\n+  }, []);\n+\n+  const getCurrentCount = useCallback(() => count || 1, [count]);\n+\n+  const clearCount = useCallback(() => {\n+    setCount(0);\n+  }, []);\n+\n+  const findNextWordStart = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      if (i >= text.length) return i;\n+\n+      const currentChar = text[i];\n+\n+      // Skip current word/sequence based on character type\n+      if (/\\w/.test(currentChar)) {\n+        // Skip current word characters\n+        while (i < text.length && /\\w/.test(text[i])) {\n+          i++;\n+        }\n+      } else if (!/\\s/.test(currentChar)) {\n+        // Skip current non-word, non-whitespace characters (like \"/\", \".\", etc.)\n+        while (i < text.length && !/\\w/.test(text[i]) && !/\\s/.test(text[i])) {\n+          i++;\n+        }\n+      }\n+\n+      // Skip whitespace\n+      while (i < text.length && /\\s/.test(text[i])) {\n+        i++;\n+      }\n+\n+      // If we reached the end of text and there's no next word,\n+      // vim behavior for dw is to delete to the end of the current word\n+      if (i >= text.length) {\n+        // Go back to find the end of the last word\n+        let endOfLastWord = text.length - 1;\n+        while (endOfLastWord >= 0 && /\\s/.test(text[endOfLastWord])) {\n+          endOfLastWord--;\n+        }\n+        // For dw on last word, return position AFTER the last character to delete entire word\n+        return Math.max(currentOffset + 1, endOfLastWord + 1);\n+      }\n+\n+      return i;\n+    },\n+    [],\n+  );\n+\n+  const findPrevWordStart = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      // If at beginning of text, return current position\n+      if (i <= 0) {\n+        return currentOffset;\n+      }\n+\n+      // Move back one character to start searching\n+      i--;\n+\n+      // Skip whitespace moving backwards\n+      while (\n+        i >= 0 &&\n+        (text[i] === ' ' || text[i] === '\\t' || text[i] === '\\n')\n+      ) {\n+        i--;\n+      }\n+\n+      if (i < 0) {\n+        return 0; // Reached beginning of text\n+      }\n+\n+      const charAtI = text[i];\n+\n+      if (/\\w/.test(charAtI)) {\n+        // We're in a word, move to its beginning\n+        while (i >= 0 && /\\w/.test(text[i])) {\n+          i--;\n+        }\n+        return i + 1; // Return first character of word\n+      } else {\n+        // We're in punctuation, move to its beginning\n+        while (\n+          i >= 0 &&\n+          !/\\w/.test(text[i]) &&\n+          text[i] !== ' ' &&\n+          text[i] !== '\\t' &&\n+          text[i] !== '\\n'\n+        ) {\n+          i--;\n+        }\n+        return i + 1; // Return first character of punctuation sequence\n+      }\n+    },\n+    [],\n+  );\n+\n+  const findWordEnd = useCallback(\n+    (text: string, currentOffset: number): number => {\n+      let i = currentOffset;\n+\n+      // If we're not on a word character, find the next word\n+      if (!/\\w/.test(text[i])) {\n+        while (i < text.length && !/\\w/.test(text[i])) {\n+          i++;\n+        }\n+      }\n+\n+      // Move to end of current word\n+      while (i < text.length && /\\w/.test(text[i])) {\n+        i++;\n+      }\n+\n+      // Move back one to be on the last character of the word\n+      return Math.max(currentOffset, i - 1);\n+    },\n+    [],\n+  );\n+\n+  const getCurrentOffset = useCallback(() => {\n+    const lines = buffer.lines;\n+    const [row, col] = buffer.cursor;\n+    let offset = 0;\n+\n+    for (let i = 0; i < row; i++) {\n+      offset += lines[i].length + 1; // +1 for newline\n+    }\n+    offset += col;\n+\n+    return offset;\n+  }, [buffer]);\n+\n+  const setOffsetPosition = useCallback(\n+    (offset: number) => {\n+      buffer.moveToOffset(offset);\n+    },\n+    [buffer],\n+  );\n+\n+  const getEffectiveVimMode = useCallback(\n+    () =>\n+      runtimeVimModeOverride !== null\n+        ? runtimeVimModeOverride\n+        : config.getVimMode(),\n+    [runtimeVimModeOverride, config],\n+  );\n+\n+  const toggleVimMode = useCallback(() => {\n+    const currentMode = getEffectiveVimMode();\n+    const newMode = !currentMode;\n+\n+    // Persist the new vim mode setting\n+    settings.setValue(SettingScope.User, 'vimMode', newMode);\n+\n+    // Update runtime override to reflect the change immediately\n+    setRuntimeVimModeOverride(newMode);\n+\n+    // If disabling vim mode while in INSERT, switch to NORMAL first\n+    if (currentMode && mode === 'INSERT') {\n+      setMode('NORMAL');\n+    }\n+  }, [getEffectiveVimMode, mode, settings]);\n+\n+  const handleInputRef = useRef<((key: Key) => boolean) | null>(null);\n+\n+  const handleInput = useCallback(\n+    (key: Key): boolean => {\n+      if (!getEffectiveVimMode()) {\n+        return false; // Let InputPrompt handle it\n+      }\n+\n+      // Clear any existing debounce timer\n+      if (debounceTimerRef.current !== null) {\n+        clearTimeout(debounceTimerRef.current as NodeJS.Timeout);\n+        debounceTimerRef.current = null;\n+      }\n+\n+      // Handle INSERT mode\n+      if (modeRef.current === 'INSERT') {\n+        // Handle escape key OR escape sequence (ESC+key pressed quickly)\n+        // Only treat as escape if:\n+        // 1. Actual escape key (key.name === 'escape'), OR\n+        // 2. Escape sequence that's NOT an arrow key or function key (doesn't start with \\u001b[)\n+        const isEscapeToNormal =\n+          key.name === 'escape' ||\n+          (key.sequence &&\n+            key.sequence.startsWith('\\u001b') &&\n+            !key.sequence.startsWith('\\u001b[') &&\n+            key.sequence.length > 1);\n+\n+        if (isEscapeToNormal) {\n+          // In vim, exiting INSERT mode moves cursor one position left\n+          // but only if cursor is at the end of the line (past the last character)\n+          const currentRow = buffer.cursor[0];\n+          const currentCol = buffer.cursor[1];\n+          const currentLine = buffer.lines[currentRow] || '';\n+\n+          // Only move left if cursor is at the end of the line (past the last character)\n+          if (currentCol > 0 && currentCol >= currentLine.length) {\n+            buffer.move('left');\n+          }\n+\n+          // Update both state and ref immediately\n+          setModeImmediate('NORMAL');\n+          clearCount();\n+          setPendingD(false);\n+          setPendingC(false);\n+          setPendingG(false);\n+\n+          // If this was an escape sequence (ESC+key), process the key part in NORMAL mode\n+          if (\n+            key.sequence &&\n+            key.sequence.startsWith('\\u001b') &&\n+            !key.sequence.startsWith('\\u001b[') &&\n+            key.sequence.length > 1\n+          ) {\n+            const remainingSequence = key.sequence.substring(1); // Remove the \\u001b part\n+            if (remainingSequence) {\n+              // Create a new key object for the remaining part\n+              const normalModeKey: Key = {\n+                name: remainingSequence.length === 1 ? '' : key.name,\n+                sequence: remainingSequence,\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: false,\n+              };\n+              // Process this key immediately in NORMAL mode by calling ourselves recursively\n+              return handleInputRef.current?.(normalModeKey) ?? false;\n+            } else {\n+              return true; // Just escape, nothing more to process\n+            }\n+          } else {\n+            return true; // Just escape, nothing more to process\n+          }\n+        }\n+\n+        // In INSERT mode, let InputPrompt handle completion keys and special commands\n+        if (\n+          key.name === 'tab' ||\n+          (key.name === 'return' && !key.ctrl) ||\n+          key.name === 'up' ||\n+          key.name === 'down'\n+        ) {\n+          return false; // Let InputPrompt handle completion\n+        }\n+\n+        // Let InputPrompt handle Ctrl+V for clipboard image pasting\n+        if (key.ctrl && key.name === 'v') {\n+          return false; // Let InputPrompt handle clipboard functionality\n+        }\n+\n+        // Special handling for Enter key to allow command submission (lower priority than completion)\n+        if (key.name === 'return' && !key.ctrl && !key.meta) {\n+          if (buffer.text.trim() && onSubmit) {\n+            // Handle command submission directly\n+            const submittedValue = buffer.text;\n+            buffer.setText('');\n+            onSubmit(submittedValue);\n+            return true;\n+          }\n+          return true; // Handled by vim (even if no onSubmit callback)\n+        }\n+\n+        // useKeypress already provides the correct format for TextBuffer\n+        buffer.handleInput(key);\n+        return true; // Handled by vim\n+      }\n+\n+      // Handle NORMAL mode\n+      if (modeRef.current === 'NORMAL') {\n+        // Handle Escape key in NORMAL mode - clear all pending states\n+        if (key.name === 'escape') {\n+          clearCount();\n+          setPendingD(false);\n+          setPendingC(false);\n+          setPendingG(false);\n+          return true; // Handled by vim\n+        }\n+\n+        // Handle count input (numbers 1-9, and 0 if count > 0)\n+        if (\n+          /^[1-9]$/.test(key.sequence) ||\n+          (key.sequence === '0' && count > 0)\n+        ) {\n+          setCount((prev) => prev * 10 + parseInt(key.sequence, 10));\n+          return true; // Handled by vim\n+        }\n+\n+        const repeatCount = getCurrentCount();\n+        const text = buffer.text;\n+        const currentOffset = getCurrentOffset();\n+\n+        switch (key.sequence) {\n+          case 'h': {\n+            // Check if this is part of a change command (ch)\n+            if (pendingC) {\n+              const commandRepeatCount = getCurrentCount();\n+              const executeChCommand = () => {\n+                // Change N characters to the left\n+                for (let i = 0; i < commandRepeatCount; i++) {\n+                  const _currentRow = buffer.cursor[0];\n+                  const currentCol = buffer.cursor[1];\n+                  if (currentCol > 0) {\n+                    buffer.move('left');\n+                    buffer.del();\n+                  }\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+\n+              clearCount();\n+              executeChCommand();\n+\n+              // Record this command for repeat\n+              lastCommandRef.current = executeChCommand;\n+              setPendingC(false);\n+              return true;\n+            }\n+\n+            // Normal left movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              const currentRow = buffer.cursor[0];\n+              const currentCol = buffer.cursor[1];\n+              if (currentCol > 0) {\n+                buffer.move('left');\n+              } else if (currentRow > 0) {\n+                // Move to end of previous line\n+                buffer.move('up');\n+                buffer.move('end');\n+              }\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'j': {\n+            // Check if this is part of a change command (cj)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change from current line down N lines\n+              const currentRow = buffer.cursor[0];\n+              const totalLines = buffer.lines.length;\n+              const linesToChange = Math.min(\n+                repeatCount + 1,\n+                totalLines - currentRow,\n+              ); // +1 to include current line\n+\n+              if (totalLines === 1) {\n+                // Single line - clear the content but keep the line\n+                const currentLine = buffer.lines[0] || '';\n+                buffer.replaceRangeByOffset(0, currentLine.length, '');\n+              } else {\n+                // Multi-line - change N lines including newlines\n+                let startOffset = 0;\n+                for (let row = 0; row < currentRow; row++) {\n+                  startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                }\n+\n+                let endOffset = startOffset;\n+                for (let i = 0; i < linesToChange; i++) {\n+                  if (currentRow + i < totalLines) {\n+                    endOffset += buffer.lines[currentRow + i].length;\n+                    if (currentRow + i < totalLines - 1) {\n+                      endOffset += 1; // +1 for newline, except for last line\n+                    }\n+                  }\n+                }\n+\n+                buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                const currentRow = buffer.cursor[0];\n+                const totalLines = buffer.lines.length;\n+                const linesToChange = Math.min(\n+                  commandRepeatCount + 1,\n+                  totalLines - currentRow,\n+                ); // +1 to include current line\n+\n+                if (totalLines === 1) {\n+                  // Single line - clear the content but keep the line\n+                  const currentLine = buffer.lines[0] || '';\n+                  buffer.replaceRangeByOffset(0, currentLine.length, '');\n+                } else {\n+                  // Multi-line - change N lines including newlines\n+                  let startOffset = 0;\n+                  for (let row = 0; row < currentRow; row++) {\n+                    startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                  }\n+\n+                  let endOffset = startOffset;\n+                  for (let i = 0; i < linesToChange; i++) {\n+                    if (currentRow + i < totalLines) {\n+                      endOffset += buffer.lines[currentRow + i].length;\n+                      if (currentRow + i < totalLines - 1) {\n+                        endOffset += 1; // +1 for newline, except for last line\n+                      }\n+                    }\n+                  }\n+\n+                  buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal down movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              buffer.move('down');\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'k': {\n+            // Check if this is part of a change command (ck)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change from current line up N lines\n+              const currentRow = buffer.cursor[0];\n+              const linesToChange = Math.min(repeatCount + 1, currentRow + 1); // +1 to include current line\n+              const startRow = currentRow - repeatCount;\n+\n+              if (buffer.lines.length === 1) {\n+                // Single line - clear the content but keep the line\n+                const currentLine = buffer.lines[0] || '';\n+                buffer.replaceRangeByOffset(0, currentLine.length, '');\n+              } else {\n+                // Multi-line - change N lines including newlines\n+                let startOffset = 0;\n+                for (let row = 0; row < Math.max(0, startRow); row++) {\n+                  startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                }\n+\n+                let endOffset = startOffset;\n+                for (let i = 0; i < linesToChange; i++) {\n+                  const rowIndex = Math.max(0, startRow) + i;\n+                  if (rowIndex < buffer.lines.length) {\n+                    endOffset += buffer.lines[rowIndex].length;\n+                    if (rowIndex < buffer.lines.length - 1) {\n+                      endOffset += 1; // +1 for newline, except for last line\n+                    }\n+                  }\n+                }\n+\n+                buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                // Move cursor to start of changed area\n+                buffer.moveToOffset(startOffset);\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                const currentRow = buffer.cursor[0];\n+                const linesToChange = Math.min(\n+                  commandRepeatCount + 1,\n+                  currentRow + 1,\n+                ); // +1 to include current line\n+                const startRow = currentRow - commandRepeatCount;\n+\n+                if (buffer.lines.length === 1) {\n+                  // Single line - clear the content but keep the line\n+                  const currentLine = buffer.lines[0] || '';\n+                  buffer.replaceRangeByOffset(0, currentLine.length, '');\n+                } else {\n+                  // Multi-line - change N lines including newlines\n+                  let startOffset = 0;\n+                  for (let row = 0; row < Math.max(0, startRow); row++) {\n+                    startOffset += buffer.lines[row].length + 1; // +1 for newline\n+                  }\n+\n+                  let endOffset = startOffset;\n+                  for (let i = 0; i < linesToChange; i++) {\n+                    const lineIndex = Math.max(0, startRow) + i;\n+                    if (lineIndex < buffer.lines.length) {\n+                      endOffset += buffer.lines[lineIndex].length;\n+                      if (lineIndex < buffer.lines.length - 1) {\n+                        endOffset += 1; // +1 for newline\n+                      } else if (\n+                        Math.max(0, startRow) > 0 &&\n+                        lineIndex === buffer.lines.length - 1\n+                      ) {\n+                        // Last line - include the newline before it instead\n+                        startOffset -= 1;\n+                      }\n+                    }\n+                  }\n+\n+                  buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal up movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              buffer.move('up');\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'l': {\n+            // Check if this is part of a change command (cl)\n+            if (pendingC) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              // Change N characters to the right\n+              for (let i = 0; i < repeatCount; i++) {\n+                buffer.del();\n+              }\n+\n+              // Record this command for repeat and switch to INSERT mode\n+              const commandRepeatCount = repeatCount;\n+              lastCommandRef.current = () => {\n+                // Change N characters to the right\n+                for (let i = 0; i < commandRepeatCount; i++) {\n+                  const currentRow = buffer.cursor[0];\n+                  const currentCol = buffer.cursor[1];\n+                  const currentLine = buffer.lines[currentRow] || '';\n+\n+                  if (currentCol < currentLine.length) {\n+                    buffer.del();\n+                  }\n+                }\n+                setModeImmediate('INSERT');\n+              };\n+              setPendingC(false);\n+              setModeImmediate('INSERT');\n+              return true;\n+            }\n+\n+            // Normal right movement\n+            for (let i = 0; i < repeatCount; i++) {\n+              const currentRow = buffer.cursor[0];\n+              const currentCol = buffer.cursor[1];\n+              const currentLine = buffer.lines[currentRow] || '';\n+\n+              // Don't move past the last character of the line\n+              if (currentCol < currentLine.length - 1) {\n+                buffer.move('right');\n+              } else if (currentRow < buffer.lines.length - 1) {\n+                // Move to beginning of next line\n+                buffer.move('down');\n+                buffer.move('home');\n+              }\n+            }\n+            clearCount();\n+            return true;\n+          }\n+\n+          case 'w': {\n+            // Check if this is part of a delete command (dw)\n+            if (pendingD) {\n+              const repeatCount = getCurrentCount();\n+              clearCount();\n+\n+              const text = buffer.text;\n+              const currentOffset = getCurrentOffset();\n+              let endOffset = currentOffset;\n+\n+              // Delete from cursor through N words using findNextWordStart for consistency\n+              let searchOffset = currentOffset;\n+              for (let i = 0; i < repeatCount; i++) {",
        "comment_created_at": "2025-07-23T08:28:57+00:00",
        "comment_author": "sijieamoy",
        "comment_body": "Moved these logic to text-buffer.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2229896937",
    "pr_number": 3936,
    "pr_file": "packages/cli/src/ui/hooks/vim.ts",
    "created_at": "2025-07-25T01:17:14+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import {\n+  findNextWordStart,\n+  findPrevWordStart,\n+  findWordEnd,\n+  logicalPosToOffset,\n+} from '../components/shared/text-buffer.js';\n+import { useVimMode } from '../contexts/VimModeContext.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const WHITESPACE_CHARS = /\\s/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved to text-buffer.ts to eliminate duplication and avoid stale state\n+\n+// Helper function to clear pending state\n+const createClearPendingState = () => ({\n+  count: 0,\n+  pendingOperator: null as 'g' | 'd' | 'c' | null,\n+});\n+\n+// State and action types for useReducer\n+type VimState = {\n+  mode: VimMode;\n+  count: number;\n+  pendingOperator: 'g' | 'd' | 'c' | null;\n+  lastCommand: { type: string; count: number } | null;\n+};\n+\n+type VimAction =\n+  | { type: 'SET_MODE'; mode: VimMode }\n+  | { type: 'SET_COUNT'; count: number }\n+  | { type: 'INCREMENT_COUNT'; digit: number }\n+  | { type: 'CLEAR_COUNT' }\n+  | { type: 'SET_PENDING_OPERATOR'; operator: 'g' | 'd' | 'c' | null }\n+  | {\n+      type: 'SET_LAST_COMMAND';\n+      command: { type: string; count: number } | null;\n+    }\n+  | { type: 'CLEAR_PENDING_STATES' }\n+  | { type: 'ESCAPE_TO_NORMAL' };\n+\n+const initialVimState: VimState = {\n+  mode: 'NORMAL',\n+  count: 0,\n+  pendingOperator: null,\n+  lastCommand: null,\n+};\n+\n+// Reducer function\n+const vimReducer = (state: VimState, action: VimAction): VimState => {\n+  switch (action.type) {\n+    case 'SET_MODE':\n+      return { ...state, mode: action.mode };\n+\n+    case 'SET_COUNT':\n+      return { ...state, count: action.count };\n+\n+    case 'INCREMENT_COUNT':\n+      return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };\n+\n+    case 'CLEAR_COUNT':\n+      return { ...state, count: 0 };\n+\n+    case 'SET_PENDING_OPERATOR':\n+      return { ...state, pendingOperator: action.operator };\n+\n+    case 'SET_LAST_COMMAND':\n+      return { ...state, lastCommand: action.command };\n+\n+    case 'CLEAR_PENDING_STATES':\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    case 'ESCAPE_TO_NORMAL':\n+      // Handle escape - clear all pending states (mode is updated via context)\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+/**\n+ * React hook that provides vim-style editing functionality for text input.\n+ *\n+ * Features:\n+ * - Modal editing (INSERT/NORMAL modes)\n+ * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes\n+ * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes\n+ * - Complex operations: dd,cc,dw,cw,db,cb,de,ce\n+ * - Command repetition (.)\n+ * - Settings persistence\n+ *\n+ * @param buffer - TextBuffer instance for text manipulation\n+ * @param onSubmit - Optional callback for command submission\n+ * @returns Object with vim state and input handler\n+ */\n+export function useVim(buffer: TextBuffer, onSubmit?: (value: string) => void) {\n+  const { vimEnabled, vimMode, setVimMode } = useVimMode();\n+  const [state, dispatch] = useReducer(vimReducer, initialVimState);\n+\n+  // Sync vim mode from context to local state\n+  useEffect(() => {\n+    dispatch({ type: 'SET_MODE', mode: vimMode });\n+  }, [vimMode]);\n+\n+  // Helper to update mode in both reducer and context\n+  const updateMode = useCallback(\n+    (mode: VimMode) => {\n+      setVimMode(mode);\n+      dispatch({ type: 'SET_MODE', mode });\n+    },\n+    [setVimMode],\n+  );\n+\n+  // Helper functions using the reducer state\n+  const getCurrentCount = useCallback(\n+    () => state.count || DEFAULT_COUNT,\n+    [state.count],\n+  );\n+\n+  // Helper to get current cursor position as offset\n+  const getCurrentOffset = useCallback(() => {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2229896937",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2229896937",
        "commented_code": "@@ -0,0 +1,863 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import {\n+  findNextWordStart,\n+  findPrevWordStart,\n+  findWordEnd,\n+  logicalPosToOffset,\n+} from '../components/shared/text-buffer.js';\n+import { useVimMode } from '../contexts/VimModeContext.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const WHITESPACE_CHARS = /\\s/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved to text-buffer.ts to eliminate duplication and avoid stale state\n+\n+// Helper function to clear pending state\n+const createClearPendingState = () => ({\n+  count: 0,\n+  pendingOperator: null as 'g' | 'd' | 'c' | null,\n+});\n+\n+// State and action types for useReducer\n+type VimState = {\n+  mode: VimMode;\n+  count: number;\n+  pendingOperator: 'g' | 'd' | 'c' | null;\n+  lastCommand: { type: string; count: number } | null;\n+};\n+\n+type VimAction =\n+  | { type: 'SET_MODE'; mode: VimMode }\n+  | { type: 'SET_COUNT'; count: number }\n+  | { type: 'INCREMENT_COUNT'; digit: number }\n+  | { type: 'CLEAR_COUNT' }\n+  | { type: 'SET_PENDING_OPERATOR'; operator: 'g' | 'd' | 'c' | null }\n+  | {\n+      type: 'SET_LAST_COMMAND';\n+      command: { type: string; count: number } | null;\n+    }\n+  | { type: 'CLEAR_PENDING_STATES' }\n+  | { type: 'ESCAPE_TO_NORMAL' };\n+\n+const initialVimState: VimState = {\n+  mode: 'NORMAL',\n+  count: 0,\n+  pendingOperator: null,\n+  lastCommand: null,\n+};\n+\n+// Reducer function\n+const vimReducer = (state: VimState, action: VimAction): VimState => {\n+  switch (action.type) {\n+    case 'SET_MODE':\n+      return { ...state, mode: action.mode };\n+\n+    case 'SET_COUNT':\n+      return { ...state, count: action.count };\n+\n+    case 'INCREMENT_COUNT':\n+      return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };\n+\n+    case 'CLEAR_COUNT':\n+      return { ...state, count: 0 };\n+\n+    case 'SET_PENDING_OPERATOR':\n+      return { ...state, pendingOperator: action.operator };\n+\n+    case 'SET_LAST_COMMAND':\n+      return { ...state, lastCommand: action.command };\n+\n+    case 'CLEAR_PENDING_STATES':\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    case 'ESCAPE_TO_NORMAL':\n+      // Handle escape - clear all pending states (mode is updated via context)\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+/**\n+ * React hook that provides vim-style editing functionality for text input.\n+ *\n+ * Features:\n+ * - Modal editing (INSERT/NORMAL modes)\n+ * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes\n+ * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes\n+ * - Complex operations: dd,cc,dw,cw,db,cb,de,ce\n+ * - Command repetition (.)\n+ * - Settings persistence\n+ *\n+ * @param buffer - TextBuffer instance for text manipulation\n+ * @param onSubmit - Optional callback for command submission\n+ * @returns Object with vim state and input handler\n+ */\n+export function useVim(buffer: TextBuffer, onSubmit?: (value: string) => void) {\n+  const { vimEnabled, vimMode, setVimMode } = useVimMode();\n+  const [state, dispatch] = useReducer(vimReducer, initialVimState);\n+\n+  // Sync vim mode from context to local state\n+  useEffect(() => {\n+    dispatch({ type: 'SET_MODE', mode: vimMode });\n+  }, [vimMode]);\n+\n+  // Helper to update mode in both reducer and context\n+  const updateMode = useCallback(\n+    (mode: VimMode) => {\n+      setVimMode(mode);\n+      dispatch({ type: 'SET_MODE', mode });\n+    },\n+    [setVimMode],\n+  );\n+\n+  // Helper functions using the reducer state\n+  const getCurrentCount = useCallback(\n+    () => state.count || DEFAULT_COUNT,\n+    [state.count],\n+  );\n+\n+  // Helper to get current cursor position as offset\n+  const getCurrentOffset = useCallback(() => {",
        "comment_created_at": "2025-07-25T01:17:14+00:00",
        "comment_author": "jacob314",
        "comment_body": "remove this helper completely as it is not safe given the fact that you want to handle multiple keystrokes one after the other so the buffer could be stale by the time you handle the second one if both keystrokes are handled in the same react event frame. sorry this logic has to be written in such a particular way to be robust but you are making changes to the trickiest part of the input system where we need to chain operations together carefully to avoid confusing user behavior.",
        "pr_file_module": null
      },
      {
        "comment_id": "2230403958",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2229896937",
        "commented_code": "@@ -0,0 +1,863 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import {\n+  findNextWordStart,\n+  findPrevWordStart,\n+  findWordEnd,\n+  logicalPosToOffset,\n+} from '../components/shared/text-buffer.js';\n+import { useVimMode } from '../contexts/VimModeContext.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const WHITESPACE_CHARS = /\\s/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved to text-buffer.ts to eliminate duplication and avoid stale state\n+\n+// Helper function to clear pending state\n+const createClearPendingState = () => ({\n+  count: 0,\n+  pendingOperator: null as 'g' | 'd' | 'c' | null,\n+});\n+\n+// State and action types for useReducer\n+type VimState = {\n+  mode: VimMode;\n+  count: number;\n+  pendingOperator: 'g' | 'd' | 'c' | null;\n+  lastCommand: { type: string; count: number } | null;\n+};\n+\n+type VimAction =\n+  | { type: 'SET_MODE'; mode: VimMode }\n+  | { type: 'SET_COUNT'; count: number }\n+  | { type: 'INCREMENT_COUNT'; digit: number }\n+  | { type: 'CLEAR_COUNT' }\n+  | { type: 'SET_PENDING_OPERATOR'; operator: 'g' | 'd' | 'c' | null }\n+  | {\n+      type: 'SET_LAST_COMMAND';\n+      command: { type: string; count: number } | null;\n+    }\n+  | { type: 'CLEAR_PENDING_STATES' }\n+  | { type: 'ESCAPE_TO_NORMAL' };\n+\n+const initialVimState: VimState = {\n+  mode: 'NORMAL',\n+  count: 0,\n+  pendingOperator: null,\n+  lastCommand: null,\n+};\n+\n+// Reducer function\n+const vimReducer = (state: VimState, action: VimAction): VimState => {\n+  switch (action.type) {\n+    case 'SET_MODE':\n+      return { ...state, mode: action.mode };\n+\n+    case 'SET_COUNT':\n+      return { ...state, count: action.count };\n+\n+    case 'INCREMENT_COUNT':\n+      return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };\n+\n+    case 'CLEAR_COUNT':\n+      return { ...state, count: 0 };\n+\n+    case 'SET_PENDING_OPERATOR':\n+      return { ...state, pendingOperator: action.operator };\n+\n+    case 'SET_LAST_COMMAND':\n+      return { ...state, lastCommand: action.command };\n+\n+    case 'CLEAR_PENDING_STATES':\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    case 'ESCAPE_TO_NORMAL':\n+      // Handle escape - clear all pending states (mode is updated via context)\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+/**\n+ * React hook that provides vim-style editing functionality for text input.\n+ *\n+ * Features:\n+ * - Modal editing (INSERT/NORMAL modes)\n+ * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes\n+ * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes\n+ * - Complex operations: dd,cc,dw,cw,db,cb,de,ce\n+ * - Command repetition (.)\n+ * - Settings persistence\n+ *\n+ * @param buffer - TextBuffer instance for text manipulation\n+ * @param onSubmit - Optional callback for command submission\n+ * @returns Object with vim state and input handler\n+ */\n+export function useVim(buffer: TextBuffer, onSubmit?: (value: string) => void) {\n+  const { vimEnabled, vimMode, setVimMode } = useVimMode();\n+  const [state, dispatch] = useReducer(vimReducer, initialVimState);\n+\n+  // Sync vim mode from context to local state\n+  useEffect(() => {\n+    dispatch({ type: 'SET_MODE', mode: vimMode });\n+  }, [vimMode]);\n+\n+  // Helper to update mode in both reducer and context\n+  const updateMode = useCallback(\n+    (mode: VimMode) => {\n+      setVimMode(mode);\n+      dispatch({ type: 'SET_MODE', mode });\n+    },\n+    [setVimMode],\n+  );\n+\n+  // Helper functions using the reducer state\n+  const getCurrentCount = useCallback(\n+    () => state.count || DEFAULT_COUNT,\n+    [state.count],\n+  );\n+\n+  // Helper to get current cursor position as offset\n+  const getCurrentOffset = useCallback(() => {",
        "comment_created_at": "2025-07-25T07:42:59+00:00",
        "comment_author": "sijieamoy",
        "comment_body": "Sorry, what do you mean by \"remove\"? Or, in other words, what's the proper way to get the current offset in vim.ts?\r\n\r\nI wrote a simple AppleScript to simulate commands like `Dw` and `ddw` in quick succession (near zero delay), and it does reveal the problem of the 2nd command operating on stale text buffer. \r\n\r\nI experimented with `useRef(buffer)` in vim.ts, so that the input handler can get the fresh buffer data after the 1st command is executed in the same frame. It appears to have fixed the staleness for `Dw`, `esc+w`, `esc+3x` etc., but not for `ddw` - `w` would still be handled with stale cursor pos instead of pos 0 of the next line after `dd`. I guess it might be a race condition between the handling of `dd` (deletion and cursor pos calculation) and `w`. If there is a 10ms delay between `dd` and `w` it actually works fine.",
        "pr_file_module": null
      },
      {
        "comment_id": "2232063868",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2229896937",
        "commented_code": "@@ -0,0 +1,863 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import {\n+  findNextWordStart,\n+  findPrevWordStart,\n+  findWordEnd,\n+  logicalPosToOffset,\n+} from '../components/shared/text-buffer.js';\n+import { useVimMode } from '../contexts/VimModeContext.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const WHITESPACE_CHARS = /\\s/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved to text-buffer.ts to eliminate duplication and avoid stale state\n+\n+// Helper function to clear pending state\n+const createClearPendingState = () => ({\n+  count: 0,\n+  pendingOperator: null as 'g' | 'd' | 'c' | null,\n+});\n+\n+// State and action types for useReducer\n+type VimState = {\n+  mode: VimMode;\n+  count: number;\n+  pendingOperator: 'g' | 'd' | 'c' | null;\n+  lastCommand: { type: string; count: number } | null;\n+};\n+\n+type VimAction =\n+  | { type: 'SET_MODE'; mode: VimMode }\n+  | { type: 'SET_COUNT'; count: number }\n+  | { type: 'INCREMENT_COUNT'; digit: number }\n+  | { type: 'CLEAR_COUNT' }\n+  | { type: 'SET_PENDING_OPERATOR'; operator: 'g' | 'd' | 'c' | null }\n+  | {\n+      type: 'SET_LAST_COMMAND';\n+      command: { type: string; count: number } | null;\n+    }\n+  | { type: 'CLEAR_PENDING_STATES' }\n+  | { type: 'ESCAPE_TO_NORMAL' };\n+\n+const initialVimState: VimState = {\n+  mode: 'NORMAL',\n+  count: 0,\n+  pendingOperator: null,\n+  lastCommand: null,\n+};\n+\n+// Reducer function\n+const vimReducer = (state: VimState, action: VimAction): VimState => {\n+  switch (action.type) {\n+    case 'SET_MODE':\n+      return { ...state, mode: action.mode };\n+\n+    case 'SET_COUNT':\n+      return { ...state, count: action.count };\n+\n+    case 'INCREMENT_COUNT':\n+      return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };\n+\n+    case 'CLEAR_COUNT':\n+      return { ...state, count: 0 };\n+\n+    case 'SET_PENDING_OPERATOR':\n+      return { ...state, pendingOperator: action.operator };\n+\n+    case 'SET_LAST_COMMAND':\n+      return { ...state, lastCommand: action.command };\n+\n+    case 'CLEAR_PENDING_STATES':\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    case 'ESCAPE_TO_NORMAL':\n+      // Handle escape - clear all pending states (mode is updated via context)\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+/**\n+ * React hook that provides vim-style editing functionality for text input.\n+ *\n+ * Features:\n+ * - Modal editing (INSERT/NORMAL modes)\n+ * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes\n+ * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes\n+ * - Complex operations: dd,cc,dw,cw,db,cb,de,ce\n+ * - Command repetition (.)\n+ * - Settings persistence\n+ *\n+ * @param buffer - TextBuffer instance for text manipulation\n+ * @param onSubmit - Optional callback for command submission\n+ * @returns Object with vim state and input handler\n+ */\n+export function useVim(buffer: TextBuffer, onSubmit?: (value: string) => void) {\n+  const { vimEnabled, vimMode, setVimMode } = useVimMode();\n+  const [state, dispatch] = useReducer(vimReducer, initialVimState);\n+\n+  // Sync vim mode from context to local state\n+  useEffect(() => {\n+    dispatch({ type: 'SET_MODE', mode: vimMode });\n+  }, [vimMode]);\n+\n+  // Helper to update mode in both reducer and context\n+  const updateMode = useCallback(\n+    (mode: VimMode) => {\n+      setVimMode(mode);\n+      dispatch({ type: 'SET_MODE', mode });\n+    },\n+    [setVimMode],\n+  );\n+\n+  // Helper functions using the reducer state\n+  const getCurrentCount = useCallback(\n+    () => state.count || DEFAULT_COUNT,\n+    [state.count],\n+  );\n+\n+  // Helper to get current cursor position as offset\n+  const getCurrentOffset = useCallback(() => {",
        "comment_created_at": "2025-07-25T21:45:06+00:00",
        "comment_author": "sijieamoy",
        "comment_body": "NVM! I get the point. Will push a fix soon.",
        "pr_file_module": null
      },
      {
        "comment_id": "2232106923",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2229896937",
        "commented_code": "@@ -0,0 +1,863 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import {\n+  findNextWordStart,\n+  findPrevWordStart,\n+  findWordEnd,\n+  logicalPosToOffset,\n+} from '../components/shared/text-buffer.js';\n+import { useVimMode } from '../contexts/VimModeContext.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const WHITESPACE_CHARS = /\\s/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved to text-buffer.ts to eliminate duplication and avoid stale state\n+\n+// Helper function to clear pending state\n+const createClearPendingState = () => ({\n+  count: 0,\n+  pendingOperator: null as 'g' | 'd' | 'c' | null,\n+});\n+\n+// State and action types for useReducer\n+type VimState = {\n+  mode: VimMode;\n+  count: number;\n+  pendingOperator: 'g' | 'd' | 'c' | null;\n+  lastCommand: { type: string; count: number } | null;\n+};\n+\n+type VimAction =\n+  | { type: 'SET_MODE'; mode: VimMode }\n+  | { type: 'SET_COUNT'; count: number }\n+  | { type: 'INCREMENT_COUNT'; digit: number }\n+  | { type: 'CLEAR_COUNT' }\n+  | { type: 'SET_PENDING_OPERATOR'; operator: 'g' | 'd' | 'c' | null }\n+  | {\n+      type: 'SET_LAST_COMMAND';\n+      command: { type: string; count: number } | null;\n+    }\n+  | { type: 'CLEAR_PENDING_STATES' }\n+  | { type: 'ESCAPE_TO_NORMAL' };\n+\n+const initialVimState: VimState = {\n+  mode: 'NORMAL',\n+  count: 0,\n+  pendingOperator: null,\n+  lastCommand: null,\n+};\n+\n+// Reducer function\n+const vimReducer = (state: VimState, action: VimAction): VimState => {\n+  switch (action.type) {\n+    case 'SET_MODE':\n+      return { ...state, mode: action.mode };\n+\n+    case 'SET_COUNT':\n+      return { ...state, count: action.count };\n+\n+    case 'INCREMENT_COUNT':\n+      return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };\n+\n+    case 'CLEAR_COUNT':\n+      return { ...state, count: 0 };\n+\n+    case 'SET_PENDING_OPERATOR':\n+      return { ...state, pendingOperator: action.operator };\n+\n+    case 'SET_LAST_COMMAND':\n+      return { ...state, lastCommand: action.command };\n+\n+    case 'CLEAR_PENDING_STATES':\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    case 'ESCAPE_TO_NORMAL':\n+      // Handle escape - clear all pending states (mode is updated via context)\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+/**\n+ * React hook that provides vim-style editing functionality for text input.\n+ *\n+ * Features:\n+ * - Modal editing (INSERT/NORMAL modes)\n+ * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes\n+ * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes\n+ * - Complex operations: dd,cc,dw,cw,db,cb,de,ce\n+ * - Command repetition (.)\n+ * - Settings persistence\n+ *\n+ * @param buffer - TextBuffer instance for text manipulation\n+ * @param onSubmit - Optional callback for command submission\n+ * @returns Object with vim state and input handler\n+ */\n+export function useVim(buffer: TextBuffer, onSubmit?: (value: string) => void) {\n+  const { vimEnabled, vimMode, setVimMode } = useVimMode();\n+  const [state, dispatch] = useReducer(vimReducer, initialVimState);\n+\n+  // Sync vim mode from context to local state\n+  useEffect(() => {\n+    dispatch({ type: 'SET_MODE', mode: vimMode });\n+  }, [vimMode]);\n+\n+  // Helper to update mode in both reducer and context\n+  const updateMode = useCallback(\n+    (mode: VimMode) => {\n+      setVimMode(mode);\n+      dispatch({ type: 'SET_MODE', mode });\n+    },\n+    [setVimMode],\n+  );\n+\n+  // Helper functions using the reducer state\n+  const getCurrentCount = useCallback(\n+    () => state.count || DEFAULT_COUNT,\n+    [state.count],\n+  );\n+\n+  // Helper to get current cursor position as offset\n+  const getCurrentOffset = useCallback(() => {",
        "comment_created_at": "2025-07-25T22:19:37+00:00",
        "comment_author": "sijieamoy",
        "comment_body": "Removed all the text buffer state reading and direct manipulation from vim.ts.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2206638047",
    "pr_number": 3957,
    "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
    "created_at": "2025-07-15T07:26:27+00:00",
    "commented_code": "}\n \n   flushIfNeeded(): void {\n-    if (Date.now() - this.last_flush_time < this.flush_interval_ms) {\n+    if (\n+      this.flushing ||",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2206648130",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3957,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2206638047",
        "commented_code": "@@ -100,21 +114,27 @@ export class ClearcutLogger {\n   }\n \n   flushIfNeeded(): void {\n-    if (Date.now() - this.last_flush_time < this.flush_interval_ms) {\n+    if (\n+      this.flushing ||",
        "comment_created_at": "2025-07-15T07:26:27+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "@gemini-code-assist, Thanks for the suggestion, but this would actually break the logic. The current design correctly separates concerns:\r\n\r\n1. flushIfNeeded() checks if flushing is needed and exits early if already flushing\r\n2. flushToClearcut() performs the actual flush operation and manages the flag\r\n\r\nIf we moved this.flushing = true before the conditional check in flushIfNeeded(), the check would always see this.flushing = true and always return early, preventing any flushes from ever happening.\r\n\r\nThe current implementation is correct:\r\n- flushIfNeeded() \u2192 checks conditions and calls flushToClearcut() if needed\r\n- flushToClearcut() \u2192 sets this.flushing = true at the start, does the work, and clears the flag in the finally block\r\n\r\nThis prevents the race condition because only one call to flushToClearcut() can be active at a time, and the flag is properly managed within the async operation's lifecycle.",
        "pr_file_module": null
      },
      {
        "comment_id": "2206655147",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3957,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2206638047",
        "commented_code": "@@ -100,21 +114,27 @@ export class ClearcutLogger {\n   }\n \n   flushIfNeeded(): void {\n-    if (Date.now() - this.last_flush_time < this.flush_interval_ms) {\n+    if (\n+      this.flushing ||",
        "comment_created_at": "2025-07-15T07:29:53+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "@gemini-code-assist You're absolutely right about the race condition! Thank you for the detailed explanation\r\n   and the corrected solution.\r\n\r\n  The issue is indeed in the time window between the this.flushing check in\r\n  flushIfNeeded() and when the flag gets set inside the async flushToClearcut() method.\r\n  Multiple concurrent calls could pass the initial check before any of them sets the flag.\r\n\r\n  Your refined approach is correct:\r\n  1. Set this.flushing = true synchronously in flushIfNeeded() right after the checks pass\r\n  2. Remove the redundant flag setting from flushToClearcut()\r\n  3. Keep the finally block for proper cleanup\r\n\r\n  This eliminates the race condition by ensuring the flag is set before any async\r\n  operations begin. I'll implement this fix. Thanks for catching this and providing the\r\n  correct solution!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216510276",
    "pr_number": 3957,
    "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
    "created_at": "2025-07-18T17:00:04+00:00",
    "commented_code": "if (this.config?.getDebugMode()) {\n           console.log('Clearcut POST request error: ', e);\n         }\n-        // Add the events back to the front of the queue to be retried.\n-        this.events.unshift(...eventsToSend);\n+        // Add the events back to the front of the queue to be retried, but limit retry queue size\n+        const eventsToRetry = eventsToSend.slice(-this.max_retry_events); // Keep only the most recent events\n+\n+        // Add retry events to the front of the deque (O(1) operations)\n+        // If the queue is full, unshift will throw, and we'll stop requeueing.\n+        for (let i = eventsToRetry.length - 1; i >= 0; i--) {\n+          try {\n+            this.events.unshift(eventsToRetry[i]);\n+          } catch (e) {\n+            // This can happen if the queue is full, possibly due to a race condition with enqueueLogEvent.",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2216510276",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3957,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2216510276",
        "commented_code": "@@ -142,8 +167,33 @@ export class ClearcutLogger {\n         if (this.config?.getDebugMode()) {\n           console.log('Clearcut POST request error: ', e);\n         }\n-        // Add the events back to the front of the queue to be retried.\n-        this.events.unshift(...eventsToSend);\n+        // Add the events back to the front of the queue to be retried, but limit retry queue size\n+        const eventsToRetry = eventsToSend.slice(-this.max_retry_events); // Keep only the most recent events\n+\n+        // Add retry events to the front of the deque (O(1) operations)\n+        // If the queue is full, unshift will throw, and we'll stop requeueing.\n+        for (let i = eventsToRetry.length - 1; i >= 0; i--) {\n+          try {\n+            this.events.unshift(eventsToRetry[i]);\n+          } catch (e) {\n+            // This can happen if the queue is full, possibly due to a race condition with enqueueLogEvent.",
        "comment_created_at": "2025-07-18T17:00:04+00:00",
        "comment_author": "jacob314",
        "comment_body": "please refactor avoid this catch block. there should be ways to avoid any race condition here. if there are failure modes I would much rather have us check that this.events is empty that catch to swallow exceptions.",
        "pr_file_module": null
      },
      {
        "comment_id": "2216789954",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3957,
        "pr_file": "packages/core/src/telemetry/clearcut-logger/clearcut-logger.ts",
        "discussion_id": "2216510276",
        "commented_code": "@@ -142,8 +167,33 @@ export class ClearcutLogger {\n         if (this.config?.getDebugMode()) {\n           console.log('Clearcut POST request error: ', e);\n         }\n-        // Add the events back to the front of the queue to be retried.\n-        this.events.unshift(...eventsToSend);\n+        // Add the events back to the front of the queue to be retried, but limit retry queue size\n+        const eventsToRetry = eventsToSend.slice(-this.max_retry_events); // Keep only the most recent events\n+\n+        // Add retry events to the front of the deque (O(1) operations)\n+        // If the queue is full, unshift will throw, and we'll stop requeueing.\n+        for (let i = eventsToRetry.length - 1; i >= 0; i--) {\n+          try {\n+            this.events.unshift(eventsToRetry[i]);\n+          } catch (e) {\n+            // This can happen if the queue is full, possibly due to a race condition with enqueueLogEvent.",
        "comment_created_at": "2025-07-18T19:24:34+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "I've refactored the code to avoid the try-catch block and prevent race conditions. The new  implementation:\r\n\r\n1. Pre-calculates available space before attempting to requeue events\r\n2. Uses deterministic size checks instead of relying on exception handling\r\n3. Prioritizes the most recent events when the queue can't fit all retry events\r\n4. Double-checks available space before each individual insert to handle concurrent enqueueLogEvent  calls\r\n\r\nThis approach eliminates the race condition by checking constraints before operations rather than  catching overflow exceptions.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173753639",
    "pr_number": 2570,
    "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
    "created_at": "2025-06-29T13:29:13+00:00",
    "commented_code": "}\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n+    readline.emitKeypressEvents(stdin, rl);\n \n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n+    // Enable bracketed paste mode if requested and stdin is writable\n+    if (enableBracketedPaste && stdin.writable) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        console.log('Bracketed paste mode enabled');\n+      } catch (err) {\n+        console.error('Failed to enable bracketed paste:', err);\n+      }\n+    }\n+\n+    const maxInputDelay = 10; // Milliseconds, increased for reliability\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      console.log('Timeout paste:', combinedSequence);\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+    };\n+\n+    // Raw input listener to capture full paste content\n+    const handleRawData = (data: Buffer) => {\n+      const input = data.toString();\n+      console.log('Raw data:', JSON.stringify(input));\n+\n+      // Check for bracketed paste sequences if enabled\n+      if (enableBracketedPaste) {\n+        if (input.includes('\\x1b[200~')) {\n+          isPasteModeRef.current = true;\n+          pasteBufferRef.current = '';\n+          console.log('Paste start detected');\n+          return;\n+        }\n+        if (input.includes('\\x1b[201~')) {\n+          isPasteModeRef.current = false;\n+          const pasteContent = pasteBufferRef.current.replace('\\x1b[200~', '').replace('\\x1b[201~', '');\n+          console.log('Paste end, content:', pasteContent);\n+          if (pasteContent.length > 0) {\n+            onKeypressRef.current({\n+              name: '',\n+              ctrl: false,\n+              meta: false,\n+              shift: false,\n+              paste: true,\n+              sequence: pasteContent,\n+            });\n+          }\n+          pasteBufferRef.current = '';\n+          return;\n+        }\n+      }\n+\n+      if (isPasteModeRef.current) {\n+        pasteBufferRef.current += input;\n+      } else if (input.length > 1) {\n+        // Treat multi-character raw input as a paste\n+        console.log('Raw paste detected:', input);\n         onKeypressRef.current({\n           name: '',\n           ctrl: false,\n           meta: false,\n           shift: false,\n           paste: true,\n-          sequence: pasteBuffer.toString(),\n+          sequence: input,\n         });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n-        } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+      }",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2173759704",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2570,
        "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
        "discussion_id": "2173753639",
        "commented_code": "@@ -47,58 +57,167 @@ export function useKeypress(\n     }\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n+    readline.emitKeypressEvents(stdin, rl);\n \n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n+    // Enable bracketed paste mode if requested and stdin is writable\n+    if (enableBracketedPaste && stdin.writable) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        console.log('Bracketed paste mode enabled');\n+      } catch (err) {\n+        console.error('Failed to enable bracketed paste:', err);\n+      }\n+    }\n+\n+    const maxInputDelay = 10; // Milliseconds, increased for reliability\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      console.log('Timeout paste:', combinedSequence);\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+    };\n+\n+    // Raw input listener to capture full paste content\n+    const handleRawData = (data: Buffer) => {\n+      const input = data.toString();\n+      console.log('Raw data:', JSON.stringify(input));\n+\n+      // Check for bracketed paste sequences if enabled\n+      if (enableBracketedPaste) {\n+        if (input.includes('\\x1b[200~')) {\n+          isPasteModeRef.current = true;\n+          pasteBufferRef.current = '';\n+          console.log('Paste start detected');\n+          return;\n+        }\n+        if (input.includes('\\x1b[201~')) {\n+          isPasteModeRef.current = false;\n+          const pasteContent = pasteBufferRef.current.replace('\\x1b[200~', '').replace('\\x1b[201~', '');\n+          console.log('Paste end, content:', pasteContent);\n+          if (pasteContent.length > 0) {\n+            onKeypressRef.current({\n+              name: '',\n+              ctrl: false,\n+              meta: false,\n+              shift: false,\n+              paste: true,\n+              sequence: pasteContent,\n+            });\n+          }\n+          pasteBufferRef.current = '';\n+          return;\n+        }\n+      }\n+\n+      if (isPasteModeRef.current) {\n+        pasteBufferRef.current += input;\n+      } else if (input.length > 1) {\n+        // Treat multi-character raw input as a paste\n+        console.log('Raw paste detected:', input);\n         onKeypressRef.current({\n           name: '',\n           ctrl: false,\n           meta: false,\n           shift: false,\n           paste: true,\n-          sequence: pasteBuffer.toString(),\n+          sequence: input,\n         });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n-        } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+      }",
        "comment_created_at": "2025-06-29T13:29:13+00:00",
        "comment_author": "jjborie",
        "comment_body": "Fixed Race Condition:\r\nAdded pasteHandledRef to track when handleRawData processes a paste.\r\nIn handleRawData, set pasteHandledRef.current = true and clear keyBufferRef.current after processing a paste (bracketed or multi-character).\r\nIn handleKeypress, skip processing if pasteHandledRef.current is true, resetting the flag afterward to allow future keypresses.\r\nThis ensures that once handleRawData handles a paste, handleKeypress does not process the same input via readline keypress events.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173780648",
    "pr_number": 2570,
    "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
    "created_at": "2025-06-29T14:43:34+00:00",
    "commented_code": "}\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n+    readline.emitKeypressEvents(stdin, rl);\n \n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n-        onKeypressRef.current({\n-          name: '',\n-          ctrl: false,\n-          meta: false,\n-          shift: false,\n-          paste: true,\n-          sequence: pasteBuffer.toString(),\n-        });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n-        } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+    // Detect bracketed paste support\n+    const term = process.env.TERM?.toLowerCase() || '';\n+    const knownSupportedTerms = [\n+      'xterm',\n+      'screen',\n+      'tmux',\n+      'rxvt',\n+      'linux',\n+      'cygwin',\n+      'st',\n+      'alacritty',\n+      'kitty',\n+    ];\n+    const isLikelySupported =\n+      stdin.writable &&\n+      knownSupportedTerms.some((supportedTerm) => term.includes(supportedTerm));\n+\n+    if (isLikelySupported) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        isBracketedPasteSupportedRef.current = true;\n+      } catch (err) {\n+        // Silently handle error, fallback to timeout-based detection\n+        isBracketedPasteSupportedRef.current = false;\n+      }\n+    }\n+\n+    const maxInputDelay = 10; // Milliseconds, increased for reliability\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+    };\n+\n+    // Raw input listener to capture full paste content\n+    const handleRawData = (data: Buffer) => {\n+      const input = data.toString();\n+\n+      if (isBracketedPasteSupportedRef.current) {\n+        // Parse input for bracketed paste sequences\n+        let remainingInput = input;\n+        while (remainingInput.length > 0) {\n+          if (!isPasteModeRef.current && remainingInput.startsWith('\\x1b[200~')) {\n+            isPasteModeRef.current = true;\n+            pasteBufferRef.current = '';\n+            remainingInput = remainingInput.slice(6); // Length of \\x1b[200~\n+            continue;\n+          }\n+          if (isPasteModeRef.current && remainingInput.startsWith('\\x1b[201~')) {\n+            isPasteModeRef.current = false;\n+            if (pasteBufferRef.current.length > 0) {\n+              pasteHandledRef.current = true;\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pasteBufferRef.current,\n+              });\n+              keyBufferRef.current = []; // Clear keypress buffer to prevent duplicate processing\n+            }\n+            pasteBufferRef.current = '';\n+            remainingInput = remainingInput.slice(6); // Length of \\x1b[201~\n+            continue;\n+          }\n+          if (isPasteModeRef.current) {\n+            // Find the next marker or end of input\n+            const nextStart = remainingInput.indexOf('\\x1b[200~');\n+            const nextEnd = remainingInput.indexOf('\\x1b[201~');\n+            let nextMarkerPos = -1;\n+            if (nextStart !== -1 && (nextEnd === -1 || nextStart < nextEnd)) {\n+              nextMarkerPos = nextStart;\n+            } else if (nextEnd !== -1) {\n+              nextMarkerPos = nextEnd;\n+            }\n+            const content = nextMarkerPos === -1 ? remainingInput : remainingInput.slice(0, nextMarkerPos);\n+            pasteBufferRef.current += content;\n+            remainingInput = nextMarkerPos === -1 ? '' : remainingInput.slice(nextMarkerPos);\n+          } else {\n+            break; // Let readline handle non-paste input\n           }\n-          onKeypressRef.current({ ...key, paste: isPaste });\n         }\n       }\n+      // Non-bracketed input is handled by handleKeypress via readline\n     };\n \n-    readline.emitKeypressEvents(stdin, rl);\n+    const handleKeypress = (_: unknown, key: Key) => {\n+      if (isPasteModeRef.current || pasteHandledRef.current) {\n+        // Skip processing if in bracketed paste mode or paste was handled by raw data\n+        pasteHandledRef.current = false; // Reset flag after skipping\n+        return;\n+      }\n+\n+      // Timeout-based detection for single characters and pastes\n+      keyBufferRef.current.push(key);\n+\n+      if (timeoutRef.current) {\n+        clearTimeout(timeoutRef.current);\n+      }\n+\n+      timeoutRef.current = setTimeout(() => {\n+        const keys = keyBufferRef.current;\n+        if (keys.length === 1) {\n+          // Single keypress\n+          const singleKey = keys[0];\n+          if (singleKey.name === 'return' && singleKey.sequence === '\\x1b\\r') {\n+            singleKey.meta = true;\n+          }\n+          onKeypressRef.current({ ...singleKey, paste: false });\n+          keyBufferRef.current = [];\n+          timeoutRef.current = null;\n+        } else {\n+          handleInput();\n+        }\n+      }, maxInputDelay);\n+    };\n+\n+    stdin.on('data', handleRawData);",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2173783465",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2570,
        "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
        "discussion_id": "2173780648",
        "commented_code": "@@ -47,58 +57,183 @@ export function useKeypress(\n     }\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n+    readline.emitKeypressEvents(stdin, rl);\n \n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n-        onKeypressRef.current({\n-          name: '',\n-          ctrl: false,\n-          meta: false,\n-          shift: false,\n-          paste: true,\n-          sequence: pasteBuffer.toString(),\n-        });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n-        } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+    // Detect bracketed paste support\n+    const term = process.env.TERM?.toLowerCase() || '';\n+    const knownSupportedTerms = [\n+      'xterm',\n+      'screen',\n+      'tmux',\n+      'rxvt',\n+      'linux',\n+      'cygwin',\n+      'st',\n+      'alacritty',\n+      'kitty',\n+    ];\n+    const isLikelySupported =\n+      stdin.writable &&\n+      knownSupportedTerms.some((supportedTerm) => term.includes(supportedTerm));\n+\n+    if (isLikelySupported) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        isBracketedPasteSupportedRef.current = true;\n+      } catch (err) {\n+        // Silently handle error, fallback to timeout-based detection\n+        isBracketedPasteSupportedRef.current = false;\n+      }\n+    }\n+\n+    const maxInputDelay = 10; // Milliseconds, increased for reliability\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+    };\n+\n+    // Raw input listener to capture full paste content\n+    const handleRawData = (data: Buffer) => {\n+      const input = data.toString();\n+\n+      if (isBracketedPasteSupportedRef.current) {\n+        // Parse input for bracketed paste sequences\n+        let remainingInput = input;\n+        while (remainingInput.length > 0) {\n+          if (!isPasteModeRef.current && remainingInput.startsWith('\\x1b[200~')) {\n+            isPasteModeRef.current = true;\n+            pasteBufferRef.current = '';\n+            remainingInput = remainingInput.slice(6); // Length of \\x1b[200~\n+            continue;\n+          }\n+          if (isPasteModeRef.current && remainingInput.startsWith('\\x1b[201~')) {\n+            isPasteModeRef.current = false;\n+            if (pasteBufferRef.current.length > 0) {\n+              pasteHandledRef.current = true;\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pasteBufferRef.current,\n+              });\n+              keyBufferRef.current = []; // Clear keypress buffer to prevent duplicate processing\n+            }\n+            pasteBufferRef.current = '';\n+            remainingInput = remainingInput.slice(6); // Length of \\x1b[201~\n+            continue;\n+          }\n+          if (isPasteModeRef.current) {\n+            // Find the next marker or end of input\n+            const nextStart = remainingInput.indexOf('\\x1b[200~');\n+            const nextEnd = remainingInput.indexOf('\\x1b[201~');\n+            let nextMarkerPos = -1;\n+            if (nextStart !== -1 && (nextEnd === -1 || nextStart < nextEnd)) {\n+              nextMarkerPos = nextStart;\n+            } else if (nextEnd !== -1) {\n+              nextMarkerPos = nextEnd;\n+            }\n+            const content = nextMarkerPos === -1 ? remainingInput : remainingInput.slice(0, nextMarkerPos);\n+            pasteBufferRef.current += content;\n+            remainingInput = nextMarkerPos === -1 ? '' : remainingInput.slice(nextMarkerPos);\n+          } else {\n+            break; // Let readline handle non-paste input\n           }\n-          onKeypressRef.current({ ...key, paste: isPaste });\n         }\n       }\n+      // Non-bracketed input is handled by handleKeypress via readline\n     };\n \n-    readline.emitKeypressEvents(stdin, rl);\n+    const handleKeypress = (_: unknown, key: Key) => {\n+      if (isPasteModeRef.current || pasteHandledRef.current) {\n+        // Skip processing if in bracketed paste mode or paste was handled by raw data\n+        pasteHandledRef.current = false; // Reset flag after skipping\n+        return;\n+      }\n+\n+      // Timeout-based detection for single characters and pastes\n+      keyBufferRef.current.push(key);\n+\n+      if (timeoutRef.current) {\n+        clearTimeout(timeoutRef.current);\n+      }\n+\n+      timeoutRef.current = setTimeout(() => {\n+        const keys = keyBufferRef.current;\n+        if (keys.length === 1) {\n+          // Single keypress\n+          const singleKey = keys[0];\n+          if (singleKey.name === 'return' && singleKey.sequence === '\\x1b\\r') {\n+            singleKey.meta = true;\n+          }\n+          onKeypressRef.current({ ...singleKey, paste: false });\n+          keyBufferRef.current = [];\n+          timeoutRef.current = null;\n+        } else {\n+          handleInput();\n+        }\n+      }, maxInputDelay);\n+    };\n+\n+    stdin.on('data', handleRawData);",
        "comment_created_at": "2025-06-29T14:43:34+00:00",
        "comment_author": "jjborie",
        "comment_body": "Fixed Race Condition:\r\nChanged stdin.on('data', handleRawData) to stdin.prependListener('data', handleRawData) to ensure handleRawData runs before readline\u2019s listener.\r\nApplied stdin.prependListener('keypress', handleKeypress) for consistency, ensuring handleKeypress aligns with raw data processing.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173797093",
    "pr_number": 2570,
    "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
    "created_at": "2025-06-29T15:43:54+00:00",
    "commented_code": "}\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n+    readline.emitKeypressEvents(stdin, rl);\n \n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n+    // Detect bracketed paste support\n+    const term = process.env.TERM?.toLowerCase() || '';\n+    const knownSupportedTerms = [\n+      'xterm',\n+      'screen',\n+      'tmux',\n+      'rxvt',\n+      'linux',\n+      'cygwin',\n+      'st',\n+      'alacritty',\n+      'kitty',\n+    ];\n+    const isLikelySupported =\n+      stdin.writable &&\n+      knownSupportedTerms.some((supportedTerm) => term.includes(supportedTerm));\n+\n+    if (isLikelySupported) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        isBracketedPasteSupportedRef.current = true;\n+      } catch (err) {\n+        // Silently handle error, fallback to timeout-based detection\n+        isBracketedPasteSupportedRef.current = false;\n+      }\n+    }\n+\n+    const maxInputDelay = 50; // Milliseconds, for reliable paste detection\n+    const pasteTimeoutDuration = 1000; // 1 second for unterminated pastes\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+    };\n+\n+    const resetPasteState = () => {\n+      if (isPasteModeRef.current && pasteBufferRef.current.length > 0) {\n+        // Process partial paste as a fallback\n         onKeypressRef.current({\n           name: '',\n           ctrl: false,\n           meta: false,\n           shift: false,\n           paste: true,\n-          sequence: pasteBuffer.toString(),\n+          sequence: pasteBufferRef.current,\n         });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n+      }\n+      isPasteModeRef.current = false;\n+      pasteBufferRef.current = '';\n+      pasteHandledRef.current = false;\n+      if (pasteTimeoutRef.current) {\n+        clearTimeout(pasteTimeoutRef.current);\n+        pasteTimeoutRef.current = null;\n+      }\n+    };\n+\n+    const handleRawData = (data: Buffer) => {\n+      if (!isBracketedPasteSupportedRef.current) {\n+        return;\n+      }\n+\n+      let remainingInput = data.toString();\n+\n+      while (remainingInput.length > 0) {\n+        if (isPasteModeRef.current) {\n+          const endMarkerIndex = remainingInput.indexOf('\\x1b[201~');\n+          if (endMarkerIndex !== -1) {\n+            pasteBufferRef.current += remainingInput.slice(0, endMarkerIndex);\n+\n+            if (pasteBufferRef.current.length > 0) {\n+              pasteHandledRef.current = true;\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pasteBufferRef.current,\n+              });\n+              keyBufferRef.current = []; // Clear keypress buffer\n+            }\n+\n+            pasteBufferRef.current = '';\n+            isPasteModeRef.current = false;\n+            remainingInput = remainingInput.slice(endMarkerIndex + 6);\n+            if (pasteTimeoutRef.current) {\n+              clearTimeout(pasteTimeoutRef.current);\n+              pasteTimeoutRef.current = null;\n+            }\n+          } else {\n+            pasteBufferRef.current += remainingInput;\n+            break; // Wait for the next data chunk for the end marker\n+          }\n         } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+          if (remainingInput.startsWith('\\x1b[200~')) {\n+            isPasteModeRef.current = true;\n+            pasteBufferRef.current = '';\n+            remainingInput = remainingInput.slice(6);\n+            // Start timeout for unterminated paste\n+            pasteTimeoutRef.current = setTimeout(resetPasteState, pasteTimeoutDuration);\n+          } else {\n+            // Not in paste mode and doesn't start with a paste marker.\n+            // Let readline handle this data.\n+            break;\n           }\n-          onKeypressRef.current({ ...key, paste: isPaste });\n         }\n       }\n     };\n \n-    readline.emitKeypressEvents(stdin, rl);\n-    stdin.on('keypress', handleKeypress);\n+    const handleKeypress = (_: unknown, key: Key) => {\n+      if (isPasteModeRef.current || pasteHandledRef.current) {\n+        // Skip processing if in bracketed paste mode or paste was handled by raw data\n+        pasteHandledRef.current = false; // Reset flag after skipping\n+        return;\n+      }",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2173809961",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2570,
        "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
        "discussion_id": "2173797093",
        "commented_code": "@@ -47,58 +62,209 @@ export function useKeypress(\n     }\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n+    readline.emitKeypressEvents(stdin, rl);\n \n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n+    // Detect bracketed paste support\n+    const term = process.env.TERM?.toLowerCase() || '';\n+    const knownSupportedTerms = [\n+      'xterm',\n+      'screen',\n+      'tmux',\n+      'rxvt',\n+      'linux',\n+      'cygwin',\n+      'st',\n+      'alacritty',\n+      'kitty',\n+    ];\n+    const isLikelySupported =\n+      stdin.writable &&\n+      knownSupportedTerms.some((supportedTerm) => term.includes(supportedTerm));\n+\n+    if (isLikelySupported) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        isBracketedPasteSupportedRef.current = true;\n+      } catch (err) {\n+        // Silently handle error, fallback to timeout-based detection\n+        isBracketedPasteSupportedRef.current = false;\n+      }\n+    }\n+\n+    const maxInputDelay = 50; // Milliseconds, for reliable paste detection\n+    const pasteTimeoutDuration = 1000; // 1 second for unterminated pastes\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+    };\n+\n+    const resetPasteState = () => {\n+      if (isPasteModeRef.current && pasteBufferRef.current.length > 0) {\n+        // Process partial paste as a fallback\n         onKeypressRef.current({\n           name: '',\n           ctrl: false,\n           meta: false,\n           shift: false,\n           paste: true,\n-          sequence: pasteBuffer.toString(),\n+          sequence: pasteBufferRef.current,\n         });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n+      }\n+      isPasteModeRef.current = false;\n+      pasteBufferRef.current = '';\n+      pasteHandledRef.current = false;\n+      if (pasteTimeoutRef.current) {\n+        clearTimeout(pasteTimeoutRef.current);\n+        pasteTimeoutRef.current = null;\n+      }\n+    };\n+\n+    const handleRawData = (data: Buffer) => {\n+      if (!isBracketedPasteSupportedRef.current) {\n+        return;\n+      }\n+\n+      let remainingInput = data.toString();\n+\n+      while (remainingInput.length > 0) {\n+        if (isPasteModeRef.current) {\n+          const endMarkerIndex = remainingInput.indexOf('\\x1b[201~');\n+          if (endMarkerIndex !== -1) {\n+            pasteBufferRef.current += remainingInput.slice(0, endMarkerIndex);\n+\n+            if (pasteBufferRef.current.length > 0) {\n+              pasteHandledRef.current = true;\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pasteBufferRef.current,\n+              });\n+              keyBufferRef.current = []; // Clear keypress buffer\n+            }\n+\n+            pasteBufferRef.current = '';\n+            isPasteModeRef.current = false;\n+            remainingInput = remainingInput.slice(endMarkerIndex + 6);\n+            if (pasteTimeoutRef.current) {\n+              clearTimeout(pasteTimeoutRef.current);\n+              pasteTimeoutRef.current = null;\n+            }\n+          } else {\n+            pasteBufferRef.current += remainingInput;\n+            break; // Wait for the next data chunk for the end marker\n+          }\n         } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+          if (remainingInput.startsWith('\\x1b[200~')) {\n+            isPasteModeRef.current = true;\n+            pasteBufferRef.current = '';\n+            remainingInput = remainingInput.slice(6);\n+            // Start timeout for unterminated paste\n+            pasteTimeoutRef.current = setTimeout(resetPasteState, pasteTimeoutDuration);\n+          } else {\n+            // Not in paste mode and doesn't start with a paste marker.\n+            // Let readline handle this data.\n+            break;\n           }\n-          onKeypressRef.current({ ...key, paste: isPaste });\n         }\n       }\n     };\n \n-    readline.emitKeypressEvents(stdin, rl);\n-    stdin.on('keypress', handleKeypress);\n+    const handleKeypress = (_: unknown, key: Key) => {\n+      if (isPasteModeRef.current || pasteHandledRef.current) {\n+        // Skip processing if in bracketed paste mode or paste was handled by raw data\n+        pasteHandledRef.current = false; // Reset flag after skipping\n+        return;\n+      }",
        "comment_created_at": "2025-06-29T15:43:54+00:00",
        "comment_author": "jjborie",
        "comment_body": "> - Ensured correct event sequence for data and keypress listeners to validate charsToIgnoreRef logic.\r\n- Verified charsToIgnoreRef prevents duplicate paste processing, addressing critical bug in paste detection coordination.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2173885008",
    "pr_number": 2570,
    "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
    "created_at": "2025-06-29T19:21:42+00:00",
    "commented_code": "}\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n-\n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n+    readline.emitKeypressEvents(stdin, rl);\n+\n+    // Detect bracketed paste support\n+    const term = process.env.TERM?.toLowerCase() || '';\n+    const knownSupportedTerms = [\n+      'xterm',\n+      'screen',\n+      'tmux',\n+      'rxvt',\n+      'linux',\n+      'cygwin',\n+      'st',\n+      'alacritty',\n+      'kitty',\n+    ];\n+    const isLikelySupported =\n+      stdin.writable &&\n+      knownSupportedTerms.some((supportedTerm) => term.includes(supportedTerm));\n+\n+    if (isLikelySupported) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        isBracketedPasteSupportedRef.current = true;\n+      } catch (err) {\n+        isBracketedPasteSupportedRef.current = false;\n+      }\n+    }\n+\n+    const maxInputDelay = 50; // Milliseconds, for reliable paste detection\n+    const pasteTimeoutDuration = 1000; // 1 second for unterminated pastes\n+    const startMarker = '\\x1b[200~';\n+    const endMarker = '\\x1b[201~';\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+      pasteHandledRef.current = false; // Reset after paste processing\n+    };\n+\n+    const resetPasteState = () => {\n+      if (isPasteModeRef.current && pasteBufferRef.current.length > 0) {\n         onKeypressRef.current({\n           name: '',\n           ctrl: false,\n           meta: false,\n           shift: false,\n           paste: true,\n-          sequence: pasteBuffer.toString(),\n+          sequence: pasteBufferRef.current,\n         });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n+      }\n+      isPasteModeRef.current = false;\n+      pasteBufferRef.current = '';\n+      pasteHandledRef.current = false;\n+      partialStartMarkerRef.current = '';\n+      if (pasteTimeoutRef.current) {\n+        clearTimeout(pasteTimeoutRef.current);\n+        pasteTimeoutRef.current = null;\n+      }\n+    };\n+\n+    const handleRawData = (data: Buffer) => {\n+      if (!isBracketedPasteSupportedRef.current) {\n+        return;\n+      }\n+\n+      let input = data.toString('utf-8');\n+\n+      if (partialStartMarkerRef.current.length > 0) {\n+        input = partialStartMarkerRef.current + input;\n+        partialStartMarkerRef.current = '';\n+      }\n+\n+      while (input.length > 0) {\n+        if (isPasteModeRef.current) {\n+          const endMarkerIndex = input.indexOf(endMarker);\n+          if (endMarkerIndex !== -1) {\n+            pasteBufferRef.current += input.slice(0, endMarkerIndex);\n+\n+            if (pasteBufferRef.current.length > 0) {\n+              pasteHandledRef.current = true;\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pasteBufferRef.current,\n+              });\n+              keyBufferRef.current = [];\n+              if (timeoutRef.current) clearTimeout(timeoutRef.current);\n+              timeoutRef.current = setTimeout(() => {\n+                pasteHandledRef.current = false;\n+                timeoutRef.current = null;\n+              }, maxInputDelay);\n+            }\n+\n+            isPasteModeRef.current = false;\n+            pasteBufferRef.current = '';\n+            if (pasteTimeoutRef.current) {\n+              clearTimeout(pasteTimeoutRef.current);\n+              pasteTimeoutRef.current = null;\n+            }\n+            input = input.slice(endMarkerIndex + endMarker.length);\n+          } else {\n+            pasteBufferRef.current += input;\n+            input = '';\n+          }\n         } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+          const startMarkerIndex = input.indexOf(startMarker);\n+          const endMarkerIndex = input.indexOf(endMarker);\n+\n+          if (\n+            startMarkerIndex !== -1 &&\n+            (endMarkerIndex === -1 || startMarkerIndex < endMarkerIndex)\n+          ) {\n+            const regularInput = input.slice(0, startMarkerIndex);\n+            if (regularInput.length > 0) {\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: false,\n+                sequence: regularInput,\n+              });\n+            }\n+            isPasteModeRef.current = true;\n+            pasteBufferRef.current = '';\n+            input = input.slice(startMarkerIndex + startMarker.length);\n+            pasteTimeoutRef.current = setTimeout(\n+              resetPasteState,\n+              pasteTimeoutDuration,\n+            );\n+          } else if (endMarkerIndex !== -1) {\n+            const pastedContent = input.slice(0, endMarkerIndex);\n+            if (pastedContent.length > 0) {\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pastedContent,\n+              });\n+            }\n+            input = input.slice(endMarkerIndex + endMarker.length);\n+          } else {\n+            if (startMarker.startsWith(input)) {\n+              partialStartMarkerRef.current = input;\n+              input = '';\n+            } else {\n+              if (input.length > 0) {\n+                onKeypressRef.current({\n+                  name: '',\n+                  ctrl: false,\n+                  meta: false,\n+                  shift: false,\n+                  paste: false,\n+                  sequence: input,\n+                });\n+              }\n+              input = '';\n+            }\n           }\n-          onKeypressRef.current({ ...key, paste: isPaste });\n         }",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2173887587",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2570,
        "pr_file": "packages/cli/src/ui/hooks/useKeypress.ts",
        "discussion_id": "2173885008",
        "commented_code": "@@ -47,58 +67,259 @@ export function useKeypress(\n     }\n \n     setRawMode(true);\n-\n     const rl = readline.createInterface({ input: stdin });\n-    let isPaste = false;\n-    let pasteBuffer = Buffer.alloc(0);\n-\n-    const handleKeypress = (_: unknown, key: Key) => {\n-      if (key.name === 'paste-start') {\n-        isPaste = true;\n-      } else if (key.name === 'paste-end') {\n-        isPaste = false;\n+    readline.emitKeypressEvents(stdin, rl);\n+\n+    // Detect bracketed paste support\n+    const term = process.env.TERM?.toLowerCase() || '';\n+    const knownSupportedTerms = [\n+      'xterm',\n+      'screen',\n+      'tmux',\n+      'rxvt',\n+      'linux',\n+      'cygwin',\n+      'st',\n+      'alacritty',\n+      'kitty',\n+    ];\n+    const isLikelySupported =\n+      stdin.writable &&\n+      knownSupportedTerms.some((supportedTerm) => term.includes(supportedTerm));\n+\n+    if (isLikelySupported) {\n+      try {\n+        stdin.write('\\x1b[?2004h');\n+        isBracketedPasteSupportedRef.current = true;\n+      } catch (err) {\n+        isBracketedPasteSupportedRef.current = false;\n+      }\n+    }\n+\n+    const maxInputDelay = 50; // Milliseconds, for reliable paste detection\n+    const pasteTimeoutDuration = 1000; // 1 second for unterminated pastes\n+    const startMarker = '\\x1b[200~';\n+    const endMarker = '\\x1b[201~';\n+\n+    const handleInput = () => {\n+      const keys = keyBufferRef.current;\n+      if (keys.length === 0) return;\n+\n+      // Combine all keypresses in the buffer as a paste\n+      const combinedSequence = keys.map((key) => key.sequence).join('');\n+      onKeypressRef.current({\n+        name: '',\n+        ctrl: false,\n+        meta: false,\n+        shift: false,\n+        paste: true,\n+        sequence: combinedSequence,\n+      });\n+\n+      keyBufferRef.current = [];\n+      timeoutRef.current = null;\n+      pasteHandledRef.current = false; // Reset after paste processing\n+    };\n+\n+    const resetPasteState = () => {\n+      if (isPasteModeRef.current && pasteBufferRef.current.length > 0) {\n         onKeypressRef.current({\n           name: '',\n           ctrl: false,\n           meta: false,\n           shift: false,\n           paste: true,\n-          sequence: pasteBuffer.toString(),\n+          sequence: pasteBufferRef.current,\n         });\n-        pasteBuffer = Buffer.alloc(0);\n-      } else {\n-        if (isPaste) {\n-          pasteBuffer = Buffer.concat([pasteBuffer, Buffer.from(key.sequence)]);\n+      }\n+      isPasteModeRef.current = false;\n+      pasteBufferRef.current = '';\n+      pasteHandledRef.current = false;\n+      partialStartMarkerRef.current = '';\n+      if (pasteTimeoutRef.current) {\n+        clearTimeout(pasteTimeoutRef.current);\n+        pasteTimeoutRef.current = null;\n+      }\n+    };\n+\n+    const handleRawData = (data: Buffer) => {\n+      if (!isBracketedPasteSupportedRef.current) {\n+        return;\n+      }\n+\n+      let input = data.toString('utf-8');\n+\n+      if (partialStartMarkerRef.current.length > 0) {\n+        input = partialStartMarkerRef.current + input;\n+        partialStartMarkerRef.current = '';\n+      }\n+\n+      while (input.length > 0) {\n+        if (isPasteModeRef.current) {\n+          const endMarkerIndex = input.indexOf(endMarker);\n+          if (endMarkerIndex !== -1) {\n+            pasteBufferRef.current += input.slice(0, endMarkerIndex);\n+\n+            if (pasteBufferRef.current.length > 0) {\n+              pasteHandledRef.current = true;\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pasteBufferRef.current,\n+              });\n+              keyBufferRef.current = [];\n+              if (timeoutRef.current) clearTimeout(timeoutRef.current);\n+              timeoutRef.current = setTimeout(() => {\n+                pasteHandledRef.current = false;\n+                timeoutRef.current = null;\n+              }, maxInputDelay);\n+            }\n+\n+            isPasteModeRef.current = false;\n+            pasteBufferRef.current = '';\n+            if (pasteTimeoutRef.current) {\n+              clearTimeout(pasteTimeoutRef.current);\n+              pasteTimeoutRef.current = null;\n+            }\n+            input = input.slice(endMarkerIndex + endMarker.length);\n+          } else {\n+            pasteBufferRef.current += input;\n+            input = '';\n+          }\n         } else {\n-          // Handle special keys\n-          if (key.name === 'return' && key.sequence === '\\x1B\\r') {\n-            key.meta = true;\n+          const startMarkerIndex = input.indexOf(startMarker);\n+          const endMarkerIndex = input.indexOf(endMarker);\n+\n+          if (\n+            startMarkerIndex !== -1 &&\n+            (endMarkerIndex === -1 || startMarkerIndex < endMarkerIndex)\n+          ) {\n+            const regularInput = input.slice(0, startMarkerIndex);\n+            if (regularInput.length > 0) {\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: false,\n+                sequence: regularInput,\n+              });\n+            }\n+            isPasteModeRef.current = true;\n+            pasteBufferRef.current = '';\n+            input = input.slice(startMarkerIndex + startMarker.length);\n+            pasteTimeoutRef.current = setTimeout(\n+              resetPasteState,\n+              pasteTimeoutDuration,\n+            );\n+          } else if (endMarkerIndex !== -1) {\n+            const pastedContent = input.slice(0, endMarkerIndex);\n+            if (pastedContent.length > 0) {\n+              onKeypressRef.current({\n+                name: '',\n+                ctrl: false,\n+                meta: false,\n+                shift: false,\n+                paste: true,\n+                sequence: pastedContent,\n+              });\n+            }\n+            input = input.slice(endMarkerIndex + endMarker.length);\n+          } else {\n+            if (startMarker.startsWith(input)) {\n+              partialStartMarkerRef.current = input;\n+              input = '';\n+            } else {\n+              if (input.length > 0) {\n+                onKeypressRef.current({\n+                  name: '',\n+                  ctrl: false,\n+                  meta: false,\n+                  shift: false,\n+                  paste: false,\n+                  sequence: input,\n+                });\n+              }\n+              input = '';\n+            }\n           }\n-          onKeypressRef.current({ ...key, paste: isPaste });\n         }",
        "comment_created_at": "2025-06-29T19:21:42+00:00",
        "comment_author": "jjborie",
        "comment_body": "Modified handleRawData to only process bracketed paste sequences, letting readline handle regular keypresses. Removed unnecessary event emissions and unreachable code. Added test to verify single keypress handling without duplication.",
        "pr_file_module": null
      }
    ]
  }
]