[
  {
    "discussion_id": "2223974408",
    "pr_number": 3936,
    "pr_file": "packages/cli/src/ui/hooks/vim.ts",
    "created_at": "2025-07-22T22:53:01+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useState, useRef, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+/**\n+ * Vim hook that handles all vim mode functionality including:\n+ * - Mode switching between INSERT and NORMAL modes\n+ * - Navigation commands (h, j, k, l, w, b, e, 0, $, ^, g, G, I, A) with count support\n+ * - Editing commands (x, a, i, o, O, d, c, D, C) with count support\n+ * - Complex commands (dd, cc, dw, cw, db, cb, de, ce, gg, etc.)\n+ * - Repeat last command (.)\n+ * - Settings persistence (vim mode state survives app restart)\n+ * - Escape behavior (move cursor left when exiting INSERT mode, clear pending operations)\n+ * - Consolidated input handling to eliminate race conditions\n+ * - Direct handleInput exposure for integration with InputPrompt\n+ */\n+export function useVim(",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2223974408",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2223974408",
        "commented_code": "@@ -0,0 +1,1571 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useState, useRef, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+/**\n+ * Vim hook that handles all vim mode functionality including:\n+ * - Mode switching between INSERT and NORMAL modes\n+ * - Navigation commands (h, j, k, l, w, b, e, 0, $, ^, g, G, I, A) with count support\n+ * - Editing commands (x, a, i, o, O, d, c, D, C) with count support\n+ * - Complex commands (dd, cc, dw, cw, db, cb, de, ce, gg, etc.)\n+ * - Repeat last command (.)\n+ * - Settings persistence (vim mode state survives app restart)\n+ * - Escape behavior (move cursor left when exiting INSERT mode, clear pending operations)\n+ * - Consolidated input handling to eliminate race conditions\n+ * - Direct handleInput exposure for integration with InputPrompt\n+ */\n+export function useVim(",
        "comment_created_at": "2025-07-22T22:53:01+00:00",
        "comment_author": "jacob314",
        "comment_body": "Gemini CLI should be able to help you refactor this hook to better align with the Gemini CLI style guide. I would encourage you to do the following to help get this to align better with the GEMINI.md in the project.\nI gave Gemini CLI the following prompt\n\"analyze @vim.ts focusing on ways it might not be aligned with this repos GEMINI.md which has specific instructions on how to use React\"\n\n\n   1. **State Management and Performance:** The hook uses multiple useState calls for interdependent state variables (mode, count, pendingG, pendingD, pendingC). This creates a complex\n      state machine that can lead to unnecessary re-renders. For instance, every keypress in NORMAL mode that is part of a count (e.g., typing \"12\") triggers a state update and\n      re-render. A more performant approach would be to manage the Vim state in a single useReducer or a useRef to avoid re-renders on every minor state change.\n[Jacob's thoughts] if we can solve this with useReducer that would be ideal. If not, I would suggest useRef. I would also worry about the current design breaking down if multiple key presses are sent in quick succession before react has time to recompute. what you are doing using useRef for entering and leaving insert mode solves it for that option but does not handle the other state.\n\n   2. **Overuse of `useCallback`**: Many of the functions wrapped in useCallback have empty dependency arrays, which suggests they do not depend on component props or state. While this\n      prevents them from being recreated on every render, it also adds boilerplate and can be a sign that these functions could be defined outside the component if they do not rely on\n       component-specific data.\n\n   3. **Complex Side Effects and State Synchronization:** The hook uses a useEffect to synchronize the mode state with a modeRef. This is a workaround for accessing the current mode\n      within the handleInput callback, which has a stale closure over the mode state. This pattern is a known \"code smell\" in React and can often be avoided by using useReducer or by\n      structuring the code to pass the latest state directly to event handlers.\nMy thoughts: if you are able to useReducer for this that would be ideal but I suspect it may not be feasible for your case.\n\n[Jacob's thoughts:] Ignore suggestion 4. I think your code is quite elegant given the difficulty of the problem it is solving. \n   4. Readability and Maintainability: The handleInput function is extremely large and contains a deeply nested switch statement. This makes it difficult to read, test, and maintain.\n      Breaking this logic down into smaller, more focused functions would significantly improve the code's clarity and align with the GEMINI.md's emphasis on simplicity and\n      readability.",
        "pr_file_module": null
      },
      {
        "comment_id": "2224704966",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2223974408",
        "commented_code": "@@ -0,0 +1,1571 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useState, useRef, useEffect } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+/**\n+ * Vim hook that handles all vim mode functionality including:\n+ * - Mode switching between INSERT and NORMAL modes\n+ * - Navigation commands (h, j, k, l, w, b, e, 0, $, ^, g, G, I, A) with count support\n+ * - Editing commands (x, a, i, o, O, d, c, D, C) with count support\n+ * - Complex commands (dd, cc, dw, cw, db, cb, de, ce, gg, etc.)\n+ * - Repeat last command (.)\n+ * - Settings persistence (vim mode state survives app restart)\n+ * - Escape behavior (move cursor left when exiting INSERT mode, clear pending operations)\n+ * - Consolidated input handling to eliminate race conditions\n+ * - Direct handleInput exposure for integration with InputPrompt\n+ */\n+export function useVim(",
        "comment_created_at": "2025-07-23T07:45:56+00:00",
        "comment_author": "sijieamoy",
        "comment_body": "Done refactoring. Here's a summary:\r\n\r\n1. State Management and Performance: The hook has been refactored to use useReducer for managing all Vim-related state (mode, count, pending states, etc.). This centralizes state logic, improves performance by reducing re-renders, and eliminates potential race conditions from multiple useState calls.\r\n\r\n2. `useCallback` Usage: The use of useCallback has been refined. Pure utility functions (findNextWordStart, findPrevWordStart, findWordEnd) have been moved outside the hook, removing unnecessary memoization. The remaining uses of useCallback for handleInput and toggleVimMode are appropriate as they depend on component state and props.\r\n\r\n3. Side Effects and State Synchronization: The useEffect hook that was used to synchronize state with a useRef has been removed. The useReducer implementation naturally solves the problem of stale closures, making the code cleaner and easier to understand.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2226658616",
    "pr_number": 3936,
    "pr_file": "packages/cli/src/ui/hooks/vim.ts",
    "created_at": "2025-07-23T20:48:09+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useState } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const LINE_SEPARATOR = '\n';\n+const WHITESPACE_CHARS = /\\s/;\n+const WORD_CHARS = /\\w/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved outside the hook to avoid unnecessary useCallback usage\n+const findNextWordStart = (text: string, currentOffset: number): number => {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2226658616",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2226658616",
        "commented_code": "@@ -0,0 +1,1420 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useState } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const LINE_SEPARATOR = '\\n';\n+const WHITESPACE_CHARS = /\\s/;\n+const WORD_CHARS = /\\w/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved outside the hook to avoid unnecessary useCallback usage\n+const findNextWordStart = (text: string, currentOffset: number): number => {",
        "comment_created_at": "2025-07-23T20:48:09+00:00",
        "comment_author": "jacob314",
        "comment_body": "these two utilities should also go into text-buffer.ts as they also need to be integrated in with the reducer in text-buffer otherwise we are operating on stale input in the even that multiple keystrokes were handled in the same React event loop.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2226670743",
    "pr_number": 3936,
    "pr_file": "packages/cli/src/ui/hooks/vim.ts",
    "created_at": "2025-07-23T20:55:07+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useState } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const LINE_SEPARATOR = '\n';\n+const WHITESPACE_CHARS = /\\s/;\n+const WORD_CHARS = /\\w/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved outside the hook to avoid unnecessary useCallback usage\n+const findNextWordStart = (text: string, currentOffset: number): number => {\n+  let i = currentOffset;\n+\n+  if (i >= text.length) return i;\n+\n+  const currentChar = text[i];\n+\n+  // Skip current word/sequence based on character type\n+  if (WORD_CHARS.test(currentChar)) {\n+    // Skip current word characters\n+    while (i < text.length && WORD_CHARS.test(text[i])) {\n+      i++;\n+    }\n+  } else if (!WHITESPACE_CHARS.test(currentChar)) {\n+    // Skip current non-word, non-whitespace characters (like \"/\", \".\", etc.)\n+    while (\n+      i < text.length &&\n+      !WORD_CHARS.test(text[i]) &&\n+      !WHITESPACE_CHARS.test(text[i])\n+    ) {\n+      i++;\n+    }\n+  }\n+\n+  // Skip whitespace\n+  while (i < text.length && WHITESPACE_CHARS.test(text[i])) {\n+    i++;\n+  }\n+\n+  // If we reached the end of text and there's no next word,\n+  // vim behavior for dw is to delete to the end of the current word\n+  if (i >= text.length) {\n+    // Go back to find the end of the last word\n+    let endOfLastWord = text.length - 1;\n+    while (endOfLastWord >= 0 && WHITESPACE_CHARS.test(text[endOfLastWord])) {\n+      endOfLastWord--;\n+    }\n+    // For dw on last word, return position AFTER the last character to delete entire word\n+    return Math.max(currentOffset + 1, endOfLastWord + 1);\n+  }\n+\n+  return i;\n+};\n+\n+const findPrevWordStart = (text: string, currentOffset: number): number => {\n+  let i = currentOffset;\n+\n+  // If at beginning of text, return current position\n+  if (i <= 0) {\n+    return currentOffset;\n+  }\n+\n+  // Move back one character to start searching\n+  i--;\n+\n+  // Skip whitespace moving backwards\n+  while (i >= 0 && (text[i] === ' ' || text[i] === '\\t' || text[i] === '\n')) {\n+    i--;\n+  }\n+\n+  if (i < 0) {\n+    return 0; // Reached beginning of text\n+  }\n+\n+  const charAtI = text[i];\n+\n+  if (WORD_CHARS.test(charAtI)) {\n+    // We're in a word, move to its beginning\n+    while (i >= 0 && WORD_CHARS.test(text[i])) {\n+      i--;\n+    }\n+    return i + 1; // Return first character of word\n+  } else {\n+    // We're in punctuation, move to its beginning\n+    while (\n+      i >= 0 &&\n+      !WORD_CHARS.test(text[i]) &&\n+      text[i] !== ' ' &&\n+      text[i] !== '\\t' &&\n+      text[i] !== LINE_SEPARATOR\n+    ) {\n+      i--;\n+    }\n+    return i + 1; // Return first character of punctuation sequence\n+  }\n+};\n+\n+const findWordEnd = (text: string, currentOffset: number): number => {\n+  let i = currentOffset;\n+\n+  // If we're not on a word character, find the next word\n+  if (!WORD_CHARS.test(text[i])) {\n+    while (i < text.length && !WORD_CHARS.test(text[i])) {\n+      i++;\n+    }\n+  }\n+\n+  // Move to end of current word\n+  while (i < text.length && WORD_CHARS.test(text[i])) {\n+    i++;\n+  }\n+\n+  // Move back one to be on the last character of the word\n+  return Math.max(currentOffset, i - 1);\n+};\n+\n+// Helper function to clear pending state\n+const createClearPendingState = () => ({\n+  count: 0,\n+  pendingG: false,\n+  pendingD: false,\n+  pendingC: false,\n+});\n+\n+// State and action types for useReducer\n+type VimState = {\n+  mode: VimMode;\n+  count: number;\n+  pendingG: boolean;\n+  pendingD: boolean;\n+  pendingC: boolean;\n+  lastCommand: { type: string; count: number } | null;\n+};\n+\n+type VimAction =\n+  | { type: 'SET_MODE'; mode: VimMode }\n+  | { type: 'SET_COUNT'; count: number }\n+  | { type: 'INCREMENT_COUNT'; digit: number }\n+  | { type: 'CLEAR_COUNT' }\n+  | { type: 'SET_PENDING_G'; pending: boolean }\n+  | { type: 'SET_PENDING_D'; pending: boolean }\n+  | { type: 'SET_PENDING_C'; pending: boolean }\n+  | {\n+      type: 'SET_LAST_COMMAND';\n+      command: { type: string; count: number } | null;\n+    }\n+  | { type: 'CLEAR_PENDING_STATES' }\n+  | { type: 'ESCAPE_TO_NORMAL' };\n+\n+const initialVimState: VimState = {\n+  mode: 'NORMAL',\n+  count: 0,\n+  pendingG: false,\n+  pendingD: false,\n+  pendingC: false,\n+  lastCommand: null,\n+};\n+\n+// Reducer function\n+const vimReducer = (state: VimState, action: VimAction): VimState => {\n+  switch (action.type) {\n+    case 'SET_MODE':\n+      return { ...state, mode: action.mode };\n+\n+    case 'SET_COUNT':\n+      return { ...state, count: action.count };\n+\n+    case 'INCREMENT_COUNT':\n+      return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };\n+\n+    case 'CLEAR_COUNT':\n+      return { ...state, count: 0 };\n+\n+    case 'SET_PENDING_G':\n+      return { ...state, pendingG: action.pending };\n+\n+    case 'SET_PENDING_D':\n+      return { ...state, pendingD: action.pending };\n+\n+    case 'SET_PENDING_C':\n+      return { ...state, pendingC: action.pending };\n+\n+    case 'SET_LAST_COMMAND':\n+      return { ...state, lastCommand: action.command };\n+\n+    case 'CLEAR_PENDING_STATES':\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    case 'ESCAPE_TO_NORMAL':\n+      // Handle escape - switch to NORMAL mode and clear all pending states\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+        mode: 'NORMAL',\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+/**\n+ * React hook that provides vim-style editing functionality for text input.\n+ *\n+ * Features:\n+ * - Modal editing (INSERT/NORMAL modes)\n+ * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes\n+ * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes\n+ * - Complex operations: dd,cc,dw,cw,db,cb,de,ce\n+ * - Command repetition (.)\n+ * - Settings persistence\n+ *\n+ * @param buffer - TextBuffer instance for text manipulation\n+ * @param settings - LoadedSettings for vim mode configuration\n+ * @param onSubmit - Optional callback for command submission\n+ * @returns Object with vim state and input handler\n+ */\n+export function useVim(\n+  buffer: TextBuffer,\n+  settings: LoadedSettings,\n+  onSubmit?: (value: string) => void,\n+) {\n+  const [state, dispatch] = useReducer(vimReducer, initialVimState);\n+  const [runtimeVimModeOverride, setRuntimeVimModeOverride] = useState<\n+    boolean | null\n+  >(null);\n+\n+  // Helper functions using the reducer state\n+  const getCurrentCount = useCallback(\n+    () => state.count || DEFAULT_COUNT,\n+    [state.count],\n+  );\n+\n+  const getCurrentOffset = useCallback(() => {\n+    const lines = buffer.lines;\n+    const [row, col] = buffer.cursor;\n+    let offset = 0;\n+\n+    for (let i = 0; i < row; i++) {\n+      offset += lines[i].length + 1; // +1 for newline\n+    }\n+    offset += col;\n+\n+    return offset;\n+  }, [buffer.lines, buffer.cursor]);\n+\n+  const setOffsetPosition = useCallback(\n+    (offset: number) => {\n+      buffer.moveToOffset(offset);\n+    },\n+    [buffer],\n+  );\n+\n+  /** Converts row/col position to absolute text offset */\n+  const getOffsetFromPosition = useCallback(\n+    (row: number, col: number) => {\n+      let offset = 0;\n+      for (let i = 0; i < row; i++) {\n+        offset += buffer.lines[i].length + 1; // +1 for newline\n+      }\n+      offset += col;\n+      return offset;\n+    },\n+    [buffer.lines],\n+  );\n+\n+  /** Calculates start/end offsets for multi-line operations like dd, cc */\n+  const getLineRangeOffsets = useCallback(\n+    (startRow: number, lineCount: number) => {\n+      const totalLines = buffer.lines.length;\n+      const actualLineCount = Math.min(lineCount, totalLines - startRow);\n+\n+      let startOffset = 0;\n+      for (let row = 0; row < startRow; row++) {\n+        startOffset += buffer.lines[row].length + 1;\n+      }\n+\n+      let endOffset = startOffset;\n+      for (let i = 0; i < actualLineCount; i++) {\n+        const lineIndex = startRow + i;\n+        if (lineIndex < totalLines) {\n+          endOffset += buffer.lines[lineIndex].length;\n+          if (lineIndex < totalLines - 1) {\n+            endOffset += 1; // +1 for newline, except for last line\n+          } else if (startRow > 0) {\n+            // Last line - include the newline before it\n+            startOffset -= 1;\n+          }\n+        }\n+      }\n+\n+      return { startOffset, endOffset, actualLineCount };\n+    },\n+    [buffer.lines],\n+  );\n+\n+  /** Handles change operations for directional movement (ch, cj, ck, cl) */\n+  const handleChangeMovement = useCallback(\n+    (movementType: 'h' | 'j' | 'k' | 'l', count: number) => {\n+      const currentRow = buffer.cursor[0];\n+      const currentCol = buffer.cursor[1];\n+\n+      switch (movementType) {\n+        case 'h': {\n+          // Change N characters to the left\n+          for (let i = 0; i < count; i++) {\n+            if (currentCol > 0) {\n+              buffer.move('left');\n+              buffer.del();\n+            }\n+          }\n+          break;\n+        }\n+\n+        case 'j': {\n+          // Change from current line down N lines\n+          const totalLines = buffer.lines.length;\n+          const linesToChange = Math.min(count + 1, totalLines - currentRow);\n+\n+          if (totalLines === 1) {\n+            const currentLine = buffer.lines[0] || '';\n+            buffer.replaceRangeByOffset(0, currentLine.length, '');\n+          } else {\n+            const { startOffset, endOffset } = getLineRangeOffsets(\n+              currentRow,\n+              linesToChange,\n+            );\n+            buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+          }\n+          break;\n+        }\n+\n+        case 'k': {\n+          // Change from current line up N lines\n+          const linesToChange = Math.min(count + 1, currentRow + 1);\n+          const startRow = currentRow - count;\n+\n+          if (buffer.lines.length === 1) {\n+            const currentLine = buffer.lines[0] || '';\n+            buffer.replaceRangeByOffset(0, currentLine.length, '');\n+          } else {\n+            const { startOffset, endOffset } = getLineRangeOffsets(\n+              Math.max(0, startRow),\n+              linesToChange,\n+            );\n+            buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+            buffer.moveToOffset(startOffset);\n+          }\n+          break;\n+        }\n+\n+        case 'l': {\n+          // Change N characters to the right\n+          for (let i = 0; i < count; i++) {\n+            buffer.del();\n+          }\n+          break;\n+        }\n+\n+        default:\n+          // This should never happen due to type constraints\n+          break;\n+      }\n+\n+      dispatch({ type: 'SET_MODE', mode: 'INSERT' });\n+      const cmdTypeMap = {\n+        h: CMD_TYPES.CHANGE_MOVEMENT.LEFT,\n+        j: CMD_TYPES.CHANGE_MOVEMENT.DOWN,\n+        k: CMD_TYPES.CHANGE_MOVEMENT.UP,\n+        l: CMD_TYPES.CHANGE_MOVEMENT.RIGHT,\n+      } as const;\n+\n+      dispatch({\n+        type: 'SET_LAST_COMMAND',\n+        command: { type: cmdTypeMap[movementType], count },\n+      });\n+      dispatch({ type: 'SET_PENDING_C', pending: false });\n+    },\n+    [buffer, getLineRangeOffsets, dispatch],\n+  );\n+\n+  /** Handles end-of-line operations (D, C) */\n+  const handleEndOfLineOperation = useCallback(\n+    (shouldEnterInsertMode: boolean) => {\n+      const currentRow = buffer.cursor[0];\n+      const currentCol = buffer.cursor[1];\n+      const currentLine = buffer.lines[currentRow] || '';\n+\n+      if (currentCol < currentLine.length) {\n+        const startOffset = getOffsetFromPosition(currentRow, currentCol);\n+        const endOffset = startOffset + (currentLine.length - currentCol);\n+        buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+      }\n+\n+      if (shouldEnterInsertMode) {\n+        dispatch({ type: 'SET_MODE', mode: 'INSERT' });\n+      }\n+    },\n+    [buffer, getOffsetFromPosition, dispatch],\n+  );\n+\n+  /** Executes common commands to eliminate duplication in dot (.) repeat command */\n+  const executeCommand = useCallback(\n+    (cmdType: string, count: number) => {\n+      switch (cmdType) {\n+        case CMD_TYPES.DELETE_WORD_FORWARD: {\n+          buffer.vimDeleteWordForward(count);\n+          break;\n+        }\n+\n+        case CMD_TYPES.DELETE_WORD_BACKWARD: {\n+          buffer.vimDeleteWordBackward(count);\n+          break;\n+        }\n+\n+        case CMD_TYPES.DELETE_WORD_END: {\n+          const text = buffer.text;",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2226670743",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3936,
        "pr_file": "packages/cli/src/ui/hooks/vim.ts",
        "discussion_id": "2226670743",
        "commented_code": "@@ -0,0 +1,1420 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import { useCallback, useReducer, useState } from 'react';\n+import type { Key } from './useKeypress.js';\n+import type { TextBuffer } from '../components/shared/text-buffer.js';\n+import type { LoadedSettings } from '../../config/settings.js';\n+import { SettingScope } from '../../config/settings.js';\n+\n+export type VimMode = 'NORMAL' | 'INSERT';\n+\n+// Constants\n+const DIGIT_MULTIPLIER = 10;\n+const DEFAULT_COUNT = 1;\n+const LINE_SEPARATOR = '\\n';\n+const WHITESPACE_CHARS = /\\s/;\n+const WORD_CHARS = /\\w/;\n+const DIGIT_1_TO_9 = /^[1-9]$/;\n+\n+// Command types\n+const CMD_TYPES = {\n+  DELETE_WORD_FORWARD: 'dw',\n+  DELETE_WORD_BACKWARD: 'db',\n+  DELETE_WORD_END: 'de',\n+  CHANGE_WORD_FORWARD: 'cw',\n+  CHANGE_WORD_BACKWARD: 'cb',\n+  CHANGE_WORD_END: 'ce',\n+  DELETE_CHAR: 'x',\n+  DELETE_LINE: 'dd',\n+  CHANGE_LINE: 'cc',\n+  DELETE_TO_EOL: 'D',\n+  CHANGE_TO_EOL: 'C',\n+  CHANGE_MOVEMENT: {\n+    LEFT: 'ch',\n+    DOWN: 'cj',\n+    UP: 'ck',\n+    RIGHT: 'cl',\n+  },\n+} as const;\n+\n+// Utility functions moved outside the hook to avoid unnecessary useCallback usage\n+const findNextWordStart = (text: string, currentOffset: number): number => {\n+  let i = currentOffset;\n+\n+  if (i >= text.length) return i;\n+\n+  const currentChar = text[i];\n+\n+  // Skip current word/sequence based on character type\n+  if (WORD_CHARS.test(currentChar)) {\n+    // Skip current word characters\n+    while (i < text.length && WORD_CHARS.test(text[i])) {\n+      i++;\n+    }\n+  } else if (!WHITESPACE_CHARS.test(currentChar)) {\n+    // Skip current non-word, non-whitespace characters (like \"/\", \".\", etc.)\n+    while (\n+      i < text.length &&\n+      !WORD_CHARS.test(text[i]) &&\n+      !WHITESPACE_CHARS.test(text[i])\n+    ) {\n+      i++;\n+    }\n+  }\n+\n+  // Skip whitespace\n+  while (i < text.length && WHITESPACE_CHARS.test(text[i])) {\n+    i++;\n+  }\n+\n+  // If we reached the end of text and there's no next word,\n+  // vim behavior for dw is to delete to the end of the current word\n+  if (i >= text.length) {\n+    // Go back to find the end of the last word\n+    let endOfLastWord = text.length - 1;\n+    while (endOfLastWord >= 0 && WHITESPACE_CHARS.test(text[endOfLastWord])) {\n+      endOfLastWord--;\n+    }\n+    // For dw on last word, return position AFTER the last character to delete entire word\n+    return Math.max(currentOffset + 1, endOfLastWord + 1);\n+  }\n+\n+  return i;\n+};\n+\n+const findPrevWordStart = (text: string, currentOffset: number): number => {\n+  let i = currentOffset;\n+\n+  // If at beginning of text, return current position\n+  if (i <= 0) {\n+    return currentOffset;\n+  }\n+\n+  // Move back one character to start searching\n+  i--;\n+\n+  // Skip whitespace moving backwards\n+  while (i >= 0 && (text[i] === ' ' || text[i] === '\\t' || text[i] === '\\n')) {\n+    i--;\n+  }\n+\n+  if (i < 0) {\n+    return 0; // Reached beginning of text\n+  }\n+\n+  const charAtI = text[i];\n+\n+  if (WORD_CHARS.test(charAtI)) {\n+    // We're in a word, move to its beginning\n+    while (i >= 0 && WORD_CHARS.test(text[i])) {\n+      i--;\n+    }\n+    return i + 1; // Return first character of word\n+  } else {\n+    // We're in punctuation, move to its beginning\n+    while (\n+      i >= 0 &&\n+      !WORD_CHARS.test(text[i]) &&\n+      text[i] !== ' ' &&\n+      text[i] !== '\\t' &&\n+      text[i] !== LINE_SEPARATOR\n+    ) {\n+      i--;\n+    }\n+    return i + 1; // Return first character of punctuation sequence\n+  }\n+};\n+\n+const findWordEnd = (text: string, currentOffset: number): number => {\n+  let i = currentOffset;\n+\n+  // If we're not on a word character, find the next word\n+  if (!WORD_CHARS.test(text[i])) {\n+    while (i < text.length && !WORD_CHARS.test(text[i])) {\n+      i++;\n+    }\n+  }\n+\n+  // Move to end of current word\n+  while (i < text.length && WORD_CHARS.test(text[i])) {\n+    i++;\n+  }\n+\n+  // Move back one to be on the last character of the word\n+  return Math.max(currentOffset, i - 1);\n+};\n+\n+// Helper function to clear pending state\n+const createClearPendingState = () => ({\n+  count: 0,\n+  pendingG: false,\n+  pendingD: false,\n+  pendingC: false,\n+});\n+\n+// State and action types for useReducer\n+type VimState = {\n+  mode: VimMode;\n+  count: number;\n+  pendingG: boolean;\n+  pendingD: boolean;\n+  pendingC: boolean;\n+  lastCommand: { type: string; count: number } | null;\n+};\n+\n+type VimAction =\n+  | { type: 'SET_MODE'; mode: VimMode }\n+  | { type: 'SET_COUNT'; count: number }\n+  | { type: 'INCREMENT_COUNT'; digit: number }\n+  | { type: 'CLEAR_COUNT' }\n+  | { type: 'SET_PENDING_G'; pending: boolean }\n+  | { type: 'SET_PENDING_D'; pending: boolean }\n+  | { type: 'SET_PENDING_C'; pending: boolean }\n+  | {\n+      type: 'SET_LAST_COMMAND';\n+      command: { type: string; count: number } | null;\n+    }\n+  | { type: 'CLEAR_PENDING_STATES' }\n+  | { type: 'ESCAPE_TO_NORMAL' };\n+\n+const initialVimState: VimState = {\n+  mode: 'NORMAL',\n+  count: 0,\n+  pendingG: false,\n+  pendingD: false,\n+  pendingC: false,\n+  lastCommand: null,\n+};\n+\n+// Reducer function\n+const vimReducer = (state: VimState, action: VimAction): VimState => {\n+  switch (action.type) {\n+    case 'SET_MODE':\n+      return { ...state, mode: action.mode };\n+\n+    case 'SET_COUNT':\n+      return { ...state, count: action.count };\n+\n+    case 'INCREMENT_COUNT':\n+      return { ...state, count: state.count * DIGIT_MULTIPLIER + action.digit };\n+\n+    case 'CLEAR_COUNT':\n+      return { ...state, count: 0 };\n+\n+    case 'SET_PENDING_G':\n+      return { ...state, pendingG: action.pending };\n+\n+    case 'SET_PENDING_D':\n+      return { ...state, pendingD: action.pending };\n+\n+    case 'SET_PENDING_C':\n+      return { ...state, pendingC: action.pending };\n+\n+    case 'SET_LAST_COMMAND':\n+      return { ...state, lastCommand: action.command };\n+\n+    case 'CLEAR_PENDING_STATES':\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+      };\n+\n+    case 'ESCAPE_TO_NORMAL':\n+      // Handle escape - switch to NORMAL mode and clear all pending states\n+      return {\n+        ...state,\n+        ...createClearPendingState(),\n+        mode: 'NORMAL',\n+      };\n+\n+    default:\n+      return state;\n+  }\n+};\n+\n+/**\n+ * React hook that provides vim-style editing functionality for text input.\n+ *\n+ * Features:\n+ * - Modal editing (INSERT/NORMAL modes)\n+ * - Navigation: h,j,k,l,w,b,e,0,$,^,gg,G with count prefixes\n+ * - Editing: x,a,i,o,O,A,I,d,c,D,C with count prefixes\n+ * - Complex operations: dd,cc,dw,cw,db,cb,de,ce\n+ * - Command repetition (.)\n+ * - Settings persistence\n+ *\n+ * @param buffer - TextBuffer instance for text manipulation\n+ * @param settings - LoadedSettings for vim mode configuration\n+ * @param onSubmit - Optional callback for command submission\n+ * @returns Object with vim state and input handler\n+ */\n+export function useVim(\n+  buffer: TextBuffer,\n+  settings: LoadedSettings,\n+  onSubmit?: (value: string) => void,\n+) {\n+  const [state, dispatch] = useReducer(vimReducer, initialVimState);\n+  const [runtimeVimModeOverride, setRuntimeVimModeOverride] = useState<\n+    boolean | null\n+  >(null);\n+\n+  // Helper functions using the reducer state\n+  const getCurrentCount = useCallback(\n+    () => state.count || DEFAULT_COUNT,\n+    [state.count],\n+  );\n+\n+  const getCurrentOffset = useCallback(() => {\n+    const lines = buffer.lines;\n+    const [row, col] = buffer.cursor;\n+    let offset = 0;\n+\n+    for (let i = 0; i < row; i++) {\n+      offset += lines[i].length + 1; // +1 for newline\n+    }\n+    offset += col;\n+\n+    return offset;\n+  }, [buffer.lines, buffer.cursor]);\n+\n+  const setOffsetPosition = useCallback(\n+    (offset: number) => {\n+      buffer.moveToOffset(offset);\n+    },\n+    [buffer],\n+  );\n+\n+  /** Converts row/col position to absolute text offset */\n+  const getOffsetFromPosition = useCallback(\n+    (row: number, col: number) => {\n+      let offset = 0;\n+      for (let i = 0; i < row; i++) {\n+        offset += buffer.lines[i].length + 1; // +1 for newline\n+      }\n+      offset += col;\n+      return offset;\n+    },\n+    [buffer.lines],\n+  );\n+\n+  /** Calculates start/end offsets for multi-line operations like dd, cc */\n+  const getLineRangeOffsets = useCallback(\n+    (startRow: number, lineCount: number) => {\n+      const totalLines = buffer.lines.length;\n+      const actualLineCount = Math.min(lineCount, totalLines - startRow);\n+\n+      let startOffset = 0;\n+      for (let row = 0; row < startRow; row++) {\n+        startOffset += buffer.lines[row].length + 1;\n+      }\n+\n+      let endOffset = startOffset;\n+      for (let i = 0; i < actualLineCount; i++) {\n+        const lineIndex = startRow + i;\n+        if (lineIndex < totalLines) {\n+          endOffset += buffer.lines[lineIndex].length;\n+          if (lineIndex < totalLines - 1) {\n+            endOffset += 1; // +1 for newline, except for last line\n+          } else if (startRow > 0) {\n+            // Last line - include the newline before it\n+            startOffset -= 1;\n+          }\n+        }\n+      }\n+\n+      return { startOffset, endOffset, actualLineCount };\n+    },\n+    [buffer.lines],\n+  );\n+\n+  /** Handles change operations for directional movement (ch, cj, ck, cl) */\n+  const handleChangeMovement = useCallback(\n+    (movementType: 'h' | 'j' | 'k' | 'l', count: number) => {\n+      const currentRow = buffer.cursor[0];\n+      const currentCol = buffer.cursor[1];\n+\n+      switch (movementType) {\n+        case 'h': {\n+          // Change N characters to the left\n+          for (let i = 0; i < count; i++) {\n+            if (currentCol > 0) {\n+              buffer.move('left');\n+              buffer.del();\n+            }\n+          }\n+          break;\n+        }\n+\n+        case 'j': {\n+          // Change from current line down N lines\n+          const totalLines = buffer.lines.length;\n+          const linesToChange = Math.min(count + 1, totalLines - currentRow);\n+\n+          if (totalLines === 1) {\n+            const currentLine = buffer.lines[0] || '';\n+            buffer.replaceRangeByOffset(0, currentLine.length, '');\n+          } else {\n+            const { startOffset, endOffset } = getLineRangeOffsets(\n+              currentRow,\n+              linesToChange,\n+            );\n+            buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+          }\n+          break;\n+        }\n+\n+        case 'k': {\n+          // Change from current line up N lines\n+          const linesToChange = Math.min(count + 1, currentRow + 1);\n+          const startRow = currentRow - count;\n+\n+          if (buffer.lines.length === 1) {\n+            const currentLine = buffer.lines[0] || '';\n+            buffer.replaceRangeByOffset(0, currentLine.length, '');\n+          } else {\n+            const { startOffset, endOffset } = getLineRangeOffsets(\n+              Math.max(0, startRow),\n+              linesToChange,\n+            );\n+            buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+            buffer.moveToOffset(startOffset);\n+          }\n+          break;\n+        }\n+\n+        case 'l': {\n+          // Change N characters to the right\n+          for (let i = 0; i < count; i++) {\n+            buffer.del();\n+          }\n+          break;\n+        }\n+\n+        default:\n+          // This should never happen due to type constraints\n+          break;\n+      }\n+\n+      dispatch({ type: 'SET_MODE', mode: 'INSERT' });\n+      const cmdTypeMap = {\n+        h: CMD_TYPES.CHANGE_MOVEMENT.LEFT,\n+        j: CMD_TYPES.CHANGE_MOVEMENT.DOWN,\n+        k: CMD_TYPES.CHANGE_MOVEMENT.UP,\n+        l: CMD_TYPES.CHANGE_MOVEMENT.RIGHT,\n+      } as const;\n+\n+      dispatch({\n+        type: 'SET_LAST_COMMAND',\n+        command: { type: cmdTypeMap[movementType], count },\n+      });\n+      dispatch({ type: 'SET_PENDING_C', pending: false });\n+    },\n+    [buffer, getLineRangeOffsets, dispatch],\n+  );\n+\n+  /** Handles end-of-line operations (D, C) */\n+  const handleEndOfLineOperation = useCallback(\n+    (shouldEnterInsertMode: boolean) => {\n+      const currentRow = buffer.cursor[0];\n+      const currentCol = buffer.cursor[1];\n+      const currentLine = buffer.lines[currentRow] || '';\n+\n+      if (currentCol < currentLine.length) {\n+        const startOffset = getOffsetFromPosition(currentRow, currentCol);\n+        const endOffset = startOffset + (currentLine.length - currentCol);\n+        buffer.replaceRangeByOffset(startOffset, endOffset, '');\n+      }\n+\n+      if (shouldEnterInsertMode) {\n+        dispatch({ type: 'SET_MODE', mode: 'INSERT' });\n+      }\n+    },\n+    [buffer, getOffsetFromPosition, dispatch],\n+  );\n+\n+  /** Executes common commands to eliminate duplication in dot (.) repeat command */\n+  const executeCommand = useCallback(\n+    (cmdType: string, count: number) => {\n+      switch (cmdType) {\n+        case CMD_TYPES.DELETE_WORD_FORWARD: {\n+          buffer.vimDeleteWordForward(count);\n+          break;\n+        }\n+\n+        case CMD_TYPES.DELETE_WORD_BACKWARD: {\n+          buffer.vimDeleteWordBackward(count);\n+          break;\n+        }\n+\n+        case CMD_TYPES.DELETE_WORD_END: {\n+          const text = buffer.text;",
        "comment_created_at": "2025-07-23T20:55:07+00:00",
        "comment_author": "jacob314",
        "comment_body": "this also needs to be integrated into text-buffer or we will hit issues when multiple keystrokes need to be processed in the same react event loop.",
        "pr_file_module": null
      }
    ]
  }
]