[
  {
    "discussion_id": "2211450180",
    "pr_number": 4107,
    "pr_file": "packages/cli/src/ui/utils/clipboardUtils.ts",
    "created_at": "2025-07-16T20:00:36+00:00",
    "commented_code": "const { stdout } = await execAsync(`osascript -e '${script}'`);\n \n+        if (stdout.trim() === 'success') {\n+          // Verify the file was created and has content\n+          try {\n+            const stats = await fs.stat(tempFilePath);\n+            if (stats.size > 0) {\n+              return tempFilePath;\n+            }\n+          } catch {\n+            // File doesn't exist, continue to next format\n+          }\n+        }\n+\n+        // Clean up failed attempt\n+        try {\n+          await fs.unlink(tempFilePath);\n+        } catch {\n+          // Ignore cleanup errors\n+        }\n+      }\n+    } else if (process.platform === 'win32') {\n+      // Windows: Use PowerShell to save clipboard image\n+      const tempFilePath = path.join(tempDir, `clipboard-${timestamp}.png`);\n+      \n+      // Use a different approach to avoid quote escaping issues\n+      const escapedPath = tempFilePath.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '`\"');",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2211450180",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4107,
        "pr_file": "packages/cli/src/ui/utils/clipboardUtils.ts",
        "discussion_id": "2211450180",
        "commented_code": "@@ -86,30 +92,62 @@ export async function saveClipboardImage(\n \n       const { stdout } = await execAsync(`osascript -e '${script}'`);\n \n+        if (stdout.trim() === 'success') {\n+          // Verify the file was created and has content\n+          try {\n+            const stats = await fs.stat(tempFilePath);\n+            if (stats.size > 0) {\n+              return tempFilePath;\n+            }\n+          } catch {\n+            // File doesn't exist, continue to next format\n+          }\n+        }\n+\n+        // Clean up failed attempt\n+        try {\n+          await fs.unlink(tempFilePath);\n+        } catch {\n+          // Ignore cleanup errors\n+        }\n+      }\n+    } else if (process.platform === 'win32') {\n+      // Windows: Use PowerShell to save clipboard image\n+      const tempFilePath = path.join(tempDir, `clipboard-${timestamp}.png`);\n+      \n+      // Use a different approach to avoid quote escaping issues\n+      const escapedPath = tempFilePath.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '`\"');",
        "comment_created_at": "2025-07-16T20:00:36+00:00",
        "comment_author": "jacob314",
        "comment_body": "rather than rolling our own shell escaping, it might make sense to use an existing npm package for this.\r\nhttps://www.npmjs.com/package/shescape?activeTab=code\r\nthis package isn't that popular so I am also open to just rolling our own or trying to find a popular package.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174814181",
    "pr_number": 2686,
    "pr_file": "packages/core/src/tools/tool-registry.ts",
    "created_at": "2025-06-30T11:13:51+00:00",
    "commented_code": "async execute(params: ToolParams): Promise<ToolResult> {\n     const callCommand = this.config.getToolCallCommand()!;\n-    const child = spawn(callCommand, [this.name]);\n+    \n+    // Validate the call command for security\n+    const commandError = validateToolCommand(callCommand);\n+    if (commandError) {\n+      return {\n+        llmContent: `Tool call command validation failed: ${commandError}`,\n+        returnDisplay: `Security Error: Invalid tool call command configuration`,\n+      };\n+    }\n+    \n+    // Validate the tool name for security\n+    const nameError = validateToolName(this.name);\n+    if (nameError) {\n+      return {\n+        llmContent: `Tool name validation failed: ${nameError}`,\n+        returnDisplay: `Security Error: Invalid tool name`,\n+      };\n+    }\n+    \n+    // Create secure execution environment\n+    const secureEnv = createSecureExecutionEnvironment();\n+    \n+    // Split command safely to get executable and base args\n+    const commandParts = callCommand.trim().split(/\\s+/);\n+    const executable = commandParts[0];\n+    const baseArgs = commandParts.slice(1);",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2174826392",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/tools/tool-registry.ts",
        "discussion_id": "2174814181",
        "commented_code": "@@ -50,7 +55,37 @@ Signal: Signal number or \\`(none)\\` if no signal was received.\n \n   async execute(params: ToolParams): Promise<ToolResult> {\n     const callCommand = this.config.getToolCallCommand()!;\n-    const child = spawn(callCommand, [this.name]);\n+    \n+    // Validate the call command for security\n+    const commandError = validateToolCommand(callCommand);\n+    if (commandError) {\n+      return {\n+        llmContent: `Tool call command validation failed: ${commandError}`,\n+        returnDisplay: `Security Error: Invalid tool call command configuration`,\n+      };\n+    }\n+    \n+    // Validate the tool name for security\n+    const nameError = validateToolName(this.name);\n+    if (nameError) {\n+      return {\n+        llmContent: `Tool name validation failed: ${nameError}`,\n+        returnDisplay: `Security Error: Invalid tool name`,\n+      };\n+    }\n+    \n+    // Create secure execution environment\n+    const secureEnv = createSecureExecutionEnvironment();\n+    \n+    // Split command safely to get executable and base args\n+    const commandParts = callCommand.trim().split(/\\s+/);\n+    const executable = commandParts[0];\n+    const baseArgs = commandParts.slice(1);",
        "comment_created_at": "2025-06-30T11:13:51+00:00",
        "comment_author": "maslinedwin",
        "comment_body": "fixed! Updated tool-registry.ts to use splitCommandSafely() instead of the unsafe split(/\\s+/). The discovery command\r\n  parsing now:\r\n\r\n  1. Uses splitCommandSafely() for proper quoted argument handling\r\n  2. Includes null check for malformed commands (unmatched quotes)\r\n  3. Gracefully handles parsing failures with appropriate error logging\r\n  4. Maintains secure execution while supporting complex discovery commands\r\n\r\n  This prevents misinterpretation of discovery commands and potential security bypasses.",
        "pr_file_module": null
      },
      {
        "comment_id": "2174835889",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/tools/tool-registry.ts",
        "discussion_id": "2174814181",
        "commented_code": "@@ -50,7 +55,37 @@ Signal: Signal number or \\`(none)\\` if no signal was received.\n \n   async execute(params: ToolParams): Promise<ToolResult> {\n     const callCommand = this.config.getToolCallCommand()!;\n-    const child = spawn(callCommand, [this.name]);\n+    \n+    // Validate the call command for security\n+    const commandError = validateToolCommand(callCommand);\n+    if (commandError) {\n+      return {\n+        llmContent: `Tool call command validation failed: ${commandError}`,\n+        returnDisplay: `Security Error: Invalid tool call command configuration`,\n+      };\n+    }\n+    \n+    // Validate the tool name for security\n+    const nameError = validateToolName(this.name);\n+    if (nameError) {\n+      return {\n+        llmContent: `Tool name validation failed: ${nameError}`,\n+        returnDisplay: `Security Error: Invalid tool name`,\n+      };\n+    }\n+    \n+    // Create secure execution environment\n+    const secureEnv = createSecureExecutionEnvironment();\n+    \n+    // Split command safely to get executable and base args\n+    const commandParts = callCommand.trim().split(/\\s+/);\n+    const executable = commandParts[0];\n+    const baseArgs = commandParts.slice(1);",
        "comment_created_at": "2025-06-30T11:19:32+00:00",
        "comment_author": "maslinedwin",
        "comment_body": "/gemini review",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174814186",
    "pr_number": 2686,
    "pr_file": "packages/core/src/tools/tool-registry.ts",
    "created_at": "2025-06-30T11:14:21+00:00",
    "commented_code": "// discover tools using discovery command, if configured\n     const discoveryCmd = this.config.getToolDiscoveryCommand();\n     if (discoveryCmd) {\n-      // execute discovery command and extract function declarations (w/ or w/o \"tool\" wrappers)\n-      const functions: FunctionDeclaration[] = [];\n-      for (const tool of JSON.parse(execSync(discoveryCmd).toString().trim())) {\n-        if (tool['function_declarations']) {\n-          functions.push(...tool['function_declarations']);\n-        } else if (tool['functionDeclarations']) {\n-          functions.push(...tool['functionDeclarations']);\n-        } else if (tool['name']) {\n-          functions.push(tool);\n-        }\n+      // Validate the discovery command for security\n+      const commandError = validateToolCommand(discoveryCmd);\n+      if (commandError) {\n+        console.error(`Tool discovery command validation failed: ${commandError}`);\n+        console.error(`Skipping tool discovery for security reasons. Command: ${discoveryCmd}`);\n+        return;\n       }\n-      // register each function as a tool\n-      for (const func of functions) {\n-        this.registerTool(\n-          new DiscoveredTool(\n-            this.config,\n-            func.name!,\n-            func.description!,\n-            func.parameters! as Record<string, unknown>,\n-          ),\n-        );\n+      \n+      // Create secure execution environment\n+      const secureEnv = createSecureExecutionEnvironment();\n+      \n+      // Split command safely to get executable and args\n+      const commandParts = discoveryCmd.trim().split(/\\s+/);\n+      const executable = commandParts[0];\n+      const args = commandParts.slice(1);",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2174827122",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/tools/tool-registry.ts",
        "discussion_id": "2174814186",
        "commented_code": "@@ -160,27 +195,71 @@ export class ToolRegistry {\n     // discover tools using discovery command, if configured\n     const discoveryCmd = this.config.getToolDiscoveryCommand();\n     if (discoveryCmd) {\n-      // execute discovery command and extract function declarations (w/ or w/o \"tool\" wrappers)\n-      const functions: FunctionDeclaration[] = [];\n-      for (const tool of JSON.parse(execSync(discoveryCmd).toString().trim())) {\n-        if (tool['function_declarations']) {\n-          functions.push(...tool['function_declarations']);\n-        } else if (tool['functionDeclarations']) {\n-          functions.push(...tool['functionDeclarations']);\n-        } else if (tool['name']) {\n-          functions.push(tool);\n-        }\n+      // Validate the discovery command for security\n+      const commandError = validateToolCommand(discoveryCmd);\n+      if (commandError) {\n+        console.error(`Tool discovery command validation failed: ${commandError}`);\n+        console.error(`Skipping tool discovery for security reasons. Command: ${discoveryCmd}`);\n+        return;\n       }\n-      // register each function as a tool\n-      for (const func of functions) {\n-        this.registerTool(\n-          new DiscoveredTool(\n-            this.config,\n-            func.name!,\n-            func.description!,\n-            func.parameters! as Record<string, unknown>,\n-          ),\n-        );\n+      \n+      // Create secure execution environment\n+      const secureEnv = createSecureExecutionEnvironment();\n+      \n+      // Split command safely to get executable and args\n+      const commandParts = discoveryCmd.trim().split(/\\s+/);\n+      const executable = commandParts[0];\n+      const args = commandParts.slice(1);",
        "comment_created_at": "2025-06-30T11:14:21+00:00",
        "comment_author": "maslinedwin",
        "comment_body": "Fixed! Replaced the unsafe split(/\\s+/) with the secure splitCommandSafely() function that properly handles quoted\r\n  arguments. The function now:\r\n\r\n  1. Uses splitCommandSafely() to parse commands correctly\r\n  2. Handles null return case when command parsing fails\r\n  3. Properly validates quoted executables without bypassing security checks\r\n  4. Maintains the isExecutableAllowed validation on the correct parsed executable\r\n\r\n  This ensures commands like 'my tool with spaces' are parsed correctly while maintaining security validation.",
        "pr_file_module": null
      },
      {
        "comment_id": "2174836175",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/tools/tool-registry.ts",
        "discussion_id": "2174814186",
        "commented_code": "@@ -160,27 +195,71 @@ export class ToolRegistry {\n     // discover tools using discovery command, if configured\n     const discoveryCmd = this.config.getToolDiscoveryCommand();\n     if (discoveryCmd) {\n-      // execute discovery command and extract function declarations (w/ or w/o \"tool\" wrappers)\n-      const functions: FunctionDeclaration[] = [];\n-      for (const tool of JSON.parse(execSync(discoveryCmd).toString().trim())) {\n-        if (tool['function_declarations']) {\n-          functions.push(...tool['function_declarations']);\n-        } else if (tool['functionDeclarations']) {\n-          functions.push(...tool['functionDeclarations']);\n-        } else if (tool['name']) {\n-          functions.push(tool);\n-        }\n+      // Validate the discovery command for security\n+      const commandError = validateToolCommand(discoveryCmd);\n+      if (commandError) {\n+        console.error(`Tool discovery command validation failed: ${commandError}`);\n+        console.error(`Skipping tool discovery for security reasons. Command: ${discoveryCmd}`);\n+        return;\n       }\n-      // register each function as a tool\n-      for (const func of functions) {\n-        this.registerTool(\n-          new DiscoveredTool(\n-            this.config,\n-            func.name!,\n-            func.description!,\n-            func.parameters! as Record<string, unknown>,\n-          ),\n-        );\n+      \n+      // Create secure execution environment\n+      const secureEnv = createSecureExecutionEnvironment();\n+      \n+      // Split command safely to get executable and args\n+      const commandParts = discoveryCmd.trim().split(/\\s+/);\n+      const executable = commandParts[0];\n+      const args = commandParts.slice(1);",
        "comment_created_at": "2025-06-30T11:19:42+00:00",
        "comment_author": "maslinedwin",
        "comment_body": "/gemini review",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174814194",
    "pr_number": 2686,
    "pr_file": "packages/core/src/utils/commandValidation.ts",
    "created_at": "2025-06-30T11:14:50+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as path from 'path';\n+import * as fs from 'fs';\n+\n+/**\n+ * Validates that a command is safe to execute by checking against an allowlist\n+ * of permitted executables and validating the command structure.\n+ */\n+export function validateToolCommand(command: string): string | null {\n+  if (!command || typeof command !== 'string') {\n+    return 'Command must be a non-empty string';\n+  }\n+\n+  const trimmed = command.trim();\n+  if (!trimmed) {\n+    return 'Command cannot be empty or whitespace only';\n+  }\n+\n+  // Split the command to get the executable and arguments\n+  const parts = trimmed.split(/\\s+/);\n+  const executable = parts[0];\n+\n+  // Check for obviously dangerous patterns\n+  if (containsDangerousPatterns(trimmed)) {\n+    return 'Command contains dangerous shell metacharacters or patterns';\n+  }\n+\n+  // Check for dangerous file access patterns\n+  if (containsSensitiveFileAccess(trimmed)) {\n+    return 'Command attempts to access sensitive system files or directories';\n+  }\n+\n+  // Validate the executable is in an allowlist of safe tools\n+  if (!isExecutableAllowed(executable)) {\n+    return `Executable '${executable}' is not in the allowlist of permitted tool discovery/call commands`;\n+  }\n+\n+  return null;\n+}\n+\n+/**\n+ * Checks if the command contains dangerous shell metacharacters or patterns\n+ */\n+function containsDangerousPatterns(command: string): boolean {\n+  // Dangerous patterns that could indicate shell injection\n+  const dangerousPatterns = [\n+    /[;&|`$(){}]/,           // Shell metacharacters\n+    /\\|\\||\\&\\&/,             // Logical operators\n+    /[<>]/,                  // Redirection\n+    /\\\\\\\\/,                  // Escaped characters (potential obfuscation)",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2174828069",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/utils/commandValidation.ts",
        "discussion_id": "2174814194",
        "commented_code": "@@ -0,0 +1,231 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as path from 'path';\n+import * as fs from 'fs';\n+\n+/**\n+ * Validates that a command is safe to execute by checking against an allowlist\n+ * of permitted executables and validating the command structure.\n+ */\n+export function validateToolCommand(command: string): string | null {\n+  if (!command || typeof command !== 'string') {\n+    return 'Command must be a non-empty string';\n+  }\n+\n+  const trimmed = command.trim();\n+  if (!trimmed) {\n+    return 'Command cannot be empty or whitespace only';\n+  }\n+\n+  // Split the command to get the executable and arguments\n+  const parts = trimmed.split(/\\s+/);\n+  const executable = parts[0];\n+\n+  // Check for obviously dangerous patterns\n+  if (containsDangerousPatterns(trimmed)) {\n+    return 'Command contains dangerous shell metacharacters or patterns';\n+  }\n+\n+  // Check for dangerous file access patterns\n+  if (containsSensitiveFileAccess(trimmed)) {\n+    return 'Command attempts to access sensitive system files or directories';\n+  }\n+\n+  // Validate the executable is in an allowlist of safe tools\n+  if (!isExecutableAllowed(executable)) {\n+    return `Executable '${executable}' is not in the allowlist of permitted tool discovery/call commands`;\n+  }\n+\n+  return null;\n+}\n+\n+/**\n+ * Checks if the command contains dangerous shell metacharacters or patterns\n+ */\n+function containsDangerousPatterns(command: string): boolean {\n+  // Dangerous patterns that could indicate shell injection\n+  const dangerousPatterns = [\n+    /[;&|`$(){}]/,           // Shell metacharacters\n+    /\\|\\||\\&\\&/,             // Logical operators\n+    /[<>]/,                  // Redirection\n+    /\\\\\\\\/,                  // Escaped characters (potential obfuscation)",
        "comment_created_at": "2025-06-30T11:14:50+00:00",
        "comment_author": "maslinedwin",
        "comment_body": "Removed! The overly broad /\\\\\\\\/ regex pattern has been completely removed from containsDangerousPatterns(). You're\r\n  absolutely right - this was causing functional regressions by blocking legitimate Windows paths like \"C:\\\\Users\\\\...\".\r\n\r\n  The other security checks (metacharacters, executable allowlist, etc.) provide sufficient protection without this\r\n  problematic pattern that breaks fundamental platform behavior.",
        "pr_file_module": null
      },
      {
        "comment_id": "2174836715",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/utils/commandValidation.ts",
        "discussion_id": "2174814194",
        "commented_code": "@@ -0,0 +1,231 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as path from 'path';\n+import * as fs from 'fs';\n+\n+/**\n+ * Validates that a command is safe to execute by checking against an allowlist\n+ * of permitted executables and validating the command structure.\n+ */\n+export function validateToolCommand(command: string): string | null {\n+  if (!command || typeof command !== 'string') {\n+    return 'Command must be a non-empty string';\n+  }\n+\n+  const trimmed = command.trim();\n+  if (!trimmed) {\n+    return 'Command cannot be empty or whitespace only';\n+  }\n+\n+  // Split the command to get the executable and arguments\n+  const parts = trimmed.split(/\\s+/);\n+  const executable = parts[0];\n+\n+  // Check for obviously dangerous patterns\n+  if (containsDangerousPatterns(trimmed)) {\n+    return 'Command contains dangerous shell metacharacters or patterns';\n+  }\n+\n+  // Check for dangerous file access patterns\n+  if (containsSensitiveFileAccess(trimmed)) {\n+    return 'Command attempts to access sensitive system files or directories';\n+  }\n+\n+  // Validate the executable is in an allowlist of safe tools\n+  if (!isExecutableAllowed(executable)) {\n+    return `Executable '${executable}' is not in the allowlist of permitted tool discovery/call commands`;\n+  }\n+\n+  return null;\n+}\n+\n+/**\n+ * Checks if the command contains dangerous shell metacharacters or patterns\n+ */\n+function containsDangerousPatterns(command: string): boolean {\n+  // Dangerous patterns that could indicate shell injection\n+  const dangerousPatterns = [\n+    /[;&|`$(){}]/,           // Shell metacharacters\n+    /\\|\\||\\&\\&/,             // Logical operators\n+    /[<>]/,                  // Redirection\n+    /\\\\\\\\/,                  // Escaped characters (potential obfuscation)",
        "comment_created_at": "2025-06-30T11:19:59+00:00",
        "comment_author": "maslinedwin",
        "comment_body": "/gemini review",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174814197",
    "pr_number": 2686,
    "pr_file": "packages/core/src/utils/commandValidation.ts",
    "created_at": "2025-06-30T11:15:05+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as path from 'path';\n+import * as fs from 'fs';\n+\n+/**\n+ * Validates that a command is safe to execute by checking against an allowlist\n+ * of permitted executables and validating the command structure.\n+ */\n+export function validateToolCommand(command: string): string | null {\n+  if (!command || typeof command !== 'string') {\n+    return 'Command must be a non-empty string';\n+  }\n+\n+  const trimmed = command.trim();\n+  if (!trimmed) {\n+    return 'Command cannot be empty or whitespace only';\n+  }\n+\n+  // Split the command to get the executable and arguments\n+  const parts = trimmed.split(/\\s+/);\n+  const executable = parts[0];\n+\n+  // Check for obviously dangerous patterns\n+  if (containsDangerousPatterns(trimmed)) {\n+    return 'Command contains dangerous shell metacharacters or patterns';\n+  }\n+\n+  // Check for dangerous file access patterns\n+  if (containsSensitiveFileAccess(trimmed)) {\n+    return 'Command attempts to access sensitive system files or directories';\n+  }\n+\n+  // Validate the executable is in an allowlist of safe tools\n+  if (!isExecutableAllowed(executable)) {\n+    return `Executable '${executable}' is not in the allowlist of permitted tool discovery/call commands`;\n+  }\n+\n+  return null;\n+}\n+\n+/**\n+ * Checks if the command contains dangerous shell metacharacters or patterns\n+ */\n+function containsDangerousPatterns(command: string): boolean {\n+  // Dangerous patterns that could indicate shell injection\n+  const dangerousPatterns = [\n+    /[;&|`$(){}]/,           // Shell metacharacters\n+    /\\|\\||\\&\\&/,             // Logical operators\n+    /[<>]/,                  // Redirection\n+    /\\\\\\\\/,                  // Escaped characters (potential obfuscation)\n+    /\\$\\{/,                  // Parameter expansion\n+    /\n|\\r/,                 // Newlines\n+    /^\\s*sudo\\s/i,           // Privilege escalation\n+    /^\\s*rm\\s/i,             // Dangerous file operations\n+    /^\\s*curl\\s.*\\|\\s*sh/i,  // Download and execute\n+    /^\\s*wget\\s.*\\|\\s*sh/i,  // Download and execute\n+  ];\n+\n+  return dangerousPatterns.some(pattern => pattern.test(command));\n+}\n+\n+/**\n+ * Checks if the command attempts to access sensitive system files or directories\n+ */\n+function containsSensitiveFileAccess(command: string): boolean {\n+  const sensitivePaths = [\n+    '/etc/passwd',\n+    '/etc/shadow',\n+    '/etc/sudoers',\n+    '/etc/hosts',\n+    '~/.ssh/',\n+    '~/.aws/',\n+    '~/.docker/',\n+    '/root/',\n+    '/proc/',\n+    '/sys/',\n+    '/dev/',\n+    'C:\\\\Windows\\\\System32',\n+    'C:\\\\Users\\\\',\n+    '%USERPROFILE%',\n+    '%APPDATA%',\n+    '%TEMP%'\n+  ];\n+\n+  const lowerCommand = command.toLowerCase();\n+  return sensitivePaths.some(path => lowerCommand.includes(path.toLowerCase()));\n+}",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2174828491",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/utils/commandValidation.ts",
        "discussion_id": "2174814197",
        "commented_code": "@@ -0,0 +1,231 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as path from 'path';\n+import * as fs from 'fs';\n+\n+/**\n+ * Validates that a command is safe to execute by checking against an allowlist\n+ * of permitted executables and validating the command structure.\n+ */\n+export function validateToolCommand(command: string): string | null {\n+  if (!command || typeof command !== 'string') {\n+    return 'Command must be a non-empty string';\n+  }\n+\n+  const trimmed = command.trim();\n+  if (!trimmed) {\n+    return 'Command cannot be empty or whitespace only';\n+  }\n+\n+  // Split the command to get the executable and arguments\n+  const parts = trimmed.split(/\\s+/);\n+  const executable = parts[0];\n+\n+  // Check for obviously dangerous patterns\n+  if (containsDangerousPatterns(trimmed)) {\n+    return 'Command contains dangerous shell metacharacters or patterns';\n+  }\n+\n+  // Check for dangerous file access patterns\n+  if (containsSensitiveFileAccess(trimmed)) {\n+    return 'Command attempts to access sensitive system files or directories';\n+  }\n+\n+  // Validate the executable is in an allowlist of safe tools\n+  if (!isExecutableAllowed(executable)) {\n+    return `Executable '${executable}' is not in the allowlist of permitted tool discovery/call commands`;\n+  }\n+\n+  return null;\n+}\n+\n+/**\n+ * Checks if the command contains dangerous shell metacharacters or patterns\n+ */\n+function containsDangerousPatterns(command: string): boolean {\n+  // Dangerous patterns that could indicate shell injection\n+  const dangerousPatterns = [\n+    /[;&|`$(){}]/,           // Shell metacharacters\n+    /\\|\\||\\&\\&/,             // Logical operators\n+    /[<>]/,                  // Redirection\n+    /\\\\\\\\/,                  // Escaped characters (potential obfuscation)\n+    /\\$\\{/,                  // Parameter expansion\n+    /\\n|\\r/,                 // Newlines\n+    /^\\s*sudo\\s/i,           // Privilege escalation\n+    /^\\s*rm\\s/i,             // Dangerous file operations\n+    /^\\s*curl\\s.*\\|\\s*sh/i,  // Download and execute\n+    /^\\s*wget\\s.*\\|\\s*sh/i,  // Download and execute\n+  ];\n+\n+  return dangerousPatterns.some(pattern => pattern.test(command));\n+}\n+\n+/**\n+ * Checks if the command attempts to access sensitive system files or directories\n+ */\n+function containsSensitiveFileAccess(command: string): boolean {\n+  const sensitivePaths = [\n+    '/etc/passwd',\n+    '/etc/shadow',\n+    '/etc/sudoers',\n+    '/etc/hosts',\n+    '~/.ssh/',\n+    '~/.aws/',\n+    '~/.docker/',\n+    '/root/',\n+    '/proc/',\n+    '/sys/',\n+    '/dev/',\n+    'C:\\\\Windows\\\\System32',\n+    'C:\\\\Users\\\\',\n+    '%USERPROFILE%',\n+    '%APPDATA%',\n+    '%TEMP%'\n+  ];\n+\n+  const lowerCommand = command.toLowerCase();\n+  return sensitivePaths.some(path => lowerCommand.includes(path.toLowerCase()));\n+}",
        "comment_created_at": "2025-06-30T11:15:05+00:00",
        "comment_author": "maslinedwin",
        "comment_body": " Fixed! The containsSensitiveFileAccess function now properly parses command arguments using splitCommandSafely() instead\r\n  of checking the entire command string. This prevents false positives like blocking \"C:\\\\Windows\\\\System32\\\\find.exe\" while\r\n   still detecting actual attempts to access sensitive paths in arguments.\r\n\r\n  The function now:\r\n  1. Parses the command safely to extract arguments\r\n  2. Only checks arguments (not the executable path) for sensitive file access\r\n  3. Avoids false positives on legitimate Windows system executables\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2174836981",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2686,
        "pr_file": "packages/core/src/utils/commandValidation.ts",
        "discussion_id": "2174814197",
        "commented_code": "@@ -0,0 +1,231 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+import * as path from 'path';\n+import * as fs from 'fs';\n+\n+/**\n+ * Validates that a command is safe to execute by checking against an allowlist\n+ * of permitted executables and validating the command structure.\n+ */\n+export function validateToolCommand(command: string): string | null {\n+  if (!command || typeof command !== 'string') {\n+    return 'Command must be a non-empty string';\n+  }\n+\n+  const trimmed = command.trim();\n+  if (!trimmed) {\n+    return 'Command cannot be empty or whitespace only';\n+  }\n+\n+  // Split the command to get the executable and arguments\n+  const parts = trimmed.split(/\\s+/);\n+  const executable = parts[0];\n+\n+  // Check for obviously dangerous patterns\n+  if (containsDangerousPatterns(trimmed)) {\n+    return 'Command contains dangerous shell metacharacters or patterns';\n+  }\n+\n+  // Check for dangerous file access patterns\n+  if (containsSensitiveFileAccess(trimmed)) {\n+    return 'Command attempts to access sensitive system files or directories';\n+  }\n+\n+  // Validate the executable is in an allowlist of safe tools\n+  if (!isExecutableAllowed(executable)) {\n+    return `Executable '${executable}' is not in the allowlist of permitted tool discovery/call commands`;\n+  }\n+\n+  return null;\n+}\n+\n+/**\n+ * Checks if the command contains dangerous shell metacharacters or patterns\n+ */\n+function containsDangerousPatterns(command: string): boolean {\n+  // Dangerous patterns that could indicate shell injection\n+  const dangerousPatterns = [\n+    /[;&|`$(){}]/,           // Shell metacharacters\n+    /\\|\\||\\&\\&/,             // Logical operators\n+    /[<>]/,                  // Redirection\n+    /\\\\\\\\/,                  // Escaped characters (potential obfuscation)\n+    /\\$\\{/,                  // Parameter expansion\n+    /\\n|\\r/,                 // Newlines\n+    /^\\s*sudo\\s/i,           // Privilege escalation\n+    /^\\s*rm\\s/i,             // Dangerous file operations\n+    /^\\s*curl\\s.*\\|\\s*sh/i,  // Download and execute\n+    /^\\s*wget\\s.*\\|\\s*sh/i,  // Download and execute\n+  ];\n+\n+  return dangerousPatterns.some(pattern => pattern.test(command));\n+}\n+\n+/**\n+ * Checks if the command attempts to access sensitive system files or directories\n+ */\n+function containsSensitiveFileAccess(command: string): boolean {\n+  const sensitivePaths = [\n+    '/etc/passwd',\n+    '/etc/shadow',\n+    '/etc/sudoers',\n+    '/etc/hosts',\n+    '~/.ssh/',\n+    '~/.aws/',\n+    '~/.docker/',\n+    '/root/',\n+    '/proc/',\n+    '/sys/',\n+    '/dev/',\n+    'C:\\\\Windows\\\\System32',\n+    'C:\\\\Users\\\\',\n+    '%USERPROFILE%',\n+    '%APPDATA%',\n+    '%TEMP%'\n+  ];\n+\n+  const lowerCommand = command.toLowerCase();\n+  return sensitivePaths.some(path => lowerCommand.includes(path.toLowerCase()));\n+}",
        "comment_created_at": "2025-06-30T11:20:09+00:00",
        "comment_author": "maslinedwin",
        "comment_body": "/gemini reivew",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2190303896",
    "pr_number": 3452,
    "pr_file": "packages/core/src/tools/shell.ts",
    "created_at": "2025-07-07T14:46:17+00:00",
    "commented_code": "if (path.isAbsolute(params.directory)) {\n         return 'Directory cannot be absolute. Must be relative to the project root directory.';\n       }\n+      const rootDir = path.resolve(this.config.getTargetDir());\n+      const resolvedDir = path.resolve(rootDir, params.directory);\n+\n+      if (!resolvedDir.startsWith(rootDir + path.sep) && resolvedDir !== rootDir) {\n+        return 'Directory traversal is not allowed. Path must be within the project root.';\n+      }",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2190313032",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3452,
        "pr_file": "packages/core/src/tools/shell.ts",
        "discussion_id": "2190303896",
        "commented_code": "@@ -248,6 +248,13 @@ Process Group PGID: Process group started or \\`(none)\\``,\n       if (path.isAbsolute(params.directory)) {\n         return 'Directory cannot be absolute. Must be relative to the project root directory.';\n       }\n+      const rootDir = path.resolve(this.config.getTargetDir());\n+      const resolvedDir = path.resolve(rootDir, params.directory);\n+\n+      if (!resolvedDir.startsWith(rootDir + path.sep) && resolvedDir !== rootDir) {\n+        return 'Directory traversal is not allowed. Path must be within the project root.';\n+      }",
        "comment_created_at": "2025-07-07T14:46:17+00:00",
        "comment_author": "y-okt",
        "comment_body": "@gemini-code-assist wouldn't commands like `ln -s /etc my-evil-link` be preventable by the following existing code?\r\n\r\n```TypeScript\r\nif (path.isAbsolute(params.directory)) {\r\n    return 'Directory cannot be absolute. Must be relative to the project root directory.';\r\n  }\r\n  ```",
        "pr_file_module": null
      },
      {
        "comment_id": "2190362550",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3452,
        "pr_file": "packages/core/src/tools/shell.ts",
        "discussion_id": "2190303896",
        "commented_code": "@@ -248,6 +248,13 @@ Process Group PGID: Process group started or \\`(none)\\``,\n       if (path.isAbsolute(params.directory)) {\n         return 'Directory cannot be absolute. Must be relative to the project root directory.';\n       }\n+      const rootDir = path.resolve(this.config.getTargetDir());\n+      const resolvedDir = path.resolve(rootDir, params.directory);\n+\n+      if (!resolvedDir.startsWith(rootDir + path.sep) && resolvedDir !== rootDir) {\n+        return 'Directory traversal is not allowed. Path must be within the project root.';\n+      }",
        "comment_created_at": "2025-07-07T15:08:06+00:00",
        "comment_author": "y-okt",
        "comment_body": "Added logic",
        "pr_file_module": null
      }
    ]
  }
]