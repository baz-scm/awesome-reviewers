[
  {
    "discussion_id": "2199981988",
    "pr_number": 2723,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
    "created_at": "2025-07-11T08:21:12+00:00",
    "commented_code": "unmount();\n   });\n \n+  describe('cursor highlighting behavior', () => {\n+    it('should show cursor highlighting when focused and hide it when unfocused', async () => {\n+      // Set up buffer with text content where cursor highlighting would be visible\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1]; // Position cursor on 'e'\n+      \n+      // Test with focus=true - cursor highlighting should be visible\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(<InputPrompt {...props} />);\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+      \n+      // Test with focus=false - cursor highlighting should NOT be visible\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(<InputPrompt {...props} />);\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+      \n+      // Both should contain the base text\n+      expect(focusedOutput).toContain('test');\n+      expect(unfocusedOutput).toContain('test');\n+      \n+      // The outputs should be defined and non-empty\n+      expect(focusedOutput).toBeDefined();\n+      expect(unfocusedOutput).toBeDefined();\n+      expect(focusedOutput?.length).toBeGreaterThan(0);\n+      expect(unfocusedOutput?.length).toBeGreaterThan(0);",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2200024500",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2723,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
        "discussion_id": "2199981988",
        "commented_code": "@@ -218,6 +218,165 @@ describe('InputPrompt', () => {\n     unmount();\n   });\n \n+  describe('cursor highlighting behavior', () => {\n+    it('should show cursor highlighting when focused and hide it when unfocused', async () => {\n+      // Set up buffer with text content where cursor highlighting would be visible\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1]; // Position cursor on 'e'\n+      \n+      // Test with focus=true - cursor highlighting should be visible\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(<InputPrompt {...props} />);\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+      \n+      // Test with focus=false - cursor highlighting should NOT be visible\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(<InputPrompt {...props} />);\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+      \n+      // Both should contain the base text\n+      expect(focusedOutput).toContain('test');\n+      expect(unfocusedOutput).toContain('test');\n+      \n+      // The outputs should be defined and non-empty\n+      expect(focusedOutput).toBeDefined();\n+      expect(unfocusedOutput).toBeDefined();\n+      expect(focusedOutput?.length).toBeGreaterThan(0);\n+      expect(unfocusedOutput?.length).toBeGreaterThan(0);",
        "comment_created_at": "2025-07-11T08:21:12+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "Updated in the latest commit. The test now includes:\r\n\r\n  1. A mock for `chalk.inverse` that wraps highlighted text in brackets `[text]` to make highlighting detectable in test output\r\n  2. Explicit assertion that `expect(focusedOutput).not.toEqual(unfocusedOutput)` to ensure outputs differ based on focus state\r\n  3. Specific checks that focused output contains `t[e]st` (with cursor highlight) while unfocused contains only `test`\r\n  4. Additional assertion that unfocused output does NOT contain `t[e]st` to ensure highlighting is removed when not focused\r\n\r\n  These changes ensure that any regression in the cursor highlighting logic (where highlighting might appear regardless of focus state) would be caught\r\n   by the tests.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2200128075",
    "pr_number": 2723,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
    "created_at": "2025-07-11T09:02:21+00:00",
    "commented_code": "unmount();\n   });\n \n+  describe('cursor highlighting behavior', () => {\n+    it('should show cursor highlighting when focused and hide it when unfocused', async () => {\n+      // Set up buffer with text content where cursor highlighting would be visible\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1]; // Position cursor on 'e'\n+\n+      // Test with focus=true - cursor highlighting should be visible\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test with focus=false - cursor highlighting should NOT be visible\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2200133314",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2723,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
        "discussion_id": "2200128075",
        "commented_code": "@@ -218,6 +225,183 @@ describe('InputPrompt', () => {\n     unmount();\n   });\n \n+  describe('cursor highlighting behavior', () => {\n+    it('should show cursor highlighting when focused and hide it when unfocused', async () => {\n+      // Set up buffer with text content where cursor highlighting would be visible\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1]; // Position cursor on 'e'\n+\n+      // Test with focus=true - cursor highlighting should be visible\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test with focus=false - cursor highlighting should NOT be visible\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();",
        "comment_created_at": "2025-07-11T09:02:21+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "@gemini-code-assist The test now includes `expect(focusedOutput).not.toEqual(unfocusedOutput)` and verifies that focused output\r\n  contains `t[e]st` while unfocused contains only `test`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2200128078",
    "pr_number": 2723,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
    "created_at": "2025-07-11T09:02:40+00:00",
    "commented_code": "unmount();\n   });\n \n+  describe('cursor highlighting behavior', () => {\n+    it('should show cursor highlighting when focused and hide it when unfocused', async () => {\n+      // Set up buffer with text content where cursor highlighting would be visible\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1]; // Position cursor on 'e'\n+\n+      // Test with focus=true - cursor highlighting should be visible\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test with focus=false - cursor highlighting should NOT be visible\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+\n+      // Both should contain the base text, but focused output should show the mocked highlight\n+      expect(focusedOutput).toContain('t[e]st'); // Assuming cursor on 'e' in 'test'\n+      expect(unfocusedOutput).toContain('test');\n+      expect(unfocusedOutput).not.toContain('t[e]st'); // Ensure unfocused doesn't have the highlight\n+      expect(focusedOutput).not.toEqual(unfocusedOutput); // Crucial: outputs must be different\n+\n+      // The outputs should be defined and non-empty (keep these if desired, but the above are more specific)\n+      expect(focusedOutput).toBeDefined();\n+      expect(unfocusedOutput).toBeDefined();\n+      expect(focusedOutput?.length).toBeGreaterThan(0);\n+      expect(unfocusedOutput?.length).toBeGreaterThan(0);\n+    });\n+\n+    it('should handle placeholder rendering with focus states', async () => {\n+      props.placeholder = 'Type here';\n+\n+      // Test focused state - placeholder logic with focus=true\n+      props.focus = true;\n+      mockBuffer.text = '';\n+      mockBuffer.lines = [''];\n+      mockBuffer.viewportVisualLines = [''];\n+\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test unfocused state - placeholder logic with focus=false\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+\n+      // Validate that both contain the placeholder text (with mocked highlighting for focused)\n+      expect(focusedOutput).toContain('[T]ype here'); // First character highlighted when focused\n+      expect(unfocusedOutput).toContain('Type here');\n+      expect(unfocusedOutput).not.toContain('[T]ype here');\n+\n+      // Validate both states render successfully\n+      expect(focusedOutput).toBeDefined();\n+      expect(unfocusedOutput).toBeDefined();\n+\n+      // The placeholder logic already properly handles focus conditionally\n+      // This test ensures our fix doesn't break placeholder rendering\n+    });\n+\n+    it('should handle text input with different focus states', async () => {\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1];\n+\n+      // Test with focus=true\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test with focus=false\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+\n+      // Both should contain the text, but focused should have highlighting\n+      expect(focusedOutput).toContain('t[e]st'); // Cursor on 'e' should be highlighted\n+      expect(unfocusedOutput).toContain('test');\n+      expect(unfocusedOutput).not.toContain('t[e]st');\n+    });\n+\n+    it('should not crash when focus changes during rendering', async () => {\n+      props.focus = true;\n+      mockBuffer.text = 'hello world';\n+      mockBuffer.lines = ['hello world'];\n+      mockBuffer.viewportVisualLines = ['hello world'];\n+      mockBuffer.visualCursor = [0, 5];\n+\n+      const { rerender, lastFrame, unmount } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+\n+      const initialOutput = lastFrame();\n+      expect(initialOutput).toContain('hello[ ]world'); // Space is highlighted when focused\n+\n+      // Change focus and re-render\n+      props.focus = false;\n+      rerender(<InputPrompt {...props} />);\n+      await wait();\n+\n+      const updatedOutput = lastFrame();\n+      expect(updatedOutput).toContain('hello world');\n+\n+      unmount();\n+    });\n+\n+    it('should properly handle cursor highlighting during focus transitions', async () => {\n+      // This test validates that cursor highlighting toggles correctly during focus changes\n+\n+      // Set up a scenario where cursor highlighting logic would be triggered\n+      mockBuffer.text = 'hello world';\n+      mockBuffer.lines = ['hello world'];\n+      mockBuffer.viewportVisualLines = ['hello world'];\n+      mockBuffer.visualCursor = [0, 5]; // Position cursor on the space between words\n+\n+      // Start with focus=true\n+      props.focus = true;\n+      const { rerender, lastFrame, unmount } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = lastFrame();",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2200133947",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2723,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
        "discussion_id": "2200128078",
        "commented_code": "@@ -218,6 +225,183 @@ describe('InputPrompt', () => {\n     unmount();\n   });\n \n+  describe('cursor highlighting behavior', () => {\n+    it('should show cursor highlighting when focused and hide it when unfocused', async () => {\n+      // Set up buffer with text content where cursor highlighting would be visible\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1]; // Position cursor on 'e'\n+\n+      // Test with focus=true - cursor highlighting should be visible\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test with focus=false - cursor highlighting should NOT be visible\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+\n+      // Both should contain the base text, but focused output should show the mocked highlight\n+      expect(focusedOutput).toContain('t[e]st'); // Assuming cursor on 'e' in 'test'\n+      expect(unfocusedOutput).toContain('test');\n+      expect(unfocusedOutput).not.toContain('t[e]st'); // Ensure unfocused doesn't have the highlight\n+      expect(focusedOutput).not.toEqual(unfocusedOutput); // Crucial: outputs must be different\n+\n+      // The outputs should be defined and non-empty (keep these if desired, but the above are more specific)\n+      expect(focusedOutput).toBeDefined();\n+      expect(unfocusedOutput).toBeDefined();\n+      expect(focusedOutput?.length).toBeGreaterThan(0);\n+      expect(unfocusedOutput?.length).toBeGreaterThan(0);\n+    });\n+\n+    it('should handle placeholder rendering with focus states', async () => {\n+      props.placeholder = 'Type here';\n+\n+      // Test focused state - placeholder logic with focus=true\n+      props.focus = true;\n+      mockBuffer.text = '';\n+      mockBuffer.lines = [''];\n+      mockBuffer.viewportVisualLines = [''];\n+\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test unfocused state - placeholder logic with focus=false\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+\n+      // Validate that both contain the placeholder text (with mocked highlighting for focused)\n+      expect(focusedOutput).toContain('[T]ype here'); // First character highlighted when focused\n+      expect(unfocusedOutput).toContain('Type here');\n+      expect(unfocusedOutput).not.toContain('[T]ype here');\n+\n+      // Validate both states render successfully\n+      expect(focusedOutput).toBeDefined();\n+      expect(unfocusedOutput).toBeDefined();\n+\n+      // The placeholder logic already properly handles focus conditionally\n+      // This test ensures our fix doesn't break placeholder rendering\n+    });\n+\n+    it('should handle text input with different focus states', async () => {\n+      mockBuffer.text = 'test';\n+      mockBuffer.lines = ['test'];\n+      mockBuffer.viewportVisualLines = ['test'];\n+      mockBuffer.visualCursor = [0, 1];\n+\n+      // Test with focus=true\n+      props.focus = true;\n+      const { lastFrame: focusedFrame, unmount: unmount1 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = focusedFrame();\n+      unmount1();\n+\n+      // Test with focus=false\n+      props.focus = false;\n+      const { lastFrame: unfocusedFrame, unmount: unmount2 } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const unfocusedOutput = unfocusedFrame();\n+      unmount2();\n+\n+      // Both should contain the text, but focused should have highlighting\n+      expect(focusedOutput).toContain('t[e]st'); // Cursor on 'e' should be highlighted\n+      expect(unfocusedOutput).toContain('test');\n+      expect(unfocusedOutput).not.toContain('t[e]st');\n+    });\n+\n+    it('should not crash when focus changes during rendering', async () => {\n+      props.focus = true;\n+      mockBuffer.text = 'hello world';\n+      mockBuffer.lines = ['hello world'];\n+      mockBuffer.viewportVisualLines = ['hello world'];\n+      mockBuffer.visualCursor = [0, 5];\n+\n+      const { rerender, lastFrame, unmount } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+\n+      const initialOutput = lastFrame();\n+      expect(initialOutput).toContain('hello[ ]world'); // Space is highlighted when focused\n+\n+      // Change focus and re-render\n+      props.focus = false;\n+      rerender(<InputPrompt {...props} />);\n+      await wait();\n+\n+      const updatedOutput = lastFrame();\n+      expect(updatedOutput).toContain('hello world');\n+\n+      unmount();\n+    });\n+\n+    it('should properly handle cursor highlighting during focus transitions', async () => {\n+      // This test validates that cursor highlighting toggles correctly during focus changes\n+\n+      // Set up a scenario where cursor highlighting logic would be triggered\n+      mockBuffer.text = 'hello world';\n+      mockBuffer.lines = ['hello world'];\n+      mockBuffer.viewportVisualLines = ['hello world'];\n+      mockBuffer.visualCursor = [0, 5]; // Position cursor on the space between words\n+\n+      // Start with focus=true\n+      props.focus = true;\n+      const { rerender, lastFrame, unmount } = render(\n+        <InputPrompt {...props} />,\n+      );\n+      await wait();\n+      const focusedOutput = lastFrame();",
        "comment_created_at": "2025-07-11T09:02:40+00:00",
        "comment_author": "yuvrajangadsingh",
        "comment_body": "@gemini-code-assist The focus transition test now verifies all three states and includes assertions that unfocused output differs\r\n  from focused, with specific checks for `hello[ ]world` vs `hello world`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2198869147",
    "pr_number": 3554,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
    "created_at": "2025-07-10T22:16:53+00:00",
    "commented_code": "expect(props.onSubmit).not.toHaveBeenCalled();\n     unmount();\n   });\n+\n+  it('should call buffer.undo on Ctrl+G', async () => {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2198869147",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 3554,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
        "discussion_id": "2198869147",
        "commented_code": "@@ -407,4 +409,26 @@ describe('InputPrompt', () => {\n     expect(props.onSubmit).not.toHaveBeenCalled();\n     unmount();\n   });\n+\n+  it('should call buffer.undo on Ctrl+G', async () => {",
        "comment_created_at": "2025-07-10T22:16:53+00:00",
        "comment_author": "jacob314",
        "comment_body": "make these tests a little more robust by adding some text to undo and redo and verifying that the text is actually undone and redone.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216803575",
    "pr_number": 4462,
    "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
    "created_at": "2025-07-18T19:41:16+00:00",
    "commented_code": "expect(props.buffer.setText).not.toHaveBeenCalled();\n     unmount();\n   });\n+\n+  describe('cursor-based completion trigger', () => {\n+    it('should trigger completion when cursor is after @ without spaces', async () => {\n+      // Set up buffer state\n+      mockBuffer.text = '@src/components';\n+      mockBuffer.lines = ['@src/components'];\n+      mockBuffer.cursor = [0, 15];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: true,\n+        suggestions: [{ label: 'Button.tsx', value: 'Button.tsx' }],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      // Verify useCompletion was called with true (should show completion)\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '@src/components',\n+        '/test/project/src',\n+        true, // shouldShowCompletion should be true\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should trigger completion when cursor is after / without spaces', async () => {\n+      mockBuffer.text = '/memory';\n+      mockBuffer.lines = ['/memory'];\n+      mockBuffer.cursor = [0, 7];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: true,\n+        suggestions: [{ label: 'show', value: 'show' }],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '/memory',\n+        '/test/project/src',\n+        true, // shouldShowCompletion should be true\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should NOT trigger completion when cursor is after space following @', async () => {\n+      mockBuffer.text = '@src/file.ts hello';\n+      mockBuffer.lines = ['@src/file.ts hello'];\n+      mockBuffer.cursor = [0, 18];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '@src/file.ts hello',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should NOT trigger completion when cursor is after space following /', async () => {\n+      mockBuffer.text = '/memory add';\n+      mockBuffer.lines = ['/memory add'];\n+      mockBuffer.cursor = [0, 11];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '/memory add',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should NOT trigger completion when cursor is not after @ or /', async () => {\n+      mockBuffer.text = 'hello world';\n+      mockBuffer.lines = ['hello world'];\n+      mockBuffer.cursor = [0, 5];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        'hello world',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should handle multiline text correctly', async () => {\n+      mockBuffer.text = 'first line\n/memory';\n+      mockBuffer.lines = ['first line', '/memory'];\n+      mockBuffer.cursor = [1, 7];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        'first line\n/memory',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false (isSlashCommand returns false because text doesn't start with /)\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should handle single line slash command correctly', async () => {\n+      mockBuffer.text = '/memory';\n+      mockBuffer.lines = ['/memory'];\n+      mockBuffer.cursor = [0, 7];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: true,\n+        suggestions: [{ label: 'show', value: 'show' }],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '/memory',\n+        '/test/project/src',\n+        true, // shouldShowCompletion should be true (isSlashCommand returns true AND cursor is after / without space)\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+  });",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2216811864",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4462,
        "pr_file": "packages/cli/src/ui/components/InputPrompt.test.tsx",
        "discussion_id": "2216803575",
        "commented_code": "@@ -570,4 +570,190 @@ describe('InputPrompt', () => {\n     expect(props.buffer.setText).not.toHaveBeenCalled();\n     unmount();\n   });\n+\n+  describe('cursor-based completion trigger', () => {\n+    it('should trigger completion when cursor is after @ without spaces', async () => {\n+      // Set up buffer state\n+      mockBuffer.text = '@src/components';\n+      mockBuffer.lines = ['@src/components'];\n+      mockBuffer.cursor = [0, 15];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: true,\n+        suggestions: [{ label: 'Button.tsx', value: 'Button.tsx' }],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      // Verify useCompletion was called with true (should show completion)\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '@src/components',\n+        '/test/project/src',\n+        true, // shouldShowCompletion should be true\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should trigger completion when cursor is after / without spaces', async () => {\n+      mockBuffer.text = '/memory';\n+      mockBuffer.lines = ['/memory'];\n+      mockBuffer.cursor = [0, 7];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: true,\n+        suggestions: [{ label: 'show', value: 'show' }],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '/memory',\n+        '/test/project/src',\n+        true, // shouldShowCompletion should be true\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should NOT trigger completion when cursor is after space following @', async () => {\n+      mockBuffer.text = '@src/file.ts hello';\n+      mockBuffer.lines = ['@src/file.ts hello'];\n+      mockBuffer.cursor = [0, 18];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '@src/file.ts hello',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should NOT trigger completion when cursor is after space following /', async () => {\n+      mockBuffer.text = '/memory add';\n+      mockBuffer.lines = ['/memory add'];\n+      mockBuffer.cursor = [0, 11];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '/memory add',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should NOT trigger completion when cursor is not after @ or /', async () => {\n+      mockBuffer.text = 'hello world';\n+      mockBuffer.lines = ['hello world'];\n+      mockBuffer.cursor = [0, 5];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        'hello world',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should handle multiline text correctly', async () => {\n+      mockBuffer.text = 'first line\\n/memory';\n+      mockBuffer.lines = ['first line', '/memory'];\n+      mockBuffer.cursor = [1, 7];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: false,\n+        suggestions: [],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        'first line\\n/memory',\n+        '/test/project/src',\n+        false, // shouldShowCompletion should be false (isSlashCommand returns false because text doesn't start with /)\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+\n+    it('should handle single line slash command correctly', async () => {\n+      mockBuffer.text = '/memory';\n+      mockBuffer.lines = ['/memory'];\n+      mockBuffer.cursor = [0, 7];\n+\n+      mockedUseCompletion.mockReturnValue({\n+        ...mockCompletion,\n+        showSuggestions: true,\n+        suggestions: [{ label: 'show', value: 'show' }],\n+      });\n+\n+      const { unmount } = render(<InputPrompt {...props} />);\n+      await wait();\n+\n+      expect(mockedUseCompletion).toHaveBeenCalledWith(\n+        '/memory',\n+        '/test/project/src',\n+        true, // shouldShowCompletion should be true (isSlashCommand returns true AND cursor is after / without space)\n+        mockSlashCommands,\n+        mockCommandContext,\n+        expect.any(Object),\n+      );\n+\n+      unmount();\n+    });\n+  });",
        "comment_created_at": "2025-07-18T19:41:16+00:00",
        "comment_author": "jacob314",
        "comment_body": "agree this is worth testing. also add tests for paths with escaped spaces. That is needed as filenames can contain spaces.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2172966555",
    "pr_number": 2233,
    "pr_file": "packages/cli/src/ui/components/shared/MaxSizedBox.test.tsx",
    "created_at": "2025-06-27T23:12:01+00:00",
    "commented_code": "\ud83d\udc36\ud83d\udc36\n \ud83d\udc36`);\n   });\n+  it('falls back to an ellipsis when width is extremely small', () => {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2172966555",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2233,
        "pr_file": "packages/cli/src/ui/components/shared/MaxSizedBox.test.tsx",
        "discussion_id": "2172966555",
        "commented_code": "@@ -247,6 +247,20 @@ Line 3`);\n \ud83d\udc36\ud83d\udc36\n \ud83d\udc36`);\n   });\n+  it('falls back to an ellipsis when width is extremely small', () => {",
        "comment_created_at": "2025-06-27T23:12:01+00:00",
        "comment_author": "jacob314",
        "comment_body": "can you add a couple more test cases?\r\nOther cases of interest:\r\nThe non wrapping text exceeds the length of the MaxSizedBox.\r\nThe non wrapping text happens to have line breaks (ugly edge case for this)\r\nThe non wrapping text  exceeds the length of the MaxSizedBox.\r\nAdd a case with multiple rows in the MaxSizedBox just for clarity of how this may look with multiple lines with `...`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2183200173",
    "pr_number": 2233,
    "pr_file": "packages/cli/src/ui/components/shared/MaxSizedBox.test.tsx",
    "created_at": "2025-07-03T16:23:00+00:00",
    "commented_code": "\ud83d\udc36\ud83d\udc36\n \ud83d\udc36`);\n   });\n+  it('falls back to an ellipsis when width is extremely small', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={2} maxHeight={2}>\n+          <Box>\n+            <Text>No</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n+\n+    expect(lastFrame()).equals('N\u2026');\n+  });\n+\n+  it('truncates long non-wrapping text with ellipsis', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={3} maxHeight={2}>\n+          <Box>\n+            <Text>ABCDE</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n+\n+    expect(lastFrame()).equals('AB\u2026');\n+  });\n+\n+  it('truncates non-wrapping text containing line breaks', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={3} maxHeight={2}>\n+          <Box>\n+            <Text>{'A\nBCDE'}</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n \n+    expect(lastFrame()).equals(`A\n\u2026`);\n+  });\n+",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2183200173",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2233,
        "pr_file": "packages/cli/src/ui/components/shared/MaxSizedBox.test.tsx",
        "discussion_id": "2183200173",
        "commented_code": "@@ -247,7 +247,73 @@ Line 3`);\n \ud83d\udc36\ud83d\udc36\n \ud83d\udc36`);\n   });\n+  it('falls back to an ellipsis when width is extremely small', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={2} maxHeight={2}>\n+          <Box>\n+            <Text>No</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n+\n+    expect(lastFrame()).equals('N\u2026');\n+  });\n+\n+  it('truncates long non-wrapping text with ellipsis', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={3} maxHeight={2}>\n+          <Box>\n+            <Text>ABCDE</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n+\n+    expect(lastFrame()).equals('AB\u2026');\n+  });\n+\n+  it('truncates non-wrapping text containing line breaks', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={3} maxHeight={2}>\n+          <Box>\n+            <Text>{'A\\nBCDE'}</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n \n+    expect(lastFrame()).equals(`A\\n\u2026`);\n+  });\n+",
        "comment_created_at": "2025-07-03T16:23:00+00:00",
        "comment_author": "jacob314",
        "comment_body": "also add a test case with emojis or other wide characters to make sure we are now handling that case correctly.",
        "pr_file_module": null
      },
      {
        "comment_id": "2190875107",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 2233,
        "pr_file": "packages/cli/src/ui/components/shared/MaxSizedBox.test.tsx",
        "discussion_id": "2183200173",
        "commented_code": "@@ -247,7 +247,73 @@ Line 3`);\n \ud83d\udc36\ud83d\udc36\n \ud83d\udc36`);\n   });\n+  it('falls back to an ellipsis when width is extremely small', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={2} maxHeight={2}>\n+          <Box>\n+            <Text>No</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n+\n+    expect(lastFrame()).equals('N\u2026');\n+  });\n+\n+  it('truncates long non-wrapping text with ellipsis', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={3} maxHeight={2}>\n+          <Box>\n+            <Text>ABCDE</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n+\n+    expect(lastFrame()).equals('AB\u2026');\n+  });\n+\n+  it('truncates non-wrapping text containing line breaks', () => {\n+    const { lastFrame } = render(\n+      <OverflowProvider>\n+        <MaxSizedBox maxWidth={3} maxHeight={2}>\n+          <Box>\n+            <Text>{'A\\nBCDE'}</Text>\n+            <Text wrap=\"wrap\">wrap</Text>\n+          </Box>\n+        </MaxSizedBox>\n+      </OverflowProvider>,\n+    );\n \n+    expect(lastFrame()).equals(`A\\n\u2026`);\n+  });\n+",
        "comment_created_at": "2025-07-07T19:30:45+00:00",
        "comment_author": "jacob314",
        "comment_body": "Is this test actually checking the rendered text for this case. On my phone so sorry if I am missing something.",
        "pr_file_module": null
      }
    ]
  }
]