[
  {
    "discussion_id": "2232401075",
    "pr_number": 4877,
    "pr_file": "packages/core/src/ide/detect-ide.ts",
    "created_at": "2025-07-26T03:04:36+00:00",
    "commented_code": "+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+export enum SupportedIDE {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2232401075",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4877,
        "pr_file": "packages/core/src/ide/detect-ide.ts",
        "discussion_id": "2232401075",
        "commented_code": "@@ -0,0 +1,25 @@\n+/**\n+ * @license\n+ * Copyright 2025 Google LLC\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+export enum SupportedIDE {",
        "comment_created_at": "2025-07-26T03:04:36+00:00",
        "comment_author": "skeshive",
        "comment_body": "nit: DetectedIde to be more explicit that this the current IDE the CLI is running in",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219655635",
    "pr_number": 4463,
    "pr_file": "packages/core/src/services/ideContext.ts",
    "created_at": "2025-07-21T16:14:22+00:00",
    "commented_code": "export const ActiveFileSchema = z.object({",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2219655635",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4463,
        "pr_file": "packages/core/src/services/ideContext.ts",
        "discussion_id": "2219655635",
        "commented_code": "@@ -26,6 +26,14 @@ export type Cursor = z.infer<typeof CursorSchema>;\n export const ActiveFileSchema = z.object({",
        "comment_created_at": "2025-07-21T16:14:22+00:00",
        "comment_author": "skeshive",
        "comment_body": "nit (ok to address in a follow-up): lets rename this to openFilesSchema and update filePath to activeFilePath since the scope of the notification is expanding",
        "pr_file_module": null
      },
      {
        "comment_id": "2219811057",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4463,
        "pr_file": "packages/core/src/services/ideContext.ts",
        "discussion_id": "2219655635",
        "commented_code": "@@ -26,6 +26,14 @@ export type Cursor = z.infer<typeof CursorSchema>;\n export const ActiveFileSchema = z.object({",
        "comment_created_at": "2025-07-21T17:23:41+00:00",
        "comment_author": "chrstnb",
        "comment_body": "Cool-- will update in the PR I had on top of this one!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217464830",
    "pr_number": 4511,
    "pr_file": "packages/cli/src/ui/commands/types.ts",
    "created_at": "2025-07-19T21:18:08+00:00",
    "commented_code": "| OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2217464830",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217464830",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';",
        "comment_created_at": "2025-07-19T21:18:08+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "Instead of source we may want to utilize a `kind` type here. Primary reason if we have more than 1 file type we support in the future this will become ambiguous",
        "pr_file_module": null
      },
      {
        "comment_id": "2217505412",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217464830",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';",
        "comment_created_at": "2025-07-19T23:49:45+00:00",
        "comment_author": "abhipatel12",
        "comment_body": "That's fair! So the way I viewed it is that the source is the general source (i.e a command loaded via a file set by a user), so this can be toml, md, etc.  So we would have a concise list of sources (built-in, file, mcp-server, etc). \r\n\r\nIf we moved to a model that used: `built-in`, `file-toml`, `file-md`, etc, we would be mixing source along with implementation. \r\n\r\nIf we end up supporting multiple file types in the future and need to differentiate between toml and md, we can use the `command.metadata.filepath` to see its extension.\r\n\r\nWDYT?",
        "pr_file_module": null
      },
      {
        "comment_id": "2217901193",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217464830",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';",
        "comment_created_at": "2025-07-20T17:50:06+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "That's a fair point; however, what's the value in tracking source? \ud83d\ude04 ",
        "pr_file_module": null
      },
      {
        "comment_id": "2217938052",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4511,
        "pr_file": "packages/cli/src/ui/commands/types.ts",
        "discussion_id": "2217464830",
        "commented_code": "@@ -106,12 +106,54 @@ export type SlashCommandActionReturn =\n   | OpenDialogActionReturn\n   | LoadHistoryActionReturn;\n \n+/**\n+ * Metadata describing a command's origin and expected behavior.\n+ */\n+export interface SlashCommandMetadata {\n+  /** The source of the command definition. */\n+  source: 'built-in' | 'file';",
        "comment_created_at": "2025-07-20T19:58:37+00:00",
        "comment_author": "abhipatel12",
        "comment_body": "My first thoughts here would revolve around UI/UX. \r\n1. Knowing where a command came from/how it was loaded. So if a user has an error, they can tell if the custom command originated from a file loaded command, mcp, etc. (especially if the the names collide)\r\n\r\n2. UI for autocomplete/suggestions - Currently, we just list all commands but if a user has a lot of commands from different sources, an icon/grouping can help distinguish the source/kind. We can also prioritize user commands first.\r\n\r\nDropping `metadata` in general, and renaming `source` to `kind` which will now become a top level required property. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2217048394",
    "pr_number": 4475,
    "pr_file": "packages/core/src/code_assist/oauth2.ts",
    "created_at": "2025-07-18T23:56:35+00:00",
    "commented_code": "}\n   }\n \n-  if (config.getNoBrowser()) {\n+  if (config.getNoBrowser() || !shouldAttemptBrowserLaunch()) {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2217048394",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4475,
        "pr_file": "packages/core/src/code_assist/oauth2.ts",
        "discussion_id": "2217048394",
        "commented_code": "@@ -121,7 +122,7 @@ export async function getOauthClient(\n     }\n   }\n \n-  if (config.getNoBrowser()) {\n+  if (config.getNoBrowser() || !shouldAttemptBrowserLaunch()) {",
        "comment_created_at": "2025-07-18T23:56:35+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "Can we change the `getNoBrowser` to be `config.isBrowserless()` which also encompasses this `shouldAttemptBrowserLaunch` logic?",
        "pr_file_module": null
      },
      {
        "comment_id": "2217050837",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4475,
        "pr_file": "packages/core/src/code_assist/oauth2.ts",
        "discussion_id": "2217048394",
        "commented_code": "@@ -121,7 +122,7 @@ export async function getOauthClient(\n     }\n   }\n \n-  if (config.getNoBrowser()) {\n+  if (config.getNoBrowser() || !shouldAttemptBrowserLaunch()) {",
        "comment_created_at": "2025-07-19T00:01:36+00:00",
        "comment_author": "mboshernitsan",
        "comment_body": "My mental model is that config.getNoBrowser() accesses the provided setting (from the settings file or the env var), whereas shouldAttemptBrowserLaunch() attempts to detect the correct behavior from the environment, but does not persists its result.  I think they are logically separate, no?  I can see adding another utility function that combines the logic, but it might be an overkill given that it is used in exactly three places right now.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2211851704",
    "pr_number": 4337,
    "pr_file": "packages/core/src/services/loopDetectionService.ts",
    "created_at": "2025-07-16T23:56:46+00:00",
    "commented_code": "return false;\n   }\n \n+  async checkForLoopWithLLM(\n+    streamSignal: AbortSignal,\n+    abortController: AbortController,\n+  ) {\n+    try {\n+      const recentHistory = this.client!.getHistory().slice(\n+        -LLM_LOOP_CHECK_HISTORY_COUNT,\n+      );\n+\n+      const prompt = `You are an expert at detecting conversation loops.\n+The following is the recent history of a conversation with an AI assistant.\n+Please analyze it to determine if the conversation is stuck in a repetitive loop.\n+A loop is defined as the AI assistant making a sequence of 5 or more tool calls that are repetitive and not making progress.\n+This can be a single tool call repeated 5 times, or a repeating pattern of tool calls (e.g., A, B, A, B, A, B, A, B, A, B).\n+\n+Analyze the tool calls made by the model in the conversation history to identify such patterns.\n+Respond with JSON. The JSON object should have a single key \"is_loop\" with a boolean value.\n+\n+Conversation history:\n+${JSON.stringify(recentHistory, null, 2)}\n+`;\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          is_loop: {",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2211851704",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 4337,
        "pr_file": "packages/core/src/services/loopDetectionService.ts",
        "discussion_id": "2211851704",
        "commented_code": "@@ -119,6 +124,58 @@ export class LoopDetectionService {\n     return false;\n   }\n \n+  async checkForLoopWithLLM(\n+    streamSignal: AbortSignal,\n+    abortController: AbortController,\n+  ) {\n+    try {\n+      const recentHistory = this.client!.getHistory().slice(\n+        -LLM_LOOP_CHECK_HISTORY_COUNT,\n+      );\n+\n+      const prompt = `You are an expert at detecting conversation loops.\n+The following is the recent history of a conversation with an AI assistant.\n+Please analyze it to determine if the conversation is stuck in a repetitive loop.\n+A loop is defined as the AI assistant making a sequence of 5 or more tool calls that are repetitive and not making progress.\n+This can be a single tool call repeated 5 times, or a repeating pattern of tool calls (e.g., A, B, A, B, A, B, A, B, A, B).\n+\n+Analyze the tool calls made by the model in the conversation history to identify such patterns.\n+Respond with JSON. The JSON object should have a single key \"is_loop\" with a boolean value.\n+\n+Conversation history:\n+${JSON.stringify(recentHistory, null, 2)}\n+`;\n+      const schema = {\n+        type: 'object',\n+        properties: {\n+          is_loop: {",
        "comment_created_at": "2025-07-16T23:56:46+00:00",
        "comment_author": "NTaylorMullen",
        "comment_body": "You may want to encourage chain of thought here and before this property have `reasoning: { type: 'string', description: 'Your reasoning on if the conversation is looping without forward progress' }`\r\n\r\nSimilarly we may want to change the parameter name to be a bit more targeted:\r\n\r\n```suggestion\r\n          loopDetected: {\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2174124338",
    "pr_number": 1743,
    "pr_file": "packages/core/src/config/config.ts",
    "created_at": "2025-07-01T02:30:23+00:00",
    "commented_code": "this.fileDiscoveryService = params.fileDiscoveryService ?? null;\n     this.bugCommand = params.bugCommand;\n     this.model = params.model;\n+    this.interactive = params.interactive ?? true;",
    "repo_full_name": "google-gemini/gemini-cli",
    "discussion_comments": [
      {
        "comment_id": "2176294275",
        "repo_full_name": "google-gemini/gemini-cli",
        "pr_number": 1743,
        "pr_file": "packages/core/src/config/config.ts",
        "discussion_id": "2174124338",
        "commented_code": "@@ -206,6 +208,7 @@ export class Config {\n     this.fileDiscoveryService = params.fileDiscoveryService ?? null;\n     this.bugCommand = params.bugCommand;\n     this.model = params.model;\n+    this.interactive = params.interactive ?? true;",
        "comment_created_at": "2025-07-01T02:30:23+00:00",
        "comment_author": "taeold",
        "comment_body": "Gemini CLI is actually interactive by default unless `-p` flag is passed. `-p` and `-i` can be combined to force into an interactive mode.\r\n\r\nI could rename this config value as `forceInteractive` or something similar to make it clear that this flag only affects behavior of the CLI when `-p` flag is present?",
        "pr_file_module": null
      }
    ]
  }
]