[
  {
    "discussion_id": "2167807740",
    "pr_number": 7608,
    "pr_file": "src/cli/ssh_cache.zig",
    "created_at": "2025-06-25T23:33:58+00:00",
    "commented_code": "+const std = @import(\"std\");\n+const Allocator = std.mem.Allocator;\n+const Child = std.process.Child;\n+\n+/// Get the path to the shared cache script\n+fn getCacheScriptPath(alloc: Allocator) ![]u8 {\n+    // Use GHOSTTY_RESOURCES_DIR if available, otherwise assume relative path\n+    const resources_dir = std.process.getEnvVarOwned(alloc, \"GHOSTTY_RESOURCES_DIR\") catch {\n+        // Fallback: assume we're running from build directory\n+        return try alloc.dupe(u8, \"src/shell-integration/shared/ghostty-ssh-cache\");\n+    };\n+    defer alloc.free(resources_dir);\n+\n+    return try std.fs.path.join(alloc, &[_][]const u8{ resources_dir, \"shell-integration\", \"shared\", \"ghostty-ssh-cache\" });\n+}\n+\n+/// List cached hosts by calling the external script\n+pub fn listCachedHosts(alloc: Allocator, writer: anytype) !void {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2167807740",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7608,
        "pr_file": "src/cli/ssh_cache.zig",
        "discussion_id": "2167807740",
        "commented_code": "@@ -0,0 +1,71 @@\n+const std = @import(\"std\");\n+const Allocator = std.mem.Allocator;\n+const Child = std.process.Child;\n+\n+/// Get the path to the shared cache script\n+fn getCacheScriptPath(alloc: Allocator) ![]u8 {\n+    // Use GHOSTTY_RESOURCES_DIR if available, otherwise assume relative path\n+    const resources_dir = std.process.getEnvVarOwned(alloc, \"GHOSTTY_RESOURCES_DIR\") catch {\n+        // Fallback: assume we're running from build directory\n+        return try alloc.dupe(u8, \"src/shell-integration/shared/ghostty-ssh-cache\");\n+    };\n+    defer alloc.free(resources_dir);\n+\n+    return try std.fs.path.join(alloc, &[_][]const u8{ resources_dir, \"shell-integration\", \"shared\", \"ghostty-ssh-cache\" });\n+}\n+\n+/// List cached hosts by calling the external script\n+pub fn listCachedHosts(alloc: Allocator, writer: anytype) !void {",
        "comment_created_at": "2025-06-25T23:33:58+00:00",
        "comment_author": "00-kat",
        "comment_body": "This function and `clearCache` seem to have identical code except for a single string literal, shouldn't the body be extracted to another function?",
        "pr_file_module": null
      },
      {
        "comment_id": "2167893288",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7608,
        "pr_file": "src/cli/ssh_cache.zig",
        "discussion_id": "2167807740",
        "commented_code": "@@ -0,0 +1,71 @@\n+const std = @import(\"std\");\n+const Allocator = std.mem.Allocator;\n+const Child = std.process.Child;\n+\n+/// Get the path to the shared cache script\n+fn getCacheScriptPath(alloc: Allocator) ![]u8 {\n+    // Use GHOSTTY_RESOURCES_DIR if available, otherwise assume relative path\n+    const resources_dir = std.process.getEnvVarOwned(alloc, \"GHOSTTY_RESOURCES_DIR\") catch {\n+        // Fallback: assume we're running from build directory\n+        return try alloc.dupe(u8, \"src/shell-integration/shared/ghostty-ssh-cache\");\n+    };\n+    defer alloc.free(resources_dir);\n+\n+    return try std.fs.path.join(alloc, &[_][]const u8{ resources_dir, \"shell-integration\", \"shared\", \"ghostty-ssh-cache\" });\n+}\n+\n+/// List cached hosts by calling the external script\n+pub fn listCachedHosts(alloc: Allocator, writer: anytype) !void {",
        "comment_created_at": "2025-06-26T01:09:52+00:00",
        "comment_author": "jasonrayne",
        "comment_body": "Yeah that was a big miss on my part, was too busy looking at the trees - missed the forest ðŸ™„ \r\nFixed in https://github.com/ghostty-org/ghostty/pull/7608/commits/eed2006b4d7110b935c14f3fcb7ba5679aa010e5",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2162664285",
    "pr_number": 7576,
    "pr_file": "src/config/Config.zig",
    "created_at": "2025-06-23T23:05:32+00:00",
    "commented_code": "height: u32,\n     };\n \n+    /// C API structure for QuickTerminalSize\n+    pub const C = extern struct {\n+        primary: CSize,\n+        secondary: CSize,\n+    };\n+\n+    pub const CSize = extern struct {\n+        type: Type,\n+        value: u32,\n+\n+        pub const Type = enum(u8) { none, percentage, pixels };\n+\n+        fn none() CSize {\n+            return .{ .type = .none, .value = 0 };\n+        }\n+\n+        fn percentage(v: f32) CSize {\n+            return .{ .type = .percentage, .value = @bitCast(v) };\n+        }\n+\n+        fn pixels(v: u32) CSize {\n+            return .{ .type = .pixels, .value = v };\n+        }\n+    };\n+\n+    pub fn cval(self: QuickTerminalSize) C {\n+        return .{\n+            .primary = if (self.primary) |p| switch (p) {\n+                .percentage => |v| CSize.percentage(v),\n+                .pixels => |v| CSize.pixels(v),\n+            } else CSize.none(),\n+            .secondary = if (self.secondary) |s| switch (s) {\n+                .percentage => |v| CSize.percentage(v),\n+                .pixels => |v| CSize.pixels(v),\n+            } else CSize.none(),",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2162664285",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7576,
        "pr_file": "src/config/Config.zig",
        "discussion_id": "2162664285",
        "commented_code": "@@ -6234,6 +6234,44 @@ pub const QuickTerminalSize = struct {\n         height: u32,\n     };\n \n+    /// C API structure for QuickTerminalSize\n+    pub const C = extern struct {\n+        primary: CSize,\n+        secondary: CSize,\n+    };\n+\n+    pub const CSize = extern struct {\n+        type: Type,\n+        value: u32,\n+\n+        pub const Type = enum(u8) { none, percentage, pixels };\n+\n+        fn none() CSize {\n+            return .{ .type = .none, .value = 0 };\n+        }\n+\n+        fn percentage(v: f32) CSize {\n+            return .{ .type = .percentage, .value = @bitCast(v) };\n+        }\n+\n+        fn pixels(v: u32) CSize {\n+            return .{ .type = .pixels, .value = v };\n+        }\n+    };\n+\n+    pub fn cval(self: QuickTerminalSize) C {\n+        return .{\n+            .primary = if (self.primary) |p| switch (p) {\n+                .percentage => |v| CSize.percentage(v),\n+                .pixels => |v| CSize.pixels(v),\n+            } else CSize.none(),\n+            .secondary = if (self.secondary) |s| switch (s) {\n+                .percentage => |v| CSize.percentage(v),\n+                .pixels => |v| CSize.pixels(v),\n+            } else CSize.none(),",
        "comment_created_at": "2025-06-23T23:05:32+00:00",
        "comment_author": "pluiedev",
        "comment_body": "Use decl literals\r\n\r\n```suggestion\r\n            .primary = if (self.primary) |p| switch (p) {\r\n                .percentage => |v| .percentage(v),\r\n                .pixels => |v| .pixels(v),\r\n            } else .none,\r\n            .secondary = if (self.secondary) |s| switch (s) {\r\n                .percentage => |v| .percentage(v),\r\n                .pixels => |v| .pixels(v),\r\n            } else .none,\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2075732816",
    "pr_number": 4464,
    "pr_file": "src/apprt/gtk/TabView.zig",
    "created_at": "2025-05-06T15:28:42+00:00",
    "commented_code": "return self.tab_view.as(gtk.Widget);\n }\n \n+pub fn syncAppearance(self: *TabView) void {\n+    self.setPageIcons();\n+}\n+\n pub fn nPages(self: *TabView) c_int {\n     return self.tab_view.getNPages();\n }\n \n+fn setPageIcons(self: *TabView) void {\n+    const count: usize = @intCast(self.nPages());\n+    for (0..count) |position| {\n+        const page = self.tab_view.getNthPage(@intCast(position));\n+        if (self.window.config.gtk_tab_icons) {\n+            if (position < 10) {\n+                var buf: [48]u8 = undefined;\n+                const name = std.fmt.bufPrintZ(\n+                    &buf,\n+                    \"numeric-{d}-circle-outline-symbolic\",\n+                    .{position + 1},\n+                ) catch unreachable;\n+                const icon = gio.ThemedIcon.new(name);\n+                page.setIcon(icon.as(gio.Icon));\n+            } else {\n+                page.setIcon(null);\n+            }\n+        } else {\n+            page.setIcon(null);\n+        }",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2075732816",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4464,
        "pr_file": "src/apprt/gtk/TabView.zig",
        "discussion_id": "2075732816",
        "commented_code": "@@ -90,10 +105,37 @@ pub fn asWidget(self: *TabView) *gtk.Widget {\n     return self.tab_view.as(gtk.Widget);\n }\n \n+pub fn syncAppearance(self: *TabView) void {\n+    self.setPageIcons();\n+}\n+\n pub fn nPages(self: *TabView) c_int {\n     return self.tab_view.getNPages();\n }\n \n+fn setPageIcons(self: *TabView) void {\n+    const count: usize = @intCast(self.nPages());\n+    for (0..count) |position| {\n+        const page = self.tab_view.getNthPage(@intCast(position));\n+        if (self.window.config.gtk_tab_icons) {\n+            if (position < 10) {\n+                var buf: [48]u8 = undefined;\n+                const name = std.fmt.bufPrintZ(\n+                    &buf,\n+                    \"numeric-{d}-circle-outline-symbolic\",\n+                    .{position + 1},\n+                ) catch unreachable;\n+                const icon = gio.ThemedIcon.new(name);\n+                page.setIcon(icon.as(gio.Icon));\n+            } else {\n+                page.setIcon(null);\n+            }\n+        } else {\n+            page.setIcon(null);\n+        }",
        "comment_created_at": "2025-05-06T15:28:42+00:00",
        "comment_author": "pluiedev",
        "comment_body": "The nested structure is a bit hard to read\r\n```suggestion\r\n        const icon: ?*gio.Icon = icon: {\r\n       \t    if (!self.window.config.gtk_tab_icons) break :icon null;\r\n       \t    if (position >= 10) break :icon null;\r\n       \t    \r\n            var buf: [48]u8 = undefined;\r\n            const name = std.fmt.bufPrintZ(\r\n              &buf,\r\n              \"numeric-{d}-circle-outline-symbolic\",\r\n              .{position + 1},\r\n            ) catch unreachable;\r\n            \r\n            break :icon gio.ThemedIcon.new(name).as(gio.Icon));\r\n        };\r\n        \r\n        page.setIcon(icon);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2075935018",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4464,
        "pr_file": "src/apprt/gtk/TabView.zig",
        "discussion_id": "2075732816",
        "commented_code": "@@ -90,10 +105,37 @@ pub fn asWidget(self: *TabView) *gtk.Widget {\n     return self.tab_view.as(gtk.Widget);\n }\n \n+pub fn syncAppearance(self: *TabView) void {\n+    self.setPageIcons();\n+}\n+\n pub fn nPages(self: *TabView) c_int {\n     return self.tab_view.getNPages();\n }\n \n+fn setPageIcons(self: *TabView) void {\n+    const count: usize = @intCast(self.nPages());\n+    for (0..count) |position| {\n+        const page = self.tab_view.getNthPage(@intCast(position));\n+        if (self.window.config.gtk_tab_icons) {\n+            if (position < 10) {\n+                var buf: [48]u8 = undefined;\n+                const name = std.fmt.bufPrintZ(\n+                    &buf,\n+                    \"numeric-{d}-circle-outline-symbolic\",\n+                    .{position + 1},\n+                ) catch unreachable;\n+                const icon = gio.ThemedIcon.new(name);\n+                page.setIcon(icon.as(gio.Icon));\n+            } else {\n+                page.setIcon(null);\n+            }\n+        } else {\n+            page.setIcon(null);\n+        }",
        "comment_created_at": "2025-05-06T17:16:21+00:00",
        "comment_author": "jcollie",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2176068973",
    "pr_number": 7732,
    "pr_file": "src/font/sprite/Face.zig",
    "created_at": "2025-06-30T22:23:42+00:00",
    "commented_code": "const builtin = @import(\"builtin\");\n const assert = std.debug.assert;\n const Allocator = std.mem.Allocator;\n+const wuffs = @import(\"wuffs\");\n+const z2d = @import(\"z2d\");\n const font = @import(\"../main.zig\");\n const Sprite = font.sprite.Sprite;\n-const Box = @import(\"Box.zig\");\n-const Powerline = @import(\"Powerline.zig\");\n-const underline = @import(\"underline.zig\");\n-const cursor = @import(\"cursor.zig\");\n+\n+const special = @import(\"draw/special.zig\");\n \n const log = std.log.scoped(.font_sprite);\n \n /// Grid metrics for rendering sprites.\n metrics: font.Metrics,\n \n+pub const DrawFnError =\n+    Allocator.Error ||\n+    z2d.painter.FillError ||\n+    z2d.painter.StrokeError ||\n+    error{\n+        /// Something went wrong while doing math.\n+        MathError,\n+    };\n+\n+/// A function that draws a glyph on the provided canvas.\n+pub const DrawFn = fn (\n+    cp: u32,\n+    canvas: *font.sprite.Canvas,\n+    width: u32,\n+    height: u32,\n+    metrics: font.Metrics,\n+) DrawFnError!void;\n+\n+const Range = struct {\n+    min: u32,\n+    max: u32,\n+    draw: DrawFn,\n+};\n+\n+/// Automatically collect ranges for functions with names\n+/// in the format `draw<CP>` or `draw<MIN>_<MAX>`.\n+const ranges = ranges: {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2176068973",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7732,
        "pr_file": "src/font/sprite/Face.zig",
        "discussion_id": "2176068973",
        "commented_code": "@@ -16,25 +16,154 @@ const std = @import(\"std\");\n const builtin = @import(\"builtin\");\n const assert = std.debug.assert;\n const Allocator = std.mem.Allocator;\n+const wuffs = @import(\"wuffs\");\n+const z2d = @import(\"z2d\");\n const font = @import(\"../main.zig\");\n const Sprite = font.sprite.Sprite;\n-const Box = @import(\"Box.zig\");\n-const Powerline = @import(\"Powerline.zig\");\n-const underline = @import(\"underline.zig\");\n-const cursor = @import(\"cursor.zig\");\n+\n+const special = @import(\"draw/special.zig\");\n \n const log = std.log.scoped(.font_sprite);\n \n /// Grid metrics for rendering sprites.\n metrics: font.Metrics,\n \n+pub const DrawFnError =\n+    Allocator.Error ||\n+    z2d.painter.FillError ||\n+    z2d.painter.StrokeError ||\n+    error{\n+        /// Something went wrong while doing math.\n+        MathError,\n+    };\n+\n+/// A function that draws a glyph on the provided canvas.\n+pub const DrawFn = fn (\n+    cp: u32,\n+    canvas: *font.sprite.Canvas,\n+    width: u32,\n+    height: u32,\n+    metrics: font.Metrics,\n+) DrawFnError!void;\n+\n+const Range = struct {\n+    min: u32,\n+    max: u32,\n+    draw: DrawFn,\n+};\n+\n+/// Automatically collect ranges for functions with names\n+/// in the format `draw<CP>` or `draw<MIN>_<MAX>`.\n+const ranges = ranges: {",
        "comment_created_at": "2025-06-30T22:23:42+00:00",
        "comment_author": "mitchellh",
        "comment_body": "Can you add a type signature here? I find with big blocks like this its good practice to prevent future mistyping if we refactor or something. And it just helps self-document a bit",
        "pr_file_module": null
      },
      {
        "comment_id": "2176089795",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7732,
        "pr_file": "src/font/sprite/Face.zig",
        "discussion_id": "2176068973",
        "commented_code": "@@ -16,25 +16,154 @@ const std = @import(\"std\");\n const builtin = @import(\"builtin\");\n const assert = std.debug.assert;\n const Allocator = std.mem.Allocator;\n+const wuffs = @import(\"wuffs\");\n+const z2d = @import(\"z2d\");\n const font = @import(\"../main.zig\");\n const Sprite = font.sprite.Sprite;\n-const Box = @import(\"Box.zig\");\n-const Powerline = @import(\"Powerline.zig\");\n-const underline = @import(\"underline.zig\");\n-const cursor = @import(\"cursor.zig\");\n+\n+const special = @import(\"draw/special.zig\");\n \n const log = std.log.scoped(.font_sprite);\n \n /// Grid metrics for rendering sprites.\n metrics: font.Metrics,\n \n+pub const DrawFnError =\n+    Allocator.Error ||\n+    z2d.painter.FillError ||\n+    z2d.painter.StrokeError ||\n+    error{\n+        /// Something went wrong while doing math.\n+        MathError,\n+    };\n+\n+/// A function that draws a glyph on the provided canvas.\n+pub const DrawFn = fn (\n+    cp: u32,\n+    canvas: *font.sprite.Canvas,\n+    width: u32,\n+    height: u32,\n+    metrics: font.Metrics,\n+) DrawFnError!void;\n+\n+const Range = struct {\n+    min: u32,\n+    max: u32,\n+    draw: DrawFn,\n+};\n+\n+/// Automatically collect ranges for functions with names\n+/// in the format `draw<CP>` or `draw<MIN>_<MAX>`.\n+const ranges = ranges: {",
        "comment_created_at": "2025-06-30T22:39:13+00:00",
        "comment_author": "qwerasd205",
        "comment_body": "Well, it's an array where the size is determined within the block, and you can't do `[_]T` in a type annotation. Would have to move the count code to a separate block to run first if we want an annotation for this.",
        "pr_file_module": null
      },
      {
        "comment_id": "2176092366",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7732,
        "pr_file": "src/font/sprite/Face.zig",
        "discussion_id": "2176068973",
        "commented_code": "@@ -16,25 +16,154 @@ const std = @import(\"std\");\n const builtin = @import(\"builtin\");\n const assert = std.debug.assert;\n const Allocator = std.mem.Allocator;\n+const wuffs = @import(\"wuffs\");\n+const z2d = @import(\"z2d\");\n const font = @import(\"../main.zig\");\n const Sprite = font.sprite.Sprite;\n-const Box = @import(\"Box.zig\");\n-const Powerline = @import(\"Powerline.zig\");\n-const underline = @import(\"underline.zig\");\n-const cursor = @import(\"cursor.zig\");\n+\n+const special = @import(\"draw/special.zig\");\n \n const log = std.log.scoped(.font_sprite);\n \n /// Grid metrics for rendering sprites.\n metrics: font.Metrics,\n \n+pub const DrawFnError =\n+    Allocator.Error ||\n+    z2d.painter.FillError ||\n+    z2d.painter.StrokeError ||\n+    error{\n+        /// Something went wrong while doing math.\n+        MathError,\n+    };\n+\n+/// A function that draws a glyph on the provided canvas.\n+pub const DrawFn = fn (\n+    cp: u32,\n+    canvas: *font.sprite.Canvas,\n+    width: u32,\n+    height: u32,\n+    metrics: font.Metrics,\n+) DrawFnError!void;\n+\n+const Range = struct {\n+    min: u32,\n+    max: u32,\n+    draw: DrawFn,\n+};\n+\n+/// Automatically collect ranges for functions with names\n+/// in the format `draw<CP>` or `draw<MIN>_<MAX>`.\n+const ranges = ranges: {",
        "comment_created_at": "2025-06-30T22:41:16+00:00",
        "comment_author": "mitchellh",
        "comment_body": "Ah ah, duh. No it's okay, maybe a comment then to note it. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2176095332",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7732,
        "pr_file": "src/font/sprite/Face.zig",
        "discussion_id": "2176068973",
        "commented_code": "@@ -16,25 +16,154 @@ const std = @import(\"std\");\n const builtin = @import(\"builtin\");\n const assert = std.debug.assert;\n const Allocator = std.mem.Allocator;\n+const wuffs = @import(\"wuffs\");\n+const z2d = @import(\"z2d\");\n const font = @import(\"../main.zig\");\n const Sprite = font.sprite.Sprite;\n-const Box = @import(\"Box.zig\");\n-const Powerline = @import(\"Powerline.zig\");\n-const underline = @import(\"underline.zig\");\n-const cursor = @import(\"cursor.zig\");\n+\n+const special = @import(\"draw/special.zig\");\n \n const log = std.log.scoped(.font_sprite);\n \n /// Grid metrics for rendering sprites.\n metrics: font.Metrics,\n \n+pub const DrawFnError =\n+    Allocator.Error ||\n+    z2d.painter.FillError ||\n+    z2d.painter.StrokeError ||\n+    error{\n+        /// Something went wrong while doing math.\n+        MathError,\n+    };\n+\n+/// A function that draws a glyph on the provided canvas.\n+pub const DrawFn = fn (\n+    cp: u32,\n+    canvas: *font.sprite.Canvas,\n+    width: u32,\n+    height: u32,\n+    metrics: font.Metrics,\n+) DrawFnError!void;\n+\n+const Range = struct {\n+    min: u32,\n+    max: u32,\n+    draw: DrawFn,\n+};\n+\n+/// Automatically collect ranges for functions with names\n+/// in the format `draw<CP>` or `draw<MIN>_<MAX>`.\n+const ranges = ranges: {",
        "comment_created_at": "2025-06-30T22:43:35+00:00",
        "comment_author": "qwerasd205",
        "comment_body": "You know what, we can copy it in to a const inside the block and then take the reference of that as a slice, seems to work, I'll do that.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1901324242",
    "pr_number": 4226,
    "pr_file": "src/config/Config.zig",
    "created_at": "2025-01-02T22:43:19+00:00",
    "commented_code": "}\n };\n \n+/// Path is a path to a single file.\n+pub const SinglePath = struct {\n+    const Self = @This();\n+\n+    /// The actual value that is updated as we parse.\n+    value: ?[]const u8 = null,\n+\n+    /// Parse a single path.\n+    pub fn parseCLI(self: *Self, alloc: Allocator, input: ?[]const u8) !void {\n+        const value = input orelse return error.ValueRequired;\n+        // If the value is empty, we set the value to null\n+        if (value.len == 0) {\n+            self.value = null;\n+            return;\n+        }\n+        const copy = try alloc.dupe(u8, value);\n+        self.value = copy;\n+    }\n+\n+    /// Deep copy of the struct. Required by Config.\n+    pub fn clone(self: Self, alloc: Allocator) Allocator.Error!Self {\n+        const value = self.value orelse return .{};\n+\n+        const copy_path = try alloc.dupe(u8, value);\n+        return .{\n+            .value = copy_path,\n+        };\n+    }\n+\n+    /// Used by Formatter\n+    pub fn formatEntry(self: Self, formatter: anytype) !void {\n+        const value = self.value orelse return;\n+        try formatter.formatEntry([]const u8, value);\n+    }\n+\n+    pub fn expand(",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "1901324242",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4226,
        "pr_file": "src/config/Config.zig",
        "discussion_id": "1901324242",
        "commented_code": "@@ -4094,6 +4113,91 @@ pub const Palette = struct {\n     }\n };\n \n+/// Path is a path to a single file.\n+pub const SinglePath = struct {\n+    const Self = @This();\n+\n+    /// The actual value that is updated as we parse.\n+    value: ?[]const u8 = null,\n+\n+    /// Parse a single path.\n+    pub fn parseCLI(self: *Self, alloc: Allocator, input: ?[]const u8) !void {\n+        const value = input orelse return error.ValueRequired;\n+        // If the value is empty, we set the value to null\n+        if (value.len == 0) {\n+            self.value = null;\n+            return;\n+        }\n+        const copy = try alloc.dupe(u8, value);\n+        self.value = copy;\n+    }\n+\n+    /// Deep copy of the struct. Required by Config.\n+    pub fn clone(self: Self, alloc: Allocator) Allocator.Error!Self {\n+        const value = self.value orelse return .{};\n+\n+        const copy_path = try alloc.dupe(u8, value);\n+        return .{\n+            .value = copy_path,\n+        };\n+    }\n+\n+    /// Used by Formatter\n+    pub fn formatEntry(self: Self, formatter: anytype) !void {\n+        const value = self.value orelse return;\n+        try formatter.formatEntry([]const u8, value);\n+    }\n+\n+    pub fn expand(",
        "comment_created_at": "2025-01-02T22:43:19+00:00",
        "comment_author": "mitchellh",
        "comment_body": "Given the duplication here with `RepeatablePath`, I'd like to see this pulled out to a shared common function. It'll probably require some parameter changes. This is especially necessary since we just merged home path expansion and this is now missing it.",
        "pr_file_module": null
      },
      {
        "comment_id": "1901438932",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4226,
        "pr_file": "src/config/Config.zig",
        "discussion_id": "1901324242",
        "commented_code": "@@ -4094,6 +4113,91 @@ pub const Palette = struct {\n     }\n };\n \n+/// Path is a path to a single file.\n+pub const SinglePath = struct {\n+    const Self = @This();\n+\n+    /// The actual value that is updated as we parse.\n+    value: ?[]const u8 = null,\n+\n+    /// Parse a single path.\n+    pub fn parseCLI(self: *Self, alloc: Allocator, input: ?[]const u8) !void {\n+        const value = input orelse return error.ValueRequired;\n+        // If the value is empty, we set the value to null\n+        if (value.len == 0) {\n+            self.value = null;\n+            return;\n+        }\n+        const copy = try alloc.dupe(u8, value);\n+        self.value = copy;\n+    }\n+\n+    /// Deep copy of the struct. Required by Config.\n+    pub fn clone(self: Self, alloc: Allocator) Allocator.Error!Self {\n+        const value = self.value orelse return .{};\n+\n+        const copy_path = try alloc.dupe(u8, value);\n+        return .{\n+            .value = copy_path,\n+        };\n+    }\n+\n+    /// Used by Formatter\n+    pub fn formatEntry(self: Self, formatter: anytype) !void {\n+        const value = self.value orelse return;\n+        try formatter.formatEntry([]const u8, value);\n+    }\n+\n+    pub fn expand(",
        "comment_created_at": "2025-01-03T03:18:22+00:00",
        "comment_author": "yunusey",
        "comment_body": "Done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2105838955",
    "pr_number": 7429,
    "pr_file": "src/terminal/osc.zig",
    "created_at": "2025-05-24T14:23:46+00:00",
    "commented_code": "/// Wait input (OSC 9;5)\n     wait_input: void,\n \n+    pub const ColorOperationSource = enum(u16) {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2105838955",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7429,
        "pr_file": "src/terminal/osc.zig",
        "discussion_id": "2105838955",
        "commented_code": "@@ -182,20 +166,42 @@ pub const Command = union(enum) {\n     /// Wait input (OSC 9;5)\n     wait_input: void,\n \n+    pub const ColorOperationSource = enum(u16) {",
        "comment_created_at": "2025-05-24T14:23:46+00:00",
        "comment_author": "mitchellh",
        "comment_body": "I think we should nest all the of these in a single `ColorOperation` struct.\r\n\r\n```zig\r\npub const ColorOperation = struct {\r\n  pub const Source = ...;\r\n  pub const List = ...;\r\n  pub const Kind = ...;\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2105874707",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7429,
        "pr_file": "src/terminal/osc.zig",
        "discussion_id": "2105838955",
        "commented_code": "@@ -182,20 +166,42 @@ pub const Command = union(enum) {\n     /// Wait input (OSC 9;5)\n     wait_input: void,\n \n+    pub const ColorOperationSource = enum(u16) {",
        "comment_created_at": "2025-05-24T16:30:26+00:00",
        "comment_author": "jcollie",
        "comment_body": "Done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2062635600",
    "pr_number": 7195,
    "pr_file": "src/config/Config.zig",
    "created_at": "2025-04-27T13:54:29+00:00",
    "commented_code": "/// The actual value that is updated as we parse.\n     value: terminal.color.Palette = terminal.color.default,\n \n+    /// ghostty_config_palette_s\n+    pub const C = extern struct {\n+        colors: [265]Color.C,\n+    };\n+\n+    pub fn cval(self: Self) Palette.C {\n+        var result: Palette.C = undefined;\n+        for (self.value, 0..) |color, i| {\n+            result.colors[i] = Color.C{",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2062635600",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7195,
        "pr_file": "src/config/Config.zig",
        "discussion_id": "2062635600",
        "commented_code": "@@ -3930,6 +3930,24 @@ pub const Palette = struct {\n     /// The actual value that is updated as we parse.\n     value: terminal.color.Palette = terminal.color.default,\n \n+    /// ghostty_config_palette_s\n+    pub const C = extern struct {\n+        colors: [265]Color.C,\n+    };\n+\n+    pub fn cval(self: Self) Palette.C {\n+        var result: Palette.C = undefined;\n+        for (self.value, 0..) |color, i| {\n+            result.colors[i] = Color.C{",
        "comment_created_at": "2025-04-27T13:54:29+00:00",
        "comment_author": "mitchellh",
        "comment_body": "Style: can do `.{` here since the result type is well known.\r\n\r\nIf you want to get really fancy you don't need the block in the `for` either since this is a single expression, but we mix that up all over the codebase.",
        "pr_file_module": null
      },
      {
        "comment_id": "2063722009",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7195,
        "pr_file": "src/config/Config.zig",
        "discussion_id": "2062635600",
        "commented_code": "@@ -3930,6 +3930,24 @@ pub const Palette = struct {\n     /// The actual value that is updated as we parse.\n     value: terminal.color.Palette = terminal.color.default,\n \n+    /// ghostty_config_palette_s\n+    pub const C = extern struct {\n+        colors: [265]Color.C,\n+    };\n+\n+    pub fn cval(self: Self) Palette.C {\n+        var result: Palette.C = undefined;\n+        for (self.value, 0..) |color, i| {\n+            result.colors[i] = Color.C{",
        "comment_created_at": "2025-04-28T13:57:54+00:00",
        "comment_author": "freepicheep",
        "comment_body": "Thank you! I'm new to Zig, so I appreciate the tutoring.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1975553172",
    "pr_number": 6027,
    "pr_file": "src/apprt/gtk/Window.zig",
    "created_at": "2025-02-28T14:57:34+00:00",
    "commented_code": "// freed when the window is closed.\n     var window = try alloc.create(Window);\n     errdefer alloc.destroy(window);\n-    try window.init(app);\n+    try window.init(app, is_quick_terminal);\n     return window;\n }\n \n-pub fn init(self: *Window, app: *App) !void {\n+pub fn init(self: *Window, app: *App, is_quick_terminal: bool) !void {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "1975553172",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 6027,
        "pr_file": "src/apprt/gtk/Window.zig",
        "discussion_id": "1975553172",
        "commented_code": "@@ -111,11 +118,11 @@ pub fn create(alloc: Allocator, app: *App) !*Window {\n     // freed when the window is closed.\n     var window = try alloc.create(Window);\n     errdefer alloc.destroy(window);\n-    try window.init(app);\n+    try window.init(app, is_quick_terminal);\n     return window;\n }\n \n-pub fn init(self: *Window, app: *App) !void {\n+pub fn init(self: *Window, app: *App, is_quick_terminal: bool) !void {",
        "comment_created_at": "2025-02-28T14:57:34+00:00",
        "comment_author": "mitchellh",
        "comment_body": "I think it'd be an improvement to separate these into separate functions: `init` and `initQuickTerminal`. It'll make it easier to grep for when looking for things that setup a quick terminal and I think is generally nicer than a modal bool on a public interface.\r\n\r\n(Internally, they probably drive back to the same non-pub `initPrivate` or w/e).",
        "pr_file_module": null
      },
      {
        "comment_id": "1975737464",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 6027,
        "pr_file": "src/apprt/gtk/Window.zig",
        "discussion_id": "1975553172",
        "commented_code": "@@ -111,11 +118,11 @@ pub fn create(alloc: Allocator, app: *App) !*Window {\n     // freed when the window is closed.\n     var window = try alloc.create(Window);\n     errdefer alloc.destroy(window);\n-    try window.init(app);\n+    try window.init(app, is_quick_terminal);\n     return window;\n }\n \n-pub fn init(self: *Window, app: *App) !void {\n+pub fn init(self: *Window, app: *App, is_quick_terminal: bool) !void {",
        "comment_created_at": "2025-02-28T17:00:38+00:00",
        "comment_author": "pluiedev",
        "comment_body": "I've decided to instead split the initialization logic so that it doesn't immediately present the window after initialization",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1904752323",
    "pr_number": 4723,
    "pr_file": "src/apprt/gtk/App.zig",
    "created_at": "2025-01-06T23:50:08+00:00",
    "commented_code": "return error.GtkApplicationRegisterFailed;\n     }\n \n-    // Perform all X11 initialization. This ultimately returns the X11\n-    // keyboard state but the block does more than that (i.e. setting up\n-    // WM_CLASS).\n-    const x11_xkb: ?x11.Xkb = x11_xkb: {\n-        if (comptime !build_options.x11) break :x11_xkb null;\n-        if (!x11.is_display(display)) break :x11_xkb null;\n-\n-        // Set the X11 window class property (WM_CLASS) if are are on an X11\n-        // display.\n-        //\n-        // Note that we also set the program name here using g_set_prgname.\n-        // This is how the instance name field for WM_CLASS is derived when\n-        // calling gdk_x11_display_set_program_class; there does not seem to be\n-        // a way to set it directly. It does not look like this is being set by\n-        // our other app initialization routines currently, but since we're\n-        // currently deriving its value from x11-instance-name effectively, I\n-        // feel like gating it behind an X11 check is better intent.\n-        //\n-        // This makes the property show up like so when using xprop:\n-        //\n-        //     WM_CLASS(STRING) = \"ghostty\", \"com.mitchellh.ghostty\"\n-        //\n-        // Append \"-debug\" on both when using the debug build.\n-        //\n-        const prgname = if (config.@\"x11-instance-name\") |pn|\n-            pn\n-        else if (builtin.mode == .Debug)\n-            \"ghostty-debug\"\n-        else\n-            \"ghostty\";\n-        c.g_set_prgname(prgname);\n-        c.gdk_x11_display_set_program_class(display, app_id);\n-\n-        // Set up Xkb\n-        break :x11_xkb try x11.Xkb.init(display);\n-    };\n-\n-    // Initialize Wayland state\n-    var wl = wayland.AppState.init(display);\n-    if (wl) |*w| try w.register();\n+    var app_platform: platform.AppState = undefined;\n+    app_platform.init(display, &config, app_id);\n+    try app_platform.setup();",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "1904752323",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4723,
        "pr_file": "src/apprt/gtk/App.zig",
        "discussion_id": "1904752323",
        "commented_code": "@@ -364,46 +359,9 @@ pub fn init(core_app: *CoreApp, opts: Options) !App {\n         return error.GtkApplicationRegisterFailed;\n     }\n \n-    // Perform all X11 initialization. This ultimately returns the X11\n-    // keyboard state but the block does more than that (i.e. setting up\n-    // WM_CLASS).\n-    const x11_xkb: ?x11.Xkb = x11_xkb: {\n-        if (comptime !build_options.x11) break :x11_xkb null;\n-        if (!x11.is_display(display)) break :x11_xkb null;\n-\n-        // Set the X11 window class property (WM_CLASS) if are are on an X11\n-        // display.\n-        //\n-        // Note that we also set the program name here using g_set_prgname.\n-        // This is how the instance name field for WM_CLASS is derived when\n-        // calling gdk_x11_display_set_program_class; there does not seem to be\n-        // a way to set it directly. It does not look like this is being set by\n-        // our other app initialization routines currently, but since we're\n-        // currently deriving its value from x11-instance-name effectively, I\n-        // feel like gating it behind an X11 check is better intent.\n-        //\n-        // This makes the property show up like so when using xprop:\n-        //\n-        //     WM_CLASS(STRING) = \"ghostty\", \"com.mitchellh.ghostty\"\n-        //\n-        // Append \"-debug\" on both when using the debug build.\n-        //\n-        const prgname = if (config.@\"x11-instance-name\") |pn|\n-            pn\n-        else if (builtin.mode == .Debug)\n-            \"ghostty-debug\"\n-        else\n-            \"ghostty\";\n-        c.g_set_prgname(prgname);\n-        c.gdk_x11_display_set_program_class(display, app_id);\n-\n-        // Set up Xkb\n-        break :x11_xkb try x11.Xkb.init(display);\n-    };\n-\n-    // Initialize Wayland state\n-    var wl = wayland.AppState.init(display);\n-    if (wl) |*w| try w.register();\n+    var app_platform: platform.AppState = undefined;\n+    app_platform.init(display, &config, app_id);\n+    try app_platform.setup();",
        "comment_created_at": "2025-01-06T23:50:08+00:00",
        "comment_author": "mitchellh",
        "comment_body": "If `setup` is always called directly after `init`, then we should combine `init` and `setup` into a fail-able `init`.",
        "pr_file_module": null
      }
    ]
  }
]