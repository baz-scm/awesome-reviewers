[
  {
    "discussion_id": "1970333389",
    "pr_number": 5988,
    "pr_file": "src/os/open.zig",
    "created_at": "2025-02-25T18:34:31+00:00",
    "commented_code": "child: std.process.Child,\n     wait: bool = false,\n };\n+\n+/// Use `xdg-open` to open a URL using the default application.\n+///\n+/// Any output on stderr is logged as a warning in the application logs. Output\n+/// on stdout is ignored.\n+pub fn openUrlLinux(\n+    alloc: Allocator,\n+    url: [:0]const u8,\n+) void {\n+    // Make a copy of the URL so that we can use it in the thread without\n+    // worrying about it getting freed by other threads.\n+    const copy = alloc.dupe(u8, url) catch |err| {\n+        log.warn(\"unable to copy URL before opening: {}\", .{err});\n+        return;\n+    };\n+    // Run `xdg-open` in a thread so that it never blocks the main thread, no\n+    // matter how long it takes to execute.\n+    const thread = std.Thread.spawn(.{}, _openUrlLinux, .{ alloc, copy }) catch |err| {\n+        alloc.free(url);\n+        log.warn(\"unable to start thread to launch url: {}\", .{err});\n+        return;\n+    };\n+    // Don't worry about the thread any more.\n+    thread.detach();\n+}\n+\n+fn _openUrlLinux(alloc: Allocator, url: []const u8) void {\n+    defer alloc.free(url);\n+\n+    var exe = std.process.Child.init(\n+        &.{ \"xdg-open\", url },\n+        alloc,\n+    );\n+\n+    // We're only interested in stderr\n+    exe.stdin_behavior = .Ignore;\n+    exe.stdout_behavior = .Ignore;\n+    exe.stderr_behavior = .Pipe;\n+\n+    exe.spawn() catch |err| {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "1970333389",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 5988,
        "pr_file": "src/os/open.zig",
        "discussion_id": "1970333389",
        "commented_code": "@@ -77,3 +81,131 @@ const OpenCommand = struct {\n     child: std.process.Child,\n     wait: bool = false,\n };\n+\n+/// Use `xdg-open` to open a URL using the default application.\n+///\n+/// Any output on stderr is logged as a warning in the application logs. Output\n+/// on stdout is ignored.\n+pub fn openUrlLinux(\n+    alloc: Allocator,\n+    url: [:0]const u8,\n+) void {\n+    // Make a copy of the URL so that we can use it in the thread without\n+    // worrying about it getting freed by other threads.\n+    const copy = alloc.dupe(u8, url) catch |err| {\n+        log.warn(\"unable to copy URL before opening: {}\", .{err});\n+        return;\n+    };\n+    // Run `xdg-open` in a thread so that it never blocks the main thread, no\n+    // matter how long it takes to execute.\n+    const thread = std.Thread.spawn(.{}, _openUrlLinux, .{ alloc, copy }) catch |err| {\n+        alloc.free(url);\n+        log.warn(\"unable to start thread to launch url: {}\", .{err});\n+        return;\n+    };\n+    // Don't worry about the thread any more.\n+    thread.detach();\n+}\n+\n+fn _openUrlLinux(alloc: Allocator, url: []const u8) void {\n+    defer alloc.free(url);\n+\n+    var exe = std.process.Child.init(\n+        &.{ \"xdg-open\", url },\n+        alloc,\n+    );\n+\n+    // We're only interested in stderr\n+    exe.stdin_behavior = .Ignore;\n+    exe.stdout_behavior = .Ignore;\n+    exe.stderr_behavior = .Pipe;\n+\n+    exe.spawn() catch |err| {",
        "comment_created_at": "2025-02-25T18:34:31+00:00",
        "comment_author": "mitchellh",
        "comment_body": "Having bunch of `catch` in this is nasty and makes it so `err defer` can't be used (if we even wanted to). I recommend the following pattern instead:\r\n\r\n```zig\r\nfn openUrlLinuxThread(...) void {\r\n    // Handle error once\r\n    openUrlLinuxThreadError(...) catch |err| {}\r\n}\r\n\r\nfn openUrlLinuxThreadError(...) !void {\r\n    // Return errors like normal, use errdefer.\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1970384076",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 5988,
        "pr_file": "src/os/open.zig",
        "discussion_id": "1970333389",
        "commented_code": "@@ -77,3 +81,131 @@ const OpenCommand = struct {\n     child: std.process.Child,\n     wait: bool = false,\n };\n+\n+/// Use `xdg-open` to open a URL using the default application.\n+///\n+/// Any output on stderr is logged as a warning in the application logs. Output\n+/// on stdout is ignored.\n+pub fn openUrlLinux(\n+    alloc: Allocator,\n+    url: [:0]const u8,\n+) void {\n+    // Make a copy of the URL so that we can use it in the thread without\n+    // worrying about it getting freed by other threads.\n+    const copy = alloc.dupe(u8, url) catch |err| {\n+        log.warn(\"unable to copy URL before opening: {}\", .{err});\n+        return;\n+    };\n+    // Run `xdg-open` in a thread so that it never blocks the main thread, no\n+    // matter how long it takes to execute.\n+    const thread = std.Thread.spawn(.{}, _openUrlLinux, .{ alloc, copy }) catch |err| {\n+        alloc.free(url);\n+        log.warn(\"unable to start thread to launch url: {}\", .{err});\n+        return;\n+    };\n+    // Don't worry about the thread any more.\n+    thread.detach();\n+}\n+\n+fn _openUrlLinux(alloc: Allocator, url: []const u8) void {\n+    defer alloc.free(url);\n+\n+    var exe = std.process.Child.init(\n+        &.{ \"xdg-open\", url },\n+        alloc,\n+    );\n+\n+    // We're only interested in stderr\n+    exe.stdin_behavior = .Ignore;\n+    exe.stdout_behavior = .Ignore;\n+    exe.stderr_behavior = .Pipe;\n+\n+    exe.spawn() catch |err| {",
        "comment_created_at": "2025-02-25T19:14:46+00:00",
        "comment_author": "jcollie",
        "comment_body": "Fixed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159344412",
    "pr_number": 7620,
    "pr_file": "src/renderer/metal/Texture.zig",
    "created_at": "2025-06-20T16:29:41+00:00",
    "commented_code": "+//! Wrapper for handling textures.\n+const Self = @This();\n+\n+const std = @import(\"std\");\n+const Allocator = std.mem.Allocator;\n+const assert = std.debug.assert;\n+const builtin = @import(\"builtin\");\n+const objc = @import(\"objc\");\n+\n+const mtl = @import(\"api.zig\");\n+const Metal = @import(\"../Metal.zig\");\n+\n+const log = std.log.scoped(.metal);\n+\n+/// Options for initializing a texture.\n+pub const Options = struct {\n+    /// MTLDevice\n+    device: objc.Object,\n+    pixel_format: mtl.MTLPixelFormat,\n+    resource_options: mtl.MTLResourceOptions,\n+};\n+\n+/// The underlying MTLTexture Object.\n+texture: objc.Object,\n+\n+/// The width of this texture.\n+width: usize,\n+/// The height of this texture.\n+height: usize,\n+\n+/// Bytes per pixel for this texture.\n+bpp: usize,\n+\n+/// Initialize a texture\n+pub fn init(\n+    opts: Options,\n+    width: usize,\n+    height: usize,\n+    data: ?[]const u8,\n+) !Self {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2159344412",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7620,
        "pr_file": "src/renderer/metal/Texture.zig",
        "discussion_id": "2159344412",
        "commented_code": "@@ -0,0 +1,196 @@\n+//! Wrapper for handling textures.\n+const Self = @This();\n+\n+const std = @import(\"std\");\n+const Allocator = std.mem.Allocator;\n+const assert = std.debug.assert;\n+const builtin = @import(\"builtin\");\n+const objc = @import(\"objc\");\n+\n+const mtl = @import(\"api.zig\");\n+const Metal = @import(\"../Metal.zig\");\n+\n+const log = std.log.scoped(.metal);\n+\n+/// Options for initializing a texture.\n+pub const Options = struct {\n+    /// MTLDevice\n+    device: objc.Object,\n+    pixel_format: mtl.MTLPixelFormat,\n+    resource_options: mtl.MTLResourceOptions,\n+};\n+\n+/// The underlying MTLTexture Object.\n+texture: objc.Object,\n+\n+/// The width of this texture.\n+width: usize,\n+/// The height of this texture.\n+height: usize,\n+\n+/// Bytes per pixel for this texture.\n+bpp: usize,\n+\n+/// Initialize a texture\n+pub fn init(\n+    opts: Options,\n+    width: usize,\n+    height: usize,\n+    data: ?[]const u8,\n+) !Self {",
        "comment_created_at": "2025-06-20T16:29:41+00:00",
        "comment_author": "mitchellh",
        "comment_body": "Pretty sure this can have an explicit error set. Eyeballed it down and it looks clean.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2159345888",
    "pr_number": 7620,
    "pr_file": "src/renderer/OpenGL.zig",
    "created_at": "2025-06-20T16:30:52+00:00",
    "commented_code": "-//! Rendering implementation for OpenGL.\n+//! Graphics API wrapper for OpenGL.\n pub const OpenGL = @This();\n \n const std = @import(\"std\");\n-const builtin = @import(\"builtin\");\n-const glfw = @import(\"glfw\");\n const assert = std.debug.assert;\n-const testing = std.testing;\n const Allocator = std.mem.Allocator;\n-const ArenaAllocator = std.heap.ArenaAllocator;\n-const link = @import(\"link.zig\");\n-const isCovering = @import(\"cell.zig\").isCovering;\n-const fgMode = @import(\"cell.zig\").fgMode;\n+const builtin = @import(\"builtin\");\n+const glfw = @import(\"glfw\");\n+const gl = @import(\"opengl\");\n const shadertoy = @import(\"shadertoy.zig\");\n const apprt = @import(\"../apprt.zig\");\n-const configpkg = @import(\"../config.zig\");\n const font = @import(\"../font/main.zig\");\n-const imgui = @import(\"imgui\");\n-const renderer = @import(\"../renderer.zig\");\n-const terminal = @import(\"../terminal/main.zig\");\n-const Terminal = terminal.Terminal;\n-const gl = @import(\"opengl\");\n-const math = @import(\"../math.zig\");\n-const Surface = @import(\"../Surface.zig\");\n-\n-const CellProgram = @import(\"opengl/CellProgram.zig\");\n-const ImageProgram = @import(\"opengl/ImageProgram.zig\");\n-const gl_image = @import(\"opengl/image.zig\");\n-const custom = @import(\"opengl/custom.zig\");\n-const Image = gl_image.Image;\n-const ImageMap = gl_image.ImageMap;\n-const ImagePlacementList = std.ArrayListUnmanaged(gl_image.Placement);\n-\n-const log = std.log.scoped(.grid);\n-\n-/// The runtime can request a single-threaded draw by setting this boolean\n-/// to true. In this case, the renderer.draw() call is expected to be called\n-/// from the runtime.\n-pub const single_threaded_draw = if (@hasDecl(apprt.Surface, \"opengl_single_threaded_draw\"))\n-    apprt.Surface.opengl_single_threaded_draw\n-else\n-    false;\n-const DrawMutex = if (single_threaded_draw) std.Thread.Mutex else void;\n-const drawMutexZero: DrawMutex = if (DrawMutex == void) void{} else .{};\n-\n-alloc: std.mem.Allocator,\n-\n-/// The configuration we need derived from the main config.\n-config: DerivedConfig,\n-\n-/// Current font metrics defining our grid.\n-grid_metrics: font.Metrics,\n-\n-/// The size of everything.\n-size: renderer.Size,\n-\n-/// The current set of cells to render. Each set of cells goes into\n-/// a separate shader call.\n-cells_bg: std.ArrayListUnmanaged(CellProgram.Cell),\n-cells: std.ArrayListUnmanaged(CellProgram.Cell),\n-\n-/// The last viewport that we based our rebuild off of. If this changes,\n-/// then we do a full rebuild of the cells. The pointer values in this pin\n-/// are NOT SAFE to read because they may be modified, freed, etc from the\n-/// termio thread. We treat the pointers as integers for comparison only.\n-cells_viewport: ?terminal.Pin = null,\n-\n-/// The size of the cells list that was sent to the GPU. This is used\n-/// to detect when the cells array was reallocated/resized and handle that\n-/// accordingly.\n-gl_cells_size: usize = 0,\n-\n-/// The last length of the cells that was written to the GPU. This is used to\n-/// determine what data needs to be rewritten on the GPU.\n-gl_cells_written: usize = 0,\n-\n-/// Shader program for cell rendering.\n-gl_state: ?GLState = null,\n-\n-/// The font structures.\n-font_grid: *font.SharedGrid,\n-font_shaper: font.Shaper,\n-font_shaper_cache: font.ShaperCache,\n-texture_grayscale_modified: usize = 0,\n-texture_grayscale_resized: usize = 0,\n-texture_color_modified: usize = 0,\n-texture_color_resized: usize = 0,\n-\n-/// True if the window is focused\n-focused: bool,\n-\n-/// The foreground color set by an OSC 10 sequence. If unset then the default\n-/// value from the config file is used.\n-foreground_color: ?terminal.color.RGB,\n-\n-/// Foreground color set in the user's config file.\n-default_foreground_color: terminal.color.RGB,\n-\n-/// The background color set by an OSC 11 sequence. If unset then the default\n-/// value from the config file is used.\n-background_color: ?terminal.color.RGB,\n-\n-/// Background color set in the user's config file.\n-default_background_color: terminal.color.RGB,\n-\n-/// The cursor color set by an OSC 12 sequence. If unset then\n-/// default_cursor_color is used.\n-cursor_color: ?terminal.color.RGB,\n-\n-/// Default cursor color when no color is set explicitly by an OSC 12 command.\n-/// This is cursor color as set in the user's config, if any. If no cursor color\n-/// is set in the user's config, then the cursor color is determined by the\n-/// current foreground color.\n-default_cursor_color: ?terminal.color.RGB,\n-\n-/// When `cursor_color` is null, swap the foreground and background colors of\n-/// the cell under the cursor for the cursor color. Otherwise, use the default\n-/// foreground color as the cursor color.\n-cursor_invert: bool,\n-\n-/// The mailbox for communicating with the window.\n-surface_mailbox: apprt.surface.Mailbox,\n-\n-/// Deferred operations. This is used to apply changes to the OpenGL context.\n-/// Some runtimes (GTK) do not support multi-threading so to keep our logic\n-/// simple we apply all OpenGL context changes in the render() call.\n-deferred_screen_size: ?SetScreenSize = null,\n-deferred_font_size: ?SetFontSize = null,\n-deferred_config: ?SetConfig = null,\n-\n-/// If we're drawing with single threaded operations\n-draw_mutex: DrawMutex = drawMutexZero,\n-\n-/// Current background to draw. This may not match self.background if the\n-/// terminal is in reversed mode.\n-draw_background: terminal.color.RGB,\n-\n-/// Whether we're doing padding extension for vertical sides.\n-padding_extend_top: bool = true,\n-padding_extend_bottom: bool = true,\n-\n-/// The images that we may render.\n-images: ImageMap = .{},\n-image_placements: ImagePlacementList = .{},\n-image_bg_end: u32 = 0,\n-image_text_end: u32 = 0,\n-image_virtual: bool = false,\n-\n-/// Deferred OpenGL operation to update the screen size.\n-const SetScreenSize = struct {\n-    size: renderer.Size,\n-\n-    fn apply(self: SetScreenSize, r: *OpenGL) !void {\n-        const gl_state: *GLState = if (r.gl_state) |*v|\n-            v\n-        else\n-            return error.OpenGLUninitialized;\n-\n-        // Apply our padding\n-        const grid_size = self.size.grid();\n-        const terminal_size = self.size.terminal();\n-\n-        // Blank space around the grid.\n-        const blank: renderer.Padding = switch (r.config.padding_color) {\n-            // We can use zero padding because the background color is our\n-            // clear color.\n-            .background => .{},\n-\n-            .extend, .@\"extend-always\" => self.size.screen.blankPadding(\n-                self.size.padding,\n-                grid_size,\n-                self.size.cell,\n-            ).add(self.size.padding),\n-        };\n-\n-        // Update our viewport for this context to be the entire window.\n-        // OpenGL works in pixels, so we have to use the pixel size.\n-        try gl.viewport(\n-            0,\n-            0,\n-            @intCast(self.size.screen.width),\n-            @intCast(self.size.screen.height),\n-        );\n-\n-        // Update the projection uniform within our shader\n-        inline for (.{ \"cell_program\", \"image_program\" }) |name| {\n-            const program = @field(gl_state, name);\n-            const bind = try program.program.use();\n-            defer bind.unbind();\n-            try program.program.setUniform(\n-                \"projection\",\n-\n-                // 2D orthographic projection with the full w/h\n-                math.ortho2d(\n-                    -1 * @as(f32, @floatFromInt(self.size.padding.left)),\n-                    @floatFromInt(terminal_size.width + self.size.padding.right),\n-                    @floatFromInt(terminal_size.height + self.size.padding.bottom),\n-                    -1 * @as(f32, @floatFromInt(self.size.padding.top)),\n-                ),\n-            );\n-        }\n-\n-        // Setup our grid padding\n-        {\n-            const program = gl_state.cell_program;\n-            const bind = try program.program.use();\n-            defer bind.unbind();\n-            try program.program.setUniform(\n-                \"grid_padding\",\n-                @Vector(4, f32){\n-                    @floatFromInt(blank.top),\n-                    @floatFromInt(blank.right),\n-                    @floatFromInt(blank.bottom),\n-                    @floatFromInt(blank.left),\n-                },\n-            );\n-            try program.program.setUniform(\n-                \"grid_size\",\n-                @Vector(2, f32){\n-                    @floatFromInt(grid_size.columns),\n-                    @floatFromInt(grid_size.rows),\n-                },\n-            );\n-        }\n-\n-        // Update our custom shader resolution\n-        if (gl_state.custom) |*custom_state| {\n-            try custom_state.setScreenSize(self.size);\n-        }\n-    }\n-};\n-\n-const SetFontSize = struct {\n-    metrics: font.Metrics,\n-\n-    fn apply(self: SetFontSize, r: *const OpenGL) !void {\n-        const gl_state = r.gl_state orelse return error.OpenGLUninitialized;\n-\n-        inline for (.{ \"cell_program\", \"image_program\" }) |name| {\n-            const program = @field(gl_state, name);\n-            const bind = try program.program.use();\n-            defer bind.unbind();\n-            try program.program.setUniform(\n-                \"cell_size\",\n-                @Vector(2, f32){\n-                    @floatFromInt(self.metrics.cell_width),\n-                    @floatFromInt(self.metrics.cell_height),\n-                },\n-            );\n-        }\n-    }\n-};\n-\n-const SetConfig = struct {\n-    fn apply(self: SetConfig, r: *const OpenGL) !void {\n-        _ = self;\n-        const gl_state = r.gl_state orelse return error.OpenGLUninitialized;\n-\n-        const bind = try gl_state.cell_program.program.use();\n-        defer bind.unbind();\n-        try gl_state.cell_program.program.setUniform(\n-            \"min_contrast\",\n-            r.config.min_contrast,\n-        );\n-    }\n-};\n-\n-/// The configuration for this renderer that is derived from the main\n-/// configuration. This must be exported so that we don't need to\n-/// pass around Config pointers which makes memory management a pain.\n-pub const DerivedConfig = struct {\n-    arena: ArenaAllocator,\n-\n-    font_thicken: bool,\n-    font_thicken_strength: u8,\n-    font_features: std.ArrayListUnmanaged([:0]const u8),\n-    font_styles: font.CodepointResolver.StyleStatus,\n-    cursor_color: ?terminal.color.RGB,\n-    cursor_invert: bool,\n-    cursor_text: ?terminal.color.RGB,\n-    cursor_opacity: f64,\n-    background: terminal.color.RGB,\n-    background_opacity: f64,\n-    foreground: terminal.color.RGB,\n-    selection_background: ?terminal.color.RGB,\n-    selection_foreground: ?terminal.color.RGB,\n-    invert_selection_fg_bg: bool,\n-    bold_is_bright: bool,\n-    min_contrast: f32,\n-    padding_color: configpkg.WindowPaddingColor,\n-    custom_shaders: configpkg.RepeatablePath,\n-    links: link.Set,\n-\n-    pub fn init(\n-        alloc_gpa: Allocator,\n-        config: *const configpkg.Config,\n-    ) !DerivedConfig {\n-        var arena = ArenaAllocator.init(alloc_gpa);\n-        errdefer arena.deinit();\n-        const alloc = arena.allocator();\n-\n-        // Copy our shaders\n-        const custom_shaders = try config.@\"custom-shader\".clone(alloc);\n-\n-        // Copy our font features\n-        const font_features = try config.@\"font-feature\".clone(alloc);\n-\n-        // Get our font styles\n-        var font_styles = font.CodepointResolver.StyleStatus.initFill(true);\n-        font_styles.set(.bold, config.@\"font-style-bold\" != .false);\n-        font_styles.set(.italic, config.@\"font-style-italic\" != .false);\n-        font_styles.set(.bold_italic, config.@\"font-style-bold-italic\" != .false);\n-\n-        // Our link configs\n-        const links = try link.Set.fromConfig(\n-            alloc,\n-            config.link.links.items,\n-        );\n-\n-        const cursor_invert = config.@\"cursor-invert-fg-bg\";\n-\n-        return .{\n-            .background_opacity = @max(0, @min(1, config.@\"background-opacity\")),\n-            .font_thicken = config.@\"font-thicken\",\n-            .font_thicken_strength = config.@\"font-thicken-strength\",\n-            .font_features = font_features.list,\n-            .font_styles = font_styles,\n-\n-            .cursor_color = if (!cursor_invert and config.@\"cursor-color\" != null)\n-                config.@\"cursor-color\".?.toTerminalRGB()\n-            else\n-                null,\n-\n-            .cursor_invert = cursor_invert,\n-\n-            .cursor_text = if (config.@\"cursor-text\") |txt|\n-                txt.toTerminalRGB()\n-            else\n-                null,\n-\n-            .cursor_opacity = @max(0, @min(1, config.@\"cursor-opacity\")),\n+const configpkg = @import(\"../config.zig\");\n+const rendererpkg = @import(\"../renderer.zig\");\n+const Renderer = rendererpkg.GenericRenderer(OpenGL);\n \n-            .background = config.background.toTerminalRGB(),\n-            .foreground = config.foreground.toTerminalRGB(),\n-            .invert_selection_fg_bg = config.@\"selection-invert-fg-bg\",\n-            .bold_is_bright = config.@\"bold-is-bright\",\n-            .min_contrast = @floatCast(config.@\"minimum-contrast\"),\n-            .padding_color = config.@\"window-padding-color\",\n+pub const GraphicsAPI = OpenGL;\n+pub const Target = @import(\"opengl/Target.zig\");\n+pub const Frame = @import(\"opengl/Frame.zig\");\n+pub const RenderPass = @import(\"opengl/RenderPass.zig\");\n+pub const Pipeline = @import(\"opengl/Pipeline.zig\");\n+const bufferpkg = @import(\"opengl/buffer.zig\");\n+pub const Buffer = bufferpkg.Buffer;\n+pub const Texture = @import(\"opengl/Texture.zig\");\n+pub const shaders = @import(\"opengl/shaders.zig\");\n \n-            .selection_background = if (config.@\"selection-background\") |bg|\n-                bg.toTerminalRGB()\n-            else\n-                null,\n+pub const cellpkg = @import(\"opengl/cell.zig\");\n+pub const imagepkg = @import(\"opengl/image.zig\");\n \n-            .selection_foreground = if (config.@\"selection-foreground\") |bg|\n-                bg.toTerminalRGB()\n-            else\n-                null,\n+pub const custom_shader_target: shadertoy.Target = .glsl;\n \n-            .custom_shaders = custom_shaders,\n-            .links = links,\n+/// Because OpenGL's frame completion is always\n+/// sync, we have no need for multi-buffering.\n+pub const swap_chain_count = 1;\n \n-            .arena = arena,\n-        };\n-    }\n+const log = std.log.scoped(.opengl);\n \n-    pub fn deinit(self: *DerivedConfig) void {\n-        const alloc = self.arena.allocator();\n-        self.links.deinit(alloc);\n-        self.arena.deinit();\n-    }\n-};\n+/// We require at least OpenGL 4.3\n+pub const MIN_VERSION_MAJOR = 4;\n+pub const MIN_VERSION_MINOR = 3;\n \n-pub fn init(alloc: Allocator, options: renderer.Options) !OpenGL {\n-    // Create the initial font shaper\n-    var shaper = try font.Shaper.init(alloc, .{\n-        .features = options.config.font_features.items,\n-    });\n-    errdefer shaper.deinit();\n+alloc: std.mem.Allocator,\n \n-    // For the remainder of the setup we lock our font grid data because\n-    // we're reading it.\n-    const grid = options.font_grid;\n-    grid.lock.lockShared();\n-    defer grid.lock.unlockShared();\n+/// Alpha blending mode\n+blending: configpkg.Config.AlphaBlending,\n \n-    var gl_state = try GLState.init(alloc, options.config, grid);\n-    errdefer gl_state.deinit();\n+/// The most recently presented target, in case we need to present it again.\n+last_target: ?Target = null,\n \n-    return OpenGL{\n+pub fn init(alloc: Allocator, opts: rendererpkg.Options) !OpenGL {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2159345888",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7620,
        "pr_file": "src/renderer/OpenGL.zig",
        "discussion_id": "2159345888",
        "commented_code": "@@ -1,450 +1,171 @@\n-//! Rendering implementation for OpenGL.\n+//! Graphics API wrapper for OpenGL.\n pub const OpenGL = @This();\n \n const std = @import(\"std\");\n-const builtin = @import(\"builtin\");\n-const glfw = @import(\"glfw\");\n const assert = std.debug.assert;\n-const testing = std.testing;\n const Allocator = std.mem.Allocator;\n-const ArenaAllocator = std.heap.ArenaAllocator;\n-const link = @import(\"link.zig\");\n-const isCovering = @import(\"cell.zig\").isCovering;\n-const fgMode = @import(\"cell.zig\").fgMode;\n+const builtin = @import(\"builtin\");\n+const glfw = @import(\"glfw\");\n+const gl = @import(\"opengl\");\n const shadertoy = @import(\"shadertoy.zig\");\n const apprt = @import(\"../apprt.zig\");\n-const configpkg = @import(\"../config.zig\");\n const font = @import(\"../font/main.zig\");\n-const imgui = @import(\"imgui\");\n-const renderer = @import(\"../renderer.zig\");\n-const terminal = @import(\"../terminal/main.zig\");\n-const Terminal = terminal.Terminal;\n-const gl = @import(\"opengl\");\n-const math = @import(\"../math.zig\");\n-const Surface = @import(\"../Surface.zig\");\n-\n-const CellProgram = @import(\"opengl/CellProgram.zig\");\n-const ImageProgram = @import(\"opengl/ImageProgram.zig\");\n-const gl_image = @import(\"opengl/image.zig\");\n-const custom = @import(\"opengl/custom.zig\");\n-const Image = gl_image.Image;\n-const ImageMap = gl_image.ImageMap;\n-const ImagePlacementList = std.ArrayListUnmanaged(gl_image.Placement);\n-\n-const log = std.log.scoped(.grid);\n-\n-/// The runtime can request a single-threaded draw by setting this boolean\n-/// to true. In this case, the renderer.draw() call is expected to be called\n-/// from the runtime.\n-pub const single_threaded_draw = if (@hasDecl(apprt.Surface, \"opengl_single_threaded_draw\"))\n-    apprt.Surface.opengl_single_threaded_draw\n-else\n-    false;\n-const DrawMutex = if (single_threaded_draw) std.Thread.Mutex else void;\n-const drawMutexZero: DrawMutex = if (DrawMutex == void) void{} else .{};\n-\n-alloc: std.mem.Allocator,\n-\n-/// The configuration we need derived from the main config.\n-config: DerivedConfig,\n-\n-/// Current font metrics defining our grid.\n-grid_metrics: font.Metrics,\n-\n-/// The size of everything.\n-size: renderer.Size,\n-\n-/// The current set of cells to render. Each set of cells goes into\n-/// a separate shader call.\n-cells_bg: std.ArrayListUnmanaged(CellProgram.Cell),\n-cells: std.ArrayListUnmanaged(CellProgram.Cell),\n-\n-/// The last viewport that we based our rebuild off of. If this changes,\n-/// then we do a full rebuild of the cells. The pointer values in this pin\n-/// are NOT SAFE to read because they may be modified, freed, etc from the\n-/// termio thread. We treat the pointers as integers for comparison only.\n-cells_viewport: ?terminal.Pin = null,\n-\n-/// The size of the cells list that was sent to the GPU. This is used\n-/// to detect when the cells array was reallocated/resized and handle that\n-/// accordingly.\n-gl_cells_size: usize = 0,\n-\n-/// The last length of the cells that was written to the GPU. This is used to\n-/// determine what data needs to be rewritten on the GPU.\n-gl_cells_written: usize = 0,\n-\n-/// Shader program for cell rendering.\n-gl_state: ?GLState = null,\n-\n-/// The font structures.\n-font_grid: *font.SharedGrid,\n-font_shaper: font.Shaper,\n-font_shaper_cache: font.ShaperCache,\n-texture_grayscale_modified: usize = 0,\n-texture_grayscale_resized: usize = 0,\n-texture_color_modified: usize = 0,\n-texture_color_resized: usize = 0,\n-\n-/// True if the window is focused\n-focused: bool,\n-\n-/// The foreground color set by an OSC 10 sequence. If unset then the default\n-/// value from the config file is used.\n-foreground_color: ?terminal.color.RGB,\n-\n-/// Foreground color set in the user's config file.\n-default_foreground_color: terminal.color.RGB,\n-\n-/// The background color set by an OSC 11 sequence. If unset then the default\n-/// value from the config file is used.\n-background_color: ?terminal.color.RGB,\n-\n-/// Background color set in the user's config file.\n-default_background_color: terminal.color.RGB,\n-\n-/// The cursor color set by an OSC 12 sequence. If unset then\n-/// default_cursor_color is used.\n-cursor_color: ?terminal.color.RGB,\n-\n-/// Default cursor color when no color is set explicitly by an OSC 12 command.\n-/// This is cursor color as set in the user's config, if any. If no cursor color\n-/// is set in the user's config, then the cursor color is determined by the\n-/// current foreground color.\n-default_cursor_color: ?terminal.color.RGB,\n-\n-/// When `cursor_color` is null, swap the foreground and background colors of\n-/// the cell under the cursor for the cursor color. Otherwise, use the default\n-/// foreground color as the cursor color.\n-cursor_invert: bool,\n-\n-/// The mailbox for communicating with the window.\n-surface_mailbox: apprt.surface.Mailbox,\n-\n-/// Deferred operations. This is used to apply changes to the OpenGL context.\n-/// Some runtimes (GTK) do not support multi-threading so to keep our logic\n-/// simple we apply all OpenGL context changes in the render() call.\n-deferred_screen_size: ?SetScreenSize = null,\n-deferred_font_size: ?SetFontSize = null,\n-deferred_config: ?SetConfig = null,\n-\n-/// If we're drawing with single threaded operations\n-draw_mutex: DrawMutex = drawMutexZero,\n-\n-/// Current background to draw. This may not match self.background if the\n-/// terminal is in reversed mode.\n-draw_background: terminal.color.RGB,\n-\n-/// Whether we're doing padding extension for vertical sides.\n-padding_extend_top: bool = true,\n-padding_extend_bottom: bool = true,\n-\n-/// The images that we may render.\n-images: ImageMap = .{},\n-image_placements: ImagePlacementList = .{},\n-image_bg_end: u32 = 0,\n-image_text_end: u32 = 0,\n-image_virtual: bool = false,\n-\n-/// Deferred OpenGL operation to update the screen size.\n-const SetScreenSize = struct {\n-    size: renderer.Size,\n-\n-    fn apply(self: SetScreenSize, r: *OpenGL) !void {\n-        const gl_state: *GLState = if (r.gl_state) |*v|\n-            v\n-        else\n-            return error.OpenGLUninitialized;\n-\n-        // Apply our padding\n-        const grid_size = self.size.grid();\n-        const terminal_size = self.size.terminal();\n-\n-        // Blank space around the grid.\n-        const blank: renderer.Padding = switch (r.config.padding_color) {\n-            // We can use zero padding because the background color is our\n-            // clear color.\n-            .background => .{},\n-\n-            .extend, .@\"extend-always\" => self.size.screen.blankPadding(\n-                self.size.padding,\n-                grid_size,\n-                self.size.cell,\n-            ).add(self.size.padding),\n-        };\n-\n-        // Update our viewport for this context to be the entire window.\n-        // OpenGL works in pixels, so we have to use the pixel size.\n-        try gl.viewport(\n-            0,\n-            0,\n-            @intCast(self.size.screen.width),\n-            @intCast(self.size.screen.height),\n-        );\n-\n-        // Update the projection uniform within our shader\n-        inline for (.{ \"cell_program\", \"image_program\" }) |name| {\n-            const program = @field(gl_state, name);\n-            const bind = try program.program.use();\n-            defer bind.unbind();\n-            try program.program.setUniform(\n-                \"projection\",\n-\n-                // 2D orthographic projection with the full w/h\n-                math.ortho2d(\n-                    -1 * @as(f32, @floatFromInt(self.size.padding.left)),\n-                    @floatFromInt(terminal_size.width + self.size.padding.right),\n-                    @floatFromInt(terminal_size.height + self.size.padding.bottom),\n-                    -1 * @as(f32, @floatFromInt(self.size.padding.top)),\n-                ),\n-            );\n-        }\n-\n-        // Setup our grid padding\n-        {\n-            const program = gl_state.cell_program;\n-            const bind = try program.program.use();\n-            defer bind.unbind();\n-            try program.program.setUniform(\n-                \"grid_padding\",\n-                @Vector(4, f32){\n-                    @floatFromInt(blank.top),\n-                    @floatFromInt(blank.right),\n-                    @floatFromInt(blank.bottom),\n-                    @floatFromInt(blank.left),\n-                },\n-            );\n-            try program.program.setUniform(\n-                \"grid_size\",\n-                @Vector(2, f32){\n-                    @floatFromInt(grid_size.columns),\n-                    @floatFromInt(grid_size.rows),\n-                },\n-            );\n-        }\n-\n-        // Update our custom shader resolution\n-        if (gl_state.custom) |*custom_state| {\n-            try custom_state.setScreenSize(self.size);\n-        }\n-    }\n-};\n-\n-const SetFontSize = struct {\n-    metrics: font.Metrics,\n-\n-    fn apply(self: SetFontSize, r: *const OpenGL) !void {\n-        const gl_state = r.gl_state orelse return error.OpenGLUninitialized;\n-\n-        inline for (.{ \"cell_program\", \"image_program\" }) |name| {\n-            const program = @field(gl_state, name);\n-            const bind = try program.program.use();\n-            defer bind.unbind();\n-            try program.program.setUniform(\n-                \"cell_size\",\n-                @Vector(2, f32){\n-                    @floatFromInt(self.metrics.cell_width),\n-                    @floatFromInt(self.metrics.cell_height),\n-                },\n-            );\n-        }\n-    }\n-};\n-\n-const SetConfig = struct {\n-    fn apply(self: SetConfig, r: *const OpenGL) !void {\n-        _ = self;\n-        const gl_state = r.gl_state orelse return error.OpenGLUninitialized;\n-\n-        const bind = try gl_state.cell_program.program.use();\n-        defer bind.unbind();\n-        try gl_state.cell_program.program.setUniform(\n-            \"min_contrast\",\n-            r.config.min_contrast,\n-        );\n-    }\n-};\n-\n-/// The configuration for this renderer that is derived from the main\n-/// configuration. This must be exported so that we don't need to\n-/// pass around Config pointers which makes memory management a pain.\n-pub const DerivedConfig = struct {\n-    arena: ArenaAllocator,\n-\n-    font_thicken: bool,\n-    font_thicken_strength: u8,\n-    font_features: std.ArrayListUnmanaged([:0]const u8),\n-    font_styles: font.CodepointResolver.StyleStatus,\n-    cursor_color: ?terminal.color.RGB,\n-    cursor_invert: bool,\n-    cursor_text: ?terminal.color.RGB,\n-    cursor_opacity: f64,\n-    background: terminal.color.RGB,\n-    background_opacity: f64,\n-    foreground: terminal.color.RGB,\n-    selection_background: ?terminal.color.RGB,\n-    selection_foreground: ?terminal.color.RGB,\n-    invert_selection_fg_bg: bool,\n-    bold_is_bright: bool,\n-    min_contrast: f32,\n-    padding_color: configpkg.WindowPaddingColor,\n-    custom_shaders: configpkg.RepeatablePath,\n-    links: link.Set,\n-\n-    pub fn init(\n-        alloc_gpa: Allocator,\n-        config: *const configpkg.Config,\n-    ) !DerivedConfig {\n-        var arena = ArenaAllocator.init(alloc_gpa);\n-        errdefer arena.deinit();\n-        const alloc = arena.allocator();\n-\n-        // Copy our shaders\n-        const custom_shaders = try config.@\"custom-shader\".clone(alloc);\n-\n-        // Copy our font features\n-        const font_features = try config.@\"font-feature\".clone(alloc);\n-\n-        // Get our font styles\n-        var font_styles = font.CodepointResolver.StyleStatus.initFill(true);\n-        font_styles.set(.bold, config.@\"font-style-bold\" != .false);\n-        font_styles.set(.italic, config.@\"font-style-italic\" != .false);\n-        font_styles.set(.bold_italic, config.@\"font-style-bold-italic\" != .false);\n-\n-        // Our link configs\n-        const links = try link.Set.fromConfig(\n-            alloc,\n-            config.link.links.items,\n-        );\n-\n-        const cursor_invert = config.@\"cursor-invert-fg-bg\";\n-\n-        return .{\n-            .background_opacity = @max(0, @min(1, config.@\"background-opacity\")),\n-            .font_thicken = config.@\"font-thicken\",\n-            .font_thicken_strength = config.@\"font-thicken-strength\",\n-            .font_features = font_features.list,\n-            .font_styles = font_styles,\n-\n-            .cursor_color = if (!cursor_invert and config.@\"cursor-color\" != null)\n-                config.@\"cursor-color\".?.toTerminalRGB()\n-            else\n-                null,\n-\n-            .cursor_invert = cursor_invert,\n-\n-            .cursor_text = if (config.@\"cursor-text\") |txt|\n-                txt.toTerminalRGB()\n-            else\n-                null,\n-\n-            .cursor_opacity = @max(0, @min(1, config.@\"cursor-opacity\")),\n+const configpkg = @import(\"../config.zig\");\n+const rendererpkg = @import(\"../renderer.zig\");\n+const Renderer = rendererpkg.GenericRenderer(OpenGL);\n \n-            .background = config.background.toTerminalRGB(),\n-            .foreground = config.foreground.toTerminalRGB(),\n-            .invert_selection_fg_bg = config.@\"selection-invert-fg-bg\",\n-            .bold_is_bright = config.@\"bold-is-bright\",\n-            .min_contrast = @floatCast(config.@\"minimum-contrast\"),\n-            .padding_color = config.@\"window-padding-color\",\n+pub const GraphicsAPI = OpenGL;\n+pub const Target = @import(\"opengl/Target.zig\");\n+pub const Frame = @import(\"opengl/Frame.zig\");\n+pub const RenderPass = @import(\"opengl/RenderPass.zig\");\n+pub const Pipeline = @import(\"opengl/Pipeline.zig\");\n+const bufferpkg = @import(\"opengl/buffer.zig\");\n+pub const Buffer = bufferpkg.Buffer;\n+pub const Texture = @import(\"opengl/Texture.zig\");\n+pub const shaders = @import(\"opengl/shaders.zig\");\n \n-            .selection_background = if (config.@\"selection-background\") |bg|\n-                bg.toTerminalRGB()\n-            else\n-                null,\n+pub const cellpkg = @import(\"opengl/cell.zig\");\n+pub const imagepkg = @import(\"opengl/image.zig\");\n \n-            .selection_foreground = if (config.@\"selection-foreground\") |bg|\n-                bg.toTerminalRGB()\n-            else\n-                null,\n+pub const custom_shader_target: shadertoy.Target = .glsl;\n \n-            .custom_shaders = custom_shaders,\n-            .links = links,\n+/// Because OpenGL's frame completion is always\n+/// sync, we have no need for multi-buffering.\n+pub const swap_chain_count = 1;\n \n-            .arena = arena,\n-        };\n-    }\n+const log = std.log.scoped(.opengl);\n \n-    pub fn deinit(self: *DerivedConfig) void {\n-        const alloc = self.arena.allocator();\n-        self.links.deinit(alloc);\n-        self.arena.deinit();\n-    }\n-};\n+/// We require at least OpenGL 4.3\n+pub const MIN_VERSION_MAJOR = 4;\n+pub const MIN_VERSION_MINOR = 3;\n \n-pub fn init(alloc: Allocator, options: renderer.Options) !OpenGL {\n-    // Create the initial font shaper\n-    var shaper = try font.Shaper.init(alloc, .{\n-        .features = options.config.font_features.items,\n-    });\n-    errdefer shaper.deinit();\n+alloc: std.mem.Allocator,\n \n-    // For the remainder of the setup we lock our font grid data because\n-    // we're reading it.\n-    const grid = options.font_grid;\n-    grid.lock.lockShared();\n-    defer grid.lock.unlockShared();\n+/// Alpha blending mode\n+blending: configpkg.Config.AlphaBlending,\n \n-    var gl_state = try GLState.init(alloc, options.config, grid);\n-    errdefer gl_state.deinit();\n+/// The most recently presented target, in case we need to present it again.\n+last_target: ?Target = null,\n \n-    return OpenGL{\n+pub fn init(alloc: Allocator, opts: rendererpkg.Options) !OpenGL {",
        "comment_created_at": "2025-06-20T16:30:52+00:00",
        "comment_author": "mitchellh",
        "comment_body": "I think this can trivially have a defined error set too. No need to dive all the way into `pkg/opengl`, can just set it here.",
        "pr_file_module": null
      }
    ]
  }
]