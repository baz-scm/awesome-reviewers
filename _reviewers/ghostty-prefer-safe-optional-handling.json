[
  {
    "discussion_id": "2160011929",
    "pr_number": 7634,
    "pr_file": "macos/Sources/Features/App Intents/Entities/TerminalEntity.swift",
    "created_at": "2025-06-21T11:30:21+00:00",
    "commented_code": "+import AppKit\n+import AppIntents\n+import SwiftUI\n+\n+struct TerminalEntity: AppEntity {\n+    let id: UUID\n+\n+    @Property(title: \"Title\")\n+    var title: String\n+\n+    @Property(title: \"Working Directory\")\n+    var workingDirectory: String?\n+\n+    @Property(title: \"Kind\")\n+    var kind: Kind\n+\n+    @MainActor\n+    @DeferredProperty(title: \"Full Contents\")\n+    @available(macOS 26.0, *)\n+    var screenContents: String? {\n+        get async {\n+            guard let surfaceView else { return nil }\n+            return surfaceView.cachedScreenContents.get()\n+        }\n+    }\n+\n+    @MainActor\n+    @DeferredProperty(title: \"Visible Contents\")\n+    @available(macOS 26.0, *)\n+    var visibleContents: String? {\n+        get async {\n+            guard let surfaceView else { return nil }\n+            return surfaceView.cachedVisibleContents.get()\n+        }\n+    }\n+\n+    var screenshot: Image?\n+\n+    static var typeDisplayRepresentation: TypeDisplayRepresentation {\n+        TypeDisplayRepresentation(name: \"Terminal\")\n+    }\n+\n+    @MainActor\n+    var displayRepresentation: DisplayRepresentation {\n+        var rep = DisplayRepresentation(title: \"\\(title)\")\n+        if let screenshot,\n+           let nsImage = ImageRenderer(content: screenshot).nsImage,\n+           let data = nsImage.tiffRepresentation {\n+            rep.image = .init(data: data)\n+        }\n+\n+        return rep\n+    }\n+\n+    /// Returns the view associated with this entity. This may no longer exist.\n+    @MainActor\n+    var surfaceView: Ghostty.SurfaceView? {\n+        Self.defaultQuery.all.first { $0.uuid == self.id }\n+    }\n+\n+    @MainActor\n+    var surfaceModel: Ghostty.Surface? {\n+        surfaceView?.surfaceModel\n+    }\n+\n+    static var defaultQuery = TerminalQuery()\n+\n+    init(_ view: Ghostty.SurfaceView) {\n+        self.id = view.uuid\n+        self.title = view.title\n+        self.workingDirectory = view.pwd\n+        self.screenshot = view.screenshot()\n+        \n+        // Determine the kind based on the window controller type\n+        if view.window?.windowController is QuickTerminalController {\n+            self.kind = .quick\n+        } else {\n+            self.kind = .normal\n+        }\n+    }\n+}\n+\n+extension TerminalEntity {\n+    enum Kind: String, AppEnum {\n+        case normal\n+        case quick\n+        \n+        static var typeDisplayRepresentation = TypeDisplayRepresentation(name: \"Terminal Kind\")\n+        \n+        static var caseDisplayRepresentations: [Self: DisplayRepresentation] = [\n+            .normal: .init(title: \"Normal\"),\n+            .quick: .init(title: \"Quick\")\n+        ]\n+    }\n+}\n+\n+struct TerminalQuery: EntityStringQuery, EnumerableEntityQuery {\n+    @MainActor\n+    func entities(for identifiers: [TerminalEntity.ID]) async throws -> [TerminalEntity] {\n+        return all.filter {\n+            identifiers.contains($0.uuid)\n+        }.map {\n+            TerminalEntity($0)\n+        }\n+    }\n+\n+    @MainActor\n+    func entities(matching string: String) async throws -> [TerminalEntity] {\n+        return all.filter {\n+            $0.title.localizedCaseInsensitiveContains(string)\n+        }.map {\n+            TerminalEntity($0)\n+        }\n+    }\n+\n+    @MainActor\n+    func allEntities() async throws -> [TerminalEntity] {\n+        return all.map { TerminalEntity($0) }\n+    }\n+\n+    @MainActor\n+    func suggestedEntities() async throws -> [TerminalEntity] {\n+        return try await allEntities()\n+    }\n+\n+    @MainActor\n+    var all: [Ghostty.SurfaceView] {\n+        // Find all of our terminal windows. This will include the quick terminal\n+        // but only if it was previously opened.\n+        let controllers = NSApp.windows.compactMap {\n+            $0.windowController as? BaseTerminalController\n+        }\n+\n+        // Get all our surfaces\n+        return controllers.reduce([]) { result, c in\n+            result + (c.surfaceTree.root?.leaves() ?? [])\n+        }",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2160011929",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7634,
        "pr_file": "macos/Sources/Features/App Intents/Entities/TerminalEntity.swift",
        "discussion_id": "2160011929",
        "commented_code": "@@ -0,0 +1,139 @@\n+import AppKit\n+import AppIntents\n+import SwiftUI\n+\n+struct TerminalEntity: AppEntity {\n+    let id: UUID\n+\n+    @Property(title: \"Title\")\n+    var title: String\n+\n+    @Property(title: \"Working Directory\")\n+    var workingDirectory: String?\n+\n+    @Property(title: \"Kind\")\n+    var kind: Kind\n+\n+    @MainActor\n+    @DeferredProperty(title: \"Full Contents\")\n+    @available(macOS 26.0, *)\n+    var screenContents: String? {\n+        get async {\n+            guard let surfaceView else { return nil }\n+            return surfaceView.cachedScreenContents.get()\n+        }\n+    }\n+\n+    @MainActor\n+    @DeferredProperty(title: \"Visible Contents\")\n+    @available(macOS 26.0, *)\n+    var visibleContents: String? {\n+        get async {\n+            guard let surfaceView else { return nil }\n+            return surfaceView.cachedVisibleContents.get()\n+        }\n+    }\n+\n+    var screenshot: Image?\n+\n+    static var typeDisplayRepresentation: TypeDisplayRepresentation {\n+        TypeDisplayRepresentation(name: \"Terminal\")\n+    }\n+\n+    @MainActor\n+    var displayRepresentation: DisplayRepresentation {\n+        var rep = DisplayRepresentation(title: \"\\(title)\")\n+        if let screenshot,\n+           let nsImage = ImageRenderer(content: screenshot).nsImage,\n+           let data = nsImage.tiffRepresentation {\n+            rep.image = .init(data: data)\n+        }\n+\n+        return rep\n+    }\n+\n+    /// Returns the view associated with this entity. This may no longer exist.\n+    @MainActor\n+    var surfaceView: Ghostty.SurfaceView? {\n+        Self.defaultQuery.all.first { $0.uuid == self.id }\n+    }\n+\n+    @MainActor\n+    var surfaceModel: Ghostty.Surface? {\n+        surfaceView?.surfaceModel\n+    }\n+\n+    static var defaultQuery = TerminalQuery()\n+\n+    init(_ view: Ghostty.SurfaceView) {\n+        self.id = view.uuid\n+        self.title = view.title\n+        self.workingDirectory = view.pwd\n+        self.screenshot = view.screenshot()\n+        \n+        // Determine the kind based on the window controller type\n+        if view.window?.windowController is QuickTerminalController {\n+            self.kind = .quick\n+        } else {\n+            self.kind = .normal\n+        }\n+    }\n+}\n+\n+extension TerminalEntity {\n+    enum Kind: String, AppEnum {\n+        case normal\n+        case quick\n+        \n+        static var typeDisplayRepresentation = TypeDisplayRepresentation(name: \"Terminal Kind\")\n+        \n+        static var caseDisplayRepresentations: [Self: DisplayRepresentation] = [\n+            .normal: .init(title: \"Normal\"),\n+            .quick: .init(title: \"Quick\")\n+        ]\n+    }\n+}\n+\n+struct TerminalQuery: EntityStringQuery, EnumerableEntityQuery {\n+    @MainActor\n+    func entities(for identifiers: [TerminalEntity.ID]) async throws -> [TerminalEntity] {\n+        return all.filter {\n+            identifiers.contains($0.uuid)\n+        }.map {\n+            TerminalEntity($0)\n+        }\n+    }\n+\n+    @MainActor\n+    func entities(matching string: String) async throws -> [TerminalEntity] {\n+        return all.filter {\n+            $0.title.localizedCaseInsensitiveContains(string)\n+        }.map {\n+            TerminalEntity($0)\n+        }\n+    }\n+\n+    @MainActor\n+    func allEntities() async throws -> [TerminalEntity] {\n+        return all.map { TerminalEntity($0) }\n+    }\n+\n+    @MainActor\n+    func suggestedEntities() async throws -> [TerminalEntity] {\n+        return try await allEntities()\n+    }\n+\n+    @MainActor\n+    var all: [Ghostty.SurfaceView] {\n+        // Find all of our terminal windows. This will include the quick terminal\n+        // but only if it was previously opened.\n+        let controllers = NSApp.windows.compactMap {\n+            $0.windowController as? BaseTerminalController\n+        }\n+\n+        // Get all our surfaces\n+        return controllers.reduce([]) { result, c in\n+            result + (c.surfaceTree.root?.leaves() ?? [])\n+        }",
        "comment_created_at": "2025-06-21T11:30:21+00:00",
        "comment_author": "jparise",
        "comment_body": "```suggestion\r\n        return controllers.flatMap { \r\n            $0.surfaceTree.root?.leaves() ?? []\r\n        }\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2062636143",
    "pr_number": 7191,
    "pr_file": "macos/Sources/Features/Terminal/BaseTerminalController.swift",
    "created_at": "2025-04-27T13:56:43+00:00",
    "commented_code": "window.performClose(sender)\n     }\n \n+    @IBAction func toggleMaximize(_ sender: Any) {\n+        guard let window = window else { return }",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2062636143",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7191,
        "pr_file": "macos/Sources/Features/Terminal/BaseTerminalController.swift",
        "discussion_id": "2062636143",
        "commented_code": "@@ -548,6 +553,11 @@ class BaseTerminalController: NSWindowController,\n         window.performClose(sender)\n     }\n \n+    @IBAction func toggleMaximize(_ sender: Any) {\n+        guard let window = window else { return }",
        "comment_created_at": "2025-04-27T13:56:43+00:00",
        "comment_author": "mitchellh",
        "comment_body": "There needs to be a guard here that the object is within the `surfaceTree` otherwise toggle maximize will maximize all open terminal windows. \ud83d\ude04 \r\n\r\nThere should be at least one other action that has this check, search for `contains`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2041179683",
    "pr_number": 7075,
    "pr_file": "macos/Sources/Features/QuickTerminal/QuickTerminalController.swift",
    "created_at": "2025-04-13T18:17:06+00:00",
    "commented_code": "@objc private func onToggleFullscreen(notification: SwiftUI.Notification) {\n         guard let target = notification.object as? Ghostty.SurfaceView else { return }\n         guard target == self.focusedSurface else { return }\n+        guard let window = self.window else { return }\n+        guard let screen = window.screen ?? NSScreen.main else { return }\n \n-        // We ignore the requested mode and always use non-native for the quick terminal\n-        toggleFullscreen(mode: .nonNative)\n+        if savedWindowFrame != nil {\n+            let originalFrame = savedWindowFrame!",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2041179683",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 7075,
        "pr_file": "macos/Sources/Features/QuickTerminal/QuickTerminalController.swift",
        "discussion_id": "2041179683",
        "commented_code": "@@ -485,9 +488,17 @@ class QuickTerminalController: BaseTerminalController {\n     @objc private func onToggleFullscreen(notification: SwiftUI.Notification) {\n         guard let target = notification.object as? Ghostty.SurfaceView else { return }\n         guard target == self.focusedSurface else { return }\n+        guard let window = self.window else { return }\n+        guard let screen = window.screen ?? NSScreen.main else { return }\n \n-        // We ignore the requested mode and always use non-native for the quick terminal\n-        toggleFullscreen(mode: .nonNative)\n+        if savedWindowFrame != nil {\n+            let originalFrame = savedWindowFrame!",
        "comment_created_at": "2025-04-13T18:17:06+00:00",
        "comment_author": "jparise",
        "comment_body": "`if let savedWindowFrame` will let you drop the force unwrap on the next line. ",
        "pr_file_module": null
      }
    ]
  }
]