[
  {
    "discussion_id": "2091366257",
    "pr_number": 4226,
    "pr_file": "src/renderer/OpenGL.zig",
    "created_at": "2025-05-15T14:46:04+00:00",
    "commented_code": "gop.value_ptr.transmit_time = image.transmit_time;\n }\n \n+/// Prepares the current background image for upload\n+pub fn prepBackgroundImage(self: *OpenGL) !void {\n+    // If the user doesn't have a background image, do nothing...\n+    const path = self.background_image.value orelse return;\n+\n+    // Read the file content\n+    const file_content = try self.readImageContent(path);\n+    defer self.alloc.free(file_content);\n+\n+    // Decode the png (currently, we only support png)\n+    const decoded_image: wuffs.ImageData = blk: {\n+        // Extract the file extension\n+        const ext = std.fs.path.extension(path);\n+        const ext_lower = try std.ascii.allocLowerString(self.alloc, ext);\n+        defer self.alloc.free(ext_lower);\n+\n+        // Match based on extension\n+        if (std.mem.eql(u8, ext_lower, \".png\")) {",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2091366257",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4226,
        "pr_file": "src/renderer/OpenGL.zig",
        "discussion_id": "2091366257",
        "commented_code": "@@ -1201,6 +1246,82 @@ fn prepKittyImage(\n     gop.value_ptr.transmit_time = image.transmit_time;\n }\n \n+/// Prepares the current background image for upload\n+pub fn prepBackgroundImage(self: *OpenGL) !void {\n+    // If the user doesn't have a background image, do nothing...\n+    const path = self.background_image.value orelse return;\n+\n+    // Read the file content\n+    const file_content = try self.readImageContent(path);\n+    defer self.alloc.free(file_content);\n+\n+    // Decode the png (currently, we only support png)\n+    const decoded_image: wuffs.ImageData = blk: {\n+        // Extract the file extension\n+        const ext = std.fs.path.extension(path);\n+        const ext_lower = try std.ascii.allocLowerString(self.alloc, ext);\n+        defer self.alloc.free(ext_lower);\n+\n+        // Match based on extension\n+        if (std.mem.eql(u8, ext_lower, \".png\")) {",
        "comment_created_at": "2025-05-15T14:46:04+00:00",
        "comment_author": "pluiedev",
        "comment_body": "Use `std.ascii.eqlIgnoreCase` to avoid allocation",
        "pr_file_module": null
      },
      {
        "comment_id": "2103551140",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4226,
        "pr_file": "src/renderer/OpenGL.zig",
        "discussion_id": "2091366257",
        "commented_code": "@@ -1201,6 +1246,82 @@ fn prepKittyImage(\n     gop.value_ptr.transmit_time = image.transmit_time;\n }\n \n+/// Prepares the current background image for upload\n+pub fn prepBackgroundImage(self: *OpenGL) !void {\n+    // If the user doesn't have a background image, do nothing...\n+    const path = self.background_image.value orelse return;\n+\n+    // Read the file content\n+    const file_content = try self.readImageContent(path);\n+    defer self.alloc.free(file_content);\n+\n+    // Decode the png (currently, we only support png)\n+    const decoded_image: wuffs.ImageData = blk: {\n+        // Extract the file extension\n+        const ext = std.fs.path.extension(path);\n+        const ext_lower = try std.ascii.allocLowerString(self.alloc, ext);\n+        defer self.alloc.free(ext_lower);\n+\n+        // Match based on extension\n+        if (std.mem.eql(u8, ext_lower, \".png\")) {",
        "comment_created_at": "2025-05-22T23:15:26+00:00",
        "comment_author": "yunusey",
        "comment_body": "Thanks for catching that! I don't even know what I was thinking; allocating space to lower down a string only to compare it with another string is pretty crazy \ud83d\ude05",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2119579107",
    "pr_number": 4226,
    "pr_file": "src/renderer/OpenGL.zig",
    "created_at": "2025-06-01T20:48:47+00:00",
    "commented_code": "gop.value_ptr.transmit_time = image.transmit_time;\n }\n \n+/// Prepares the current background image for upload\n+pub fn prepBackgroundImage(self: *OpenGL, path: []const u8) !void {\n+    // Read the file content\n+    const file_content = try self.readImageContent(path);\n+    defer self.alloc.free(file_content);\n+\n+    // Decode the png (currently, we only support png)\n+    const decoded_image: wuffs.ImageData = blk: {\n+        // Extract the file extension\n+        const ext = std.fs.path.extension(path);\n+\n+        // Match based on extension\n+        if (std.ascii.eqlIgnoreCase(ext, \".png\")) {\n+            break :blk try wuffs.png.decode(self.alloc, file_content);\n+        } else if (std.ascii.eqlIgnoreCase(ext, \".jpg\") or std.ascii.eqlIgnoreCase(ext, \".jpeg\")) {\n+            break :blk try wuffs.jpeg.decode(self.alloc, file_content);\n+        } else {\n+            log.warn(\"unsupported image format: {s}\", .{ext});\n+            return error.InvalidData;\n+        }\n+    };\n+    defer self.alloc.free(decoded_image.data);\n+\n+    // Copy the data into the pending state\n+    const data = try self.alloc.dupe(u8, decoded_image.data);\n+    errdefer self.alloc.free(data);",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "2119579107",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4226,
        "pr_file": "src/renderer/OpenGL.zig",
        "discussion_id": "2119579107",
        "commented_code": "@@ -1160,6 +1219,77 @@ fn prepKittyImage(\n     gop.value_ptr.transmit_time = image.transmit_time;\n }\n \n+/// Prepares the current background image for upload\n+pub fn prepBackgroundImage(self: *OpenGL, path: []const u8) !void {\n+    // Read the file content\n+    const file_content = try self.readImageContent(path);\n+    defer self.alloc.free(file_content);\n+\n+    // Decode the png (currently, we only support png)\n+    const decoded_image: wuffs.ImageData = blk: {\n+        // Extract the file extension\n+        const ext = std.fs.path.extension(path);\n+\n+        // Match based on extension\n+        if (std.ascii.eqlIgnoreCase(ext, \".png\")) {\n+            break :blk try wuffs.png.decode(self.alloc, file_content);\n+        } else if (std.ascii.eqlIgnoreCase(ext, \".jpg\") or std.ascii.eqlIgnoreCase(ext, \".jpeg\")) {\n+            break :blk try wuffs.jpeg.decode(self.alloc, file_content);\n+        } else {\n+            log.warn(\"unsupported image format: {s}\", .{ext});\n+            return error.InvalidData;\n+        }\n+    };\n+    defer self.alloc.free(decoded_image.data);\n+\n+    // Copy the data into the pending state\n+    const data = try self.alloc.dupe(u8, decoded_image.data);\n+    errdefer self.alloc.free(data);",
        "comment_created_at": "2025-06-01T20:48:47+00:00",
        "comment_author": "pluiedev",
        "comment_body": "I'm slightly confused as to why this is necessary. We own the data contained within `decoded_image` and we're using the same allocator, so why are we making a copy of it and freeing the old data?",
        "pr_file_module": null
      },
      {
        "comment_id": "2119752373",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4226,
        "pr_file": "src/renderer/OpenGL.zig",
        "discussion_id": "2119579107",
        "commented_code": "@@ -1160,6 +1219,77 @@ fn prepKittyImage(\n     gop.value_ptr.transmit_time = image.transmit_time;\n }\n \n+/// Prepares the current background image for upload\n+pub fn prepBackgroundImage(self: *OpenGL, path: []const u8) !void {\n+    // Read the file content\n+    const file_content = try self.readImageContent(path);\n+    defer self.alloc.free(file_content);\n+\n+    // Decode the png (currently, we only support png)\n+    const decoded_image: wuffs.ImageData = blk: {\n+        // Extract the file extension\n+        const ext = std.fs.path.extension(path);\n+\n+        // Match based on extension\n+        if (std.ascii.eqlIgnoreCase(ext, \".png\")) {\n+            break :blk try wuffs.png.decode(self.alloc, file_content);\n+        } else if (std.ascii.eqlIgnoreCase(ext, \".jpg\") or std.ascii.eqlIgnoreCase(ext, \".jpeg\")) {\n+            break :blk try wuffs.jpeg.decode(self.alloc, file_content);\n+        } else {\n+            log.warn(\"unsupported image format: {s}\", .{ext});\n+            return error.InvalidData;\n+        }\n+    };\n+    defer self.alloc.free(decoded_image.data);\n+\n+    // Copy the data into the pending state\n+    const data = try self.alloc.dupe(u8, decoded_image.data);\n+    errdefer self.alloc.free(data);",
        "comment_created_at": "2025-06-02T00:04:29+00:00",
        "comment_author": "yunusey",
        "comment_body": "https://github.com/ghostty-org/ghostty/pull/4226/commits/5f849b2060f0539db1da327bfb43a86c8f2cb02d removes the allocation and uses `@constCast` to pass the already owned `decoded_image.data`.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1952855628",
    "pr_number": 5309,
    "pr_file": "src/termio/Exec.zig",
    "created_at": "2025-02-12T15:13:17+00:00",
    "commented_code": "// This is not apprt-specific, so we do it here.\n         env.remove(\"VTE_VERSION\");\n \n+        // Add environment variables from the config\n+        {\n+            var it = cfg.additional_env.iterator();\n+            while (it.next()) |entry| {\n+                const key_copy = try alloc.dupe(u8, entry.key_ptr.*);\n+                errdefer alloc.free(key_copy);\n+                const value_copy = try alloc.dupe(u8, entry.value_ptr.*);\n+                errdefer alloc.free(value_copy);\n+                try env.put(key_copy, value_copy);",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "1952855628",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 5309,
        "pr_file": "src/termio/Exec.zig",
        "discussion_id": "1952855628",
        "commented_code": "@@ -844,6 +845,18 @@ const Subprocess = struct {\n         // This is not apprt-specific, so we do it here.\n         env.remove(\"VTE_VERSION\");\n \n+        // Add environment variables from the config\n+        {\n+            var it = cfg.additional_env.iterator();\n+            while (it.next()) |entry| {\n+                const key_copy = try alloc.dupe(u8, entry.key_ptr.*);\n+                errdefer alloc.free(key_copy);\n+                const value_copy = try alloc.dupe(u8, entry.value_ptr.*);\n+                errdefer alloc.free(value_copy);\n+                try env.put(key_copy, value_copy);",
        "comment_created_at": "2025-02-12T15:13:17+00:00",
        "comment_author": "rockorager",
        "comment_body": "`env.put` copies the values. You shouldn't need to dupe the value, and also prevents a memory leak from that dupe (those are never freed).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1903160293",
    "pr_number": 4584,
    "pr_file": "src/os/xdg.zig",
    "created_at": "2025-01-04T22:15:25+00:00",
    "commented_code": "try testing.expectEqualSlices([*:0]const u8, actual, &.{ \"a\", \"-e\", \"b\", \"c\" });\n     }\n }\n+\n+/// https://specifications.freedesktop.org/basedir-spec/latest/\n+pub const Dirs = enum {\n+    config,\n+    data,\n+\n+    pub fn key(self: Dirs) []const u8 {\n+        return switch (self) {\n+            .config => \"XDG_CONFIG_DIRS\",\n+            .data => \"XDG_DATA_DIRS\",\n+        };\n+    }\n+\n+    pub fn default(self: Dirs) []const u8 {\n+        return switch (self) {\n+            .config => \"/etc/xdg\",\n+            .data => \"/usr/local/share:/usr/share\",\n+        };\n+    }\n+};\n+\n+pub const config_dirs = Dirs.config;\n+pub const data_dirs = Dirs.data;\n+\n+pub const DirsIterator = struct {\n+    data: []const u8,\n+    iterator: std.mem.SplitIterator(u8, .scalar),\n+\n+    /// https://specifications.freedesktop.org/basedir-spec/latest/\n+    pub fn init(env: std.process.EnvMap, key: Dirs) DirsIterator {\n+        const data = data: {\n+            if (env.get(key.key())) |data| {\n+                if (std.mem.trim(u8, data, &std.ascii.whitespace).len > 0) break :data data;\n+            }\n+\n+            break :data key.default();\n+        };\n+\n+        return .{\n+            .data = data,\n+            .iterator = std.mem.splitScalar(u8, data, ':'),\n+        };\n+    }\n+\n+    pub fn next(self: *DirsIterator) ?[]const u8 {\n+        return self.iterator.next();\n+    }\n+};\n+\n+/// https://specifications.freedesktop.org/basedir-spec/latest/\n+pub fn dirsIterator(alloc: std.mem.Allocator, key: Dirs) std.mem.Allocator.Error!DirsIterator {\n+    const env = std.process.getEnvMap(alloc);",
    "repo_full_name": "ghostty-org/ghostty",
    "discussion_comments": [
      {
        "comment_id": "1903160293",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4584,
        "pr_file": "src/os/xdg.zig",
        "discussion_id": "1903160293",
        "commented_code": "@@ -193,3 +193,87 @@ test parseTerminalExec {\n         try testing.expectEqualSlices([*:0]const u8, actual, &.{ \"a\", \"-e\", \"b\", \"c\" });\n     }\n }\n+\n+/// https://specifications.freedesktop.org/basedir-spec/latest/\n+pub const Dirs = enum {\n+    config,\n+    data,\n+\n+    pub fn key(self: Dirs) []const u8 {\n+        return switch (self) {\n+            .config => \"XDG_CONFIG_DIRS\",\n+            .data => \"XDG_DATA_DIRS\",\n+        };\n+    }\n+\n+    pub fn default(self: Dirs) []const u8 {\n+        return switch (self) {\n+            .config => \"/etc/xdg\",\n+            .data => \"/usr/local/share:/usr/share\",\n+        };\n+    }\n+};\n+\n+pub const config_dirs = Dirs.config;\n+pub const data_dirs = Dirs.data;\n+\n+pub const DirsIterator = struct {\n+    data: []const u8,\n+    iterator: std.mem.SplitIterator(u8, .scalar),\n+\n+    /// https://specifications.freedesktop.org/basedir-spec/latest/\n+    pub fn init(env: std.process.EnvMap, key: Dirs) DirsIterator {\n+        const data = data: {\n+            if (env.get(key.key())) |data| {\n+                if (std.mem.trim(u8, data, &std.ascii.whitespace).len > 0) break :data data;\n+            }\n+\n+            break :data key.default();\n+        };\n+\n+        return .{\n+            .data = data,\n+            .iterator = std.mem.splitScalar(u8, data, ':'),\n+        };\n+    }\n+\n+    pub fn next(self: *DirsIterator) ?[]const u8 {\n+        return self.iterator.next();\n+    }\n+};\n+\n+/// https://specifications.freedesktop.org/basedir-spec/latest/\n+pub fn dirsIterator(alloc: std.mem.Allocator, key: Dirs) std.mem.Allocator.Error!DirsIterator {\n+    const env = std.process.getEnvMap(alloc);",
        "comment_created_at": "2025-01-04T22:15:25+00:00",
        "comment_author": "mitchellh",
        "comment_body": "Allocating when we don't have to on systems like posix feels bad. We shouldn't allocate on posix.",
        "pr_file_module": null
      },
      {
        "comment_id": "1903163986",
        "repo_full_name": "ghostty-org/ghostty",
        "pr_number": 4584,
        "pr_file": "src/os/xdg.zig",
        "discussion_id": "1903160293",
        "commented_code": "@@ -193,3 +193,87 @@ test parseTerminalExec {\n         try testing.expectEqualSlices([*:0]const u8, actual, &.{ \"a\", \"-e\", \"b\", \"c\" });\n     }\n }\n+\n+/// https://specifications.freedesktop.org/basedir-spec/latest/\n+pub const Dirs = enum {\n+    config,\n+    data,\n+\n+    pub fn key(self: Dirs) []const u8 {\n+        return switch (self) {\n+            .config => \"XDG_CONFIG_DIRS\",\n+            .data => \"XDG_DATA_DIRS\",\n+        };\n+    }\n+\n+    pub fn default(self: Dirs) []const u8 {\n+        return switch (self) {\n+            .config => \"/etc/xdg\",\n+            .data => \"/usr/local/share:/usr/share\",\n+        };\n+    }\n+};\n+\n+pub const config_dirs = Dirs.config;\n+pub const data_dirs = Dirs.data;\n+\n+pub const DirsIterator = struct {\n+    data: []const u8,\n+    iterator: std.mem.SplitIterator(u8, .scalar),\n+\n+    /// https://specifications.freedesktop.org/basedir-spec/latest/\n+    pub fn init(env: std.process.EnvMap, key: Dirs) DirsIterator {\n+        const data = data: {\n+            if (env.get(key.key())) |data| {\n+                if (std.mem.trim(u8, data, &std.ascii.whitespace).len > 0) break :data data;\n+            }\n+\n+            break :data key.default();\n+        };\n+\n+        return .{\n+            .data = data,\n+            .iterator = std.mem.splitScalar(u8, data, ':'),\n+        };\n+    }\n+\n+    pub fn next(self: *DirsIterator) ?[]const u8 {\n+        return self.iterator.next();\n+    }\n+};\n+\n+/// https://specifications.freedesktop.org/basedir-spec/latest/\n+pub fn dirsIterator(alloc: std.mem.Allocator, key: Dirs) std.mem.Allocator.Error!DirsIterator {\n+    const env = std.process.getEnvMap(alloc);",
        "comment_created_at": "2025-01-04T22:53:12+00:00",
        "comment_author": "jcollie",
        "comment_body": "Allocations removed.",
        "pr_file_module": null
      }
    ]
  }
]