[
  {
    "discussion_id": "802182172",
    "pr_number": 3054,
    "pr_file": "gin.go",
    "created_at": "2022-02-09T00:53:55+00:00",
    "commented_code": "engine.SetHTMLTemplate(templ)\n }\n \n+\n+// LoadHTMLFromFS loads HTML files identified by glob pattern\n+// from a filesytem interface and associates the result with HTML renderer.",
    "repo_full_name": "gin-gonic/gin",
    "discussion_comments": [
      {
        "comment_id": "802182172",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 3054,
        "pr_file": "gin.go",
        "discussion_id": "802182172",
        "commented_code": "@@ -267,6 +268,23 @@ func (engine *Engine) LoadHTMLFiles(files ...string) {\n \tengine.SetHTMLTemplate(templ)\n }\n \n+\n+// LoadHTMLFromFS loads HTML files identified by glob pattern\n+// from a filesytem interface and associates the result with HTML renderer.",
        "comment_created_at": "2022-02-09T00:53:55+00:00",
        "comment_author": "dhermes",
        "comment_body": "I can add to the `godoc` a mention of `go:embed` if desired.\r\n\r\nThe expected usage is to refer to a `go:embed` filesystem, e.g.\r\n\r\n```go\r\n// embeddedTemplates holds our static web server content.\r\n//go:embed templates/*\r\nvar embeddedTemplates embed.FS\r\n\r\n// ...\r\n\r\nengine.LoadHTMLFromFS(embeddedTemplates, \"templates/*.tmpl\")\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "929352952",
    "pr_number": 1957,
    "pr_file": "binding/header.go",
    "created_at": "2022-07-25T22:20:37+00:00",
    "commented_code": "+package binding\n+\n+import (\n+\t\"net/http\"\n+\t\"net/textproto\"\n+\t\"reflect\"\n+)\n+\n+type headerBinding struct{}\n+\n+func (headerBinding) Name() string {\n+\treturn \"header\"\n+}\n+\n+func (headerBinding) Bind(req *http.Request, obj interface{}) error {\n+\n+\tif err := mapHeader(obj, req.Header); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn validate(obj)\n+}\n+\n+func mapHeader(ptr interface{}, h map[string][]string) error {\n+\treturn mappingByPtr(ptr, headerSource(h), \"header\")\n+}\n+\n+type headerSource map[string][]string\n+\n+var _ setter = headerSource(nil)\n+\n+func (hs headerSource) TrySet(value reflect.Value, field reflect.StructField, tagValue string, opt setOptions) (isSetted bool, err error) {\n+\treturn setByForm(value, field, hs, textproto.CanonicalMIMEHeaderKey(tagValue), opt)",
    "repo_full_name": "gin-gonic/gin",
    "discussion_comments": [
      {
        "comment_id": "929352952",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 1957,
        "pr_file": "binding/header.go",
        "discussion_id": "929352952",
        "commented_code": "@@ -0,0 +1,34 @@\n+package binding\n+\n+import (\n+\t\"net/http\"\n+\t\"net/textproto\"\n+\t\"reflect\"\n+)\n+\n+type headerBinding struct{}\n+\n+func (headerBinding) Name() string {\n+\treturn \"header\"\n+}\n+\n+func (headerBinding) Bind(req *http.Request, obj interface{}) error {\n+\n+\tif err := mapHeader(obj, req.Header); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn validate(obj)\n+}\n+\n+func mapHeader(ptr interface{}, h map[string][]string) error {\n+\treturn mappingByPtr(ptr, headerSource(h), \"header\")\n+}\n+\n+type headerSource map[string][]string\n+\n+var _ setter = headerSource(nil)\n+\n+func (hs headerSource) TrySet(value reflect.Value, field reflect.StructField, tagValue string, opt setOptions) (isSetted bool, err error) {\n+\treturn setByForm(value, field, hs, textproto.CanonicalMIMEHeaderKey(tagValue), opt)",
        "comment_created_at": "2022-07-25T22:20:37+00:00",
        "comment_author": "NeverBehave",
        "comment_body": "the tag value of `CanonicalMIMEHeaderKey` is used instead of the actual tag value. This should be mentioned in the docs.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "270607421",
    "pr_number": 1829,
    "pr_file": "binding/form.go",
    "created_at": "2019-03-30T01:15:15+00:00",
    "commented_code": "if err := req.ParseMultipartForm(defaultMemory); err != nil {\n \t\treturn err\n \t}\n-\tif err := mapForm(obj, req.MultipartForm.Value); err != nil {\n+\tif err := mappingByPtr(obj, (*multipartRequest)(req), \"form\"); err != nil {\n \t\treturn err\n \t}\n \n-\tif err := mapFiles(obj, req); err != nil {\n-\t\treturn err\n+\treturn validate(obj)\n+}\n+\n+type multipartRequest http.Request\n+\n+var (\n+\tmultipartFileHeaderStructType = reflect.TypeOf(multipart.FileHeader{})\n+)\n+\n+func (r *multipartRequest) Set(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error) {",
    "repo_full_name": "gin-gonic/gin",
    "discussion_comments": [
      {
        "comment_id": "270607421",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 1829,
        "pr_file": "binding/form.go",
        "discussion_id": "270607421",
        "commented_code": "@@ -53,13 +57,30 @@ func (formMultipartBinding) Bind(req *http.Request, obj interface{}) error {\n \tif err := req.ParseMultipartForm(defaultMemory); err != nil {\n \t\treturn err\n \t}\n-\tif err := mapForm(obj, req.MultipartForm.Value); err != nil {\n+\tif err := mappingByPtr(obj, (*multipartRequest)(req), \"form\"); err != nil {\n \t\treturn err\n \t}\n \n-\tif err := mapFiles(obj, req); err != nil {\n-\t\treturn err\n+\treturn validate(obj)\n+}\n+\n+type multipartRequest http.Request\n+\n+var (\n+\tmultipartFileHeaderStructType = reflect.TypeOf(multipart.FileHeader{})\n+)\n+\n+func (r *multipartRequest) Set(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error) {",
        "comment_created_at": "2019-03-30T01:15:15+00:00",
        "comment_author": "thinkerou",
        "comment_body": "check: `var _ setter = &multipartRequest`\r\nand add node for export method/class/interface.",
        "pr_file_module": null
      },
      {
        "comment_id": "270626442",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 1829,
        "pr_file": "binding/form.go",
        "discussion_id": "270607421",
        "commented_code": "@@ -53,13 +57,30 @@ func (formMultipartBinding) Bind(req *http.Request, obj interface{}) error {\n \tif err := req.ParseMultipartForm(defaultMemory); err != nil {\n \t\treturn err\n \t}\n-\tif err := mapForm(obj, req.MultipartForm.Value); err != nil {\n+\tif err := mappingByPtr(obj, (*multipartRequest)(req), \"form\"); err != nil {\n \t\treturn err\n \t}\n \n-\tif err := mapFiles(obj, req); err != nil {\n-\t\treturn err\n+\treturn validate(obj)\n+}\n+\n+type multipartRequest http.Request\n+\n+var (\n+\tmultipartFileHeaderStructType = reflect.TypeOf(multipart.FileHeader{})\n+)\n+\n+func (r *multipartRequest) Set(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error) {",
        "comment_created_at": "2019-03-30T14:00:37+00:00",
        "comment_author": "vkd",
        "comment_body": "What do you mean when you talk about \"node\"?\r\nBtw, this method is not exported because the type `multipartRequest` is not exported, and I see no warnings about this from any linters.",
        "pr_file_module": null
      },
      {
        "comment_id": "270699611",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 1829,
        "pr_file": "binding/form.go",
        "discussion_id": "270607421",
        "commented_code": "@@ -53,13 +57,30 @@ func (formMultipartBinding) Bind(req *http.Request, obj interface{}) error {\n \tif err := req.ParseMultipartForm(defaultMemory); err != nil {\n \t\treturn err\n \t}\n-\tif err := mapForm(obj, req.MultipartForm.Value); err != nil {\n+\tif err := mappingByPtr(obj, (*multipartRequest)(req), \"form\"); err != nil {\n \t\treturn err\n \t}\n \n-\tif err := mapFiles(obj, req); err != nil {\n-\t\treturn err\n+\treturn validate(obj)\n+}\n+\n+type multipartRequest http.Request\n+\n+var (\n+\tmultipartFileHeaderStructType = reflect.TypeOf(multipart.FileHeader{})\n+)\n+\n+func (r *multipartRequest) Set(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error) {",
        "comment_created_at": "2019-04-01T01:55:56+00:00",
        "comment_author": "thinkerou",
        "comment_body": "@vkd sorry, word typo, `note`.\r\nYes, it's not exported. We should add some usage note for new and important interface/method/class even if un-exported. thanks!",
        "pr_file_module": null
      },
      {
        "comment_id": "270752589",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 1829,
        "pr_file": "binding/form.go",
        "discussion_id": "270607421",
        "commented_code": "@@ -53,13 +57,30 @@ func (formMultipartBinding) Bind(req *http.Request, obj interface{}) error {\n \tif err := req.ParseMultipartForm(defaultMemory); err != nil {\n \t\treturn err\n \t}\n-\tif err := mapForm(obj, req.MultipartForm.Value); err != nil {\n+\tif err := mappingByPtr(obj, (*multipartRequest)(req), \"form\"); err != nil {\n \t\treturn err\n \t}\n \n-\tif err := mapFiles(obj, req); err != nil {\n-\t\treturn err\n+\treturn validate(obj)\n+}\n+\n+type multipartRequest http.Request\n+\n+var (\n+\tmultipartFileHeaderStructType = reflect.TypeOf(multipart.FileHeader{})\n+)\n+\n+func (r *multipartRequest) Set(value reflect.Value, field reflect.StructField, key string, opt setOptions) (isSetted bool, err error) {",
        "comment_created_at": "2019-04-01T08:03:38+00:00",
        "comment_author": "vkd",
        "comment_body": "Ok, thanks. I've added a couple of comments.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "217152194",
    "pr_number": 1539,
    "pr_file": "gin.go",
    "created_at": "2018-09-12T19:02:05+00:00",
    "commented_code": "return\n }\n \n+// RunLimited - use netuil.LimitListener to limit the number of inbound accepts",
    "repo_full_name": "gin-gonic/gin",
    "discussion_comments": [
      {
        "comment_id": "217152194",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 1539,
        "pr_file": "gin.go",
        "discussion_id": "217152194",
        "commented_code": "@@ -288,6 +290,42 @@ func (engine *Engine) Run(addr ...string) (err error) {\n \treturn\n }\n \n+// RunLimited - use netuil.LimitListener to limit the number of inbound accepts",
        "comment_created_at": "2018-09-12T19:02:05+00:00",
        "comment_author": "javierprovecho",
        "comment_body": "don't use '-'  after func name, we prefer this format: `// RunLimited attaches the router to a http.Server and starts listening and serving HTTP requests using netutil.LimitListener to limit the number of inbound accepts`",
        "pr_file_module": null
      }
    ]
  }
]