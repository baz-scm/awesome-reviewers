[
  {
    "discussion_id": "2167938992",
    "pr_number": 4276,
    "pr_file": "context.go",
    "created_at": "2025-06-26T01:56:44+00:00",
    "commented_code": "TOMLData any\n }\n \n-// Negotiate calls different Render according to acceptable Accept format.\n-func (c *Context) Negotiate(code int, config Negotiate) {\n-\tswitch c.NegotiateFormat(config.Offered...) {\n-\tcase binding.MIMEJSON:\n+func NewNegotiate(offered []string) Negotiate {\n+\treturn Negotiate{Offered: offered}\n+}\n+func (receiver Negotiate) WithData(data any) Negotiate {\n+\treceiver.Data = data\n+\treturn receiver\n+}\n+\n+// NegotiationRenderFunc is responsible for rendering data in a specific format.\n+type NegotiationRenderFunc func(status int, config Negotiate, c *Context)\n+\n+func AddNegotiationRenderMapping(mimeType string, binding NegotiationRenderFunc) {\n+\tnegotiationRenderMappings[mimeType] = binding\n+}\n+\n+// All predefined negotiationRenderMappings - associate a content type\n+// with a NegotiationRenderFunc, which is responsible for rendering\n+// data in a specific format.\n+var negotiationRenderMappings = map[string]NegotiationRenderFunc{\n+\tbinding.MIMEJSON: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.JSONData, config.Data)\n \t\tc.JSON(code, data)\n-\n-\tcase binding.MIMEHTML:\n+\t},\n+\tbinding.MIMEHTML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.HTMLData, config.Data)\n \t\tc.HTML(code, config.HTMLName, data)\n-\n-\tcase binding.MIMEXML:\n+\t},\n+\tbinding.MIMEXML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.XMLData, config.Data)\n \t\tc.XML(code, data)\n-\n-\tcase binding.MIMEYAML, binding.MIMEYAML2:\n+\t},\n+\tbinding.MIMEYAML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.YAMLData, config.Data)\n \t\tc.YAML(code, data)\n-\n-\tcase binding.MIMETOML:\n+\t},\n+\tbinding.MIMEYAML2: func(code int, config Negotiate, c *Context) {\n+\t\tdata := chooseData(config.YAMLData, config.Data)\n+\t\tc.YAML(code, data)\n+\t},\n+\tbinding.MIMETOML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.TOMLData, config.Data)\n \t\tc.TOML(code, data)\n+\t},\n+\tbinding.MIMEPROTOBUF: func(code int, config Negotiate, c *Context) {\n+\t\tc.ProtoBuf(code, config.Data)\n+\t},\n+}\n \n-\tdefault:\n-\t\tc.AbortWithError(http.StatusNotAcceptable, errors.New(\"the accepted formats are not offered by the server\")) //nolint: errcheck\n+// Negotiate calls different Render according to acceptable Accept format.\n+func (c *Context) Negotiate(code int, config Negotiate) {\n+\n+\taccepted := c.NegotiateFormat(config.Offered...)\n+\tfor bind, fn := range negotiationRenderMappings {\n+\t\tif bind == accepted {\n+\t\t\tfn(code, config, c)\n+\t\t\treturn\n+\t\t}",
    "repo_full_name": "gin-gonic/gin",
    "discussion_comments": [
      {
        "comment_id": "2167938992",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 4276,
        "pr_file": "context.go",
        "discussion_id": "2167938992",
        "commented_code": "@@ -1264,32 +1264,66 @@ type Negotiate struct {\n \tTOMLData any\n }\n \n-// Negotiate calls different Render according to acceptable Accept format.\n-func (c *Context) Negotiate(code int, config Negotiate) {\n-\tswitch c.NegotiateFormat(config.Offered...) {\n-\tcase binding.MIMEJSON:\n+func NewNegotiate(offered []string) Negotiate {\n+\treturn Negotiate{Offered: offered}\n+}\n+func (receiver Negotiate) WithData(data any) Negotiate {\n+\treceiver.Data = data\n+\treturn receiver\n+}\n+\n+// NegotiationRenderFunc is responsible for rendering data in a specific format.\n+type NegotiationRenderFunc func(status int, config Negotiate, c *Context)\n+\n+func AddNegotiationRenderMapping(mimeType string, binding NegotiationRenderFunc) {\n+\tnegotiationRenderMappings[mimeType] = binding\n+}\n+\n+// All predefined negotiationRenderMappings - associate a content type\n+// with a NegotiationRenderFunc, which is responsible for rendering\n+// data in a specific format.\n+var negotiationRenderMappings = map[string]NegotiationRenderFunc{\n+\tbinding.MIMEJSON: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.JSONData, config.Data)\n \t\tc.JSON(code, data)\n-\n-\tcase binding.MIMEHTML:\n+\t},\n+\tbinding.MIMEHTML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.HTMLData, config.Data)\n \t\tc.HTML(code, config.HTMLName, data)\n-\n-\tcase binding.MIMEXML:\n+\t},\n+\tbinding.MIMEXML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.XMLData, config.Data)\n \t\tc.XML(code, data)\n-\n-\tcase binding.MIMEYAML, binding.MIMEYAML2:\n+\t},\n+\tbinding.MIMEYAML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.YAMLData, config.Data)\n \t\tc.YAML(code, data)\n-\n-\tcase binding.MIMETOML:\n+\t},\n+\tbinding.MIMEYAML2: func(code int, config Negotiate, c *Context) {\n+\t\tdata := chooseData(config.YAMLData, config.Data)\n+\t\tc.YAML(code, data)\n+\t},\n+\tbinding.MIMETOML: func(code int, config Negotiate, c *Context) {\n \t\tdata := chooseData(config.TOMLData, config.Data)\n \t\tc.TOML(code, data)\n+\t},\n+\tbinding.MIMEPROTOBUF: func(code int, config Negotiate, c *Context) {\n+\t\tc.ProtoBuf(code, config.Data)\n+\t},\n+}\n \n-\tdefault:\n-\t\tc.AbortWithError(http.StatusNotAcceptable, errors.New(\"the accepted formats are not offered by the server\")) //nolint: errcheck\n+// Negotiate calls different Render according to acceptable Accept format.\n+func (c *Context) Negotiate(code int, config Negotiate) {\n+\n+\taccepted := c.NegotiateFormat(config.Offered...)\n+\tfor bind, fn := range negotiationRenderMappings {\n+\t\tif bind == accepted {\n+\t\t\tfn(code, config, c)\n+\t\t\treturn\n+\t\t}",
        "comment_created_at": "2025-06-26T01:56:44+00:00",
        "comment_author": "Copilot",
        "comment_body": "Iterating over the entire map to find a matching key is O(n). You can simplify and speed this up by doing a direct lookup: `if fn, ok := negotiationRenderMappings[accepted]; ok { ... }`.\n```suggestion\n\tif fn, ok := negotiationRenderMappings[accepted]; ok {\n\t\tfn(code, config, c)\n\t\treturn\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "187933858",
    "pr_number": 1296,
    "pr_file": "gin.go",
    "created_at": "2018-05-14T12:26:14+00:00",
    "commented_code": "engine.SetHTMLTemplate(templ)\n }\n \n+// LoadHTMLFilesRecursively loads recursively a slice of HTML files mathing an extension\n+// and associates the result with HTML renderer.\n+func (engine *Engine) LoadHTMLFilesRecursively(folder string, extensionsAllowed []string) {\n+\n+\tfiles := []string{}\n+\tsort.Strings(extensionsAllowed)\n+\n+\tfilepath.Walk(folder, func(path string, info os.FileInfo, err error) error {\n+\t\textension := strings.ToLower(filepath.Ext(path))\n+\t\tindexFound := sort.SearchStrings(extensionsAllowed, extension)\n+\t\tif indexFound < len(extensionsAllowed) && extensionsAllowed[indexFound] == extension {\n+\t\t\tfiles = append(files, path)",
    "repo_full_name": "gin-gonic/gin",
    "discussion_comments": [
      {
        "comment_id": "187933858",
        "repo_full_name": "gin-gonic/gin",
        "pr_number": 1296,
        "pr_file": "gin.go",
        "discussion_id": "187933858",
        "commented_code": "@@ -194,6 +197,26 @@ func (engine *Engine) LoadHTMLFiles(files ...string) {\n \tengine.SetHTMLTemplate(templ)\n }\n \n+// LoadHTMLFilesRecursively loads recursively a slice of HTML files mathing an extension\n+// and associates the result with HTML renderer.\n+func (engine *Engine) LoadHTMLFilesRecursively(folder string, extensionsAllowed []string) {\n+\n+\tfiles := []string{}\n+\tsort.Strings(extensionsAllowed)\n+\n+\tfilepath.Walk(folder, func(path string, info os.FileInfo, err error) error {\n+\t\textension := strings.ToLower(filepath.Ext(path))\n+\t\tindexFound := sort.SearchStrings(extensionsAllowed, extension)\n+\t\tif indexFound < len(extensionsAllowed) && extensionsAllowed[indexFound] == extension {\n+\t\t\tfiles = append(files, path)",
        "comment_created_at": "2018-05-14T12:26:14+00:00",
        "comment_author": "thinkerou",
        "comment_body": "There are have `sort` and `search` two steps.\r\nwhy not use the follow code?\r\n\r\n```go\r\nfor _, v := range extensionsAllowed {\r\n    if strings.ToLower(v) == extension {\r\n        files = append(files, path)\r\n    }\r\n}\r\n```\r\nmoreover, `sort.SearchStrings` maybe have problem, see https://github.com/golang/go/issues/25382",
        "pr_file_module": null
      }
    ]
  }
]