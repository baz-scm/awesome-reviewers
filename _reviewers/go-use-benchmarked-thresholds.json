[
  {
    "discussion_id": "1039851514",
    "pr_number": 57080,
    "pr_file": "src/encoding/json/encode.go",
    "created_at": "2022-12-05T16:58:40+00:00",
    "commented_code": "return &encodeState{ptrSeen: make(map[any]struct{})}\n }\n \n+func cacheEncodeState(e *encodeState) {\n+\t// caching large objects is not memory efficient.\n+\tif e.Buffer.Cap() > 32768 {",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "1039851514",
        "repo_full_name": "golang/go",
        "pr_number": 57080,
        "pr_file": "src/encoding/json/encode.go",
        "discussion_id": "1039851514",
        "commented_code": "@@ -312,6 +312,14 @@ func newEncodeState() *encodeState {\n \treturn &encodeState{ptrSeen: make(map[any]struct{})}\n }\n \n+func cacheEncodeState(e *encodeState) {\n+\t// caching large objects is not memory efficient.\n+\tif e.Buffer.Cap() > 32768 {",
        "comment_created_at": "2022-12-05T16:58:40+00:00",
        "comment_author": "lavalamp",
        "comment_body": "Some limit seems like a great idea, but how did you come up with this specific number?",
        "pr_file_module": null
      },
      {
        "comment_id": "1039872785",
        "repo_full_name": "golang/go",
        "pr_number": 57080,
        "pr_file": "src/encoding/json/encode.go",
        "discussion_id": "1039851514",
        "commented_code": "@@ -312,6 +312,14 @@ func newEncodeState() *encodeState {\n \treturn &encodeState{ptrSeen: make(map[any]struct{})}\n }\n \n+func cacheEncodeState(e *encodeState) {\n+\t// caching large objects is not memory efficient.\n+\tif e.Buffer.Cap() > 32768 {",
        "comment_created_at": "2022-12-05T17:17:22+00:00",
        "comment_author": "linxiulei",
        "comment_body": "I am open to any numbers <= 1MiB, which is good enough for apiserver issue that I am trying to fix",
        "pr_file_module": null
      },
      {
        "comment_id": "1039881909",
        "repo_full_name": "golang/go",
        "pr_number": 57080,
        "pr_file": "src/encoding/json/encode.go",
        "discussion_id": "1039851514",
        "commented_code": "@@ -312,6 +312,14 @@ func newEncodeState() *encodeState {\n \treturn &encodeState{ptrSeen: make(map[any]struct{})}\n }\n \n+func cacheEncodeState(e *encodeState) {\n+\t// caching large objects is not memory efficient.\n+\tif e.Buffer.Cap() > 32768 {",
        "comment_created_at": "2022-12-05T17:26:36+00:00",
        "comment_author": "lavalamp",
        "comment_body": "I recommend doing some kind of search process to recommend an optimal value or a tighter range. E.g. binary search through possible values to find the lowest and highest ones that fix your problem.\r\n\r\nI suspect your particular test won't be able to narrow this down too much, you'll need a more realistic object size distribution. I'm not sure where to get that from.",
        "pr_file_module": null
      },
      {
        "comment_id": "1039889510",
        "repo_full_name": "golang/go",
        "pr_number": 57080,
        "pr_file": "src/encoding/json/encode.go",
        "discussion_id": "1039851514",
        "commented_code": "@@ -312,6 +312,14 @@ func newEncodeState() *encodeState {\n \treturn &encodeState{ptrSeen: make(map[any]struct{})}\n }\n \n+func cacheEncodeState(e *encodeState) {\n+\t// caching large objects is not memory efficient.\n+\tif e.Buffer.Cap() > 32768 {",
        "comment_created_at": "2022-12-05T17:34:04+00:00",
        "comment_author": "lavalamp",
        "comment_body": "Actually, I just read this code more and I agree that caching large objects is going to be horribly memory inefficient because they can be reused to store small objects, which will retain all that memory for little reason. I'm not sure where a good threshold is but it may be even smaller than this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1402793001",
    "pr_number": 48209,
    "pr_file": "src/cmd/compile/internal/inline/inl.go",
    "created_at": "2023-11-22T23:24:33+00:00",
    "commented_code": "inlineMaxBudget       = 80\n \tinlineExtraAppendCost = 0\n \t// default is to inline if there's at most one call. -l=4 overrides this by using 1 instead.\n-\tinlineExtraCallCost  = 57              // 57 was benchmarked to provided most benefit with no bad surprises; see https://github.com/golang/go/issues/19348#issuecomment-439370742\n+\tinlineExtraCallCost  = 57              // 57 was benchmarked to provide most benefit with no bad surprises; see https://github.com/golang/go/issues/19348#issuecomment-439370742\n \tinlineExtraPanicCost = 1               // do not penalize inlining panics.\n \tinlineExtraThrowCost = inlineMaxBudget // with current (2018-05/1.11) code, inlining runtime.throw does not help.\n \n \tinlineBigFunctionNodes   = 5000 // Functions with this many nodes are considered \"big\".\n \tinlineBigFunctionMaxCost = 20   // Max cost of inlinee when inlining into a \"big\" function.\n+\n+\t// These values were benchmarked to provide most benefit with no bad surprises.\n+\tinlineBigForCost           = 105 // FORs with at least this cost are considered \"big\".\n+\tinlineIntoForExtraCallCost = 14\n+\tinlineIntoForExtraBudget   = 18 // Extra budget when inlining into FORs which are not \"big\".\n+\n+\t// The upper budget for a visitor. It accounts the maximum cost with which a function could be inlined.\n+\tinlineVisitorBudget = inlineMaxBudget + inlineIntoForExtraBudget\n )\n \n+// isInlinable checks if the function can be inlined in a 'typical' scenario\n+// when no boosts are applied.\n+func isInlinable(fn *ir.Func) bool {\n+\treturn fn != nil && fn.Inl != nil && fn.Inl.Cost <= inlineMaxBudget\n+}\n+\n+type forContext struct {\n+\tcost int32 // Helps to determine if FOR is a \"big\" one.\n+}\n+\n+type inlContext struct {\n+\t// Map to keep track of functions that have been inlined at a particular\n+\t// call site, in order to stop inlining when we reach the beginning of a\n+\t// recursion cycle again. We don't inline immediately recursive functions,\n+\t// but allow inlining if there is a recursion cycle of many functions.\n+\t// Most likely, the inlining will stop before we even hit the beginning of\n+\t// the cycle again, but the map catches the unusual case.\n+\tinlinedCallees map[*ir.Func]bool\n+\n+\t// Stack to recognise which call nodes are located inside fors, while doing inlnode.\n+\tforsStack           []forContext\n+\tinitialInlineBudget int32 // Initial inline budget. Boosts are calculated related to this.\n+}\n+\n+// Current decision is made on whether all FORs in current scope are not \"big\".\n+func (ctx inlContext) canBoostInliningIntoFor() bool {\n+\tfor i := 0; i < len(ctx.forsStack); i++ {\n+\t\tif ctx.forsStack[i].cost >= inlineBigForCost {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn len(ctx.forsStack) > 0\n+}\n+\n+func (ctx *inlContext) Init(fn *ir.Func) {\n+\tctx.inlinedCallees = make(map[*ir.Func]bool)\n+\n+\tif isBigFunc(fn) {\n+\t\tctx.initialInlineBudget = inlineBigFunctionMaxCost\n+\t} else {\n+\t\tctx.initialInlineBudget = inlineMaxBudget\n+\t}\n+}\n+\n+func (ctx *inlContext) PushFor(n ir.Node) {\n+\tctx.forsStack = append(ctx.forsStack, forContext{forCost(n)})\n+\n+\tif base.Flag.LowerM > 1 {\n+\t\tfmt.Printf(\"%v: add FOR to stack %v\n\", ir.Line(n), ctx.forsStack)\n+\t}\n+}\n+\n+func (ctx *inlContext) PopFor() {\n+\tctx.forsStack = ctx.forsStack[:len(ctx.forsStack)-1]\n+}\n+\n+func (ctx inlContext) InlineBudget() int32 {\n+\tfinalBudget := ctx.initialInlineBudget\n+\tif ctx.canBoostInliningIntoFor() && ctx.initialInlineBudget == inlineMaxBudget {\n+\t\t// Boosts only regular functions\n+\t\tfinalBudget += inlineIntoForExtraBudget\n+\t}\n+\n+\treturn finalBudget",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "1402793001",
        "repo_full_name": "golang/go",
        "pr_number": 48209,
        "pr_file": "src/cmd/compile/internal/inline/inl.go",
        "discussion_id": "1402793001",
        "commented_code": "@@ -45,14 +45,107 @@ const (\n \tinlineMaxBudget       = 80\n \tinlineExtraAppendCost = 0\n \t// default is to inline if there's at most one call. -l=4 overrides this by using 1 instead.\n-\tinlineExtraCallCost  = 57              // 57 was benchmarked to provided most benefit with no bad surprises; see https://github.com/golang/go/issues/19348#issuecomment-439370742\n+\tinlineExtraCallCost  = 57              // 57 was benchmarked to provide most benefit with no bad surprises; see https://github.com/golang/go/issues/19348#issuecomment-439370742\n \tinlineExtraPanicCost = 1               // do not penalize inlining panics.\n \tinlineExtraThrowCost = inlineMaxBudget // with current (2018-05/1.11) code, inlining runtime.throw does not help.\n \n \tinlineBigFunctionNodes   = 5000 // Functions with this many nodes are considered \"big\".\n \tinlineBigFunctionMaxCost = 20   // Max cost of inlinee when inlining into a \"big\" function.\n+\n+\t// These values were benchmarked to provide most benefit with no bad surprises.\n+\tinlineBigForCost           = 105 // FORs with at least this cost are considered \"big\".\n+\tinlineIntoForExtraCallCost = 14\n+\tinlineIntoForExtraBudget   = 18 // Extra budget when inlining into FORs which are not \"big\".\n+\n+\t// The upper budget for a visitor. It accounts the maximum cost with which a function could be inlined.\n+\tinlineVisitorBudget = inlineMaxBudget + inlineIntoForExtraBudget\n )\n \n+// isInlinable checks if the function can be inlined in a 'typical' scenario\n+// when no boosts are applied.\n+func isInlinable(fn *ir.Func) bool {\n+\treturn fn != nil && fn.Inl != nil && fn.Inl.Cost <= inlineMaxBudget\n+}\n+\n+type forContext struct {\n+\tcost int32 // Helps to determine if FOR is a \"big\" one.\n+}\n+\n+type inlContext struct {\n+\t// Map to keep track of functions that have been inlined at a particular\n+\t// call site, in order to stop inlining when we reach the beginning of a\n+\t// recursion cycle again. We don't inline immediately recursive functions,\n+\t// but allow inlining if there is a recursion cycle of many functions.\n+\t// Most likely, the inlining will stop before we even hit the beginning of\n+\t// the cycle again, but the map catches the unusual case.\n+\tinlinedCallees map[*ir.Func]bool\n+\n+\t// Stack to recognise which call nodes are located inside fors, while doing inlnode.\n+\tforsStack           []forContext\n+\tinitialInlineBudget int32 // Initial inline budget. Boosts are calculated related to this.\n+}\n+\n+// Current decision is made on whether all FORs in current scope are not \"big\".\n+func (ctx inlContext) canBoostInliningIntoFor() bool {\n+\tfor i := 0; i < len(ctx.forsStack); i++ {\n+\t\tif ctx.forsStack[i].cost >= inlineBigForCost {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn len(ctx.forsStack) > 0\n+}\n+\n+func (ctx *inlContext) Init(fn *ir.Func) {\n+\tctx.inlinedCallees = make(map[*ir.Func]bool)\n+\n+\tif isBigFunc(fn) {\n+\t\tctx.initialInlineBudget = inlineBigFunctionMaxCost\n+\t} else {\n+\t\tctx.initialInlineBudget = inlineMaxBudget\n+\t}\n+}\n+\n+func (ctx *inlContext) PushFor(n ir.Node) {\n+\tctx.forsStack = append(ctx.forsStack, forContext{forCost(n)})\n+\n+\tif base.Flag.LowerM > 1 {\n+\t\tfmt.Printf(\"%v: add FOR to stack %v\\n\", ir.Line(n), ctx.forsStack)\n+\t}\n+}\n+\n+func (ctx *inlContext) PopFor() {\n+\tctx.forsStack = ctx.forsStack[:len(ctx.forsStack)-1]\n+}\n+\n+func (ctx inlContext) InlineBudget() int32 {\n+\tfinalBudget := ctx.initialInlineBudget\n+\tif ctx.canBoostInliningIntoFor() && ctx.initialInlineBudget == inlineMaxBudget {\n+\t\t// Boosts only regular functions\n+\t\tfinalBudget += inlineIntoForExtraBudget\n+\t}\n+\n+\treturn finalBudget",
        "comment_created_at": "2023-11-22T23:24:33+00:00",
        "comment_author": "Mifrill",
        "comment_body": "When the calculated value can be directly returned without being stored in an intermediary variable, it results in a more concise and straightforward function:\r\n```suggestion\r\n\tif ctx.canBoostInliningIntoFor() && ctx.initialInlineBudget == inlineMaxBudget {\r\n\t\t// Only boost regular functions\r\n\t\treturn ctx.initialInlineBudget + inlineIntoForExtraBudget\r\n\t}\r\n\r\n\treturn ctx.initialInlineBudget\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "281461671",
    "pr_number": 31803,
    "pr_file": "src/encoding/binary/binary_test.go",
    "created_at": "2019-05-07T05:04:38+00:00",
    "commented_code": "LittleEndian.PutUint64(putbuf[:], uint64(i))\n \t}\n }\n+\n+func BenchmarkReadFloats(b *testing.B) {\n+\tvar ls Struct\n+\tbsr := &byteSliceReader{}\n+\tvar r io.Reader = bsr\n+\tb.SetBytes(4 + 8)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbsr.remain = big[30:]\n+\t\tRead(r, BigEndian, &ls.Float32)\n+\t\tRead(r, BigEndian, &ls.Float64)",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "281461671",
        "repo_full_name": "golang/go",
        "pr_number": 31803,
        "pr_file": "src/encoding/binary/binary_test.go",
        "discussion_id": "281461671",
        "commented_code": "@@ -542,3 +542,50 @@ func BenchmarkLittleEndianPutUint64(b *testing.B) {\n \t\tLittleEndian.PutUint64(putbuf[:], uint64(i))\n \t}\n }\n+\n+func BenchmarkReadFloats(b *testing.B) {\n+\tvar ls Struct\n+\tbsr := &byteSliceReader{}\n+\tvar r io.Reader = bsr\n+\tb.SetBytes(4 + 8)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbsr.remain = big[30:]\n+\t\tRead(r, BigEndian, &ls.Float32)\n+\t\tRead(r, BigEndian, &ls.Float64)",
        "comment_created_at": "2019-05-07T05:04:38+00:00",
        "comment_author": "CAFxX",
        "comment_body": "I'd have separated benchmarks for 32 and 64 bits.\r\n\r\nSame applies below.",
        "pr_file_module": null
      }
    ]
  }
]