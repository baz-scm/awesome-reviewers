[
  {
    "discussion_id": "402411190",
    "pr_number": 36678,
    "pr_file": "src/net/http/httputil/reverseproxy.go",
    "created_at": "2020-04-02T15:37:40+00:00",
    "commented_code": "outreq.Header.Set(\"Upgrade\", reqUpType)\n \t}\n \n+\tif p.OverwriteForwardedHeaders {\n+\t\tproto := \"https\"\n+\t\tif req.TLS == nil {",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "402411190",
        "repo_full_name": "golang/go",
        "pr_number": 36678,
        "pr_file": "src/net/http/httputil/reverseproxy.go",
        "discussion_id": "402411190",
        "commented_code": "@@ -244,6 +259,17 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t\toutreq.Header.Set(\"Upgrade\", reqUpType)\n \t}\n \n+\tif p.OverwriteForwardedHeaders {\n+\t\tproto := \"https\"\n+\t\tif req.TLS == nil {",
        "comment_created_at": "2020-04-02T15:37:40+00:00",
        "comment_author": "ruudk",
        "comment_body": "Not sure about this. `req.TLS` is only set when the current http server is handling the TLS. But if TLS is done by a load balancer in front of this server, it will say `http`, how can the backend know if it was an `https` request originally?",
        "pr_file_module": null
      },
      {
        "comment_id": "402477923",
        "repo_full_name": "golang/go",
        "pr_number": 36678,
        "pr_file": "src/net/http/httputil/reverseproxy.go",
        "discussion_id": "402411190",
        "commented_code": "@@ -244,6 +259,17 @@ func (p *ReverseProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n \t\toutreq.Header.Set(\"Upgrade\", reqUpType)\n \t}\n \n+\tif p.OverwriteForwardedHeaders {\n+\t\tproto := \"https\"\n+\t\tif req.TLS == nil {",
        "comment_created_at": "2020-04-02T17:17:09+00:00",
        "comment_author": "dunglas",
        "comment_body": "Then you'll have to handle this manually. If the TLS termination is handled by a non-HTTP server, the proxy cannot guess it. If it is handled by an HTTP server, then this server should set the Forwarded headers.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "993573272",
    "pr_number": 56161,
    "pr_file": "src/net/dnsconfig_windows.go",
    "created_at": "2022-10-12T14:54:22+00:00",
    "commented_code": "// In practice, however, it mostly works.\n \tfor _, aa := range aas {\n \t\tfor dns := aa.FirstDnsServerAddress; dns != nil; dns = dns.Next {\n+\t\t\t// Only take interfaces whose OperStatus is IfOperStatusUp(0x01) into DNS configs.\n+\t\t\tif aa.OperStatus != 0x01 {",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "993573272",
        "repo_full_name": "golang/go",
        "pr_number": 56161,
        "pr_file": "src/net/dnsconfig_windows.go",
        "discussion_id": "993573272",
        "commented_code": "@@ -30,6 +30,10 @@ func dnsReadConfig(ignoredFilename string) (conf *dnsConfig) {\n \t// In practice, however, it mostly works.\n \tfor _, aa := range aas {\n \t\tfor dns := aa.FirstDnsServerAddress; dns != nil; dns = dns.Next {\n+\t\t\t// Only take interfaces whose OperStatus is IfOperStatusUp(0x01) into DNS configs.\n+\t\t\tif aa.OperStatus != 0x01 {",
        "comment_created_at": "2022-10-12T14:54:22+00:00",
        "comment_author": "wizardishungry",
        "comment_body": "```suggestion\r\n\t\t\tif aa.OperStatus != windows.IfOperStatusUp {\r\n```\r\nYou'll need to import `syscall/windows` as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "996976639",
        "repo_full_name": "golang/go",
        "pr_number": 56161,
        "pr_file": "src/net/dnsconfig_windows.go",
        "discussion_id": "993573272",
        "commented_code": "@@ -30,6 +30,10 @@ func dnsReadConfig(ignoredFilename string) (conf *dnsConfig) {\n \t// In practice, however, it mostly works.\n \tfor _, aa := range aas {\n \t\tfor dns := aa.FirstDnsServerAddress; dns != nil; dns = dns.Next {\n+\t\t\t// Only take interfaces whose OperStatus is IfOperStatusUp(0x01) into DNS configs.\n+\t\t\tif aa.OperStatus != 0x01 {",
        "comment_created_at": "2022-10-17T12:05:02+00:00",
        "comment_author": "zhzy0077",
        "comment_body": "Thank you. It's updated.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "542482520",
    "pr_number": 42768,
    "pr_file": "src/net/unixsock_readmsg_test.go",
    "created_at": "2020-12-14T15:38:57+00:00",
    "commented_code": "+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T) {\n+\tif !testableNetwork(\"unix\") {\n+\t\tt.Skip(\"not unix system\")\n+\t}\n+\n+\tfds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_STREAM, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Socketpair: %v\", err)\n+\t}\n+\twriteFile := os.NewFile(uintptr(fds[0]), \"parent-reads\")\n+\treadFile := os.NewFile(uintptr(fds[1]), \"parent-reads\")\n+\tdefer readFile.Close()\n+\n+\tc, err := FileConn(readFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\n+\tuc, ok := c.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", c)\n+\t}\n+\n+\tbuf := make([]byte, 32) // expect 1 byte\n+\toob := make([]byte, 32) // expect 24 bytes\n+\terr = uc.SetReadDeadline(5 * time.Second)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Can't set unix connection timeout: %v\", err)\n+\t}\n+\t_, oobn, _, _, err := uc.ReadMsgUnix(buf, oob)",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "542482520",
        "repo_full_name": "golang/go",
        "pr_number": 42768,
        "pr_file": "src/net/unixsock_readmsg_test.go",
        "discussion_id": "542482520",
        "commented_code": "@@ -0,0 +1,75 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T) {\n+\tif !testableNetwork(\"unix\") {\n+\t\tt.Skip(\"not unix system\")\n+\t}\n+\n+\tfds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_STREAM, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Socketpair: %v\", err)\n+\t}\n+\twriteFile := os.NewFile(uintptr(fds[0]), \"parent-reads\")\n+\treadFile := os.NewFile(uintptr(fds[1]), \"parent-reads\")\n+\tdefer readFile.Close()\n+\n+\tc, err := FileConn(readFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\n+\tuc, ok := c.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", c)\n+\t}\n+\n+\tbuf := make([]byte, 32) // expect 1 byte\n+\toob := make([]byte, 32) // expect 24 bytes\n+\terr = uc.SetReadDeadline(5 * time.Second)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Can't set unix connection timeout: %v\", err)\n+\t}\n+\t_, oobn, _, _, err := uc.ReadMsgUnix(buf, oob)",
        "comment_created_at": "2020-12-14T15:38:57+00:00",
        "comment_author": "rittneje",
        "comment_body": "You still need to write something to the connection first (see point 4 [here](https://github.com/golang/go/issues/42765#issuecomment-744038431)).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "542483383",
    "pr_number": 42768,
    "pr_file": "src/net/unixsock_readmsg_test.go",
    "created_at": "2020-12-14T15:40:02+00:00",
    "commented_code": "+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T) {\n+\tif !testableNetwork(\"unix\") {\n+\t\tt.Skip(\"not unix system\")\n+\t}\n+\n+\tfds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_STREAM, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Socketpair: %v\", err)\n+\t}\n+\twriteFile := os.NewFile(uintptr(fds[0]), \"parent-reads\")\n+\treadFile := os.NewFile(uintptr(fds[1]), \"parent-reads\")\n+\tdefer readFile.Close()\n+\n+\tc, err := FileConn(readFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\n+\tuc, ok := c.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", c)\n+\t}\n+\n+\tbuf := make([]byte, 32) // expect 1 byte\n+\toob := make([]byte, 32) // expect 24 bytes",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "542483383",
        "repo_full_name": "golang/go",
        "pr_number": 42768,
        "pr_file": "src/net/unixsock_readmsg_test.go",
        "discussion_id": "542483383",
        "commented_code": "@@ -0,0 +1,75 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T) {\n+\tif !testableNetwork(\"unix\") {\n+\t\tt.Skip(\"not unix system\")\n+\t}\n+\n+\tfds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_STREAM, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Socketpair: %v\", err)\n+\t}\n+\twriteFile := os.NewFile(uintptr(fds[0]), \"parent-reads\")\n+\treadFile := os.NewFile(uintptr(fds[1]), \"parent-reads\")\n+\tdefer readFile.Close()\n+\n+\tc, err := FileConn(readFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tdefer c.Close()\n+\n+\tuc, ok := c.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", c)\n+\t}\n+\n+\tbuf := make([]byte, 32) // expect 1 byte\n+\toob := make([]byte, 32) // expect 24 bytes",
        "comment_created_at": "2020-12-14T15:40:02+00:00",
        "comment_author": "rittneje",
        "comment_body": "The size should be `syscall.CmsgSpace(4)` (because one file descriptor is 4 bytes). You should also remove/update the comment.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "543492141",
    "pr_number": 42768,
    "pr_file": "src/net/unixsock_readmsg_test.go",
    "created_at": "2020-12-15T16:25:53+00:00",
    "commented_code": "+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package net\n+\n+import (\n+\t\"log\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T) {\n+\tif !testableNetwork(\"unix\") {\n+\t\tt.Skip(\"not unix system\")\n+\t}\n+\n+\tscmFile, err := os.Open(os.DevNull)\n+\tif err != nil {\n+\t\tt.Fatalf(\"file open: %v\", err)\n+\t}\n+\tdefer scmFile.Close()\n+\n+\trights := syscall.UnixRights(int(scmFile.Fd()))\n+\tfds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_STREAM, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Socketpair: %v\", err)\n+\t}\n+\n+\twriteFile := os.NewFile(uintptr(fds[0]), \"write-socket\")\n+\treadFile := os.NewFile(uintptr(fds[1]), \"read-socket\")\n+\tdefer writeFile.Close()\n+\tdefer readFile.Close()\n+\n+\tcw, err := FileConn(writeFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tcr, err := FileConn(readFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tdefer cr.Close()\n+\tdefer cw.Close()\n+\n+\tucw, ok := cw.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", cw)\n+\t}\n+\tucr, ok := cr.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", cr)\n+\t}\n+\n+\toob := make([]byte, syscall.CmsgSpace(4))\n+\terr = ucw.SetWriteDeadline(5 * time.Second)",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "543492141",
        "repo_full_name": "golang/go",
        "pr_number": 42768,
        "pr_file": "src/net/unixsock_readmsg_test.go",
        "discussion_id": "543492141",
        "commented_code": "@@ -0,0 +1,106 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris\n+\n+package net\n+\n+import (\n+\t\"log\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+func TestUnixConnReadMsgUnixSCMRightsCloseOnExec(t *testing.T) {\n+\tif !testableNetwork(\"unix\") {\n+\t\tt.Skip(\"not unix system\")\n+\t}\n+\n+\tscmFile, err := os.Open(os.DevNull)\n+\tif err != nil {\n+\t\tt.Fatalf(\"file open: %v\", err)\n+\t}\n+\tdefer scmFile.Close()\n+\n+\trights := syscall.UnixRights(int(scmFile.Fd()))\n+\tfds, err := syscall.Socketpair(syscall.AF_LOCAL, syscall.SOCK_STREAM, 0)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Socketpair: %v\", err)\n+\t}\n+\n+\twriteFile := os.NewFile(uintptr(fds[0]), \"write-socket\")\n+\treadFile := os.NewFile(uintptr(fds[1]), \"read-socket\")\n+\tdefer writeFile.Close()\n+\tdefer readFile.Close()\n+\n+\tcw, err := FileConn(writeFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tcr, err := FileConn(readFile)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FileConn: %v\", err)\n+\t}\n+\tdefer cr.Close()\n+\tdefer cw.Close()\n+\n+\tucw, ok := cw.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", cw)\n+\t}\n+\tucr, ok := cr.(*UnixConn)\n+\tif !ok {\n+\t\tt.Fatalf(\"unexpected FileConn type; expected UnixConn, got %T\", cr)\n+\t}\n+\n+\toob := make([]byte, syscall.CmsgSpace(4))\n+\terr = ucw.SetWriteDeadline(5 * time.Second)",
        "comment_created_at": "2020-12-15T16:25:53+00:00",
        "comment_author": "rittneje",
        "comment_body": "This needs to be `time.Now().Add(5 * time.Second)`. Same for `SetReadDeadline` below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "283715970",
    "pr_number": 30278,
    "pr_file": "src/net/ip.go",
    "created_at": "2019-05-14T09:49:29+00:00",
    "commented_code": "return len(ip) == IPv6len && ip[0] == 0xff\n }\n \n+// IsLocal reports whether `ip' is a local address, according to\n+// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n+func (ip IP) IsLocal() bool {\n+\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t// Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918\n+\t\treturn ip4[0] == 10 ||\n+\t\t\t(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||\n+\t\t\t(ip4[0] == 192 && ip4[1] == 168)",
    "repo_full_name": "golang/go",
    "discussion_comments": [
      {
        "comment_id": "283715970",
        "repo_full_name": "golang/go",
        "pr_number": 30278,
        "pr_file": "src/net/ip.go",
        "discussion_id": "283715970",
        "commented_code": "@@ -130,6 +130,19 @@ func (ip IP) IsMulticast() bool {\n \treturn len(ip) == IPv6len && ip[0] == 0xff\n }\n \n+// IsLocal reports whether `ip' is a local address, according to\n+// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n+func (ip IP) IsLocal() bool {\n+\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t// Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918\n+\t\treturn ip4[0] == 10 ||\n+\t\t\t(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||\n+\t\t\t(ip4[0] == 192 && ip4[1] == 168)",
        "comment_created_at": "2019-05-14T09:49:29+00:00",
        "comment_author": "msoedov",
        "comment_body": "1) `IsLocal` name is miss-leading. Did you mean `IsPrivate`? I would interpret `IsLocal` as a private address in **the same network** \r\n2) How to handle cases `0.0.0.0` and `127.0.0.1` and `::1`?",
        "pr_file_module": null
      },
      {
        "comment_id": "298539876",
        "repo_full_name": "golang/go",
        "pr_number": 30278,
        "pr_file": "src/net/ip.go",
        "discussion_id": "283715970",
        "commented_code": "@@ -130,6 +130,19 @@ func (ip IP) IsMulticast() bool {\n \treturn len(ip) == IPv6len && ip[0] == 0xff\n }\n \n+// IsLocal reports whether `ip' is a local address, according to\n+// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n+func (ip IP) IsLocal() bool {\n+\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t// Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918\n+\t\treturn ip4[0] == 10 ||\n+\t\t\t(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||\n+\t\t\t(ip4[0] == 192 && ip4[1] == 168)",
        "comment_created_at": "2019-06-28T10:23:07+00:00",
        "comment_author": "cypres",
        "comment_body": "1. I also think `IsPrivate` would be a better name.\r\n2. We do at least have `IsUnspecified()` and `IsLoopback()` to cover those cases with IsLocal you can do `IsLocal() || IsUnspecified() || IsLoopback()` if you want to cover all.",
        "pr_file_module": null
      },
      {
        "comment_id": "302766777",
        "repo_full_name": "golang/go",
        "pr_number": 30278,
        "pr_file": "src/net/ip.go",
        "discussion_id": "283715970",
        "commented_code": "@@ -130,6 +130,19 @@ func (ip IP) IsMulticast() bool {\n \treturn len(ip) == IPv6len && ip[0] == 0xff\n }\n \n+// IsLocal reports whether `ip' is a local address, according to\n+// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n+func (ip IP) IsLocal() bool {\n+\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t// Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918\n+\t\treturn ip4[0] == 10 ||\n+\t\t\t(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||\n+\t\t\t(ip4[0] == 192 && ip4[1] == 168)",
        "comment_created_at": "2019-07-11T22:29:18+00:00",
        "comment_author": "ilyam8",
        "comment_body": "Speaking about [private addresses](https://en.wikipedia.org/wiki/Reserved_IP_addresses) - [`100.64.0.0/10`](https://tools.ietf.org/html/rfc6598) is private, [`198.18.0.0/15`](https://tools.ietf.org/html/rfc5735) is private too.\r\n\r\nThis implementation is true only for `RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).`",
        "pr_file_module": null
      },
      {
        "comment_id": "302771189",
        "repo_full_name": "golang/go",
        "pr_number": 30278,
        "pr_file": "src/net/ip.go",
        "discussion_id": "283715970",
        "commented_code": "@@ -130,6 +130,19 @@ func (ip IP) IsMulticast() bool {\n \treturn len(ip) == IPv6len && ip[0] == 0xff\n }\n \n+// IsLocal reports whether `ip' is a local address, according to\n+// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n+func (ip IP) IsLocal() bool {\n+\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t// Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918\n+\t\treturn ip4[0] == 10 ||\n+\t\t\t(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||\n+\t\t\t(ip4[0] == 192 && ip4[1] == 168)",
        "comment_created_at": "2019-07-11T22:48:29+00:00",
        "comment_author": "cypres",
        "comment_body": "Sure but that doesn't mean it would still be useful too have a group for RFC 1918 and RFC 4193... We're using this to filter webhook calls, so people can't setup a webhook that calls a private address in our internal networks. The carrier grade nat scope  100.64.0.0/10 and/or the benchmark test net 198.18.0.0/15 is not really any concern for us, protecting internal networks is.",
        "pr_file_module": null
      },
      {
        "comment_id": "302774296",
        "repo_full_name": "golang/go",
        "pr_number": 30278,
        "pr_file": "src/net/ip.go",
        "discussion_id": "283715970",
        "commented_code": "@@ -130,6 +130,19 @@ func (ip IP) IsMulticast() bool {\n \treturn len(ip) == IPv6len && ip[0] == 0xff\n }\n \n+// IsLocal reports whether `ip' is a local address, according to\n+// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n+func (ip IP) IsLocal() bool {\n+\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t// Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918\n+\t\treturn ip4[0] == 10 ||\n+\t\t\t(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||\n+\t\t\t(ip4[0] == 192 && ip4[1] == 168)",
        "comment_created_at": "2019-07-11T23:02:01+00:00",
        "comment_author": "ilyam8",
        "comment_body": "i was not clear, my points are:\r\n - `IsLocal` is a bad name, i am with you on it.\r\n - `IsPrivate` is ok name, but changing the name brings new problem - current implementation includes only part of private ip address blocks.",
        "pr_file_module": null
      },
      {
        "comment_id": "302815955",
        "repo_full_name": "golang/go",
        "pr_number": 30278,
        "pr_file": "src/net/ip.go",
        "discussion_id": "283715970",
        "commented_code": "@@ -130,6 +130,19 @@ func (ip IP) IsMulticast() bool {\n \treturn len(ip) == IPv6len && ip[0] == 0xff\n }\n \n+// IsLocal reports whether `ip' is a local address, according to\n+// RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).\n+func (ip IP) IsLocal() bool {\n+\tif ip4 := ip.To4(); ip4 != nil {\n+\t\t// Local IPv4 addresses are defined in https://tools.ietf.org/html/rfc1918\n+\t\treturn ip4[0] == 10 ||\n+\t\t\t(ip4[0] == 172 && ip4[1]&0xf0 == 16) ||\n+\t\t\t(ip4[0] == 192 && ip4[1] == 168)",
        "comment_created_at": "2019-07-12T03:31:46+00:00",
        "comment_author": "ilyam8",
        "comment_body": "I have a second thought about it. `IsPrivate` wont do, because there are a lot of other ip block in the private scope. \r\n\r\nIP blocks from `rfc1918` fall into `private` category but they have special purpose. `rfc1918` doesnt name them local tho. But the gist is -  local communication (inside enterprise). So the grouping is ok, naming is a little bit miss-leading. Proof - our comments :smile: \r\n\r\nBut `IsLocal` makes more sense then `IsPrivate` and this logical block shouldnt cover\r\n\r\n> How to handle cases 0.0.0.0 and 127.0.0.1 and ::1?\r\n\r\nOnly blocks from `RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses)` should be there.",
        "pr_file_module": null
      }
    ]
  }
]