[
  {
    "discussion_id": "2275052771",
    "pr_number": 4078,
    "pr_file": "crates/goose/src/agents/subagent_task_config.rs",
    "created_at": "2025-08-14T01:38:12+00:00",
    "commented_code": "+use crate::config::Config;\n+use crate::model::ModelConfig;\n use crate::providers::base::Provider;\n+use crate::providers::create;\n use std::env;\n use std::fmt;\n use std::sync::Arc;\n use uuid::Uuid;\n \n /// Default maximum number of turns for task execution\n-pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 5;\n+pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 10;\n \n-/// Environment variable name for configuring max turns\n-pub const GOOSE_SUBAGENT_MAX_TURNS_ENV_VAR: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+/// config variable name for max subagent turns\n+pub const GOOSE_SUBAGENT_MAX_TURNS: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+\n+/// config variable name for subagent provider\n+pub const GOOSE_SUBAGENT_PROVIDER: &str = \"GOOSE_SUBAGENT_PROVIDER\";",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2275052771",
        "repo_full_name": "block/goose",
        "pr_number": 4078,
        "pr_file": "crates/goose/src/agents/subagent_task_config.rs",
        "discussion_id": "2275052771",
        "commented_code": "@@ -1,50 +1,106 @@\n+use crate::config::Config;\n+use crate::model::ModelConfig;\n use crate::providers::base::Provider;\n+use crate::providers::create;\n use std::env;\n use std::fmt;\n use std::sync::Arc;\n use uuid::Uuid;\n \n /// Default maximum number of turns for task execution\n-pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 5;\n+pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 10;\n \n-/// Environment variable name for configuring max turns\n-pub const GOOSE_SUBAGENT_MAX_TURNS_ENV_VAR: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+/// config variable name for max subagent turns\n+pub const GOOSE_SUBAGENT_MAX_TURNS: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+\n+/// config variable name for subagent provider\n+pub const GOOSE_SUBAGENT_PROVIDER: &str = \"GOOSE_SUBAGENT_PROVIDER\";",
        "comment_created_at": "2025-08-14T01:38:12+00:00",
        "comment_author": "michaelneale",
        "comment_body": "I don't think we want another env var - but this should hopefully use the consolidated provider config being worked on cc @DOsinga\r\n\r\nalso wouldn't subagent be more dynamic. ie it could even at runtime decide to use a different model? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2276954238",
        "repo_full_name": "block/goose",
        "pr_number": 4078,
        "pr_file": "crates/goose/src/agents/subagent_task_config.rs",
        "discussion_id": "2275052771",
        "commented_code": "@@ -1,50 +1,106 @@\n+use crate::config::Config;\n+use crate::model::ModelConfig;\n use crate::providers::base::Provider;\n+use crate::providers::create;\n use std::env;\n use std::fmt;\n use std::sync::Arc;\n use uuid::Uuid;\n \n /// Default maximum number of turns for task execution\n-pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 5;\n+pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 10;\n \n-/// Environment variable name for configuring max turns\n-pub const GOOSE_SUBAGENT_MAX_TURNS_ENV_VAR: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+/// config variable name for max subagent turns\n+pub const GOOSE_SUBAGENT_MAX_TURNS: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+\n+/// config variable name for subagent provider\n+pub const GOOSE_SUBAGENT_PROVIDER: &str = \"GOOSE_SUBAGENT_PROVIDER\";",
        "comment_created_at": "2025-08-14T15:22:48+00:00",
        "comment_author": "DOsinga",
        "comment_body": "I agree. This should be done through settings",
        "pr_file_module": null
      },
      {
        "comment_id": "2279548613",
        "repo_full_name": "block/goose",
        "pr_number": 4078,
        "pr_file": "crates/goose/src/agents/subagent_task_config.rs",
        "discussion_id": "2275052771",
        "commented_code": "@@ -1,50 +1,106 @@\n+use crate::config::Config;\n+use crate::model::ModelConfig;\n use crate::providers::base::Provider;\n+use crate::providers::create;\n use std::env;\n use std::fmt;\n use std::sync::Arc;\n use uuid::Uuid;\n \n /// Default maximum number of turns for task execution\n-pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 5;\n+pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 10;\n \n-/// Environment variable name for configuring max turns\n-pub const GOOSE_SUBAGENT_MAX_TURNS_ENV_VAR: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+/// config variable name for max subagent turns\n+pub const GOOSE_SUBAGENT_MAX_TURNS: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+\n+/// config variable name for subagent provider\n+pub const GOOSE_SUBAGENT_PROVIDER: &str = \"GOOSE_SUBAGENT_PROVIDER\";",
        "comment_created_at": "2025-08-15T17:29:00+00:00",
        "comment_author": "wendytang",
        "comment_body": "ack not adding more env vars - this is for a particular use case internally: \"we mostly set env vars via SKI's config map. These env are then picked up when we spawn the server in the same SKI pod\" \r\n\r\nis there a solution you'd recommend for this use case besides env vars? my understanding is that the local config.yaml wouldn't work here.\r\n\r\nhttps://sq-block.slack.com/archives/C06PBQ52MCK/p1755120454506039?thread_ts=1752186263.072219&cid=C06PBQ52MCK",
        "pr_file_module": null
      },
      {
        "comment_id": "2279603374",
        "repo_full_name": "block/goose",
        "pr_number": 4078,
        "pr_file": "crates/goose/src/agents/subagent_task_config.rs",
        "discussion_id": "2275052771",
        "commented_code": "@@ -1,50 +1,106 @@\n+use crate::config::Config;\n+use crate::model::ModelConfig;\n use crate::providers::base::Provider;\n+use crate::providers::create;\n use std::env;\n use std::fmt;\n use std::sync::Arc;\n use uuid::Uuid;\n \n /// Default maximum number of turns for task execution\n-pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 5;\n+pub const DEFAULT_SUBAGENT_MAX_TURNS: usize = 10;\n \n-/// Environment variable name for configuring max turns\n-pub const GOOSE_SUBAGENT_MAX_TURNS_ENV_VAR: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+/// config variable name for max subagent turns\n+pub const GOOSE_SUBAGENT_MAX_TURNS: &str = \"GOOSE_SUBAGENT_MAX_TURNS\";\n+\n+/// config variable name for subagent provider\n+pub const GOOSE_SUBAGENT_PROVIDER: &str = \"GOOSE_SUBAGENT_PROVIDER\";",
        "comment_created_at": "2025-08-15T18:02:53+00:00",
        "comment_author": "DOsinga",
        "comment_body": "two things:\r\n* why wouldn't we be able to ship whatever goose is run in the container with the right settings in the config.yaml?\r\n* even if we want to use environment variables, we should still read the values from the config; you can override those always with environment variables I think",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2249210547",
    "pr_number": 3761,
    "pr_file": "crates/goose/src/model.rs",
    "created_at": "2025-08-02T11:01:28+00:00",
    "commented_code": "#[test]\n     fn test_model_config_context_limits() {\n-        let config = ModelConfig::new(\"claude-3-opus\")\n-            .unwrap()\n-            .with_context_limit(Some(150_000));\n-        assert_eq!(config.context_limit(), 150_000);\n-\n-        let config = ModelConfig::new(\"claude-3-opus\").unwrap();\n-        assert_eq!(config.context_limit(), 200_000);\n-\n-        let config = ModelConfig::new(\"gpt-4-turbo\").unwrap();\n-        assert_eq!(config.context_limit(), 128_000);\n-\n-        let config = ModelConfig::new(\"unknown-model\").unwrap();\n-        assert_eq!(config.context_limit(), DEFAULT_CONTEXT_LIMIT);\n+        // Clear all GOOSE environment variables to ensure clean test environment\n+        with_var(\"GOOSE_TEMPERATURE\", None::<&str>, || {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2249210547",
        "repo_full_name": "block/goose",
        "pr_number": 3761,
        "pr_file": "crates/goose/src/model.rs",
        "discussion_id": "2249210547",
        "commented_code": "@@ -247,19 +247,28 @@ mod tests {\n \n     #[test]\n     fn test_model_config_context_limits() {\n-        let config = ModelConfig::new(\"claude-3-opus\")\n-            .unwrap()\n-            .with_context_limit(Some(150_000));\n-        assert_eq!(config.context_limit(), 150_000);\n-\n-        let config = ModelConfig::new(\"claude-3-opus\").unwrap();\n-        assert_eq!(config.context_limit(), 200_000);\n-\n-        let config = ModelConfig::new(\"gpt-4-turbo\").unwrap();\n-        assert_eq!(config.context_limit(), 128_000);\n-\n-        let config = ModelConfig::new(\"unknown-model\").unwrap();\n-        assert_eq!(config.context_limit(), DEFAULT_CONTEXT_LIMIT);\n+        // Clear all GOOSE environment variables to ensure clean test environment\n+        with_var(\"GOOSE_TEMPERATURE\", None::<&str>, || {",
        "comment_created_at": "2025-08-02T11:01:28+00:00",
        "comment_author": "DOsinga",
        "comment_body": "this with_var looks nice, but shouldn't this be at the other test that actually sets these? of course relying on these in tests is crazy to begin with\r\n\r\nceterum censeo variabiles ambientis esse delendas",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2249786549",
    "pr_number": 3788,
    "pr_file": "crates/goose/src/context_mgmt/auto_compact.rs",
    "created_at": "2025-08-03T08:36:37+00:00",
    "commented_code": "///\n /// This function analyzes the current token usage and returns detailed information\n /// about whether compaction is needed and how close we are to the threshold.\n+/// It prioritizes actual token counts from session metadata when available,\n+/// falling back to estimated counts if needed.\n ///\n /// # Arguments\n /// * `agent` - The agent to use for context management\n /// * `messages` - The current message history\n /// * `threshold_override` - Optional threshold override (defaults to GOOSE_AUTO_COMPACT_THRESHOLD config)\n+/// * `session_metadata` - Optional session metadata containing actual token counts\n ///\n /// # Returns\n /// * `CompactionCheckResult` containing detailed information about compaction needs\n pub async fn check_compaction_needed(\n     agent: &Agent,\n     messages: &[Message],\n     threshold_override: Option<f64>,\n+    session_metadata: Option<&crate::session::storage::SessionMetadata>,\n ) -> Result<CompactionCheckResult> {\n     // Get threshold from config or use override\n     let config = Config::global();",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2249786549",
        "repo_full_name": "block/goose",
        "pr_number": 3788,
        "pr_file": "crates/goose/src/context_mgmt/auto_compact.rs",
        "discussion_id": "2249786549",
        "commented_code": "@@ -42,18 +45,22 @@ pub struct CompactionCheckResult {\n ///\n /// This function analyzes the current token usage and returns detailed information\n /// about whether compaction is needed and how close we are to the threshold.\n+/// It prioritizes actual token counts from session metadata when available,\n+/// falling back to estimated counts if needed.\n ///\n /// # Arguments\n /// * `agent` - The agent to use for context management\n /// * `messages` - The current message history\n /// * `threshold_override` - Optional threshold override (defaults to GOOSE_AUTO_COMPACT_THRESHOLD config)\n+/// * `session_metadata` - Optional session metadata containing actual token counts\n ///\n /// # Returns\n /// * `CompactionCheckResult` containing detailed information about compaction needs\n pub async fn check_compaction_needed(\n     agent: &Agent,\n     messages: &[Message],\n     threshold_override: Option<f64>,\n+    session_metadata: Option<&crate::session::storage::SessionMetadata>,\n ) -> Result<CompactionCheckResult> {\n     // Get threshold from config or use override\n     let config = Config::global();",
        "comment_created_at": "2025-08-03T08:36:37+00:00",
        "comment_author": "DOsinga",
        "comment_body": "let's kill the environment variables - this function should just have the threshold passed in. some caller, somewhere may use the environment variable for now. but not this deep into things",
        "pr_file_module": null
      },
      {
        "comment_id": "2252182641",
        "repo_full_name": "block/goose",
        "pr_number": 3788,
        "pr_file": "crates/goose/src/context_mgmt/auto_compact.rs",
        "discussion_id": "2249786549",
        "commented_code": "@@ -42,18 +45,22 @@ pub struct CompactionCheckResult {\n ///\n /// This function analyzes the current token usage and returns detailed information\n /// about whether compaction is needed and how close we are to the threshold.\n+/// It prioritizes actual token counts from session metadata when available,\n+/// falling back to estimated counts if needed.\n ///\n /// # Arguments\n /// * `agent` - The agent to use for context management\n /// * `messages` - The current message history\n /// * `threshold_override` - Optional threshold override (defaults to GOOSE_AUTO_COMPACT_THRESHOLD config)\n+/// * `session_metadata` - Optional session metadata containing actual token counts\n ///\n /// # Returns\n /// * `CompactionCheckResult` containing detailed information about compaction needs\n pub async fn check_compaction_needed(\n     agent: &Agent,\n     messages: &[Message],\n     threshold_override: Option<f64>,\n+    session_metadata: Option<&crate::session::storage::SessionMetadata>,\n ) -> Result<CompactionCheckResult> {\n     // Get threshold from config or use override\n     let config = Config::global();",
        "comment_created_at": "2025-08-04T17:32:27+00:00",
        "comment_author": "katzdave",
        "comment_body": "Where do we draw the line what is/isn't allowed to read the global config? I do agree with you that it would be more clear if this parameter got passed in but if there are too many params it leads to a lot of clutter.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2212370782",
    "pr_number": 3474,
    "pr_file": "crates/goose/src/agents/retry.rs",
    "created_at": "2025-07-17T06:13:08+00:00",
    "commented_code": "+use anyhow::Result;\n+use std::process::Stdio;\n+use std::time::Duration;\n+use tokio::process::Command;\n+use tracing::{debug, info, warn};\n+\n+use crate::agents::types::{\n+    RetryConfig, SuccessCheck, SuccessCheckType, DEFAULT_CLEANUP_TIMEOUT_SECONDS,\n+    DEFAULT_RETRY_TIMEOUT_SECONDS,\n+};\n+use crate::config::Config;\n+\n+/// Environment variable for configuring retry timeout globally\n+const GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS\";\n+\n+/// Environment variable for configuring cleanup timeout globally\n+const GOOSE_RECIPE_CLEANUP_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_CLEANUP_TIMEOUT_SECONDS\";\n+\n+/// Get the configured timeout duration for retry operations\n+/// retry_config.timeout_seconds -> env var -> default\n+fn get_retry_timeout(retry_config: &RetryConfig) -> Duration {\n+    let timeout_seconds = retry_config\n+        .timeout_seconds\n+        .or_else(|| {\n+            let config = Config::global();\n+            config.get_param(GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS).ok()\n+        })\n+        .unwrap_or(DEFAULT_RETRY_TIMEOUT_SECONDS);\n+\n+    Duration::from_secs(timeout_seconds)",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2212370782",
        "repo_full_name": "block/goose",
        "pr_number": 3474,
        "pr_file": "crates/goose/src/agents/retry.rs",
        "discussion_id": "2212370782",
        "commented_code": "@@ -0,0 +1,323 @@\n+use anyhow::Result;\n+use std::process::Stdio;\n+use std::time::Duration;\n+use tokio::process::Command;\n+use tracing::{debug, info, warn};\n+\n+use crate::agents::types::{\n+    RetryConfig, SuccessCheck, SuccessCheckType, DEFAULT_CLEANUP_TIMEOUT_SECONDS,\n+    DEFAULT_RETRY_TIMEOUT_SECONDS,\n+};\n+use crate::config::Config;\n+\n+/// Environment variable for configuring retry timeout globally\n+const GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS\";\n+\n+/// Environment variable for configuring cleanup timeout globally\n+const GOOSE_RECIPE_CLEANUP_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_CLEANUP_TIMEOUT_SECONDS\";\n+\n+/// Get the configured timeout duration for retry operations\n+/// retry_config.timeout_seconds -> env var -> default\n+fn get_retry_timeout(retry_config: &RetryConfig) -> Duration {\n+    let timeout_seconds = retry_config\n+        .timeout_seconds\n+        .or_else(|| {\n+            let config = Config::global();\n+            config.get_param(GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS).ok()\n+        })\n+        .unwrap_or(DEFAULT_RETRY_TIMEOUT_SECONDS);\n+\n+    Duration::from_secs(timeout_seconds)",
        "comment_created_at": "2025-07-17T06:13:08+00:00",
        "comment_author": "jsibbison-square",
        "comment_body": "Do we have any validation anywhere that `max_retries is > 0` and same with these timeouts?",
        "pr_file_module": null
      },
      {
        "comment_id": "2215672500",
        "repo_full_name": "block/goose",
        "pr_number": 3474,
        "pr_file": "crates/goose/src/agents/retry.rs",
        "discussion_id": "2212370782",
        "commented_code": "@@ -0,0 +1,323 @@\n+use anyhow::Result;\n+use std::process::Stdio;\n+use std::time::Duration;\n+use tokio::process::Command;\n+use tracing::{debug, info, warn};\n+\n+use crate::agents::types::{\n+    RetryConfig, SuccessCheck, SuccessCheckType, DEFAULT_CLEANUP_TIMEOUT_SECONDS,\n+    DEFAULT_RETRY_TIMEOUT_SECONDS,\n+};\n+use crate::config::Config;\n+\n+/// Environment variable for configuring retry timeout globally\n+const GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS\";\n+\n+/// Environment variable for configuring cleanup timeout globally\n+const GOOSE_RECIPE_CLEANUP_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_CLEANUP_TIMEOUT_SECONDS\";\n+\n+/// Get the configured timeout duration for retry operations\n+/// retry_config.timeout_seconds -> env var -> default\n+fn get_retry_timeout(retry_config: &RetryConfig) -> Duration {\n+    let timeout_seconds = retry_config\n+        .timeout_seconds\n+        .or_else(|| {\n+            let config = Config::global();\n+            config.get_param(GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS).ok()\n+        })\n+        .unwrap_or(DEFAULT_RETRY_TIMEOUT_SECONDS);\n+\n+    Duration::from_secs(timeout_seconds)",
        "comment_created_at": "2025-07-18T10:16:42+00:00",
        "comment_author": "cloud-on-prem",
        "comment_body": "added validation to RetryConfig",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2188785846",
    "pr_number": 3262,
    "pr_file": "crates/goose/src/config/base.rs",
    "created_at": "2025-07-07T01:13:49+00:00",
    "commented_code": "/// For Goose-specific configuration, consider prefixing with \"goose_\" to avoid conflicts.\n pub struct Config {\n     config_path: PathBuf,\n-    secrets: SecretStorage,\n-}\n-\n-enum SecretStorage {\n-    Keyring { service: String },\n-    File { path: PathBuf },\n+    keyring: Arc<dyn KeyringBackend>,\n+    keyring_service: String,\n }\n \n // Global instance\n static GLOBAL_CONFIG: OnceCell<Config> = OnceCell::new();\n \n impl Default for Config {\n     fn default() -> Self {\n+        let config_dir = choose_app_strategy(APP_STRATEGY.clone())\n+            .expect(\"goose requires a home dir\")\n+            .config_dir();\n+\n+        let keyring: Arc<dyn KeyringBackend> = if env::var(\"GOOSE_DISABLE_KEYRING\").is_ok() {\n+            Arc::new(FileKeyringBackend::new(config_dir.join(\"secrets.yaml\")))",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2188785846",
        "repo_full_name": "block/goose",
        "pr_number": 3262,
        "pr_file": "crates/goose/src/config/base.rs",
        "discussion_id": "2188785846",
        "commented_code": "@@ -105,19 +106,31 @@ impl From<keyring::Error> for ConfigError {\n /// For Goose-specific configuration, consider prefixing with \"goose_\" to avoid conflicts.\n pub struct Config {\n     config_path: PathBuf,\n-    secrets: SecretStorage,\n-}\n-\n-enum SecretStorage {\n-    Keyring { service: String },\n-    File { path: PathBuf },\n+    keyring: Arc<dyn KeyringBackend>,\n+    keyring_service: String,\n }\n \n // Global instance\n static GLOBAL_CONFIG: OnceCell<Config> = OnceCell::new();\n \n impl Default for Config {\n     fn default() -> Self {\n+        let config_dir = choose_app_strategy(APP_STRATEGY.clone())\n+            .expect(\"goose requires a home dir\")\n+            .config_dir();\n+\n+        let keyring: Arc<dyn KeyringBackend> = if env::var(\"GOOSE_DISABLE_KEYRING\").is_ok() {\n+            Arc::new(FileKeyringBackend::new(config_dir.join(\"secrets.yaml\")))",
        "comment_created_at": "2025-07-07T01:13:49+00:00",
        "comment_author": "jsibbison-square",
        "comment_body": "Bonus points if \"secrets.yaml\" is a constant.",
        "pr_file_module": null
      },
      {
        "comment_id": "2188863089",
        "repo_full_name": "block/goose",
        "pr_number": 3262,
        "pr_file": "crates/goose/src/config/base.rs",
        "discussion_id": "2188785846",
        "commented_code": "@@ -105,19 +106,31 @@ impl From<keyring::Error> for ConfigError {\n /// For Goose-specific configuration, consider prefixing with \"goose_\" to avoid conflicts.\n pub struct Config {\n     config_path: PathBuf,\n-    secrets: SecretStorage,\n-}\n-\n-enum SecretStorage {\n-    Keyring { service: String },\n-    File { path: PathBuf },\n+    keyring: Arc<dyn KeyringBackend>,\n+    keyring_service: String,\n }\n \n // Global instance\n static GLOBAL_CONFIG: OnceCell<Config> = OnceCell::new();\n \n impl Default for Config {\n     fn default() -> Self {\n+        let config_dir = choose_app_strategy(APP_STRATEGY.clone())\n+            .expect(\"goose requires a home dir\")\n+            .config_dir();\n+\n+        let keyring: Arc<dyn KeyringBackend> = if env::var(\"GOOSE_DISABLE_KEYRING\").is_ok() {\n+            Arc::new(FileKeyringBackend::new(config_dir.join(\"secrets.yaml\")))",
        "comment_created_at": "2025-07-07T02:48:34+00:00",
        "comment_author": "cloud-on-prem",
        "comment_body": "yep good call; added it now",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1995814985",
    "pr_number": 1693,
    "pr_file": "crates/goose-cli/src/session/output.rs",
    "created_at": "2025-03-14T15:49:41+00:00",
    "commented_code": "}\n \n thread_local! {\n-    static CURRENT_THEME: RefCell<Theme> = RefCell::new(\n-        std::env::var(\"GOOSE_CLI_THEME\")\n-            .ok()\n-            .map(|val| {\n-                if val.eq_ignore_ascii_case(\"light\") {\n-                    Theme::Light\n-                } else if val.eq_ignore_ascii_case(\"ansi\") {\n-                    Theme::Ansi\n-                } else {\n-                    Theme::Dark\n-                }\n-            })\n-            .unwrap_or(Theme::Dark)\n-    );\n+    static CURRENT_THEME: RefCell<Theme> = RefCell::new({",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "1995814985",
        "repo_full_name": "block/goose",
        "pr_number": 1693,
        "pr_file": "crates/goose-cli/src/session/output.rs",
        "discussion_id": "1995814985",
        "commented_code": "@@ -28,24 +28,46 @@ impl Theme {\n }\n \n thread_local! {\n-    static CURRENT_THEME: RefCell<Theme> = RefCell::new(\n-        std::env::var(\"GOOSE_CLI_THEME\")\n-            .ok()\n-            .map(|val| {\n-                if val.eq_ignore_ascii_case(\"light\") {\n-                    Theme::Light\n-                } else if val.eq_ignore_ascii_case(\"ansi\") {\n-                    Theme::Ansi\n-                } else {\n-                    Theme::Dark\n-                }\n-            })\n-            .unwrap_or(Theme::Dark)\n-    );\n+    static CURRENT_THEME: RefCell<Theme> = RefCell::new({",
        "comment_created_at": "2025-03-14T15:49:41+00:00",
        "comment_author": "lily-de",
        "comment_body": "typically in our flows env vars supercede anything in the config, do you think that should be reversed for the theme? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1997563440",
        "repo_full_name": "block/goose",
        "pr_number": 1693,
        "pr_file": "crates/goose-cli/src/session/output.rs",
        "discussion_id": "1995814985",
        "commented_code": "@@ -28,24 +28,46 @@ impl Theme {\n }\n \n thread_local! {\n-    static CURRENT_THEME: RefCell<Theme> = RefCell::new(\n-        std::env::var(\"GOOSE_CLI_THEME\")\n-            .ok()\n-            .map(|val| {\n-                if val.eq_ignore_ascii_case(\"light\") {\n-                    Theme::Light\n-                } else if val.eq_ignore_ascii_case(\"ansi\") {\n-                    Theme::Ansi\n-                } else {\n-                    Theme::Dark\n-                }\n-            })\n-            .unwrap_or(Theme::Dark)\n-    );\n+    static CURRENT_THEME: RefCell<Theme> = RefCell::new({",
        "comment_created_at": "2025-03-16T11:21:09+00:00",
        "comment_author": "Developerayo",
        "comment_body": "Ah! I see, nope, I'll update to check env vars first then fallback to config",
        "pr_file_module": null
      }
    ]
  }
]