[
  {
    "discussion_id": "2271370982",
    "pr_number": 4057,
    "pr_file": "crates/goose/src/agents/extension_manager.rs",
    "created_at": "2025-08-12T21:48:38+00:00",
    "commented_code": "}\n }\n \n+async fn child_process_client(\n+    mut command: Command,\n+    timeout: &Option<u64>,\n+) -> ExtensionResult<McpClient> {\n+    command.process_group(0);\n+    let (transport, mut stderr) = TokioChildProcess::builder(command)\n+        .stderr(Stdio::piped())\n+        .spawn()?;\n+    let mut stderr = stderr\n+        .take()\n+        .expect(\"should have a stderr handle because it was requested\");",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2271370982",
        "repo_full_name": "block/goose",
        "pr_number": 4057,
        "pr_file": "crates/goose/src/agents/extension_manager.rs",
        "discussion_id": "2271370982",
        "commented_code": "@@ -105,6 +105,42 @@ impl Default for ExtensionManager {\n     }\n }\n \n+async fn child_process_client(\n+    mut command: Command,\n+    timeout: &Option<u64>,\n+) -> ExtensionResult<McpClient> {\n+    command.process_group(0);\n+    let (transport, mut stderr) = TokioChildProcess::builder(command)\n+        .stderr(Stdio::piped())\n+        .spawn()?;\n+    let mut stderr = stderr\n+        .take()\n+        .expect(\"should have a stderr handle because it was requested\");",
        "comment_created_at": "2025-08-12T21:48:38+00:00",
        "comment_author": "DOsinga",
        "comment_body": "this shouldn't happen of course, but I'd still rather do .ok_or or something so we don't panic",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2242081920",
    "pr_number": 3718,
    "pr_file": "crates/goose-server/src/routes/agent.rs",
    "created_at": "2025-07-30T09:38:14+00:00",
    "commented_code": ".get_param(\"GOOSE_MODEL\")\n             .expect(\"Did not find a model on payload or in env to update provider with\")\n     });\n-    let model_config = ModelConfig::new(model);\n+    let model_config = ModelConfig::new(&model).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2242081920",
        "repo_full_name": "block/goose",
        "pr_number": 3718,
        "pr_file": "crates/goose-server/src/routes/agent.rs",
        "discussion_id": "2242081920",
        "commented_code": "@@ -255,7 +255,7 @@ async fn update_agent_provider(\n             .get_param(\"GOOSE_MODEL\")\n             .expect(\"Did not find a model on payload or in env to update provider with\")\n     });\n-    let model_config = ModelConfig::new(model);\n+    let model_config = ModelConfig::new(&model).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;",
        "comment_created_at": "2025-07-30T09:38:14+00:00",
        "comment_author": "DOsinga",
        "comment_body": "the line above where we have .expect() will kill goosed and it is all over. not sure how we would have gotten here, but still, we should probably do another 500; I also think we should change the description of the 500 from internal server error here to something descriptive; could not update provider, make sure that you have the right config or something",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2219465464",
    "pr_number": 3513,
    "pr_file": "crates/goose/src/session/storage.rs",
    "created_at": "2025-07-21T14:54:09+00:00",
    "commented_code": ".to_path_buf()\n }\n \n+fn get_current_working_dir() -> PathBuf {\n+    std::env::current_dir()\n+        .or_else(|_| Ok::<PathBuf, io::Error>(get_home_dir()))\n+        .expect(\"could not determine the current working directory\")\n+}",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2219465464",
        "repo_full_name": "block/goose",
        "pr_number": 3513,
        "pr_file": "crates/goose/src/session/storage.rs",
        "discussion_id": "2219465464",
        "commented_code": "@@ -31,6 +31,12 @@ fn get_home_dir() -> PathBuf {\n         .to_path_buf()\n }\n \n+fn get_current_working_dir() -> PathBuf {\n+    std::env::current_dir()\n+        .or_else(|_| Ok::<PathBuf, io::Error>(get_home_dir()))\n+        .expect(\"could not determine the current working directory\")\n+}",
        "comment_created_at": "2025-07-21T14:54:09+00:00",
        "comment_author": "DOsinga",
        "comment_body": "excellent. I wonder if we should avoid panicking here though - either return a default \"\", or bubble up?\r\n\r\nfn get_current_working_dir() -> Result<PathBuf, io::Error> {\r\n    std::env::current_dir().or_else(|_| Ok(get_home_dir()))\r\n}\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2220730824",
        "repo_full_name": "block/goose",
        "pr_number": 3513,
        "pr_file": "crates/goose/src/session/storage.rs",
        "discussion_id": "2219465464",
        "commented_code": "@@ -31,6 +31,12 @@ fn get_home_dir() -> PathBuf {\n         .to_path_buf()\n }\n \n+fn get_current_working_dir() -> PathBuf {\n+    std::env::current_dir()\n+        .or_else(|_| Ok::<PathBuf, io::Error>(get_home_dir()))\n+        .expect(\"could not determine the current working directory\")\n+}",
        "comment_created_at": "2025-07-22T01:17:55+00:00",
        "comment_author": "michaelneale",
        "comment_body": "yeah - in other cases if we can't find a cwd then default to home (I think that may only show up in rare testing scenarios though). Things will work if you run from home (as it is usually smart enough to then know what directory to really work in from context later on) - so seems reasonable to default instead of panic?",
        "pr_file_module": null
      },
      {
        "comment_id": "2229344846",
        "repo_full_name": "block/goose",
        "pr_number": 3513,
        "pr_file": "crates/goose/src/session/storage.rs",
        "discussion_id": "2219465464",
        "commented_code": "@@ -31,6 +31,12 @@ fn get_home_dir() -> PathBuf {\n         .to_path_buf()\n }\n \n+fn get_current_working_dir() -> PathBuf {\n+    std::env::current_dir()\n+        .or_else(|_| Ok::<PathBuf, io::Error>(get_home_dir()))\n+        .expect(\"could not determine the current working directory\")\n+}",
        "comment_created_at": "2025-07-24T19:07:58+00:00",
        "comment_author": "s-soroosh",
        "comment_body": "Here we default to home dir and then panic. Isn't this the same behaviour as you outlined? \r\nNote that `get_home_dir` itself also panic if it can't find the home dir. So I think the only question is whether want want to show a specific error here that cwd couldn't be determined, or home directory couldn't be determined.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2189364582",
    "pr_number": 2793,
    "pr_file": "crates/goose/src/session/storage.rs",
    "created_at": "2025-07-07T08:33:19+00:00",
    "commented_code": ".to_path_buf()\n }\n \n+fn get_current_working_dir() -> PathBuf {\n+    std::env::current_dir().expect(\"could not determine the current working directory\")",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2189364582",
        "repo_full_name": "block/goose",
        "pr_number": 2793,
        "pr_file": "crates/goose/src/session/storage.rs",
        "discussion_id": "2189364582",
        "commented_code": "@@ -17,6 +17,10 @@ fn get_home_dir() -> PathBuf {\n         .to_path_buf()\n }\n \n+fn get_current_working_dir() -> PathBuf {\n+    std::env::current_dir().expect(\"could not determine the current working directory\")",
        "comment_created_at": "2025-07-07T08:33:19+00:00",
        "comment_author": "DOsinga",
        "comment_body": "would be better to default here to the home_dir rather than die ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2282458549",
    "pr_number": 4124,
    "pr_file": "crates/goose/src/providers/retry.rs",
    "created_at": "2025-08-18T13:46:24+00:00",
    "commented_code": "error\n                         );\n \n-                        let delay = config.delay_for_attempt(attempts);\n+                        let delay = if let ProviderError::RateLimitExceeded { retry_delay, .. } = &error {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2282458549",
        "repo_full_name": "block/goose",
        "pr_number": 4124,
        "pr_file": "crates/goose/src/providers/retry.rs",
        "discussion_id": "2282458549",
        "commented_code": "@@ -101,7 +101,17 @@ pub trait ProviderRetry {\n                             error\n                         );\n \n-                        let delay = config.delay_for_attempt(attempts);\n+                        let delay = if let ProviderError::RateLimitExceeded { retry_delay, .. } = &error {",
        "comment_created_at": "2025-08-18T13:46:24+00:00",
        "comment_author": "jamadeo",
        "comment_body": "you can simplify to\n\n```\n    let delay = match &error {\n        ProviderError::RateLimitExceeded {\n            retry_delay: Some(provider_delay),\n            ..\n        } => *provider_delay,\n        _ => config.delay_for_attempt(attempts),\n    };\n```\n\nlosing the debug but that doesn't seem terribly important to keep",
        "pr_file_module": null
      },
      {
        "comment_id": "2291049206",
        "repo_full_name": "block/goose",
        "pr_number": 4124,
        "pr_file": "crates/goose/src/providers/retry.rs",
        "discussion_id": "2282458549",
        "commented_code": "@@ -101,7 +101,17 @@ pub trait ProviderRetry {\n                             error\n                         );\n \n-                        let delay = config.delay_for_attempt(attempts);\n+                        let delay = if let ProviderError::RateLimitExceeded { retry_delay, .. } = &error {",
        "comment_created_at": "2025-08-21T13:21:09+00:00",
        "comment_author": "sings-to-bees-on-wednesdays",
        "comment_body": "OK, done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2199892001",
    "pr_number": 3257,
    "pr_file": "crates/goose-cli/src/cli.rs",
    "created_at": "2025-07-11T07:25:02+00:00",
    "commented_code": "use std::io::Read;\n use std::path::PathBuf;\n \n+use goose::message::MessageContent;\n+use goose::telemetry::{\n+    CommandExecution, CommandResult, CommandType, SessionExecution, SessionResult, SessionType,\n+    TokenUsage, ToolUsage,\n+};\n+use std::collections::HashMap;\n+\n+fn extract_telemetry_data_from_session(\n+    session: &crate::Session,\n+    params: &[(String, String)],\n+) -> (\n+    Option<TokenUsage>,\n+    Vec<ToolUsage>,\n+    HashMap<String, String>,\n+    Option<String>,\n+) {\n+    let token_usage = if let Ok(metadata) = session.get_metadata() {\n+        let input_tokens = metadata.input_tokens.unwrap_or(0) as u64;\n+        let output_tokens = metadata.output_tokens.unwrap_or(0) as u64;\n+\n+        if input_tokens > 0 || output_tokens > 0 {\n+            Some(TokenUsage::new(input_tokens, output_tokens))\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let messages = session.message_history();\n+    let mut tool_usage_map: HashMap<String, ToolUsage> = HashMap::new();\n+\n+    for message in &messages {\n+        for content in &message.content {\n+            match content {\n+                MessageContent::ToolRequest(tool_request) => {\n+                    if let Ok(tool_call) = &tool_request.tool_call {\n+                        let tool_name = &tool_call.name;\n+                        let entry = tool_usage_map\n+                            .entry(tool_name.clone())\n+                            .or_insert_with(|| ToolUsage::new(tool_name));\n+                        entry.add_call(std::time::Duration::from_millis(0), true);\n+                    }\n+                }\n+                MessageContent::ToolResponse(tool_response) => {\n+                    if tool_response.tool_result.is_err() {\n+                        for tool_usage in tool_usage_map.values_mut() {\n+                            if tool_usage.error_count < tool_usage.call_count {\n+                                tool_usage.error_count += 1;\n+                                tool_usage.success_count =\n+                                    tool_usage.call_count - tool_usage.error_count;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    let tool_usage: Vec<ToolUsage> = tool_usage_map.into_values().collect();\n+\n+    let mut metadata = HashMap::new();\n+    for (key, value) in params {\n+        metadata.insert(key.clone(), value.clone());\n+    }\n+\n+    if let Ok(session_metadata) = session.get_metadata() {\n+        metadata.insert(\n+            \"working_dir\".to_string(),\n+            session_metadata.working_dir.to_string_lossy().to_string(),\n+        );\n+        metadata.insert(\n+            \"message_count\".to_string(),\n+            session_metadata.message_count.to_string(),\n+        );\n+        if let Some(schedule_id) = session_metadata.schedule_id {\n+            metadata.insert(\"schedule_id\".to_string(), schedule_id);\n+        }\n+    }\n+\n+    let environment = detect_environment();\n+\n+    (token_usage, tool_usage, metadata, environment)\n+}\n+\n+fn detect_environment() -> Option<String> {\n+    let mut env_indicators = Vec::new();\n+\n+    if std::env::var(\"CI\").is_ok() {\n+        env_indicators.push(\"ci\");\n+    }\n+    if std::env::var(\"GITHUB_ACTIONS\").is_ok() {\n+        env_indicators.push(\"github-actions\");\n+    }\n+    if std::env::var(\"JENKINS_URL\").is_ok() {\n+        env_indicators.push(\"jenkins\");\n+    }\n+    if std::env::var(\"GITLAB_CI\").is_ok() {\n+        env_indicators.push(\"gitlab-ci\");\n+    }\n+\n+    if std::env::var(\"DOCKER_CONTAINER\").is_ok() || std::path::Path::new(\"/.dockerenv\").exists() {\n+        env_indicators.push(\"docker\");\n+    }\n+    if std::env::var(\"KUBERNETES_SERVICE_HOST\").is_ok() {\n+        env_indicators.push(\"kubernetes\");\n+    }\n+\n+    if std::env::var(\"AWS_LAMBDA_FUNCTION_NAME\").is_ok() {\n+        env_indicators.push(\"aws-lambda\");\n+    }\n+    if std::env::var(\"GOOGLE_CLOUD_PROJECT\").is_ok() {\n+        env_indicators.push(\"gcp\");\n+    }\n+    if std::env::var(\"AZURE_FUNCTIONS_ENVIRONMENT\").is_ok() {\n+        env_indicators.push(\"azure-functions\");\n+    }\n+\n+    if std::env::var(\"VSCODE_INJECTION\").is_ok() {\n+        env_indicators.push(\"vscode\");\n+    }\n+    if std::env::var(\"TERM_PROGRAM\").as_deref() == Ok(\"iTerm.app\") {\n+        env_indicators.push(\"iterm\");\n+    }\n+    if std::env::var(\"TERM_PROGRAM\").as_deref() == Ok(\"Apple_Terminal\") {\n+        env_indicators.push(\"terminal-app\");\n+    }\n+\n+    if std::env::var(\"GOOSE_JOB_ID\").is_ok() {\n+        env_indicators.push(\"scheduled\");\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    env_indicators.push(\"macos\");\n+    #[cfg(target_os = \"linux\")]\n+    env_indicators.push(\"linux\");\n+    #[cfg(target_os = \"windows\")]\n+    env_indicators.push(\"windows\");\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    env_indicators.push(\"x86_64\");\n+    #[cfg(target_arch = \"aarch64\")]\n+    env_indicators.push(\"aarch64\");\n+    #[cfg(target_arch = \"arm\")]\n+    env_indicators.push(\"arm\");\n+\n+    if env_indicators.is_empty() {\n+        None\n+    } else {\n+        Some(env_indicators.join(\",\"))\n+    }\n+}\n+\n+async fn track_session_execution<F, Fut, T>(\n+    session_id: &str,\n+    session_type: SessionType,\n+    execution_fn: F,\n+) -> Result<T>\n+where\n+    F: FnOnce() -> Fut,\n+    Fut: std::future::Future<Output = Result<(T, crate::Session)>>,\n+{\n+    let start_time = std::time::Instant::now();\n+\n+    let telemetry_execution = goose::telemetry::global_telemetry().map(|_manager| {\n+        SessionExecution::new(session_id, session_type).with_metadata(\"interface\", \"cli\")\n+    });\n+\n+    let result = execution_fn().await;\n+\n+    if let Some(mut execution) = telemetry_execution {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2199892001",
        "repo_full_name": "block/goose",
        "pr_number": 3257,
        "pr_file": "crates/goose-cli/src/cli.rs",
        "discussion_id": "2199892001",
        "commented_code": "@@ -29,6 +29,345 @@ use goose_bench::runners::model_runner::ModelRunner;\n use std::io::Read;\n use std::path::PathBuf;\n \n+use goose::message::MessageContent;\n+use goose::telemetry::{\n+    CommandExecution, CommandResult, CommandType, SessionExecution, SessionResult, SessionType,\n+    TokenUsage, ToolUsage,\n+};\n+use std::collections::HashMap;\n+\n+fn extract_telemetry_data_from_session(\n+    session: &crate::Session,\n+    params: &[(String, String)],\n+) -> (\n+    Option<TokenUsage>,\n+    Vec<ToolUsage>,\n+    HashMap<String, String>,\n+    Option<String>,\n+) {\n+    let token_usage = if let Ok(metadata) = session.get_metadata() {\n+        let input_tokens = metadata.input_tokens.unwrap_or(0) as u64;\n+        let output_tokens = metadata.output_tokens.unwrap_or(0) as u64;\n+\n+        if input_tokens > 0 || output_tokens > 0 {\n+            Some(TokenUsage::new(input_tokens, output_tokens))\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let messages = session.message_history();\n+    let mut tool_usage_map: HashMap<String, ToolUsage> = HashMap::new();\n+\n+    for message in &messages {\n+        for content in &message.content {\n+            match content {\n+                MessageContent::ToolRequest(tool_request) => {\n+                    if let Ok(tool_call) = &tool_request.tool_call {\n+                        let tool_name = &tool_call.name;\n+                        let entry = tool_usage_map\n+                            .entry(tool_name.clone())\n+                            .or_insert_with(|| ToolUsage::new(tool_name));\n+                        entry.add_call(std::time::Duration::from_millis(0), true);\n+                    }\n+                }\n+                MessageContent::ToolResponse(tool_response) => {\n+                    if tool_response.tool_result.is_err() {\n+                        for tool_usage in tool_usage_map.values_mut() {\n+                            if tool_usage.error_count < tool_usage.call_count {\n+                                tool_usage.error_count += 1;\n+                                tool_usage.success_count =\n+                                    tool_usage.call_count - tool_usage.error_count;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    let tool_usage: Vec<ToolUsage> = tool_usage_map.into_values().collect();\n+\n+    let mut metadata = HashMap::new();\n+    for (key, value) in params {\n+        metadata.insert(key.clone(), value.clone());\n+    }\n+\n+    if let Ok(session_metadata) = session.get_metadata() {\n+        metadata.insert(\n+            \"working_dir\".to_string(),\n+            session_metadata.working_dir.to_string_lossy().to_string(),\n+        );\n+        metadata.insert(\n+            \"message_count\".to_string(),\n+            session_metadata.message_count.to_string(),\n+        );\n+        if let Some(schedule_id) = session_metadata.schedule_id {\n+            metadata.insert(\"schedule_id\".to_string(), schedule_id);\n+        }\n+    }\n+\n+    let environment = detect_environment();\n+\n+    (token_usage, tool_usage, metadata, environment)\n+}\n+\n+fn detect_environment() -> Option<String> {\n+    let mut env_indicators = Vec::new();\n+\n+    if std::env::var(\"CI\").is_ok() {\n+        env_indicators.push(\"ci\");\n+    }\n+    if std::env::var(\"GITHUB_ACTIONS\").is_ok() {\n+        env_indicators.push(\"github-actions\");\n+    }\n+    if std::env::var(\"JENKINS_URL\").is_ok() {\n+        env_indicators.push(\"jenkins\");\n+    }\n+    if std::env::var(\"GITLAB_CI\").is_ok() {\n+        env_indicators.push(\"gitlab-ci\");\n+    }\n+\n+    if std::env::var(\"DOCKER_CONTAINER\").is_ok() || std::path::Path::new(\"/.dockerenv\").exists() {\n+        env_indicators.push(\"docker\");\n+    }\n+    if std::env::var(\"KUBERNETES_SERVICE_HOST\").is_ok() {\n+        env_indicators.push(\"kubernetes\");\n+    }\n+\n+    if std::env::var(\"AWS_LAMBDA_FUNCTION_NAME\").is_ok() {\n+        env_indicators.push(\"aws-lambda\");\n+    }\n+    if std::env::var(\"GOOGLE_CLOUD_PROJECT\").is_ok() {\n+        env_indicators.push(\"gcp\");\n+    }\n+    if std::env::var(\"AZURE_FUNCTIONS_ENVIRONMENT\").is_ok() {\n+        env_indicators.push(\"azure-functions\");\n+    }\n+\n+    if std::env::var(\"VSCODE_INJECTION\").is_ok() {\n+        env_indicators.push(\"vscode\");\n+    }\n+    if std::env::var(\"TERM_PROGRAM\").as_deref() == Ok(\"iTerm.app\") {\n+        env_indicators.push(\"iterm\");\n+    }\n+    if std::env::var(\"TERM_PROGRAM\").as_deref() == Ok(\"Apple_Terminal\") {\n+        env_indicators.push(\"terminal-app\");\n+    }\n+\n+    if std::env::var(\"GOOSE_JOB_ID\").is_ok() {\n+        env_indicators.push(\"scheduled\");\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    env_indicators.push(\"macos\");\n+    #[cfg(target_os = \"linux\")]\n+    env_indicators.push(\"linux\");\n+    #[cfg(target_os = \"windows\")]\n+    env_indicators.push(\"windows\");\n+\n+    #[cfg(target_arch = \"x86_64\")]\n+    env_indicators.push(\"x86_64\");\n+    #[cfg(target_arch = \"aarch64\")]\n+    env_indicators.push(\"aarch64\");\n+    #[cfg(target_arch = \"arm\")]\n+    env_indicators.push(\"arm\");\n+\n+    if env_indicators.is_empty() {\n+        None\n+    } else {\n+        Some(env_indicators.join(\",\"))\n+    }\n+}\n+\n+async fn track_session_execution<F, Fut, T>(\n+    session_id: &str,\n+    session_type: SessionType,\n+    execution_fn: F,\n+) -> Result<T>\n+where\n+    F: FnOnce() -> Fut,\n+    Fut: std::future::Future<Output = Result<(T, crate::Session)>>,\n+{\n+    let start_time = std::time::Instant::now();\n+\n+    let telemetry_execution = goose::telemetry::global_telemetry().map(|_manager| {\n+        SessionExecution::new(session_id, session_type).with_metadata(\"interface\", \"cli\")\n+    });\n+\n+    let result = execution_fn().await;\n+\n+    if let Some(mut execution) = telemetry_execution {",
        "comment_created_at": "2025-07-11T07:25:02+00:00",
        "comment_author": "cloud-on-prem",
        "comment_body": "Probably, worth catching the `None` case and logging it if Telemetry fails for some reason?",
        "pr_file_module": null
      }
    ]
  }
]