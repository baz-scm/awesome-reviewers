[
  {
    "discussion_id": "2288939389",
    "pr_number": 4228,
    "pr_file": "crates/goose/src/providers/base.rs",
    "created_at": "2025-08-20T18:15:05+00:00",
    "commented_code": "tools: &[Tool],\n     ) -> Result<(Message, ProviderUsage), ProviderError>;\n \n+    /// Generate the next message using a fast/cheaper model when available",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2288939389",
        "repo_full_name": "block/goose",
        "pr_number": 4228,
        "pr_file": "crates/goose/src/providers/base.rs",
        "discussion_id": "2288939389",
        "commented_code": "@@ -337,6 +337,32 @@ pub trait Provider: Send + Sync {\n         tools: &[Tool],\n     ) -> Result<(Message, ProviderUsage), ProviderError>;\n \n+    /// Generate the next message using a fast/cheaper model when available",
        "comment_created_at": "2025-08-20T18:15:05+00:00",
        "comment_author": "Kvadratni",
        "comment_body": "can we maybe just have complete take a model as optional so if not provided - we use the default ?\nthis way we son't need to add 2 methods to every provider?",
        "pr_file_module": null
      },
      {
        "comment_id": "2288972787",
        "repo_full_name": "block/goose",
        "pr_number": 4228,
        "pr_file": "crates/goose/src/providers/base.rs",
        "discussion_id": "2288939389",
        "commented_code": "@@ -337,6 +337,32 @@ pub trait Provider: Send + Sync {\n         tools: &[Tool],\n     ) -> Result<(Message, ProviderUsage), ProviderError>;\n \n+    /// Generate the next message using a fast/cheaper model when available",
        "comment_created_at": "2025-08-20T18:32:20+00:00",
        "comment_author": "katzdave",
        "comment_body": "My thought was I'd rather not leak model to provider base as it doesn't ever make sense to specify outside of this module, and I don't want someone to try setting it somewhere like summarize.rs",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2286122333",
    "pr_number": 2799,
    "pr_file": "crates/goose/src/providers/google.rs",
    "created_at": "2025-08-19T19:16:14+00:00",
    "commented_code": "key: api_key,\n         };\n \n-        let api_client =\n+        let mut api_client =\n             ApiClient::new(host, auth)?.with_header(\"Content-Type\", \"application/json\")?;\n \n+        // Apply TLS configuration if any TLS fields are configured\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            api_client = api_client.with_tls_config(tls_config)?;\n+        }\n+",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2286122333",
        "repo_full_name": "block/goose",
        "pr_number": 2799,
        "pr_file": "crates/goose/src/providers/google.rs",
        "discussion_id": "2286122333",
        "commented_code": "@@ -66,9 +66,14 @@ impl GoogleProvider {\n             key: api_key,\n         };\n \n-        let api_client =\n+        let mut api_client =\n             ApiClient::new(host, auth)?.with_header(\"Content-Type\", \"application/json\")?;\n \n+        // Apply TLS configuration if any TLS fields are configured\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            api_client = api_client.with_tls_config(tls_config)?;\n+        }\n+",
        "comment_created_at": "2025-08-19T19:16:14+00:00",
        "comment_author": "DOsinga",
        "comment_body": "can't we now just do this once in the api_client constructor?",
        "pr_file_module": null
      },
      {
        "comment_id": "2286126450",
        "repo_full_name": "block/goose",
        "pr_number": 2799,
        "pr_file": "crates/goose/src/providers/google.rs",
        "discussion_id": "2286122333",
        "commented_code": "@@ -66,9 +66,14 @@ impl GoogleProvider {\n             key: api_key,\n         };\n \n-        let api_client =\n+        let mut api_client =\n             ApiClient::new(host, auth)?.with_header(\"Content-Type\", \"application/json\")?;\n \n+        // Apply TLS configuration if any TLS fields are configured\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            api_client = api_client.with_tls_config(tls_config)?;\n+        }\n+",
        "comment_created_at": "2025-08-19T19:18:08+00:00",
        "comment_author": "myaple",
        "comment_body": "happy to, I was just following the pattern of the other with_* functions. I'll consolidate. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2286128939",
        "repo_full_name": "block/goose",
        "pr_number": 2799,
        "pr_file": "crates/goose/src/providers/google.rs",
        "discussion_id": "2286122333",
        "commented_code": "@@ -66,9 +66,14 @@ impl GoogleProvider {\n             key: api_key,\n         };\n \n-        let api_client =\n+        let mut api_client =\n             ApiClient::new(host, auth)?.with_header(\"Content-Type\", \"application/json\")?;\n \n+        // Apply TLS configuration if any TLS fields are configured\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            api_client = api_client.with_tls_config(tls_config)?;\n+        }\n+",
        "comment_created_at": "2025-08-19T19:19:37+00:00",
        "comment_author": "DOsinga",
        "comment_body": "yeah, I get that, but if it is not provider specific, we can just always load it. then if we need something for providers that is not general, we can add it there.",
        "pr_file_module": null
      },
      {
        "comment_id": "2286197054",
        "repo_full_name": "block/goose",
        "pr_number": 2799,
        "pr_file": "crates/goose/src/providers/google.rs",
        "discussion_id": "2286122333",
        "commented_code": "@@ -66,9 +66,14 @@ impl GoogleProvider {\n             key: api_key,\n         };\n \n-        let api_client =\n+        let mut api_client =\n             ApiClient::new(host, auth)?.with_header(\"Content-Type\", \"application/json\")?;\n \n+        // Apply TLS configuration if any TLS fields are configured\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            api_client = api_client.with_tls_config(tls_config)?;\n+        }\n+",
        "comment_created_at": "2025-08-19T19:56:10+00:00",
        "comment_author": "myaple",
        "comment_body": "alright, I cut it all down to just changes in the api_client itself, loads by default and keeps the rebuild_client bit for the other with_ funcs. I'll give it a test tomorrow and hopefully we can finish this PR then.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2199906450",
    "pr_number": 3353,
    "pr_file": "crates/goose/src/agents/subagent_handler.rs",
    "created_at": "2025-07-11T07:31:53+00:00",
    "commented_code": "args = args.with_timeout(timeout);\n         }\n \n-        // Get the provider from the parent agent\n-        let provider = self\n-            .provider()\n-            .await\n-            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to get provider: {}\", e)))?;\n+        // Determine which provider to use\n+        let provider = if let Some(recipe_name) = &args.recipe_name {\n+            // Load the recipe to check if it specifies a provider\n+            match manager.load_recipe(recipe_name).await {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2199906450",
        "repo_full_name": "block/goose",
        "pr_number": 3353,
        "pr_file": "crates/goose/src/agents/subagent_handler.rs",
        "discussion_id": "2199906450",
        "commented_code": "@@ -55,11 +57,82 @@ impl Agent {\n             args = args.with_timeout(timeout);\n         }\n \n-        // Get the provider from the parent agent\n-        let provider = self\n-            .provider()\n-            .await\n-            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to get provider: {}\", e)))?;\n+        // Determine which provider to use\n+        let provider = if let Some(recipe_name) = &args.recipe_name {\n+            // Load the recipe to check if it specifies a provider\n+            match manager.load_recipe(recipe_name).await {",
        "comment_created_at": "2025-07-11T07:31:53+00:00",
        "comment_author": "lifeizhou-ap",
        "comment_body": "This would not work sometimes as recipe could be a template that accept parameters to be rendered. \r\n\r\nRecipe example with parameters:  https://github.com/block/goose/pull/2395\r\n\r\nOne option that could be working nicely: \r\n\r\nShall we change the `subagent` constructor with parameters `system message`, `prompts`, `extensions`, `provider`, `model` and `temperature` (we also can group some of them into struct logically).  In this case sub-agent does not need to know the recipe. \r\n\r\nCurrently render recipe logic is in goose-cli and I can some of the logic into `goose` package.  Once the recipe is parsed, we can pass those attributes to sub-agent.  WDYT?\r\n\r\nWe can also sync on your Monday afternoon if you are available.   Thank you!\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2201366290",
        "repo_full_name": "block/goose",
        "pr_number": 3353,
        "pr_file": "crates/goose/src/agents/subagent_handler.rs",
        "discussion_id": "2199906450",
        "commented_code": "@@ -55,11 +57,82 @@ impl Agent {\n             args = args.with_timeout(timeout);\n         }\n \n-        // Get the provider from the parent agent\n-        let provider = self\n-            .provider()\n-            .await\n-            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to get provider: {}\", e)))?;\n+        // Determine which provider to use\n+        let provider = if let Some(recipe_name) = &args.recipe_name {\n+            // Load the recipe to check if it specifies a provider\n+            match manager.load_recipe(recipe_name).await {",
        "comment_created_at": "2025-07-11T17:15:32+00:00",
        "comment_author": "wendytang",
        "comment_body": "> Shall we change the subagent constructor with parameters system message, prompts, extensions, provider, model and temperature (we also can group some of them into struct logically). In this case sub-agent does not need to know the recipe.\r\n\r\nIn essence, recipe will be rendered with parameters and then the fields will be passed to subagent struct? That sounds good to me. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2178101251",
    "pr_number": 3188,
    "pr_file": "crates/goose/src/agents/final_output_tool.rs",
    "created_at": "2025-07-01T16:58:41+00:00",
    "commented_code": "+use crate::agents::tool_execution::ToolCallResult;\n+use crate::recipe::Response;\n+use indoc::formatdoc;\n+use mcp_core::{\n+    tool::{Tool, ToolAnnotations},\n+    Content, ToolCall, ToolError,\n+};\n+use serde_json::{json, Value};\n+\n+pub const FINAL_OUTPUT_TOOL_NAME: &str = \"final_output\";\n+pub const FINAL_OUTPUT_CONTINUATION_MESSAGE: &str =\n+    \"You MUST call the `final_output` tool with your final output for the user.\";\n+\n+pub struct FinalOutputTool {\n+    pub response: Response,\n+    /// The final output collected for the user. It will be a single line string for easy script extraction from output.\n+    pub final_output: Option<String>,\n+}\n+\n+impl FinalOutputTool {\n+    pub fn new(response: Response) -> Self {\n+        if response.json_schema.is_none() {\n+            panic!(\"Cannot create FinalOutputTool: json_schema is required\");\n+        }\n+        let schema = response.json_schema.as_ref().unwrap();\n+\n+        if let Some(obj) = schema.as_object() {\n+            if obj.is_empty() {\n+                panic!(\"Cannot create FinalOutputTool: empty json_schema is not allowed\");\n+            }\n+        }\n+\n+        jsonschema::meta::validate(schema).unwrap();\n+        Self {\n+            response,\n+            final_output: None,\n+        }\n+    }\n+\n+    pub fn tool(&self) -> Tool {\n+        let instructions = formatdoc! {r#\"\n+            This tool collects the final output for a user and provides validation for structured JSON final output against a predefined schema.\n+\n+            This tool MUST be used for the final output to the user.\n+            \n+            Purpose:\n+            - Collects the final output for a user\n+            - Ensures that final outputs conform to the expected JSON structure\n+            - Provides clear validation feedback when outputs don't match the schema\n+            \n+            Usage:\n+            - Call the `final_output` tool with your JSON final output\n+            \n+            The expected JSON schema format is:\n+\n+            {}\n+            \n+            When validation fails, you'll receive:\n+            - Specific validation errors\n+            - The expected format\n+        \"#, serde_json::to_string_pretty(self.response.json_schema.as_ref().unwrap()).unwrap()};\n+\n+        Tool::new(\n+            FINAL_OUTPUT_TOOL_NAME.to_string(),\n+            instructions,\n+            json!({\n+                \"type\": \"object\",\n+                \"properties\": {\n+                    \"final_output\": {\n+                        \"type\": \"string\",\n+                        \"description\": \"The JSON string final output to validate and collect\"\n+                    }\n+                },\n+                \"required\": [\"final_output\"]\n+            }),",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2178101251",
        "repo_full_name": "block/goose",
        "pr_number": 3188,
        "pr_file": "crates/goose/src/agents/final_output_tool.rs",
        "discussion_id": "2178101251",
        "commented_code": "@@ -0,0 +1,468 @@\n+use crate::agents::tool_execution::ToolCallResult;\n+use crate::recipe::Response;\n+use indoc::formatdoc;\n+use mcp_core::{\n+    tool::{Tool, ToolAnnotations},\n+    Content, ToolCall, ToolError,\n+};\n+use serde_json::{json, Value};\n+\n+pub const FINAL_OUTPUT_TOOL_NAME: &str = \"final_output\";\n+pub const FINAL_OUTPUT_CONTINUATION_MESSAGE: &str =\n+    \"You MUST call the `final_output` tool with your final output for the user.\";\n+\n+pub struct FinalOutputTool {\n+    pub response: Response,\n+    /// The final output collected for the user. It will be a single line string for easy script extraction from output.\n+    pub final_output: Option<String>,\n+}\n+\n+impl FinalOutputTool {\n+    pub fn new(response: Response) -> Self {\n+        if response.json_schema.is_none() {\n+            panic!(\"Cannot create FinalOutputTool: json_schema is required\");\n+        }\n+        let schema = response.json_schema.as_ref().unwrap();\n+\n+        if let Some(obj) = schema.as_object() {\n+            if obj.is_empty() {\n+                panic!(\"Cannot create FinalOutputTool: empty json_schema is not allowed\");\n+            }\n+        }\n+\n+        jsonschema::meta::validate(schema).unwrap();\n+        Self {\n+            response,\n+            final_output: None,\n+        }\n+    }\n+\n+    pub fn tool(&self) -> Tool {\n+        let instructions = formatdoc! {r#\"\n+            This tool collects the final output for a user and provides validation for structured JSON final output against a predefined schema.\n+\n+            This tool MUST be used for the final output to the user.\n+            \n+            Purpose:\n+            - Collects the final output for a user\n+            - Ensures that final outputs conform to the expected JSON structure\n+            - Provides clear validation feedback when outputs don't match the schema\n+            \n+            Usage:\n+            - Call the `final_output` tool with your JSON final output\n+            \n+            The expected JSON schema format is:\n+\n+            {}\n+            \n+            When validation fails, you'll receive:\n+            - Specific validation errors\n+            - The expected format\n+        \"#, serde_json::to_string_pretty(self.response.json_schema.as_ref().unwrap()).unwrap()};\n+\n+        Tool::new(\n+            FINAL_OUTPUT_TOOL_NAME.to_string(),\n+            instructions,\n+            json!({\n+                \"type\": \"object\",\n+                \"properties\": {\n+                    \"final_output\": {\n+                        \"type\": \"string\",\n+                        \"description\": \"The JSON string final output to validate and collect\"\n+                    }\n+                },\n+                \"required\": [\"final_output\"]\n+            }),",
        "comment_created_at": "2025-07-01T16:58:41+00:00",
        "comment_author": "DOsinga",
        "comment_body": "couldn't we just insert the json schema at this point? asking the llm to do it in this format probably works, but since the tool takes a json schema, why not use that?",
        "pr_file_module": null
      },
      {
        "comment_id": "2178820715",
        "repo_full_name": "block/goose",
        "pr_number": 3188,
        "pr_file": "crates/goose/src/agents/final_output_tool.rs",
        "discussion_id": "2178101251",
        "commented_code": "@@ -0,0 +1,468 @@\n+use crate::agents::tool_execution::ToolCallResult;\n+use crate::recipe::Response;\n+use indoc::formatdoc;\n+use mcp_core::{\n+    tool::{Tool, ToolAnnotations},\n+    Content, ToolCall, ToolError,\n+};\n+use serde_json::{json, Value};\n+\n+pub const FINAL_OUTPUT_TOOL_NAME: &str = \"final_output\";\n+pub const FINAL_OUTPUT_CONTINUATION_MESSAGE: &str =\n+    \"You MUST call the `final_output` tool with your final output for the user.\";\n+\n+pub struct FinalOutputTool {\n+    pub response: Response,\n+    /// The final output collected for the user. It will be a single line string for easy script extraction from output.\n+    pub final_output: Option<String>,\n+}\n+\n+impl FinalOutputTool {\n+    pub fn new(response: Response) -> Self {\n+        if response.json_schema.is_none() {\n+            panic!(\"Cannot create FinalOutputTool: json_schema is required\");\n+        }\n+        let schema = response.json_schema.as_ref().unwrap();\n+\n+        if let Some(obj) = schema.as_object() {\n+            if obj.is_empty() {\n+                panic!(\"Cannot create FinalOutputTool: empty json_schema is not allowed\");\n+            }\n+        }\n+\n+        jsonschema::meta::validate(schema).unwrap();\n+        Self {\n+            response,\n+            final_output: None,\n+        }\n+    }\n+\n+    pub fn tool(&self) -> Tool {\n+        let instructions = formatdoc! {r#\"\n+            This tool collects the final output for a user and provides validation for structured JSON final output against a predefined schema.\n+\n+            This tool MUST be used for the final output to the user.\n+            \n+            Purpose:\n+            - Collects the final output for a user\n+            - Ensures that final outputs conform to the expected JSON structure\n+            - Provides clear validation feedback when outputs don't match the schema\n+            \n+            Usage:\n+            - Call the `final_output` tool with your JSON final output\n+            \n+            The expected JSON schema format is:\n+\n+            {}\n+            \n+            When validation fails, you'll receive:\n+            - Specific validation errors\n+            - The expected format\n+        \"#, serde_json::to_string_pretty(self.response.json_schema.as_ref().unwrap()).unwrap()};\n+\n+        Tool::new(\n+            FINAL_OUTPUT_TOOL_NAME.to_string(),\n+            instructions,\n+            json!({\n+                \"type\": \"object\",\n+                \"properties\": {\n+                    \"final_output\": {\n+                        \"type\": \"string\",\n+                        \"description\": \"The JSON string final output to validate and collect\"\n+                    }\n+                },\n+                \"required\": [\"final_output\"]\n+            }),",
        "comment_created_at": "2025-07-02T01:48:32+00:00",
        "comment_author": "jsibbison-square",
        "comment_body": "\ud83d\udd25 Very nice, that cleans up the code a bit too.",
        "pr_file_module": null
      }
    ]
  }
]