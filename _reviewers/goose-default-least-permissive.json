[
  {
    "discussion_id": "2297925839",
    "pr_number": 4216,
    "pr_file": "crates/goose-server/src/routes/agent.rs",
    "created_at": "2025-08-25T12:06:49+00:00",
    "commented_code": "pub struct UpdateProviderRequest {\n     provider: String,\n     model: Option<String>,\n+    #[allow(dead_code)]\n+    session_id: String,\n }\n \n #[derive(Deserialize, utoipa::ToSchema)]\n pub struct SessionConfigRequest {\n     response: Option<Response>,\n+    #[allow(dead_code)]\n+    session_id: String,\n }\n \n #[derive(Deserialize, utoipa::ToSchema)]\n pub struct GetToolsQuery {\n     extension_name: Option<String>,\n+    #[allow(dead_code)]\n+    session_id: String,\n+}\n+\n+#[derive(Deserialize, utoipa::ToSchema)]\n+pub struct UpdateRouterToolSelectorRequest {\n+    #[allow(dead_code)]\n+    session_id: String,\n+}\n+\n+#[derive(Deserialize, utoipa::ToSchema)]\n+pub struct StartAgentRequest {\n+    working_dir: String,\n+}\n+\n+#[derive(Deserialize, utoipa::ToSchema)]\n+pub struct ResumeAgentRequest {\n+    session_id: String,\n+}\n+\n+// This is the same as SessionHistoryResponse\n+#[derive(Serialize, utoipa::ToSchema)]\n+pub struct StartAgentResponse {\n+    session_id: String,\n+    metadata: SessionMetadata,\n+    messages: Vec<Message>,\n }\n \n #[derive(Serialize, utoipa::ToSchema)]\n pub struct ErrorResponse {\n     error: String,\n }\n \n+#[utoipa::path(\n+    post,\n+    path = \"/agent/start\",\n+    request_body = StartAgentRequest,\n+    responses(\n+        (status = 200, description = \"Agent started successfully\", body = StartAgentResponse),\n+        (status = 400, description = \"Bad request - invalid working directory\"),\n+        (status = 401, description = \"Unauthorized - invalid secret key\"),\n+        (status = 500, description = \"Internal server error\")\n+    )\n+)]\n+async fn start_agent(\n+    State(state): State<Arc<AppState>>,\n+    headers: HeaderMap,\n+    Json(payload): Json<StartAgentRequest>,\n+) -> Result<Json<StartAgentResponse>, (StatusCode, Json<ErrorResponse>)> {\n+    verify_secret_key(&headers, &state).map_err(|_| {\n+        (\n+            StatusCode::UNAUTHORIZED,\n+            Json(ErrorResponse {\n+                error: \"Unauthorized - Invalid or missing API key\".to_string(),\n+            }),\n+        )\n+    })?;",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2297925839",
        "repo_full_name": "block/goose",
        "pr_number": 4216,
        "pr_file": "crates/goose-server/src/routes/agent.rs",
        "discussion_id": "2297925839",
        "commented_code": "@@ -42,23 +55,144 @@ pub struct AddSubRecipesResponse {\n pub struct UpdateProviderRequest {\n     provider: String,\n     model: Option<String>,\n+    #[allow(dead_code)]\n+    session_id: String,\n }\n \n #[derive(Deserialize, utoipa::ToSchema)]\n pub struct SessionConfigRequest {\n     response: Option<Response>,\n+    #[allow(dead_code)]\n+    session_id: String,\n }\n \n #[derive(Deserialize, utoipa::ToSchema)]\n pub struct GetToolsQuery {\n     extension_name: Option<String>,\n+    #[allow(dead_code)]\n+    session_id: String,\n+}\n+\n+#[derive(Deserialize, utoipa::ToSchema)]\n+pub struct UpdateRouterToolSelectorRequest {\n+    #[allow(dead_code)]\n+    session_id: String,\n+}\n+\n+#[derive(Deserialize, utoipa::ToSchema)]\n+pub struct StartAgentRequest {\n+    working_dir: String,\n+}\n+\n+#[derive(Deserialize, utoipa::ToSchema)]\n+pub struct ResumeAgentRequest {\n+    session_id: String,\n+}\n+\n+// This is the same as SessionHistoryResponse\n+#[derive(Serialize, utoipa::ToSchema)]\n+pub struct StartAgentResponse {\n+    session_id: String,\n+    metadata: SessionMetadata,\n+    messages: Vec<Message>,\n }\n \n #[derive(Serialize, utoipa::ToSchema)]\n pub struct ErrorResponse {\n     error: String,\n }\n \n+#[utoipa::path(\n+    post,\n+    path = \"/agent/start\",\n+    request_body = StartAgentRequest,\n+    responses(\n+        (status = 200, description = \"Agent started successfully\", body = StartAgentResponse),\n+        (status = 400, description = \"Bad request - invalid working directory\"),\n+        (status = 401, description = \"Unauthorized - invalid secret key\"),\n+        (status = 500, description = \"Internal server error\")\n+    )\n+)]\n+async fn start_agent(\n+    State(state): State<Arc<AppState>>,\n+    headers: HeaderMap,\n+    Json(payload): Json<StartAgentRequest>,\n+) -> Result<Json<StartAgentResponse>, (StatusCode, Json<ErrorResponse>)> {\n+    verify_secret_key(&headers, &state).map_err(|_| {\n+        (\n+            StatusCode::UNAUTHORIZED,\n+            Json(ErrorResponse {\n+                error: \"Unauthorized - Invalid or missing API key\".to_string(),\n+            }),\n+        )\n+    })?;",
        "comment_created_at": "2025-08-25T12:06:49+00:00",
        "comment_author": "jamadeo",
        "comment_body": "do we use verify_secret_key on all handlers? we should use [middleware](https://docs.rs/axum/latest/axum/middleware/index.html) for that if we can",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2292378506",
    "pr_number": 4237,
    "pr_file": "crates/goose-cli/src/session/mod.rs",
    "created_at": "2025-08-21T23:59:35+00:00",
    "commented_code": "if let Some(MessageContent::ToolConfirmationRequest(confirmation)) = message.content.first() {\n                                 output::hide_thinking();\n \n+                                // Display security message if present\n+                                if let Some(security_message) = &confirmation.prompt {\n+                                    println!(\"\n{}\", security_message);\n+                                }\n+\n                                 // Format the confirmation prompt\n                                 let prompt = \"Goose would like to call the above tool, do you allow?\".to_string();\n \n                                 // Get confirmation from user\n                                 let permission_result = cliclack::select(prompt)\n-                                    .item(Permission::AllowOnce, \"Allow\", \"Allow the tool call once\")\n-                                    .item(Permission::AlwaysAllow, \"Always Allow\", \"Always allow the tool call\")",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2292378506",
        "repo_full_name": "block/goose",
        "pr_number": 4237,
        "pr_file": "crates/goose-cli/src/session/mod.rs",
        "discussion_id": "2292378506",
        "commented_code": "@@ -908,13 +908,17 @@ impl Session {\n                             if let Some(MessageContent::ToolConfirmationRequest(confirmation)) = message.content.first() {\n                                 output::hide_thinking();\n \n+                                // Display security message if present\n+                                if let Some(security_message) = &confirmation.prompt {\n+                                    println!(\"\\n{}\", security_message);\n+                                }\n+\n                                 // Format the confirmation prompt\n                                 let prompt = \"Goose would like to call the above tool, do you allow?\".to_string();\n \n                                 // Get confirmation from user\n                                 let permission_result = cliclack::select(prompt)\n-                                    .item(Permission::AllowOnce, \"Allow\", \"Allow the tool call once\")\n-                                    .item(Permission::AlwaysAllow, \"Always Allow\", \"Always allow the tool call\")",
        "comment_created_at": "2025-08-21T23:59:35+00:00",
        "comment_author": "DOsinga",
        "comment_body": "did you mean to delete this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2292410072",
        "repo_full_name": "block/goose",
        "pr_number": 4237,
        "pr_file": "crates/goose-cli/src/session/mod.rs",
        "discussion_id": "2292378506",
        "commented_code": "@@ -908,13 +908,17 @@ impl Session {\n                             if let Some(MessageContent::ToolConfirmationRequest(confirmation)) = message.content.first() {\n                                 output::hide_thinking();\n \n+                                // Display security message if present\n+                                if let Some(security_message) = &confirmation.prompt {\n+                                    println!(\"\\n{}\", security_message);\n+                                }\n+\n                                 // Format the confirmation prompt\n                                 let prompt = \"Goose would like to call the above tool, do you allow?\".to_string();\n \n                                 // Get confirmation from user\n                                 let permission_result = cliclack::select(prompt)\n-                                    .item(Permission::AllowOnce, \"Allow\", \"Allow the tool call once\")\n-                                    .item(Permission::AlwaysAllow, \"Always Allow\", \"Always allow the tool call\")",
        "comment_created_at": "2025-08-22T00:25:48+00:00",
        "comment_author": "dorien-koelemeijer",
        "comment_body": "We want to make sure users can't always allow a tool call. I wasn't entirely sure whether you had mentioned to take it away entirely, or if we just want to take away that option for these security findings. Let me know what you think the better way is. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2292666603",
        "repo_full_name": "block/goose",
        "pr_number": 4237,
        "pr_file": "crates/goose-cli/src/session/mod.rs",
        "discussion_id": "2292378506",
        "commented_code": "@@ -908,13 +908,17 @@ impl Session {\n                             if let Some(MessageContent::ToolConfirmationRequest(confirmation)) = message.content.first() {\n                                 output::hide_thinking();\n \n+                                // Display security message if present\n+                                if let Some(security_message) = &confirmation.prompt {\n+                                    println!(\"\\n{}\", security_message);\n+                                }\n+\n                                 // Format the confirmation prompt\n                                 let prompt = \"Goose would like to call the above tool, do you allow?\".to_string();\n \n                                 // Get confirmation from user\n                                 let permission_result = cliclack::select(prompt)\n-                                    .item(Permission::AllowOnce, \"Allow\", \"Allow the tool call once\")\n-                                    .item(Permission::AlwaysAllow, \"Always Allow\", \"Always allow the tool call\")",
        "comment_created_at": "2025-08-22T04:34:25+00:00",
        "comment_author": "michaelneale",
        "comment_body": "I think we want to leave that in, as it is a common mode ",
        "pr_file_module": null
      },
      {
        "comment_id": "2292766833",
        "repo_full_name": "block/goose",
        "pr_number": 4237,
        "pr_file": "crates/goose-cli/src/session/mod.rs",
        "discussion_id": "2292378506",
        "commented_code": "@@ -908,13 +908,17 @@ impl Session {\n                             if let Some(MessageContent::ToolConfirmationRequest(confirmation)) = message.content.first() {\n                                 output::hide_thinking();\n \n+                                // Display security message if present\n+                                if let Some(security_message) = &confirmation.prompt {\n+                                    println!(\"\\n{}\", security_message);\n+                                }\n+\n                                 // Format the confirmation prompt\n                                 let prompt = \"Goose would like to call the above tool, do you allow?\".to_string();\n \n                                 // Get confirmation from user\n                                 let permission_result = cliclack::select(prompt)\n-                                    .item(Permission::AllowOnce, \"Allow\", \"Allow the tool call once\")\n-                                    .item(Permission::AlwaysAllow, \"Always Allow\", \"Always allow the tool call\")",
        "comment_created_at": "2025-08-22T05:52:46+00:00",
        "comment_author": "dorien-koelemeijer",
        "comment_body": "Will revert these changes, thanks for clarifying",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2276971519",
    "pr_number": 4021,
    "pr_file": "crates/goose/src/agents/agent.rs",
    "created_at": "2025-08-14T15:29:30+00:00",
    "commented_code": ");\n                                     }\n                                 } else {\n+                                    // Check if we need to show model download status before security scanning\n+                                    if let Some(download_message) = self.security_manager.check_model_download_status().await {\n+                                        yield AgentEvent::Message(Message::assistant().with_text(download_message));\n+                                    }\n+\n+                                    // SECURITY FIX: Scan tools for prompt injection BEFORE permission checking",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2276971519",
        "repo_full_name": "block/goose",
        "pr_number": 4021,
        "pr_file": "crates/goose/src/agents/agent.rs",
        "discussion_id": "2276971519",
        "commented_code": "@@ -1078,6 +1081,29 @@ impl Agent {\n                                         );\n                                     }\n                                 } else {\n+                                    // Check if we need to show model download status before security scanning\n+                                    if let Some(download_message) = self.security_manager.check_model_download_status().await {\n+                                        yield AgentEvent::Message(Message::assistant().with_text(download_message));\n+                                    }\n+\n+                                    // SECURITY FIX: Scan tools for prompt injection BEFORE permission checking",
        "comment_created_at": "2025-08-14T15:29:30+00:00",
        "comment_author": "DOsinga",
        "comment_body": "this is probably fine for testing, but we should refactor this so we have a generic way to check whether we want to run a tool that says yes/no/ask the user with prompt and then take the least permissive version of that, i.e. if the counter says no, don't even run the security thing if that makes sense",
        "pr_file_module": null
      }
    ]
  }
]