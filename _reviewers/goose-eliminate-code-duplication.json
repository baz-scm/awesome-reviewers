[
  {
    "discussion_id": "2265202908",
    "pr_number": 3824,
    "pr_file": "crates/goose-server/src/routes/config_management.rs",
    "created_at": "2025-08-10T09:38:07+00:00",
    "commented_code": ") -> Result<Json<Vec<ProviderDetails>>, StatusCode> {\n     verify_secret_key(&headers, &state)?;\n \n-    let providers_metadata = get_providers();\n+    let mut providers_metadata = get_providers();\n+\n+    let config_dir = etcetera::choose_app_strategy(goose::config::base::APP_STRATEGY.clone())",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2265202908",
        "repo_full_name": "block/goose",
        "pr_number": 3824,
        "pr_file": "crates/goose-server/src/routes/config_management.rs",
        "discussion_id": "2265202908",
        "commented_code": "@@ -306,7 +315,68 @@ pub async fn providers(\n ) -> Result<Json<Vec<ProviderDetails>>, StatusCode> {\n     verify_secret_key(&headers, &state)?;\n \n-    let providers_metadata = get_providers();\n+    let mut providers_metadata = get_providers();\n+\n+    let config_dir = etcetera::choose_app_strategy(goose::config::base::APP_STRATEGY.clone())",
        "comment_created_at": "2025-08-10T09:38:07+00:00",
        "comment_author": "DOsinga",
        "comment_body": "So I think here and it in the other handle, it would be better I think to move the work to custom_provider.rs, keep the routes light and have:\r\n\r\n`let custom_providers_dir = config_dir.join(\"custom_providers\");`\r\n\r\nappear only once type of thing. we can do this in a follow up though",
        "pr_file_module": null
      },
      {
        "comment_id": "2265413622",
        "repo_full_name": "block/goose",
        "pr_number": 3824,
        "pr_file": "crates/goose-server/src/routes/config_management.rs",
        "discussion_id": "2265202908",
        "commented_code": "@@ -306,7 +315,68 @@ pub async fn providers(\n ) -> Result<Json<Vec<ProviderDetails>>, StatusCode> {\n     verify_secret_key(&headers, &state)?;\n \n-    let providers_metadata = get_providers();\n+    let mut providers_metadata = get_providers();\n+\n+    let config_dir = etcetera::choose_app_strategy(goose::config::base::APP_STRATEGY.clone())",
        "comment_created_at": "2025-08-10T19:37:10+00:00",
        "comment_author": "Developerayo",
        "comment_body": "Ah! yes, agreed, will move the work to `custom_providers.rs`, better to do in this",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288346516",
    "pr_number": 2799,
    "pr_file": "crates/goose/src/providers/api_client.rs",
    "created_at": "2025-08-20T14:20:55+00:00",
    "commented_code": "}\n \n     pub fn with_timeout(host: String, auth: AuthMethod, timeout: Duration) -> Result<Self> {\n+        let mut client_builder = Client::builder().timeout(timeout);\n+\n+        // Automatically configure TLS if TLS configuration is present\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            if tls_config.is_configured() {\n+                // Load client identity (certificate + private key)\n+                if let Some(identity) = tls_config.load_identity()? {\n+                    client_builder = client_builder.identity(identity);\n+                }\n+\n+                // Load CA certificates\n+                let ca_certs = tls_config.load_ca_certificates()?;\n+                for ca_cert in ca_certs {\n+                    client_builder = client_builder.add_root_certificate(ca_cert);\n+                }\n+            }\n+        }\n+\n+        let client = client_builder.build()?;\n+\n         Ok(Self {\n-            client: Client::builder().timeout(timeout).build()?,\n+            client,\n             host,\n             auth,\n             default_headers: HeaderMap::new(),\n             timeout,\n+            tls_config: TlsConfig::from_config()?,\n         })\n     }\n \n+    fn rebuild_client(&mut self) -> Result<()> {\n+        let mut client_builder = Client::builder()\n+            .timeout(self.timeout)\n+            .default_headers(self.default_headers.clone());\n+\n+        // Configure TLS if specified\n+        if let Some(tls_config) = &self.tls_config {\n+            if tls_config.is_configured() {\n+                // Load client identity (certificate + private key)\n+                if let Some(identity) = tls_config.load_identity()? {\n+                    client_builder = client_builder.identity(identity);\n+                }\n+\n+                // Load CA certificates\n+                let ca_certs = tls_config.load_ca_certificates()?;\n+                for ca_cert in ca_certs {\n+                    client_builder = client_builder.add_root_certificate(ca_cert);\n+                }\n+            }\n+        }",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2288346516",
        "repo_full_name": "block/goose",
        "pr_number": 2799,
        "pr_file": "crates/goose/src/providers/api_client.rs",
        "discussion_id": "2288346516",
        "commented_code": "@@ -79,32 +195,72 @@ impl ApiClient {\n     }\n \n     pub fn with_timeout(host: String, auth: AuthMethod, timeout: Duration) -> Result<Self> {\n+        let mut client_builder = Client::builder().timeout(timeout);\n+\n+        // Automatically configure TLS if TLS configuration is present\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            if tls_config.is_configured() {\n+                // Load client identity (certificate + private key)\n+                if let Some(identity) = tls_config.load_identity()? {\n+                    client_builder = client_builder.identity(identity);\n+                }\n+\n+                // Load CA certificates\n+                let ca_certs = tls_config.load_ca_certificates()?;\n+                for ca_cert in ca_certs {\n+                    client_builder = client_builder.add_root_certificate(ca_cert);\n+                }\n+            }\n+        }\n+\n+        let client = client_builder.build()?;\n+\n         Ok(Self {\n-            client: Client::builder().timeout(timeout).build()?,\n+            client,\n             host,\n             auth,\n             default_headers: HeaderMap::new(),\n             timeout,\n+            tls_config: TlsConfig::from_config()?,\n         })\n     }\n \n+    fn rebuild_client(&mut self) -> Result<()> {\n+        let mut client_builder = Client::builder()\n+            .timeout(self.timeout)\n+            .default_headers(self.default_headers.clone());\n+\n+        // Configure TLS if specified\n+        if let Some(tls_config) = &self.tls_config {\n+            if tls_config.is_configured() {\n+                // Load client identity (certificate + private key)\n+                if let Some(identity) = tls_config.load_identity()? {\n+                    client_builder = client_builder.identity(identity);\n+                }\n+\n+                // Load CA certificates\n+                let ca_certs = tls_config.load_ca_certificates()?;\n+                for ca_cert in ca_certs {\n+                    client_builder = client_builder.add_root_certificate(ca_cert);\n+                }\n+            }\n+        }",
        "comment_created_at": "2025-08-20T14:20:55+00:00",
        "comment_author": "jamadeo",
        "comment_body": "this is almost the same as the one in with_timeout - consider extracting that?",
        "pr_file_module": null
      },
      {
        "comment_id": "2289038615",
        "repo_full_name": "block/goose",
        "pr_number": 2799,
        "pr_file": "crates/goose/src/providers/api_client.rs",
        "discussion_id": "2288346516",
        "commented_code": "@@ -79,32 +195,72 @@ impl ApiClient {\n     }\n \n     pub fn with_timeout(host: String, auth: AuthMethod, timeout: Duration) -> Result<Self> {\n+        let mut client_builder = Client::builder().timeout(timeout);\n+\n+        // Automatically configure TLS if TLS configuration is present\n+        if let Some(tls_config) = TlsConfig::from_config()? {\n+            if tls_config.is_configured() {\n+                // Load client identity (certificate + private key)\n+                if let Some(identity) = tls_config.load_identity()? {\n+                    client_builder = client_builder.identity(identity);\n+                }\n+\n+                // Load CA certificates\n+                let ca_certs = tls_config.load_ca_certificates()?;\n+                for ca_cert in ca_certs {\n+                    client_builder = client_builder.add_root_certificate(ca_cert);\n+                }\n+            }\n+        }\n+\n+        let client = client_builder.build()?;\n+\n         Ok(Self {\n-            client: Client::builder().timeout(timeout).build()?,\n+            client,\n             host,\n             auth,\n             default_headers: HeaderMap::new(),\n             timeout,\n+            tls_config: TlsConfig::from_config()?,\n         })\n     }\n \n+    fn rebuild_client(&mut self) -> Result<()> {\n+        let mut client_builder = Client::builder()\n+            .timeout(self.timeout)\n+            .default_headers(self.default_headers.clone());\n+\n+        // Configure TLS if specified\n+        if let Some(tls_config) = &self.tls_config {\n+            if tls_config.is_configured() {\n+                // Load client identity (certificate + private key)\n+                if let Some(identity) = tls_config.load_identity()? {\n+                    client_builder = client_builder.identity(identity);\n+                }\n+\n+                // Load CA certificates\n+                let ca_certs = tls_config.load_ca_certificates()?;\n+                for ca_cert in ca_certs {\n+                    client_builder = client_builder.add_root_certificate(ca_cert);\n+                }\n+            }\n+        }",
        "comment_created_at": "2025-08-20T19:03:12+00:00",
        "comment_author": "myaple",
        "comment_body": "extracted to a private function ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2254076011",
    "pr_number": 3085,
    "pr_file": "crates/goose-mcp/src/developer/mod.rs",
    "created_at": "2025-08-05T11:35:59+00:00",
    "commented_code": "// - macOS/Linux: ~/.config/goose/\n         // - Windows:     ~\\AppData\\Roaming\\Block\\goose\\config\\\n         // keep previous behavior of expanding ~/.config in case this fails\n-        let global_hints_path = choose_app_strategy(crate::APP_STRATEGY.clone())\n-            .map(|strategy| strategy.in_config_dir(\".goosehints\"))\n-            .unwrap_or_else(|_| {\n-                PathBuf::from(shellexpand::tilde(\"~/.config/goose/.goosehints\").to_string())\n-            });\n+        let get_global_path = |filename: &str| -> PathBuf {\n+            choose_app_strategy(crate::APP_STRATEGY.clone())\n+                .map(|strategy| strategy.in_config_dir(filename))\n+                .unwrap_or_else(|_| {\n+                    PathBuf::from(shellexpand::tilde(&format!(\"~/.config/goose/{}\", filename)).to_string())\n+                })\n+        };\n \n         // Create the directory if it doesn't exist\n-        let _ = std::fs::create_dir_all(global_hints_path.parent().unwrap());\n-\n-        // Check for local hints in current directory\n-        let local_hints_path = cwd.join(\".goosehints\");\n+        let config_dir = get_global_path(\".goosehints\").parent().unwrap().to_path_buf();\n+        let _ = std::fs::create_dir_all(&config_dir);\n+\n+        // Define hint files to check: (filename, global_header, local_header)\n+        let hint_files = [\n+            (\".goosehints\", \n+             \"### Global Hints\nThe developer extension includes some global hints that apply to all projects & directories.\n\",\n+             \"### Project Hints\nThe developer extension includes some hints for working on the project in this directory.\n\"),\n+            (\"GOOSE.md\", \n+             \"### Global GOOSE.md\nThe developer extension includes global documentation from GOOSE.md that applies to all projects & directories.\n\",\n+             \"### Project GOOSE.md\nThe developer extension includes project documentation from GOOSE.md for working on the project in this directory.\n\"),\n+        ];\n \n-        // Read global hints if they exist\n         let mut hints = String::new();\n-        if global_hints_path.is_file() {\n-            if let Ok(global_hints) = std::fs::read_to_string(&global_hints_path) {\n-                hints.push_str(\"\n### Global Hints\nThe developer extension includes some global hints that apply to all projects & directories.\n\");\n-                hints.push_str(&global_hints);\n+\n+        // Process each hint file type\n+        for (filename, global_header, local_header) in hint_files.iter() {\n+            // Check global file",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2254076011",
        "repo_full_name": "block/goose",
        "pr_number": 3085,
        "pr_file": "crates/goose-mcp/src/developer/mod.rs",
        "discussion_id": "2254076011",
        "commented_code": "@@ -372,35 +372,56 @@ impl DeveloperRouter {\n         // - macOS/Linux: ~/.config/goose/\n         // - Windows:     ~\\AppData\\Roaming\\Block\\goose\\config\\\n         // keep previous behavior of expanding ~/.config in case this fails\n-        let global_hints_path = choose_app_strategy(crate::APP_STRATEGY.clone())\n-            .map(|strategy| strategy.in_config_dir(\".goosehints\"))\n-            .unwrap_or_else(|_| {\n-                PathBuf::from(shellexpand::tilde(\"~/.config/goose/.goosehints\").to_string())\n-            });\n+        let get_global_path = |filename: &str| -> PathBuf {\n+            choose_app_strategy(crate::APP_STRATEGY.clone())\n+                .map(|strategy| strategy.in_config_dir(filename))\n+                .unwrap_or_else(|_| {\n+                    PathBuf::from(shellexpand::tilde(&format!(\"~/.config/goose/{}\", filename)).to_string())\n+                })\n+        };\n \n         // Create the directory if it doesn't exist\n-        let _ = std::fs::create_dir_all(global_hints_path.parent().unwrap());\n-\n-        // Check for local hints in current directory\n-        let local_hints_path = cwd.join(\".goosehints\");\n+        let config_dir = get_global_path(\".goosehints\").parent().unwrap().to_path_buf();\n+        let _ = std::fs::create_dir_all(&config_dir);\n+\n+        // Define hint files to check: (filename, global_header, local_header)\n+        let hint_files = [\n+            (\".goosehints\", \n+             \"### Global Hints\\nThe developer extension includes some global hints that apply to all projects & directories.\\n\",\n+             \"### Project Hints\\nThe developer extension includes some hints for working on the project in this directory.\\n\"),\n+            (\"GOOSE.md\", \n+             \"### Global GOOSE.md\\nThe developer extension includes global documentation from GOOSE.md that applies to all projects & directories.\\n\",\n+             \"### Project GOOSE.md\\nThe developer extension includes project documentation from GOOSE.md for working on the project in this directory.\\n\"),\n+        ];\n \n-        // Read global hints if they exist\n         let mut hints = String::new();\n-        if global_hints_path.is_file() {\n-            if let Ok(global_hints) = std::fs::read_to_string(&global_hints_path) {\n-                hints.push_str(\"\\n### Global Hints\\nThe developer extension includes some global hints that apply to all projects & directories.\\n\");\n-                hints.push_str(&global_hints);\n+\n+        // Process each hint file type\n+        for (filename, global_header, local_header) in hint_files.iter() {\n+            // Check global file",
        "comment_created_at": "2025-08-05T11:35:59+00:00",
        "comment_author": "DOsinga",
        "comment_body": "can we avoid the duplication here by just having another loop over (global_path, global_header) (local_path, local_header)?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2279699633",
    "pr_number": 4080,
    "pr_file": "crates/goose/src/recipe/mod.rs",
    "created_at": "2025-08-15T19:01:37+00:00",
    "commented_code": "}\n \n impl Recipe {\n+    /// Returns true if harmful content is detected in instructions, prompt, or activities fields\n+    pub fn check_for_security_warnings(&self) -> bool {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2279699633",
        "repo_full_name": "block/goose",
        "pr_number": 4080,
        "pr_file": "crates/goose/src/recipe/mod.rs",
        "discussion_id": "2279699633",
        "commented_code": "@@ -253,6 +254,34 @@ pub struct RecipeBuilder {\n }\n \n impl Recipe {\n+    /// Returns true if harmful content is detected in instructions, prompt, or activities fields\n+    pub fn check_for_security_warnings(&self) -> bool {",
        "comment_created_at": "2025-08-15T19:01:37+00:00",
        "comment_author": "DOsinga",
        "comment_body": "you can just loop through all the fields instead of repeating the code",
        "pr_file_module": null
      },
      {
        "comment_id": "2279946816",
        "repo_full_name": "block/goose",
        "pr_number": 4080,
        "pr_file": "crates/goose/src/recipe/mod.rs",
        "discussion_id": "2279699633",
        "commented_code": "@@ -253,6 +254,34 @@ pub struct RecipeBuilder {\n }\n \n impl Recipe {\n+    /// Returns true if harmful content is detected in instructions, prompt, or activities fields\n+    pub fn check_for_security_warnings(&self) -> bool {",
        "comment_created_at": "2025-08-15T21:53:54+00:00",
        "comment_author": "amed-xyz",
        "comment_body": "good point, done!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2253511566",
    "pr_number": 3767,
    "pr_file": "crates/goose-mcp/src/developer/mod.rs",
    "created_at": "2025-08-05T08:12:52+00:00",
    "commented_code": "}\n     }\n \n+    // Helper method to validate and calculate view range indices\n+    fn calculate_view_range(\n+        &self,\n+        view_range: Option<(usize, i64)>,\n+        total_lines: usize,\n+    ) -> Result<(usize, usize), ToolError> {\n+        if let Some((start_line, end_line)) = view_range {\n+            // Convert 1-indexed line numbers to 0-indexed\n+            let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n+            let end_idx = if end_line == -1 {\n+                total_lines\n+            } else {\n+                std::cmp::min(end_line as usize, total_lines)\n+            };\n+\n+            if start_idx >= total_lines {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} is beyond the end of the file (total lines: {})\",\n+                    start_line, total_lines\n+                )));\n+            }\n+\n+            if start_idx >= end_idx {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} must be less than end line {}\",\n+                    start_line, end_line\n+                )));\n+            }\n+\n+            Ok((start_idx, end_idx))\n+        } else {\n+            Ok((0, total_lines))\n+        }\n+    }\n+\n+    // Helper method to format file content with line numbers\n+    fn format_file_content(\n+        &self,\n+        path: &Path,\n+        lines: &[&str],\n+        start_idx: usize,\n+        end_idx: usize,\n+        view_range: Option<(usize, i64)>,\n+    ) -> String {\n+        let display_content = if lines.is_empty() {\n+            String::new()\n+        } else {\n+            let selected_lines: Vec<String> = lines[start_idx..end_idx]\n+                .iter()\n+                .enumerate()\n+                .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n+                .collect();\n+\n+            selected_lines.join(\"\n\")\n+        };\n+\n+        let language = lang::get_language_identifier(path);\n+        if view_range.is_some() {\n+            formatdoc! {\"\n+                ### {path} (lines {start}-{end})\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                start=view_range.unwrap().0,\n+                end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n+                language=language,\n+                content=display_content,\n+            }\n+        } else {\n+            formatdoc! {\"\n+                ### {path}\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                language=language,\n+                content=display_content,\n+            }\n+        }\n+    }\n+\n     async fn text_editor_view(\n         &self,\n         path: &PathBuf,\n         view_range: Option<(usize, i64)>,\n     ) -> Result<Vec<Content>, ToolError> {\n-        if path.is_file() {\n-            // Check file size first (400KB limit)\n-            const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n+        if !path.is_file() {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"The path '{}' does not exist or is not a file.\",\n+                path.display()\n+            )));\n+        }\n \n-            let f = File::open(path)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n+        // Check file size first (400KB limit)\n+        const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n \n-            let file_size = f\n-                .metadata()\n-                .map_err(|e| {\n-                    ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e))\n-                })?\n-                .len();\n+        let f = File::open(path)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n \n-            if file_size > MAX_FILE_SIZE {\n-                return Err(ToolError::ExecutionError(format!(\n-                    \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n-                    path.display(),\n-                    file_size as f64 / 1024.0\n-                )));\n-            }\n-            // Ensure we never read over that limit even if the file is being concurrently mutated\n-            // (e.g. it's a log file)\n-            let mut f = f.take(MAX_FILE_SIZE);\n-\n-            let uri = Url::from_file_path(path)\n-                .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n-                .to_string();\n-\n-            let mut content = String::new();\n-            f.read_to_string(&mut content)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n-\n-            let lines: Vec<&str> = content.lines().collect();\n-            let total_lines = lines.len();\n-\n-            // Handle view_range if provided, otherwise show all lines\n-            let (start_idx, end_idx) = if let Some((start_line, end_line)) = view_range {\n-                // Convert 1-indexed line numbers to 0-indexed\n-                let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n-                let end_idx = if end_line == -1 {\n-                    total_lines\n-                } else {\n-                    std::cmp::min(end_line as usize, total_lines)\n-                };\n-\n-                if start_idx >= total_lines {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} is beyond the end of the file (total lines: {})\",\n-                        start_line, total_lines\n-                    )));\n-                }\n+        let file_size = f\n+            .metadata()\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e)))?\n+            .len();\n \n-                if start_idx >= end_idx {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} must be less than end line {}\",\n-                        start_line, end_line\n-                    )));\n-                }\n+        if file_size > MAX_FILE_SIZE {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n+                path.display(),\n+                file_size as f64 / 1024.0\n+            )));\n+        }\n \n-                (start_idx, end_idx)\n-            } else {\n-                (0, total_lines)\n-            };\n+        // Ensure we never read over that limit even if the file is being concurrently mutated\n+        let mut f = f.take(MAX_FILE_SIZE);\n \n-            // Always format lines with line numbers for better usability\n-            let display_content = if total_lines == 0 {\n-                String::new()\n-            } else {\n-                let selected_lines: Vec<String> = lines[start_idx..end_idx]\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n-                    .collect();\n+        let uri = Url::from_file_path(path)\n+            .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n+            .to_string();\n \n-                selected_lines.join(\"\n\")\n-            };\n+        let mut content = String::new();\n+        f.read_to_string(&mut content)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n \n-            let language = lang::get_language_identifier(path);\n-            let formatted = if view_range.is_some() {\n-                formatdoc! {\"\n-                    ### {path} (lines {start}-{end})\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    start=view_range.unwrap().0,\n-                    end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n-                    language=language,\n-                    content=display_content,\n-                }\n-            } else {\n-                formatdoc! {\"\n-                    ### {path}\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    language=language,\n-                    content=display_content,\n-                }\n-            };\n+        let lines: Vec<&str> = content.lines().collect();\n+        let total_lines = lines.len();",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2253511566",
        "repo_full_name": "block/goose",
        "pr_number": 3767,
        "pr_file": "crates/goose-mcp/src/developer/mod.rs",
        "discussion_id": "2253511566",
        "commented_code": "@@ -965,130 +966,152 @@ impl DeveloperRouter {\n         }\n     }\n \n+    // Helper method to validate and calculate view range indices\n+    fn calculate_view_range(\n+        &self,\n+        view_range: Option<(usize, i64)>,\n+        total_lines: usize,\n+    ) -> Result<(usize, usize), ToolError> {\n+        if let Some((start_line, end_line)) = view_range {\n+            // Convert 1-indexed line numbers to 0-indexed\n+            let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n+            let end_idx = if end_line == -1 {\n+                total_lines\n+            } else {\n+                std::cmp::min(end_line as usize, total_lines)\n+            };\n+\n+            if start_idx >= total_lines {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} is beyond the end of the file (total lines: {})\",\n+                    start_line, total_lines\n+                )));\n+            }\n+\n+            if start_idx >= end_idx {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} must be less than end line {}\",\n+                    start_line, end_line\n+                )));\n+            }\n+\n+            Ok((start_idx, end_idx))\n+        } else {\n+            Ok((0, total_lines))\n+        }\n+    }\n+\n+    // Helper method to format file content with line numbers\n+    fn format_file_content(\n+        &self,\n+        path: &Path,\n+        lines: &[&str],\n+        start_idx: usize,\n+        end_idx: usize,\n+        view_range: Option<(usize, i64)>,\n+    ) -> String {\n+        let display_content = if lines.is_empty() {\n+            String::new()\n+        } else {\n+            let selected_lines: Vec<String> = lines[start_idx..end_idx]\n+                .iter()\n+                .enumerate()\n+                .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n+                .collect();\n+\n+            selected_lines.join(\"\\n\")\n+        };\n+\n+        let language = lang::get_language_identifier(path);\n+        if view_range.is_some() {\n+            formatdoc! {\"\n+                ### {path} (lines {start}-{end})\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                start=view_range.unwrap().0,\n+                end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n+                language=language,\n+                content=display_content,\n+            }\n+        } else {\n+            formatdoc! {\"\n+                ### {path}\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                language=language,\n+                content=display_content,\n+            }\n+        }\n+    }\n+\n     async fn text_editor_view(\n         &self,\n         path: &PathBuf,\n         view_range: Option<(usize, i64)>,\n     ) -> Result<Vec<Content>, ToolError> {\n-        if path.is_file() {\n-            // Check file size first (400KB limit)\n-            const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n+        if !path.is_file() {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"The path '{}' does not exist or is not a file.\",\n+                path.display()\n+            )));\n+        }\n \n-            let f = File::open(path)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n+        // Check file size first (400KB limit)\n+        const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n \n-            let file_size = f\n-                .metadata()\n-                .map_err(|e| {\n-                    ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e))\n-                })?\n-                .len();\n+        let f = File::open(path)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n \n-            if file_size > MAX_FILE_SIZE {\n-                return Err(ToolError::ExecutionError(format!(\n-                    \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n-                    path.display(),\n-                    file_size as f64 / 1024.0\n-                )));\n-            }\n-            // Ensure we never read over that limit even if the file is being concurrently mutated\n-            // (e.g. it's a log file)\n-            let mut f = f.take(MAX_FILE_SIZE);\n-\n-            let uri = Url::from_file_path(path)\n-                .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n-                .to_string();\n-\n-            let mut content = String::new();\n-            f.read_to_string(&mut content)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n-\n-            let lines: Vec<&str> = content.lines().collect();\n-            let total_lines = lines.len();\n-\n-            // Handle view_range if provided, otherwise show all lines\n-            let (start_idx, end_idx) = if let Some((start_line, end_line)) = view_range {\n-                // Convert 1-indexed line numbers to 0-indexed\n-                let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n-                let end_idx = if end_line == -1 {\n-                    total_lines\n-                } else {\n-                    std::cmp::min(end_line as usize, total_lines)\n-                };\n-\n-                if start_idx >= total_lines {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} is beyond the end of the file (total lines: {})\",\n-                        start_line, total_lines\n-                    )));\n-                }\n+        let file_size = f\n+            .metadata()\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e)))?\n+            .len();\n \n-                if start_idx >= end_idx {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} must be less than end line {}\",\n-                        start_line, end_line\n-                    )));\n-                }\n+        if file_size > MAX_FILE_SIZE {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n+                path.display(),\n+                file_size as f64 / 1024.0\n+            )));\n+        }\n \n-                (start_idx, end_idx)\n-            } else {\n-                (0, total_lines)\n-            };\n+        // Ensure we never read over that limit even if the file is being concurrently mutated\n+        let mut f = f.take(MAX_FILE_SIZE);\n \n-            // Always format lines with line numbers for better usability\n-            let display_content = if total_lines == 0 {\n-                String::new()\n-            } else {\n-                let selected_lines: Vec<String> = lines[start_idx..end_idx]\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n-                    .collect();\n+        let uri = Url::from_file_path(path)\n+            .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n+            .to_string();\n \n-                selected_lines.join(\"\\n\")\n-            };\n+        let mut content = String::new();\n+        f.read_to_string(&mut content)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n \n-            let language = lang::get_language_identifier(path);\n-            let formatted = if view_range.is_some() {\n-                formatdoc! {\"\n-                    ### {path} (lines {start}-{end})\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    start=view_range.unwrap().0,\n-                    end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n-                    language=language,\n-                    content=display_content,\n-                }\n-            } else {\n-                formatdoc! {\"\n-                    ### {path}\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    language=language,\n-                    content=display_content,\n-                }\n-            };\n+        let lines: Vec<&str> = content.lines().collect();\n+        let total_lines = lines.len();",
        "comment_created_at": "2025-08-05T08:12:52+00:00",
        "comment_author": "DOsinga",
        "comment_body": "could be paranoid here and check the max line length of lines",
        "pr_file_module": null
      },
      {
        "comment_id": "2253518535",
        "repo_full_name": "block/goose",
        "pr_number": 3767,
        "pr_file": "crates/goose-mcp/src/developer/mod.rs",
        "discussion_id": "2253511566",
        "commented_code": "@@ -965,130 +966,152 @@ impl DeveloperRouter {\n         }\n     }\n \n+    // Helper method to validate and calculate view range indices\n+    fn calculate_view_range(\n+        &self,\n+        view_range: Option<(usize, i64)>,\n+        total_lines: usize,\n+    ) -> Result<(usize, usize), ToolError> {\n+        if let Some((start_line, end_line)) = view_range {\n+            // Convert 1-indexed line numbers to 0-indexed\n+            let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n+            let end_idx = if end_line == -1 {\n+                total_lines\n+            } else {\n+                std::cmp::min(end_line as usize, total_lines)\n+            };\n+\n+            if start_idx >= total_lines {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} is beyond the end of the file (total lines: {})\",\n+                    start_line, total_lines\n+                )));\n+            }\n+\n+            if start_idx >= end_idx {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} must be less than end line {}\",\n+                    start_line, end_line\n+                )));\n+            }\n+\n+            Ok((start_idx, end_idx))\n+        } else {\n+            Ok((0, total_lines))\n+        }\n+    }\n+\n+    // Helper method to format file content with line numbers\n+    fn format_file_content(\n+        &self,\n+        path: &Path,\n+        lines: &[&str],\n+        start_idx: usize,\n+        end_idx: usize,\n+        view_range: Option<(usize, i64)>,\n+    ) -> String {\n+        let display_content = if lines.is_empty() {\n+            String::new()\n+        } else {\n+            let selected_lines: Vec<String> = lines[start_idx..end_idx]\n+                .iter()\n+                .enumerate()\n+                .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n+                .collect();\n+\n+            selected_lines.join(\"\\n\")\n+        };\n+\n+        let language = lang::get_language_identifier(path);\n+        if view_range.is_some() {\n+            formatdoc! {\"\n+                ### {path} (lines {start}-{end})\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                start=view_range.unwrap().0,\n+                end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n+                language=language,\n+                content=display_content,\n+            }\n+        } else {\n+            formatdoc! {\"\n+                ### {path}\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                language=language,\n+                content=display_content,\n+            }\n+        }\n+    }\n+\n     async fn text_editor_view(\n         &self,\n         path: &PathBuf,\n         view_range: Option<(usize, i64)>,\n     ) -> Result<Vec<Content>, ToolError> {\n-        if path.is_file() {\n-            // Check file size first (400KB limit)\n-            const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n+        if !path.is_file() {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"The path '{}' does not exist or is not a file.\",\n+                path.display()\n+            )));\n+        }\n \n-            let f = File::open(path)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n+        // Check file size first (400KB limit)\n+        const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n \n-            let file_size = f\n-                .metadata()\n-                .map_err(|e| {\n-                    ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e))\n-                })?\n-                .len();\n+        let f = File::open(path)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n \n-            if file_size > MAX_FILE_SIZE {\n-                return Err(ToolError::ExecutionError(format!(\n-                    \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n-                    path.display(),\n-                    file_size as f64 / 1024.0\n-                )));\n-            }\n-            // Ensure we never read over that limit even if the file is being concurrently mutated\n-            // (e.g. it's a log file)\n-            let mut f = f.take(MAX_FILE_SIZE);\n-\n-            let uri = Url::from_file_path(path)\n-                .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n-                .to_string();\n-\n-            let mut content = String::new();\n-            f.read_to_string(&mut content)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n-\n-            let lines: Vec<&str> = content.lines().collect();\n-            let total_lines = lines.len();\n-\n-            // Handle view_range if provided, otherwise show all lines\n-            let (start_idx, end_idx) = if let Some((start_line, end_line)) = view_range {\n-                // Convert 1-indexed line numbers to 0-indexed\n-                let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n-                let end_idx = if end_line == -1 {\n-                    total_lines\n-                } else {\n-                    std::cmp::min(end_line as usize, total_lines)\n-                };\n-\n-                if start_idx >= total_lines {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} is beyond the end of the file (total lines: {})\",\n-                        start_line, total_lines\n-                    )));\n-                }\n+        let file_size = f\n+            .metadata()\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e)))?\n+            .len();\n \n-                if start_idx >= end_idx {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} must be less than end line {}\",\n-                        start_line, end_line\n-                    )));\n-                }\n+        if file_size > MAX_FILE_SIZE {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n+                path.display(),\n+                file_size as f64 / 1024.0\n+            )));\n+        }\n \n-                (start_idx, end_idx)\n-            } else {\n-                (0, total_lines)\n-            };\n+        // Ensure we never read over that limit even if the file is being concurrently mutated\n+        let mut f = f.take(MAX_FILE_SIZE);\n \n-            // Always format lines with line numbers for better usability\n-            let display_content = if total_lines == 0 {\n-                String::new()\n-            } else {\n-                let selected_lines: Vec<String> = lines[start_idx..end_idx]\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n-                    .collect();\n+        let uri = Url::from_file_path(path)\n+            .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n+            .to_string();\n \n-                selected_lines.join(\"\\n\")\n-            };\n+        let mut content = String::new();\n+        f.read_to_string(&mut content)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n \n-            let language = lang::get_language_identifier(path);\n-            let formatted = if view_range.is_some() {\n-                formatdoc! {\"\n-                    ### {path} (lines {start}-{end})\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    start=view_range.unwrap().0,\n-                    end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n-                    language=language,\n-                    content=display_content,\n-                }\n-            } else {\n-                formatdoc! {\"\n-                    ### {path}\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    language=language,\n-                    content=display_content,\n-                }\n-            };\n+        let lines: Vec<&str> = content.lines().collect();\n+        let total_lines = lines.len();",
        "comment_created_at": "2025-08-05T08:15:53+00:00",
        "comment_author": "michaelneale",
        "comment_body": "yeah I wasn't sure how to break that down - as it is a problem (ie if you tell goose to look at your session jsonl files - will get heavy). \r\n\r\nThe issue then is - the view editor tool doesn't have a range that looks inside a line (so it would need to be enhanced) so either part of this change or a follow on to have it take a column range as well as row start and finish? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2253682489",
        "repo_full_name": "block/goose",
        "pr_number": 3767,
        "pr_file": "crates/goose-mcp/src/developer/mod.rs",
        "discussion_id": "2253511566",
        "commented_code": "@@ -965,130 +966,152 @@ impl DeveloperRouter {\n         }\n     }\n \n+    // Helper method to validate and calculate view range indices\n+    fn calculate_view_range(\n+        &self,\n+        view_range: Option<(usize, i64)>,\n+        total_lines: usize,\n+    ) -> Result<(usize, usize), ToolError> {\n+        if let Some((start_line, end_line)) = view_range {\n+            // Convert 1-indexed line numbers to 0-indexed\n+            let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n+            let end_idx = if end_line == -1 {\n+                total_lines\n+            } else {\n+                std::cmp::min(end_line as usize, total_lines)\n+            };\n+\n+            if start_idx >= total_lines {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} is beyond the end of the file (total lines: {})\",\n+                    start_line, total_lines\n+                )));\n+            }\n+\n+            if start_idx >= end_idx {\n+                return Err(ToolError::InvalidParameters(format!(\n+                    \"Start line {} must be less than end line {}\",\n+                    start_line, end_line\n+                )));\n+            }\n+\n+            Ok((start_idx, end_idx))\n+        } else {\n+            Ok((0, total_lines))\n+        }\n+    }\n+\n+    // Helper method to format file content with line numbers\n+    fn format_file_content(\n+        &self,\n+        path: &Path,\n+        lines: &[&str],\n+        start_idx: usize,\n+        end_idx: usize,\n+        view_range: Option<(usize, i64)>,\n+    ) -> String {\n+        let display_content = if lines.is_empty() {\n+            String::new()\n+        } else {\n+            let selected_lines: Vec<String> = lines[start_idx..end_idx]\n+                .iter()\n+                .enumerate()\n+                .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n+                .collect();\n+\n+            selected_lines.join(\"\\n\")\n+        };\n+\n+        let language = lang::get_language_identifier(path);\n+        if view_range.is_some() {\n+            formatdoc! {\"\n+                ### {path} (lines {start}-{end})\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                start=view_range.unwrap().0,\n+                end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n+                language=language,\n+                content=display_content,\n+            }\n+        } else {\n+            formatdoc! {\"\n+                ### {path}\n+                ```{language}\n+                {content}\n+                ```\n+                \",\n+                path=path.display(),\n+                language=language,\n+                content=display_content,\n+            }\n+        }\n+    }\n+\n     async fn text_editor_view(\n         &self,\n         path: &PathBuf,\n         view_range: Option<(usize, i64)>,\n     ) -> Result<Vec<Content>, ToolError> {\n-        if path.is_file() {\n-            // Check file size first (400KB limit)\n-            const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n+        if !path.is_file() {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"The path '{}' does not exist or is not a file.\",\n+                path.display()\n+            )));\n+        }\n \n-            let f = File::open(path)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n+        // Check file size first (400KB limit)\n+        const MAX_FILE_SIZE: u64 = 400 * 1024; // 400KB in bytes\n \n-            let file_size = f\n-                .metadata()\n-                .map_err(|e| {\n-                    ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e))\n-                })?\n-                .len();\n+        let f = File::open(path)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to open file: {}\", e)))?;\n \n-            if file_size > MAX_FILE_SIZE {\n-                return Err(ToolError::ExecutionError(format!(\n-                    \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n-                    path.display(),\n-                    file_size as f64 / 1024.0\n-                )));\n-            }\n-            // Ensure we never read over that limit even if the file is being concurrently mutated\n-            // (e.g. it's a log file)\n-            let mut f = f.take(MAX_FILE_SIZE);\n-\n-            let uri = Url::from_file_path(path)\n-                .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n-                .to_string();\n-\n-            let mut content = String::new();\n-            f.read_to_string(&mut content)\n-                .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n-\n-            let lines: Vec<&str> = content.lines().collect();\n-            let total_lines = lines.len();\n-\n-            // Handle view_range if provided, otherwise show all lines\n-            let (start_idx, end_idx) = if let Some((start_line, end_line)) = view_range {\n-                // Convert 1-indexed line numbers to 0-indexed\n-                let start_idx = if start_line > 0 { start_line - 1 } else { 0 };\n-                let end_idx = if end_line == -1 {\n-                    total_lines\n-                } else {\n-                    std::cmp::min(end_line as usize, total_lines)\n-                };\n-\n-                if start_idx >= total_lines {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} is beyond the end of the file (total lines: {})\",\n-                        start_line, total_lines\n-                    )));\n-                }\n+        let file_size = f\n+            .metadata()\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to get file metadata: {}\", e)))?\n+            .len();\n \n-                if start_idx >= end_idx {\n-                    return Err(ToolError::InvalidParameters(format!(\n-                        \"Start line {} must be less than end line {}\",\n-                        start_line, end_line\n-                    )));\n-                }\n+        if file_size > MAX_FILE_SIZE {\n+            return Err(ToolError::ExecutionError(format!(\n+                \"File '{}' is too large ({:.2}KB). Maximum size is 400KB to prevent memory issues.\",\n+                path.display(),\n+                file_size as f64 / 1024.0\n+            )));\n+        }\n \n-                (start_idx, end_idx)\n-            } else {\n-                (0, total_lines)\n-            };\n+        // Ensure we never read over that limit even if the file is being concurrently mutated\n+        let mut f = f.take(MAX_FILE_SIZE);\n \n-            // Always format lines with line numbers for better usability\n-            let display_content = if total_lines == 0 {\n-                String::new()\n-            } else {\n-                let selected_lines: Vec<String> = lines[start_idx..end_idx]\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, line)| format!(\"{}: {}\", start_idx + i + 1, line))\n-                    .collect();\n+        let uri = Url::from_file_path(path)\n+            .map_err(|_| ToolError::ExecutionError(\"Invalid file path\".into()))?\n+            .to_string();\n \n-                selected_lines.join(\"\\n\")\n-            };\n+        let mut content = String::new();\n+        f.read_to_string(&mut content)\n+            .map_err(|e| ToolError::ExecutionError(format!(\"Failed to read file: {}\", e)))?;\n \n-            let language = lang::get_language_identifier(path);\n-            let formatted = if view_range.is_some() {\n-                formatdoc! {\"\n-                    ### {path} (lines {start}-{end})\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    start=view_range.unwrap().0,\n-                    end=if view_range.unwrap().1 == -1 { \"end\".to_string() } else { view_range.unwrap().1.to_string() },\n-                    language=language,\n-                    content=display_content,\n-                }\n-            } else {\n-                formatdoc! {\"\n-                    ### {path}\n-                    ```{language}\n-                    {content}\n-                    ```\n-                    \",\n-                    path=path.display(),\n-                    language=language,\n-                    content=display_content,\n-                }\n-            };\n+        let lines: Vec<&str> = content.lines().collect();\n+        let total_lines = lines.len();",
        "comment_created_at": "2025-08-05T09:19:51+00:00",
        "comment_author": "michaelneale",
        "comment_body": "will have a follow on task to make it read by column too when needed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2229231004",
    "pr_number": 3559,
    "pr_file": "crates/goose-cli/src/commands/web.rs",
    "created_at": "2025-07-24T18:19:07+00:00",
    "commented_code": "session_msgs.clone()\n     };\n \n+    // Check and compact messages if needed before calling reply\n+    let compact_result = check_and_compact_messages(agent, &messages, None).await?;\n+    if compact_result.compacted {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2229231004",
        "repo_full_name": "block/goose",
        "pr_number": 3559,
        "pr_file": "crates/goose-cli/src/commands/web.rs",
        "discussion_id": "2229231004",
        "commented_code": "@@ -455,6 +456,45 @@ async fn process_message_streaming(\n         session_msgs.clone()\n     };\n \n+    // Check and compact messages if needed before calling reply\n+    let compact_result = check_and_compact_messages(agent, &messages, None).await?;\n+    if compact_result.compacted {",
        "comment_created_at": "2025-07-24T18:19:07+00:00",
        "comment_author": "DOsinga",
        "comment_body": "you are repeating this code 3 times (and not for scheduled tasks?) - can we just move this into agent.reply?",
        "pr_file_module": null
      },
      {
        "comment_id": "2229547361",
        "repo_full_name": "block/goose",
        "pr_number": 3559,
        "pr_file": "crates/goose-cli/src/commands/web.rs",
        "discussion_id": "2229231004",
        "commented_code": "@@ -455,6 +456,45 @@ async fn process_message_streaming(\n         session_msgs.clone()\n     };\n \n+    // Check and compact messages if needed before calling reply\n+    let compact_result = check_and_compact_messages(agent, &messages, None).await?;\n+    if compact_result.compacted {",
        "comment_created_at": "2025-07-24T20:50:01+00:00",
        "comment_author": "katzdave",
        "comment_body": "Done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234473721",
    "pr_number": 3668,
    "pr_file": "crates/goose-cli/src/recipes/secret_discovery.rs",
    "created_at": "2025-07-28T02:46:55+00:00",
    "commented_code": "+use crate::recipes::search_recipe::retrieve_recipe_file;\n+use goose::agents::extension::ExtensionConfig;\n+use goose::recipe::Recipe;\n+use std::collections::HashSet;\n+\n+/// Represents a secret requirement discovered from a recipe extension\n+#[derive(Debug, Clone, PartialEq)]\n+pub struct SecretRequirement {\n+    /// The environment variable name (e.g., \"GITHUB_TOKEN\")\n+    pub key: String,\n+    /// The name of the extension that requires this secret\n+    pub extension_name: String,\n+}\n+\n+impl SecretRequirement {\n+    pub fn new(extension_name: String, key: String) -> Self {\n+        Self {\n+            key,\n+            extension_name,\n+        }\n+    }\n+\n+    /// Returns a human-readable description of what this secret is for\n+    pub fn description(&self) -> String {\n+        format!(\"Required by {} extension\", self.extension_name)\n+    }\n+}\n+\n+/// Discovers all secrets required by MCP extensions in a recipe and its sub-recipes\n+///\n+/// This function recursively scans the recipe and all its sub-recipes for extensions\n+/// and collects their declared env_keys, creating SecretRequirement structs for each\n+/// unique environment variable.\n+///\n+/// # Arguments\n+/// * `recipe` - The recipe to analyze for secret requirements\n+///\n+/// # Returns\n+/// A vector of SecretRequirement objects, deduplicated by key name\n+pub fn discover_recipe_secrets(recipe: &Recipe) -> Vec<SecretRequirement> {\n+    let mut visited_recipes = HashSet::new();\n+    discover_recipe_secrets_recursive(recipe, &mut visited_recipes)\n+}\n+\n+/// Internal recursive function (depth-first search) to discover secrets nested in sub-recipes\n+/// This is future-proofing for a time when we have more than one-level of sub-recipe nesting\n+fn discover_recipe_secrets_recursive(\n+    recipe: &Recipe,\n+    visited_recipes: &mut HashSet<String>,\n+) -> Vec<SecretRequirement> {\n+    let mut secrets: Vec<SecretRequirement> = Vec::new();\n+    let mut seen_keys = HashSet::new();\n+\n+    if let Some(extensions) = &recipe.extensions {\n+        for ext in extensions {\n+            let (extension_name, env_keys) = match ext {\n+                ExtensionConfig::Sse { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Stdio { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::StreamableHttp { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Builtin { name, .. } => (name, &Vec::new()),\n+                ExtensionConfig::Frontend { name, .. } => (name, &Vec::new()),\n+            };\n+\n+            for key in env_keys {\n+                if seen_keys.insert(key.clone()) {\n+                    let secret_req = SecretRequirement::new(extension_name.clone(), key.clone());\n+                    secrets.push(secret_req);\n+                }\n+            }\n+        }\n+    }\n+\n+    if let Some(sub_recipes) = &recipe.sub_recipes {\n+        for sub_recipe in sub_recipes {\n+            if visited_recipes.contains(&sub_recipe.path) {\n+                continue;\n+            }\n+            visited_recipes.insert(sub_recipe.path.clone());\n+\n+            match load_sub_recipe(&sub_recipe.path) {\n+                Ok(loaded_recipe) => {\n+                    let sub_secrets =\n+                        discover_recipe_secrets_recursive(&loaded_recipe, visited_recipes);\n+                    for sub_secret in sub_secrets {\n+                        if seen_keys.insert(sub_secret.key.clone()) {\n+                            secrets.push(sub_secret);\n+                        }\n+                    }\n+                }\n+                Err(_) => {\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    secrets\n+}\n+\n+/// Loads a recipe from a file path for sub-recipe secret discovery\n+///\n+/// For secret discovery, we only need the recipe structure (extensions and env_keys),\n+/// not parameter-substituted content, so we parse the raw YAML directly for speed and robustness.\n+fn load_sub_recipe(recipe_path: &str) -> Result<Recipe, Box<dyn std::error::Error>> {\n+    let recipe_file = retrieve_recipe_file(recipe_path)?;\n+    let recipe: Recipe = serde_yaml::from_str(&recipe_file.content)?;\n+    Ok(recipe)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use goose::agents::extension::{Envs, ExtensionConfig};\n+    use goose::recipe::Recipe;\n+    use std::collections::HashMap;\n+\n+    fn create_test_recipe_with_extensions() -> Recipe {\n+        Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Test Recipe\".to_string(),\n+            description: \"A test recipe with MCP extensions\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: Some(vec![\n+                ExtensionConfig::Sse {\n+                    name: \"github-mcp\".to_string(),\n+                    uri: \"sse://example.com\".to_string(),\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"GITHUB_TOKEN\".to_string(), \"GITHUB_API_URL\".to_string()],\n+                    description: None,\n+                    timeout: None,\n+                    bundled: None,\n+                },\n+                ExtensionConfig::Stdio {\n+                    name: \"slack-mcp\".to_string(),\n+                    cmd: \"slack-mcp\".to_string(),\n+                    args: vec![],\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"SLACK_TOKEN\".to_string()],\n+                    timeout: None,\n+                    description: None,\n+                    bundled: None,\n+                },\n+                ExtensionConfig::Builtin {\n+                    name: \"builtin-ext\".to_string(),\n+                    display_name: None,\n+                    description: None,\n+                    timeout: None,\n+                    bundled: None,\n+                },\n+            ]),\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            sub_recipes: None,\n+            retry: None,\n+        }\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets() {\n+        let recipe = create_test_recipe_with_extensions();\n+        let secrets = discover_recipe_secrets(&recipe);\n+\n+        assert_eq!(secrets.len(), 3);\n+\n+        let github_token = secrets.iter().find(|s| s.key == \"GITHUB_TOKEN\").unwrap();\n+        assert_eq!(github_token.key, \"GITHUB_TOKEN\");\n+        assert_eq!(github_token.extension_name, \"github-mcp\");\n+        assert_eq!(\n+            github_token.description(),\n+            \"Required by github-mcp extension\"\n+        );\n+\n+        let github_api = secrets.iter().find(|s| s.key == \"GITHUB_API_URL\").unwrap();\n+        assert_eq!(github_api.key, \"GITHUB_API_URL\");\n+        assert_eq!(github_api.extension_name, \"github-mcp\");\n+\n+        let slack_token = secrets.iter().find(|s| s.key == \"SLACK_TOKEN\").unwrap();\n+        assert_eq!(slack_token.key, \"SLACK_TOKEN\");\n+        assert_eq!(slack_token.extension_name, \"slack-mcp\");\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets_empty_recipe() {\n+        let recipe = Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Empty Recipe\".to_string(),\n+            description: \"A recipe with no extensions\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: None,\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            sub_recipes: None,\n+            retry: None,\n+        };\n+\n+        let secrets = discover_recipe_secrets(&recipe);\n+        assert_eq!(secrets.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets_deduplication() {\n+        let recipe = Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Test Recipe\".to_string(),\n+            description: \"A test recipe with duplicate secrets\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: Some(vec![\n+                ExtensionConfig::Sse {\n+                    name: \"service-a\".to_string(),\n+                    uri: \"sse://example.com\".to_string(),\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"API_KEY\".to_string()],\n+                    description: None,\n+                    timeout: None,\n+                    bundled: None,\n+                },\n+                ExtensionConfig::Stdio {\n+                    name: \"service-b\".to_string(),\n+                    cmd: \"service-b\".to_string(),\n+                    args: vec![],\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"API_KEY\".to_string()], // Same original key, different extension\n+                    timeout: None,\n+                    description: None,\n+                    bundled: None,\n+                },\n+            ]),\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            sub_recipes: None,\n+            retry: None,\n+        };\n+\n+        let secrets = discover_recipe_secrets(&recipe);\n+        assert_eq!(secrets.len(), 1);\n+\n+        let api_key = secrets.iter().find(|s| s.key == \"API_KEY\").unwrap();\n+        assert_eq!(api_key.key, \"API_KEY\");\n+        assert!(api_key.extension_name == \"service-a\" || api_key.extension_name == \"service-b\");\n+    }\n+\n+    #[test]\n+    fn test_secret_requirement_creation() {\n+        let req = SecretRequirement::new(\"test-ext\".to_string(), \"API_TOKEN\".to_string());\n+\n+        assert_eq!(req.key, \"API_TOKEN\");\n+        assert_eq!(req.extension_name, \"test-ext\");\n+        assert_eq!(req.description(), \"Required by test-ext extension\");\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets_with_sub_recipes() {\n+        use goose::recipe::SubRecipe;\n+\n+        let recipe = Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Parent Recipe\".to_string(),\n+            description: \"A recipe with sub-recipes\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: Some(vec![ExtensionConfig::Sse {\n+                name: \"parent-ext\".to_string(),\n+                uri: \"sse://parent.com\".to_string(),\n+                envs: Envs::new(HashMap::new()),\n+                env_keys: vec![\"PARENT_TOKEN\".to_string()],\n+                description: None,\n+                timeout: None,\n+                bundled: None,\n+            }]),\n+            sub_recipes: Some(vec![SubRecipe {\n+                name: \"child-recipe\".to_string(),\n+                path: \"path/to/child.yaml\".to_string(),\n+                values: None,\n+                sequential_when_repeated: false,\n+                description: None,\n+            }]),\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            retry: None,\n+        };\n+\n+        let secrets = discover_recipe_secrets(&recipe);\n+\n+        assert_eq!(secrets.len(), 1);\n+\n+        let parent_secret = secrets.iter().find(|s| s.key == \"PARENT_TOKEN\").unwrap();\n+        assert_eq!(parent_secret.extension_name, \"parent-ext\");\n+    }\n+\n+    /// Integration tests - these test the full workflow within recipe context\n+    mod integration_tests {\n+        use super::*;\n+        use crate::recipes::recipe::collect_missing_secrets;\n+        use goose::config::Config;\n+        use goose::recipe::SubRecipe;\n+        use serde_json::Value;\n+\n+        fn create_test_recipe_with_mcp_extensions() -> Recipe {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2234473721",
        "repo_full_name": "block/goose",
        "pr_number": 3668,
        "pr_file": "crates/goose-cli/src/recipes/secret_discovery.rs",
        "discussion_id": "2234473721",
        "commented_code": "@@ -0,0 +1,508 @@\n+use crate::recipes::search_recipe::retrieve_recipe_file;\n+use goose::agents::extension::ExtensionConfig;\n+use goose::recipe::Recipe;\n+use std::collections::HashSet;\n+\n+/// Represents a secret requirement discovered from a recipe extension\n+#[derive(Debug, Clone, PartialEq)]\n+pub struct SecretRequirement {\n+    /// The environment variable name (e.g., \"GITHUB_TOKEN\")\n+    pub key: String,\n+    /// The name of the extension that requires this secret\n+    pub extension_name: String,\n+}\n+\n+impl SecretRequirement {\n+    pub fn new(extension_name: String, key: String) -> Self {\n+        Self {\n+            key,\n+            extension_name,\n+        }\n+    }\n+\n+    /// Returns a human-readable description of what this secret is for\n+    pub fn description(&self) -> String {\n+        format!(\"Required by {} extension\", self.extension_name)\n+    }\n+}\n+\n+/// Discovers all secrets required by MCP extensions in a recipe and its sub-recipes\n+///\n+/// This function recursively scans the recipe and all its sub-recipes for extensions\n+/// and collects their declared env_keys, creating SecretRequirement structs for each\n+/// unique environment variable.\n+///\n+/// # Arguments\n+/// * `recipe` - The recipe to analyze for secret requirements\n+///\n+/// # Returns\n+/// A vector of SecretRequirement objects, deduplicated by key name\n+pub fn discover_recipe_secrets(recipe: &Recipe) -> Vec<SecretRequirement> {\n+    let mut visited_recipes = HashSet::new();\n+    discover_recipe_secrets_recursive(recipe, &mut visited_recipes)\n+}\n+\n+/// Internal recursive function (depth-first search) to discover secrets nested in sub-recipes\n+/// This is future-proofing for a time when we have more than one-level of sub-recipe nesting\n+fn discover_recipe_secrets_recursive(\n+    recipe: &Recipe,\n+    visited_recipes: &mut HashSet<String>,\n+) -> Vec<SecretRequirement> {\n+    let mut secrets: Vec<SecretRequirement> = Vec::new();\n+    let mut seen_keys = HashSet::new();\n+\n+    if let Some(extensions) = &recipe.extensions {\n+        for ext in extensions {\n+            let (extension_name, env_keys) = match ext {\n+                ExtensionConfig::Sse { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Stdio { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::StreamableHttp { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Builtin { name, .. } => (name, &Vec::new()),\n+                ExtensionConfig::Frontend { name, .. } => (name, &Vec::new()),\n+            };\n+\n+            for key in env_keys {\n+                if seen_keys.insert(key.clone()) {\n+                    let secret_req = SecretRequirement::new(extension_name.clone(), key.clone());\n+                    secrets.push(secret_req);\n+                }\n+            }\n+        }\n+    }\n+\n+    if let Some(sub_recipes) = &recipe.sub_recipes {\n+        for sub_recipe in sub_recipes {\n+            if visited_recipes.contains(&sub_recipe.path) {\n+                continue;\n+            }\n+            visited_recipes.insert(sub_recipe.path.clone());\n+\n+            match load_sub_recipe(&sub_recipe.path) {\n+                Ok(loaded_recipe) => {\n+                    let sub_secrets =\n+                        discover_recipe_secrets_recursive(&loaded_recipe, visited_recipes);\n+                    for sub_secret in sub_secrets {\n+                        if seen_keys.insert(sub_secret.key.clone()) {\n+                            secrets.push(sub_secret);\n+                        }\n+                    }\n+                }\n+                Err(_) => {\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    secrets\n+}\n+\n+/// Loads a recipe from a file path for sub-recipe secret discovery\n+///\n+/// For secret discovery, we only need the recipe structure (extensions and env_keys),\n+/// not parameter-substituted content, so we parse the raw YAML directly for speed and robustness.\n+fn load_sub_recipe(recipe_path: &str) -> Result<Recipe, Box<dyn std::error::Error>> {\n+    let recipe_file = retrieve_recipe_file(recipe_path)?;\n+    let recipe: Recipe = serde_yaml::from_str(&recipe_file.content)?;\n+    Ok(recipe)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use goose::agents::extension::{Envs, ExtensionConfig};\n+    use goose::recipe::Recipe;\n+    use std::collections::HashMap;\n+\n+    fn create_test_recipe_with_extensions() -> Recipe {\n+        Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Test Recipe\".to_string(),\n+            description: \"A test recipe with MCP extensions\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: Some(vec![\n+                ExtensionConfig::Sse {\n+                    name: \"github-mcp\".to_string(),\n+                    uri: \"sse://example.com\".to_string(),\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"GITHUB_TOKEN\".to_string(), \"GITHUB_API_URL\".to_string()],\n+                    description: None,\n+                    timeout: None,\n+                    bundled: None,\n+                },\n+                ExtensionConfig::Stdio {\n+                    name: \"slack-mcp\".to_string(),\n+                    cmd: \"slack-mcp\".to_string(),\n+                    args: vec![],\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"SLACK_TOKEN\".to_string()],\n+                    timeout: None,\n+                    description: None,\n+                    bundled: None,\n+                },\n+                ExtensionConfig::Builtin {\n+                    name: \"builtin-ext\".to_string(),\n+                    display_name: None,\n+                    description: None,\n+                    timeout: None,\n+                    bundled: None,\n+                },\n+            ]),\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            sub_recipes: None,\n+            retry: None,\n+        }\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets() {\n+        let recipe = create_test_recipe_with_extensions();\n+        let secrets = discover_recipe_secrets(&recipe);\n+\n+        assert_eq!(secrets.len(), 3);\n+\n+        let github_token = secrets.iter().find(|s| s.key == \"GITHUB_TOKEN\").unwrap();\n+        assert_eq!(github_token.key, \"GITHUB_TOKEN\");\n+        assert_eq!(github_token.extension_name, \"github-mcp\");\n+        assert_eq!(\n+            github_token.description(),\n+            \"Required by github-mcp extension\"\n+        );\n+\n+        let github_api = secrets.iter().find(|s| s.key == \"GITHUB_API_URL\").unwrap();\n+        assert_eq!(github_api.key, \"GITHUB_API_URL\");\n+        assert_eq!(github_api.extension_name, \"github-mcp\");\n+\n+        let slack_token = secrets.iter().find(|s| s.key == \"SLACK_TOKEN\").unwrap();\n+        assert_eq!(slack_token.key, \"SLACK_TOKEN\");\n+        assert_eq!(slack_token.extension_name, \"slack-mcp\");\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets_empty_recipe() {\n+        let recipe = Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Empty Recipe\".to_string(),\n+            description: \"A recipe with no extensions\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: None,\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            sub_recipes: None,\n+            retry: None,\n+        };\n+\n+        let secrets = discover_recipe_secrets(&recipe);\n+        assert_eq!(secrets.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets_deduplication() {\n+        let recipe = Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Test Recipe\".to_string(),\n+            description: \"A test recipe with duplicate secrets\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: Some(vec![\n+                ExtensionConfig::Sse {\n+                    name: \"service-a\".to_string(),\n+                    uri: \"sse://example.com\".to_string(),\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"API_KEY\".to_string()],\n+                    description: None,\n+                    timeout: None,\n+                    bundled: None,\n+                },\n+                ExtensionConfig::Stdio {\n+                    name: \"service-b\".to_string(),\n+                    cmd: \"service-b\".to_string(),\n+                    args: vec![],\n+                    envs: Envs::new(HashMap::new()),\n+                    env_keys: vec![\"API_KEY\".to_string()], // Same original key, different extension\n+                    timeout: None,\n+                    description: None,\n+                    bundled: None,\n+                },\n+            ]),\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            sub_recipes: None,\n+            retry: None,\n+        };\n+\n+        let secrets = discover_recipe_secrets(&recipe);\n+        assert_eq!(secrets.len(), 1);\n+\n+        let api_key = secrets.iter().find(|s| s.key == \"API_KEY\").unwrap();\n+        assert_eq!(api_key.key, \"API_KEY\");\n+        assert!(api_key.extension_name == \"service-a\" || api_key.extension_name == \"service-b\");\n+    }\n+\n+    #[test]\n+    fn test_secret_requirement_creation() {\n+        let req = SecretRequirement::new(\"test-ext\".to_string(), \"API_TOKEN\".to_string());\n+\n+        assert_eq!(req.key, \"API_TOKEN\");\n+        assert_eq!(req.extension_name, \"test-ext\");\n+        assert_eq!(req.description(), \"Required by test-ext extension\");\n+    }\n+\n+    #[test]\n+    fn test_discover_recipe_secrets_with_sub_recipes() {\n+        use goose::recipe::SubRecipe;\n+\n+        let recipe = Recipe {\n+            version: \"1.0.0\".to_string(),\n+            title: \"Parent Recipe\".to_string(),\n+            description: \"A recipe with sub-recipes\".to_string(),\n+            instructions: Some(\"Test instructions\".to_string()),\n+            prompt: None,\n+            extensions: Some(vec![ExtensionConfig::Sse {\n+                name: \"parent-ext\".to_string(),\n+                uri: \"sse://parent.com\".to_string(),\n+                envs: Envs::new(HashMap::new()),\n+                env_keys: vec![\"PARENT_TOKEN\".to_string()],\n+                description: None,\n+                timeout: None,\n+                bundled: None,\n+            }]),\n+            sub_recipes: Some(vec![SubRecipe {\n+                name: \"child-recipe\".to_string(),\n+                path: \"path/to/child.yaml\".to_string(),\n+                values: None,\n+                sequential_when_repeated: false,\n+                description: None,\n+            }]),\n+            context: None,\n+            settings: None,\n+            activities: None,\n+            author: None,\n+            parameters: None,\n+            response: None,\n+            retry: None,\n+        };\n+\n+        let secrets = discover_recipe_secrets(&recipe);\n+\n+        assert_eq!(secrets.len(), 1);\n+\n+        let parent_secret = secrets.iter().find(|s| s.key == \"PARENT_TOKEN\").unwrap();\n+        assert_eq!(parent_secret.extension_name, \"parent-ext\");\n+    }\n+\n+    /// Integration tests - these test the full workflow within recipe context\n+    mod integration_tests {\n+        use super::*;\n+        use crate::recipes::recipe::collect_missing_secrets;\n+        use goose::config::Config;\n+        use goose::recipe::SubRecipe;\n+        use serde_json::Value;\n+\n+        fn create_test_recipe_with_mcp_extensions() -> Recipe {",
        "comment_created_at": "2025-07-28T02:46:55+00:00",
        "comment_author": "jsibbison-square",
        "comment_body": "This fn is only used once, maybe change it to accept extensions and sub_recipes so it can be reused to reduce duplication.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2234475307",
    "pr_number": 3668,
    "pr_file": "crates/goose-cli/src/recipes/secret_discovery.rs",
    "created_at": "2025-07-28T02:47:30+00:00",
    "commented_code": "+use crate::recipes::search_recipe::retrieve_recipe_file;\n+use goose::agents::extension::ExtensionConfig;\n+use goose::recipe::Recipe;\n+use std::collections::HashSet;\n+\n+/// Represents a secret requirement discovered from a recipe extension\n+#[derive(Debug, Clone, PartialEq)]\n+pub struct SecretRequirement {\n+    /// The environment variable name (e.g., \"GITHUB_TOKEN\")\n+    pub key: String,\n+    /// The name of the extension that requires this secret\n+    pub extension_name: String,\n+}\n+\n+impl SecretRequirement {\n+    pub fn new(extension_name: String, key: String) -> Self {\n+        Self {\n+            key,\n+            extension_name,\n+        }\n+    }\n+\n+    /// Returns a human-readable description of what this secret is for\n+    pub fn description(&self) -> String {\n+        format!(\"Required by {} extension\", self.extension_name)\n+    }\n+}\n+\n+/// Discovers all secrets required by MCP extensions in a recipe and its sub-recipes\n+///\n+/// This function recursively scans the recipe and all its sub-recipes for extensions\n+/// and collects their declared env_keys, creating SecretRequirement structs for each\n+/// unique environment variable.\n+///\n+/// # Arguments\n+/// * `recipe` - The recipe to analyze for secret requirements\n+///\n+/// # Returns\n+/// A vector of SecretRequirement objects, deduplicated by key name\n+pub fn discover_recipe_secrets(recipe: &Recipe) -> Vec<SecretRequirement> {\n+    let mut visited_recipes = HashSet::new();\n+    discover_recipe_secrets_recursive(recipe, &mut visited_recipes)\n+}\n+\n+/// Internal recursive function (depth-first search) to discover secrets nested in sub-recipes\n+/// This is future-proofing for a time when we have more than one-level of sub-recipe nesting\n+fn discover_recipe_secrets_recursive(\n+    recipe: &Recipe,\n+    visited_recipes: &mut HashSet<String>,\n+) -> Vec<SecretRequirement> {\n+    let mut secrets: Vec<SecretRequirement> = Vec::new();\n+    let mut seen_keys = HashSet::new();\n+\n+    if let Some(extensions) = &recipe.extensions {\n+        for ext in extensions {\n+            let (extension_name, env_keys) = match ext {\n+                ExtensionConfig::Sse { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Stdio { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::StreamableHttp { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Builtin { name, .. } => (name, &Vec::new()),\n+                ExtensionConfig::Frontend { name, .. } => (name, &Vec::new()),\n+            };\n+\n+            for key in env_keys {\n+                if seen_keys.insert(key.clone()) {\n+                    let secret_req = SecretRequirement::new(extension_name.clone(), key.clone());\n+                    secrets.push(secret_req);\n+                }\n+            }\n+        }\n+    }\n+\n+    if let Some(sub_recipes) = &recipe.sub_recipes {\n+        for sub_recipe in sub_recipes {\n+            if visited_recipes.contains(&sub_recipe.path) {\n+                continue;\n+            }\n+            visited_recipes.insert(sub_recipe.path.clone());\n+\n+            match load_sub_recipe(&sub_recipe.path) {\n+                Ok(loaded_recipe) => {\n+                    let sub_secrets =\n+                        discover_recipe_secrets_recursive(&loaded_recipe, visited_recipes);\n+                    for sub_secret in sub_secrets {\n+                        if seen_keys.insert(sub_secret.key.clone()) {\n+                            secrets.push(sub_secret);\n+                        }\n+                    }\n+                }\n+                Err(_) => {\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    secrets\n+}\n+\n+/// Loads a recipe from a file path for sub-recipe secret discovery\n+///\n+/// For secret discovery, we only need the recipe structure (extensions and env_keys),\n+/// not parameter-substituted content, so we parse the raw YAML directly for speed and robustness.\n+fn load_sub_recipe(recipe_path: &str) -> Result<Recipe, Box<dyn std::error::Error>> {\n+    let recipe_file = retrieve_recipe_file(recipe_path)?;\n+    let recipe: Recipe = serde_yaml::from_str(&recipe_file.content)?;\n+    Ok(recipe)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use goose::agents::extension::{Envs, ExtensionConfig};\n+    use goose::recipe::Recipe;\n+    use std::collections::HashMap;\n+\n+    fn create_test_recipe_with_extensions() -> Recipe {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2234475307",
        "repo_full_name": "block/goose",
        "pr_number": 3668,
        "pr_file": "crates/goose-cli/src/recipes/secret_discovery.rs",
        "discussion_id": "2234475307",
        "commented_code": "@@ -0,0 +1,508 @@\n+use crate::recipes::search_recipe::retrieve_recipe_file;\n+use goose::agents::extension::ExtensionConfig;\n+use goose::recipe::Recipe;\n+use std::collections::HashSet;\n+\n+/// Represents a secret requirement discovered from a recipe extension\n+#[derive(Debug, Clone, PartialEq)]\n+pub struct SecretRequirement {\n+    /// The environment variable name (e.g., \"GITHUB_TOKEN\")\n+    pub key: String,\n+    /// The name of the extension that requires this secret\n+    pub extension_name: String,\n+}\n+\n+impl SecretRequirement {\n+    pub fn new(extension_name: String, key: String) -> Self {\n+        Self {\n+            key,\n+            extension_name,\n+        }\n+    }\n+\n+    /// Returns a human-readable description of what this secret is for\n+    pub fn description(&self) -> String {\n+        format!(\"Required by {} extension\", self.extension_name)\n+    }\n+}\n+\n+/// Discovers all secrets required by MCP extensions in a recipe and its sub-recipes\n+///\n+/// This function recursively scans the recipe and all its sub-recipes for extensions\n+/// and collects their declared env_keys, creating SecretRequirement structs for each\n+/// unique environment variable.\n+///\n+/// # Arguments\n+/// * `recipe` - The recipe to analyze for secret requirements\n+///\n+/// # Returns\n+/// A vector of SecretRequirement objects, deduplicated by key name\n+pub fn discover_recipe_secrets(recipe: &Recipe) -> Vec<SecretRequirement> {\n+    let mut visited_recipes = HashSet::new();\n+    discover_recipe_secrets_recursive(recipe, &mut visited_recipes)\n+}\n+\n+/// Internal recursive function (depth-first search) to discover secrets nested in sub-recipes\n+/// This is future-proofing for a time when we have more than one-level of sub-recipe nesting\n+fn discover_recipe_secrets_recursive(\n+    recipe: &Recipe,\n+    visited_recipes: &mut HashSet<String>,\n+) -> Vec<SecretRequirement> {\n+    let mut secrets: Vec<SecretRequirement> = Vec::new();\n+    let mut seen_keys = HashSet::new();\n+\n+    if let Some(extensions) = &recipe.extensions {\n+        for ext in extensions {\n+            let (extension_name, env_keys) = match ext {\n+                ExtensionConfig::Sse { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Stdio { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::StreamableHttp { name, env_keys, .. } => (name, env_keys),\n+                ExtensionConfig::Builtin { name, .. } => (name, &Vec::new()),\n+                ExtensionConfig::Frontend { name, .. } => (name, &Vec::new()),\n+            };\n+\n+            for key in env_keys {\n+                if seen_keys.insert(key.clone()) {\n+                    let secret_req = SecretRequirement::new(extension_name.clone(), key.clone());\n+                    secrets.push(secret_req);\n+                }\n+            }\n+        }\n+    }\n+\n+    if let Some(sub_recipes) = &recipe.sub_recipes {\n+        for sub_recipe in sub_recipes {\n+            if visited_recipes.contains(&sub_recipe.path) {\n+                continue;\n+            }\n+            visited_recipes.insert(sub_recipe.path.clone());\n+\n+            match load_sub_recipe(&sub_recipe.path) {\n+                Ok(loaded_recipe) => {\n+                    let sub_secrets =\n+                        discover_recipe_secrets_recursive(&loaded_recipe, visited_recipes);\n+                    for sub_secret in sub_secrets {\n+                        if seen_keys.insert(sub_secret.key.clone()) {\n+                            secrets.push(sub_secret);\n+                        }\n+                    }\n+                }\n+                Err(_) => {\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    secrets\n+}\n+\n+/// Loads a recipe from a file path for sub-recipe secret discovery\n+///\n+/// For secret discovery, we only need the recipe structure (extensions and env_keys),\n+/// not parameter-substituted content, so we parse the raw YAML directly for speed and robustness.\n+fn load_sub_recipe(recipe_path: &str) -> Result<Recipe, Box<dyn std::error::Error>> {\n+    let recipe_file = retrieve_recipe_file(recipe_path)?;\n+    let recipe: Recipe = serde_yaml::from_str(&recipe_file.content)?;\n+    Ok(recipe)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use goose::agents::extension::{Envs, ExtensionConfig};\n+    use goose::recipe::Recipe;\n+    use std::collections::HashMap;\n+\n+    fn create_test_recipe_with_extensions() -> Recipe {",
        "comment_created_at": "2025-07-28T02:47:30+00:00",
        "comment_author": "jsibbison-square",
        "comment_body": "This fn is only used once, maybe change it to accept extensions and sub_recipes so it can be reused to reduce duplication.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2216001257",
    "pr_number": 3474,
    "pr_file": "crates/goose/src/agents/retry.rs",
    "created_at": "2025-07-18T13:05:14+00:00",
    "commented_code": "+use anyhow::Result;\n+use std::process::Stdio;\n+use std::time::Duration;\n+use tokio::process::Command;\n+use tracing::{debug, info, warn};\n+\n+use crate::agents::types::{\n+    RetryConfig, SuccessCheck, DEFAULT_ON_FAILURE_TIMEOUT_SECONDS, DEFAULT_RETRY_TIMEOUT_SECONDS,\n+};\n+use crate::config::Config;\n+\n+/// Environment variable for configuring retry timeout globally\n+const GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS\";\n+\n+/// Environment variable for configuring on_failure timeout globally\n+const GOOSE_RECIPE_ON_FAILURE_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_ON_FAILURE_TIMEOUT_SECONDS\";\n+\n+/// Get the configured timeout duration for retry operations\n+/// retry_config.timeout_seconds -> env var -> default\n+fn get_retry_timeout(retry_config: &RetryConfig) -> Duration {\n+    let timeout_seconds = retry_config\n+        .timeout_seconds\n+        .or_else(|| {\n+            let config = Config::global();\n+            config.get_param(GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS).ok()\n+        })\n+        .unwrap_or(DEFAULT_RETRY_TIMEOUT_SECONDS);\n+\n+    Duration::from_secs(timeout_seconds)\n+}\n+\n+/// Get the configured timeout duration for on_failure operations\n+/// retry_config.on_failure_timeout_seconds -> env var -> default\n+fn get_on_failure_timeout(retry_config: &RetryConfig) -> Duration {\n+    let timeout_seconds = retry_config\n+        .on_failure_timeout_seconds\n+        .or_else(|| {\n+            let config = Config::global();\n+            config\n+                .get_param(GOOSE_RECIPE_ON_FAILURE_TIMEOUT_SECONDS)\n+                .ok()\n+        })\n+        .unwrap_or(DEFAULT_ON_FAILURE_TIMEOUT_SECONDS);\n+\n+    Duration::from_secs(timeout_seconds)\n+}\n+\n+/// Execute all success checks and return true if all pass\n+pub async fn execute_success_checks(\n+    checks: &[SuccessCheck],\n+    retry_config: &RetryConfig,\n+) -> Result<bool> {\n+    let timeout = get_retry_timeout(retry_config);\n+\n+    for check in checks {\n+        match check {\n+            SuccessCheck::Shell { command } => {\n+                let result = execute_shell_command(command, timeout).await?;\n+                if !result.status.success() {\n+                    warn!(\n+                        \"Success check failed: command '{}' exited with status {}, stderr: {}\",\n+                        command,\n+                        result.status,\n+                        String::from_utf8_lossy(&result.stderr)\n+                    );\n+                    return Ok(false);\n+                }\n+                info!(\n+                    \"Success check passed: command '{}' completed successfully\",\n+                    command\n+                );\n+            }\n+        }\n+    }\n+    Ok(true)\n+}\n+\n+/// Execute a shell command with cross-platform compatibility and mandatory timeout\n+pub async fn execute_shell_command(\n+    command: &str,\n+    timeout: std::time::Duration,\n+) -> Result<std::process::Output> {\n+    debug!(\n+        \"Executing shell command with timeout {:?}: {}\",\n+        timeout, command\n+    );\n+\n+    let future = async {\n+        let output = if cfg!(target_os = \"windows\") {",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2216001257",
        "repo_full_name": "block/goose",
        "pr_number": 3474,
        "pr_file": "crates/goose/src/agents/retry.rs",
        "discussion_id": "2216001257",
        "commented_code": "@@ -0,0 +1,338 @@\n+use anyhow::Result;\n+use std::process::Stdio;\n+use std::time::Duration;\n+use tokio::process::Command;\n+use tracing::{debug, info, warn};\n+\n+use crate::agents::types::{\n+    RetryConfig, SuccessCheck, DEFAULT_ON_FAILURE_TIMEOUT_SECONDS, DEFAULT_RETRY_TIMEOUT_SECONDS,\n+};\n+use crate::config::Config;\n+\n+/// Environment variable for configuring retry timeout globally\n+const GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS\";\n+\n+/// Environment variable for configuring on_failure timeout globally\n+const GOOSE_RECIPE_ON_FAILURE_TIMEOUT_SECONDS: &str = \"GOOSE_RECIPE_ON_FAILURE_TIMEOUT_SECONDS\";\n+\n+/// Get the configured timeout duration for retry operations\n+/// retry_config.timeout_seconds -> env var -> default\n+fn get_retry_timeout(retry_config: &RetryConfig) -> Duration {\n+    let timeout_seconds = retry_config\n+        .timeout_seconds\n+        .or_else(|| {\n+            let config = Config::global();\n+            config.get_param(GOOSE_RECIPE_RETRY_TIMEOUT_SECONDS).ok()\n+        })\n+        .unwrap_or(DEFAULT_RETRY_TIMEOUT_SECONDS);\n+\n+    Duration::from_secs(timeout_seconds)\n+}\n+\n+/// Get the configured timeout duration for on_failure operations\n+/// retry_config.on_failure_timeout_seconds -> env var -> default\n+fn get_on_failure_timeout(retry_config: &RetryConfig) -> Duration {\n+    let timeout_seconds = retry_config\n+        .on_failure_timeout_seconds\n+        .or_else(|| {\n+            let config = Config::global();\n+            config\n+                .get_param(GOOSE_RECIPE_ON_FAILURE_TIMEOUT_SECONDS)\n+                .ok()\n+        })\n+        .unwrap_or(DEFAULT_ON_FAILURE_TIMEOUT_SECONDS);\n+\n+    Duration::from_secs(timeout_seconds)\n+}\n+\n+/// Execute all success checks and return true if all pass\n+pub async fn execute_success_checks(\n+    checks: &[SuccessCheck],\n+    retry_config: &RetryConfig,\n+) -> Result<bool> {\n+    let timeout = get_retry_timeout(retry_config);\n+\n+    for check in checks {\n+        match check {\n+            SuccessCheck::Shell { command } => {\n+                let result = execute_shell_command(command, timeout).await?;\n+                if !result.status.success() {\n+                    warn!(\n+                        \"Success check failed: command '{}' exited with status {}, stderr: {}\",\n+                        command,\n+                        result.status,\n+                        String::from_utf8_lossy(&result.stderr)\n+                    );\n+                    return Ok(false);\n+                }\n+                info!(\n+                    \"Success check passed: command '{}' completed successfully\",\n+                    command\n+                );\n+            }\n+        }\n+    }\n+    Ok(true)\n+}\n+\n+/// Execute a shell command with cross-platform compatibility and mandatory timeout\n+pub async fn execute_shell_command(\n+    command: &str,\n+    timeout: std::time::Duration,\n+) -> Result<std::process::Output> {\n+    debug!(\n+        \"Executing shell command with timeout {:?}: {}\",\n+        timeout, command\n+    );\n+\n+    let future = async {\n+        let output = if cfg!(target_os = \"windows\") {",
        "comment_created_at": "2025-07-18T13:05:14+00:00",
        "comment_author": "lifeizhou-ap",
        "comment_body": "could be less duplication\r\n```\r\nlet command = if cfg!(target_os = \"windows\") {\r\n            Command::new(\"cmd\")\r\n                .args([\"/C\", command])\r\n} else {\r\n            Command::new(\"sh\")\r\n                .args([\"-c\", command])\r\n};\r\nlet output = command.stdout(Stdio::piped())\r\n        .stderr(Stdio::piped())\r\n        .stdin(Stdio::null())\r\n        .kill_on_drop(true)\r\n        .output()\r\n        .await?\r\n```",
        "pr_file_module": null
      }
    ]
  }
]