[
  {
    "discussion_id": "2285815637",
    "pr_number": 4187,
    "pr_file": "ui/desktop/src/components/settings/extensions/bundled-extensions.ts",
    "created_at": "2025-08-19T16:50:01+00:00",
    "commented_code": "// Cast the imported JSON data to the expected type\n     const bundledExtensions = bundledExtensionsData as BundledExtension[];\n \n+    for (let i = existingExtensions.length - 1; i >= 0; i--) {\n+      const ext = existingExtensions[i];\n+      if (ext.type == 'builtin' && DEPRECATED_BUILTINS.includes(ext.name)) {\n+        existingExtensions.splice(i, 1);",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2285815637",
        "repo_full_name": "block/goose",
        "pr_number": 4187,
        "pr_file": "ui/desktop/src/components/settings/extensions/bundled-extensions.ts",
        "discussion_id": "2285815637",
        "commented_code": "@@ -37,6 +39,13 @@ export async function syncBundledExtensions(\n     // Cast the imported JSON data to the expected type\n     const bundledExtensions = bundledExtensionsData as BundledExtension[];\n \n+    for (let i = existingExtensions.length - 1; i >= 0; i--) {\n+      const ext = existingExtensions[i];\n+      if (ext.type == 'builtin' && DEPRECATED_BUILTINS.includes(ext.name)) {\n+        existingExtensions.splice(i, 1);",
        "comment_created_at": "2025-08-19T16:50:01+00:00",
        "comment_author": "alexhancock",
        "comment_body": "this would modify the in memory copy of the existing extensions read from the config, but wouldn't remove the extension from the config file\r\n\r\nI assume we want something that does that, right?",
        "pr_file_module": null
      },
      {
        "comment_id": "2286074873",
        "repo_full_name": "block/goose",
        "pr_number": 4187,
        "pr_file": "ui/desktop/src/components/settings/extensions/bundled-extensions.ts",
        "discussion_id": "2285815637",
        "commented_code": "@@ -37,6 +39,13 @@ export async function syncBundledExtensions(\n     // Cast the imported JSON data to the expected type\n     const bundledExtensions = bundledExtensionsData as BundledExtension[];\n \n+    for (let i = existingExtensions.length - 1; i >= 0; i--) {\n+      const ext = existingExtensions[i];\n+      if (ext.type == 'builtin' && DEPRECATED_BUILTINS.includes(ext.name)) {\n+        existingExtensions.splice(i, 1);",
        "comment_created_at": "2025-08-19T18:53:05+00:00",
        "comment_author": "jamadeo",
        "comment_body": "You're right, it's still in my config file. I thought this would sync them back to the config but I guess it doesn't? I don't see it in the extensions UI and if I ask Goose to use drive it does not find it. But I suppose if I ran the CLI it would pick it up.",
        "pr_file_module": null
      },
      {
        "comment_id": "2286317807",
        "repo_full_name": "block/goose",
        "pr_number": 4187,
        "pr_file": "ui/desktop/src/components/settings/extensions/bundled-extensions.ts",
        "discussion_id": "2285815637",
        "commented_code": "@@ -37,6 +39,13 @@ export async function syncBundledExtensions(\n     // Cast the imported JSON data to the expected type\n     const bundledExtensions = bundledExtensionsData as BundledExtension[];\n \n+    for (let i = existingExtensions.length - 1; i >= 0; i--) {\n+      const ext = existingExtensions[i];\n+      if (ext.type == 'builtin' && DEPRECATED_BUILTINS.includes(ext.name)) {\n+        existingExtensions.splice(i, 1);",
        "comment_created_at": "2025-08-19T20:57:11+00:00",
        "comment_author": "jamadeo",
        "comment_body": "So this doesn't do it perfectly but I think it has the intended effect. It will refuse to load the deprecated extension and then if it sees a 'googledrive' bundled extension, it will be replaced. If not, it will just ignore it. It's not a perfect clean-up of the config but any other solution would mean adding a \"migration\" hook/step in the config load/save, which would be nice to avoid if possible. This way at least it all lives in the same place.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2215992144",
    "pr_number": 3510,
    "pr_file": "ui/desktop/src/main.ts",
    "created_at": "2025-07-18T13:00:41+00:00",
    "commented_code": "};\n \n const generateSecretKey = () => {\n-  const key = crypto.randomBytes(32).toString('hex');\n+  const key = process.env.GOOSE_EXTERNAL_BACKEND ? 'test' : crypto.randomBytes(32).toString('hex');",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2215992144",
        "repo_full_name": "block/goose",
        "pr_number": 3510,
        "pr_file": "ui/desktop/src/main.ts",
        "discussion_id": "2215992144",
        "commented_code": "@@ -452,7 +452,7 @@ const getGooseProvider = () => {\n };\n \n const generateSecretKey = () => {\n-  const key = crypto.randomBytes(32).toString('hex');\n+  const key = process.env.GOOSE_EXTERNAL_BACKEND ? 'test' : crypto.randomBytes(32).toString('hex');",
        "comment_created_at": "2025-07-18T13:00:41+00:00",
        "comment_author": "jamadeo",
        "comment_body": "maybe here you could just check if GOOSE_SERVER__SECRET_KEY is already set, and if so, use that instead of generating one. Then in the Justfile set it",
        "pr_file_module": null
      },
      {
        "comment_id": "2217248674",
        "repo_full_name": "block/goose",
        "pr_number": 3510,
        "pr_file": "ui/desktop/src/main.ts",
        "discussion_id": "2215992144",
        "commented_code": "@@ -452,7 +452,7 @@ const getGooseProvider = () => {\n };\n \n const generateSecretKey = () => {\n-  const key = crypto.randomBytes(32).toString('hex');\n+  const key = process.env.GOOSE_EXTERNAL_BACKEND ? 'test' : crypto.randomBytes(32).toString('hex');",
        "comment_created_at": "2025-07-19T08:59:27+00:00",
        "comment_author": "DOsinga",
        "comment_body": "yes, but then you put the burden on the user to set that in their RustRover started backend to the same value - that thing currently sets it to test, so this is lower maintaince maybe?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2141261684",
    "pr_number": 2852,
    "pr_file": "ui/desktop/src/utils/autoUpdater.ts",
    "created_at": "2025-06-11T23:29:15+00:00",
    "commented_code": "+import { autoUpdater, UpdateInfo } from 'electron-updater';\n+import {\n+  BrowserWindow,\n+  ipcMain,\n+  nativeImage,\n+  Tray,\n+  shell,\n+  app,\n+  dialog,\n+  Menu,\n+  MenuItemConstructorOptions,\n+} from 'electron';\n+import * as path from 'path';\n+import * as fs from 'fs/promises';\n+import log from './logger';\n+import { githubUpdater } from './githubUpdater';\n+import { loadRecentDirs } from './recentDirs';\n+\n+let updateAvailable = false;\n+let trayRef: Tray | null = null;\n+let isUsingGitHubFallback = false;\n+let githubUpdateInfo: {\n+  latestVersion?: string;\n+  downloadUrl?: string;\n+  releaseUrl?: string;\n+  downloadPath?: string;\n+  extractedPath?: string;\n+} = {};\n+\n+// Store update state\n+let lastUpdateState: { updateAvailable: boolean; latestVersion?: string } | null = null;\n+\n+// Configure auto-updater\n+export function setupAutoUpdater(tray?: Tray) {\n+  if (tray) {\n+    trayRef = tray;\n+  }\n+\n+  // Set the feed URL for GitHub releases\n+  autoUpdater.setFeedURL({\n+    provider: 'github',\n+    owner: 'block',\n+    repo: 'goose',\n+    releaseType: 'release',\n+  });\n+\n+  // Configure auto-updater settings\n+  autoUpdater.autoDownload = false; // We'll trigger downloads manually\n+  autoUpdater.autoInstallOnAppQuit = true;\n+\n+  // Set logger",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2141261684",
        "repo_full_name": "block/goose",
        "pr_number": 2852,
        "pr_file": "ui/desktop/src/utils/autoUpdater.ts",
        "discussion_id": "2141261684",
        "commented_code": "@@ -0,0 +1,493 @@\n+import { autoUpdater, UpdateInfo } from 'electron-updater';\n+import {\n+  BrowserWindow,\n+  ipcMain,\n+  nativeImage,\n+  Tray,\n+  shell,\n+  app,\n+  dialog,\n+  Menu,\n+  MenuItemConstructorOptions,\n+} from 'electron';\n+import * as path from 'path';\n+import * as fs from 'fs/promises';\n+import log from './logger';\n+import { githubUpdater } from './githubUpdater';\n+import { loadRecentDirs } from './recentDirs';\n+\n+let updateAvailable = false;\n+let trayRef: Tray | null = null;\n+let isUsingGitHubFallback = false;\n+let githubUpdateInfo: {\n+  latestVersion?: string;\n+  downloadUrl?: string;\n+  releaseUrl?: string;\n+  downloadPath?: string;\n+  extractedPath?: string;\n+} = {};\n+\n+// Store update state\n+let lastUpdateState: { updateAvailable: boolean; latestVersion?: string } | null = null;\n+\n+// Configure auto-updater\n+export function setupAutoUpdater(tray?: Tray) {\n+  if (tray) {\n+    trayRef = tray;\n+  }\n+\n+  // Set the feed URL for GitHub releases\n+  autoUpdater.setFeedURL({\n+    provider: 'github',\n+    owner: 'block',\n+    repo: 'goose',\n+    releaseType: 'release',\n+  });\n+\n+  // Configure auto-updater settings\n+  autoUpdater.autoDownload = false; // We'll trigger downloads manually\n+  autoUpdater.autoInstallOnAppQuit = true;\n+\n+  // Set logger",
        "comment_created_at": "2025-06-11T23:29:15+00:00",
        "comment_author": "baxen",
        "comment_body": "this helped me test this out locally - i couldn't get the update check to trigger without it\r\n\r\n```suggestion\r\n  autoUpdater.autoInstallOnAppQuit = true;\r\n\r\n   // Enable updates in development mode for testing\r\n   if (process.env.ENABLE_DEV_UPDATES === 'true') {\r\n     autoUpdater.forceDevUpdateConfig = true;\r\n   }\r\n   \r\n  // Set logger\r\n```",
        "pr_file_module": null
      }
    ]
  }
]