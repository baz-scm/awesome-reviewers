[
  {
    "discussion_id": "2294194965",
    "pr_number": 4282,
    "pr_file": "ui/desktop/src/components/ChatInput.tsx",
    "created_at": "2025-08-22T16:42:26+00:00",
    "commented_code": "return true; // Return true if message was queued\n   };\n \n-  const performSubmit = () => {\n-    const validPastedImageFilesPaths = pastedImages\n-      .filter((img) => img.filePath && !img.error && !img.isLoading)\n-      .map((img) => img.filePath as string);\n-\n-    // Get paths from all dropped files (both parent and local)\n-    const droppedFilePaths = allDroppedFiles\n-      .filter((file) => !file.error && !file.isLoading)\n-      .map((file) => file.path);\n-\n-    let textToSend = displayValue.trim();\n+  const performSubmit = useCallback(\n+    (text?: string) => {\n+      const validPastedImageFilesPaths = pastedImages\n+        .filter((img) => img.filePath && !img.error && !img.isLoading)\n+        .map((img) => img.filePath as string);\n+      // Get paths from all dropped files (both parent and local)\n+      const droppedFilePaths = allDroppedFiles\n+        .filter((file) => !file.error && !file.isLoading)\n+        .map((file) => file.path);\n+\n+      let textToSend = text ?? displayValue.trim();\n+\n+      // Combine pasted images and dropped files\n+      const allFilePaths = [...validPastedImageFilesPaths, ...droppedFilePaths];\n+      if (allFilePaths.length > 0) {\n+        const pathsString = allFilePaths.join(' ');\n+        textToSend = textToSend ? `${textToSend} ${pathsString}` : pathsString;\n+      }\n \n-    // Combine pasted images and dropped files\n-    const allFilePaths = [...validPastedImageFilesPaths, ...droppedFilePaths];\n-    if (allFilePaths.length > 0) {\n-      const pathsString = allFilePaths.join(' ');\n-      textToSend = textToSend ? `${textToSend} ${pathsString}` : pathsString;\n-    }\n+      if (textToSend) {\n+        if (displayValue.trim()) {\n+          LocalMessageStorage.addMessage(displayValue);\n+        } else if (allFilePaths.length > 0) {\n+          LocalMessageStorage.addMessage(allFilePaths.join(' '));\n+        }\n \n-    if (textToSend) {\n-      if (displayValue.trim()) {\n-        LocalMessageStorage.addMessage(displayValue);\n-      } else if (allFilePaths.length > 0) {\n-        LocalMessageStorage.addMessage(allFilePaths.join(' '));\n-      }\n+        handleSubmit(\n+          new CustomEvent('submit', { detail: { value: textToSend } }) as unknown as React.FormEvent\n+        );\n \n-      handleSubmit(\n-        new CustomEvent('submit', { detail: { value: textToSend } }) as unknown as React.FormEvent\n-      );\n+        // Auto-resume queue after sending a NON-interruption message (if it was paused due to interruption)\n+        if (\n+          queuePausedRef.current &&\n+          lastInterruption &&\n+          textToSend &&\n+          !detectInterruption(textToSend)\n+        ) {\n+          queuePausedRef.current = false;\n+          setLastInterruption(null);\n+        }\n \n-      // Auto-resume queue after sending a NON-interruption message (if it was paused due to interruption)\n-      if (\n-        queuePausedRef.current &&\n-        lastInterruption &&\n-        textToSend &&\n-        !detectInterruption(textToSend)\n-      ) {\n-        queuePausedRef.current = false;\n-        setLastInterruption(null);\n-      }\n+        setDisplayValue('');\n+        setValue('');\n+        setPastedImages([]);\n+        setHistoryIndex(-1);\n+        setSavedInput('');\n+        setIsInGlobalHistory(false);\n+        setHasUserTyped(false);\n \n-      setDisplayValue('');\n-      setValue('');\n-      setPastedImages([]);\n-      setHistoryIndex(-1);\n-      setSavedInput('');\n-      setIsInGlobalHistory(false);\n-      setHasUserTyped(false);\n+        // Clear draft when message is sent\n+        if (chatContext && chatContext.clearDraft) {\n+          chatContext.clearDraft();\n+        }\n \n-      // Clear draft when message is sent\n-      if (chatContext && chatContext.clearDraft) {\n-        chatContext.clearDraft();\n+        // Clear both parent and local dropped files after processing\n+        if (onFilesProcessed && droppedFiles.length > 0) {\n+          onFilesProcessed();\n+        }\n+        if (localDroppedFiles.length > 0) {\n+          setLocalDroppedFiles([]);\n+        }\n       }\n+    },\n+    [\n+      allDroppedFiles,\n+      chatContext,\n+      displayValue,\n+      droppedFiles.length,\n+      handleSubmit,\n+      lastInterruption,\n+      localDroppedFiles.length,\n+      onFilesProcessed,\n+      pastedImages,\n+      setLocalDroppedFiles,\n+    ]\n+  );",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2294194965",
        "repo_full_name": "block/goose",
        "pr_number": 4282,
        "pr_file": "ui/desktop/src/components/ChatInput.tsx",
        "discussion_id": "2294194965",
        "commented_code": "@@ -936,69 +942,89 @@ export default function ChatInput({\n     return true; // Return true if message was queued\n   };\n \n-  const performSubmit = () => {\n-    const validPastedImageFilesPaths = pastedImages\n-      .filter((img) => img.filePath && !img.error && !img.isLoading)\n-      .map((img) => img.filePath as string);\n-\n-    // Get paths from all dropped files (both parent and local)\n-    const droppedFilePaths = allDroppedFiles\n-      .filter((file) => !file.error && !file.isLoading)\n-      .map((file) => file.path);\n-\n-    let textToSend = displayValue.trim();\n+  const performSubmit = useCallback(\n+    (text?: string) => {\n+      const validPastedImageFilesPaths = pastedImages\n+        .filter((img) => img.filePath && !img.error && !img.isLoading)\n+        .map((img) => img.filePath as string);\n+      // Get paths from all dropped files (both parent and local)\n+      const droppedFilePaths = allDroppedFiles\n+        .filter((file) => !file.error && !file.isLoading)\n+        .map((file) => file.path);\n+\n+      let textToSend = text ?? displayValue.trim();\n+\n+      // Combine pasted images and dropped files\n+      const allFilePaths = [...validPastedImageFilesPaths, ...droppedFilePaths];\n+      if (allFilePaths.length > 0) {\n+        const pathsString = allFilePaths.join(' ');\n+        textToSend = textToSend ? `${textToSend} ${pathsString}` : pathsString;\n+      }\n \n-    // Combine pasted images and dropped files\n-    const allFilePaths = [...validPastedImageFilesPaths, ...droppedFilePaths];\n-    if (allFilePaths.length > 0) {\n-      const pathsString = allFilePaths.join(' ');\n-      textToSend = textToSend ? `${textToSend} ${pathsString}` : pathsString;\n-    }\n+      if (textToSend) {\n+        if (displayValue.trim()) {\n+          LocalMessageStorage.addMessage(displayValue);\n+        } else if (allFilePaths.length > 0) {\n+          LocalMessageStorage.addMessage(allFilePaths.join(' '));\n+        }\n \n-    if (textToSend) {\n-      if (displayValue.trim()) {\n-        LocalMessageStorage.addMessage(displayValue);\n-      } else if (allFilePaths.length > 0) {\n-        LocalMessageStorage.addMessage(allFilePaths.join(' '));\n-      }\n+        handleSubmit(\n+          new CustomEvent('submit', { detail: { value: textToSend } }) as unknown as React.FormEvent\n+        );\n \n-      handleSubmit(\n-        new CustomEvent('submit', { detail: { value: textToSend } }) as unknown as React.FormEvent\n-      );\n+        // Auto-resume queue after sending a NON-interruption message (if it was paused due to interruption)\n+        if (\n+          queuePausedRef.current &&\n+          lastInterruption &&\n+          textToSend &&\n+          !detectInterruption(textToSend)\n+        ) {\n+          queuePausedRef.current = false;\n+          setLastInterruption(null);\n+        }\n \n-      // Auto-resume queue after sending a NON-interruption message (if it was paused due to interruption)\n-      if (\n-        queuePausedRef.current &&\n-        lastInterruption &&\n-        textToSend &&\n-        !detectInterruption(textToSend)\n-      ) {\n-        queuePausedRef.current = false;\n-        setLastInterruption(null);\n-      }\n+        setDisplayValue('');\n+        setValue('');\n+        setPastedImages([]);\n+        setHistoryIndex(-1);\n+        setSavedInput('');\n+        setIsInGlobalHistory(false);\n+        setHasUserTyped(false);\n \n-      setDisplayValue('');\n-      setValue('');\n-      setPastedImages([]);\n-      setHistoryIndex(-1);\n-      setSavedInput('');\n-      setIsInGlobalHistory(false);\n-      setHasUserTyped(false);\n+        // Clear draft when message is sent\n+        if (chatContext && chatContext.clearDraft) {\n+          chatContext.clearDraft();\n+        }\n \n-      // Clear draft when message is sent\n-      if (chatContext && chatContext.clearDraft) {\n-        chatContext.clearDraft();\n+        // Clear both parent and local dropped files after processing\n+        if (onFilesProcessed && droppedFiles.length > 0) {\n+          onFilesProcessed();\n+        }\n+        if (localDroppedFiles.length > 0) {\n+          setLocalDroppedFiles([]);\n+        }\n       }\n+    },\n+    [\n+      allDroppedFiles,\n+      chatContext,\n+      displayValue,\n+      droppedFiles.length,\n+      handleSubmit,\n+      lastInterruption,\n+      localDroppedFiles.length,\n+      onFilesProcessed,\n+      pastedImages,\n+      setLocalDroppedFiles,\n+    ]\n+  );",
        "comment_created_at": "2025-08-22T16:42:26+00:00",
        "comment_author": "DOsinga",
        "comment_body": "what happened here? did we not get warnings about this?",
        "pr_file_module": null
      },
      {
        "comment_id": "2294203725",
        "repo_full_name": "block/goose",
        "pr_number": 4282,
        "pr_file": "ui/desktop/src/components/ChatInput.tsx",
        "discussion_id": "2294194965",
        "commented_code": "@@ -936,69 +942,89 @@ export default function ChatInput({\n     return true; // Return true if message was queued\n   };\n \n-  const performSubmit = () => {\n-    const validPastedImageFilesPaths = pastedImages\n-      .filter((img) => img.filePath && !img.error && !img.isLoading)\n-      .map((img) => img.filePath as string);\n-\n-    // Get paths from all dropped files (both parent and local)\n-    const droppedFilePaths = allDroppedFiles\n-      .filter((file) => !file.error && !file.isLoading)\n-      .map((file) => file.path);\n-\n-    let textToSend = displayValue.trim();\n+  const performSubmit = useCallback(\n+    (text?: string) => {\n+      const validPastedImageFilesPaths = pastedImages\n+        .filter((img) => img.filePath && !img.error && !img.isLoading)\n+        .map((img) => img.filePath as string);\n+      // Get paths from all dropped files (both parent and local)\n+      const droppedFilePaths = allDroppedFiles\n+        .filter((file) => !file.error && !file.isLoading)\n+        .map((file) => file.path);\n+\n+      let textToSend = text ?? displayValue.trim();\n+\n+      // Combine pasted images and dropped files\n+      const allFilePaths = [...validPastedImageFilesPaths, ...droppedFilePaths];\n+      if (allFilePaths.length > 0) {\n+        const pathsString = allFilePaths.join(' ');\n+        textToSend = textToSend ? `${textToSend} ${pathsString}` : pathsString;\n+      }\n \n-    // Combine pasted images and dropped files\n-    const allFilePaths = [...validPastedImageFilesPaths, ...droppedFilePaths];\n-    if (allFilePaths.length > 0) {\n-      const pathsString = allFilePaths.join(' ');\n-      textToSend = textToSend ? `${textToSend} ${pathsString}` : pathsString;\n-    }\n+      if (textToSend) {\n+        if (displayValue.trim()) {\n+          LocalMessageStorage.addMessage(displayValue);\n+        } else if (allFilePaths.length > 0) {\n+          LocalMessageStorage.addMessage(allFilePaths.join(' '));\n+        }\n \n-    if (textToSend) {\n-      if (displayValue.trim()) {\n-        LocalMessageStorage.addMessage(displayValue);\n-      } else if (allFilePaths.length > 0) {\n-        LocalMessageStorage.addMessage(allFilePaths.join(' '));\n-      }\n+        handleSubmit(\n+          new CustomEvent('submit', { detail: { value: textToSend } }) as unknown as React.FormEvent\n+        );\n \n-      handleSubmit(\n-        new CustomEvent('submit', { detail: { value: textToSend } }) as unknown as React.FormEvent\n-      );\n+        // Auto-resume queue after sending a NON-interruption message (if it was paused due to interruption)\n+        if (\n+          queuePausedRef.current &&\n+          lastInterruption &&\n+          textToSend &&\n+          !detectInterruption(textToSend)\n+        ) {\n+          queuePausedRef.current = false;\n+          setLastInterruption(null);\n+        }\n \n-      // Auto-resume queue after sending a NON-interruption message (if it was paused due to interruption)\n-      if (\n-        queuePausedRef.current &&\n-        lastInterruption &&\n-        textToSend &&\n-        !detectInterruption(textToSend)\n-      ) {\n-        queuePausedRef.current = false;\n-        setLastInterruption(null);\n-      }\n+        setDisplayValue('');\n+        setValue('');\n+        setPastedImages([]);\n+        setHistoryIndex(-1);\n+        setSavedInput('');\n+        setIsInGlobalHistory(false);\n+        setHasUserTyped(false);\n \n-      setDisplayValue('');\n-      setValue('');\n-      setPastedImages([]);\n-      setHistoryIndex(-1);\n-      setSavedInput('');\n-      setIsInGlobalHistory(false);\n-      setHasUserTyped(false);\n+        // Clear draft when message is sent\n+        if (chatContext && chatContext.clearDraft) {\n+          chatContext.clearDraft();\n+        }\n \n-      // Clear draft when message is sent\n-      if (chatContext && chatContext.clearDraft) {\n-        chatContext.clearDraft();\n+        // Clear both parent and local dropped files after processing\n+        if (onFilesProcessed && droppedFiles.length > 0) {\n+          onFilesProcessed();\n+        }\n+        if (localDroppedFiles.length > 0) {\n+          setLocalDroppedFiles([]);\n+        }\n       }\n+    },\n+    [\n+      allDroppedFiles,\n+      chatContext,\n+      displayValue,\n+      droppedFiles.length,\n+      handleSubmit,\n+      lastInterruption,\n+      localDroppedFiles.length,\n+      onFilesProcessed,\n+      pastedImages,\n+      setLocalDroppedFiles,\n+    ]\n+  );",
        "comment_created_at": "2025-08-22T16:47:56+00:00",
        "comment_author": "jamadeo",
        "comment_body": "The key change here is running performSubmit() in a useEffect, but in order to do that I wrapped that in a useCallback, and that meant enumerating its dependencies.\n\nWe could have gotten away with keeping this a function re-created on every render, since the submit effect should only actually do something just once anyway, but we'd have to suppress some warnings and potentially invite some future bugs. Using hooks for all of them seemed the right way to go",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288825603",
    "pr_number": 4207,
    "pr_file": "ui/desktop/src/components/ChatInput.tsx",
    "created_at": "2025-08-20T17:19:08+00:00",
    "commented_code": "setHasUserTyped(false);\n   }, [initialValue]); // Keep only initialValue as a dependency\n \n+  // Track if we've already set the recipe prompt to avoid re-setting it\n+  const hasSetRecipePromptRef = useRef(false);\n+\n   // Handle recipe prompt updates\n   useEffect(() => {\n-    // If recipe is accepted and we have an initial prompt, and no messages yet, set the prompt\n-    if (recipeAccepted && initialPrompt && messages.length === 0 && !displayValue.trim()) {\n+    // If recipe is accepted and we have an initial prompt, and no messages yet, and we haven't set it before\n+    if (\n+      recipeAccepted &&\n+      initialPrompt &&\n+      messages.length === 0 &&\n+      !hasSetRecipePromptRef.current\n+    ) {\n       setDisplayValue(initialPrompt);\n       setValue(initialPrompt);\n+      hasSetRecipePromptRef.current = true;\n       setTimeout(() => {\n         textAreaRef.current?.focus();\n       }, 0);\n     }\n-  }, [recipeAccepted, initialPrompt, messages.length, displayValue]);\n+  }, [recipeAccepted, initialPrompt, messages.length]);",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2288825603",
        "repo_full_name": "block/goose",
        "pr_number": 4207,
        "pr_file": "ui/desktop/src/components/ChatInput.tsx",
        "discussion_id": "2288825603",
        "commented_code": "@@ -203,17 +203,33 @@ export default function ChatInput({\n     setHasUserTyped(false);\n   }, [initialValue]); // Keep only initialValue as a dependency\n \n+  // Track if we've already set the recipe prompt to avoid re-setting it\n+  const hasSetRecipePromptRef = useRef(false);\n+\n   // Handle recipe prompt updates\n   useEffect(() => {\n-    // If recipe is accepted and we have an initial prompt, and no messages yet, set the prompt\n-    if (recipeAccepted && initialPrompt && messages.length === 0 && !displayValue.trim()) {\n+    // If recipe is accepted and we have an initial prompt, and no messages yet, and we haven't set it before\n+    if (\n+      recipeAccepted &&\n+      initialPrompt &&\n+      messages.length === 0 &&\n+      !hasSetRecipePromptRef.current\n+    ) {\n       setDisplayValue(initialPrompt);\n       setValue(initialPrompt);\n+      hasSetRecipePromptRef.current = true;\n       setTimeout(() => {\n         textAreaRef.current?.focus();\n       }, 0);\n     }\n-  }, [recipeAccepted, initialPrompt, messages.length, displayValue]);\n+  }, [recipeAccepted, initialPrompt, messages.length]);",
        "comment_created_at": "2025-08-20T17:19:08+00:00",
        "comment_author": "alexhancock",
        "comment_body": "don't we need `hasSetRecipePromptRef` in the deps here?",
        "pr_file_module": null
      },
      {
        "comment_id": "2289273060",
        "repo_full_name": "block/goose",
        "pr_number": 4207,
        "pr_file": "ui/desktop/src/components/ChatInput.tsx",
        "discussion_id": "2288825603",
        "commented_code": "@@ -203,17 +203,33 @@ export default function ChatInput({\n     setHasUserTyped(false);\n   }, [initialValue]); // Keep only initialValue as a dependency\n \n+  // Track if we've already set the recipe prompt to avoid re-setting it\n+  const hasSetRecipePromptRef = useRef(false);\n+\n   // Handle recipe prompt updates\n   useEffect(() => {\n-    // If recipe is accepted and we have an initial prompt, and no messages yet, set the prompt\n-    if (recipeAccepted && initialPrompt && messages.length === 0 && !displayValue.trim()) {\n+    // If recipe is accepted and we have an initial prompt, and no messages yet, and we haven't set it before\n+    if (\n+      recipeAccepted &&\n+      initialPrompt &&\n+      messages.length === 0 &&\n+      !hasSetRecipePromptRef.current\n+    ) {\n       setDisplayValue(initialPrompt);\n       setValue(initialPrompt);\n+      hasSetRecipePromptRef.current = true;\n       setTimeout(() => {\n         textAreaRef.current?.focus();\n       }, 0);\n     }\n-  }, [recipeAccepted, initialPrompt, messages.length, displayValue]);\n+  }, [recipeAccepted, initialPrompt, messages.length]);",
        "comment_created_at": "2025-08-20T20:53:25+00:00",
        "comment_author": "zanesq",
        "comment_body": "no its not needed because its a ref object so it doesn't change only the `.current` property changes but changes to `.current` in refs don't trigger re-renders anyway. I added a comment for futuredev",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2280021859",
    "pr_number": 4072,
    "pr_file": "ui/desktop/src/components/pair.tsx",
    "created_at": "2025-08-15T23:24:59+00:00",
    "commented_code": "// Clear the location state to prevent re-processing\n       window.history.replaceState({}, '', '/pair');\n     }\n-  }, [location.state, chat.id, setChat]);\n+    // eslint-disable-next-line react-hooks/exhaustive-deps",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2280021859",
        "repo_full_name": "block/goose",
        "pr_number": 4072,
        "pr_file": "ui/desktop/src/components/pair.tsx",
        "discussion_id": "2280021859",
        "commented_code": "@@ -76,7 +76,8 @@ export default function Pair({\n       // Clear the location state to prevent re-processing\n       window.history.replaceState({}, '', '/pair');\n     }\n-  }, [location.state, chat.id, setChat]);\n+    // eslint-disable-next-line react-hooks/exhaustive-deps",
        "comment_created_at": "2025-08-15T23:24:59+00:00",
        "comment_author": "zanesq",
        "comment_body": "These setters aren't needed, React guarantees that state setter functions, such as the setState function returned by the useState hook, maintain referential stability across re-renders. This means that the identity of the setter function itself does not change between renders.",
        "pr_file_module": null
      }
    ]
  }
]