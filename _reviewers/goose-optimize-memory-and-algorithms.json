[
  {
    "discussion_id": "2267645727",
    "pr_number": 3902,
    "pr_file": "crates/goose/src/agents/agent.rs",
    "created_at": "2025-08-11T18:30:10+00:00",
    "commented_code": "}\n \n impl Agent {\n+    const DEFAULT_TODO_MAX_CHARS: usize = 50_000;",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2267645727",
        "repo_full_name": "block/goose",
        "pr_number": 3902,
        "pr_file": "crates/goose/src/agents/agent.rs",
        "discussion_id": "2267645727",
        "commented_code": "@@ -148,6 +152,15 @@ where\n }\n \n impl Agent {\n+    const DEFAULT_TODO_MAX_CHARS: usize = 50_000;",
        "comment_created_at": "2025-08-11T18:30:10+00:00",
        "comment_author": "katzdave",
        "comment_body": "Seems really large? Maybe ~5k?",
        "pr_file_module": null
      },
      {
        "comment_id": "2267808351",
        "repo_full_name": "block/goose",
        "pr_number": 3902,
        "pr_file": "crates/goose/src/agents/agent.rs",
        "discussion_id": "2267645727",
        "commented_code": "@@ -148,6 +152,15 @@ where\n }\n \n impl Agent {\n+    const DEFAULT_TODO_MAX_CHARS: usize = 50_000;",
        "comment_created_at": "2025-08-11T19:27:41+00:00",
        "comment_author": "tlongwell-block",
        "comment_body": "I was mostly thinking about ensuring the overall memory usage is tiny by default while still letting the agent have a lot of scratch space if it actually wanted to use it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2246574965",
    "pr_number": 3750,
    "pr_file": "crates/goose-mcp/src/developer/mod.rs",
    "created_at": "2025-07-31T23:38:25+00:00",
    "commented_code": "self.ignore_patterns.matched(path, false).is_ignore()\n     }\n \n+    // shell output can be large, this will help manage that\n+    fn process_shell_output(&self, output_str: &str) -> Result<(String, String), ToolError> {\n+        let lines: Vec<&str> = output_str.lines().collect();\n+        let line_count = lines.len();\n+\n+        let final_output = if line_count > 100 {\n+            let tmp_file = tempfile::NamedTempFile::new().map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to create temporary file: {}\", e))\n+            })?;\n+\n+            std::fs::write(tmp_file.path(), output_str).map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to write to temporary file: {}\", e))\n+            })?;\n+\n+            let (_, path) = tmp_file.keep().map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to persist temporary file: {}\", e))\n+            })?;\n+\n+            let last_100_lines: Vec<&str> = lines.iter().rev().take(100).rev().copied().collect();\n+\n+            format!(\n+                \"private note: output was {} lines and we are only showing the most recent lines, remainder of lines in {}. do not show tmp file to user, that file can be searched if extra context needed to fulfill request. truncated output: \n{}\",\n+                line_count,\n+                path.display(),\n+                last_100_lines.join(\"\n\")",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2246574965",
        "repo_full_name": "block/goose",
        "pr_number": 3750,
        "pr_file": "crates/goose-mcp/src/developer/mod.rs",
        "discussion_id": "2246574965",
        "commented_code": "@@ -594,6 +594,46 @@ impl DeveloperRouter {\n         self.ignore_patterns.matched(path, false).is_ignore()\n     }\n \n+    // shell output can be large, this will help manage that\n+    fn process_shell_output(&self, output_str: &str) -> Result<(String, String), ToolError> {\n+        let lines: Vec<&str> = output_str.lines().collect();\n+        let line_count = lines.len();\n+\n+        let final_output = if line_count > 100 {\n+            let tmp_file = tempfile::NamedTempFile::new().map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to create temporary file: {}\", e))\n+            })?;\n+\n+            std::fs::write(tmp_file.path(), output_str).map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to write to temporary file: {}\", e))\n+            })?;\n+\n+            let (_, path) = tmp_file.keep().map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to persist temporary file: {}\", e))\n+            })?;\n+\n+            let last_100_lines: Vec<&str> = lines.iter().rev().take(100).rev().copied().collect();\n+\n+            format!(\n+                \"private note: output was {} lines and we are only showing the most recent lines, remainder of lines in {}. do not show tmp file to user, that file can be searched if extra context needed to fulfill request. truncated output: \\n{}\",\n+                line_count,\n+                path.display(),\n+                last_100_lines.join(\"\\n\")",
        "comment_created_at": "2025-07-31T23:38:25+00:00",
        "comment_author": "cgwalters",
        "comment_body": "Not that this truly matters but since we're talking about efficiency, you don't need to collect into the intermediate Vec above to do this.\n\nI asked Gemini e.g. and it came up with\n\n```\n// Calculate the start index, preventing underflow if lines < 100\nlet start = lines.len().saturating_sub(100);\n\n// Slice the lines and join them into a string directly\nlet last_100_lines_str = lines[start..].join(\"\\n\");\n```\n\nBut even then we can still optimize further by using `format!` for the message and then appending each line to the string.\n\nAlso...in this whole vein we probably want to handle pathological cases like extremely long lines.\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2246711483",
        "repo_full_name": "block/goose",
        "pr_number": 3750,
        "pr_file": "crates/goose-mcp/src/developer/mod.rs",
        "discussion_id": "2246574965",
        "commented_code": "@@ -594,6 +594,46 @@ impl DeveloperRouter {\n         self.ignore_patterns.matched(path, false).is_ignore()\n     }\n \n+    // shell output can be large, this will help manage that\n+    fn process_shell_output(&self, output_str: &str) -> Result<(String, String), ToolError> {\n+        let lines: Vec<&str> = output_str.lines().collect();\n+        let line_count = lines.len();\n+\n+        let final_output = if line_count > 100 {\n+            let tmp_file = tempfile::NamedTempFile::new().map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to create temporary file: {}\", e))\n+            })?;\n+\n+            std::fs::write(tmp_file.path(), output_str).map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to write to temporary file: {}\", e))\n+            })?;\n+\n+            let (_, path) = tmp_file.keep().map_err(|e| {\n+                ToolError::ExecutionError(format!(\"Failed to persist temporary file: {}\", e))\n+            })?;\n+\n+            let last_100_lines: Vec<&str> = lines.iter().rev().take(100).rev().copied().collect();\n+\n+            format!(\n+                \"private note: output was {} lines and we are only showing the most recent lines, remainder of lines in {}. do not show tmp file to user, that file can be searched if extra context needed to fulfill request. truncated output: \\n{}\",\n+                line_count,\n+                path.display(),\n+                last_100_lines.join(\"\\n\")",
        "comment_created_at": "2025-08-01T01:47:31+00:00",
        "comment_author": "michaelneale",
        "comment_body": "yeah efficiency here isn't really the rust side, but could be tweaked, good catch. \r\n\r\nyes long lines - I think can do another PR for that, as I have seen that (ie ask goose to look at your session jsonl files - they are long! Would like to address that. Perhaps along with the text_editor_view tool as well?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2239019694",
    "pr_number": 3269,
    "pr_file": "crates/goose-mcp/src/developer/mod.rs",
    "created_at": "2025-07-29T08:45:49+00:00",
    "commented_code": "},\n         };\n \n-        // choose_app_strategy().config_dir()\n-        // - macOS/Linux: ~/.config/goose/\n-        // - Windows:     ~\\AppData\\Roaming\\Block\\goose\\config\\\n-        // keep previous behavior of expanding ~/.config in case this fails\n-        let global_hints_path = choose_app_strategy(crate::APP_STRATEGY.clone())\n-            .map(|strategy| strategy.in_config_dir(\".goosehints\"))\n-            .unwrap_or_else(|_| {\n-                PathBuf::from(shellexpand::tilde(\"~/.config/goose/.goosehints\").to_string())\n-            });\n+        let hints_filenames: Vec<String> = std::env::var(\"CONTEXT_FILE_NAMES\")\n+            .ok()\n+            .and_then(|s| serde_json::from_str(&s).ok())\n+            .unwrap_or_else(|| vec![\".goosehints\".to_string()]);\n+\n+        let mut global_hints_contents = Vec::new();\n+        let mut local_hints_contents = Vec::new();",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2239019694",
        "repo_full_name": "block/goose",
        "pr_number": 3269,
        "pr_file": "crates/goose-mcp/src/developer/mod.rs",
        "discussion_id": "2239019694",
        "commented_code": "@@ -468,40 +468,59 @@ impl DeveloperRouter {\n             },\n         };\n \n-        // choose_app_strategy().config_dir()\n-        // - macOS/Linux: ~/.config/goose/\n-        // - Windows:     ~\\AppData\\Roaming\\Block\\goose\\config\\\n-        // keep previous behavior of expanding ~/.config in case this fails\n-        let global_hints_path = choose_app_strategy(crate::APP_STRATEGY.clone())\n-            .map(|strategy| strategy.in_config_dir(\".goosehints\"))\n-            .unwrap_or_else(|_| {\n-                PathBuf::from(shellexpand::tilde(\"~/.config/goose/.goosehints\").to_string())\n-            });\n+        let hints_filenames: Vec<String> = std::env::var(\"CONTEXT_FILE_NAMES\")\n+            .ok()\n+            .and_then(|s| serde_json::from_str(&s).ok())\n+            .unwrap_or_else(|| vec![\".goosehints\".to_string()]);\n+\n+        let mut global_hints_contents = Vec::new();\n+        let mut local_hints_contents = Vec::new();",
        "comment_created_at": "2025-07-29T08:45:49+00:00",
        "comment_author": "DOsinga",
        "comment_body": "we could pre-allocate those since we know the number of files",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154859515",
    "pr_number": 2982,
    "pr_file": "crates/goose/src/agents/sub_recipe_manager.rs",
    "created_at": "2025-06-18T15:05:13+00:00",
    "commented_code": "+use mcp_core::{Content, Tool, ToolError};\n+use serde_json::Value;\n+use std::collections::HashMap;\n+\n+use crate::{\n+    agents::recipe_tools::sub_recipe_tools::{\n+        create_sub_recipe_tool, run_sub_recipe, SUB_RECIPE_TOOL_NAME_PREFIX,\n+    },\n+    recipe::SubRecipe,\n+};\n+\n+#[derive(Debug, Clone)]\n+pub struct SubRecipeManager {\n+    pub sub_recipe_tools: HashMap<String, Tool>,\n+    pub sub_recipes: HashMap<String, SubRecipe>,\n+}\n+\n+impl Default for SubRecipeManager {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl SubRecipeManager {\n+    pub fn new() -> Self {\n+        Self {\n+            sub_recipe_tools: HashMap::new(),\n+            sub_recipes: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn add_sub_recipe_tools(&mut self, sub_recipes_to_add: Vec<SubRecipe>) {\n+        for sub_recipe in sub_recipes_to_add {\n+            let sub_recipe_name = sub_recipe.name.clone();\n+            let tool = create_sub_recipe_tool(&sub_recipe);\n+            self.sub_recipe_tools.insert(sub_recipe_name.clone(), tool);\n+            self.sub_recipes.insert(sub_recipe_name, sub_recipe);\n+        }\n+    }\n+\n+    pub fn is_sub_recipe_tool(&self, tool_name: &str) -> bool {\n+        tool_name.starts_with(SUB_RECIPE_TOOL_NAME_PREFIX)",
    "repo_full_name": "block/goose",
    "discussion_comments": [
      {
        "comment_id": "2154859515",
        "repo_full_name": "block/goose",
        "pr_number": 2982,
        "pr_file": "crates/goose/src/agents/sub_recipe_manager.rs",
        "discussion_id": "2154859515",
        "commented_code": "@@ -0,0 +1,69 @@\n+use mcp_core::{Content, Tool, ToolError};\n+use serde_json::Value;\n+use std::collections::HashMap;\n+\n+use crate::{\n+    agents::recipe_tools::sub_recipe_tools::{\n+        create_sub_recipe_tool, run_sub_recipe, SUB_RECIPE_TOOL_NAME_PREFIX,\n+    },\n+    recipe::SubRecipe,\n+};\n+\n+#[derive(Debug, Clone)]\n+pub struct SubRecipeManager {\n+    pub sub_recipe_tools: HashMap<String, Tool>,\n+    pub sub_recipes: HashMap<String, SubRecipe>,\n+}\n+\n+impl Default for SubRecipeManager {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl SubRecipeManager {\n+    pub fn new() -> Self {\n+        Self {\n+            sub_recipe_tools: HashMap::new(),\n+            sub_recipes: HashMap::new(),\n+        }\n+    }\n+\n+    pub fn add_sub_recipe_tools(&mut self, sub_recipes_to_add: Vec<SubRecipe>) {\n+        for sub_recipe in sub_recipes_to_add {\n+            let sub_recipe_name = sub_recipe.name.clone();\n+            let tool = create_sub_recipe_tool(&sub_recipe);\n+            self.sub_recipe_tools.insert(sub_recipe_name.clone(), tool);\n+            self.sub_recipes.insert(sub_recipe_name, sub_recipe);\n+        }\n+    }\n+\n+    pub fn is_sub_recipe_tool(&self, tool_name: &str) -> bool {\n+        tool_name.starts_with(SUB_RECIPE_TOOL_NAME_PREFIX)",
        "comment_created_at": "2025-06-18T15:05:13+00:00",
        "comment_author": "jamadeo",
        "comment_body": "here you might as well just test for membership in the map, rather than the prefix",
        "pr_file_module": null
      }
    ]
  }
]