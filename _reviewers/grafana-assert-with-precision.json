[
  {
    "discussion_id": "2180422922",
    "pr_number": 107004,
    "pr_file": "pkg/services/ngalert/remote/alertmanager_test.go",
    "created_at": "2025-07-02T15:55:20+00:00",
    "commented_code": "}\n }\n \n+func TestApplyConfigWithExtraConfigs(t *testing.T) {\n+\tconst tenantID = \"test\"\n+\n+\tvar configSent client.UserGrafanaConfig\n+\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\trequire.Equal(t, tenantID, r.Header.Get(client.MimirTenantHeader))\n+\t\trequire.Equal(t, \"true\", r.Header.Get(client.RemoteAlertmanagerHeader))\n+\n+\t\tif r.Method == http.MethodPost && strings.Contains(r.URL.Path, \"/config\") {\n+\t\t\trequire.NoError(t, json.NewDecoder(r.Body).Decode(&configSent))\n+\t\t}\n+\n+\t\tw.Header().Add(\"content-type\", \"application/json\")\n+\t\trequire.NoError(t, json.NewEncoder(w).Encode(map[string]string{\"status\": \"success\"}))\n+\t}))\n+\tdefer server.Close()\n+\n+\tvar cfg apimodels.PostableUserConfig\n+\trequire.NoError(t, json.Unmarshal([]byte(testGrafanaConfig), &cfg))\n+\n+\tcfg.ExtraConfigs = []apimodels.ExtraConfiguration{\n+\t\t{\n+\t\t\tIdentifier: \"test-external\",\n+\t\t\tMergeMatchers: []*labels.Matcher{\n+\t\t\t\t{\n+\t\t\t\t\tType:  labels.MatchEqual,\n+\t\t\t\t\tName:  \"test\",\n+\t\t\t\t\tValue: \"value\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tTemplateFiles: map[string]string{},\n+\t\t\tAlertmanagerConfig: `global:\n+  smtp_smarthost: localhost:587\n+  smtp_from: alerts@grafana.com\n+route:\n+  receiver: extra-receiver\n+receivers:\n+  - name: extra-receiver\n+    email_configs:\n+      - to: alerts@grafana.com`,\n+\t\t},\n+\t}\n+\n+\tsecretsService := secretsManager.SetupTestService(t, database.ProvideSecretsStore(db.InitTestDB(t)))\n+\ttc := notifier.NewCrypto(secretsService, nil, log.NewNopLogger())\n+\tctx := context.Background()\n+\n+\tc := AlertmanagerConfig{\n+\t\tOrgID:         1,\n+\t\tTenantID:      tenantID,\n+\t\tURL:           server.URL,\n+\t\tDefaultConfig: defaultGrafanaConfig,\n+\t\tPromoteConfig: true,\n+\t}\n+\n+\tstore := ngfakes.NewFakeKVStore(t)\n+\tfstore := notifier.NewFileStore(1, store)\n+\trequire.NoError(t, store.Set(ctx, c.OrgID, \"alertmanager\", notifier.SilencesFilename, \"\"))\n+\trequire.NoError(t, store.Set(ctx, c.OrgID, \"alertmanager\", notifier.NotificationLogFilename, \"\"))\n+\n+\tm := metrics.NewRemoteAlertmanagerMetrics(prometheus.NewRegistry())\n+\tam, err := NewAlertmanager(ctx, c, fstore, tc, NoopAutogenFn, m, tracing.InitializeTracerForTest())\n+\trequire.NoError(t, err)",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2180422922",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107004,
        "pr_file": "pkg/services/ngalert/remote/alertmanager_test.go",
        "discussion_id": "2180422922",
        "commented_code": "@@ -561,6 +564,198 @@ func Test_isDefaultConfiguration(t *testing.T) {\n \t}\n }\n \n+func TestApplyConfigWithExtraConfigs(t *testing.T) {\n+\tconst tenantID = \"test\"\n+\n+\tvar configSent client.UserGrafanaConfig\n+\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\trequire.Equal(t, tenantID, r.Header.Get(client.MimirTenantHeader))\n+\t\trequire.Equal(t, \"true\", r.Header.Get(client.RemoteAlertmanagerHeader))\n+\n+\t\tif r.Method == http.MethodPost && strings.Contains(r.URL.Path, \"/config\") {\n+\t\t\trequire.NoError(t, json.NewDecoder(r.Body).Decode(&configSent))\n+\t\t}\n+\n+\t\tw.Header().Add(\"content-type\", \"application/json\")\n+\t\trequire.NoError(t, json.NewEncoder(w).Encode(map[string]string{\"status\": \"success\"}))\n+\t}))\n+\tdefer server.Close()\n+\n+\tvar cfg apimodels.PostableUserConfig\n+\trequire.NoError(t, json.Unmarshal([]byte(testGrafanaConfig), &cfg))\n+\n+\tcfg.ExtraConfigs = []apimodels.ExtraConfiguration{\n+\t\t{\n+\t\t\tIdentifier: \"test-external\",\n+\t\t\tMergeMatchers: []*labels.Matcher{\n+\t\t\t\t{\n+\t\t\t\t\tType:  labels.MatchEqual,\n+\t\t\t\t\tName:  \"test\",\n+\t\t\t\t\tValue: \"value\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tTemplateFiles: map[string]string{},\n+\t\t\tAlertmanagerConfig: `global:\n+  smtp_smarthost: localhost:587\n+  smtp_from: alerts@grafana.com\n+route:\n+  receiver: extra-receiver\n+receivers:\n+  - name: extra-receiver\n+    email_configs:\n+      - to: alerts@grafana.com`,\n+\t\t},\n+\t}\n+\n+\tsecretsService := secretsManager.SetupTestService(t, database.ProvideSecretsStore(db.InitTestDB(t)))\n+\ttc := notifier.NewCrypto(secretsService, nil, log.NewNopLogger())\n+\tctx := context.Background()\n+\n+\tc := AlertmanagerConfig{\n+\t\tOrgID:         1,\n+\t\tTenantID:      tenantID,\n+\t\tURL:           server.URL,\n+\t\tDefaultConfig: defaultGrafanaConfig,\n+\t\tPromoteConfig: true,\n+\t}\n+\n+\tstore := ngfakes.NewFakeKVStore(t)\n+\tfstore := notifier.NewFileStore(1, store)\n+\trequire.NoError(t, store.Set(ctx, c.OrgID, \"alertmanager\", notifier.SilencesFilename, \"\"))\n+\trequire.NoError(t, store.Set(ctx, c.OrgID, \"alertmanager\", notifier.NotificationLogFilename, \"\"))\n+\n+\tm := metrics.NewRemoteAlertmanagerMetrics(prometheus.NewRegistry())\n+\tam, err := NewAlertmanager(ctx, c, fstore, tc, NoopAutogenFn, m, tracing.InitializeTracerForTest())\n+\trequire.NoError(t, err)",
        "comment_created_at": "2025-07-02T15:55:20+00:00",
        "comment_author": "yuri-tceretian",
        "comment_body": "I think the more correct asserts in this tests would be checking what the server receives. Similar to what you do in the test below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2177606430",
    "pr_number": 107305,
    "pr_file": "pkg/storage/unified/resource/storage_backend_test.go",
    "created_at": "2025-07-01T13:26:11+00:00",
    "commented_code": "+package resource\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n+\n+\t\"github.com/grafana/grafana/pkg/apimachinery/utils\"\n+\t\"github.com/grafana/grafana/pkg/storage/unified/resourcepb\"\n+)\n+\n+func setupTestStorageBackend(t *testing.T) *kvStorageBackend {\n+\tkv := setupTestKV(t)\n+\treturn NewkvStorageBackend(kv)\n+}\n+\n+func TestNewkvStorageBackend(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\n+\tassert.NotNil(t, backend)\n+\tassert.NotNil(t, backend.kv)\n+\tassert.NotNil(t, backend.dataStore)\n+\tassert.NotNil(t, backend.metaStore)\n+\tassert.NotNil(t, backend.eventStore)\n+\tassert.NotNil(t, backend.notifier)\n+\tassert.NotNil(t, backend.snowflake)\n+}\n+\n+func TestKvStorageBackend_WriteEvent_Success(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\ttests := []struct {\n+\t\tname      string\n+\t\teventType resourcepb.WatchEvent_Type\n+\t}{\n+\t\t{\n+\t\t\tname:      \"write ADDED event\",\n+\t\t\teventType: resourcepb.WatchEvent_ADDED,\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"write MODIFIED event\",\n+\t\t\teventType: resourcepb.WatchEvent_MODIFIED,\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"write DELETED event\",\n+\t\t\teventType: resourcepb.WatchEvent_DELETED,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\ttestObj, err := createTestObject()\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\twriteEvent := WriteEvent{\n+\t\t\t\tType: tt.eventType,\n+\t\t\t\tKey: &resourcepb.ResourceKey{\n+\t\t\t\t\tNamespace: \"default\",\n+\t\t\t\t\tGroup:     \"apps\",\n+\t\t\t\t\tResource:  \"resource\",\n+\t\t\t\t\tName:      \"test-resource\",\n+\t\t\t\t},\n+\t\t\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\t\t\tObject:     metaAccessor,\n+\t\t\t\tPreviousRV: 100,\n+\t\t\t}\n+\n+\t\t\trv, err := backend.WriteEvent(ctx, writeEvent)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tassert.Greater(t, rv, int64(0), \"resource version should be positive\")\n+\n+\t\t\t// Verify data was written to dataStore\n+\t\t\tvar expectedAction DataAction\n+\t\t\tswitch tt.eventType {\n+\t\t\tcase resourcepb.WatchEvent_ADDED:\n+\t\t\t\texpectedAction = DataActionCreated\n+\t\t\tcase resourcepb.WatchEvent_MODIFIED:\n+\t\t\t\texpectedAction = DataActionUpdated\n+\t\t\tcase resourcepb.WatchEvent_DELETED:\n+\t\t\t\texpectedAction = DataActionDeleted\n+\t\t\tdefault:\n+\t\t\t\tt.Fatalf(\"unexpected event type: %v\", tt.eventType)\n+\t\t\t}\n+\n+\t\t\tdataKey := DataKey{\n+\t\t\t\tNamespace:       \"default\",\n+\t\t\t\tGroup:           \"apps\",\n+\t\t\t\tResource:        \"resource\",\n+\t\t\t\tName:            \"test-resource\",\n+\t\t\t\tResourceVersion: rv,\n+\t\t\t\tAction:          expectedAction,\n+\t\t\t}\n+\n+\t\t\tdataReader, err := backend.dataStore.Get(ctx, dataKey)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tdataValue, err := io.ReadAll(dataReader)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tassert.Equal(t, objectToJSONBytes(t, testObj), dataValue)\n+\n+\t\t\t// Verify metadata was written to metaStore\n+\t\t\tmetaKey := MetaDataKey{\n+\t\t\t\tNamespace:       \"default\",\n+\t\t\t\tGroup:           \"apps\",\n+\t\t\t\tResource:        \"resource\",\n+\t\t\t\tName:            \"test-resource\",\n+\t\t\t\tResourceVersion: rv,\n+\t\t\t\tAction:          expectedAction,\n+\t\t\t\tFolder:          \"\",\n+\t\t\t}\n+\n+\t\t\tm, err := backend.metaStore.Get(ctx, metaKey)\n+\t\t\trequire.NoError(t, err)\n+\t\t\trequire.NotNil(t, m)\n+\t\t\trequire.Equal(t, \"test-resource\", m.Key.Name)\n+\t\t\trequire.Equal(t, \"default\", m.Key.Namespace)\n+\t\t\trequire.Equal(t, \"apps\", m.Key.Group)\n+\t\t\trequire.Equal(t, \"resource\", m.Key.Resource)\n+\n+\t\t\t// Verify event was written to eventStore\n+\t\t\teventKey := EventKey{\n+\t\t\t\tNamespace:       \"default\",\n+\t\t\t\tGroup:           \"apps\",\n+\t\t\t\tResource:        \"resource\",\n+\t\t\t\tName:            \"test-resource\",\n+\t\t\t\tResourceVersion: rv,\n+\t\t\t}\n+\n+\t\t\t_, err = backend.eventStore.Get(ctx, eventKey)\n+\t\t\trequire.NoError(t, err)\n+\t\t})\n+\t}\n+}\n+\n+func TestKvStorageBackend_WriteEvent_ResourceAlreadyExists(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// Create a test resource first\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\t// First create should succeed\n+\trv1, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\trequire.Greater(t, rv1, int64(0))\n+\n+\t// Try to create the same resource again - should fail with ErrResourceAlreadyExists\n+\twriteEvent.PreviousRV = 0 // Reset previous RV to simulate a fresh create attempt\n+\trv2, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.Error(t, err)\n+\trequire.Equal(t, int64(0), rv2)\n+\trequire.ErrorIs(t, err, ErrResourceAlreadyExists)\n+\n+\t// Verify the error is the correct type\n+\trequire.Contains(t, err.Error(), \"the resource already exists\")\n+}\n+\n+func TestKvStorageBackend_ReadResource_Success(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// First, write a resource to read\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\trv, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Now test reading the resource\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tResourceVersion: 0, // Read latest version\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed\")\n+\trequire.NotNil(t, response.Key, \"Response should have a key\")\n+\trequire.Equal(t, \"test-deployment\", response.Key.Name)\n+\trequire.Equal(t, \"default\", response.Key.Namespace)\n+\trequire.Equal(t, \"apps\", response.Key.Group)\n+\trequire.Equal(t, \"deployments\", response.Key.Resource)\n+\trequire.Equal(t, rv, response.ResourceVersion)\n+\trequire.Equal(t, objectToJSONBytes(t, testObj), response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_SpecificVersion(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// Create initial version\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\trv1, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Update the resource\n+\ttestObj.Object[\"spec\"].(map[string]any)[\"value\"] = \"updated data\"\n+\twriteEvent.Type = resourcepb.WatchEvent_MODIFIED\n+\twriteEvent.Value = objectToJSONBytes(t, testObj)\n+\twriteEvent.PreviousRV = rv1\n+\n+\trv2, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Read the first version specifically\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tResourceVersion: rv1,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed for specific version\")\n+\trequire.Equal(t, rv1, response.ResourceVersion)\n+\n+\t// Verify we got the original data, not the updated data\n+\toriginalObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, objectToJSONBytes(t, originalObj), response.Value)\n+\n+\t// Read the latest version\n+\treadReq.ResourceVersion = 0\n+\tresponse = backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed for latest version\")\n+\trequire.Equal(t, rv2, response.ResourceVersion)\n+\trequire.Equal(t, objectToJSONBytes(t, testObj), response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_NotFound(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"nonexistent-deployment\",\n+\t\t},\n+\t\tResourceVersion: 0,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.NotNil(t, response.Error, \"ReadResource should return error for nonexistent resource\")\n+\trequire.Equal(t, int32(404), response.Error.Code)\n+\trequire.Equal(t, \"not found\", response.Error.Message)\n+\trequire.Nil(t, response.Key)\n+\trequire.Equal(t, int64(0), response.ResourceVersion)\n+\trequire.Nil(t, response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_MissingKey(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey:             nil, // Missing key\n+\t\tResourceVersion: 0,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.NotNil(t, response.Error, \"ReadResource should return error for missing key\")\n+\trequire.Equal(t, int32(400), response.Error.Code)\n+\trequire.Equal(t, \"missing key\", response.Error.Message)\n+\trequire.Nil(t, response.Key)\n+\trequire.Equal(t, int64(0), response.ResourceVersion)\n+\trequire.Nil(t, response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_DeletedResource(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// First, create a resource\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\trv1, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Delete the resource\n+\twriteEvent.Type = resourcepb.WatchEvent_DELETED\n+\twriteEvent.PreviousRV = rv1\n+\n+\t_, err = backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Try to read the latest version (should be deleted and return not found)\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tResourceVersion: 0,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.NotNil(t, response.Error, \"ReadResource should return not found for deleted resource\")\n+\trequire.Equal(t, int32(404), response.Error.Code)\n+\trequire.Equal(t, \"not found\", response.Error.Message)\n+\n+\t// Try to read the original version (should still work)\n+\treadReq.ResourceVersion = rv1\n+\tresponse = backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed for specific version before deletion\")\n+\trequire.Equal(t, rv1, response.ResourceVersion)\n+\trequire.Equal(t, objectToJSONBytes(t, testObj), response.Value)\n+}\n+\n+func TestKvStorageBackend_ListIterator_Success(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// Create multiple test resources\n+\tresources := []struct {\n+\t\tname  string\n+\t\tgroup string\n+\t\tvalue string\n+\t}{\n+\t\t{\"resource-1\", \"apps\", \"data-1\"},\n+\t\t{\"resource-2\", \"apps\", \"data-2\"},\n+\t\t{\"resource-3\", \"core\", \"data-3\"},\n+\t}\n+\n+\tfor _, res := range resources {\n+\t\ttestObj, err := createTestObjectWithName(res.name, res.group, res.value)\n+\t\trequire.NoError(t, err)\n+\n+\t\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\t\trequire.NoError(t, err)\n+\n+\t\twriteEvent := WriteEvent{\n+\t\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\t\tKey: &resourcepb.ResourceKey{\n+\t\t\t\tNamespace: \"default\",\n+\t\t\t\tGroup:     res.group,\n+\t\t\t\tResource:  \"deployments\",\n+\t\t\t\tName:      res.name,\n+\t\t\t},\n+\t\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\t\tObject:     metaAccessor,\n+\t\t\tPreviousRV: 0,\n+\t\t}\n+\n+\t\t_, err = backend.WriteEvent(ctx, writeEvent)\n+\t\trequire.NoError(t, err)\n+\t}\n+\n+\t// Test listing all resources in \"apps\" group\n+\tlistReq := &resourcepb.ListRequest{\n+\t\tOptions: &resourcepb.ListOptions{\n+\t\t\tKey: &resourcepb.ResourceKey{\n+\t\t\t\tNamespace: \"default\",\n+\t\t\t\tGroup:     \"apps\",\n+\t\t\t\tResource:  \"deployments\",\n+\t\t\t},\n+\t\t},\n+\t\tLimit: 10,\n+\t}\n+\n+\tvar collectedItems []struct {\n+\t\tname            string\n+\t\tnamespace       string\n+\t\tresourceVersion int64\n+\t\tvalue           []byte\n+\t}\n+\n+\trv, err := backend.ListIterator(ctx, listReq, func(iter ListIterator) error {\n+\t\tfor iter.Next() {\n+\t\t\tif err := iter.Error(); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tcollectedItems = append(collectedItems, struct {\n+\t\t\t\tname            string\n+\t\t\t\tnamespace       string\n+\t\t\t\tresourceVersion int64\n+\t\t\t\tvalue           []byte\n+\t\t\t}{\n+\t\t\t\tname:            iter.Name(),\n+\t\t\t\tnamespace:       iter.Namespace(),\n+\t\t\t\tresourceVersion: iter.ResourceVersion(),\n+\t\t\t\tvalue:           iter.Value(),\n+\t\t\t})\n+\t\t}\n+\t\treturn iter.Error()\n+\t})\n+\n+\trequire.NoError(t, err)\n+\trequire.Greater(t, rv, int64(0))\n+\trequire.Len(t, collectedItems, 2) // Only resources in \"apps\" group\n+\n+\t// Verify the items contain expected data\n+\tnames := make([]string, len(collectedItems))\n+\tfor i, item := range collectedItems {\n+\t\tnames[i] = item.name\n+\t\trequire.Equal(t, \"default\", item.namespace)\n+\t\trequire.Greater(t, item.resourceVersion, int64(0))\n+\t\trequire.NotEmpty(t, item.value)\n+\t}\n+\trequire.Contains(t, names, \"resource-1\")\n+\trequire.Contains(t, names, \"resource-2\")",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2177606430",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107305,
        "pr_file": "pkg/storage/unified/resource/storage_backend_test.go",
        "discussion_id": "2177606430",
        "commented_code": "@@ -0,0 +1,1030 @@\n+package resource\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n+\n+\t\"github.com/grafana/grafana/pkg/apimachinery/utils\"\n+\t\"github.com/grafana/grafana/pkg/storage/unified/resourcepb\"\n+)\n+\n+func setupTestStorageBackend(t *testing.T) *kvStorageBackend {\n+\tkv := setupTestKV(t)\n+\treturn NewkvStorageBackend(kv)\n+}\n+\n+func TestNewkvStorageBackend(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\n+\tassert.NotNil(t, backend)\n+\tassert.NotNil(t, backend.kv)\n+\tassert.NotNil(t, backend.dataStore)\n+\tassert.NotNil(t, backend.metaStore)\n+\tassert.NotNil(t, backend.eventStore)\n+\tassert.NotNil(t, backend.notifier)\n+\tassert.NotNil(t, backend.snowflake)\n+}\n+\n+func TestKvStorageBackend_WriteEvent_Success(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\ttests := []struct {\n+\t\tname      string\n+\t\teventType resourcepb.WatchEvent_Type\n+\t}{\n+\t\t{\n+\t\t\tname:      \"write ADDED event\",\n+\t\t\teventType: resourcepb.WatchEvent_ADDED,\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"write MODIFIED event\",\n+\t\t\teventType: resourcepb.WatchEvent_MODIFIED,\n+\t\t},\n+\t\t{\n+\t\t\tname:      \"write DELETED event\",\n+\t\t\teventType: resourcepb.WatchEvent_DELETED,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\ttestObj, err := createTestObject()\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\twriteEvent := WriteEvent{\n+\t\t\t\tType: tt.eventType,\n+\t\t\t\tKey: &resourcepb.ResourceKey{\n+\t\t\t\t\tNamespace: \"default\",\n+\t\t\t\t\tGroup:     \"apps\",\n+\t\t\t\t\tResource:  \"resource\",\n+\t\t\t\t\tName:      \"test-resource\",\n+\t\t\t\t},\n+\t\t\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\t\t\tObject:     metaAccessor,\n+\t\t\t\tPreviousRV: 100,\n+\t\t\t}\n+\n+\t\t\trv, err := backend.WriteEvent(ctx, writeEvent)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tassert.Greater(t, rv, int64(0), \"resource version should be positive\")\n+\n+\t\t\t// Verify data was written to dataStore\n+\t\t\tvar expectedAction DataAction\n+\t\t\tswitch tt.eventType {\n+\t\t\tcase resourcepb.WatchEvent_ADDED:\n+\t\t\t\texpectedAction = DataActionCreated\n+\t\t\tcase resourcepb.WatchEvent_MODIFIED:\n+\t\t\t\texpectedAction = DataActionUpdated\n+\t\t\tcase resourcepb.WatchEvent_DELETED:\n+\t\t\t\texpectedAction = DataActionDeleted\n+\t\t\tdefault:\n+\t\t\t\tt.Fatalf(\"unexpected event type: %v\", tt.eventType)\n+\t\t\t}\n+\n+\t\t\tdataKey := DataKey{\n+\t\t\t\tNamespace:       \"default\",\n+\t\t\t\tGroup:           \"apps\",\n+\t\t\t\tResource:        \"resource\",\n+\t\t\t\tName:            \"test-resource\",\n+\t\t\t\tResourceVersion: rv,\n+\t\t\t\tAction:          expectedAction,\n+\t\t\t}\n+\n+\t\t\tdataReader, err := backend.dataStore.Get(ctx, dataKey)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tdataValue, err := io.ReadAll(dataReader)\n+\t\t\trequire.NoError(t, err)\n+\t\t\tassert.Equal(t, objectToJSONBytes(t, testObj), dataValue)\n+\n+\t\t\t// Verify metadata was written to metaStore\n+\t\t\tmetaKey := MetaDataKey{\n+\t\t\t\tNamespace:       \"default\",\n+\t\t\t\tGroup:           \"apps\",\n+\t\t\t\tResource:        \"resource\",\n+\t\t\t\tName:            \"test-resource\",\n+\t\t\t\tResourceVersion: rv,\n+\t\t\t\tAction:          expectedAction,\n+\t\t\t\tFolder:          \"\",\n+\t\t\t}\n+\n+\t\t\tm, err := backend.metaStore.Get(ctx, metaKey)\n+\t\t\trequire.NoError(t, err)\n+\t\t\trequire.NotNil(t, m)\n+\t\t\trequire.Equal(t, \"test-resource\", m.Key.Name)\n+\t\t\trequire.Equal(t, \"default\", m.Key.Namespace)\n+\t\t\trequire.Equal(t, \"apps\", m.Key.Group)\n+\t\t\trequire.Equal(t, \"resource\", m.Key.Resource)\n+\n+\t\t\t// Verify event was written to eventStore\n+\t\t\teventKey := EventKey{\n+\t\t\t\tNamespace:       \"default\",\n+\t\t\t\tGroup:           \"apps\",\n+\t\t\t\tResource:        \"resource\",\n+\t\t\t\tName:            \"test-resource\",\n+\t\t\t\tResourceVersion: rv,\n+\t\t\t}\n+\n+\t\t\t_, err = backend.eventStore.Get(ctx, eventKey)\n+\t\t\trequire.NoError(t, err)\n+\t\t})\n+\t}\n+}\n+\n+func TestKvStorageBackend_WriteEvent_ResourceAlreadyExists(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// Create a test resource first\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\t// First create should succeed\n+\trv1, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\trequire.Greater(t, rv1, int64(0))\n+\n+\t// Try to create the same resource again - should fail with ErrResourceAlreadyExists\n+\twriteEvent.PreviousRV = 0 // Reset previous RV to simulate a fresh create attempt\n+\trv2, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.Error(t, err)\n+\trequire.Equal(t, int64(0), rv2)\n+\trequire.ErrorIs(t, err, ErrResourceAlreadyExists)\n+\n+\t// Verify the error is the correct type\n+\trequire.Contains(t, err.Error(), \"the resource already exists\")\n+}\n+\n+func TestKvStorageBackend_ReadResource_Success(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// First, write a resource to read\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\trv, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Now test reading the resource\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tResourceVersion: 0, // Read latest version\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed\")\n+\trequire.NotNil(t, response.Key, \"Response should have a key\")\n+\trequire.Equal(t, \"test-deployment\", response.Key.Name)\n+\trequire.Equal(t, \"default\", response.Key.Namespace)\n+\trequire.Equal(t, \"apps\", response.Key.Group)\n+\trequire.Equal(t, \"deployments\", response.Key.Resource)\n+\trequire.Equal(t, rv, response.ResourceVersion)\n+\trequire.Equal(t, objectToJSONBytes(t, testObj), response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_SpecificVersion(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// Create initial version\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\trv1, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Update the resource\n+\ttestObj.Object[\"spec\"].(map[string]any)[\"value\"] = \"updated data\"\n+\twriteEvent.Type = resourcepb.WatchEvent_MODIFIED\n+\twriteEvent.Value = objectToJSONBytes(t, testObj)\n+\twriteEvent.PreviousRV = rv1\n+\n+\trv2, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Read the first version specifically\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tResourceVersion: rv1,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed for specific version\")\n+\trequire.Equal(t, rv1, response.ResourceVersion)\n+\n+\t// Verify we got the original data, not the updated data\n+\toriginalObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\trequire.Equal(t, objectToJSONBytes(t, originalObj), response.Value)\n+\n+\t// Read the latest version\n+\treadReq.ResourceVersion = 0\n+\tresponse = backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed for latest version\")\n+\trequire.Equal(t, rv2, response.ResourceVersion)\n+\trequire.Equal(t, objectToJSONBytes(t, testObj), response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_NotFound(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"nonexistent-deployment\",\n+\t\t},\n+\t\tResourceVersion: 0,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.NotNil(t, response.Error, \"ReadResource should return error for nonexistent resource\")\n+\trequire.Equal(t, int32(404), response.Error.Code)\n+\trequire.Equal(t, \"not found\", response.Error.Message)\n+\trequire.Nil(t, response.Key)\n+\trequire.Equal(t, int64(0), response.ResourceVersion)\n+\trequire.Nil(t, response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_MissingKey(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey:             nil, // Missing key\n+\t\tResourceVersion: 0,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.NotNil(t, response.Error, \"ReadResource should return error for missing key\")\n+\trequire.Equal(t, int32(400), response.Error.Code)\n+\trequire.Equal(t, \"missing key\", response.Error.Message)\n+\trequire.Nil(t, response.Key)\n+\trequire.Equal(t, int64(0), response.ResourceVersion)\n+\trequire.Nil(t, response.Value)\n+}\n+\n+func TestKvStorageBackend_ReadResource_DeletedResource(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// First, create a resource\n+\ttestObj, err := createTestObject()\n+\trequire.NoError(t, err)\n+\n+\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\trequire.NoError(t, err)\n+\n+\twriteEvent := WriteEvent{\n+\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\tObject:     metaAccessor,\n+\t\tPreviousRV: 0,\n+\t}\n+\n+\trv1, err := backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Delete the resource\n+\twriteEvent.Type = resourcepb.WatchEvent_DELETED\n+\twriteEvent.PreviousRV = rv1\n+\n+\t_, err = backend.WriteEvent(ctx, writeEvent)\n+\trequire.NoError(t, err)\n+\n+\t// Try to read the latest version (should be deleted and return not found)\n+\treadReq := &resourcepb.ReadRequest{\n+\t\tKey: &resourcepb.ResourceKey{\n+\t\t\tNamespace: \"default\",\n+\t\t\tGroup:     \"apps\",\n+\t\t\tResource:  \"deployments\",\n+\t\t\tName:      \"test-deployment\",\n+\t\t},\n+\t\tResourceVersion: 0,\n+\t}\n+\n+\tresponse := backend.ReadResource(ctx, readReq)\n+\trequire.NotNil(t, response.Error, \"ReadResource should return not found for deleted resource\")\n+\trequire.Equal(t, int32(404), response.Error.Code)\n+\trequire.Equal(t, \"not found\", response.Error.Message)\n+\n+\t// Try to read the original version (should still work)\n+\treadReq.ResourceVersion = rv1\n+\tresponse = backend.ReadResource(ctx, readReq)\n+\trequire.Nil(t, response.Error, \"ReadResource should succeed for specific version before deletion\")\n+\trequire.Equal(t, rv1, response.ResourceVersion)\n+\trequire.Equal(t, objectToJSONBytes(t, testObj), response.Value)\n+}\n+\n+func TestKvStorageBackend_ListIterator_Success(t *testing.T) {\n+\tbackend := setupTestStorageBackend(t)\n+\tctx := context.Background()\n+\n+\t// Create multiple test resources\n+\tresources := []struct {\n+\t\tname  string\n+\t\tgroup string\n+\t\tvalue string\n+\t}{\n+\t\t{\"resource-1\", \"apps\", \"data-1\"},\n+\t\t{\"resource-2\", \"apps\", \"data-2\"},\n+\t\t{\"resource-3\", \"core\", \"data-3\"},\n+\t}\n+\n+\tfor _, res := range resources {\n+\t\ttestObj, err := createTestObjectWithName(res.name, res.group, res.value)\n+\t\trequire.NoError(t, err)\n+\n+\t\tmetaAccessor, err := utils.MetaAccessor(testObj)\n+\t\trequire.NoError(t, err)\n+\n+\t\twriteEvent := WriteEvent{\n+\t\t\tType: resourcepb.WatchEvent_ADDED,\n+\t\t\tKey: &resourcepb.ResourceKey{\n+\t\t\t\tNamespace: \"default\",\n+\t\t\t\tGroup:     res.group,\n+\t\t\t\tResource:  \"deployments\",\n+\t\t\t\tName:      res.name,\n+\t\t\t},\n+\t\t\tValue:      objectToJSONBytes(t, testObj),\n+\t\t\tObject:     metaAccessor,\n+\t\t\tPreviousRV: 0,\n+\t\t}\n+\n+\t\t_, err = backend.WriteEvent(ctx, writeEvent)\n+\t\trequire.NoError(t, err)\n+\t}\n+\n+\t// Test listing all resources in \"apps\" group\n+\tlistReq := &resourcepb.ListRequest{\n+\t\tOptions: &resourcepb.ListOptions{\n+\t\t\tKey: &resourcepb.ResourceKey{\n+\t\t\t\tNamespace: \"default\",\n+\t\t\t\tGroup:     \"apps\",\n+\t\t\t\tResource:  \"deployments\",\n+\t\t\t},\n+\t\t},\n+\t\tLimit: 10,\n+\t}\n+\n+\tvar collectedItems []struct {\n+\t\tname            string\n+\t\tnamespace       string\n+\t\tresourceVersion int64\n+\t\tvalue           []byte\n+\t}\n+\n+\trv, err := backend.ListIterator(ctx, listReq, func(iter ListIterator) error {\n+\t\tfor iter.Next() {\n+\t\t\tif err := iter.Error(); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tcollectedItems = append(collectedItems, struct {\n+\t\t\t\tname            string\n+\t\t\t\tnamespace       string\n+\t\t\t\tresourceVersion int64\n+\t\t\t\tvalue           []byte\n+\t\t\t}{\n+\t\t\t\tname:            iter.Name(),\n+\t\t\t\tnamespace:       iter.Namespace(),\n+\t\t\t\tresourceVersion: iter.ResourceVersion(),\n+\t\t\t\tvalue:           iter.Value(),\n+\t\t\t})\n+\t\t}\n+\t\treturn iter.Error()\n+\t})\n+\n+\trequire.NoError(t, err)\n+\trequire.Greater(t, rv, int64(0))\n+\trequire.Len(t, collectedItems, 2) // Only resources in \"apps\" group\n+\n+\t// Verify the items contain expected data\n+\tnames := make([]string, len(collectedItems))\n+\tfor i, item := range collectedItems {\n+\t\tnames[i] = item.name\n+\t\trequire.Equal(t, \"default\", item.namespace)\n+\t\trequire.Greater(t, item.resourceVersion, int64(0))\n+\t\trequire.NotEmpty(t, item.value)\n+\t}\n+\trequire.Contains(t, names, \"resource-1\")\n+\trequire.Contains(t, names, \"resource-2\")",
        "comment_created_at": "2025-07-01T13:26:11+00:00",
        "comment_author": "pstibrany",
        "comment_body": "```suggestion\n\trequire.Equal(t, []string{\"resource-1\", \"resource-2\"}, names)\n```\n\nThis also checks ordering. WDYT?",
        "pr_file_module": null
      }
    ]
  }
]