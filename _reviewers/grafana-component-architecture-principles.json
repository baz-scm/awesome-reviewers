[
  {
    "discussion_id": "2184828054",
    "pr_number": 107612,
    "pr_file": "public/app/core/components/SessionExpiryMonitor/SessionExpiryMonitor.tsx",
    "created_at": "2025-07-04T09:19:20+00:00",
    "commented_code": "+import { useEffect, useRef, useState } from 'react';\n+\n+import { t } from '@grafana/i18n';\n+import { useAppNotification } from 'app/core/copy/appNotification';\n+import { contextSrv } from 'app/core/core';\n+import { getSessionExpiry, hasSessionExpiry } from 'app/core/utils/auth';\n+\n+interface SessionExpiryMonitorProps {\n+  warningMinutes?: number; // Minutes before expiry to show warning\n+  checkIntervalMs?: number; // How often to check session expiry\n+}\n+\n+export function SessionExpiryMonitor({ \n+  warningMinutes = 5, \n+  checkIntervalMs = 30000 // Check every 30 seconds\n+}: SessionExpiryMonitorProps) {\n+  const notifyApp = useAppNotification();\n+  const [hasShownWarning, setHasShownWarning] = useState(false);\n+  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n+  const lastExpiryTimeRef = useRef<number | null>(null);\n+\n+  useEffect(() => {\n+    // Only monitor if user is signed in and session expiry is available\n+    if (!contextSrv.isSignedIn || !hasSessionExpiry()) {\n+      return;\n+    }\n+\n+    const checkSessionExpiry = () => {\n+      const expiryTimestamp = getSessionExpiry();\n+      if (!expiryTimestamp) {\n+        return;\n+      }\n+\n+      const now = Date.now();\n+      const expiryTime = expiryTimestamp * 1000;\n+      const sessionTimeRemainingMs = expiryTime - now;\n+      const sessionTimeRemainingMinutes = sessionTimeRemainingMs / (60 * 1000);\n+\n+      // Dynamic warning time: Use the smaller of warningMinutes or half the remaining session time\n+      // This prevents showing warnings immediately for short sessions\n+      const effectiveWarningMinutes = Math.min(\n+        warningMinutes, \n+        Math.max(1, sessionTimeRemainingMinutes / 2) // At least 1 minute, at most half remaining time\n+      );\n+      \n+      const warningTime = expiryTime - (effectiveWarningMinutes * 60 * 1000);\n+\n+      // Reset warning flag if session is renewed (expiry time changed)\n+      if (lastExpiryTimeRef.current && lastExpiryTimeRef.current !== expiryTime) {\n+        setHasShownWarning(false);\n+        lastExpiryTimeRef.current = expiryTime;\n+      } else if (!lastExpiryTimeRef.current) {\n+        lastExpiryTimeRef.current = expiryTime;\n+      }\n+\n+      // Show warning if we've reached the warning threshold and haven't shown it yet\n+      // Also ensure we have at least 30 seconds remaining to avoid showing warning too late\n+      if (now >= warningTime && sessionTimeRemainingMs > 30000 && !hasShownWarning) {\n+        const remainingMinutes = Math.ceil(sessionTimeRemainingMs / (60 * 1000));\n+        \n+        try {\n+          notifyApp.warning(\n+            t('session-expiry.warning-title', 'Session Expiring Soon'),\n+            t('session-expiry.warning-message', \n+              'Your session will expire in {{minutes}} minute(s). Please make sure to finish up or save any changes.',\n+              { minutes: remainingMinutes }\n+            )\n+          );\n+          \n+          setHasShownWarning(true);\n+        } catch (error) {\n+          console.error('Error showing session expiry notification:', error);\n+        }\n+      }\n+    };\n+\n+    checkSessionExpiry();\n+\n+    intervalRef.current = setInterval(checkSessionExpiry, checkIntervalMs);\n+\n+    return () => {\n+      if (intervalRef.current) {\n+        clearInterval(intervalRef.current);\n+        intervalRef.current = null;\n+      }\n+    };\n+  }, [warningMinutes, checkIntervalMs, notifyApp, hasShownWarning]);\n+\n+  return null;",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2184828054",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107612,
        "pr_file": "public/app/core/components/SessionExpiryMonitor/SessionExpiryMonitor.tsx",
        "discussion_id": "2184828054",
        "commented_code": "@@ -0,0 +1,90 @@\n+import { useEffect, useRef, useState } from 'react';\n+\n+import { t } from '@grafana/i18n';\n+import { useAppNotification } from 'app/core/copy/appNotification';\n+import { contextSrv } from 'app/core/core';\n+import { getSessionExpiry, hasSessionExpiry } from 'app/core/utils/auth';\n+\n+interface SessionExpiryMonitorProps {\n+  warningMinutes?: number; // Minutes before expiry to show warning\n+  checkIntervalMs?: number; // How often to check session expiry\n+}\n+\n+export function SessionExpiryMonitor({ \n+  warningMinutes = 5, \n+  checkIntervalMs = 30000 // Check every 30 seconds\n+}: SessionExpiryMonitorProps) {\n+  const notifyApp = useAppNotification();\n+  const [hasShownWarning, setHasShownWarning] = useState(false);\n+  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n+  const lastExpiryTimeRef = useRef<number | null>(null);\n+\n+  useEffect(() => {\n+    // Only monitor if user is signed in and session expiry is available\n+    if (!contextSrv.isSignedIn || !hasSessionExpiry()) {\n+      return;\n+    }\n+\n+    const checkSessionExpiry = () => {\n+      const expiryTimestamp = getSessionExpiry();\n+      if (!expiryTimestamp) {\n+        return;\n+      }\n+\n+      const now = Date.now();\n+      const expiryTime = expiryTimestamp * 1000;\n+      const sessionTimeRemainingMs = expiryTime - now;\n+      const sessionTimeRemainingMinutes = sessionTimeRemainingMs / (60 * 1000);\n+\n+      // Dynamic warning time: Use the smaller of warningMinutes or half the remaining session time\n+      // This prevents showing warnings immediately for short sessions\n+      const effectiveWarningMinutes = Math.min(\n+        warningMinutes, \n+        Math.max(1, sessionTimeRemainingMinutes / 2) // At least 1 minute, at most half remaining time\n+      );\n+      \n+      const warningTime = expiryTime - (effectiveWarningMinutes * 60 * 1000);\n+\n+      // Reset warning flag if session is renewed (expiry time changed)\n+      if (lastExpiryTimeRef.current && lastExpiryTimeRef.current !== expiryTime) {\n+        setHasShownWarning(false);\n+        lastExpiryTimeRef.current = expiryTime;\n+      } else if (!lastExpiryTimeRef.current) {\n+        lastExpiryTimeRef.current = expiryTime;\n+      }\n+\n+      // Show warning if we've reached the warning threshold and haven't shown it yet\n+      // Also ensure we have at least 30 seconds remaining to avoid showing warning too late\n+      if (now >= warningTime && sessionTimeRemainingMs > 30000 && !hasShownWarning) {\n+        const remainingMinutes = Math.ceil(sessionTimeRemainingMs / (60 * 1000));\n+        \n+        try {\n+          notifyApp.warning(\n+            t('session-expiry.warning-title', 'Session Expiring Soon'),\n+            t('session-expiry.warning-message', \n+              'Your session will expire in {{minutes}} minute(s). Please make sure to finish up or save any changes.',\n+              { minutes: remainingMinutes }\n+            )\n+          );\n+          \n+          setHasShownWarning(true);\n+        } catch (error) {\n+          console.error('Error showing session expiry notification:', error);\n+        }\n+      }\n+    };\n+\n+    checkSessionExpiry();\n+\n+    intervalRef.current = setInterval(checkSessionExpiry, checkIntervalMs);\n+\n+    return () => {\n+      if (intervalRef.current) {\n+        clearInterval(intervalRef.current);\n+        intervalRef.current = null;\n+      }\n+    };\n+  }, [warningMinutes, checkIntervalMs, notifyApp, hasShownWarning]);\n+\n+  return null;",
        "comment_created_at": "2025-07-04T09:19:20+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "Since it doesn't render any JSX, this can be just a custom hook instead of a react component. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2164380860",
    "pr_number": 107089,
    "pr_file": "public/app/features/browse-dashboards/components/DeleteProvisionedFolderForm.tsx",
    "created_at": "2025-06-24T15:54:22+00:00",
    "commented_code": "+import { useEffect } from 'react';\n+import { FormProvider, useForm } from 'react-hook-form';\n+\n+import { AppEvents } from '@grafana/data';\n+import { Trans, t } from '@grafana/i18n';\n+import { getAppEvents } from '@grafana/runtime';\n+import { Button, Space, Stack } from '@grafana/ui';\n+import { useDeleteRepositoryFilesWithPathMutation } from 'app/api/clients/provisioning/v0alpha1';\n+import { AnnoKeySourcePath } from 'app/features/apiserver/types';\n+import { DashboardEditFormSharedFields } from 'app/features/dashboard-scene/components/Provisioned/DashboardEditFormSharedFields';\n+import { BaseProvisionedFormData } from 'app/features/dashboard-scene/saving/shared';\n+import { FolderDTO } from 'app/types';\n+\n+import { useProvisionedFolderFormData } from '../hooks/useProvisionedFolderFormData';\n+\n+import { DescendantCount } from './BrowseActions/DescendantCount';\n+import { getFolderURL } from './utils';\n+\n+interface DeleteProvisionedFolderFormProps {\n+  parentFolder?: FolderDTO;\n+}\n+\n+export function DeleteProvisionedFolderForm({ parentFolder }: DeleteProvisionedFolderFormProps) {\n+  const resourceId = parentFolder?.uid || '';\n+\n+  // form related\n+  const methods = useForm<BaseProvisionedFormData>(); // form initial value will be set by useProvisionedFolderFormData",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2164380860",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107089,
        "pr_file": "public/app/features/browse-dashboards/components/DeleteProvisionedFolderForm.tsx",
        "discussion_id": "2164380860",
        "commented_code": "@@ -0,0 +1,135 @@\n+import { useEffect } from 'react';\n+import { FormProvider, useForm } from 'react-hook-form';\n+\n+import { AppEvents } from '@grafana/data';\n+import { Trans, t } from '@grafana/i18n';\n+import { getAppEvents } from '@grafana/runtime';\n+import { Button, Space, Stack } from '@grafana/ui';\n+import { useDeleteRepositoryFilesWithPathMutation } from 'app/api/clients/provisioning/v0alpha1';\n+import { AnnoKeySourcePath } from 'app/features/apiserver/types';\n+import { DashboardEditFormSharedFields } from 'app/features/dashboard-scene/components/Provisioned/DashboardEditFormSharedFields';\n+import { BaseProvisionedFormData } from 'app/features/dashboard-scene/saving/shared';\n+import { FolderDTO } from 'app/types';\n+\n+import { useProvisionedFolderFormData } from '../hooks/useProvisionedFolderFormData';\n+\n+import { DescendantCount } from './BrowseActions/DescendantCount';\n+import { getFolderURL } from './utils';\n+\n+interface DeleteProvisionedFolderFormProps {\n+  parentFolder?: FolderDTO;\n+}\n+\n+export function DeleteProvisionedFolderForm({ parentFolder }: DeleteProvisionedFolderFormProps) {\n+  const resourceId = parentFolder?.uid || '';\n+\n+  // form related\n+  const methods = useForm<BaseProvisionedFormData>(); // form initial value will be set by useProvisionedFolderFormData",
        "comment_created_at": "2025-06-24T15:54:22+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "Not a fan of this indirect approach of setting the form data, it's not straightforward to figure the data flow by looking at the code. Plus we unnecessarily render the component with a stale data (component renders => data is fetched => data set to form => component renders with the updated data). \r\n\r\nMaybe splitting into two components and use early return if the data hasn't been fetched yet will work better?",
        "pr_file_module": null
      },
      {
        "comment_id": "2164855495",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107089,
        "pr_file": "public/app/features/browse-dashboards/components/DeleteProvisionedFolderForm.tsx",
        "discussion_id": "2164380860",
        "commented_code": "@@ -0,0 +1,135 @@\n+import { useEffect } from 'react';\n+import { FormProvider, useForm } from 'react-hook-form';\n+\n+import { AppEvents } from '@grafana/data';\n+import { Trans, t } from '@grafana/i18n';\n+import { getAppEvents } from '@grafana/runtime';\n+import { Button, Space, Stack } from '@grafana/ui';\n+import { useDeleteRepositoryFilesWithPathMutation } from 'app/api/clients/provisioning/v0alpha1';\n+import { AnnoKeySourcePath } from 'app/features/apiserver/types';\n+import { DashboardEditFormSharedFields } from 'app/features/dashboard-scene/components/Provisioned/DashboardEditFormSharedFields';\n+import { BaseProvisionedFormData } from 'app/features/dashboard-scene/saving/shared';\n+import { FolderDTO } from 'app/types';\n+\n+import { useProvisionedFolderFormData } from '../hooks/useProvisionedFolderFormData';\n+\n+import { DescendantCount } from './BrowseActions/DescendantCount';\n+import { getFolderURL } from './utils';\n+\n+interface DeleteProvisionedFolderFormProps {\n+  parentFolder?: FolderDTO;\n+}\n+\n+export function DeleteProvisionedFolderForm({ parentFolder }: DeleteProvisionedFolderFormProps) {\n+  const resourceId = parentFolder?.uid || '';\n+\n+  // form related\n+  const methods = useForm<BaseProvisionedFormData>(); // form initial value will be set by useProvisionedFolderFormData",
        "comment_created_at": "2025-06-24T20:35:29+00:00",
        "comment_author": "ywzheng1",
        "comment_body": "Good call out, its now split into 2 components. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1529966951",
    "pr_number": 84512,
    "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
    "created_at": "2024-03-19T08:57:00+00:00",
    "commented_code": "sceneGridLayout.setState({\n       children: [newGridItem, ...sceneGridLayout.state.children],\n     });\n+    this.setState({ body: sceneGridLayout });",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1529966951",
        "repo_full_name": "grafana/grafana",
        "pr_number": 84512,
        "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
        "discussion_id": "1529966951",
        "commented_code": "@@ -739,6 +737,7 @@ export class DashboardScene extends SceneObjectBase<DashboardSceneState> {\n     sceneGridLayout.setState({\n       children: [newGridItem, ...sceneGridLayout.state.children],\n     });\n+    this.setState({ body: sceneGridLayout });",
        "comment_created_at": "2024-03-19T08:57:00+00:00",
        "comment_author": "torkelo",
        "comment_body": "I assume this is to cause a state change and re-render of the DashboardSceneRenderer (since you removed the isEmpty state). \r\n\r\nThere are many places more we would have to update as well I think (removeRow, removePanel, addPanel etc) ? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182091444",
    "pr_number": 107521,
    "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
    "created_at": "2025-07-03T07:41:46+00:00",
    "commented_code": "this.addActivationHandler(() => this._activationHandler());\n   }\n \n+  // Setups a listener to the url and saves the current query params if the url is the url of this dashboard scene.\n+  private setupUrlListener = () => {\n+    // return a noop function if the feature toggle is disabled\n+    if (!config.featureToggles.preserveDashboardStateWhenNavigating) {\n+      return () => {};\n+    }\n+\n+    const unlisten = locationService.getHistory().listen((a) => {\n+      if (this.state.uid && a.pathname.includes(this.state.uid)) {\n+        this._currentQueryParams = a.search;\n+      }\n+    });",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2182091444",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107521,
        "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
        "discussion_id": "2182091444",
        "commented_code": "@@ -213,10 +217,37 @@ export class DashboardScene extends SceneObjectBase<DashboardSceneState> impleme\n     this.addActivationHandler(() => this._activationHandler());\n   }\n \n+  // Setups a listener to the url and saves the current query params if the url is the url of this dashboard scene.\n+  private setupUrlListener = () => {\n+    // return a noop function if the feature toggle is disabled\n+    if (!config.featureToggles.preserveDashboardStateWhenNavigating) {\n+      return () => {};\n+    }\n+\n+    const unlisten = locationService.getHistory().listen((a) => {\n+      if (this.state.uid && a.pathname.includes(this.state.uid)) {\n+        this._currentQueryParams = a.search;\n+      }\n+    });",
        "comment_created_at": "2025-07-03T07:41:46+00:00",
        "comment_author": "torkelo",
        "comment_body": "directly subscribing to history is usually a bad idea (vs using react useLocation). History events happen before route changes. It's much better to use useLocation + effect  to update state. This way you do not need to check if the update is relevant for the current dashboard / route (which can be error prone).\r\n\r\nhttps://github.com/grafana/scenes/blob/main/packages/scenes/src/services/useUrlSync.ts#L9\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2182434197",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107521,
        "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
        "discussion_id": "2182091444",
        "commented_code": "@@ -213,10 +217,37 @@ export class DashboardScene extends SceneObjectBase<DashboardSceneState> impleme\n     this.addActivationHandler(() => this._activationHandler());\n   }\n \n+  // Setups a listener to the url and saves the current query params if the url is the url of this dashboard scene.\n+  private setupUrlListener = () => {\n+    // return a noop function if the feature toggle is disabled\n+    if (!config.featureToggles.preserveDashboardStateWhenNavigating) {\n+      return () => {};\n+    }\n+\n+    const unlisten = locationService.getHistory().listen((a) => {\n+      if (this.state.uid && a.pathname.includes(this.state.uid)) {\n+        this._currentQueryParams = a.search;\n+      }\n+    });",
        "comment_created_at": "2025-07-03T10:28:07+00:00",
        "comment_author": "dprokop",
        "comment_body": "> History events happen before route changes\r\n\r\n@torkelo That's exactly what is needed here. I want to capture the url state before the route has change. I.e. imagine we are on `/d/<UID>?orgId=1&var-a=1` and we are navigating using i.e. a link to `/d/<UID-1>`. To preserve the location correctly, I need to capture `var-a=1` before the url has updated, and this code does exactly that.",
        "pr_file_module": null
      },
      {
        "comment_id": "2182632503",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107521,
        "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
        "discussion_id": "2182091444",
        "commented_code": "@@ -213,10 +217,37 @@ export class DashboardScene extends SceneObjectBase<DashboardSceneState> impleme\n     this.addActivationHandler(() => this._activationHandler());\n   }\n \n+  // Setups a listener to the url and saves the current query params if the url is the url of this dashboard scene.\n+  private setupUrlListener = () => {\n+    // return a noop function if the feature toggle is disabled\n+    if (!config.featureToggles.preserveDashboardStateWhenNavigating) {\n+      return () => {};\n+    }\n+\n+    const unlisten = locationService.getHistory().listen((a) => {\n+      if (this.state.uid && a.pathname.includes(this.state.uid)) {\n+        this._currentQueryParams = a.search;\n+      }\n+    });",
        "comment_created_at": "2025-07-03T12:14:01+00:00",
        "comment_author": "torkelo",
        "comment_body": "@dprokop not sure I follow, why do you need the event before the route change? It looks like you ignore the history event when uid does not match (which is the one before the route change). \r\n\r\n> I.e. imagine we are on /d/<UID>?orgId=1&var-a=1 and we are navigating using i.e. a link to /d/<UID-1>. To preserve the location correctly, I need to capture var-a=1 before the url has updated, and this code does exactly that.\r\n\r\nIf you add this to DashboardSceneRenderer (in render code or in useEffect, does not matter as _currentQueryParams is not part of state that triggers react re-render). \r\n\r\n```\r\nmodel.rememberSearchParams(location.search) \r\n```\r\n\r\nWould only save the URL before the link click to another dashboard ",
        "pr_file_module": null
      },
      {
        "comment_id": "2182778363",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107521,
        "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
        "discussion_id": "2182091444",
        "commented_code": "@@ -213,10 +217,37 @@ export class DashboardScene extends SceneObjectBase<DashboardSceneState> impleme\n     this.addActivationHandler(() => this._activationHandler());\n   }\n \n+  // Setups a listener to the url and saves the current query params if the url is the url of this dashboard scene.\n+  private setupUrlListener = () => {\n+    // return a noop function if the feature toggle is disabled\n+    if (!config.featureToggles.preserveDashboardStateWhenNavigating) {\n+      return () => {};\n+    }\n+\n+    const unlisten = locationService.getHistory().listen((a) => {\n+      if (this.state.uid && a.pathname.includes(this.state.uid)) {\n+        this._currentQueryParams = a.search;\n+      }\n+    });",
        "comment_created_at": "2025-07-03T13:24:19+00:00",
        "comment_author": "dprokop",
        "comment_body": "@torkelo but adding this to the render path or useEffect will cause the params to be remembered every time the page renders. What I want tho is to remember the state of the url when I navigate to another dashboard, so that another dashboard can restore the url state when it initializes. If we do it in the render path, then we are always restoring the \"own\" params, don't we?\r\n\r\n>  It looks like you ignore the history event when uid does not match (which is the one before the route change)\r\n\r\nBecause i only care about the state of the dashboard I'm navigating away from",
        "pr_file_module": null
      },
      {
        "comment_id": "2183024701",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107521,
        "pr_file": "public/app/features/dashboard-scene/scene/DashboardScene.tsx",
        "discussion_id": "2182091444",
        "commented_code": "@@ -213,10 +217,37 @@ export class DashboardScene extends SceneObjectBase<DashboardSceneState> impleme\n     this.addActivationHandler(() => this._activationHandler());\n   }\n \n+  // Setups a listener to the url and saves the current query params if the url is the url of this dashboard scene.\n+  private setupUrlListener = () => {\n+    // return a noop function if the feature toggle is disabled\n+    if (!config.featureToggles.preserveDashboardStateWhenNavigating) {\n+      return () => {};\n+    }\n+\n+    const unlisten = locationService.getHistory().listen((a) => {\n+      if (this.state.uid && a.pathname.includes(this.state.uid)) {\n+        this._currentQueryParams = a.search;\n+      }\n+    });",
        "comment_created_at": "2025-07-03T15:03:42+00:00",
        "comment_author": "torkelo",
        "comment_body": "> but adding this to the render path or useEffect will cause the params to be remembered every time the page renders.\r\n\r\nBut your code will also update the _currentQueryParams everytime the URL changes. But subscribing directly to history will also subscribe to history events that are unrelated to the current dashboard, something useLocation fixes. \r\n\r\n> What I want tho is to remember the state of the url when I navigate to another dashboard\r\n\r\nyes, that is what will happen. useLocation inside DashboardSceneRenderer will not return a location for different dashboard so no need to compare uid. ",
        "pr_file_module": null
      }
    ]
  }
]