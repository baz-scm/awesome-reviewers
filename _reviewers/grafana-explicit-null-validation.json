[
  {
    "discussion_id": "2177914619",
    "pr_number": 106851,
    "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
    "created_at": "2025-07-01T15:32:51+00:00",
    "commented_code": "return GetDataSourceRef(ds)\n \t}\n \n-\tif dsName, ok := nameOrRef.(string); ok && dsName != \"\" {\n+\t// Handle string cases (including empty strings)\n+\tif dsName, ok := nameOrRef.(string); ok {\n+\t\tif dsName == \"\" {\n+\t\t\t// Empty string should return empty object (frontend behavior)\n+\t\t\treturn map[string]interface{}{}\n+\t\t}",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2177914619",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106851,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2177914619",
        "commented_code": "@@ -100,7 +102,13 @@ func MigrateDatasourceNameToRef(nameOrRef interface{}, options map[string]bool,\n \t\treturn GetDataSourceRef(ds)\n \t}\n \n-\tif dsName, ok := nameOrRef.(string); ok && dsName != \"\" {\n+\t// Handle string cases (including empty strings)\n+\tif dsName, ok := nameOrRef.(string); ok {\n+\t\tif dsName == \"\" {\n+\t\t\t// Empty string should return empty object (frontend behavior)\n+\t\t\treturn map[string]interface{}{}\n+\t\t}",
        "comment_created_at": "2025-07-01T15:32:51+00:00",
        "comment_author": "dprokop",
        "comment_body": "this is suspicious, shouldn't it retun `nil`? Can't see this behavior in the FE, but I may be blind ðŸ™„ ",
        "pr_file_module": null
      },
      {
        "comment_id": "2177917720",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106851,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2177914619",
        "commented_code": "@@ -100,7 +102,13 @@ func MigrateDatasourceNameToRef(nameOrRef interface{}, options map[string]bool,\n \t\treturn GetDataSourceRef(ds)\n \t}\n \n-\tif dsName, ok := nameOrRef.(string); ok && dsName != \"\" {\n+\t// Handle string cases (including empty strings)\n+\tif dsName, ok := nameOrRef.(string); ok {\n+\t\tif dsName == \"\" {\n+\t\t\t// Empty string should return empty object (frontend behavior)\n+\t\t\treturn map[string]interface{}{}\n+\t\t}",
        "comment_created_at": "2025-07-01T15:34:32+00:00",
        "comment_author": "dprokop",
        "comment_body": "there's even a `empty string should return nil` test case for empty string :D",
        "pr_file_module": null
      },
      {
        "comment_id": "2177945206",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106851,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2177914619",
        "commented_code": "@@ -100,7 +102,13 @@ func MigrateDatasourceNameToRef(nameOrRef interface{}, options map[string]bool,\n \t\treturn GetDataSourceRef(ds)\n \t}\n \n-\tif dsName, ok := nameOrRef.(string); ok && dsName != \"\" {\n+\t// Handle string cases (including empty strings)\n+\tif dsName, ok := nameOrRef.(string); ok {\n+\t\tif dsName == \"\" {\n+\t\t\t// Empty string should return empty object (frontend behavior)\n+\t\t\treturn map[string]interface{}{}\n+\t\t}",
        "comment_created_at": "2025-07-01T15:49:21+00:00",
        "comment_author": "ivanortegaalba",
        "comment_body": "It is because falsy values are falling back to an empty object. This was detected by the comparator; if we leave the name as an empty string, it would fall back to an empty object. I guess because none of the DS attributes can be calculated.",
        "pr_file_module": null
      },
      {
        "comment_id": "2179501002",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106851,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2177914619",
        "commented_code": "@@ -100,7 +102,13 @@ func MigrateDatasourceNameToRef(nameOrRef interface{}, options map[string]bool,\n \t\treturn GetDataSourceRef(ds)\n \t}\n \n-\tif dsName, ok := nameOrRef.(string); ok && dsName != \"\" {\n+\t// Handle string cases (including empty strings)\n+\tif dsName, ok := nameOrRef.(string); ok {\n+\t\tif dsName == \"\" {\n+\t\t\t// Empty string should return empty object (frontend behavior)\n+\t\t\treturn map[string]interface{}{}\n+\t\t}",
        "comment_created_at": "2025-07-02T08:52:23+00:00",
        "comment_author": "dprokop",
        "comment_body": "> if we leave the name as an empty string, it would fall back to an empty object\r\n\r\ndo you mean this is how FE migration currently does it?",
        "pr_file_module": null
      },
      {
        "comment_id": "2182360788",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106851,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2177914619",
        "commented_code": "@@ -100,7 +102,13 @@ func MigrateDatasourceNameToRef(nameOrRef interface{}, options map[string]bool,\n \t\treturn GetDataSourceRef(ds)\n \t}\n \n-\tif dsName, ok := nameOrRef.(string); ok && dsName != \"\" {\n+\t// Handle string cases (including empty strings)\n+\tif dsName, ok := nameOrRef.(string); ok {\n+\t\tif dsName == \"\" {\n+\t\t\t// Empty string should return empty object (frontend behavior)\n+\t\t\treturn map[string]interface{}{}\n+\t\t}",
        "comment_created_at": "2025-07-03T09:50:57+00:00",
        "comment_author": "ivanortegaalba",
        "comment_body": "Yes! This exactly matches with frontend logic!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169256281",
    "pr_number": 106848,
    "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
    "created_at": "2025-06-26T14:48:09+00:00",
    "commented_code": "+package schemaversion\n+\n+// Shared utility functions for datasource migrations across different schema versions.\n+// These functions handle the common logic for migrating datasource references from\n+// string names/UIDs to structured reference objects with uid, type, and apiVersion.\n+\n+// GetDataSourceRef creates a datasource reference object with uid, type and optional apiVersion\n+func GetDataSourceRef(ds *DataSourceInfo) map[string]interface{} {\n+\tif ds == nil {\n+\t\treturn nil\n+\t}\n+\tref := map[string]interface{}{\n+\t\t\"uid\":  ds.UID,\n+\t\t\"type\": ds.Type,\n+\t}\n+\tif ds.APIVersion != \"\" {\n+\t\tref[\"apiVersion\"] = ds.APIVersion\n+\t}\n+\treturn ref\n+}\n+\n+// GetDefaultDSInstanceSettings returns the default datasource if one exists\n+func GetDefaultDSInstanceSettings(datasources []DataSourceInfo) *DataSourceInfo {\n+\tfor _, ds := range datasources {\n+\t\tif ds.Default {\n+\t\t\treturn &DataSourceInfo{\n+\t\t\t\tUID:        ds.UID,\n+\t\t\t\tType:       ds.Type,\n+\t\t\t\tName:       ds.Name,\n+\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// GetInstanceSettings looks up a datasource by name or uid reference\n+func GetInstanceSettings(nameOrRef interface{}, datasources []DataSourceInfo) *DataSourceInfo {\n+\tif nameOrRef == nil || nameOrRef == \"default\" {\n+\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t}\n+\n+\t// Check if it's a reference object without UID - should return default\n+\tif ref, ok := nameOrRef.(map[string]interface{}); ok {\n+\t\tif _, hasUID := ref[\"uid\"]; !hasUID {\n+\t\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t\t}\n+\t\t// It's a reference object with UID, search for matching UID\n+\t\tfor _, ds := range datasources {\n+\t\t\tif uid, hasUID := ref[\"uid\"]; hasUID && uid == ds.UID {\n+\t\t\t\treturn &DataSourceInfo{\n+\t\t\t\t\tUID:        ds.UID,\n+\t\t\t\t\tType:       ds.Type,\n+\t\t\t\t\tName:       ds.Name,\n+\t\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2169256281",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106848,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2169256281",
        "commented_code": "@@ -0,0 +1,110 @@\n+package schemaversion\n+\n+// Shared utility functions for datasource migrations across different schema versions.\n+// These functions handle the common logic for migrating datasource references from\n+// string names/UIDs to structured reference objects with uid, type, and apiVersion.\n+\n+// GetDataSourceRef creates a datasource reference object with uid, type and optional apiVersion\n+func GetDataSourceRef(ds *DataSourceInfo) map[string]interface{} {\n+\tif ds == nil {\n+\t\treturn nil\n+\t}\n+\tref := map[string]interface{}{\n+\t\t\"uid\":  ds.UID,\n+\t\t\"type\": ds.Type,\n+\t}\n+\tif ds.APIVersion != \"\" {\n+\t\tref[\"apiVersion\"] = ds.APIVersion\n+\t}\n+\treturn ref\n+}\n+\n+// GetDefaultDSInstanceSettings returns the default datasource if one exists\n+func GetDefaultDSInstanceSettings(datasources []DataSourceInfo) *DataSourceInfo {\n+\tfor _, ds := range datasources {\n+\t\tif ds.Default {\n+\t\t\treturn &DataSourceInfo{\n+\t\t\t\tUID:        ds.UID,\n+\t\t\t\tType:       ds.Type,\n+\t\t\t\tName:       ds.Name,\n+\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// GetInstanceSettings looks up a datasource by name or uid reference\n+func GetInstanceSettings(nameOrRef interface{}, datasources []DataSourceInfo) *DataSourceInfo {\n+\tif nameOrRef == nil || nameOrRef == \"default\" {\n+\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t}\n+\n+\t// Check if it's a reference object without UID - should return default\n+\tif ref, ok := nameOrRef.(map[string]interface{}); ok {\n+\t\tif _, hasUID := ref[\"uid\"]; !hasUID {\n+\t\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t\t}\n+\t\t// It's a reference object with UID, search for matching UID\n+\t\tfor _, ds := range datasources {\n+\t\t\tif uid, hasUID := ref[\"uid\"]; hasUID && uid == ds.UID {\n+\t\t\t\treturn &DataSourceInfo{\n+\t\t\t\t\tUID:        ds.UID,\n+\t\t\t\t\tType:       ds.Type,\n+\t\t\t\t\tName:       ds.Name,\n+\t\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil",
        "comment_created_at": "2025-06-26T14:48:09+00:00",
        "comment_author": "stephaniehingtgen",
        "comment_body": "Do we want to return the default datasource if not found as well?",
        "pr_file_module": null
      },
      {
        "comment_id": "2169256746",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106848,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2169256281",
        "commented_code": "@@ -0,0 +1,110 @@\n+package schemaversion\n+\n+// Shared utility functions for datasource migrations across different schema versions.\n+// These functions handle the common logic for migrating datasource references from\n+// string names/UIDs to structured reference objects with uid, type, and apiVersion.\n+\n+// GetDataSourceRef creates a datasource reference object with uid, type and optional apiVersion\n+func GetDataSourceRef(ds *DataSourceInfo) map[string]interface{} {\n+\tif ds == nil {\n+\t\treturn nil\n+\t}\n+\tref := map[string]interface{}{\n+\t\t\"uid\":  ds.UID,\n+\t\t\"type\": ds.Type,\n+\t}\n+\tif ds.APIVersion != \"\" {\n+\t\tref[\"apiVersion\"] = ds.APIVersion\n+\t}\n+\treturn ref\n+}\n+\n+// GetDefaultDSInstanceSettings returns the default datasource if one exists\n+func GetDefaultDSInstanceSettings(datasources []DataSourceInfo) *DataSourceInfo {\n+\tfor _, ds := range datasources {\n+\t\tif ds.Default {\n+\t\t\treturn &DataSourceInfo{\n+\t\t\t\tUID:        ds.UID,\n+\t\t\t\tType:       ds.Type,\n+\t\t\t\tName:       ds.Name,\n+\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// GetInstanceSettings looks up a datasource by name or uid reference\n+func GetInstanceSettings(nameOrRef interface{}, datasources []DataSourceInfo) *DataSourceInfo {\n+\tif nameOrRef == nil || nameOrRef == \"default\" {\n+\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t}\n+\n+\t// Check if it's a reference object without UID - should return default\n+\tif ref, ok := nameOrRef.(map[string]interface{}); ok {\n+\t\tif _, hasUID := ref[\"uid\"]; !hasUID {\n+\t\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t\t}\n+\t\t// It's a reference object with UID, search for matching UID\n+\t\tfor _, ds := range datasources {\n+\t\t\tif uid, hasUID := ref[\"uid\"]; hasUID && uid == ds.UID {\n+\t\t\t\treturn &DataSourceInfo{\n+\t\t\t\t\tUID:        ds.UID,\n+\t\t\t\t\tType:       ds.Type,\n+\t\t\t\t\tName:       ds.Name,\n+\t\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil",
        "comment_created_at": "2025-06-26T14:48:22+00:00",
        "comment_author": "stephaniehingtgen",
        "comment_body": "Same question for the other three `return nil`",
        "pr_file_module": null
      },
      {
        "comment_id": "2169376288",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106848,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/datasource_utils.go",
        "discussion_id": "2169256281",
        "commented_code": "@@ -0,0 +1,110 @@\n+package schemaversion\n+\n+// Shared utility functions for datasource migrations across different schema versions.\n+// These functions handle the common logic for migrating datasource references from\n+// string names/UIDs to structured reference objects with uid, type, and apiVersion.\n+\n+// GetDataSourceRef creates a datasource reference object with uid, type and optional apiVersion\n+func GetDataSourceRef(ds *DataSourceInfo) map[string]interface{} {\n+\tif ds == nil {\n+\t\treturn nil\n+\t}\n+\tref := map[string]interface{}{\n+\t\t\"uid\":  ds.UID,\n+\t\t\"type\": ds.Type,\n+\t}\n+\tif ds.APIVersion != \"\" {\n+\t\tref[\"apiVersion\"] = ds.APIVersion\n+\t}\n+\treturn ref\n+}\n+\n+// GetDefaultDSInstanceSettings returns the default datasource if one exists\n+func GetDefaultDSInstanceSettings(datasources []DataSourceInfo) *DataSourceInfo {\n+\tfor _, ds := range datasources {\n+\t\tif ds.Default {\n+\t\t\treturn &DataSourceInfo{\n+\t\t\t\tUID:        ds.UID,\n+\t\t\t\tType:       ds.Type,\n+\t\t\t\tName:       ds.Name,\n+\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// GetInstanceSettings looks up a datasource by name or uid reference\n+func GetInstanceSettings(nameOrRef interface{}, datasources []DataSourceInfo) *DataSourceInfo {\n+\tif nameOrRef == nil || nameOrRef == \"default\" {\n+\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t}\n+\n+\t// Check if it's a reference object without UID - should return default\n+\tif ref, ok := nameOrRef.(map[string]interface{}); ok {\n+\t\tif _, hasUID := ref[\"uid\"]; !hasUID {\n+\t\t\treturn GetDefaultDSInstanceSettings(datasources)\n+\t\t}\n+\t\t// It's a reference object with UID, search for matching UID\n+\t\tfor _, ds := range datasources {\n+\t\t\tif uid, hasUID := ref[\"uid\"]; hasUID && uid == ds.UID {\n+\t\t\t\treturn &DataSourceInfo{\n+\t\t\t\t\tUID:        ds.UID,\n+\t\t\t\t\tType:       ds.Type,\n+\t\t\t\t\tName:       ds.Name,\n+\t\t\t\t\tAPIVersion: ds.APIVersion,\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn nil",
        "comment_created_at": "2025-06-26T15:45:52+00:00",
        "comment_author": "ivanortegaalba",
        "comment_body": "Good catch! I just fixed it. This will make it consistent with the frontend",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2169263160",
    "pr_number": 106848,
    "pr_file": "apps/dashboard/pkg/migration/schemaversion/v33.go",
    "created_at": "2025-06-26T14:51:15+00:00",
    "commented_code": "+package schemaversion\n+\n+// V33 migrates panel datasource references from string names to UIDs.\n+//\n+// This migration addresses datasource references in dashboard panels and their targets\n+// that use the legacy string format. The migration converts these references to the new\n+// structured format with uid, type, and apiVersion fields.\n+//\n+// The migration works by:\n+// 1. Identifying datasource references in panel-level datasource fields\n+// 2. Converting string datasource references to structured reference objects\n+// 3. Migrating target-level datasource references within each panel\n+// 4. Handling nested panels in collapsed rows\n+// 5. Always setting panel datasource (even if migration returns nil)\n+// 6. Only setting target datasource if migration returns non-nil (preserves originals when nil)\n+// 7. Using returnDefaultAsNull: true (so \"default\" and nil become nil for panels, preserved for targets)\n+//\n+// Panel Datasource Example - String to Object:\n+//\n+// Before migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": \"prometheus-uid\",\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": \"elasticsearch-name\" },\n+//\t    { \"refId\": \"B\", \"datasource\": null }\n+//\t  ]\n+//\t}\n+//\n+// After migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": { \"uid\": \"prometheus-uid\", \"type\": \"prometheus\", \"apiVersion\": \"v1\" },\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": { \"uid\": \"elasticsearch-uid\", \"type\": \"elasticsearch\", \"apiVersion\": \"v2\" } },\n+//\t    { \"refId\": \"B\", \"datasource\": null }\n+//\t  ]\n+//\t}\n+//\n+// Default Datasource Example - Null Conversion:\n+//\n+// Before migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": \"default\",\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": \"default\" }\n+//\t  ]\n+//\t}\n+//\n+// After migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": null,\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": \"default\" }\n+//\t  ]\n+//\t}\n+func V33(dsInfo DataSourceInfoProvider) SchemaVersionMigrationFunc {\n+\tdatasources := dsInfo.GetDataSourceInfo()\n+\treturn func(dashboard map[string]interface{}) error {\n+\t\tdashboard[\"schemaVersion\"] = int(33)\n+\n+\t\tmigratePanelsV33(dashboard, datasources)\n+\n+\t\treturn nil\n+\t}\n+}\n+\n+// migratePanelsV33 updates datasource references in dashboard panels for V33 migration\n+func migratePanelsV33(dashboard map[string]interface{}, datasources []DataSourceInfo) {\n+\tpanels, ok := dashboard[\"panels\"].([]interface{})",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2169263160",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106848,
        "pr_file": "apps/dashboard/pkg/migration/schemaversion/v33.go",
        "discussion_id": "2169263160",
        "commented_code": "@@ -0,0 +1,133 @@\n+package schemaversion\n+\n+// V33 migrates panel datasource references from string names to UIDs.\n+//\n+// This migration addresses datasource references in dashboard panels and their targets\n+// that use the legacy string format. The migration converts these references to the new\n+// structured format with uid, type, and apiVersion fields.\n+//\n+// The migration works by:\n+// 1. Identifying datasource references in panel-level datasource fields\n+// 2. Converting string datasource references to structured reference objects\n+// 3. Migrating target-level datasource references within each panel\n+// 4. Handling nested panels in collapsed rows\n+// 5. Always setting panel datasource (even if migration returns nil)\n+// 6. Only setting target datasource if migration returns non-nil (preserves originals when nil)\n+// 7. Using returnDefaultAsNull: true (so \"default\" and nil become nil for panels, preserved for targets)\n+//\n+// Panel Datasource Example - String to Object:\n+//\n+// Before migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": \"prometheus-uid\",\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": \"elasticsearch-name\" },\n+//\t    { \"refId\": \"B\", \"datasource\": null }\n+//\t  ]\n+//\t}\n+//\n+// After migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": { \"uid\": \"prometheus-uid\", \"type\": \"prometheus\", \"apiVersion\": \"v1\" },\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": { \"uid\": \"elasticsearch-uid\", \"type\": \"elasticsearch\", \"apiVersion\": \"v2\" } },\n+//\t    { \"refId\": \"B\", \"datasource\": null }\n+//\t  ]\n+//\t}\n+//\n+// Default Datasource Example - Null Conversion:\n+//\n+// Before migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": \"default\",\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": \"default\" }\n+//\t  ]\n+//\t}\n+//\n+// After migration:\n+//\n+//\tpanel: {\n+//\t  \"datasource\": null,\n+//\t  \"targets\": [\n+//\t    { \"refId\": \"A\", \"datasource\": \"default\" }\n+//\t  ]\n+//\t}\n+func V33(dsInfo DataSourceInfoProvider) SchemaVersionMigrationFunc {\n+\tdatasources := dsInfo.GetDataSourceInfo()\n+\treturn func(dashboard map[string]interface{}) error {\n+\t\tdashboard[\"schemaVersion\"] = int(33)\n+\n+\t\tmigratePanelsV33(dashboard, datasources)\n+\n+\t\treturn nil\n+\t}\n+}\n+\n+// migratePanelsV33 updates datasource references in dashboard panels for V33 migration\n+func migratePanelsV33(dashboard map[string]interface{}, datasources []DataSourceInfo) {\n+\tpanels, ok := dashboard[\"panels\"].([]interface{})",
        "comment_created_at": "2025-06-26T14:51:15+00:00",
        "comment_author": "stephaniehingtgen",
        "comment_body": "also should check here if the dashboard is nil",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2155389324",
    "pr_number": 106739,
    "pr_file": "pkg/registry/apis/secret/worker/worker.go",
    "created_at": "2025-06-18T19:55:25+00:00",
    "commented_code": "}\n \n func (w *Worker) processMessage(ctx context.Context, message contracts.OutboxMessage) error {\n-\topts := []trace.SpanStartOption{}\n+\tstart := time.Now()\n+\tvar keeperType string",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2155400206",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106739,
        "pr_file": "pkg/registry/apis/secret/worker/worker.go",
        "discussion_id": "2155389324",
        "commented_code": "@@ -130,8 +134,14 @@ func (w *Worker) ReceiveAndProcessMessages(ctx context.Context) error {\n }\n \n func (w *Worker) processMessage(ctx context.Context, message contracts.OutboxMessage) error {\n-\topts := []trace.SpanStartOption{}\n+\tstart := time.Now()\n+\tvar keeperType string",
        "comment_created_at": "2025-06-18T20:02:27+00:00",
        "comment_author": "mmandrus",
        "comment_body": "Fixed https://github.com/grafana/grafana/pull/106739/commits/427fefe697ed49b7c5229a3c592c9ae74f6521c4",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1634129743",
    "pr_number": 88886,
    "pr_file": "pkg/apiserver/rest/dualwriter_mode2.go",
    "created_at": "2024-06-11T03:33:03+00:00",
    "commented_code": "}\n \n func enrichLegacyObject(originalObj, returnedObj runtime.Object, created bool) (runtime.Object, error) {\n-\taccessorReturned, err := meta.Accessor(returnedObj)\n+\tif returnedObj == nil {\n+\t\treturn nil, errors.New(\"cannot enrich nil object\")\n+\t}\n+\tret := returnedObj.DeepCopyObject()",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1634129743",
        "repo_full_name": "grafana/grafana",
        "pr_number": 88886,
        "pr_file": "pkg/apiserver/rest/dualwriter_mode2.go",
        "discussion_id": "1634129743",
        "commented_code": "@@ -347,7 +348,12 @@ func parseList(legacyList []runtime.Object) (metainternalversion.ListOptions, ma\n }\n \n func enrichLegacyObject(originalObj, returnedObj runtime.Object, created bool) (runtime.Object, error) {\n-\taccessorReturned, err := meta.Accessor(returnedObj)\n+\tif returnedObj == nil {\n+\t\treturn nil, errors.New(\"cannot enrich nil object\")\n+\t}\n+\tret := returnedObj.DeepCopyObject()",
        "comment_created_at": "2024-06-11T03:33:03+00:00",
        "comment_author": "diegommm",
        "comment_body": "I think this was the root cause at all times: `enrichLegacyObject` takes two objects and returns a third one, but it changes the input at the same time: it is modifying `returnedObj` because it's a pointer type. If `enrichLegacyObject` is expected to actually modify the input, then it should probably not return a `runtime.Object` since the input is already changed, otherwise it could be misleading.",
        "pr_file_module": null
      },
      {
        "comment_id": "1634811482",
        "repo_full_name": "grafana/grafana",
        "pr_number": 88886,
        "pr_file": "pkg/apiserver/rest/dualwriter_mode2.go",
        "discussion_id": "1634129743",
        "commented_code": "@@ -347,7 +348,12 @@ func parseList(legacyList []runtime.Object) (metainternalversion.ListOptions, ma\n }\n \n func enrichLegacyObject(originalObj, returnedObj runtime.Object, created bool) (runtime.Object, error) {\n-\taccessorReturned, err := meta.Accessor(returnedObj)\n+\tif returnedObj == nil {\n+\t\treturn nil, errors.New(\"cannot enrich nil object\")\n+\t}\n+\tret := returnedObj.DeepCopyObject()",
        "comment_created_at": "2024-06-11T12:38:49+00:00",
        "comment_author": "leonorfmartins",
        "comment_body": "yes, we should totally change this fn's signature, I'm making a note to do just that. I learned only too late that these accessors would modify the object. Thanks for fixing that!",
        "pr_file_module": null
      }
    ]
  }
]