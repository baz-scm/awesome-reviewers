[
  {
    "discussion_id": "2166055047",
    "pr_number": 107130,
    "pr_file": "pkg/services/authz/zanzana.go",
    "created_at": "2025-06-25T07:56:00+00:00",
    "commented_code": "return fmt.Errorf(\"failed to start zanzana: %w\", err)\n \t}\n \n-\tauthenticator := authnlib.NewAccessTokenAuthenticator(\n-\t\tauthnlib.NewAccessTokenVerifier(\n-\t\t\tauthnlib.VerifierConfig{AllowedAudiences: []string{AuthzServiceAudience}},\n-\t\t\tauthnlib.NewKeyRetriever(authnlib.KeyRetrieverConfig{\n-\t\t\t\tSigningKeysURL: z.cfg.ZanzanaServer.SigningKeysURL,\n-\t\t\t}),\n-\t\t),\n-\t)\n+\tvar authenticatorInterceptor interceptors.Authenticator\n+\tif z.cfg.ZanzanaServer.AllowInsecure {",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2166055047",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107130,
        "pr_file": "pkg/services/authz/zanzana.go",
        "discussion_id": "2166055047",
        "commented_code": "@@ -177,19 +177,32 @@ func (z *Zanzana) start(ctx context.Context) error {\n \t\treturn fmt.Errorf(\"failed to start zanzana: %w\", err)\n \t}\n \n-\tauthenticator := authnlib.NewAccessTokenAuthenticator(\n-\t\tauthnlib.NewAccessTokenVerifier(\n-\t\t\tauthnlib.VerifierConfig{AllowedAudiences: []string{AuthzServiceAudience}},\n-\t\t\tauthnlib.NewKeyRetriever(authnlib.KeyRetrieverConfig{\n-\t\t\t\tSigningKeysURL: z.cfg.ZanzanaServer.SigningKeysURL,\n-\t\t\t}),\n-\t\t),\n-\t)\n+\tvar authenticatorInterceptor interceptors.Authenticator\n+\tif z.cfg.ZanzanaServer.AllowInsecure {",
        "comment_created_at": "2025-06-25T07:56:00+00:00",
        "comment_author": "alexanderzobnin",
        "comment_body": "We could also add protection to allow insecure mode only in \"development\" environment, not in production. Something like:\r\n\r\n```suggestion\r\n\tif z.cfg.ZanzanaServer.AllowInsecure && z.cfg.Env == setting.Dev {\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "2166901779",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107130,
        "pr_file": "pkg/services/authz/zanzana.go",
        "discussion_id": "2166055047",
        "commented_code": "@@ -177,19 +177,32 @@ func (z *Zanzana) start(ctx context.Context) error {\n \t\treturn fmt.Errorf(\"failed to start zanzana: %w\", err)\n \t}\n \n-\tauthenticator := authnlib.NewAccessTokenAuthenticator(\n-\t\tauthnlib.NewAccessTokenVerifier(\n-\t\t\tauthnlib.VerifierConfig{AllowedAudiences: []string{AuthzServiceAudience}},\n-\t\t\tauthnlib.NewKeyRetriever(authnlib.KeyRetrieverConfig{\n-\t\t\t\tSigningKeysURL: z.cfg.ZanzanaServer.SigningKeysURL,\n-\t\t\t}),\n-\t\t),\n-\t)\n+\tvar authenticatorInterceptor interceptors.Authenticator\n+\tif z.cfg.ZanzanaServer.AllowInsecure {",
        "comment_created_at": "2025-06-25T14:39:31+00:00",
        "comment_author": "forsethc",
        "comment_body": "Good call.  I thought about that yesterday after opening the PR but wasn't sure where that config point lived.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2126893368",
    "pr_number": 106335,
    "pr_file": "pkg/services/pluginsintegration/pluginaccesscontrol/accesscontrol.go",
    "created_at": "2025-06-04T15:30:13+00:00",
    "commented_code": "ac.ActionAlertingNotificationsExternalWrite: true,\n }\n \n-// GetDataSourceRouteEvaluator returns an evaluator for the given data source UID and action.\n-func GetDataSourceRouteEvaluator(dsUID, action string) ac.Evaluator {\n+// NOTE: remove me before commit\n+// made this private to avoid confusion with the external GetDataSourceRouteMultiActionEvaluator\n+// getDataSourceRouteEvaluator returns an evaluator for the given data source UID and action.\n+func getDataSourceRouteEvaluator(dsUID, action string) ac.Evaluator {\n \tif datasourcesActions[action] {\n \t\treturn ac.EvalPermission(action, \"datasources:uid:\"+dsUID)\n \t}\n \treturn ac.EvalPermission(action)\n }\n \n+// GetDataSourceRouteMultiActionEvaluator returns an evaluator for multiple data source actions (OR logic)\n+func GetDataSourceRouteMultiActionEvaluator(dsUID string, actions []string) ac.Evaluator {\n+\tif len(actions) == 0 {\n+\t\treturn ac.EvalPermission(\"\") // Always deny\n+\t}",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2126893368",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106335,
        "pr_file": "pkg/services/pluginsintegration/pluginaccesscontrol/accesscontrol.go",
        "discussion_id": "2126893368",
        "commented_code": "@@ -107,23 +107,61 @@ var datasourcesActions = map[string]bool{\n \tac.ActionAlertingNotificationsExternalWrite: true,\n }\n \n-// GetDataSourceRouteEvaluator returns an evaluator for the given data source UID and action.\n-func GetDataSourceRouteEvaluator(dsUID, action string) ac.Evaluator {\n+// NOTE: remove me before commit\n+// made this private to avoid confusion with the external GetDataSourceRouteMultiActionEvaluator\n+// getDataSourceRouteEvaluator returns an evaluator for the given data source UID and action.\n+func getDataSourceRouteEvaluator(dsUID, action string) ac.Evaluator {\n \tif datasourcesActions[action] {\n \t\treturn ac.EvalPermission(action, \"datasources:uid:\"+dsUID)\n \t}\n \treturn ac.EvalPermission(action)\n }\n \n+// GetDataSourceRouteMultiActionEvaluator returns an evaluator for multiple data source actions (OR logic)\n+func GetDataSourceRouteMultiActionEvaluator(dsUID string, actions []string) ac.Evaluator {\n+\tif len(actions) == 0 {\n+\t\treturn ac.EvalPermission(\"\") // Always deny\n+\t}",
        "comment_created_at": "2025-06-04T15:30:13+00:00",
        "comment_author": "IevaVasiljeva",
        "comment_body": "We should never encounter this case here, so I'm not sure how to best treat it. Feels wrong to deny, but feels risky to allow. Also feels weird to be denying by using `EvalPermission(\"\")`. Something like \"no opinion\" that was implemented for the new APIs evaluators would be suitable, but that's probably overcomplicating it. If you stick with this code, could you please add a comment stating that this code should never be hit?",
        "pr_file_module": null
      },
      {
        "comment_id": "2152454383",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106335,
        "pr_file": "pkg/services/pluginsintegration/pluginaccesscontrol/accesscontrol.go",
        "discussion_id": "2126893368",
        "commented_code": "@@ -107,23 +107,61 @@ var datasourcesActions = map[string]bool{\n \tac.ActionAlertingNotificationsExternalWrite: true,\n }\n \n-// GetDataSourceRouteEvaluator returns an evaluator for the given data source UID and action.\n-func GetDataSourceRouteEvaluator(dsUID, action string) ac.Evaluator {\n+// NOTE: remove me before commit\n+// made this private to avoid confusion with the external GetDataSourceRouteMultiActionEvaluator\n+// getDataSourceRouteEvaluator returns an evaluator for the given data source UID and action.\n+func getDataSourceRouteEvaluator(dsUID, action string) ac.Evaluator {\n \tif datasourcesActions[action] {\n \t\treturn ac.EvalPermission(action, \"datasources:uid:\"+dsUID)\n \t}\n \treturn ac.EvalPermission(action)\n }\n \n+// GetDataSourceRouteMultiActionEvaluator returns an evaluator for multiple data source actions (OR logic)\n+func GetDataSourceRouteMultiActionEvaluator(dsUID string, actions []string) ac.Evaluator {\n+\tif len(actions) == 0 {\n+\t\treturn ac.EvalPermission(\"\") // Always deny\n+\t}",
        "comment_created_at": "2025-06-17T14:40:05+00:00",
        "comment_author": "eleijonmarck",
        "comment_body": "i actually removed this piece of code to make it easier. if we would have zero actions, we would hit the evaluator with zero evaluators which would result in a `false`. Meaning we would deny the request. Is this okay?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1409599875",
    "pr_number": 78599,
    "pr_file": "pkg/services/dashboards/database/database.go",
    "created_at": "2023-11-29T16:54:57+00:00",
    "commented_code": "sql, params := sb.ToSQL(limit, page)\n \n \terr = d.store.WithDbSession(ctx, func(sess *db.Session) error {\n+\t\tstart := time.Now()\n+\t\tdefer func() {\n+\t\t\td.log.Info(\"Original search query\", \"time\", time.Since(start), \"results\", len(res))\n+\t\t}()\n \t\treturn sess.SQL(sql, params...).Find(&res)\n \t})\n \n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// Only use modified search for non-empty search queries, otherwise it's just listing and new query can't help there yet.\n+\tif query.Title != \"\" && len(query.FolderUIDs) == 0 && len(query.FolderIds) == 0 { //nolint:staticcheck\n+\t\tresults, err := d.findDashboards(ctx, query)\n+\t\tif err != nil {\n+\t\t\td.log.Info(\"new search failed\", \"error\", err)\n+\t\t}\n+\t\treturn results, nil\n+\t}\n \treturn res, nil\n }\n \n+// searchHit represents a single matching row from the search query below.\n+type searchHit struct {\n+\tOrgID       int64  `xorm:\"org_id\"`\n+\tID          int64  `xorm:\"id\"` // this probably should be deprecated but it will break dashboard_tag table for now\n+\tKind        string `xorm:\"kind\"`\n+\tUID         string `xorm:\"uid\"`\n+\tTitle       string `xorm:\"title\"`\n+\tTerm        string `xorm:\"term\"`\n+\tFolderTitle string `xorm:\"folder_title\"`\n+\tFolderUID   string `xorm:\"folder_uid\"`\n+}\n+\n+// searchData is an input data for the search query template below.\n+type searchData struct {\n+\tSQLBuilder\n+\tText    string\n+\tOrgID   int64\n+\tUserID  int64\n+\tTeamIDs []int64\n+\tRole    string\n+\tLimit   int64\n+\n+\tDialect        migrator.Dialect\n+\tHasSplitScopes bool\n+}\n+\n+// SQLBuilder is a more-or-less reusable SQL query builder that is based on\n+// text/template. SQL is not a composable language really, so having all\n+// subqueries/partials/filters in one place helps to better understand the whole\n+// query.\n+// SQLBuilder is expected to be embedded into the data struct passed into the\n+// template. In a template one can use {{.Arg .Foo}} and it will replace that\n+// with a \"?\" placeholder appending the value of .Foo to the Params slice.\n+type SQLBuilder struct {\n+\tParams []any\n+}\n+\n+func (sb *SQLBuilder) Arg(v any) (sql string) { sb.Params = append(sb.Params, v); return \"?\" }\n+\n+var searchSQL = template.Must(template.New(\"\").Parse(`\n+{{- /*\n+####\n+#### Here come different implementations for the innermost full-text search query.\n+#### A query is expected to return a list of entities with their (OrgID, UID, Kind, Title, ParentFolderUID)\n+####\n+*/ -}}\n+{{- define \"text-search\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }}\n+{{ end }}\n+{{- define \"text-search-mysql-fts\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE MATCH(title) AGAINST({{ .Arg .Text }}) AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE MATCH(title) AGAINST({{ .Arg .Text }})\n+{{ end }}\n+{{- define \"text-search-legacy\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND is_folder\n+{{ end }}\n+\n+SELECT DISTINCT\n+\tentity.org_id, entity.kind, entity.uid, entity.id, entity.title,\n+\tdashboard_tag.term as term, f1.uid as folder_uid, f1.title as folder_title FROM (\n+\t{{- template \"text-search-legacy\" . -}}\n+) AS entity\n+LEFT JOIN folder f1 ON (entity.parent_uid = f1.uid AND entity.org_id = f1.org_id)\n+{{ if ne .UserID 0 }}   {{- /* If a user is not admin: need to filter by permissions */ -}}\n+LEFT JOIN folder f2 ON (f1.parent_uid     = f2.uid AND f1.org_id     = f2.org_id)\n+LEFT JOIN folder f3 ON (f2.parent_uid     = f3.uid AND f2.org_id     = f3.org_id)\n+LEFT JOIN folder f4 ON (f3.parent_uid     = f4.uid AND f3.org_id     = f4.org_id)\n+INNER JOIN permission p ON \n+p.role_id IN (\n+\tSELECT ur.role_id FROM user_role AS ur    WHERE ur.user_id = {{ .Arg .UserID }} AND (ur.org_id = {{ .Arg .OrgID }} OR ur.org_id = 0)\n+\tUNION\n+\tSELECT tr.role_id FROM team_role AS tr    WHERE tr.team_id IN (\n+\t\t{{- range $i, $el := .TeamIDs -}}\n+\t\t{{- if $i -}},{{- end -}}\n+\t\t{{- $.Arg $el -}}\n+\t\t{{- end -}}\n+\t) AND tr.org_id = {{ .Arg .OrgID }}\n+\tUNION\n+\tSELECT br.role_id FROM builtin_role AS br WHERE br.role IN ({{ .Arg .Role }}) AND (br.org_id = {{ .Arg .OrgID }} OR br.org_id = 0)\n+) AND (\n+{{ if .HasSplitScopes }}\n+\t{{- /* This permission check relies on the optimised (indexed) split scope columns in the permission table */ -}}\n+\t(\n+\t\tp.kind = 'dashboards' AND\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.identifier = entity.uid",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1409599875",
        "repo_full_name": "grafana/grafana",
        "pr_number": 78599,
        "pr_file": "pkg/services/dashboards/database/database.go",
        "discussion_id": "1409599875",
        "commented_code": "@@ -994,16 +997,220 @@ func (d *dashboardStore) FindDashboards(ctx context.Context, query *dashboards.F\n \tsql, params := sb.ToSQL(limit, page)\n \n \terr = d.store.WithDbSession(ctx, func(sess *db.Session) error {\n+\t\tstart := time.Now()\n+\t\tdefer func() {\n+\t\t\td.log.Info(\"Original search query\", \"time\", time.Since(start), \"results\", len(res))\n+\t\t}()\n \t\treturn sess.SQL(sql, params...).Find(&res)\n \t})\n \n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// Only use modified search for non-empty search queries, otherwise it's just listing and new query can't help there yet.\n+\tif query.Title != \"\" && len(query.FolderUIDs) == 0 && len(query.FolderIds) == 0 { //nolint:staticcheck\n+\t\tresults, err := d.findDashboards(ctx, query)\n+\t\tif err != nil {\n+\t\t\td.log.Info(\"new search failed\", \"error\", err)\n+\t\t}\n+\t\treturn results, nil\n+\t}\n \treturn res, nil\n }\n \n+// searchHit represents a single matching row from the search query below.\n+type searchHit struct {\n+\tOrgID       int64  `xorm:\"org_id\"`\n+\tID          int64  `xorm:\"id\"` // this probably should be deprecated but it will break dashboard_tag table for now\n+\tKind        string `xorm:\"kind\"`\n+\tUID         string `xorm:\"uid\"`\n+\tTitle       string `xorm:\"title\"`\n+\tTerm        string `xorm:\"term\"`\n+\tFolderTitle string `xorm:\"folder_title\"`\n+\tFolderUID   string `xorm:\"folder_uid\"`\n+}\n+\n+// searchData is an input data for the search query template below.\n+type searchData struct {\n+\tSQLBuilder\n+\tText    string\n+\tOrgID   int64\n+\tUserID  int64\n+\tTeamIDs []int64\n+\tRole    string\n+\tLimit   int64\n+\n+\tDialect        migrator.Dialect\n+\tHasSplitScopes bool\n+}\n+\n+// SQLBuilder is a more-or-less reusable SQL query builder that is based on\n+// text/template. SQL is not a composable language really, so having all\n+// subqueries/partials/filters in one place helps to better understand the whole\n+// query.\n+// SQLBuilder is expected to be embedded into the data struct passed into the\n+// template. In a template one can use {{.Arg .Foo}} and it will replace that\n+// with a \"?\" placeholder appending the value of .Foo to the Params slice.\n+type SQLBuilder struct {\n+\tParams []any\n+}\n+\n+func (sb *SQLBuilder) Arg(v any) (sql string) { sb.Params = append(sb.Params, v); return \"?\" }\n+\n+var searchSQL = template.Must(template.New(\"\").Parse(`\n+{{- /*\n+####\n+#### Here come different implementations for the innermost full-text search query.\n+#### A query is expected to return a list of entities with their (OrgID, UID, Kind, Title, ParentFolderUID)\n+####\n+*/ -}}\n+{{- define \"text-search\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }}\n+{{ end }}\n+{{- define \"text-search-mysql-fts\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE MATCH(title) AGAINST({{ .Arg .Text }}) AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE MATCH(title) AGAINST({{ .Arg .Text }})\n+{{ end }}\n+{{- define \"text-search-legacy\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND is_folder\n+{{ end }}\n+\n+SELECT DISTINCT\n+\tentity.org_id, entity.kind, entity.uid, entity.id, entity.title,\n+\tdashboard_tag.term as term, f1.uid as folder_uid, f1.title as folder_title FROM (\n+\t{{- template \"text-search-legacy\" . -}}\n+) AS entity\n+LEFT JOIN folder f1 ON (entity.parent_uid = f1.uid AND entity.org_id = f1.org_id)\n+{{ if ne .UserID 0 }}   {{- /* If a user is not admin: need to filter by permissions */ -}}\n+LEFT JOIN folder f2 ON (f1.parent_uid     = f2.uid AND f1.org_id     = f2.org_id)\n+LEFT JOIN folder f3 ON (f2.parent_uid     = f3.uid AND f2.org_id     = f3.org_id)\n+LEFT JOIN folder f4 ON (f3.parent_uid     = f4.uid AND f3.org_id     = f4.org_id)\n+INNER JOIN permission p ON \n+p.role_id IN (\n+\tSELECT ur.role_id FROM user_role AS ur    WHERE ur.user_id = {{ .Arg .UserID }} AND (ur.org_id = {{ .Arg .OrgID }} OR ur.org_id = 0)\n+\tUNION\n+\tSELECT tr.role_id FROM team_role AS tr    WHERE tr.team_id IN (\n+\t\t{{- range $i, $el := .TeamIDs -}}\n+\t\t{{- if $i -}},{{- end -}}\n+\t\t{{- $.Arg $el -}}\n+\t\t{{- end -}}\n+\t) AND tr.org_id = {{ .Arg .OrgID }}\n+\tUNION\n+\tSELECT br.role_id FROM builtin_role AS br WHERE br.role IN ({{ .Arg .Role }}) AND (br.org_id = {{ .Arg .OrgID }} OR br.org_id = 0)\n+) AND (\n+{{ if .HasSplitScopes }}\n+\t{{- /* This permission check relies on the optimised (indexed) split scope columns in the permission table */ -}}\n+\t(\n+\t\tp.kind = 'dashboards' AND\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.identifier = entity.uid",
        "comment_created_at": "2023-11-29T16:54:57+00:00",
        "comment_author": "kalleep",
        "comment_body": "There is a case missing here, if user has `dashboard:read` on parent folder. \r\n\r\nSo a user can read the dashboard if either has a direct scope `dashboards:read` -> `dashboards:uid:1` or if the user has `dashboards:read` -> `folder:uid:<parent folder>`.\r\n\r\nThat check would have to look something like the case u used for folder kinds bud with dashboard read action instead",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1409605124",
    "pr_number": 78599,
    "pr_file": "pkg/services/dashboards/database/database.go",
    "created_at": "2023-11-29T16:58:41+00:00",
    "commented_code": "sql, params := sb.ToSQL(limit, page)\n \n \terr = d.store.WithDbSession(ctx, func(sess *db.Session) error {\n+\t\tstart := time.Now()\n+\t\tdefer func() {\n+\t\t\td.log.Info(\"Original search query\", \"time\", time.Since(start), \"results\", len(res))\n+\t\t}()\n \t\treturn sess.SQL(sql, params...).Find(&res)\n \t})\n \n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// Only use modified search for non-empty search queries, otherwise it's just listing and new query can't help there yet.\n+\tif query.Title != \"\" && len(query.FolderUIDs) == 0 && len(query.FolderIds) == 0 { //nolint:staticcheck\n+\t\tresults, err := d.findDashboards(ctx, query)\n+\t\tif err != nil {\n+\t\t\td.log.Info(\"new search failed\", \"error\", err)\n+\t\t}\n+\t\treturn results, nil\n+\t}\n \treturn res, nil\n }\n \n+// searchHit represents a single matching row from the search query below.\n+type searchHit struct {\n+\tOrgID       int64  `xorm:\"org_id\"`\n+\tID          int64  `xorm:\"id\"` // this probably should be deprecated but it will break dashboard_tag table for now\n+\tKind        string `xorm:\"kind\"`\n+\tUID         string `xorm:\"uid\"`\n+\tTitle       string `xorm:\"title\"`\n+\tTerm        string `xorm:\"term\"`\n+\tFolderTitle string `xorm:\"folder_title\"`\n+\tFolderUID   string `xorm:\"folder_uid\"`\n+}\n+\n+// searchData is an input data for the search query template below.\n+type searchData struct {\n+\tSQLBuilder\n+\tText    string\n+\tOrgID   int64\n+\tUserID  int64\n+\tTeamIDs []int64\n+\tRole    string\n+\tLimit   int64\n+\n+\tDialect        migrator.Dialect\n+\tHasSplitScopes bool\n+}\n+\n+// SQLBuilder is a more-or-less reusable SQL query builder that is based on\n+// text/template. SQL is not a composable language really, so having all\n+// subqueries/partials/filters in one place helps to better understand the whole\n+// query.\n+// SQLBuilder is expected to be embedded into the data struct passed into the\n+// template. In a template one can use {{.Arg .Foo}} and it will replace that\n+// with a \"?\" placeholder appending the value of .Foo to the Params slice.\n+type SQLBuilder struct {\n+\tParams []any\n+}\n+\n+func (sb *SQLBuilder) Arg(v any) (sql string) { sb.Params = append(sb.Params, v); return \"?\" }\n+\n+var searchSQL = template.Must(template.New(\"\").Parse(`\n+{{- /*\n+####\n+#### Here come different implementations for the innermost full-text search query.\n+#### A query is expected to return a list of entities with their (OrgID, UID, Kind, Title, ParentFolderUID)\n+####\n+*/ -}}\n+{{- define \"text-search\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }}\n+{{ end }}\n+{{- define \"text-search-mysql-fts\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE MATCH(title) AGAINST({{ .Arg .Text }}) AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE MATCH(title) AGAINST({{ .Arg .Text }})\n+{{ end }}\n+{{- define \"text-search-legacy\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND is_folder\n+{{ end }}\n+\n+SELECT DISTINCT\n+\tentity.org_id, entity.kind, entity.uid, entity.id, entity.title,\n+\tdashboard_tag.term as term, f1.uid as folder_uid, f1.title as folder_title FROM (\n+\t{{- template \"text-search-legacy\" . -}}\n+) AS entity\n+LEFT JOIN folder f1 ON (entity.parent_uid = f1.uid AND entity.org_id = f1.org_id)\n+{{ if ne .UserID 0 }}   {{- /* If a user is not admin: need to filter by permissions */ -}}\n+LEFT JOIN folder f2 ON (f1.parent_uid     = f2.uid AND f1.org_id     = f2.org_id)\n+LEFT JOIN folder f3 ON (f2.parent_uid     = f3.uid AND f2.org_id     = f3.org_id)\n+LEFT JOIN folder f4 ON (f3.parent_uid     = f4.uid AND f3.org_id     = f4.org_id)\n+INNER JOIN permission p ON \n+p.role_id IN (\n+\tSELECT ur.role_id FROM user_role AS ur    WHERE ur.user_id = {{ .Arg .UserID }} AND (ur.org_id = {{ .Arg .OrgID }} OR ur.org_id = 0)\n+\tUNION\n+\tSELECT tr.role_id FROM team_role AS tr    WHERE tr.team_id IN (\n+\t\t{{- range $i, $el := .TeamIDs -}}\n+\t\t{{- if $i -}},{{- end -}}\n+\t\t{{- $.Arg $el -}}\n+\t\t{{- end -}}\n+\t) AND tr.org_id = {{ .Arg .OrgID }}\n+\tUNION\n+\tSELECT br.role_id FROM builtin_role AS br WHERE br.role IN ({{ .Arg .Role }}) AND (br.org_id = {{ .Arg .OrgID }} OR br.org_id = 0)\n+) AND (\n+{{ if .HasSplitScopes }}\n+\t{{- /* This permission check relies on the optimised (indexed) split scope columns in the permission table */ -}}\n+\t(\n+\t\tp.kind = 'dashboards' AND\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.identifier = entity.uid\n+\t) OR (\n+\t\tp.kind = 'folders' AND\n+\t\tp.action = 'folders:read' AND\n+\t\tp.identifier IN (f4.uid, f3.uid, f2.uid, f1.uid, entity.uid)\n+\t)\n+{{ else }}\n+\t(\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.scope LIKE 'dashboards:uid:%' AND\n+\t\tsubstr(p.scope, 16) = entity.uid\n+\t) OR (\n+\t\tp.action = 'folders:read' AND\n+\t\tp.scope LIKE 'folders:uid:%' AND\n+\t\tsubstr(p.scope, 13) IN (f4.uid, f3.uid, f2.uid, f1.uid, entity.uid)\n+\t)\n+{{ end }}\n+)\n+{{ end }}\n+LEFT JOIN dashboard_tag ON dashboard_tag.dashboard_id = entity.id\n+ORDER BY entity.title ASC\n+LIMIT {{ .Arg .Limit }}\n+`))\n+\n+func (d *dashboardStore) findDashboards(ctx context.Context, query *dashboards.FindPersistedDashboardsQuery) ([]dashboards.DashboardSearchProjection, error) {\n+\t// Only handle non-empty search queries\n+\tif query.Title == \"\" {\n+\t\treturn nil, nil\n+\t}\n+\n+\t// Get OrgID, Team IDs and UserID (zero for admins)\n+\torgID, userID, teamIDs := query.OrgId, int64(0), []int64{}\n+\tif orgID == 0 {\n+\t\torgID = query.SignedInUser.GetOrgID()\n+\t}\n+\tif !query.SignedInUser.GetIsGrafanaAdmin() {",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1409605124",
        "repo_full_name": "grafana/grafana",
        "pr_number": 78599,
        "pr_file": "pkg/services/dashboards/database/database.go",
        "discussion_id": "1409605124",
        "commented_code": "@@ -994,16 +997,220 @@ func (d *dashboardStore) FindDashboards(ctx context.Context, query *dashboards.F\n \tsql, params := sb.ToSQL(limit, page)\n \n \terr = d.store.WithDbSession(ctx, func(sess *db.Session) error {\n+\t\tstart := time.Now()\n+\t\tdefer func() {\n+\t\t\td.log.Info(\"Original search query\", \"time\", time.Since(start), \"results\", len(res))\n+\t\t}()\n \t\treturn sess.SQL(sql, params...).Find(&res)\n \t})\n \n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// Only use modified search for non-empty search queries, otherwise it's just listing and new query can't help there yet.\n+\tif query.Title != \"\" && len(query.FolderUIDs) == 0 && len(query.FolderIds) == 0 { //nolint:staticcheck\n+\t\tresults, err := d.findDashboards(ctx, query)\n+\t\tif err != nil {\n+\t\t\td.log.Info(\"new search failed\", \"error\", err)\n+\t\t}\n+\t\treturn results, nil\n+\t}\n \treturn res, nil\n }\n \n+// searchHit represents a single matching row from the search query below.\n+type searchHit struct {\n+\tOrgID       int64  `xorm:\"org_id\"`\n+\tID          int64  `xorm:\"id\"` // this probably should be deprecated but it will break dashboard_tag table for now\n+\tKind        string `xorm:\"kind\"`\n+\tUID         string `xorm:\"uid\"`\n+\tTitle       string `xorm:\"title\"`\n+\tTerm        string `xorm:\"term\"`\n+\tFolderTitle string `xorm:\"folder_title\"`\n+\tFolderUID   string `xorm:\"folder_uid\"`\n+}\n+\n+// searchData is an input data for the search query template below.\n+type searchData struct {\n+\tSQLBuilder\n+\tText    string\n+\tOrgID   int64\n+\tUserID  int64\n+\tTeamIDs []int64\n+\tRole    string\n+\tLimit   int64\n+\n+\tDialect        migrator.Dialect\n+\tHasSplitScopes bool\n+}\n+\n+// SQLBuilder is a more-or-less reusable SQL query builder that is based on\n+// text/template. SQL is not a composable language really, so having all\n+// subqueries/partials/filters in one place helps to better understand the whole\n+// query.\n+// SQLBuilder is expected to be embedded into the data struct passed into the\n+// template. In a template one can use {{.Arg .Foo}} and it will replace that\n+// with a \"?\" placeholder appending the value of .Foo to the Params slice.\n+type SQLBuilder struct {\n+\tParams []any\n+}\n+\n+func (sb *SQLBuilder) Arg(v any) (sql string) { sb.Params = append(sb.Params, v); return \"?\" }\n+\n+var searchSQL = template.Must(template.New(\"\").Parse(`\n+{{- /*\n+####\n+#### Here come different implementations for the innermost full-text search query.\n+#### A query is expected to return a list of entities with their (OrgID, UID, Kind, Title, ParentFolderUID)\n+####\n+*/ -}}\n+{{- define \"text-search\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }}\n+{{ end }}\n+{{- define \"text-search-mysql-fts\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE MATCH(title) AGAINST({{ .Arg .Text }}) AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE MATCH(title) AGAINST({{ .Arg .Text }})\n+{{ end }}\n+{{- define \"text-search-legacy\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND is_folder\n+{{ end }}\n+\n+SELECT DISTINCT\n+\tentity.org_id, entity.kind, entity.uid, entity.id, entity.title,\n+\tdashboard_tag.term as term, f1.uid as folder_uid, f1.title as folder_title FROM (\n+\t{{- template \"text-search-legacy\" . -}}\n+) AS entity\n+LEFT JOIN folder f1 ON (entity.parent_uid = f1.uid AND entity.org_id = f1.org_id)\n+{{ if ne .UserID 0 }}   {{- /* If a user is not admin: need to filter by permissions */ -}}\n+LEFT JOIN folder f2 ON (f1.parent_uid     = f2.uid AND f1.org_id     = f2.org_id)\n+LEFT JOIN folder f3 ON (f2.parent_uid     = f3.uid AND f2.org_id     = f3.org_id)\n+LEFT JOIN folder f4 ON (f3.parent_uid     = f4.uid AND f3.org_id     = f4.org_id)\n+INNER JOIN permission p ON \n+p.role_id IN (\n+\tSELECT ur.role_id FROM user_role AS ur    WHERE ur.user_id = {{ .Arg .UserID }} AND (ur.org_id = {{ .Arg .OrgID }} OR ur.org_id = 0)\n+\tUNION\n+\tSELECT tr.role_id FROM team_role AS tr    WHERE tr.team_id IN (\n+\t\t{{- range $i, $el := .TeamIDs -}}\n+\t\t{{- if $i -}},{{- end -}}\n+\t\t{{- $.Arg $el -}}\n+\t\t{{- end -}}\n+\t) AND tr.org_id = {{ .Arg .OrgID }}\n+\tUNION\n+\tSELECT br.role_id FROM builtin_role AS br WHERE br.role IN ({{ .Arg .Role }}) AND (br.org_id = {{ .Arg .OrgID }} OR br.org_id = 0)\n+) AND (\n+{{ if .HasSplitScopes }}\n+\t{{- /* This permission check relies on the optimised (indexed) split scope columns in the permission table */ -}}\n+\t(\n+\t\tp.kind = 'dashboards' AND\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.identifier = entity.uid\n+\t) OR (\n+\t\tp.kind = 'folders' AND\n+\t\tp.action = 'folders:read' AND\n+\t\tp.identifier IN (f4.uid, f3.uid, f2.uid, f1.uid, entity.uid)\n+\t)\n+{{ else }}\n+\t(\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.scope LIKE 'dashboards:uid:%' AND\n+\t\tsubstr(p.scope, 16) = entity.uid\n+\t) OR (\n+\t\tp.action = 'folders:read' AND\n+\t\tp.scope LIKE 'folders:uid:%' AND\n+\t\tsubstr(p.scope, 13) IN (f4.uid, f3.uid, f2.uid, f1.uid, entity.uid)\n+\t)\n+{{ end }}\n+)\n+{{ end }}\n+LEFT JOIN dashboard_tag ON dashboard_tag.dashboard_id = entity.id\n+ORDER BY entity.title ASC\n+LIMIT {{ .Arg .Limit }}\n+`))\n+\n+func (d *dashboardStore) findDashboards(ctx context.Context, query *dashboards.FindPersistedDashboardsQuery) ([]dashboards.DashboardSearchProjection, error) {\n+\t// Only handle non-empty search queries\n+\tif query.Title == \"\" {\n+\t\treturn nil, nil\n+\t}\n+\n+\t// Get OrgID, Team IDs and UserID (zero for admins)\n+\torgID, userID, teamIDs := query.OrgId, int64(0), []int64{}\n+\tif orgID == 0 {\n+\t\torgID = query.SignedInUser.GetOrgID()\n+\t}\n+\tif !query.SignedInUser.GetIsGrafanaAdmin() {",
        "comment_created_at": "2023-11-29T16:58:41+00:00",
        "comment_author": "kalleep",
        "comment_body": "Being a `Grafana Admin` has no guarantees that the user can read all dashboards in enterprise because those things can be modified. What we need to check is something like we do in the other query. \r\n\r\n1. If user have `dashboards:read` with either dashboard or folder wildcard scope we don't need to check for permission for kind dashboard.\r\n2. If user have `folders:read` with  folder wildcard scope we don't need to check for permission for kind folder.\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "1441820907",
        "repo_full_name": "grafana/grafana",
        "pr_number": 78599,
        "pr_file": "pkg/services/dashboards/database/database.go",
        "discussion_id": "1409605124",
        "commented_code": "@@ -994,16 +997,220 @@ func (d *dashboardStore) FindDashboards(ctx context.Context, query *dashboards.F\n \tsql, params := sb.ToSQL(limit, page)\n \n \terr = d.store.WithDbSession(ctx, func(sess *db.Session) error {\n+\t\tstart := time.Now()\n+\t\tdefer func() {\n+\t\t\td.log.Info(\"Original search query\", \"time\", time.Since(start), \"results\", len(res))\n+\t\t}()\n \t\treturn sess.SQL(sql, params...).Find(&res)\n \t})\n \n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n+\t// Only use modified search for non-empty search queries, otherwise it's just listing and new query can't help there yet.\n+\tif query.Title != \"\" && len(query.FolderUIDs) == 0 && len(query.FolderIds) == 0 { //nolint:staticcheck\n+\t\tresults, err := d.findDashboards(ctx, query)\n+\t\tif err != nil {\n+\t\t\td.log.Info(\"new search failed\", \"error\", err)\n+\t\t}\n+\t\treturn results, nil\n+\t}\n \treturn res, nil\n }\n \n+// searchHit represents a single matching row from the search query below.\n+type searchHit struct {\n+\tOrgID       int64  `xorm:\"org_id\"`\n+\tID          int64  `xorm:\"id\"` // this probably should be deprecated but it will break dashboard_tag table for now\n+\tKind        string `xorm:\"kind\"`\n+\tUID         string `xorm:\"uid\"`\n+\tTitle       string `xorm:\"title\"`\n+\tTerm        string `xorm:\"term\"`\n+\tFolderTitle string `xorm:\"folder_title\"`\n+\tFolderUID   string `xorm:\"folder_uid\"`\n+}\n+\n+// searchData is an input data for the search query template below.\n+type searchData struct {\n+\tSQLBuilder\n+\tText    string\n+\tOrgID   int64\n+\tUserID  int64\n+\tTeamIDs []int64\n+\tRole    string\n+\tLimit   int64\n+\n+\tDialect        migrator.Dialect\n+\tHasSplitScopes bool\n+}\n+\n+// SQLBuilder is a more-or-less reusable SQL query builder that is based on\n+// text/template. SQL is not a composable language really, so having all\n+// subqueries/partials/filters in one place helps to better understand the whole\n+// query.\n+// SQLBuilder is expected to be embedded into the data struct passed into the\n+// template. In a template one can use {{.Arg .Foo}} and it will replace that\n+// with a \"?\" placeholder appending the value of .Foo to the Params slice.\n+type SQLBuilder struct {\n+\tParams []any\n+}\n+\n+func (sb *SQLBuilder) Arg(v any) (sql string) { sb.Params = append(sb.Params, v); return \"?\" }\n+\n+var searchSQL = template.Must(template.New(\"\").Parse(`\n+{{- /*\n+####\n+#### Here come different implementations for the innermost full-text search query.\n+#### A query is expected to return a list of entities with their (OrgID, UID, Kind, Title, ParentFolderUID)\n+####\n+*/ -}}\n+{{- define \"text-search\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }}\n+{{ end }}\n+{{- define \"text-search-mysql-fts\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE MATCH(title) AGAINST({{ .Arg .Text }}) AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, 0, parent_uid, title FROM folder WHERE MATCH(title) AGAINST({{ .Arg .Text }})\n+{{ end }}\n+{{- define \"text-search-legacy\" -}}\n+SELECT org_id, 'dashboard' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND NOT is_folder\n+UNION ALL\n+SELECT org_id, 'folder' as kind, uid, id, folder_uid as parent_uid, title FROM dashboard WHERE title {{ .Dialect.LikeStr }} {{ .Arg .Text }} AND is_folder\n+{{ end }}\n+\n+SELECT DISTINCT\n+\tentity.org_id, entity.kind, entity.uid, entity.id, entity.title,\n+\tdashboard_tag.term as term, f1.uid as folder_uid, f1.title as folder_title FROM (\n+\t{{- template \"text-search-legacy\" . -}}\n+) AS entity\n+LEFT JOIN folder f1 ON (entity.parent_uid = f1.uid AND entity.org_id = f1.org_id)\n+{{ if ne .UserID 0 }}   {{- /* If a user is not admin: need to filter by permissions */ -}}\n+LEFT JOIN folder f2 ON (f1.parent_uid     = f2.uid AND f1.org_id     = f2.org_id)\n+LEFT JOIN folder f3 ON (f2.parent_uid     = f3.uid AND f2.org_id     = f3.org_id)\n+LEFT JOIN folder f4 ON (f3.parent_uid     = f4.uid AND f3.org_id     = f4.org_id)\n+INNER JOIN permission p ON \n+p.role_id IN (\n+\tSELECT ur.role_id FROM user_role AS ur    WHERE ur.user_id = {{ .Arg .UserID }} AND (ur.org_id = {{ .Arg .OrgID }} OR ur.org_id = 0)\n+\tUNION\n+\tSELECT tr.role_id FROM team_role AS tr    WHERE tr.team_id IN (\n+\t\t{{- range $i, $el := .TeamIDs -}}\n+\t\t{{- if $i -}},{{- end -}}\n+\t\t{{- $.Arg $el -}}\n+\t\t{{- end -}}\n+\t) AND tr.org_id = {{ .Arg .OrgID }}\n+\tUNION\n+\tSELECT br.role_id FROM builtin_role AS br WHERE br.role IN ({{ .Arg .Role }}) AND (br.org_id = {{ .Arg .OrgID }} OR br.org_id = 0)\n+) AND (\n+{{ if .HasSplitScopes }}\n+\t{{- /* This permission check relies on the optimised (indexed) split scope columns in the permission table */ -}}\n+\t(\n+\t\tp.kind = 'dashboards' AND\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.identifier = entity.uid\n+\t) OR (\n+\t\tp.kind = 'folders' AND\n+\t\tp.action = 'folders:read' AND\n+\t\tp.identifier IN (f4.uid, f3.uid, f2.uid, f1.uid, entity.uid)\n+\t)\n+{{ else }}\n+\t(\n+\t\tp.action = 'dashboards:read' AND\n+\t\tp.scope LIKE 'dashboards:uid:%' AND\n+\t\tsubstr(p.scope, 16) = entity.uid\n+\t) OR (\n+\t\tp.action = 'folders:read' AND\n+\t\tp.scope LIKE 'folders:uid:%' AND\n+\t\tsubstr(p.scope, 13) IN (f4.uid, f3.uid, f2.uid, f1.uid, entity.uid)\n+\t)\n+{{ end }}\n+)\n+{{ end }}\n+LEFT JOIN dashboard_tag ON dashboard_tag.dashboard_id = entity.id\n+ORDER BY entity.title ASC\n+LIMIT {{ .Arg .Limit }}\n+`))\n+\n+func (d *dashboardStore) findDashboards(ctx context.Context, query *dashboards.FindPersistedDashboardsQuery) ([]dashboards.DashboardSearchProjection, error) {\n+\t// Only handle non-empty search queries\n+\tif query.Title == \"\" {\n+\t\treturn nil, nil\n+\t}\n+\n+\t// Get OrgID, Team IDs and UserID (zero for admins)\n+\torgID, userID, teamIDs := query.OrgId, int64(0), []int64{}\n+\tif orgID == 0 {\n+\t\torgID = query.SignedInUser.GetOrgID()\n+\t}\n+\tif !query.SignedInUser.GetIsGrafanaAdmin() {",
        "comment_created_at": "2024-01-04T14:24:50+00:00",
        "comment_author": "zserge",
        "comment_body": "Thanks! Definitely needs to be fixed, I've added it to the epic as a known bug but I would also want to add more integration tests for this query covering scenarios like this one.",
        "pr_file_module": null
      }
    ]
  }
]