[
  {
    "discussion_id": "2184285425",
    "pr_number": 107579,
    "pr_file": "public/app/features/plugins/plugin_loader.ts",
    "created_at": "2025-07-04T04:09:33+00:00",
    "commented_code": "});\n }\n \n-// Only successfully loaded plugins are cached\n-const importedAppPlugins: Record<string, AppPlugin> = {};\n+// Cache for import promises to prevent duplicate imports\n+const importPromises: Record<string, Promise<AppPlugin>> = {};\n \n export async function importAppPlugin(meta: PluginMeta): Promise<AppPlugin> {\n   const pluginId = meta.id;\n \n-  if (importedAppPlugins[pluginId]) {\n-    return importedAppPlugins[pluginId];\n+  // If import is already in progress or completed, return the existing promise\n+  if (importPromises[pluginId] !== undefined) {\n+    return importPromises[pluginId];\n   }\n \n-  throwIfAngular(meta);\n+  importPromises[pluginId] = (async () => {\n+    throwIfAngular(meta);\n \n-  const pluginExports = await importPluginModule({\n-    path: meta.module,\n-    version: meta.info?.version,\n-    pluginId: meta.id,\n-    loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n-    moduleHash: meta.moduleHash,\n-    translations: meta.translations,\n-  });\n+    const pluginExports = await importPluginModule({\n+      path: meta.module,\n+      version: meta.info?.version,\n+      pluginId: meta.id,\n+      loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n+      moduleHash: meta.moduleHash,\n+      translations: meta.translations,\n+    });\n \n-  const { plugin = new AppPlugin() } = pluginExports;\n-  plugin.init(meta);\n-  plugin.meta = meta;\n-  plugin.setComponentsFromLegacyExports(pluginExports);\n+    const { plugin = new AppPlugin() } = pluginExports;\n+    plugin.init(meta);\n+    plugin.meta = meta;\n+    plugin.setComponentsFromLegacyExports(pluginExports);\n \n-  exposedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.exposedComponentConfigs || [],\n-  });\n-  addedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedComponentConfigs || [],\n-  });\n-  addedLinksRegistry.register({\n-    pluginId,\n-    configs: plugin.addedLinkConfigs || [],\n-  });\n-  addedFunctionsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedFunctionConfigs || [],\n-  });\n+    exposedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.exposedComponentConfigs || [],\n+    });\n+    addedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedComponentConfigs || [],\n+    });\n+    addedLinksRegistry.register({\n+      pluginId,\n+      configs: plugin.addedLinkConfigs || [],\n+    });\n+    addedFunctionsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedFunctionConfigs || [],\n+    });\n \n-  importedAppPlugins[pluginId] = plugin;\n+    return plugin;\n+  })();",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2184285425",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107579,
        "pr_file": "public/app/features/plugins/plugin_loader.ts",
        "discussion_id": "2184285425",
        "commented_code": "@@ -187,52 +187,55 @@ export function importDataSourcePlugin(meta: DataSourcePluginMeta): Promise<Gene\n   });\n }\n \n-// Only successfully loaded plugins are cached\n-const importedAppPlugins: Record<string, AppPlugin> = {};\n+// Cache for import promises to prevent duplicate imports\n+const importPromises: Record<string, Promise<AppPlugin>> = {};\n \n export async function importAppPlugin(meta: PluginMeta): Promise<AppPlugin> {\n   const pluginId = meta.id;\n \n-  if (importedAppPlugins[pluginId]) {\n-    return importedAppPlugins[pluginId];\n+  // If import is already in progress or completed, return the existing promise\n+  if (importPromises[pluginId] !== undefined) {\n+    return importPromises[pluginId];\n   }\n \n-  throwIfAngular(meta);\n+  importPromises[pluginId] = (async () => {\n+    throwIfAngular(meta);\n \n-  const pluginExports = await importPluginModule({\n-    path: meta.module,\n-    version: meta.info?.version,\n-    pluginId: meta.id,\n-    loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n-    moduleHash: meta.moduleHash,\n-    translations: meta.translations,\n-  });\n+    const pluginExports = await importPluginModule({\n+      path: meta.module,\n+      version: meta.info?.version,\n+      pluginId: meta.id,\n+      loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n+      moduleHash: meta.moduleHash,\n+      translations: meta.translations,\n+    });\n \n-  const { plugin = new AppPlugin() } = pluginExports;\n-  plugin.init(meta);\n-  plugin.meta = meta;\n-  plugin.setComponentsFromLegacyExports(pluginExports);\n+    const { plugin = new AppPlugin() } = pluginExports;\n+    plugin.init(meta);\n+    plugin.meta = meta;\n+    plugin.setComponentsFromLegacyExports(pluginExports);\n \n-  exposedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.exposedComponentConfigs || [],\n-  });\n-  addedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedComponentConfigs || [],\n-  });\n-  addedLinksRegistry.register({\n-    pluginId,\n-    configs: plugin.addedLinkConfigs || [],\n-  });\n-  addedFunctionsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedFunctionConfigs || [],\n-  });\n+    exposedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.exposedComponentConfigs || [],\n+    });\n+    addedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedComponentConfigs || [],\n+    });\n+    addedLinksRegistry.register({\n+      pluginId,\n+      configs: plugin.addedLinkConfigs || [],\n+    });\n+    addedFunctionsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedFunctionConfigs || [],\n+    });\n \n-  importedAppPlugins[pluginId] = plugin;\n+    return plugin;\n+  })();",
        "comment_created_at": "2025-07-04T04:09:33+00:00",
        "comment_author": "hugohaggmark",
        "comment_body": "[nitpick]: I understand this is a temporary fix until we start work on https://github.com/grafana/grafana/issues/97106 but maybe we should break out this part into a separate async function and call that instead of using a self executing function?",
        "pr_file_module": null
      },
      {
        "comment_id": "2184314266",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107579,
        "pr_file": "public/app/features/plugins/plugin_loader.ts",
        "discussion_id": "2184285425",
        "commented_code": "@@ -187,52 +187,55 @@ export function importDataSourcePlugin(meta: DataSourcePluginMeta): Promise<Gene\n   });\n }\n \n-// Only successfully loaded plugins are cached\n-const importedAppPlugins: Record<string, AppPlugin> = {};\n+// Cache for import promises to prevent duplicate imports\n+const importPromises: Record<string, Promise<AppPlugin>> = {};\n \n export async function importAppPlugin(meta: PluginMeta): Promise<AppPlugin> {\n   const pluginId = meta.id;\n \n-  if (importedAppPlugins[pluginId]) {\n-    return importedAppPlugins[pluginId];\n+  // If import is already in progress or completed, return the existing promise\n+  if (importPromises[pluginId] !== undefined) {\n+    return importPromises[pluginId];\n   }\n \n-  throwIfAngular(meta);\n+  importPromises[pluginId] = (async () => {\n+    throwIfAngular(meta);\n \n-  const pluginExports = await importPluginModule({\n-    path: meta.module,\n-    version: meta.info?.version,\n-    pluginId: meta.id,\n-    loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n-    moduleHash: meta.moduleHash,\n-    translations: meta.translations,\n-  });\n+    const pluginExports = await importPluginModule({\n+      path: meta.module,\n+      version: meta.info?.version,\n+      pluginId: meta.id,\n+      loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n+      moduleHash: meta.moduleHash,\n+      translations: meta.translations,\n+    });\n \n-  const { plugin = new AppPlugin() } = pluginExports;\n-  plugin.init(meta);\n-  plugin.meta = meta;\n-  plugin.setComponentsFromLegacyExports(pluginExports);\n+    const { plugin = new AppPlugin() } = pluginExports;\n+    plugin.init(meta);\n+    plugin.meta = meta;\n+    plugin.setComponentsFromLegacyExports(pluginExports);\n \n-  exposedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.exposedComponentConfigs || [],\n-  });\n-  addedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedComponentConfigs || [],\n-  });\n-  addedLinksRegistry.register({\n-    pluginId,\n-    configs: plugin.addedLinkConfigs || [],\n-  });\n-  addedFunctionsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedFunctionConfigs || [],\n-  });\n+    exposedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.exposedComponentConfigs || [],\n+    });\n+    addedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedComponentConfigs || [],\n+    });\n+    addedLinksRegistry.register({\n+      pluginId,\n+      configs: plugin.addedLinkConfigs || [],\n+    });\n+    addedFunctionsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedFunctionConfigs || [],\n+    });\n \n-  importedAppPlugins[pluginId] = plugin;\n+    return plugin;\n+  })();",
        "comment_created_at": "2025-07-04T04:27:40+00:00",
        "comment_author": "leventebalogh",
        "comment_body": "Yeah, that's a good point @hugohaggmark, will extract it out \ud83d\udc4d ",
        "pr_file_module": null
      },
      {
        "comment_id": "2184559379",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107579,
        "pr_file": "public/app/features/plugins/plugin_loader.ts",
        "discussion_id": "2184285425",
        "commented_code": "@@ -187,52 +187,55 @@ export function importDataSourcePlugin(meta: DataSourcePluginMeta): Promise<Gene\n   });\n }\n \n-// Only successfully loaded plugins are cached\n-const importedAppPlugins: Record<string, AppPlugin> = {};\n+// Cache for import promises to prevent duplicate imports\n+const importPromises: Record<string, Promise<AppPlugin>> = {};\n \n export async function importAppPlugin(meta: PluginMeta): Promise<AppPlugin> {\n   const pluginId = meta.id;\n \n-  if (importedAppPlugins[pluginId]) {\n-    return importedAppPlugins[pluginId];\n+  // If import is already in progress or completed, return the existing promise\n+  if (importPromises[pluginId] !== undefined) {\n+    return importPromises[pluginId];\n   }\n \n-  throwIfAngular(meta);\n+  importPromises[pluginId] = (async () => {\n+    throwIfAngular(meta);\n \n-  const pluginExports = await importPluginModule({\n-    path: meta.module,\n-    version: meta.info?.version,\n-    pluginId: meta.id,\n-    loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n-    moduleHash: meta.moduleHash,\n-    translations: meta.translations,\n-  });\n+    const pluginExports = await importPluginModule({\n+      path: meta.module,\n+      version: meta.info?.version,\n+      pluginId: meta.id,\n+      loadingStrategy: meta.loadingStrategy ?? PluginLoadingStrategy.fetch,\n+      moduleHash: meta.moduleHash,\n+      translations: meta.translations,\n+    });\n \n-  const { plugin = new AppPlugin() } = pluginExports;\n-  plugin.init(meta);\n-  plugin.meta = meta;\n-  plugin.setComponentsFromLegacyExports(pluginExports);\n+    const { plugin = new AppPlugin() } = pluginExports;\n+    plugin.init(meta);\n+    plugin.meta = meta;\n+    plugin.setComponentsFromLegacyExports(pluginExports);\n \n-  exposedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.exposedComponentConfigs || [],\n-  });\n-  addedComponentsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedComponentConfigs || [],\n-  });\n-  addedLinksRegistry.register({\n-    pluginId,\n-    configs: plugin.addedLinkConfigs || [],\n-  });\n-  addedFunctionsRegistry.register({\n-    pluginId,\n-    configs: plugin.addedFunctionConfigs || [],\n-  });\n+    exposedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.exposedComponentConfigs || [],\n+    });\n+    addedComponentsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedComponentConfigs || [],\n+    });\n+    addedLinksRegistry.register({\n+      pluginId,\n+      configs: plugin.addedLinkConfigs || [],\n+    });\n+    addedFunctionsRegistry.register({\n+      pluginId,\n+      configs: plugin.addedFunctionConfigs || [],\n+    });\n \n-  importedAppPlugins[pluginId] = plugin;\n+    return plugin;\n+  })();",
        "comment_created_at": "2025-07-04T06:52:13+00:00",
        "comment_author": "leventebalogh",
        "comment_body": "Fixed in https://github.com/grafana/grafana/pull/107579/commits/063e31ac2a103686626b6130bb8df36960d32c0c. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2183219926",
    "pr_number": 107338,
    "pr_file": "packages/grafana-ui/src/components/Table/TableNG/utils.ts",
    "created_at": "2025-07-03T16:31:06+00:00",
    "commented_code": "return TABLE.CELL_PADDING * 2 + bodyFontSize * lineHeight;\n }\n \n+/**\n+ * @internal\n+ * Returns true if cell inspection (hover to see full content) is enabled for the field.\n+ */\n+export function isCellInspectEnabled(field: Field): boolean {\n+  return field.config?.custom?.inspect ?? false;\n+}\n+\n+/**\n+ * @internal\n+ * Returns true if text wrapping should be applied to the cell.\n+ */\n+export function shouldTextWrap(field: Field): boolean {\n+  const cellOptions = getCellOptions(field);\n+  return ('wrapText' in cellOptions && cellOptions.wrapText) ?? false;\n+}\n+\n+// matches characters which CSS\n+const spaceRegex = /[\\s-]/;\n+\n+export interface GetMaxWrapCellOptions {\n+  colWidths: number[];\n+  avgCharWidth: number;\n+  wrappedColIdxs: boolean[];\n+}\n+\n+/**\n+ * @internal\n+ * loop through the fields and their values, determine which cell is going to determine the\n+ * height of the row based on its content and width, and then return the text, index, and number of lines for that cell.\n+ */\n+export function getMaxWrapCell(\n+  fields: Field[],\n+  rowIdx: number,\n+  { colWidths, avgCharWidth, wrappedColIdxs }: GetMaxWrapCellOptions\n+): {\n+  text: string;\n+  idx: number;\n+  numLines: number;\n+} {\n+  let maxLines = 1;\n+  let maxLinesIdx = -1;\n+  let maxLinesText = '';\n+\n+  for (let i = 0; i < colWidths.length; i++) {\n+    if (wrappedColIdxs[i]) {\n+      const field = fields[i];\n+      // special case: for the header, provide `-1` as the row index.\n+      const cellTextRaw = rowIdx === -1 ? getDisplayName(field) : field.values[rowIdx];\n+\n+      if (cellTextRaw != null) {\n+        const cellText = String(cellTextRaw);\n+\n+        if (spaceRegex.test(cellText)) {\n+          const charsPerLine = colWidths[i] / avgCharWidth;\n+          const approxLines = cellText.length / charsPerLine;\n+\n+          if (approxLines > maxLines) {\n+            maxLines = approxLines;\n+            maxLinesIdx = i;\n+            maxLinesText = cellText;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  return { text: maxLinesText, idx: maxLinesIdx, numLines: maxLines };\n+}\n+\n /**\n  * @internal\n  * Returns true if text overflow handling should be applied to the cell.\n  */\n-export function shouldTextOverflow(\n-  fieldType: FieldType,\n-  cellType: TableCellDisplayMode,\n-  textWrap: boolean,\n-  cellInspect: boolean\n-): boolean {\n-  // Tech debt: Technically image cells are of type string, which is misleading (kinda?)\n-  // so we need to ensure we don't apply overflow hover states fo type image\n-  return fieldType === FieldType.string && cellType !== TableCellDisplayMode.Image && !textWrap && !cellInspect;\n+export function shouldTextOverflow(field: Field): boolean {",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2183219926",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107338,
        "pr_file": "packages/grafana-ui/src/components/Table/TableNG/utils.ts",
        "discussion_id": "2183219926",
        "commented_code": "@@ -69,19 +48,89 @@ export function getDefaultRowHeight(theme: GrafanaTheme2, cellHeight?: TableCell\n   return TABLE.CELL_PADDING * 2 + bodyFontSize * lineHeight;\n }\n \n+/**\n+ * @internal\n+ * Returns true if cell inspection (hover to see full content) is enabled for the field.\n+ */\n+export function isCellInspectEnabled(field: Field): boolean {\n+  return field.config?.custom?.inspect ?? false;\n+}\n+\n+/**\n+ * @internal\n+ * Returns true if text wrapping should be applied to the cell.\n+ */\n+export function shouldTextWrap(field: Field): boolean {\n+  const cellOptions = getCellOptions(field);\n+  return ('wrapText' in cellOptions && cellOptions.wrapText) ?? false;\n+}\n+\n+// matches characters which CSS\n+const spaceRegex = /[\\s-]/;\n+\n+export interface GetMaxWrapCellOptions {\n+  colWidths: number[];\n+  avgCharWidth: number;\n+  wrappedColIdxs: boolean[];\n+}\n+\n+/**\n+ * @internal\n+ * loop through the fields and their values, determine which cell is going to determine the\n+ * height of the row based on its content and width, and then return the text, index, and number of lines for that cell.\n+ */\n+export function getMaxWrapCell(\n+  fields: Field[],\n+  rowIdx: number,\n+  { colWidths, avgCharWidth, wrappedColIdxs }: GetMaxWrapCellOptions\n+): {\n+  text: string;\n+  idx: number;\n+  numLines: number;\n+} {\n+  let maxLines = 1;\n+  let maxLinesIdx = -1;\n+  let maxLinesText = '';\n+\n+  for (let i = 0; i < colWidths.length; i++) {\n+    if (wrappedColIdxs[i]) {\n+      const field = fields[i];\n+      // special case: for the header, provide `-1` as the row index.\n+      const cellTextRaw = rowIdx === -1 ? getDisplayName(field) : field.values[rowIdx];\n+\n+      if (cellTextRaw != null) {\n+        const cellText = String(cellTextRaw);\n+\n+        if (spaceRegex.test(cellText)) {\n+          const charsPerLine = colWidths[i] / avgCharWidth;\n+          const approxLines = cellText.length / charsPerLine;\n+\n+          if (approxLines > maxLines) {\n+            maxLines = approxLines;\n+            maxLinesIdx = i;\n+            maxLinesText = cellText;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  return { text: maxLinesText, idx: maxLinesIdx, numLines: maxLines };\n+}\n+\n /**\n  * @internal\n  * Returns true if text overflow handling should be applied to the cell.\n  */\n-export function shouldTextOverflow(\n-  fieldType: FieldType,\n-  cellType: TableCellDisplayMode,\n-  textWrap: boolean,\n-  cellInspect: boolean\n-): boolean {\n-  // Tech debt: Technically image cells are of type string, which is misleading (kinda?)\n-  // so we need to ensure we don't apply overflow hover states fo type image\n-  return fieldType === FieldType.string && cellType !== TableCellDisplayMode.Image && !textWrap && !cellInspect;\n+export function shouldTextOverflow(field: Field): boolean {",
        "comment_created_at": "2025-07-03T16:31:06+00:00",
        "comment_author": "fastfrwrd",
        "comment_body": "this is a preference thing for utils generally, but since methods like `shouldTextWrap` or `isCellInspectEnabled` do inexpensive lookups on the field, I prefer utils which pass the whole field in rather than the outputs of those checks so that the method is more composable in any context without additional legwork. I find this to be more reusable and less prone to mistakes in the long run.",
        "pr_file_module": null
      },
      {
        "comment_id": "2183223337",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107338,
        "pr_file": "packages/grafana-ui/src/components/Table/TableNG/utils.ts",
        "discussion_id": "2183219926",
        "commented_code": "@@ -69,19 +48,89 @@ export function getDefaultRowHeight(theme: GrafanaTheme2, cellHeight?: TableCell\n   return TABLE.CELL_PADDING * 2 + bodyFontSize * lineHeight;\n }\n \n+/**\n+ * @internal\n+ * Returns true if cell inspection (hover to see full content) is enabled for the field.\n+ */\n+export function isCellInspectEnabled(field: Field): boolean {\n+  return field.config?.custom?.inspect ?? false;\n+}\n+\n+/**\n+ * @internal\n+ * Returns true if text wrapping should be applied to the cell.\n+ */\n+export function shouldTextWrap(field: Field): boolean {\n+  const cellOptions = getCellOptions(field);\n+  return ('wrapText' in cellOptions && cellOptions.wrapText) ?? false;\n+}\n+\n+// matches characters which CSS\n+const spaceRegex = /[\\s-]/;\n+\n+export interface GetMaxWrapCellOptions {\n+  colWidths: number[];\n+  avgCharWidth: number;\n+  wrappedColIdxs: boolean[];\n+}\n+\n+/**\n+ * @internal\n+ * loop through the fields and their values, determine which cell is going to determine the\n+ * height of the row based on its content and width, and then return the text, index, and number of lines for that cell.\n+ */\n+export function getMaxWrapCell(\n+  fields: Field[],\n+  rowIdx: number,\n+  { colWidths, avgCharWidth, wrappedColIdxs }: GetMaxWrapCellOptions\n+): {\n+  text: string;\n+  idx: number;\n+  numLines: number;\n+} {\n+  let maxLines = 1;\n+  let maxLinesIdx = -1;\n+  let maxLinesText = '';\n+\n+  for (let i = 0; i < colWidths.length; i++) {\n+    if (wrappedColIdxs[i]) {\n+      const field = fields[i];\n+      // special case: for the header, provide `-1` as the row index.\n+      const cellTextRaw = rowIdx === -1 ? getDisplayName(field) : field.values[rowIdx];\n+\n+      if (cellTextRaw != null) {\n+        const cellText = String(cellTextRaw);\n+\n+        if (spaceRegex.test(cellText)) {\n+          const charsPerLine = colWidths[i] / avgCharWidth;\n+          const approxLines = cellText.length / charsPerLine;\n+\n+          if (approxLines > maxLines) {\n+            maxLines = approxLines;\n+            maxLinesIdx = i;\n+            maxLinesText = cellText;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  return { text: maxLinesText, idx: maxLinesIdx, numLines: maxLines };\n+}\n+\n /**\n  * @internal\n  * Returns true if text overflow handling should be applied to the cell.\n  */\n-export function shouldTextOverflow(\n-  fieldType: FieldType,\n-  cellType: TableCellDisplayMode,\n-  textWrap: boolean,\n-  cellInspect: boolean\n-): boolean {\n-  // Tech debt: Technically image cells are of type string, which is misleading (kinda?)\n-  // so we need to ensure we don't apply overflow hover states fo type image\n-  return fieldType === FieldType.string && cellType !== TableCellDisplayMode.Image && !textWrap && !cellInspect;\n+export function shouldTextOverflow(field: Field): boolean {",
        "comment_created_at": "2025-07-03T16:32:50+00:00",
        "comment_author": "fastfrwrd",
        "comment_body": "another way to do it if the checks do become expensive might be\r\n\r\n```ts\r\nexport function shouldTextOverflow(\r\n  field: Field,\r\n  textWrap = shouldTextWrap(field),\r\n  // etc...\r\n) {\r\n  // ...\r\n}\r\n```\r\n\r\nso that the user can provide a pre-calculated value optionally to avoid re-calculating, but it's not strictly necessary and the call can just be `shouldTextOverflow(field)` in a normal use case.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2179536695",
    "pr_number": 103064,
    "pr_file": "public/app/features/plugins/admin/state/actions.ts",
    "created_at": "2025-07-02T09:08:36+00:00",
    "commented_code": "try {\n     await installPlugin(id, version);\n-    await updatePanels();\n+    await getBackendSrv()\n+      .get('/api/frontend/settings')\n+      .then((settings: Settings) => {\n+        config.panels = settings.panels;\n+      });",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2179536695",
        "repo_full_name": "grafana/grafana",
        "pr_number": 103064,
        "pr_file": "public/app/features/plugins/admin/state/actions.ts",
        "discussion_id": "2179536695",
        "commented_code": "@@ -202,7 +203,11 @@ export const install = createAsyncThunk<\n \n   try {\n     await installPlugin(id, version);\n-    await updatePanels();\n+    await getBackendSrv()\n+      .get('/api/frontend/settings')\n+      .then((settings: Settings) => {\n+        config.panels = settings.panels;\n+      });",
        "comment_created_at": "2025-07-02T09:08:36+00:00",
        "comment_author": "hugohaggmark",
        "comment_body": "[nitpick]: could this duplication just be a function within this file?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2157226661",
    "pr_number": 106994,
    "pr_file": "public/app/features/search/service/utils.ts",
    "created_at": "2025-06-19T14:56:48+00:00",
    "commented_code": "return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ */\n+export function filterSearchResults(",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2157226661",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106994,
        "pr_file": "public/app/features/search/service/utils.ts",
        "discussion_id": "2157226661",
        "commented_code": "@@ -161,3 +161,47 @@ export function searchHitsToDashboardSearchHits(searchHits: SearchHit[]): Dashbo\n     return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ */\n+export function filterSearchResults(",
        "comment_created_at": "2025-06-19T14:56:48+00:00",
        "comment_author": "leeoniya",
        "comment_body": "@Clarity-89 you might consider re-using our existing searcher: https://github.com/grafana/grafana/blob/main/packages/grafana-ui/src/components/Combobox/filter.ts\r\n\r\nto also search tags, you can construct each haystack string like `${hit.title},${hit.tags.join()}`",
        "pr_file_module": null
      },
      {
        "comment_id": "2157232086",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106994,
        "pr_file": "public/app/features/search/service/utils.ts",
        "discussion_id": "2157226661",
        "commented_code": "@@ -161,3 +161,47 @@ export function searchHitsToDashboardSearchHits(searchHits: SearchHit[]): Dashbo\n     return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ */\n+export function filterSearchResults(",
        "comment_created_at": "2025-06-19T15:00:05+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "Nice \ud83c\udf89  I'll check it out. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2157237034",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106994,
        "pr_file": "public/app/features/search/service/utils.ts",
        "discussion_id": "2157226661",
        "commented_code": "@@ -161,3 +161,47 @@ export function searchHitsToDashboardSearchHits(searchHits: SearchHit[]): Dashbo\n     return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ */\n+export function filterSearchResults(",
        "comment_created_at": "2025-06-19T15:03:10+00:00",
        "comment_author": "leeoniya",
        "comment_body": "you may need to lightly refactor/extract the core util fn to accept just haystack and needle and have a wrapper fn use the matched indices to return the match array of original options.\r\n\r\nhttps://github.com/grafana/grafana/blob/db2301d58df6c6f80ccde8db70dfad2cf7c5466e/packages/grafana-ui/src/components/Combobox/filter.ts#L44",
        "pr_file_module": null
      },
      {
        "comment_id": "2163594811",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106994,
        "pr_file": "public/app/features/search/service/utils.ts",
        "discussion_id": "2157226661",
        "commented_code": "@@ -161,3 +161,47 @@ export function searchHitsToDashboardSearchHits(searchHits: SearchHit[]): Dashbo\n     return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ */\n+export function filterSearchResults(",
        "comment_created_at": "2025-06-24T10:42:00+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "@leeoniya this seems to work pretty well here! I've moved the core functionality to grafana/data for easier reuse: https://github.com/grafana/grafana/pull/107110",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2166428190",
    "pr_number": 107089,
    "pr_file": "public/app/features/browse-dashboards/hooks/useProvisionedFolderFormData.ts",
    "created_at": "2025-06-25T10:55:41+00:00",
    "commented_code": "+import { useMemo } from 'react';\n+\n+import { Folder } from 'app/api/clients/folder/v1beta1';\n+import { RepositoryView } from 'app/api/clients/provisioning/v0alpha1';\n+import { AnnoKeySourcePath } from 'app/features/apiserver/types';\n+import { getDefaultWorkflow, getWorkflowOptions } from 'app/features/dashboard-scene/saving/provisioned/defaults';\n+import { useGetResourceRepositoryView } from 'app/features/provisioning/hooks/useGetResourceRepositoryView';\n+\n+import { BaseProvisionedFormData } from '../../dashboard-scene/saving/shared';\n+\n+export interface UseProvisionedFolderFormDataProps {\n+  folderUid?: string;\n+  action: 'create' | 'delete';\n+  title?: string;\n+}\n+\n+export interface ProvisionedFolderFormDataResult {\n+  repository?: RepositoryView;\n+  folder?: Folder;\n+  workflowOptions: Array<{ label: string; value: string }>;\n+  isGitHub: boolean;\n+  initialValues?: BaseProvisionedFormData;\n+}\n+\n+/**\n+ * Hook for managing provisioned folder create/delete form data.",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2166428190",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107089,
        "pr_file": "public/app/features/browse-dashboards/hooks/useProvisionedFolderFormData.ts",
        "discussion_id": "2166428190",
        "commented_code": "@@ -0,0 +1,61 @@\n+import { useMemo } from 'react';\n+\n+import { Folder } from 'app/api/clients/folder/v1beta1';\n+import { RepositoryView } from 'app/api/clients/provisioning/v0alpha1';\n+import { AnnoKeySourcePath } from 'app/features/apiserver/types';\n+import { getDefaultWorkflow, getWorkflowOptions } from 'app/features/dashboard-scene/saving/provisioned/defaults';\n+import { useGetResourceRepositoryView } from 'app/features/provisioning/hooks/useGetResourceRepositoryView';\n+\n+import { BaseProvisionedFormData } from '../../dashboard-scene/saving/shared';\n+\n+export interface UseProvisionedFolderFormDataProps {\n+  folderUid?: string;\n+  action: 'create' | 'delete';\n+  title?: string;\n+}\n+\n+export interface ProvisionedFolderFormDataResult {\n+  repository?: RepositoryView;\n+  folder?: Folder;\n+  workflowOptions: Array<{ label: string; value: string }>;\n+  isGitHub: boolean;\n+  initialValues?: BaseProvisionedFormData;\n+}\n+\n+/**\n+ * Hook for managing provisioned folder create/delete form data.",
        "comment_created_at": "2025-06-25T10:55:41+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "Ideally we'd use the same hook (with some configuration) for all resources, but not sure it's feasible. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2166824140",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107089,
        "pr_file": "public/app/features/browse-dashboards/hooks/useProvisionedFolderFormData.ts",
        "discussion_id": "2166428190",
        "commented_code": "@@ -0,0 +1,61 @@\n+import { useMemo } from 'react';\n+\n+import { Folder } from 'app/api/clients/folder/v1beta1';\n+import { RepositoryView } from 'app/api/clients/provisioning/v0alpha1';\n+import { AnnoKeySourcePath } from 'app/features/apiserver/types';\n+import { getDefaultWorkflow, getWorkflowOptions } from 'app/features/dashboard-scene/saving/provisioned/defaults';\n+import { useGetResourceRepositoryView } from 'app/features/provisioning/hooks/useGetResourceRepositoryView';\n+\n+import { BaseProvisionedFormData } from '../../dashboard-scene/saving/shared';\n+\n+export interface UseProvisionedFolderFormDataProps {\n+  folderUid?: string;\n+  action: 'create' | 'delete';\n+  title?: string;\n+}\n+\n+export interface ProvisionedFolderFormDataResult {\n+  repository?: RepositoryView;\n+  folder?: Folder;\n+  workflowOptions: Array<{ label: string; value: string }>;\n+  isGitHub: boolean;\n+  initialValues?: BaseProvisionedFormData;\n+}\n+\n+/**\n+ * Hook for managing provisioned folder create/delete form data.",
        "comment_created_at": "2025-06-25T14:11:03+00:00",
        "comment_author": "ywzheng1",
        "comment_body": "I initially considered a shared hook as well, but combining folder and dashboard handling would likely introduce a number of conditional branches (if/switch logic), kinda hurts readability. Keeping them as separate, purpose-specific hooks feels cleaner and easier to reason about, at least for now?",
        "pr_file_module": null
      }
    ]
  }
]