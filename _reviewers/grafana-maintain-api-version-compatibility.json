[
  {
    "discussion_id": "2156782974",
    "pr_number": 105918,
    "pr_file": "public/app/features/dashboard-scene/pages/DashboardScenePageStateManager.ts",
    "created_at": "2025-06-19T11:34:28+00:00",
    "commented_code": "transformResponseToScene(rsp: DashboardDTO | null, options: LoadDashboardOptions): DashboardScene | null {\n     const fromCache = this.getSceneFromCache(options.uid);\n \n-    if (fromCache && fromCache.state.version === rsp?.dashboard.version) {\n+    if (fromCache && fromCache.state.meta.updated === rsp?.meta.updated) {",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2156782974",
        "repo_full_name": "grafana/grafana",
        "pr_number": 105918,
        "pr_file": "public/app/features/dashboard-scene/pages/DashboardScenePageStateManager.ts",
        "discussion_id": "2156782974",
        "commented_code": "@@ -376,7 +376,7 @@ export class DashboardScenePageStateManager extends DashboardScenePageStateManag\n   transformResponseToScene(rsp: DashboardDTO | null, options: LoadDashboardOptions): DashboardScene | null {\n     const fromCache = this.getSceneFromCache(options.uid);\n \n-    if (fromCache && fromCache.state.version === rsp?.dashboard.version) {\n+    if (fromCache && fromCache.state.meta.updated === rsp?.meta.updated) {",
        "comment_created_at": "2025-06-19T11:34:28+00:00",
        "comment_author": "torkelo",
        "comment_body": "I am not seeing this updated field being set (it's undefined), at least when new k8s v1 API is used ",
        "pr_file_module": null
      },
      {
        "comment_id": "2157320556",
        "repo_full_name": "grafana/grafana",
        "pr_number": 105918,
        "pr_file": "public/app/features/dashboard-scene/pages/DashboardScenePageStateManager.ts",
        "discussion_id": "2156782974",
        "commented_code": "@@ -376,7 +376,7 @@ export class DashboardScenePageStateManager extends DashboardScenePageStateManag\n   transformResponseToScene(rsp: DashboardDTO | null, options: LoadDashboardOptions): DashboardScene | null {\n     const fromCache = this.getSceneFromCache(options.uid);\n \n-    if (fromCache && fromCache.state.version === rsp?.dashboard.version) {\n+    if (fromCache && fromCache.state.meta.updated === rsp?.meta.updated) {",
        "comment_created_at": "2025-06-19T15:57:10+00:00",
        "comment_author": "axelavargas",
        "comment_body": "Good catch! for k8s v1 we called it differently and we are not passing it when we get the dashboard. https://github.com/grafana/grafana/blob/main/public/app/features/dashboard/api/v1.ts#L130\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2157596711",
        "repo_full_name": "grafana/grafana",
        "pr_number": 105918,
        "pr_file": "public/app/features/dashboard-scene/pages/DashboardScenePageStateManager.ts",
        "discussion_id": "2156782974",
        "commented_code": "@@ -376,7 +376,7 @@ export class DashboardScenePageStateManager extends DashboardScenePageStateManag\n   transformResponseToScene(rsp: DashboardDTO | null, options: LoadDashboardOptions): DashboardScene | null {\n     const fromCache = this.getSceneFromCache(options.uid);\n \n-    if (fromCache && fromCache.state.version === rsp?.dashboard.version) {\n+    if (fromCache && fromCache.state.meta.updated === rsp?.meta.updated) {",
        "comment_created_at": "2025-06-19T20:03:42+00:00",
        "comment_author": "yashschandra",
        "comment_body": "@torkelo @axelavargas I have added a field `created` in k8s api (https://github.com/grafana/grafana/pull/105918/files#diff-cadf9776aaf5637547a6630fe406e9fdbbdfc20beb72cae3beeb7e6dd95b2f5cR127) and changed the check for cache usage while loading scene. (however I am having trouble testing it locally for k8s api) ",
        "pr_file_module": null
      },
      {
        "comment_id": "2158402049",
        "repo_full_name": "grafana/grafana",
        "pr_number": 105918,
        "pr_file": "public/app/features/dashboard-scene/pages/DashboardScenePageStateManager.ts",
        "discussion_id": "2156782974",
        "commented_code": "@@ -376,7 +376,7 @@ export class DashboardScenePageStateManager extends DashboardScenePageStateManag\n   transformResponseToScene(rsp: DashboardDTO | null, options: LoadDashboardOptions): DashboardScene | null {\n     const fromCache = this.getSceneFromCache(options.uid);\n \n-    if (fromCache && fromCache.state.version === rsp?.dashboard.version) {\n+    if (fromCache && fromCache.state.meta.updated === rsp?.meta.updated) {",
        "comment_created_at": "2025-06-20T08:57:43+00:00",
        "comment_author": "axelavargas",
        "comment_body": "@yashschandra, oops, we should have given more info on those k8s API versions 😅 .  To test locally, you'll need to turn on the `kubernetesDashboards` feature toggle in your `custom.ini` or `grafana.ini` ([doc](https://grafana.com/docs/grafana/latest/setup-grafana/configure-grafana/))  \r\n\r\nSomething like:\r\n```\r\n[feature_toggles]\r\n# there are currently two ways to enable feature toggles in the `grafana.ini`.\r\n# you can either pass an array of feature you want to enable to the `enable` field or\r\n# configure each toggle by setting the name of the toggle to true/false. Toggles set to true/false\r\n# will take presidence over toggles in the `enable` list.\r\n\r\nkubernetesDashboards = true\r\n\r\n\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2159770130",
        "repo_full_name": "grafana/grafana",
        "pr_number": 105918,
        "pr_file": "public/app/features/dashboard-scene/pages/DashboardScenePageStateManager.ts",
        "discussion_id": "2156782974",
        "commented_code": "@@ -376,7 +376,7 @@ export class DashboardScenePageStateManager extends DashboardScenePageStateManag\n   transformResponseToScene(rsp: DashboardDTO | null, options: LoadDashboardOptions): DashboardScene | null {\n     const fromCache = this.getSceneFromCache(options.uid);\n \n-    if (fromCache && fromCache.state.version === rsp?.dashboard.version) {\n+    if (fromCache && fromCache.state.meta.updated === rsp?.meta.updated) {",
        "comment_created_at": "2025-06-20T23:52:33+00:00",
        "comment_author": "yashschandra",
        "comment_body": "Thanks @axelavargas for sharing the steps for testing. I tested the code for classic, v1 and v2 dashboard schemas and found that the code changes are working fine for classic and v1 schemas and that v2 schema does not require any code changes at all (since it is always creating a new _uid_ for each imported json whether we pass _uid_ or not). Let me know if I have made a mistake in my understanding.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2168132826",
    "pr_number": 107208,
    "pr_file": "packages/grafana-prometheus/src/datasource.ts",
    "created_at": "2025-06-26T05:19:36+00:00",
    "commented_code": ") {\n     super(instanceSettings);\n \n-    this.type = 'prometheus';\n-    this.id = instanceSettings.id;\n-    this.url = instanceSettings.url!;\n+    // DATASOURCE CONFIGURATION PROPERTIES\n     this.access = instanceSettings.access;\n     this.basicAuth = instanceSettings.basicAuth;\n-    this.withCredentials = Boolean(instanceSettings.withCredentials);\n-    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n-    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n-    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n-    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n-    this.ruleMappings = {};\n-    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n+    this.cache = new QueryCache({\n+      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n+      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n+      applyInterpolation: this.interpolateString.bind(this),\n+    });\n+    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n     this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n     this.datasourceConfigurationPrometheusFlavor = instanceSettings.jsonData.prometheusType;\n     this.datasourceConfigurationPrometheusVersion = instanceSettings.jsonData.prometheusVersion;\n-    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n-    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n-    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n     this.disableRecordingRules = instanceSettings.jsonData.disableRecordingRules ?? false;\n-    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n     this.exemplarsAvailable = true;\n-    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n+    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n+    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n+    this.id = instanceSettings.id;\n+    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n+    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n     this.metricNamesAutocompleteSuggestionLimit =\n       instanceSettings.jsonData.codeModeMetricNamesSuggestionLimit ?? SUGGESTIONS_LIMIT;\n+    this.ruleMappings = {};\n+    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n+    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n+    this.type = 'prometheus';\n+    this.url = instanceSettings.url!;\n+    this.withCredentials = Boolean(instanceSettings.withCredentials);\n+    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n \n-    this.cache = new QueryCache({\n-      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n-      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n-      applyInterpolation: this.interpolateString.bind(this),\n-    });\n-\n+    // INHERITED PROPERTIES\n     this.annotations = PrometheusAnnotationSupport(this);\n+    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+\n+    // LANGUAGE PROVIDER\n+    // This needs to be the last thing we initialize.\n     this.languageProvider = languageProvider ?? new PrometheusLanguageProvider(this);\n   }\n \n-  init = async () => {\n+  /**\n+   * Initializes the Prometheus datasource by loading recording rules and checking exemplar availability.\n+   *\n+   * This method performs two key initialization tasks: Loads recording rules from the\n+   * Prometheus API and checks if exemplars are available by testing the exemplars API endpoint.\n+   */\n+  init = async (): Promise<void> => {\n     if (!this.disableRecordingRules) {\n       this.loadRules();\n     }\n     this.exemplarsAvailable = await this.areExemplarsAvailable();\n   };\n \n+  /**\n+   * Loads recording rules from the Prometheus API and extracts rule mappings.\n+   *\n+   * This method fetches rules from the `/api/v1/rules` endpoint and processes\n+   * them to create a mapping of rule names to their corresponding queries and labels.\n+   * The rules API is experimental, so errors are logged but not thrown.\n+   */\n+  private async loadRules(): Promise<void> {\n+    try {\n+      const params = {};\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/rules', params, options);\n+      const ruleGroups = res.data?.data?.groups;\n+\n+      if (ruleGroups) {\n+        this.ruleMappings = extractRuleMappingFromGroups(ruleGroups);\n+      }\n+    } catch (err) {\n+      console.log('Rules API is experimental. Ignore next error.');\n+      console.error(err);\n+    }\n+  }\n+\n+  /**\n+   * Checks if exemplars are available by testing the exemplars API endpoint.\n+   *\n+   * This method makes a test request to the `/api/v1/query_exemplars` endpoint to determine\n+   * if the Prometheus instance supports exemplars. The test uses a simple query with a\n+   * 30-minute time range. If the request succeeds with a 'success' status, exemplars\n+   * are considered available. Errors are caught and return false to avoid breaking\n+   * the datasource initialization.\n+   */\n+  private async areExemplarsAvailable(): Promise<boolean> {\n+    try {\n+      const params = {\n+        query: 'test',\n+        start: dateTime().subtract(30, 'minutes').valueOf().toString(),\n+        end: dateTime().valueOf().toString(),\n+      };\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/query_exemplars', params, options);\n+\n+      return res.data.status === 'success';\n+    } catch (err) {\n+      return false;\n+    }\n+  }\n+",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2168132826",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107208,
        "pr_file": "packages/grafana-prometheus/src/datasource.ts",
        "discussion_id": "2168132826",
        "commented_code": "@@ -118,48 +112,106 @@ export class PrometheusDatasource\n   ) {\n     super(instanceSettings);\n \n-    this.type = 'prometheus';\n-    this.id = instanceSettings.id;\n-    this.url = instanceSettings.url!;\n+    // DATASOURCE CONFIGURATION PROPERTIES\n     this.access = instanceSettings.access;\n     this.basicAuth = instanceSettings.basicAuth;\n-    this.withCredentials = Boolean(instanceSettings.withCredentials);\n-    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n-    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n-    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n-    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n-    this.ruleMappings = {};\n-    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n+    this.cache = new QueryCache({\n+      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n+      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n+      applyInterpolation: this.interpolateString.bind(this),\n+    });\n+    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n     this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n     this.datasourceConfigurationPrometheusFlavor = instanceSettings.jsonData.prometheusType;\n     this.datasourceConfigurationPrometheusVersion = instanceSettings.jsonData.prometheusVersion;\n-    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n-    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n-    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n     this.disableRecordingRules = instanceSettings.jsonData.disableRecordingRules ?? false;\n-    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n     this.exemplarsAvailable = true;\n-    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n+    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n+    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n+    this.id = instanceSettings.id;\n+    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n+    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n     this.metricNamesAutocompleteSuggestionLimit =\n       instanceSettings.jsonData.codeModeMetricNamesSuggestionLimit ?? SUGGESTIONS_LIMIT;\n+    this.ruleMappings = {};\n+    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n+    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n+    this.type = 'prometheus';\n+    this.url = instanceSettings.url!;\n+    this.withCredentials = Boolean(instanceSettings.withCredentials);\n+    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n \n-    this.cache = new QueryCache({\n-      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n-      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n-      applyInterpolation: this.interpolateString.bind(this),\n-    });\n-\n+    // INHERITED PROPERTIES\n     this.annotations = PrometheusAnnotationSupport(this);\n+    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+\n+    // LANGUAGE PROVIDER\n+    // This needs to be the last thing we initialize.\n     this.languageProvider = languageProvider ?? new PrometheusLanguageProvider(this);\n   }\n \n-  init = async () => {\n+  /**\n+   * Initializes the Prometheus datasource by loading recording rules and checking exemplar availability.\n+   *\n+   * This method performs two key initialization tasks: Loads recording rules from the\n+   * Prometheus API and checks if exemplars are available by testing the exemplars API endpoint.\n+   */\n+  init = async (): Promise<void> => {\n     if (!this.disableRecordingRules) {\n       this.loadRules();\n     }\n     this.exemplarsAvailable = await this.areExemplarsAvailable();\n   };\n \n+  /**\n+   * Loads recording rules from the Prometheus API and extracts rule mappings.\n+   *\n+   * This method fetches rules from the `/api/v1/rules` endpoint and processes\n+   * them to create a mapping of rule names to their corresponding queries and labels.\n+   * The rules API is experimental, so errors are logged but not thrown.\n+   */\n+  private async loadRules(): Promise<void> {\n+    try {\n+      const params = {};\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/rules', params, options);\n+      const ruleGroups = res.data?.data?.groups;\n+\n+      if (ruleGroups) {\n+        this.ruleMappings = extractRuleMappingFromGroups(ruleGroups);\n+      }\n+    } catch (err) {\n+      console.log('Rules API is experimental. Ignore next error.');\n+      console.error(err);\n+    }\n+  }\n+\n+  /**\n+   * Checks if exemplars are available by testing the exemplars API endpoint.\n+   *\n+   * This method makes a test request to the `/api/v1/query_exemplars` endpoint to determine\n+   * if the Prometheus instance supports exemplars. The test uses a simple query with a\n+   * 30-minute time range. If the request succeeds with a 'success' status, exemplars\n+   * are considered available. Errors are caught and return false to avoid breaking\n+   * the datasource initialization.\n+   */\n+  private async areExemplarsAvailable(): Promise<boolean> {\n+    try {\n+      const params = {\n+        query: 'test',\n+        start: dateTime().subtract(30, 'minutes').valueOf().toString(),\n+        end: dateTime().valueOf().toString(),\n+      };\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/query_exemplars', params, options);\n+\n+      return res.data.status === 'success';\n+    } catch (err) {\n+      return false;\n+    }\n+  }\n+",
        "comment_created_at": "2025-06-26T05:19:36+00:00",
        "comment_author": "hugohaggmark",
        "comment_body": "There are some external consumers of the grafana/prometheus package so making `loadRules` and `areExemplarsAvailable` private will be a breaking change. Is this an intentional breaking change?",
        "pr_file_module": null
      },
      {
        "comment_id": "2169502467",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107208,
        "pr_file": "packages/grafana-prometheus/src/datasource.ts",
        "discussion_id": "2168132826",
        "commented_code": "@@ -118,48 +112,106 @@ export class PrometheusDatasource\n   ) {\n     super(instanceSettings);\n \n-    this.type = 'prometheus';\n-    this.id = instanceSettings.id;\n-    this.url = instanceSettings.url!;\n+    // DATASOURCE CONFIGURATION PROPERTIES\n     this.access = instanceSettings.access;\n     this.basicAuth = instanceSettings.basicAuth;\n-    this.withCredentials = Boolean(instanceSettings.withCredentials);\n-    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n-    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n-    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n-    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n-    this.ruleMappings = {};\n-    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n+    this.cache = new QueryCache({\n+      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n+      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n+      applyInterpolation: this.interpolateString.bind(this),\n+    });\n+    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n     this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n     this.datasourceConfigurationPrometheusFlavor = instanceSettings.jsonData.prometheusType;\n     this.datasourceConfigurationPrometheusVersion = instanceSettings.jsonData.prometheusVersion;\n-    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n-    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n-    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n     this.disableRecordingRules = instanceSettings.jsonData.disableRecordingRules ?? false;\n-    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n     this.exemplarsAvailable = true;\n-    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n+    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n+    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n+    this.id = instanceSettings.id;\n+    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n+    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n     this.metricNamesAutocompleteSuggestionLimit =\n       instanceSettings.jsonData.codeModeMetricNamesSuggestionLimit ?? SUGGESTIONS_LIMIT;\n+    this.ruleMappings = {};\n+    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n+    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n+    this.type = 'prometheus';\n+    this.url = instanceSettings.url!;\n+    this.withCredentials = Boolean(instanceSettings.withCredentials);\n+    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n \n-    this.cache = new QueryCache({\n-      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n-      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n-      applyInterpolation: this.interpolateString.bind(this),\n-    });\n-\n+    // INHERITED PROPERTIES\n     this.annotations = PrometheusAnnotationSupport(this);\n+    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+\n+    // LANGUAGE PROVIDER\n+    // This needs to be the last thing we initialize.\n     this.languageProvider = languageProvider ?? new PrometheusLanguageProvider(this);\n   }\n \n-  init = async () => {\n+  /**\n+   * Initializes the Prometheus datasource by loading recording rules and checking exemplar availability.\n+   *\n+   * This method performs two key initialization tasks: Loads recording rules from the\n+   * Prometheus API and checks if exemplars are available by testing the exemplars API endpoint.\n+   */\n+  init = async (): Promise<void> => {\n     if (!this.disableRecordingRules) {\n       this.loadRules();\n     }\n     this.exemplarsAvailable = await this.areExemplarsAvailable();\n   };\n \n+  /**\n+   * Loads recording rules from the Prometheus API and extracts rule mappings.\n+   *\n+   * This method fetches rules from the `/api/v1/rules` endpoint and processes\n+   * them to create a mapping of rule names to their corresponding queries and labels.\n+   * The rules API is experimental, so errors are logged but not thrown.\n+   */\n+  private async loadRules(): Promise<void> {\n+    try {\n+      const params = {};\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/rules', params, options);\n+      const ruleGroups = res.data?.data?.groups;\n+\n+      if (ruleGroups) {\n+        this.ruleMappings = extractRuleMappingFromGroups(ruleGroups);\n+      }\n+    } catch (err) {\n+      console.log('Rules API is experimental. Ignore next error.');\n+      console.error(err);\n+    }\n+  }\n+\n+  /**\n+   * Checks if exemplars are available by testing the exemplars API endpoint.\n+   *\n+   * This method makes a test request to the `/api/v1/query_exemplars` endpoint to determine\n+   * if the Prometheus instance supports exemplars. The test uses a simple query with a\n+   * 30-minute time range. If the request succeeds with a 'success' status, exemplars\n+   * are considered available. Errors are caught and return false to avoid breaking\n+   * the datasource initialization.\n+   */\n+  private async areExemplarsAvailable(): Promise<boolean> {\n+    try {\n+      const params = {\n+        query: 'test',\n+        start: dateTime().subtract(30, 'minutes').valueOf().toString(),\n+        end: dateTime().valueOf().toString(),\n+      };\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/query_exemplars', params, options);\n+\n+      return res.data.status === 'success';\n+    } catch (err) {\n+      return false;\n+    }\n+  }\n+",
        "comment_created_at": "2025-06-26T17:01:00+00:00",
        "comment_author": "itsmylife",
        "comment_body": "@hugohaggmark I couldn't find any consumers who rely on these. Do you have anything you can share. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2170720248",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107208,
        "pr_file": "packages/grafana-prometheus/src/datasource.ts",
        "discussion_id": "2168132826",
        "commented_code": "@@ -118,48 +112,106 @@ export class PrometheusDatasource\n   ) {\n     super(instanceSettings);\n \n-    this.type = 'prometheus';\n-    this.id = instanceSettings.id;\n-    this.url = instanceSettings.url!;\n+    // DATASOURCE CONFIGURATION PROPERTIES\n     this.access = instanceSettings.access;\n     this.basicAuth = instanceSettings.basicAuth;\n-    this.withCredentials = Boolean(instanceSettings.withCredentials);\n-    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n-    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n-    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n-    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n-    this.ruleMappings = {};\n-    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n+    this.cache = new QueryCache({\n+      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n+      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n+      applyInterpolation: this.interpolateString.bind(this),\n+    });\n+    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n     this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n     this.datasourceConfigurationPrometheusFlavor = instanceSettings.jsonData.prometheusType;\n     this.datasourceConfigurationPrometheusVersion = instanceSettings.jsonData.prometheusVersion;\n-    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n-    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n-    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n     this.disableRecordingRules = instanceSettings.jsonData.disableRecordingRules ?? false;\n-    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n     this.exemplarsAvailable = true;\n-    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n+    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n+    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n+    this.id = instanceSettings.id;\n+    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n+    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n     this.metricNamesAutocompleteSuggestionLimit =\n       instanceSettings.jsonData.codeModeMetricNamesSuggestionLimit ?? SUGGESTIONS_LIMIT;\n+    this.ruleMappings = {};\n+    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n+    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n+    this.type = 'prometheus';\n+    this.url = instanceSettings.url!;\n+    this.withCredentials = Boolean(instanceSettings.withCredentials);\n+    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n \n-    this.cache = new QueryCache({\n-      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n-      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n-      applyInterpolation: this.interpolateString.bind(this),\n-    });\n-\n+    // INHERITED PROPERTIES\n     this.annotations = PrometheusAnnotationSupport(this);\n+    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+\n+    // LANGUAGE PROVIDER\n+    // This needs to be the last thing we initialize.\n     this.languageProvider = languageProvider ?? new PrometheusLanguageProvider(this);\n   }\n \n-  init = async () => {\n+  /**\n+   * Initializes the Prometheus datasource by loading recording rules and checking exemplar availability.\n+   *\n+   * This method performs two key initialization tasks: Loads recording rules from the\n+   * Prometheus API and checks if exemplars are available by testing the exemplars API endpoint.\n+   */\n+  init = async (): Promise<void> => {\n     if (!this.disableRecordingRules) {\n       this.loadRules();\n     }\n     this.exemplarsAvailable = await this.areExemplarsAvailable();\n   };\n \n+  /**\n+   * Loads recording rules from the Prometheus API and extracts rule mappings.\n+   *\n+   * This method fetches rules from the `/api/v1/rules` endpoint and processes\n+   * them to create a mapping of rule names to their corresponding queries and labels.\n+   * The rules API is experimental, so errors are logged but not thrown.\n+   */\n+  private async loadRules(): Promise<void> {\n+    try {\n+      const params = {};\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/rules', params, options);\n+      const ruleGroups = res.data?.data?.groups;\n+\n+      if (ruleGroups) {\n+        this.ruleMappings = extractRuleMappingFromGroups(ruleGroups);\n+      }\n+    } catch (err) {\n+      console.log('Rules API is experimental. Ignore next error.');\n+      console.error(err);\n+    }\n+  }\n+\n+  /**\n+   * Checks if exemplars are available by testing the exemplars API endpoint.\n+   *\n+   * This method makes a test request to the `/api/v1/query_exemplars` endpoint to determine\n+   * if the Prometheus instance supports exemplars. The test uses a simple query with a\n+   * 30-minute time range. If the request succeeds with a 'success' status, exemplars\n+   * are considered available. Errors are caught and return false to avoid breaking\n+   * the datasource initialization.\n+   */\n+  private async areExemplarsAvailable(): Promise<boolean> {\n+    try {\n+      const params = {\n+        query: 'test',\n+        start: dateTime().subtract(30, 'minutes').valueOf().toString(),\n+        end: dateTime().valueOf().toString(),\n+      };\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/query_exemplars', params, options);\n+\n+      return res.data.status === 'success';\n+    } catch (err) {\n+      return false;\n+    }\n+  }\n+",
        "comment_created_at": "2025-06-27T04:04:59+00:00",
        "comment_author": "hugohaggmark",
        "comment_body": "I didn't dig to deep into this, I did this search https://github.com/search?q=org%3Agrafana%20%40grafana%2Fprometheus&type=code and there was 5 pages of result so I just wanted you to be aware of the potential breaking change. If you have dug deeper and couldn't find any consumers I'm alright with that. Sorry for the noise 👍  ",
        "pr_file_module": null
      },
      {
        "comment_id": "2171421842",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107208,
        "pr_file": "packages/grafana-prometheus/src/datasource.ts",
        "discussion_id": "2168132826",
        "commented_code": "@@ -118,48 +112,106 @@ export class PrometheusDatasource\n   ) {\n     super(instanceSettings);\n \n-    this.type = 'prometheus';\n-    this.id = instanceSettings.id;\n-    this.url = instanceSettings.url!;\n+    // DATASOURCE CONFIGURATION PROPERTIES\n     this.access = instanceSettings.access;\n     this.basicAuth = instanceSettings.basicAuth;\n-    this.withCredentials = Boolean(instanceSettings.withCredentials);\n-    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n-    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n-    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n-    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n-    this.ruleMappings = {};\n-    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n+    this.cache = new QueryCache({\n+      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n+      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n+      applyInterpolation: this.interpolateString.bind(this),\n+    });\n+    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n     this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n     this.datasourceConfigurationPrometheusFlavor = instanceSettings.jsonData.prometheusType;\n     this.datasourceConfigurationPrometheusVersion = instanceSettings.jsonData.prometheusVersion;\n-    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n-    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n-    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n     this.disableRecordingRules = instanceSettings.jsonData.disableRecordingRules ?? false;\n-    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+    this.exemplarTraceIdDestinations = instanceSettings.jsonData.exemplarTraceIdDestinations;\n     this.exemplarsAvailable = true;\n-    this.cacheLevel = instanceSettings.jsonData.cacheLevel ?? PrometheusCacheLevel.Low;\n+    this.hasIncrementalQuery = instanceSettings.jsonData.incrementalQuerying ?? false;\n+    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n+    this.id = instanceSettings.id;\n+    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n+    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup ?? false;\n     this.metricNamesAutocompleteSuggestionLimit =\n       instanceSettings.jsonData.codeModeMetricNamesSuggestionLimit ?? SUGGESTIONS_LIMIT;\n+    this.ruleMappings = {};\n+    this.seriesEndpoint = instanceSettings.jsonData.seriesEndpoint ?? false;\n+    this.seriesLimit = instanceSettings.jsonData.seriesLimit ?? DEFAULT_SERIES_LIMIT;\n+    this.type = 'prometheus';\n+    this.url = instanceSettings.url!;\n+    this.withCredentials = Boolean(instanceSettings.withCredentials);\n+    this.defaultEditor = instanceSettings.jsonData.defaultEditor;\n \n-    this.cache = new QueryCache({\n-      getTargetSignature: this.getPrometheusTargetSignature.bind(this),\n-      overlapString: instanceSettings.jsonData.incrementalQueryOverlapWindow ?? defaultPrometheusQueryOverlapWindow,\n-      applyInterpolation: this.interpolateString.bind(this),\n-    });\n-\n+    // INHERITED PROPERTIES\n     this.annotations = PrometheusAnnotationSupport(this);\n+    this.variables = new PrometheusVariableSupport(this, this.templateSrv);\n+\n+    // LANGUAGE PROVIDER\n+    // This needs to be the last thing we initialize.\n     this.languageProvider = languageProvider ?? new PrometheusLanguageProvider(this);\n   }\n \n-  init = async () => {\n+  /**\n+   * Initializes the Prometheus datasource by loading recording rules and checking exemplar availability.\n+   *\n+   * This method performs two key initialization tasks: Loads recording rules from the\n+   * Prometheus API and checks if exemplars are available by testing the exemplars API endpoint.\n+   */\n+  init = async (): Promise<void> => {\n     if (!this.disableRecordingRules) {\n       this.loadRules();\n     }\n     this.exemplarsAvailable = await this.areExemplarsAvailable();\n   };\n \n+  /**\n+   * Loads recording rules from the Prometheus API and extracts rule mappings.\n+   *\n+   * This method fetches rules from the `/api/v1/rules` endpoint and processes\n+   * them to create a mapping of rule names to their corresponding queries and labels.\n+   * The rules API is experimental, so errors are logged but not thrown.\n+   */\n+  private async loadRules(): Promise<void> {\n+    try {\n+      const params = {};\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/rules', params, options);\n+      const ruleGroups = res.data?.data?.groups;\n+\n+      if (ruleGroups) {\n+        this.ruleMappings = extractRuleMappingFromGroups(ruleGroups);\n+      }\n+    } catch (err) {\n+      console.log('Rules API is experimental. Ignore next error.');\n+      console.error(err);\n+    }\n+  }\n+\n+  /**\n+   * Checks if exemplars are available by testing the exemplars API endpoint.\n+   *\n+   * This method makes a test request to the `/api/v1/query_exemplars` endpoint to determine\n+   * if the Prometheus instance supports exemplars. The test uses a simple query with a\n+   * 30-minute time range. If the request succeeds with a 'success' status, exemplars\n+   * are considered available. Errors are caught and return false to avoid breaking\n+   * the datasource initialization.\n+   */\n+  private async areExemplarsAvailable(): Promise<boolean> {\n+    try {\n+      const params = {\n+        query: 'test',\n+        start: dateTime().subtract(30, 'minutes').valueOf().toString(),\n+        end: dateTime().valueOf().toString(),\n+      };\n+      const options = { showErrorAlert: false };\n+      const res = await this.metadataRequest('/api/v1/query_exemplars', params, options);\n+\n+      return res.data.status === 'success';\n+    } catch (err) {\n+      return false;\n+    }\n+  }\n+",
        "comment_created_at": "2025-06-27T09:41:12+00:00",
        "comment_author": "itsgareth",
        "comment_body": "i just did a deeper dive into this, and i also didn't find any usage. i appreciate you raising this though! ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1602996309",
    "pr_number": 87545,
    "pr_file": "scripts/generate-rtk-apis.ts",
    "created_at": "2024-05-16T09:37:30+00:00",
    "commented_code": "'getDashboardByUid',\n       ],\n     },\n+",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1602996309",
        "repo_full_name": "grafana/grafana",
        "pr_number": 87545,
        "pr_file": "scripts/generate-rtk-apis.ts",
        "discussion_id": "1602996309",
        "commented_code": "@@ -23,6 +23,25 @@ const config: ConfigFile = {\n         'getDashboardByUid',\n       ],\n     },\n+",
        "comment_created_at": "2024-05-16T09:37:30+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "Wonder how to make this work for Enterprise. Should we define the same file there with own paths and then somehow merge it with this one? ",
        "pr_file_module": null
      },
      {
        "comment_id": "1603330058",
        "repo_full_name": "grafana/grafana",
        "pr_number": 87545,
        "pr_file": "scripts/generate-rtk-apis.ts",
        "discussion_id": "1602996309",
        "commented_code": "@@ -23,6 +23,25 @@ const config: ConfigFile = {\n         'getDashboardByUid',\n       ],\n     },\n+",
        "comment_created_at": "2024-05-16T13:19:17+00:00",
        "comment_author": "joshhunt",
        "comment_body": "Yeah, that's a valid question. Where would the API clients for enterprise live? Given the legacy api enterprise spec lives in the OSS repo, i think it's fine to generate the clients into OSS repo as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "1603338732",
        "repo_full_name": "grafana/grafana",
        "pr_number": 87545,
        "pr_file": "scripts/generate-rtk-apis.ts",
        "discussion_id": "1602996309",
        "commented_code": "@@ -23,6 +23,25 @@ const config: ConfigFile = {\n         'getDashboardByUid',\n       ],\n     },\n+",
        "comment_created_at": "2024-05-16T13:24:17+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "I think the generated clients should be in the same place as the feature (the FE part), under the `api` folder, so Enterprise clients would be in the Enterprise repo. As for the scripts that generate those clients, I'm not sure. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1603349148",
        "repo_full_name": "grafana/grafana",
        "pr_number": 87545,
        "pr_file": "scripts/generate-rtk-apis.ts",
        "discussion_id": "1602996309",
        "commented_code": "@@ -23,6 +23,25 @@ const config: ConfigFile = {\n         'getDashboardByUid',\n       ],\n     },\n+",
        "comment_created_at": "2024-05-16T13:28:16+00:00",
        "comment_author": "joshhunt",
        "comment_body": "Yeah, that's valid. The problem is that there's this desire to share at least some of these API clients with plugins, probably through the grafana-runtime package.",
        "pr_file_module": null
      }
    ]
  }
]