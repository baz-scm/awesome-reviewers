[
  {
    "discussion_id": "2155672595",
    "pr_number": 106962,
    "pr_file": "public/app/plugins/panel/geomap/layers/data/markersLayer.tsx",
    "created_at": "2025-06-18T22:54:11+00:00",
    "commented_code": "// Track if we find any line strings during feature processing\n           let hasLineString = false;\n+          \n+          // Track coordinates to avoid rendering duplicate markers at the same location\n+          const processedCoordinates = new Set<string>();\n \n           source.forEachFeature((feature) => {\n-            const isLineString = feature.getGeometry()?.getType() === 'LineString';\n+            const geometry = feature.getGeometry();\n+            const isLineString = geometry?.getType() === 'LineString';\n+            \n+            // For point geometries, check if we've already processed this coordinate\n+            if (geometry?.getType() === 'Point') {\n+              const coordinates = geometry.getCoordinates();\n+              const coordKey = `${coordinates[0]},${coordinates[1]}`;",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2155672595",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106962,
        "pr_file": "public/app/plugins/panel/geomap/layers/data/markersLayer.tsx",
        "discussion_id": "2155672595",
        "commented_code": "@@ -122,9 +122,26 @@ export const markersLayer: MapLayerRegistryItem<MarkersConfig> = {\n \n           // Track if we find any line strings during feature processing\n           let hasLineString = false;\n+          \n+          // Track coordinates to avoid rendering duplicate markers at the same location\n+          const processedCoordinates = new Set<string>();\n \n           source.forEachFeature((feature) => {\n-            const isLineString = feature.getGeometry()?.getType() === 'LineString';\n+            const geometry = feature.getGeometry();\n+            const isLineString = geometry?.getType() === 'LineString';\n+            \n+            // For point geometries, check if we've already processed this coordinate\n+            if (geometry?.getType() === 'Point') {\n+              const coordinates = geometry.getCoordinates();\n+              const coordKey = `${coordinates[0]},${coordinates[1]}`;",
        "comment_created_at": "2025-06-18T22:54:11+00:00",
        "comment_author": "drew08t",
        "comment_body": "A limitation on this approach are for markers with dimension driven color or size. Might need to check for those too to define uniqueness. But, if we do that, opacities will still stack. Open to suggestions here.",
        "pr_file_module": null
      },
      {
        "comment_id": "2156002206",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106962,
        "pr_file": "public/app/plugins/panel/geomap/layers/data/markersLayer.tsx",
        "discussion_id": "2155672595",
        "commented_code": "@@ -122,9 +122,26 @@ export const markersLayer: MapLayerRegistryItem<MarkersConfig> = {\n \n           // Track if we find any line strings during feature processing\n           let hasLineString = false;\n+          \n+          // Track coordinates to avoid rendering duplicate markers at the same location\n+          const processedCoordinates = new Set<string>();\n \n           source.forEachFeature((feature) => {\n-            const isLineString = feature.getGeometry()?.getType() === 'LineString';\n+            const geometry = feature.getGeometry();\n+            const isLineString = geometry?.getType() === 'LineString';\n+            \n+            // For point geometries, check if we've already processed this coordinate\n+            if (geometry?.getType() === 'Point') {\n+              const coordinates = geometry.getCoordinates();\n+              const coordKey = `${coordinates[0]},${coordinates[1]}`;",
        "comment_created_at": "2025-06-19T03:24:00+00:00",
        "comment_author": "leeoniya",
        "comment_body": "hmm, this could get quite expensive for \"webgl quantity\" of markers? maybe we can take a different approach here?\r\n\r\ninstead of drawing the additional 0.05 bounding circle, is it possible to clamp the min opacity of the marker itself to 0.05 until the OL issue is fixed? that way we have the same inacurate alpha composition as we do today, but without the circle artifact.",
        "pr_file_module": null
      },
      {
        "comment_id": "2168104523",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106962,
        "pr_file": "public/app/plugins/panel/geomap/layers/data/markersLayer.tsx",
        "discussion_id": "2155672595",
        "commented_code": "@@ -122,9 +122,26 @@ export const markersLayer: MapLayerRegistryItem<MarkersConfig> = {\n \n           // Track if we find any line strings during feature processing\n           let hasLineString = false;\n+          \n+          // Track coordinates to avoid rendering duplicate markers at the same location\n+          const processedCoordinates = new Set<string>();\n \n           source.forEachFeature((feature) => {\n-            const isLineString = feature.getGeometry()?.getType() === 'LineString';\n+            const geometry = feature.getGeometry();\n+            const isLineString = geometry?.getType() === 'LineString';\n+            \n+            // For point geometries, check if we've already processed this coordinate\n+            if (geometry?.getType() === 'Point') {\n+              const coordinates = geometry.getCoordinates();\n+              const coordKey = `${coordinates[0]},${coordinates[1]}`;",
        "comment_created_at": "2025-06-26T04:55:07+00:00",
        "comment_author": "drew08t",
        "comment_body": "Great point about performance! I did some testing and this block of code adds the following amount of processing time during initialization:\r\n100k points: ~140ms\r\n10k points: ~15ms\r\n1k points: ~1ms\r\n\r\nConsidering the current limitation of hit detection when using webGL, I think it is worth the performance hit for now until we find an alternative approach. I'm going to see how much more performance suffers when taking into account color or size as well to define uniqueness. ",
        "pr_file_module": null
      },
      {
        "comment_id": "2168121124",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106962,
        "pr_file": "public/app/plugins/panel/geomap/layers/data/markersLayer.tsx",
        "discussion_id": "2155672595",
        "commented_code": "@@ -122,9 +122,26 @@ export const markersLayer: MapLayerRegistryItem<MarkersConfig> = {\n \n           // Track if we find any line strings during feature processing\n           let hasLineString = false;\n+          \n+          // Track coordinates to avoid rendering duplicate markers at the same location\n+          const processedCoordinates = new Set<string>();\n \n           source.forEachFeature((feature) => {\n-            const isLineString = feature.getGeometry()?.getType() === 'LineString';\n+            const geometry = feature.getGeometry();\n+            const isLineString = geometry?.getType() === 'LineString';\n+            \n+            // For point geometries, check if we've already processed this coordinate\n+            if (geometry?.getType() === 'Point') {\n+              const coordinates = geometry.getCoordinates();\n+              const coordKey = `${coordinates[0]},${coordinates[1]}`;",
        "comment_created_at": "2025-06-26T05:10:35+00:00",
        "comment_author": "drew08t",
        "comment_body": "Taking into account color, text, size, and rotation impacts our performance a bit:\r\n100k points: ~180ms\r\n10k points: ~20ms",
        "pr_file_module": null
      },
      {
        "comment_id": "2168127892",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106962,
        "pr_file": "public/app/plugins/panel/geomap/layers/data/markersLayer.tsx",
        "discussion_id": "2155672595",
        "commented_code": "@@ -122,9 +122,26 @@ export const markersLayer: MapLayerRegistryItem<MarkersConfig> = {\n \n           // Track if we find any line strings during feature processing\n           let hasLineString = false;\n+          \n+          // Track coordinates to avoid rendering duplicate markers at the same location\n+          const processedCoordinates = new Set<string>();\n \n           source.forEachFeature((feature) => {\n-            const isLineString = feature.getGeometry()?.getType() === 'LineString';\n+            const geometry = feature.getGeometry();\n+            const isLineString = geometry?.getType() === 'LineString';\n+            \n+            // For point geometries, check if we've already processed this coordinate\n+            if (geometry?.getType() === 'Point') {\n+              const coordinates = geometry.getCoordinates();\n+              const coordKey = `${coordinates[0]},${coordinates[1]}`;",
        "comment_created_at": "2025-06-26T05:15:45+00:00",
        "comment_author": "drew08t",
        "comment_body": "Here's an example of multiple points with the same coordinates that have different sizes and colors.\r\n\r\n<img width=\"426\" alt=\"image\" src=\"https://github.com/user-attachments/assets/f4e8338f-8f5a-4451-90e4-defc3ffe11f1\" />\r\n\r\nI figure if the markers have distinct dims, opacity should stack and bleed through in that case.\r\n\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2154185169",
    "pr_number": 104207,
    "pr_file": "public/app/features/dashboard-scene/sharing/ExportButton/ExportAsImage.tsx",
    "created_at": "2025-06-18T09:54:01+00:00",
    "commented_code": "+import { css } from '@emotion/css';\n+import { saveAs } from 'file-saver';\n+import { useState, useEffect } from 'react';\n+\n+import { GrafanaTheme2 } from '@grafana/data';\n+import { selectors } from '@grafana/e2e-selectors';\n+import { Trans, t } from '@grafana/i18n';\n+import { config } from '@grafana/runtime';\n+import { SceneComponentProps, SceneObjectBase, SceneObjectState } from '@grafana/scenes';\n+import { Alert, Button, useStyles2 } from '@grafana/ui';\n+import { DashboardInteractions } from 'app/features/dashboard-scene/utils/interactions';\n+import { getDashboardSceneFor } from 'app/features/dashboard-scene/utils/utils';\n+\n+import { ImagePreview } from '../components/ImagePreview';\n+import { ShareView } from '../types';\n+\n+import { generateDashboardImage, ImageGenerationError } from './utils';\n+\n+type ErrorState = {\n+  message: string;\n+  title: string;\n+  code?: ImageGenerationError;\n+} | null;\n+\n+export interface ExportAsImageState extends SceneObjectState {\n+  onDismiss: () => void;\n+}\n+\n+export class ExportAsImage extends SceneObjectBase<ExportAsImageState> implements ShareView {\n+  static Component = ExportAsImageRenderer;\n+\n+  public getTabLabel() {\n+    return t('share-modal.image.title', 'Export as image');\n+  }\n+}\n+\n+function ExportAsImageRenderer({ model }: SceneComponentProps<ExportAsImage>) {\n+  const { onDismiss } = model.useState();\n+  const dashboard = getDashboardSceneFor(model);\n+  const [isLoading, setIsLoading] = useState(false);\n+  const [imageBlob, setImageBlob] = useState<Blob | null>(null);\n+  const [error, setError] = useState<ErrorState>(null);\n+  const styles = useStyles2(getStyles);\n+\n+  // Clean up object URLs when component unmounts\n+  useEffect(() => {\n+    return () => {\n+      if (imageBlob) {\n+        URL.revokeObjectURL(URL.createObjectURL(imageBlob));\n+      }\n+    };\n+  }, [imageBlob]);",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2154185169",
        "repo_full_name": "grafana/grafana",
        "pr_number": 104207,
        "pr_file": "public/app/features/dashboard-scene/sharing/ExportButton/ExportAsImage.tsx",
        "discussion_id": "2154185169",
        "commented_code": "@@ -0,0 +1,200 @@\n+import { css } from '@emotion/css';\n+import { saveAs } from 'file-saver';\n+import { useState, useEffect } from 'react';\n+\n+import { GrafanaTheme2 } from '@grafana/data';\n+import { selectors } from '@grafana/e2e-selectors';\n+import { Trans, t } from '@grafana/i18n';\n+import { config } from '@grafana/runtime';\n+import { SceneComponentProps, SceneObjectBase, SceneObjectState } from '@grafana/scenes';\n+import { Alert, Button, useStyles2 } from '@grafana/ui';\n+import { DashboardInteractions } from 'app/features/dashboard-scene/utils/interactions';\n+import { getDashboardSceneFor } from 'app/features/dashboard-scene/utils/utils';\n+\n+import { ImagePreview } from '../components/ImagePreview';\n+import { ShareView } from '../types';\n+\n+import { generateDashboardImage, ImageGenerationError } from './utils';\n+\n+type ErrorState = {\n+  message: string;\n+  title: string;\n+  code?: ImageGenerationError;\n+} | null;\n+\n+export interface ExportAsImageState extends SceneObjectState {\n+  onDismiss: () => void;\n+}\n+\n+export class ExportAsImage extends SceneObjectBase<ExportAsImageState> implements ShareView {\n+  static Component = ExportAsImageRenderer;\n+\n+  public getTabLabel() {\n+    return t('share-modal.image.title', 'Export as image');\n+  }\n+}\n+\n+function ExportAsImageRenderer({ model }: SceneComponentProps<ExportAsImage>) {\n+  const { onDismiss } = model.useState();\n+  const dashboard = getDashboardSceneFor(model);\n+  const [isLoading, setIsLoading] = useState(false);\n+  const [imageBlob, setImageBlob] = useState<Blob | null>(null);\n+  const [error, setError] = useState<ErrorState>(null);\n+  const styles = useStyles2(getStyles);\n+\n+  // Clean up object URLs when component unmounts\n+  useEffect(() => {\n+    return () => {\n+      if (imageBlob) {\n+        URL.revokeObjectURL(URL.createObjectURL(imageBlob));\n+      }\n+    };\n+  }, [imageBlob]);",
        "comment_created_at": "2025-06-18T09:54:01+00:00",
        "comment_author": "juanicabanas",
        "comment_body": "why is this necessary?",
        "pr_file_module": null
      },
      {
        "comment_id": "2168032373",
        "repo_full_name": "grafana/grafana",
        "pr_number": 104207,
        "pr_file": "public/app/features/dashboard-scene/sharing/ExportButton/ExportAsImage.tsx",
        "discussion_id": "2154185169",
        "commented_code": "@@ -0,0 +1,200 @@\n+import { css } from '@emotion/css';\n+import { saveAs } from 'file-saver';\n+import { useState, useEffect } from 'react';\n+\n+import { GrafanaTheme2 } from '@grafana/data';\n+import { selectors } from '@grafana/e2e-selectors';\n+import { Trans, t } from '@grafana/i18n';\n+import { config } from '@grafana/runtime';\n+import { SceneComponentProps, SceneObjectBase, SceneObjectState } from '@grafana/scenes';\n+import { Alert, Button, useStyles2 } from '@grafana/ui';\n+import { DashboardInteractions } from 'app/features/dashboard-scene/utils/interactions';\n+import { getDashboardSceneFor } from 'app/features/dashboard-scene/utils/utils';\n+\n+import { ImagePreview } from '../components/ImagePreview';\n+import { ShareView } from '../types';\n+\n+import { generateDashboardImage, ImageGenerationError } from './utils';\n+\n+type ErrorState = {\n+  message: string;\n+  title: string;\n+  code?: ImageGenerationError;\n+} | null;\n+\n+export interface ExportAsImageState extends SceneObjectState {\n+  onDismiss: () => void;\n+}\n+\n+export class ExportAsImage extends SceneObjectBase<ExportAsImageState> implements ShareView {\n+  static Component = ExportAsImageRenderer;\n+\n+  public getTabLabel() {\n+    return t('share-modal.image.title', 'Export as image');\n+  }\n+}\n+\n+function ExportAsImageRenderer({ model }: SceneComponentProps<ExportAsImage>) {\n+  const { onDismiss } = model.useState();\n+  const dashboard = getDashboardSceneFor(model);\n+  const [isLoading, setIsLoading] = useState(false);\n+  const [imageBlob, setImageBlob] = useState<Blob | null>(null);\n+  const [error, setError] = useState<ErrorState>(null);\n+  const styles = useStyles2(getStyles);\n+\n+  // Clean up object URLs when component unmounts\n+  useEffect(() => {\n+    return () => {\n+      if (imageBlob) {\n+        URL.revokeObjectURL(URL.createObjectURL(imageBlob));\n+      }\n+    };\n+  }, [imageBlob]);",
        "comment_created_at": "2025-06-26T03:38:06+00:00",
        "comment_author": "nmarrs",
        "comment_body": "it's necessary to prevent memory leaks by cleaning up object URLs created from the image blob\r\n\r\nWhen URL.createObjectURL() is used elsewhere in the code to display the blob, those URLs need to be revoked when the component unmounts, otherwise the browser keeps the blob data in memory indefinitely",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1498718108",
    "pr_number": 82018,
    "pr_file": "packages/grafana-ui/src/components/Table/RowsList.tsx",
    "created_at": "2024-02-22T06:35:06+00:00",
    "commented_code": "timeRange?: TimeRange;\n   footerPaginationEnabled: boolean;\n   initialRowIndex?: number;\n+  // Boolean to specify if a data attribute containing row index is added to each row\n+  showDataIndices: boolean;",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1498718108",
        "repo_full_name": "grafana/grafana",
        "pr_number": 82018,
        "pr_file": "packages/grafana-ui/src/components/Table/RowsList.tsx",
        "discussion_id": "1498718108",
        "commented_code": "@@ -45,6 +45,8 @@ interface RowsListProps {\n   timeRange?: TimeRange;\n   footerPaginationEnabled: boolean;\n   initialRowIndex?: number;\n+  // Boolean to specify if a data attribute containing row index is added to each row\n+  showDataIndices: boolean;",
        "comment_created_at": "2024-02-22T06:35:06+00:00",
        "comment_author": "torkelo",
        "comment_body": "I don't understand this prop, it does not seem cause any visual change, yet named \"showDataIndices\". \r\n\r\nIt just adds  data-row-index, how is that property used? why do we need it? If we need it can't we always render it?= ",
        "pr_file_module": null
      },
      {
        "comment_id": "1499020895",
        "repo_full_name": "grafana/grafana",
        "pr_number": 82018,
        "pr_file": "packages/grafana-ui/src/components/Table/RowsList.tsx",
        "discussion_id": "1498718108",
        "commented_code": "@@ -45,6 +45,8 @@ interface RowsListProps {\n   timeRange?: TimeRange;\n   footerPaginationEnabled: boolean;\n   initialRowIndex?: number;\n+  // Boolean to specify if a data attribute containing row index is added to each row\n+  showDataIndices: boolean;",
        "comment_created_at": "2024-02-22T10:29:45+00:00",
        "comment_author": "matyax",
        "comment_body": "We could always render it, or render it only if a `onCellClick` is provided.",
        "pr_file_module": null
      },
      {
        "comment_id": "1499224391",
        "repo_full_name": "grafana/grafana",
        "pr_number": 82018,
        "pr_file": "packages/grafana-ui/src/components/Table/RowsList.tsx",
        "discussion_id": "1498718108",
        "commented_code": "@@ -45,6 +45,8 @@ interface RowsListProps {\n   timeRange?: TimeRange;\n   footerPaginationEnabled: boolean;\n   initialRowIndex?: number;\n+  // Boolean to specify if a data attribute containing row index is added to each row\n+  showDataIndices: boolean;",
        "comment_created_at": "2024-02-22T13:14:52+00:00",
        "comment_author": "gtk-grafana",
        "comment_body": "This prop is just to conditionally render the additional data attribute, which are only used when the table click callback function is defined, we didn't want to introduce unnecessary DOM attributes that could have performance impact on tables not using this feature (although the impact is negligible). ",
        "pr_file_module": null
      },
      {
        "comment_id": "1499232749",
        "repo_full_name": "grafana/grafana",
        "pr_number": 82018,
        "pr_file": "packages/grafana-ui/src/components/Table/RowsList.tsx",
        "discussion_id": "1498718108",
        "commented_code": "@@ -45,6 +45,8 @@ interface RowsListProps {\n   timeRange?: TimeRange;\n   footerPaginationEnabled: boolean;\n   initialRowIndex?: number;\n+  // Boolean to specify if a data attribute containing row index is added to each row\n+  showDataIndices: boolean;",
        "comment_created_at": "2024-02-22T13:21:04+00:00",
        "comment_author": "gtk-grafana",
        "comment_body": "If we want to render this for everyone that would simplify the code a bit, but I was trying to be overly cautious not to impact existing users to make it easier for this to get merged in so we can start building more interactivity with table ASAP. ",
        "pr_file_module": null
      }
    ]
  }
]