[
  {
    "discussion_id": "2167560859",
    "pr_number": 106997,
    "pr_file": "pkg/services/libraryelements/database.go",
    "created_at": "2025-06-25T20:22:49+00:00",
    "commented_code": "if folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2167560859",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106997,
        "pr_file": "pkg/services/libraryelements/database.go",
        "discussion_id": "2167560859",
        "commented_code": "@@ -441,15 +441,29 @@ func (l *LibraryElementService) getAllLibraryElements(c context.Context, signedI\n \tif folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})",
        "comment_created_at": "2025-06-25T20:22:49+00:00",
        "comment_author": "evictorero",
        "comment_body": "Instead of using the `folderService.GetFolders` service and filtering later by title using a JOIN we could use a different service and search directly by title and permissions. Did you take a look at the `folderService.SearchFolders` ? ",
        "pr_file_module": null
      },
      {
        "comment_id": "2168700001",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106997,
        "pr_file": "pkg/services/libraryelements/database.go",
        "discussion_id": "2167560859",
        "commented_code": "@@ -441,15 +441,29 @@ func (l *LibraryElementService) getAllLibraryElements(c context.Context, signedI\n \tif folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})",
        "comment_created_at": "2025-06-26T10:05:24+00:00",
        "comment_author": "axelavargas",
        "comment_body": "No, I didn't look at that service. Thanks, Eze. I'll check it out.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167561571",
    "pr_number": 106997,
    "pr_file": "pkg/services/libraryelements/database.go",
    "created_at": "2025-06-25T20:23:15+00:00",
    "commented_code": "if folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})\n+\tif err != nil {\n+\t\treturn model.LibraryElementSearchResult{}, err\n+\t}\n+\t// Every signed in user can see the general folder. The general folder might have \"general\" or the empty string as its UID.\n+\taccessibleFolderUIDs := make([]string, 0, len(fs)+2)\n+\taccessibleFolderUIDs = append(accessibleFolderUIDs, \"general\", \"\")\n+\tfor _, f := range fs {\n+\t\taccessibleFolderUIDs = append(accessibleFolderUIDs, f.UID)\n+\t}\n+\n \terr = l.SQLStore.WithDbSession(c, func(session *db.Session) error {\n \t\tbuilder := db.NewSqlBuilder(l.Cfg, l.features, l.SQLStore.GetDialect(), recursiveQueriesAreSupported)\n \t\tif folderFilter.includeGeneralFolder {\n \t\t\tbuilder.Write(selectLibraryElementDTOWithMeta)\n \t\t\tbuilder.Write(\", '' as folder_uid \")\n \t\t\tbuilder.Write(getFromLibraryElementDTOWithMeta(l.SQLStore.GetDialect()))\n+\t\t\tbuilder.Write(\" LEFT JOIN folder f ON le.folder_uid = f.uid AND le.org_id = f.org_id\")",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2167561571",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106997,
        "pr_file": "pkg/services/libraryelements/database.go",
        "discussion_id": "2167561571",
        "commented_code": "@@ -441,15 +441,29 @@ func (l *LibraryElementService) getAllLibraryElements(c context.Context, signedI\n \tif folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})\n+\tif err != nil {\n+\t\treturn model.LibraryElementSearchResult{}, err\n+\t}\n+\t// Every signed in user can see the general folder. The general folder might have \"general\" or the empty string as its UID.\n+\taccessibleFolderUIDs := make([]string, 0, len(fs)+2)\n+\taccessibleFolderUIDs = append(accessibleFolderUIDs, \"general\", \"\")\n+\tfor _, f := range fs {\n+\t\taccessibleFolderUIDs = append(accessibleFolderUIDs, f.UID)\n+\t}\n+\n \terr = l.SQLStore.WithDbSession(c, func(session *db.Session) error {\n \t\tbuilder := db.NewSqlBuilder(l.Cfg, l.features, l.SQLStore.GetDialect(), recursiveQueriesAreSupported)\n \t\tif folderFilter.includeGeneralFolder {\n \t\t\tbuilder.Write(selectLibraryElementDTOWithMeta)\n \t\t\tbuilder.Write(\", '' as folder_uid \")\n \t\t\tbuilder.Write(getFromLibraryElementDTOWithMeta(l.SQLStore.GetDialect()))\n+\t\t\tbuilder.Write(\" LEFT JOIN folder f ON le.folder_uid = f.uid AND le.org_id = f.org_id\")",
        "comment_created_at": "2025-06-25T20:23:15+00:00",
        "comment_author": "evictorero",
        "comment_body": "I don't think we should use a JOIN while migrating to unified storage. We recently removed all queries that join the dashboards table and it is the same case for folders.",
        "pr_file_module": null
      },
      {
        "comment_id": "2168701032",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106997,
        "pr_file": "pkg/services/libraryelements/database.go",
        "discussion_id": "2167561571",
        "commented_code": "@@ -441,15 +441,29 @@ func (l *LibraryElementService) getAllLibraryElements(c context.Context, signedI\n \tif folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})\n+\tif err != nil {\n+\t\treturn model.LibraryElementSearchResult{}, err\n+\t}\n+\t// Every signed in user can see the general folder. The general folder might have \"general\" or the empty string as its UID.\n+\taccessibleFolderUIDs := make([]string, 0, len(fs)+2)\n+\taccessibleFolderUIDs = append(accessibleFolderUIDs, \"general\", \"\")\n+\tfor _, f := range fs {\n+\t\taccessibleFolderUIDs = append(accessibleFolderUIDs, f.UID)\n+\t}\n+\n \terr = l.SQLStore.WithDbSession(c, func(session *db.Session) error {\n \t\tbuilder := db.NewSqlBuilder(l.Cfg, l.features, l.SQLStore.GetDialect(), recursiveQueriesAreSupported)\n \t\tif folderFilter.includeGeneralFolder {\n \t\t\tbuilder.Write(selectLibraryElementDTOWithMeta)\n \t\t\tbuilder.Write(\", '' as folder_uid \")\n \t\t\tbuilder.Write(getFromLibraryElementDTOWithMeta(l.SQLStore.GetDialect()))\n+\t\t\tbuilder.Write(\" LEFT JOIN folder f ON le.folder_uid = f.uid AND le.org_id = f.org_id\")",
        "comment_created_at": "2025-06-26T10:05:56+00:00",
        "comment_author": "axelavargas",
        "comment_body": "I will research a different way, btw if you have any examples, let me know",
        "pr_file_module": null
      },
      {
        "comment_id": "2168972955",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106997,
        "pr_file": "pkg/services/libraryelements/database.go",
        "discussion_id": "2167561571",
        "commented_code": "@@ -441,15 +441,29 @@ func (l *LibraryElementService) getAllLibraryElements(c context.Context, signedI\n \tif folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})\n+\tif err != nil {\n+\t\treturn model.LibraryElementSearchResult{}, err\n+\t}\n+\t// Every signed in user can see the general folder. The general folder might have \"general\" or the empty string as its UID.\n+\taccessibleFolderUIDs := make([]string, 0, len(fs)+2)\n+\taccessibleFolderUIDs = append(accessibleFolderUIDs, \"general\", \"\")\n+\tfor _, f := range fs {\n+\t\taccessibleFolderUIDs = append(accessibleFolderUIDs, f.UID)\n+\t}\n+\n \terr = l.SQLStore.WithDbSession(c, func(session *db.Session) error {\n \t\tbuilder := db.NewSqlBuilder(l.Cfg, l.features, l.SQLStore.GetDialect(), recursiveQueriesAreSupported)\n \t\tif folderFilter.includeGeneralFolder {\n \t\t\tbuilder.Write(selectLibraryElementDTOWithMeta)\n \t\t\tbuilder.Write(\", '' as folder_uid \")\n \t\t\tbuilder.Write(getFromLibraryElementDTOWithMeta(l.SQLStore.GetDialect()))\n+\t\t\tbuilder.Write(\" LEFT JOIN folder f ON le.folder_uid = f.uid AND le.org_id = f.org_id\")",
        "comment_created_at": "2025-06-26T12:39:40+00:00",
        "comment_author": "evictorero",
        "comment_body": "This JOIN is only needed to filter by f.title but if `folderService.SearchFolders` already returns folders filtered by permissions and title then you can use the folder uids directly in this query and remove the JOIN.",
        "pr_file_module": null
      },
      {
        "comment_id": "2174604925",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106997,
        "pr_file": "pkg/services/libraryelements/database.go",
        "discussion_id": "2167561571",
        "commented_code": "@@ -441,15 +441,29 @@ func (l *LibraryElementService) getAllLibraryElements(c context.Context, signedI\n \tif folderFilter.parseError != nil {\n \t\treturn model.LibraryElementSearchResult{}, folderFilter.parseError\n \t}\n+\n+\t// Get accessible folder UIDs for secure folder name search\n+\tfs, err := l.folderService.GetFolders(c, folder.GetFoldersQuery{OrgID: signedInUser.GetOrgID(), SignedInUser: signedInUser})\n+\tif err != nil {\n+\t\treturn model.LibraryElementSearchResult{}, err\n+\t}\n+\t// Every signed in user can see the general folder. The general folder might have \"general\" or the empty string as its UID.\n+\taccessibleFolderUIDs := make([]string, 0, len(fs)+2)\n+\taccessibleFolderUIDs = append(accessibleFolderUIDs, \"general\", \"\")\n+\tfor _, f := range fs {\n+\t\taccessibleFolderUIDs = append(accessibleFolderUIDs, f.UID)\n+\t}\n+\n \terr = l.SQLStore.WithDbSession(c, func(session *db.Session) error {\n \t\tbuilder := db.NewSqlBuilder(l.Cfg, l.features, l.SQLStore.GetDialect(), recursiveQueriesAreSupported)\n \t\tif folderFilter.includeGeneralFolder {\n \t\t\tbuilder.Write(selectLibraryElementDTOWithMeta)\n \t\t\tbuilder.Write(\", '' as folder_uid \")\n \t\t\tbuilder.Write(getFromLibraryElementDTOWithMeta(l.SQLStore.GetDialect()))\n+\t\t\tbuilder.Write(\" LEFT JOIN folder f ON le.folder_uid = f.uid AND le.org_id = f.org_id\")",
        "comment_created_at": "2025-06-30T09:12:48+00:00",
        "comment_author": "axelavargas",
        "comment_body": "I made changes using the the `folderService.SearchFolders`, it works as expected! I had to implement some fallback mechanism because that service is behind `KubernetesClientDashboardsFolders`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2175121002",
    "pr_number": 106997,
    "pr_file": "pkg/services/libraryelements/database.go",
    "created_at": "2025-06-30T13:44:45+00:00",
    "commented_code": "builder.Write(selectLibraryElementDTOWithMeta)\n \t\tbuilder.Write(\", le.folder_uid as folder_uid \")\n \t\tbuilder.Write(getFromLibraryElementDTOWithMeta(l.SQLStore.GetDialect()))\n+\t\tbuilder.Write(\" LEFT JOIN folder f ON le.folder_uid = f.uid AND le.org_id = f.org_id\")",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2175121002",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106997,
        "pr_file": "pkg/services/libraryelements/database.go",
        "discussion_id": "2175121002",
        "commented_code": "@@ -459,9 +495,10 @@ func (l *LibraryElementService) getAllLibraryElements(c context.Context, signedI\n \t\tbuilder.Write(selectLibraryElementDTOWithMeta)\n \t\tbuilder.Write(\", le.folder_uid as folder_uid \")\n \t\tbuilder.Write(getFromLibraryElementDTOWithMeta(l.SQLStore.GetDialect()))\n+\t\tbuilder.Write(\" LEFT JOIN folder f ON le.folder_uid = f.uid AND le.org_id = f.org_id\")",
        "comment_created_at": "2025-06-30T13:44:45+00:00",
        "comment_author": "evictorero",
        "comment_body": "This is not needed anymore, we can filter directly by `folder_uid` and `org_id` in the `library_element` table",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1440890072",
    "pr_number": 79953,
    "pr_file": "pkg/services/ngalert/state/manager.go",
    "created_at": "2024-01-03T20:06:44+00:00",
    "commented_code": "statesCount := 0\n \tstates := make(map[int64]map[string]*ruleStates, len(orgIds))\n-\tfor _, orgId := range orgIds {\n-\t\t// Get Rules\n-\t\truleCmd := ngModels.ListAlertRulesQuery{\n-\t\t\tOrgID: orgId,\n-\t\t}\n-\t\talertRules, err := rulesReader.ListAlertRules(ctx, &ruleCmd)\n-\t\tif err != nil {\n-\t\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n-\t\t}\n+\tfor _, orgID := range orgIds {\n+\t\torgStates, count := st.warmOrg(ctx, orgID, rules)\n+\t\tstatesCount += count\n+\t\tstates[orgID] = orgStates\n+\t}\n+\tst.cache.setAllStates(states)\n+\tst.log.Info(\"State cache has been initialized\", \"states\", statesCount, \"duration\", time.Since(startTime))\n+}\n \n-\t\truleByUID := make(map[string]*ngModels.AlertRule, len(alertRules))\n-\t\tfor _, rule := range alertRules {\n-\t\t\truleByUID[rule.UID] = rule\n-\t\t}\n+func (st *Manager) warmOrg(ctx context.Context, orgID int64, rules RuleReader) (map[string]*ruleStates, int) {\n+\t// Get Rules\n+\truleCmd := ngModels.ListAlertRulesQuery{\n+\t\tOrgID: orgID,\n+\t}\n+\talertRules, err := rules.ListAlertRules(ctx, &ruleCmd)\n+\tif err != nil {\n+\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n+\t}\n+\n+\truleByUID := make(map[string]*ngModels.AlertRule, len(alertRules))\n+\tfor _, rule := range alertRules {\n+\t\truleByUID[rule.UID] = rule\n+\t}\n+\n+\tstates := make(map[string]*ruleStates, len(ruleByUID))\n+\tcount := 0\n+\n+\t// Get Instances\n+\tcmd := ngModels.ListAlertInstancesQuery{\n+\t\tRuleOrgID: orgID,\n+\t}\n+\talertInstances, err := st.instanceStore.ListAlertInstances(ctx, &cmd)\n+\tif err != nil {\n+\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n+\t}\n \n-\t\torgStates := make(map[string]*ruleStates, len(ruleByUID))\n-\t\tstates[orgId] = orgStates\n+\torphanedInstances := make([]ngModels.AlertInstanceKey, 0)",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1440890072",
        "repo_full_name": "grafana/grafana",
        "pr_number": 79953,
        "pr_file": "pkg/services/ngalert/state/manager.go",
        "discussion_id": "1440890072",
        "commented_code": "@@ -113,69 +113,97 @@ func (st *Manager) Warm(ctx context.Context, rulesReader RuleReader) {\n \n \tstatesCount := 0\n \tstates := make(map[int64]map[string]*ruleStates, len(orgIds))\n-\tfor _, orgId := range orgIds {\n-\t\t// Get Rules\n-\t\truleCmd := ngModels.ListAlertRulesQuery{\n-\t\t\tOrgID: orgId,\n-\t\t}\n-\t\talertRules, err := rulesReader.ListAlertRules(ctx, &ruleCmd)\n-\t\tif err != nil {\n-\t\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n-\t\t}\n+\tfor _, orgID := range orgIds {\n+\t\torgStates, count := st.warmOrg(ctx, orgID, rules)\n+\t\tstatesCount += count\n+\t\tstates[orgID] = orgStates\n+\t}\n+\tst.cache.setAllStates(states)\n+\tst.log.Info(\"State cache has been initialized\", \"states\", statesCount, \"duration\", time.Since(startTime))\n+}\n \n-\t\truleByUID := make(map[string]*ngModels.AlertRule, len(alertRules))\n-\t\tfor _, rule := range alertRules {\n-\t\t\truleByUID[rule.UID] = rule\n-\t\t}\n+func (st *Manager) warmOrg(ctx context.Context, orgID int64, rules RuleReader) (map[string]*ruleStates, int) {\n+\t// Get Rules\n+\truleCmd := ngModels.ListAlertRulesQuery{\n+\t\tOrgID: orgID,\n+\t}\n+\talertRules, err := rules.ListAlertRules(ctx, &ruleCmd)\n+\tif err != nil {\n+\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n+\t}\n+\n+\truleByUID := make(map[string]*ngModels.AlertRule, len(alertRules))\n+\tfor _, rule := range alertRules {\n+\t\truleByUID[rule.UID] = rule\n+\t}\n+\n+\tstates := make(map[string]*ruleStates, len(ruleByUID))\n+\tcount := 0\n+\n+\t// Get Instances\n+\tcmd := ngModels.ListAlertInstancesQuery{\n+\t\tRuleOrgID: orgID,\n+\t}\n+\talertInstances, err := st.instanceStore.ListAlertInstances(ctx, &cmd)\n+\tif err != nil {\n+\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n+\t}\n \n-\t\torgStates := make(map[string]*ruleStates, len(ruleByUID))\n-\t\tstates[orgId] = orgStates\n+\torphanedInstances := make([]ngModels.AlertInstanceKey, 0)",
        "comment_created_at": "2024-01-03T20:06:44+00:00",
        "comment_author": "grobinson-grafana",
        "comment_body": "Would it not be easier (and perhaps faster too) to do something like this in SQL:\r\n\r\n```\r\nDELETE FROM alert_instance WHERE rule_uid NOT IN (SELECT uid FROM alert_rule)\r\n```\r\n\r\nand then load the remaining instances?",
        "pr_file_module": null
      },
      {
        "comment_id": "1441023802",
        "repo_full_name": "grafana/grafana",
        "pr_number": 79953,
        "pr_file": "pkg/services/ngalert/state/manager.go",
        "discussion_id": "1440890072",
        "commented_code": "@@ -113,69 +113,97 @@ func (st *Manager) Warm(ctx context.Context, rulesReader RuleReader) {\n \n \tstatesCount := 0\n \tstates := make(map[int64]map[string]*ruleStates, len(orgIds))\n-\tfor _, orgId := range orgIds {\n-\t\t// Get Rules\n-\t\truleCmd := ngModels.ListAlertRulesQuery{\n-\t\t\tOrgID: orgId,\n-\t\t}\n-\t\talertRules, err := rulesReader.ListAlertRules(ctx, &ruleCmd)\n-\t\tif err != nil {\n-\t\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n-\t\t}\n+\tfor _, orgID := range orgIds {\n+\t\torgStates, count := st.warmOrg(ctx, orgID, rules)\n+\t\tstatesCount += count\n+\t\tstates[orgID] = orgStates\n+\t}\n+\tst.cache.setAllStates(states)\n+\tst.log.Info(\"State cache has been initialized\", \"states\", statesCount, \"duration\", time.Since(startTime))\n+}\n \n-\t\truleByUID := make(map[string]*ngModels.AlertRule, len(alertRules))\n-\t\tfor _, rule := range alertRules {\n-\t\t\truleByUID[rule.UID] = rule\n-\t\t}\n+func (st *Manager) warmOrg(ctx context.Context, orgID int64, rules RuleReader) (map[string]*ruleStates, int) {\n+\t// Get Rules\n+\truleCmd := ngModels.ListAlertRulesQuery{\n+\t\tOrgID: orgID,\n+\t}\n+\talertRules, err := rules.ListAlertRules(ctx, &ruleCmd)\n+\tif err != nil {\n+\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n+\t}\n+\n+\truleByUID := make(map[string]*ngModels.AlertRule, len(alertRules))\n+\tfor _, rule := range alertRules {\n+\t\truleByUID[rule.UID] = rule\n+\t}\n+\n+\tstates := make(map[string]*ruleStates, len(ruleByUID))\n+\tcount := 0\n+\n+\t// Get Instances\n+\tcmd := ngModels.ListAlertInstancesQuery{\n+\t\tRuleOrgID: orgID,\n+\t}\n+\talertInstances, err := st.instanceStore.ListAlertInstances(ctx, &cmd)\n+\tif err != nil {\n+\t\tst.log.Error(\"Unable to fetch previous state\", \"error\", err)\n+\t}\n \n-\t\torgStates := make(map[string]*ruleStates, len(ruleByUID))\n-\t\tstates[orgId] = orgStates\n+\torphanedInstances := make([]ngModels.AlertInstanceKey, 0)",
        "comment_created_at": "2024-01-03T22:23:17+00:00",
        "comment_author": "alexweav",
        "comment_body": "I moved to a different implementation that's closer to this, IMO we shouldn't do this as part of warm() but in a separate phase that can be invoked on its own.\r\n\r\nI couldn't do this exactly though, since rule UIDs aren't unique, and this needs to work across multiple orgs, so it needs to take the (org, UID) tuple into account rather than just comparing UIDs.\r\n\r\nA multi-column `WHERE NOT IN` statement is not part of the SQL standard, it's an extension, unfortunately. It works in Postgres, but is not guaranteed to work in other databases. Also, crossing tables in one query hurts the abstraction around the stores, by coupling two concrete implementations of different interfaces together.\r\n\r\nI've done the next best thing to this - the new implementation loads only the distinct rule UIDs and orgIDs from the instances, not the whole thing. This query can be answered purely by an index and without a table scan, so it's _much_ faster than the cache warm.",
        "pr_file_module": null
      }
    ]
  }
]