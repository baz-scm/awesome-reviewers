[
  {
    "discussion_id": "2156805617",
    "pr_number": 106983,
    "pr_file": "public/app/plugins/datasource/graphite/datasource.test.ts",
    "created_at": "2025-06-19T11:46:31+00:00",
    "commented_code": "expect(results[0]).toBe('target=' + encodeURIComponent('avg(web01.cpu)'));\n     });\n \n+    it('should not recursively replace queries that reference themselves', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [{ target: 'sumSeries(carbon.test.test-host.cpuUsage, #A)' }],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent('sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A))')\n+      );\n+    });\n+\n+    it('should not recursively replace queries that reference themselves, but will replace nested references', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+        B: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [\n+            {\n+              target: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+            },\n+            {\n+              target: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+            },\n+          ],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent(\n+            'sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A, #B), add(carbon.test.test-host.cpuUsage, 1.5))'",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2156805617",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106983,
        "pr_file": "public/app/plugins/datasource/graphite/datasource.test.ts",
        "discussion_id": "2156805617",
        "commented_code": "@@ -508,6 +508,48 @@ describe('graphiteDatasource', () => {\n       expect(results[0]).toBe('target=' + encodeURIComponent('avg(web01.cpu)'));\n     });\n \n+    it('should not recursively replace queries that reference themselves', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [{ target: 'sumSeries(carbon.test.test-host.cpuUsage, #A)' }],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent('sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A))')\n+      );\n+    });\n+\n+    it('should not recursively replace queries that reference themselves, but will replace nested references', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+        B: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [\n+            {\n+              target: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+            },\n+            {\n+              target: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+            },\n+          ],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent(\n+            'sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A, #B), add(carbon.test.test-host.cpuUsage, 1.5))'",
        "comment_created_at": "2025-06-19T11:46:31+00:00",
        "comment_author": "ivanortegaalba",
        "comment_body": "Should here `#B` be replaced since it doesn't refer to itself?",
        "pr_file_module": null
      },
      {
        "comment_id": "2156841142",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106983,
        "pr_file": "public/app/plugins/datasource/graphite/datasource.test.ts",
        "discussion_id": "2156805617",
        "commented_code": "@@ -508,6 +508,48 @@ describe('graphiteDatasource', () => {\n       expect(results[0]).toBe('target=' + encodeURIComponent('avg(web01.cpu)'));\n     });\n \n+    it('should not recursively replace queries that reference themselves', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [{ target: 'sumSeries(carbon.test.test-host.cpuUsage, #A)' }],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent('sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A))')\n+      );\n+    });\n+\n+    it('should not recursively replace queries that reference themselves, but will replace nested references', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+        B: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [\n+            {\n+              target: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+            },\n+            {\n+              target: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+            },\n+          ],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent(\n+            'sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A, #B), add(carbon.test.test-host.cpuUsage, 1.5))'",
        "comment_created_at": "2025-06-19T11:58:53+00:00",
        "comment_author": "aangelisc",
        "comment_body": "We're avoiding recursion and not running the `nestedSeriesRegexReplacer` which leads to the second series not being replaced.\r\n\r\nFor example, with the following input queries:\r\n\r\n```json\r\n{\r\n    \"A\": \"sumSeries(carbon.agents.7633fdb7fb00-a.cpuUsage, #A, #B)\",\r\n    \"B\": \"add(carbon.agents.7633fdb7fb00-a.cpuUsage, 1.5)\"\r\n}\r\n```\r\n\r\nthe resultant Graphite target will be: `aliasSub(sumSeries(carbon.agents.7633fdb7fb00-a.cpuUsage, aliasSub(sumSeries(carbon.agents.7633fdb7fb00-a.cpuUsage, #A, #B), \"(^.*$)\", \"\\\\1 A\"), add(carbon.agents.7633fdb7fb00-a.cpuUsage, 1.5)), \"(^.*$)\", \"\\\\1 A\")&target=aliasSub(add(carbon.agents.7633fdb7fb00-a.cpuUsage, 1.5), \"(^.*$)\", \"\\\\1 B\")`\r\n\r\nwhich Graphite then evaluates as:\r\n\r\n```json\r\n{\r\n    \"A\": \"sumSeries(carbon.agents.7633fdb7fb00-a.cpuUsage,sumSeries(carbon.agents.7633fdb7fb00-a.cpuUsage),add(carbon.agents.7633fdb7fb00-a.cpuUsage,1))\",\r\n    \"B\": \"add(carbon.agents.7633fdb7fb00-a.cpuUsage,1)\"\r\n}\r\n```\r\n\r\nwhich is a valid query.",
        "pr_file_module": null
      },
      {
        "comment_id": "2156849013",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106983,
        "pr_file": "public/app/plugins/datasource/graphite/datasource.test.ts",
        "discussion_id": "2156805617",
        "commented_code": "@@ -508,6 +508,48 @@ describe('graphiteDatasource', () => {\n       expect(results[0]).toBe('target=' + encodeURIComponent('avg(web01.cpu)'));\n     });\n \n+    it('should not recursively replace queries that reference themselves', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [{ target: 'sumSeries(carbon.test.test-host.cpuUsage, #A)' }],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent('sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A))')\n+      );\n+    });\n+\n+    it('should not recursively replace queries that reference themselves, but will replace nested references', () => {\n+      const originalTargetMap = {\n+        A: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+        B: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+      };\n+      const results = ctx.ds.buildGraphiteParams(\n+        {\n+          targets: [\n+            {\n+              target: 'sumSeries(carbon.test.test-host.cpuUsage, #A, #B)',\n+            },\n+            {\n+              target: 'add(carbon.test.test-host.cpuUsage, 1.5)',\n+            },\n+          ],\n+        },\n+        originalTargetMap\n+      );\n+      expect(results[0]).toBe(\n+        'target=' +\n+          encodeURIComponent(\n+            'sumSeries(carbon.test.test-host.cpuUsage, sumSeries(carbon.test.test-host.cpuUsage, #A, #B), add(carbon.test.test-host.cpuUsage, 1.5))'",
        "comment_created_at": "2025-06-19T12:03:52+00:00",
        "comment_author": "ivanortegaalba",
        "comment_body": "Oh nice! Got it! This is correct! Thanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2167583322",
    "pr_number": 106994,
    "pr_file": "public/app/features/search/service/utils.ts",
    "created_at": "2025-06-25T20:36:30+00:00",
    "commented_code": "return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ * Supports fuzzy search for tags and titles and alphabetical sorting\n+ */\n+export function filterSearchResults(\n+  results: SearchHit[],\n+  query: {\n+    query?: string;\n+    tag?: string[];\n+    sort?: string;\n+  }\n+): SearchHit[] {\n+  let filtered = results;\n+\n+  if ((query.query && query.query.trim() !== '' && query.query !== '*') || (query.tag && query.tag.length > 0)) {\n+    const searchString = query.query || query.tag?.join(',') || '';\n+    const haystack = results.map((hit) => `${hit.title},${hit.tags.join(',')}`);\n+    const indices = fuzzySearch(haystack, searchString);\n+    filtered = indices.map((index) => results[index]);\n+  }\n+\n+  if (query.sort) {\n+    const collator = new Intl.Collator();\n+    filtered = filtered.sort((a, b) => {\n+      if (query.sort === 'alpha-asc') {\n+        return collator.compare(a.title, b.title);\n+      }\n+      if (query.sort === 'alpha-desc') {\n+        return collator.compare(b.title, a.title);\n+      }",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2167583322",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106994,
        "pr_file": "public/app/features/search/service/utils.ts",
        "discussion_id": "2167583322",
        "commented_code": "@@ -161,3 +161,41 @@ export function searchHitsToDashboardSearchHits(searchHits: SearchHit[]): Dashbo\n     return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ * Supports fuzzy search for tags and titles and alphabetical sorting\n+ */\n+export function filterSearchResults(\n+  results: SearchHit[],\n+  query: {\n+    query?: string;\n+    tag?: string[];\n+    sort?: string;\n+  }\n+): SearchHit[] {\n+  let filtered = results;\n+\n+  if ((query.query && query.query.trim() !== '' && query.query !== '*') || (query.tag && query.tag.length > 0)) {\n+    const searchString = query.query || query.tag?.join(',') || '';\n+    const haystack = results.map((hit) => `${hit.title},${hit.tags.join(',')}`);\n+    const indices = fuzzySearch(haystack, searchString);\n+    filtered = indices.map((index) => results[index]);\n+  }\n+\n+  if (query.sort) {\n+    const collator = new Intl.Collator();\n+    filtered = filtered.sort((a, b) => {\n+      if (query.sort === 'alpha-asc') {\n+        return collator.compare(a.title, b.title);\n+      }\n+      if (query.sort === 'alpha-desc') {\n+        return collator.compare(b.title, a.title);\n+      }",
        "comment_created_at": "2025-06-25T20:36:30+00:00",
        "comment_author": "leeoniya",
        "comment_body": "you can pull the `if` out of the hot path, and just use a multiplier determined above this fn.\r\n\r\n```ts\r\nlet mult = query.sort === 'alpha-desc' ? -1 : 1;\r\nfiltered.sort((a, b) => mult * collator.compare(a.title, b.title));\r\n```\r\n\r\ngood on extracting the collator instance, btw :+1: ",
        "pr_file_module": null
      },
      {
        "comment_id": "2167587923",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106994,
        "pr_file": "public/app/features/search/service/utils.ts",
        "discussion_id": "2167583322",
        "commented_code": "@@ -161,3 +161,41 @@ export function searchHitsToDashboardSearchHits(searchHits: SearchHit[]): Dashbo\n     return dashboardHit;\n   });\n }\n+\n+/**\n+ * Filters search results based on query parameters\n+ * This is used when backend filtering is not available (e.g., for deleted dashboards)\n+ * Supports fuzzy search for tags and titles and alphabetical sorting\n+ */\n+export function filterSearchResults(\n+  results: SearchHit[],\n+  query: {\n+    query?: string;\n+    tag?: string[];\n+    sort?: string;\n+  }\n+): SearchHit[] {\n+  let filtered = results;\n+\n+  if ((query.query && query.query.trim() !== '' && query.query !== '*') || (query.tag && query.tag.length > 0)) {\n+    const searchString = query.query || query.tag?.join(',') || '';\n+    const haystack = results.map((hit) => `${hit.title},${hit.tags.join(',')}`);\n+    const indices = fuzzySearch(haystack, searchString);\n+    filtered = indices.map((index) => results[index]);\n+  }\n+\n+  if (query.sort) {\n+    const collator = new Intl.Collator();\n+    filtered = filtered.sort((a, b) => {\n+      if (query.sort === 'alpha-asc') {\n+        return collator.compare(a.title, b.title);\n+      }\n+      if (query.sort === 'alpha-desc') {\n+        return collator.compare(b.title, a.title);\n+      }",
        "comment_created_at": "2025-06-25T20:38:50+00:00",
        "comment_author": "leeoniya",
        "comment_body": "alternatively, you can leave the filtered order. uFuzzy ranks by match quality AND an english collator already :)\r\n\r\nhttps://github.com/leeoniya/uFuzzy/blob/0c8bc57d1c1150307f1a61ce27c4b843bf9a0ee3/src/uFuzzy.mjs#L108",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1507639576",
    "pr_number": 83673,
    "pr_file": "packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.test.ts",
    "created_at": "2024-02-29T14:05:07+00:00",
    "commented_code": "+import { textToDataContainer } from '../FlameGraph/testHelpers';\n+\n+import { createResidualEdges, removeRedundantEdges } from './edgeUtils';\n+import { edgesToString } from './treeTransforms.test';\n+import { GraphEdges, GraphNode, GraphNodes } from './types';\n+\n+describe('createResidualEdges', () => {\n+  it('doesnt create new edge if nothing was deleted', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('doesnt create new edge if its not needed', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['1'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('creates residual edge if we remove middle node', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['4'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(edgesToString(newEdges)).toEqual(['1-3', '2-4', '2-5', '4-5']);\n+    expect(newEdges['2-5']).toMatchObject({ residual: true });\n+  });\n+});\n+\n+describe('removeRedundantEdges', () => {\n+  it('it should remove redundant edges', () => {\n+    // At the start we have graph like this:\n+    //  0   1\n+    //  |\\ /\n+    //  2 3\n+    //  \\ |\n+    //   4\n+\n+    const allSortedNodes: GraphNode[] = [\n+      { label: '0', self: 5, value: 5, parents: [], children: [] },\n+      { label: '1', self: 6, value: 6, parents: [], children: [] },\n+      { label: '2', self: 3, value: 3, parents: [], children: [] },\n+      { label: '3', self: 6, value: 6, parents: [], children: [] },\n+      { label: '4', self: 3, value: 3, parents: [], children: [] },\n+    ];\n+\n+    const edges: GraphEdges = {\n+      '0-2': { from: allSortedNodes[0], to: allSortedNodes[2], weight: 1, residual: false },\n+      '0-3': { from: allSortedNodes[0], to: allSortedNodes[3], weight: 1, residual: false },\n+      '1-3': { from: allSortedNodes[1], to: allSortedNodes[3], weight: 1, residual: false },\n+      '2-4': { from: allSortedNodes[2], to: allSortedNodes[4], weight: 1, residual: false },\n+      '3-4': { from: allSortedNodes[3], to: allSortedNodes[4], weight: 1, residual: false },\n+    };\n+\n+    allSortedNodes[0].children.push(edges['0-2'], edges['0-3']);\n+    allSortedNodes[1].children.push(edges['1-3']);\n+    allSortedNodes[2].parents.push(edges['0-2']);\n+    allSortedNodes[2].children.push(edges['2-4']);\n+    allSortedNodes[3].parents.push(edges['0-3'], edges['1-3']);\n+    allSortedNodes[3].children.push(edges['3-4']);\n+    allSortedNodes[4].parents.push(edges['2-4'], edges['3-4']);\n+\n+    // By trimming we removed 3:\n+    //  0   1\n+    //  |\\ /\n+    //  2 x\n+    //  \\ |\n+    //   4\n+\n+    const keptNodes: GraphNodes = {\n+      0: allSortedNodes[0],\n+      1: allSortedNodes[1],\n+      2: allSortedNodes[2],\n+      4: allSortedNodes[4],\n+    };\n+\n+    // This should then create residual edges:\n+    //  0   1\n+    //  |\\  |\n+    //  2 | |\n+    //  \\ | /\n+    //   \\|/\n+    //    4\n+    // Where 0-4 is redundant while 1-4 is kept. We should also remove any edge referencing the removed 3 node.\n+    edges['0-4'] = { from: allSortedNodes[0], to: allSortedNodes[4], weight: 1, residual: true };\n+    edges['1-4'] = { from: allSortedNodes[1], to: allSortedNodes[4], weight: 1, residual: true };\n+\n+    const newEdges = removeRedundantEdges(allSortedNodes, keptNodes, edges, 0);\n+    expect(edgesToString(newEdges)).toEqual(['0-2', '1-4', '2-4']);",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1507639576",
        "repo_full_name": "grafana/grafana",
        "pr_number": 83673,
        "pr_file": "packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.test.ts",
        "discussion_id": "1507639576",
        "commented_code": "@@ -0,0 +1,125 @@\n+import { textToDataContainer } from '../FlameGraph/testHelpers';\n+\n+import { createResidualEdges, removeRedundantEdges } from './edgeUtils';\n+import { edgesToString } from './treeTransforms.test';\n+import { GraphEdges, GraphNode, GraphNodes } from './types';\n+\n+describe('createResidualEdges', () => {\n+  it('doesnt create new edge if nothing was deleted', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('doesnt create new edge if its not needed', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['1'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('creates residual edge if we remove middle node', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['4'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(edgesToString(newEdges)).toEqual(['1-3', '2-4', '2-5', '4-5']);\n+    expect(newEdges['2-5']).toMatchObject({ residual: true });\n+  });\n+});\n+\n+describe('removeRedundantEdges', () => {\n+  it('it should remove redundant edges', () => {\n+    // At the start we have graph like this:\n+    //  0   1\n+    //  |\\ /\n+    //  2 3\n+    //  \\ |\n+    //   4\n+\n+    const allSortedNodes: GraphNode[] = [\n+      { label: '0', self: 5, value: 5, parents: [], children: [] },\n+      { label: '1', self: 6, value: 6, parents: [], children: [] },\n+      { label: '2', self: 3, value: 3, parents: [], children: [] },\n+      { label: '3', self: 6, value: 6, parents: [], children: [] },\n+      { label: '4', self: 3, value: 3, parents: [], children: [] },\n+    ];\n+\n+    const edges: GraphEdges = {\n+      '0-2': { from: allSortedNodes[0], to: allSortedNodes[2], weight: 1, residual: false },\n+      '0-3': { from: allSortedNodes[0], to: allSortedNodes[3], weight: 1, residual: false },\n+      '1-3': { from: allSortedNodes[1], to: allSortedNodes[3], weight: 1, residual: false },\n+      '2-4': { from: allSortedNodes[2], to: allSortedNodes[4], weight: 1, residual: false },\n+      '3-4': { from: allSortedNodes[3], to: allSortedNodes[4], weight: 1, residual: false },\n+    };\n+\n+    allSortedNodes[0].children.push(edges['0-2'], edges['0-3']);\n+    allSortedNodes[1].children.push(edges['1-3']);\n+    allSortedNodes[2].parents.push(edges['0-2']);\n+    allSortedNodes[2].children.push(edges['2-4']);\n+    allSortedNodes[3].parents.push(edges['0-3'], edges['1-3']);\n+    allSortedNodes[3].children.push(edges['3-4']);\n+    allSortedNodes[4].parents.push(edges['2-4'], edges['3-4']);\n+\n+    // By trimming we removed 3:\n+    //  0   1\n+    //  |\\ /\n+    //  2 x\n+    //  \\ |\n+    //   4\n+\n+    const keptNodes: GraphNodes = {\n+      0: allSortedNodes[0],\n+      1: allSortedNodes[1],\n+      2: allSortedNodes[2],\n+      4: allSortedNodes[4],\n+    };\n+\n+    // This should then create residual edges:\n+    //  0   1\n+    //  |\\  |\n+    //  2 | |\n+    //  \\ | /\n+    //   \\|/\n+    //    4\n+    // Where 0-4 is redundant while 1-4 is kept. We should also remove any edge referencing the removed 3 node.\n+    edges['0-4'] = { from: allSortedNodes[0], to: allSortedNodes[4], weight: 1, residual: true };\n+    edges['1-4'] = { from: allSortedNodes[1], to: allSortedNodes[4], weight: 1, residual: true };\n+\n+    const newEdges = removeRedundantEdges(allSortedNodes, keptNodes, edges, 0);\n+    expect(edgesToString(newEdges)).toEqual(['0-2', '1-4', '2-4']);",
        "comment_created_at": "2024-02-29T14:05:07+00:00",
        "comment_author": "simonswine",
        "comment_body": "The code is producing the, in my eyes, correct result. \r\n\r\nYou want to show that function 0 has called 4 (directly, or with nodes in between that have been removed), rather than add the value of the mesurement to the one were function 0 calls 2 which then calls 4 \r\n\r\n```suggestion\r\n    expect(edgesToString(newEdges)).toEqual(['0-2', '0-4', '1-4', '2-4']);\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1532222194",
        "repo_full_name": "grafana/grafana",
        "pr_number": 83673,
        "pr_file": "packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.test.ts",
        "discussion_id": "1507639576",
        "commented_code": "@@ -0,0 +1,125 @@\n+import { textToDataContainer } from '../FlameGraph/testHelpers';\n+\n+import { createResidualEdges, removeRedundantEdges } from './edgeUtils';\n+import { edgesToString } from './treeTransforms.test';\n+import { GraphEdges, GraphNode, GraphNodes } from './types';\n+\n+describe('createResidualEdges', () => {\n+  it('doesnt create new edge if nothing was deleted', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('doesnt create new edge if its not needed', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['1'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('creates residual edge if we remove middle node', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['4'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(edgesToString(newEdges)).toEqual(['1-3', '2-4', '2-5', '4-5']);\n+    expect(newEdges['2-5']).toMatchObject({ residual: true });\n+  });\n+});\n+\n+describe('removeRedundantEdges', () => {\n+  it('it should remove redundant edges', () => {\n+    // At the start we have graph like this:\n+    //  0   1\n+    //  |\\ /\n+    //  2 3\n+    //  \\ |\n+    //   4\n+\n+    const allSortedNodes: GraphNode[] = [\n+      { label: '0', self: 5, value: 5, parents: [], children: [] },\n+      { label: '1', self: 6, value: 6, parents: [], children: [] },\n+      { label: '2', self: 3, value: 3, parents: [], children: [] },\n+      { label: '3', self: 6, value: 6, parents: [], children: [] },\n+      { label: '4', self: 3, value: 3, parents: [], children: [] },\n+    ];\n+\n+    const edges: GraphEdges = {\n+      '0-2': { from: allSortedNodes[0], to: allSortedNodes[2], weight: 1, residual: false },\n+      '0-3': { from: allSortedNodes[0], to: allSortedNodes[3], weight: 1, residual: false },\n+      '1-3': { from: allSortedNodes[1], to: allSortedNodes[3], weight: 1, residual: false },\n+      '2-4': { from: allSortedNodes[2], to: allSortedNodes[4], weight: 1, residual: false },\n+      '3-4': { from: allSortedNodes[3], to: allSortedNodes[4], weight: 1, residual: false },\n+    };\n+\n+    allSortedNodes[0].children.push(edges['0-2'], edges['0-3']);\n+    allSortedNodes[1].children.push(edges['1-3']);\n+    allSortedNodes[2].parents.push(edges['0-2']);\n+    allSortedNodes[2].children.push(edges['2-4']);\n+    allSortedNodes[3].parents.push(edges['0-3'], edges['1-3']);\n+    allSortedNodes[3].children.push(edges['3-4']);\n+    allSortedNodes[4].parents.push(edges['2-4'], edges['3-4']);\n+\n+    // By trimming we removed 3:\n+    //  0   1\n+    //  |\\ /\n+    //  2 x\n+    //  \\ |\n+    //   4\n+\n+    const keptNodes: GraphNodes = {\n+      0: allSortedNodes[0],\n+      1: allSortedNodes[1],\n+      2: allSortedNodes[2],\n+      4: allSortedNodes[4],\n+    };\n+\n+    // This should then create residual edges:\n+    //  0   1\n+    //  |\\  |\n+    //  2 | |\n+    //  \\ | /\n+    //   \\|/\n+    //    4\n+    // Where 0-4 is redundant while 1-4 is kept. We should also remove any edge referencing the removed 3 node.\n+    edges['0-4'] = { from: allSortedNodes[0], to: allSortedNodes[4], weight: 1, residual: true };\n+    edges['1-4'] = { from: allSortedNodes[1], to: allSortedNodes[4], weight: 1, residual: true };\n+\n+    const newEdges = removeRedundantEdges(allSortedNodes, keptNodes, edges, 0);\n+    expect(edgesToString(newEdges)).toEqual(['0-2', '1-4', '2-4']);",
        "comment_created_at": "2024-03-20T14:48:41+00:00",
        "comment_author": "aocenas",
        "comment_body": "@simonswine I think you are right but I am trying to figure out why this function is written like it is:\r\n```typescript\r\nfunction isRedundantEdge(edge: GraphEdge) {\r\n  const seen: Record<string, boolean> = {};\r\n  const queue = [edge.to];\r\n\r\n  while (queue.length > 0) {\r\n    const node = queue.shift()!;\r\n\r\n    // loop over all edges that go into this node\r\n    for (const parentEdge of node.parents) {\r\n      if (edge === parentEdge || seen[parentEdge.from.label]) {\r\n        // skip if we are looking at the same edge, or we have already seen this parent node\r\n        continue;\r\n      }\r\n\r\n      if (parentEdge.from === edge.from) {\r\n        // we found edge that has the same from - to nodes as the edge we are testing.\r\n        return true;\r\n      }\r\n      seen[parentEdge.from.label] = true;\r\n      queue.push(parentEdge.from);\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n```\r\n\r\nI mean it seems to just check if there is any duplicate edges. Which means edge that has the same `from` and `to` node. Like that seems to be it so it could just check all the parent edges of it's `to` node and check it's `from` node and that's it. I am not sure why it does a traversal with `queue.push(parentEdge.from);`. In case of graph like this:\r\n```\r\n0   1\r\n|\\  |\r\n2 | |\r\n\\ | /\r\n \\|/\r\n  4\r\n```\r\nTesting 2-4 means checking 0-4 and 1-4 which obviously don't have the same nodes but then it goes to node 2 and checks its edges but because we have already seen 0 we skip. That seems unnecessary to me unless I don't understand some other parts of this.",
        "pr_file_module": null
      },
      {
        "comment_id": "1532228690",
        "repo_full_name": "grafana/grafana",
        "pr_number": 83673,
        "pr_file": "packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.test.ts",
        "discussion_id": "1507639576",
        "commented_code": "@@ -0,0 +1,125 @@\n+import { textToDataContainer } from '../FlameGraph/testHelpers';\n+\n+import { createResidualEdges, removeRedundantEdges } from './edgeUtils';\n+import { edgesToString } from './treeTransforms.test';\n+import { GraphEdges, GraphNode, GraphNodes } from './types';\n+\n+describe('createResidualEdges', () => {\n+  it('doesnt create new edge if nothing was deleted', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('doesnt create new edge if its not needed', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['1'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('creates residual edge if we remove middle node', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['4'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(edgesToString(newEdges)).toEqual(['1-3', '2-4', '2-5', '4-5']);\n+    expect(newEdges['2-5']).toMatchObject({ residual: true });\n+  });\n+});\n+\n+describe('removeRedundantEdges', () => {\n+  it('it should remove redundant edges', () => {\n+    // At the start we have graph like this:\n+    //  0   1\n+    //  |\\ /\n+    //  2 3\n+    //  \\ |\n+    //   4\n+\n+    const allSortedNodes: GraphNode[] = [\n+      { label: '0', self: 5, value: 5, parents: [], children: [] },\n+      { label: '1', self: 6, value: 6, parents: [], children: [] },\n+      { label: '2', self: 3, value: 3, parents: [], children: [] },\n+      { label: '3', self: 6, value: 6, parents: [], children: [] },\n+      { label: '4', self: 3, value: 3, parents: [], children: [] },\n+    ];\n+\n+    const edges: GraphEdges = {\n+      '0-2': { from: allSortedNodes[0], to: allSortedNodes[2], weight: 1, residual: false },\n+      '0-3': { from: allSortedNodes[0], to: allSortedNodes[3], weight: 1, residual: false },\n+      '1-3': { from: allSortedNodes[1], to: allSortedNodes[3], weight: 1, residual: false },\n+      '2-4': { from: allSortedNodes[2], to: allSortedNodes[4], weight: 1, residual: false },\n+      '3-4': { from: allSortedNodes[3], to: allSortedNodes[4], weight: 1, residual: false },\n+    };\n+\n+    allSortedNodes[0].children.push(edges['0-2'], edges['0-3']);\n+    allSortedNodes[1].children.push(edges['1-3']);\n+    allSortedNodes[2].parents.push(edges['0-2']);\n+    allSortedNodes[2].children.push(edges['2-4']);\n+    allSortedNodes[3].parents.push(edges['0-3'], edges['1-3']);\n+    allSortedNodes[3].children.push(edges['3-4']);\n+    allSortedNodes[4].parents.push(edges['2-4'], edges['3-4']);\n+\n+    // By trimming we removed 3:\n+    //  0   1\n+    //  |\\ /\n+    //  2 x\n+    //  \\ |\n+    //   4\n+\n+    const keptNodes: GraphNodes = {\n+      0: allSortedNodes[0],\n+      1: allSortedNodes[1],\n+      2: allSortedNodes[2],\n+      4: allSortedNodes[4],\n+    };\n+\n+    // This should then create residual edges:\n+    //  0   1\n+    //  |\\  |\n+    //  2 | |\n+    //  \\ | /\n+    //   \\|/\n+    //    4\n+    // Where 0-4 is redundant while 1-4 is kept. We should also remove any edge referencing the removed 3 node.\n+    edges['0-4'] = { from: allSortedNodes[0], to: allSortedNodes[4], weight: 1, residual: true };\n+    edges['1-4'] = { from: allSortedNodes[1], to: allSortedNodes[4], weight: 1, residual: true };\n+\n+    const newEdges = removeRedundantEdges(allSortedNodes, keptNodes, edges, 0);\n+    expect(edgesToString(newEdges)).toEqual(['0-2', '1-4', '2-4']);",
        "comment_created_at": "2024-03-20T14:52:34+00:00",
        "comment_author": "aocenas",
        "comment_body": "But that should not even happen because we pass only a map of edges where key is `<from>-<to>` and so you cannot even create such duplicates in such map, because you would just rewrite the key. You can have duplicates in the `node.parents` because that is an array but then here we do:\r\nhttps://github.com/grafana/grafana/blob/1ef4d495995ab71d26e78e7632790236e61cb8a2/packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.ts#L104\r\n\r\nSo we find a duplicate in the `node.parents` but then delete the edge in `edges` map where there should not be any duplicates. This does not make sense to me.",
        "pr_file_module": null
      },
      {
        "comment_id": "1532529165",
        "repo_full_name": "grafana/grafana",
        "pr_number": 83673,
        "pr_file": "packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.test.ts",
        "discussion_id": "1507639576",
        "commented_code": "@@ -0,0 +1,125 @@\n+import { textToDataContainer } from '../FlameGraph/testHelpers';\n+\n+import { createResidualEdges, removeRedundantEdges } from './edgeUtils';\n+import { edgesToString } from './treeTransforms.test';\n+import { GraphEdges, GraphNode, GraphNodes } from './types';\n+\n+describe('createResidualEdges', () => {\n+  it('doesnt create new edge if nothing was deleted', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('doesnt create new edge if its not needed', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['1'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('creates residual edge if we remove middle node', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['4'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(edgesToString(newEdges)).toEqual(['1-3', '2-4', '2-5', '4-5']);\n+    expect(newEdges['2-5']).toMatchObject({ residual: true });\n+  });\n+});\n+\n+describe('removeRedundantEdges', () => {\n+  it('it should remove redundant edges', () => {\n+    // At the start we have graph like this:\n+    //  0   1\n+    //  |\\ /\n+    //  2 3\n+    //  \\ |\n+    //   4\n+\n+    const allSortedNodes: GraphNode[] = [\n+      { label: '0', self: 5, value: 5, parents: [], children: [] },\n+      { label: '1', self: 6, value: 6, parents: [], children: [] },\n+      { label: '2', self: 3, value: 3, parents: [], children: [] },\n+      { label: '3', self: 6, value: 6, parents: [], children: [] },\n+      { label: '4', self: 3, value: 3, parents: [], children: [] },\n+    ];\n+\n+    const edges: GraphEdges = {\n+      '0-2': { from: allSortedNodes[0], to: allSortedNodes[2], weight: 1, residual: false },\n+      '0-3': { from: allSortedNodes[0], to: allSortedNodes[3], weight: 1, residual: false },\n+      '1-3': { from: allSortedNodes[1], to: allSortedNodes[3], weight: 1, residual: false },\n+      '2-4': { from: allSortedNodes[2], to: allSortedNodes[4], weight: 1, residual: false },\n+      '3-4': { from: allSortedNodes[3], to: allSortedNodes[4], weight: 1, residual: false },\n+    };\n+\n+    allSortedNodes[0].children.push(edges['0-2'], edges['0-3']);\n+    allSortedNodes[1].children.push(edges['1-3']);\n+    allSortedNodes[2].parents.push(edges['0-2']);\n+    allSortedNodes[2].children.push(edges['2-4']);\n+    allSortedNodes[3].parents.push(edges['0-3'], edges['1-3']);\n+    allSortedNodes[3].children.push(edges['3-4']);\n+    allSortedNodes[4].parents.push(edges['2-4'], edges['3-4']);\n+\n+    // By trimming we removed 3:\n+    //  0   1\n+    //  |\\ /\n+    //  2 x\n+    //  \\ |\n+    //   4\n+\n+    const keptNodes: GraphNodes = {\n+      0: allSortedNodes[0],\n+      1: allSortedNodes[1],\n+      2: allSortedNodes[2],\n+      4: allSortedNodes[4],\n+    };\n+\n+    // This should then create residual edges:\n+    //  0   1\n+    //  |\\  |\n+    //  2 | |\n+    //  \\ | /\n+    //   \\|/\n+    //    4\n+    // Where 0-4 is redundant while 1-4 is kept. We should also remove any edge referencing the removed 3 node.\n+    edges['0-4'] = { from: allSortedNodes[0], to: allSortedNodes[4], weight: 1, residual: true };\n+    edges['1-4'] = { from: allSortedNodes[1], to: allSortedNodes[4], weight: 1, residual: true };\n+\n+    const newEdges = removeRedundantEdges(allSortedNodes, keptNodes, edges, 0);\n+    expect(edgesToString(newEdges)).toEqual(['0-2', '1-4', '2-4']);",
        "comment_created_at": "2024-03-20T17:38:57+00:00",
        "comment_author": "aocenas",
        "comment_body": "Ok it does not actually do that. the code marks nodes it sees except for the current edge nodes so if I have edges `1-2` `1-3` and `3-2`, if I test `1-2` it will be redundant because I can traverse to `1` through `3`. Why doesn't do this in test is this weird part of code:\r\nhttps://github.com/grafana/grafana/blob/1ef4d495995ab71d26e78e7632790236e61cb8a2/packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.ts#L100\r\n\r\nMind that this is a `break` not `continue`. This means if we have one non-residual edge all other edges are skipped and not trimmed. This is dependent on the ordering which is done by weight. Again no idea if this is by design or not. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1532545848",
        "repo_full_name": "grafana/grafana",
        "pr_number": 83673,
        "pr_file": "packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.test.ts",
        "discussion_id": "1507639576",
        "commented_code": "@@ -0,0 +1,125 @@\n+import { textToDataContainer } from '../FlameGraph/testHelpers';\n+\n+import { createResidualEdges, removeRedundantEdges } from './edgeUtils';\n+import { edgesToString } from './treeTransforms.test';\n+import { GraphEdges, GraphNode, GraphNodes } from './types';\n+\n+describe('createResidualEdges', () => {\n+  it('doesnt create new edge if nothing was deleted', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('doesnt create new edge if its not needed', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['1'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(newEdges).toEqual(edges);\n+  });\n+\n+  it('creates residual edge if we remove middle node', () => {\n+    const { root, nodes, edges } = getDefaultGraph();\n+    delete nodes['4'];\n+\n+    const newEdges = createResidualEdges(root, nodes, edges);\n+    expect(edgesToString(newEdges)).toEqual(['1-3', '2-4', '2-5', '4-5']);\n+    expect(newEdges['2-5']).toMatchObject({ residual: true });\n+  });\n+});\n+\n+describe('removeRedundantEdges', () => {\n+  it('it should remove redundant edges', () => {\n+    // At the start we have graph like this:\n+    //  0   1\n+    //  |\\ /\n+    //  2 3\n+    //  \\ |\n+    //   4\n+\n+    const allSortedNodes: GraphNode[] = [\n+      { label: '0', self: 5, value: 5, parents: [], children: [] },\n+      { label: '1', self: 6, value: 6, parents: [], children: [] },\n+      { label: '2', self: 3, value: 3, parents: [], children: [] },\n+      { label: '3', self: 6, value: 6, parents: [], children: [] },\n+      { label: '4', self: 3, value: 3, parents: [], children: [] },\n+    ];\n+\n+    const edges: GraphEdges = {\n+      '0-2': { from: allSortedNodes[0], to: allSortedNodes[2], weight: 1, residual: false },\n+      '0-3': { from: allSortedNodes[0], to: allSortedNodes[3], weight: 1, residual: false },\n+      '1-3': { from: allSortedNodes[1], to: allSortedNodes[3], weight: 1, residual: false },\n+      '2-4': { from: allSortedNodes[2], to: allSortedNodes[4], weight: 1, residual: false },\n+      '3-4': { from: allSortedNodes[3], to: allSortedNodes[4], weight: 1, residual: false },\n+    };\n+\n+    allSortedNodes[0].children.push(edges['0-2'], edges['0-3']);\n+    allSortedNodes[1].children.push(edges['1-3']);\n+    allSortedNodes[2].parents.push(edges['0-2']);\n+    allSortedNodes[2].children.push(edges['2-4']);\n+    allSortedNodes[3].parents.push(edges['0-3'], edges['1-3']);\n+    allSortedNodes[3].children.push(edges['3-4']);\n+    allSortedNodes[4].parents.push(edges['2-4'], edges['3-4']);\n+\n+    // By trimming we removed 3:\n+    //  0   1\n+    //  |\\ /\n+    //  2 x\n+    //  \\ |\n+    //   4\n+\n+    const keptNodes: GraphNodes = {\n+      0: allSortedNodes[0],\n+      1: allSortedNodes[1],\n+      2: allSortedNodes[2],\n+      4: allSortedNodes[4],\n+    };\n+\n+    // This should then create residual edges:\n+    //  0   1\n+    //  |\\  |\n+    //  2 | |\n+    //  \\ | /\n+    //   \\|/\n+    //    4\n+    // Where 0-4 is redundant while 1-4 is kept. We should also remove any edge referencing the removed 3 node.\n+    edges['0-4'] = { from: allSortedNodes[0], to: allSortedNodes[4], weight: 1, residual: true };\n+    edges['1-4'] = { from: allSortedNodes[1], to: allSortedNodes[4], weight: 1, residual: true };\n+\n+    const newEdges = removeRedundantEdges(allSortedNodes, keptNodes, edges, 0);\n+    expect(edgesToString(newEdges)).toEqual(['0-2', '1-4', '2-4']);",
        "comment_created_at": "2024-03-20T17:49:58+00:00",
        "comment_author": "aocenas",
        "comment_body": "When testing on some real world flamegraph it seems to remove a residual edge, that has high weight but then it also trims all the other edges coming from a node because of the weightCutoff here:\r\nhttps://github.com/grafana/grafana/blob/cea33062232ea3764400b9f270ad73bbbe120054/packages/grafana-flamegraph/src/FlameNodeGraph/edgeUtils.ts#L113\r\n\r\nThis leaves the node stranded and again no idea if that makes sense or not.",
        "pr_file_module": null
      }
    ]
  }
]