[
  {
    "discussion_id": "2179724421",
    "pr_number": 106778,
    "pr_file": "public/app/features/alerting/unified/hooks/useAbilities.ts",
    "created_at": "2025-07-02T10:39:18+00:00",
    "commented_code": "}, [abilities, actions]);\n }\n \n-// This hook is being called a lot in different places\n-// In some cases multiple times for ~80 rules (e.g. on the list page)\n-// We need to investigate further if some of these calls are redundant\n-// In the meantime, memoizing the result helps\n+/**\n+ * @deprecated Use {@link useAllRulerRuleAbilities} instead\n+ */\n export function useAllAlertRuleAbilities(rule: CombinedRule): Abilities<AlertRuleAction> {\n-  const rulesSourceName = getRulesSourceName(rule.namespace.rulesSource);\n+  // This hook is being called a lot in different places\n+  // In some cases multiple times for ~80 rules (e.g. on the list page)\n+  // We need to investigate further if some of these calls are redundant\n+  // In the meantime, memoizing the result helps\n+  const groupIdentifierV2 = useMemo(() => groupIdentifier.fromCombinedRule(rule), [rule]);\n+  return useAllRulerRuleAbilities(rule.rulerRule, groupIdentifierV2);\n+}\n \n-  const {\n-    isEditable,\n-    isRemovable,\n-    isRulerAvailable = false,\n-    loading,\n-  } = useIsRuleEditable(rulesSourceName, rule.rulerRule);\n+export function useAllRulerRuleAbilities(\n+  rule: RulerRuleDTO | undefined,\n+  groupIdentifier: RuleGroupIdentifierV2\n+): Abilities<AlertRuleAction> {\n+  const rulesSourceName = getGroupOriginName(groupIdentifier);\n+\n+  const { isEditable, isRemovable, isRulerAvailable = false, loading } = useIsRuleEditable(rulesSourceName, rule);\n   const [_, exportAllowed] = useAlertingAbility(AlertingAction.ExportGrafanaManagedRules);\n-  const canSilence = useCanSilence(rule.rulerRule);\n+  const canSilence = useCanSilence(rule);\n \n   const abilities = useMemo<Abilities<AlertRuleAction>>(() => {\n-    const isProvisioned =\n-      rulerRuleType.grafana.rule(rule.rulerRule) && Boolean(rule.rulerRule.grafana_alert.provenance);\n-    const isFederated = isFederatedRuleGroup(rule.group);\n-    const isGrafanaManagedAlertRule = rulerRuleType.grafana.rule(rule.rulerRule);\n-    const isPluginProvided = isPluginProvidedRule(rule.rulerRule);\n+    const isProvisioned = rulerRuleType.grafana.rule(rule) && Boolean(rule.grafana_alert.provenance);",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2179724421",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106778,
        "pr_file": "public/app/features/alerting/unified/hooks/useAbilities.ts",
        "discussion_id": "2179724421",
        "commented_code": "@@ -211,28 +210,35 @@ export function useRulerRuleAbilities(\n   }, [abilities, actions]);\n }\n \n-// This hook is being called a lot in different places\n-// In some cases multiple times for ~80 rules (e.g. on the list page)\n-// We need to investigate further if some of these calls are redundant\n-// In the meantime, memoizing the result helps\n+/**\n+ * @deprecated Use {@link useAllRulerRuleAbilities} instead\n+ */\n export function useAllAlertRuleAbilities(rule: CombinedRule): Abilities<AlertRuleAction> {\n-  const rulesSourceName = getRulesSourceName(rule.namespace.rulesSource);\n+  // This hook is being called a lot in different places\n+  // In some cases multiple times for ~80 rules (e.g. on the list page)\n+  // We need to investigate further if some of these calls are redundant\n+  // In the meantime, memoizing the result helps\n+  const groupIdentifierV2 = useMemo(() => groupIdentifier.fromCombinedRule(rule), [rule]);\n+  return useAllRulerRuleAbilities(rule.rulerRule, groupIdentifierV2);\n+}\n \n-  const {\n-    isEditable,\n-    isRemovable,\n-    isRulerAvailable = false,\n-    loading,\n-  } = useIsRuleEditable(rulesSourceName, rule.rulerRule);\n+export function useAllRulerRuleAbilities(\n+  rule: RulerRuleDTO | undefined,\n+  groupIdentifier: RuleGroupIdentifierV2\n+): Abilities<AlertRuleAction> {\n+  const rulesSourceName = getGroupOriginName(groupIdentifier);\n+\n+  const { isEditable, isRemovable, isRulerAvailable = false, loading } = useIsRuleEditable(rulesSourceName, rule);\n   const [_, exportAllowed] = useAlertingAbility(AlertingAction.ExportGrafanaManagedRules);\n-  const canSilence = useCanSilence(rule.rulerRule);\n+  const canSilence = useCanSilence(rule);\n \n   const abilities = useMemo<Abilities<AlertRuleAction>>(() => {\n-    const isProvisioned =\n-      rulerRuleType.grafana.rule(rule.rulerRule) && Boolean(rule.rulerRule.grafana_alert.provenance);\n-    const isFederated = isFederatedRuleGroup(rule.group);\n-    const isGrafanaManagedAlertRule = rulerRuleType.grafana.rule(rule.rulerRule);\n-    const isPluginProvided = isPluginProvidedRule(rule.rulerRule);\n+    const isProvisioned = rulerRuleType.grafana.rule(rule) && Boolean(rule.grafana_alert.provenance);",
        "comment_created_at": "2025-07-02T10:39:18+00:00",
        "comment_author": "gillesdemey",
        "comment_body": "nit: I think we can use `rule ? isProvisionedRule(rule) : false` here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2182620785",
    "pr_number": 107569,
    "pr_file": "packages/grafana-prometheus/src/language_provider.ts",
    "created_at": "2025-07-03T12:07:39+00:00",
    "commented_code": "return params;\n   }, []);\n \n-  return metrics.length === 0 ? MATCH_ALL_LABELS_STR : `__name__=~\"${metrics.join('|')}\"`;\n+  return metrics.length === 0 ? [] : [`__name__=~\"${metrics.join('|')}\"`];",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2182620785",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107569,
        "pr_file": "packages/grafana-prometheus/src/language_provider.ts",
        "discussion_id": "2182620785",
        "commented_code": "@@ -818,5 +818,5 @@ export const populateMatchParamsFromQueries = (queries?: PromQuery[]): string =>\n     return params;\n   }, []);\n \n-  return metrics.length === 0 ? MATCH_ALL_LABELS_STR : `__name__=~\"${metrics.join('|')}\"`;\n+  return metrics.length === 0 ? [] : [`__name__=~\"${metrics.join('|')}\"`];",
        "comment_created_at": "2025-07-03T12:07:39+00:00",
        "comment_author": "zoltanbedi",
        "comment_body": "Why is it needed to change the return type to array?",
        "pr_file_module": null
      },
      {
        "comment_id": "2182642300",
        "repo_full_name": "grafana/grafana",
        "pr_number": 107569,
        "pr_file": "packages/grafana-prometheus/src/language_provider.ts",
        "discussion_id": "2182620785",
        "commented_code": "@@ -818,5 +818,5 @@ export const populateMatchParamsFromQueries = (queries?: PromQuery[]): string =>\n     return params;\n   }, []);\n \n-  return metrics.length === 0 ? MATCH_ALL_LABELS_STR : `__name__=~\"${metrics.join('|')}\"`;\n+  return metrics.length === 0 ? [] : [`__name__=~\"${metrics.join('|')}\"`];",
        "comment_created_at": "2025-07-03T12:19:06+00:00",
        "comment_author": "itsmylife",
        "comment_body": "I use this in datasource.ts `extractResourceMatcher`. It just makes easy to handle. Otherwise I need to return `undefined`. Handling `undefined` is a bit more tedious. That's why I prefered this way. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2168196273",
    "pr_number": 106926,
    "pr_file": "public/app/core/components/NestedFolderPicker/useFoldersQueryV2.ts",
    "created_at": "2025-06-26T06:00:49+00:00",
    "commented_code": "+import { createSelector } from '@reduxjs/toolkit';\n+import { QueryStatus } from '@reduxjs/toolkit/query';\n+import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n+\n+import { folderAPIv1beta1 } from 'app/api/clients/folder/v1beta1';\n+import { DashboardViewItemWithUIItems, DashboardsTreeItem } from 'app/features/browse-dashboards/types';\n+import { useDispatch, useSelector } from 'app/types/store';\n+\n+import { ManagerKind } from '../../../features/apiserver/types';\n+import { PAGE_SIZE } from '../../../features/browse-dashboards/api/services';\n+import { getPaginationPlaceholders } from '../../../features/browse-dashboards/state/utils';\n+\n+import { ROOT_FOLDER_ITEM } from './utils';\n+\n+type GetFolderChildrenQuery = ReturnType<ReturnType<typeof folderAPIv1beta1.endpoints.getFolderChildren.select>>;\n+type GetFolderChildrenRequest = {\n+  unsubscribe: () => void;\n+};\n+\n+const rootFolderToken = 'general';\n+const collator = new Intl.Collator();\n+\n+/**\n+ * Returns a loaded folder hierarchy as a flat list and a function to load folders.\n+ * This version uses the getFolderChildren API from the folder v1beta1 API. Compared to legacy API, the v1beta1 API\n+ * does not have pagination at the moment.\n+ */\n+export function useFoldersQueryV2(isBrowsing: boolean, openFolders: Record<string, boolean>) {\n+  const dispatch = useDispatch();\n+\n+  // Keep a list of all request subscriptions so we can unsubscribe from them when the component is unmounted\n+  const requestsRef = useRef<GetFolderChildrenRequest[]>([]);\n+\n+  // Keep a list of selectors for dynamic state selection\n+  const [selectors, setSelectors] = useState<\n+    Array<ReturnType<typeof folderAPIv1beta1.endpoints.getFolderChildren.select>>\n+  >([]);\n+\n+  // This is an aggregated dynamic selector of all the selectors for all the request issued while loading the folder\n+  // tree and returns the whole tree that was loaded so far.\n+  const listAllFoldersSelector = useMemo(() => {\n+    return createSelector(selectors, (...responses) => {\n+      // Returns loading true if any of the responses is still loading\n+      let isLoading = false;\n+\n+      const responseByParent: Record<string, GetFolderChildrenQuery> = {};\n+\n+      for (const response of responses) {\n+        if (response.status === QueryStatus.pending) {\n+          isLoading = true;\n+        }\n+\n+        const parentName = response.originalArgs?.name;\n+        if (parentName) {\n+          responseByParent[parentName] = response;\n+        }\n+      }\n+\n+      return {\n+        isLoading,\n+        responseByParent,\n+      };\n+    });\n+  }, [selectors]);\n+\n+  const state = useSelector(listAllFoldersSelector);\n+\n+  // Loads folders for the given parent UID\n+  const requestNextPage = useCallback(\n+    (parentUid: string | undefined) => {\n+      const finalParentUid = parentUid ?? rootFolderToken;\n+      const response = state.responseByParent[finalParentUid];\n+      const isLoading = response?.status === QueryStatus.pending;\n+\n+      // If already loading, don't request again\n+      if (isLoading) {\n+        return;\n+      }\n+\n+      const args = { name: finalParentUid };\n+\n+      // Make a request\n+      const subscription = dispatch(folderAPIv1beta1.endpoints.getFolderChildren.initiate(args));\n+\n+      // Add selector for the response to the list so we can then have an aggregated selector for all the folders\n+      const selector = folderAPIv1beta1.endpoints.getFolderChildren.select(args);\n+      setSelectors((selectors) => selectors.concat(selector));\n+\n+      // the subscriptions are saved in a ref so they can be unsubscribed on unmount\n+      requestsRef.current = requestsRef.current.concat([subscription]);\n+    },\n+    [state, dispatch]\n+  );\n+\n+  // Unsubscribe from all requests when the component is unmounted\n+  useEffect(() => {\n+    return () => {\n+      for (const req of requestsRef.current) {\n+        req.unsubscribe();\n+      }\n+    };\n+  }, []);\n+\n+  // Convert the individual responses into a flat list of folders, with level indicating\n+  // the depth in the hierarchy.\n+  const treeList = useMemo(() => {\n+    if (!isBrowsing) {\n+      return [];\n+    }\n+\n+    function createFlatList(\n+      parentUid: string | undefined,\n+      response: GetFolderChildrenQuery | undefined,\n+      level: number\n+    ): Array<DashboardsTreeItem<DashboardViewItemWithUIItems>> {\n+      let folders = response?.data?.items ? [...response.data.items] : [];\n+      folders.sort((a, b) => collator.compare(a.spec.title, b.spec.title));\n+\n+      const list = folders.flatMap((item) => {\n+        const name = item.metadata.name!;\n+        const folderIsOpen = openFolders[name];\n+        const flatItem: DashboardsTreeItem<DashboardViewItemWithUIItems> = {\n+          isOpen: Boolean(folderIsOpen),\n+          level: level,\n+          item: {\n+            kind: 'folder' as const,\n+            title: item.spec.title,\n+            // We use resource name as UID because well, not sure what metadata.uid would be used for now as you cannot\n+            // query by it.\n+            uid: name,\n+            // Extract managedBy from annotations if available\n+            managedBy: ManagerKind[item.metadata.annotations?.['grafana.com/managed-by'] as keyof typeof ManagerKind],",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "2168196273",
        "repo_full_name": "grafana/grafana",
        "pr_number": 106926,
        "pr_file": "public/app/core/components/NestedFolderPicker/useFoldersQueryV2.ts",
        "discussion_id": "2168196273",
        "commented_code": "@@ -0,0 +1,164 @@\n+import { createSelector } from '@reduxjs/toolkit';\n+import { QueryStatus } from '@reduxjs/toolkit/query';\n+import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n+\n+import { folderAPIv1beta1 } from 'app/api/clients/folder/v1beta1';\n+import { DashboardViewItemWithUIItems, DashboardsTreeItem } from 'app/features/browse-dashboards/types';\n+import { useDispatch, useSelector } from 'app/types/store';\n+\n+import { ManagerKind } from '../../../features/apiserver/types';\n+import { PAGE_SIZE } from '../../../features/browse-dashboards/api/services';\n+import { getPaginationPlaceholders } from '../../../features/browse-dashboards/state/utils';\n+\n+import { ROOT_FOLDER_ITEM } from './utils';\n+\n+type GetFolderChildrenQuery = ReturnType<ReturnType<typeof folderAPIv1beta1.endpoints.getFolderChildren.select>>;\n+type GetFolderChildrenRequest = {\n+  unsubscribe: () => void;\n+};\n+\n+const rootFolderToken = 'general';\n+const collator = new Intl.Collator();\n+\n+/**\n+ * Returns a loaded folder hierarchy as a flat list and a function to load folders.\n+ * This version uses the getFolderChildren API from the folder v1beta1 API. Compared to legacy API, the v1beta1 API\n+ * does not have pagination at the moment.\n+ */\n+export function useFoldersQueryV2(isBrowsing: boolean, openFolders: Record<string, boolean>) {\n+  const dispatch = useDispatch();\n+\n+  // Keep a list of all request subscriptions so we can unsubscribe from them when the component is unmounted\n+  const requestsRef = useRef<GetFolderChildrenRequest[]>([]);\n+\n+  // Keep a list of selectors for dynamic state selection\n+  const [selectors, setSelectors] = useState<\n+    Array<ReturnType<typeof folderAPIv1beta1.endpoints.getFolderChildren.select>>\n+  >([]);\n+\n+  // This is an aggregated dynamic selector of all the selectors for all the request issued while loading the folder\n+  // tree and returns the whole tree that was loaded so far.\n+  const listAllFoldersSelector = useMemo(() => {\n+    return createSelector(selectors, (...responses) => {\n+      // Returns loading true if any of the responses is still loading\n+      let isLoading = false;\n+\n+      const responseByParent: Record<string, GetFolderChildrenQuery> = {};\n+\n+      for (const response of responses) {\n+        if (response.status === QueryStatus.pending) {\n+          isLoading = true;\n+        }\n+\n+        const parentName = response.originalArgs?.name;\n+        if (parentName) {\n+          responseByParent[parentName] = response;\n+        }\n+      }\n+\n+      return {\n+        isLoading,\n+        responseByParent,\n+      };\n+    });\n+  }, [selectors]);\n+\n+  const state = useSelector(listAllFoldersSelector);\n+\n+  // Loads folders for the given parent UID\n+  const requestNextPage = useCallback(\n+    (parentUid: string | undefined) => {\n+      const finalParentUid = parentUid ?? rootFolderToken;\n+      const response = state.responseByParent[finalParentUid];\n+      const isLoading = response?.status === QueryStatus.pending;\n+\n+      // If already loading, don't request again\n+      if (isLoading) {\n+        return;\n+      }\n+\n+      const args = { name: finalParentUid };\n+\n+      // Make a request\n+      const subscription = dispatch(folderAPIv1beta1.endpoints.getFolderChildren.initiate(args));\n+\n+      // Add selector for the response to the list so we can then have an aggregated selector for all the folders\n+      const selector = folderAPIv1beta1.endpoints.getFolderChildren.select(args);\n+      setSelectors((selectors) => selectors.concat(selector));\n+\n+      // the subscriptions are saved in a ref so they can be unsubscribed on unmount\n+      requestsRef.current = requestsRef.current.concat([subscription]);\n+    },\n+    [state, dispatch]\n+  );\n+\n+  // Unsubscribe from all requests when the component is unmounted\n+  useEffect(() => {\n+    return () => {\n+      for (const req of requestsRef.current) {\n+        req.unsubscribe();\n+      }\n+    };\n+  }, []);\n+\n+  // Convert the individual responses into a flat list of folders, with level indicating\n+  // the depth in the hierarchy.\n+  const treeList = useMemo(() => {\n+    if (!isBrowsing) {\n+      return [];\n+    }\n+\n+    function createFlatList(\n+      parentUid: string | undefined,\n+      response: GetFolderChildrenQuery | undefined,\n+      level: number\n+    ): Array<DashboardsTreeItem<DashboardViewItemWithUIItems>> {\n+      let folders = response?.data?.items ? [...response.data.items] : [];\n+      folders.sort((a, b) => collator.compare(a.spec.title, b.spec.title));\n+\n+      const list = folders.flatMap((item) => {\n+        const name = item.metadata.name!;\n+        const folderIsOpen = openFolders[name];\n+        const flatItem: DashboardsTreeItem<DashboardViewItemWithUIItems> = {\n+          isOpen: Boolean(folderIsOpen),\n+          level: level,\n+          item: {\n+            kind: 'folder' as const,\n+            title: item.spec.title,\n+            // We use resource name as UID because well, not sure what metadata.uid would be used for now as you cannot\n+            // query by it.\n+            uid: name,\n+            // Extract managedBy from annotations if available\n+            managedBy: ManagerKind[item.metadata.annotations?.['grafana.com/managed-by'] as keyof typeof ManagerKind],",
        "comment_created_at": "2025-06-26T06:00:49+00:00",
        "comment_author": "Clarity-89",
        "comment_body": "```suggestion\r\n            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\r\n            managedBy: item.metadata?.annotations?.[AnnoKeyManagerKind] as ManagerKind | undefined,\r\n```\r\n\r\nI think we'd need to extract all the annotations since we'll need them in a few places. To keep the shapes backwards compatible I suggest adding an optional `metadata` prop to folders with the resource's metadata. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1647133241",
    "pr_number": 87954,
    "pr_file": "public/app/features/alerting/unified/components/export/providers.ts",
    "created_at": "2024-06-20T07:57:07+00:00",
    "commented_code": "type: 'terraform',\n };\n \n+export const OperatorExportProvider: ExportProvider<'operator'> = {\n+  name: 'Grafana Operator',\n+  exportFormat: 'operator',\n+  overrideLanguage: 'yaml',\n+  type: 'operator',\n+  supports: ['AlertRuleGroup', 'AlertRule', 'Receiver', 'RuleFolder'],\n+  formatter: (raw: string) => {\n+    const out: any[] = [];\n+    const parsed = loadAll(raw) as Array<{ kind: string }>;",
    "repo_full_name": "grafana/grafana",
    "discussion_comments": [
      {
        "comment_id": "1647133241",
        "repo_full_name": "grafana/grafana",
        "pr_number": 87954,
        "pr_file": "public/app/features/alerting/unified/components/export/providers.ts",
        "discussion_id": "1647133241",
        "commented_code": "@@ -32,12 +43,51 @@ export const HclExportProvider: ExportProvider<'hcl'> = {\n   type: 'terraform',\n };\n \n+export const OperatorExportProvider: ExportProvider<'operator'> = {\n+  name: 'Grafana Operator',\n+  exportFormat: 'operator',\n+  overrideLanguage: 'yaml',\n+  type: 'operator',\n+  supports: ['AlertRuleGroup', 'AlertRule', 'Receiver', 'RuleFolder'],\n+  formatter: (raw: string) => {\n+    const out: any[] = [];\n+    const parsed = loadAll(raw) as Array<{ kind: string }>;",
        "comment_created_at": "2024-06-20T07:57:07+00:00",
        "comment_author": "dcharbonnier",
        "comment_body": "```suggestion\r\n    const parsed = loadAll(raw) as Array<Record<string, unknown> & { kind: string }>;\r\n```",
        "pr_file_module": null
      }
    ]
  }
]