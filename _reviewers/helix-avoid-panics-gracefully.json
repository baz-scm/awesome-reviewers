[
  {
    "discussion_id": "1710187717",
    "pr_number": 11411,
    "pr_file": "helix-term/src/commands.rs",
    "created_at": "2024-08-08T19:49:48+00:00",
    "commented_code": "doc.apply(&transaction, view.id);\n     }\n \n+    pub fn insert_char_interactive(cx: &mut Context) {\n+        let count = cx.count();\n+\n+        // need to wait for next key\n+        cx.on_next_key(move |cx, event| {\n+            match event {\n+                KeyEvent {\n+                    code: KeyCode::Char(ch),\n+                    ..\n+                } => {\n+                    for _ in 0..count {\n+                        insert::insert_char(cx, ch)\n+                    }\n+                }\n+                KeyEvent {\n+                    code: KeyCode::Enter,\n+                    ..\n+                } => {\n+                    assert!(count == 1, \"inserting multiple newlines not yet supported\");",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1710187717",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11411,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1710187717",
        "commented_code": "@@ -3815,6 +3820,35 @@ pub mod insert {\n         doc.apply(&transaction, view.id);\n     }\n \n+    pub fn insert_char_interactive(cx: &mut Context) {\n+        let count = cx.count();\n+\n+        // need to wait for next key\n+        cx.on_next_key(move |cx, event| {\n+            match event {\n+                KeyEvent {\n+                    code: KeyCode::Char(ch),\n+                    ..\n+                } => {\n+                    for _ in 0..count {\n+                        insert::insert_char(cx, ch)\n+                    }\n+                }\n+                KeyEvent {\n+                    code: KeyCode::Enter,\n+                    ..\n+                } => {\n+                    assert!(count == 1, \"inserting multiple newlines not yet supported\");",
        "comment_created_at": "2024-08-08T19:49:48+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "Rather than a panic you can set an error in the statusline:\r\n\r\n```rust\r\nif count != 1 {\r\n    cx.editor.set_error(\"inserting multiple newlines not yet supported\");\r\n}\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1710403263",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11411,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1710187717",
        "commented_code": "@@ -3815,6 +3820,35 @@ pub mod insert {\n         doc.apply(&transaction, view.id);\n     }\n \n+    pub fn insert_char_interactive(cx: &mut Context) {\n+        let count = cx.count();\n+\n+        // need to wait for next key\n+        cx.on_next_key(move |cx, event| {\n+            match event {\n+                KeyEvent {\n+                    code: KeyCode::Char(ch),\n+                    ..\n+                } => {\n+                    for _ in 0..count {\n+                        insert::insert_char(cx, ch)\n+                    }\n+                }\n+                KeyEvent {\n+                    code: KeyCode::Enter,\n+                    ..\n+                } => {\n+                    assert!(count == 1, \"inserting multiple newlines not yet supported\");",
        "comment_created_at": "2024-08-08T23:03:30+00:00",
        "comment_author": "jyn514",
        "comment_body": "oh that's much better yes, thank you!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1157844696",
    "pr_number": 2507,
    "pr_file": "helix-term/src/ui/completion.rs",
    "created_at": "2023-04-04T22:57:10+00:00",
    "commented_code": "// always present here\n                     let item = item.unwrap();\n \n+                    let offset_encoding = editor\n+                        .language_servers\n+                        .get_by_id(item.language_server_id)\n+                        .expect(\"language server disappeared between completion request and application\")",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1157844696",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-term/src/ui/completion.rs",
        "discussion_id": "1157844696",
        "commented_code": "@@ -224,6 +226,12 @@ impl Completion {\n                     // always present here\n                     let item = item.unwrap();\n \n+                    let offset_encoding = editor\n+                        .language_servers\n+                        .get_by_id(item.language_server_id)\n+                        .expect(\"language server disappeared between completion request and application\")",
        "comment_created_at": "2023-04-04T22:57:10+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "interesting this could feasibly happen tough if we request completions and then do `:lsp-restart` before the completion menu shows up. A bit of an edgecase but we probably shoiuldn't panic and fail a bit more graciously with an error. A match setting an error should be good enough. Ideallt we would close the completion menu but we don't have to.",
        "pr_file_module": null
      },
      {
        "comment_id": "1158859965",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-term/src/ui/completion.rs",
        "discussion_id": "1157844696",
        "commented_code": "@@ -224,6 +226,12 @@ impl Completion {\n                     // always present here\n                     let item = item.unwrap();\n \n+                    let offset_encoding = editor\n+                        .language_servers\n+                        .get_by_id(item.language_server_id)\n+                        .expect(\"language server disappeared between completion request and application\")",
        "comment_created_at": "2023-04-05T18:16:34+00:00",
        "comment_author": "Philipp-M",
        "comment_body": "I've refactored it a little bit with a macro that exits this function early in https://github.com/helix-editor/helix/pull/2507/commits/fb4cea53d76c6007ef25d1f458e812259fd95a6e. Better would indeed be closing the completion menu, but it's not completely trivial, as we need access to the compositor (which we have not...), so because it's such an edge_case, I just added a `TODO`",
        "pr_file_module": null
      },
      {
        "comment_id": "1158893239",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-term/src/ui/completion.rs",
        "discussion_id": "1157844696",
        "commented_code": "@@ -224,6 +226,12 @@ impl Completion {\n                     // always present here\n                     let item = item.unwrap();\n \n+                    let offset_encoding = editor\n+                        .language_servers\n+                        .get_by_id(item.language_server_id)\n+                        .expect(\"language server disappeared between completion request and application\")",
        "comment_created_at": "2023-04-05T18:47:17+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "yeah that's fair enough for now I will likely do significant changes to the life cycle of the completion menu in the future anyway so as long as we are not panicking that's good enough for now :+1: ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2021622201",
    "pr_number": 13242,
    "pr_file": "helix-term/src/ui/mod.rs",
    "created_at": "2025-03-31T19:06:48+00:00",
    "commented_code": "type FilePicker = Picker<PathBuf, FilePickerData>;\n \n pub fn file_picker(editor: &Editor, root: PathBuf) -> FilePicker {\n+    let roots = vec![root];\n+    file_picker_multiple_roots(editor, roots)\n+}\n+\n+fn longest_common_prefix(paths: &[PathBuf]) -> PathBuf {\n+    if paths.is_empty() {\n+        panic!(\"Got empty paths list\")\n+    }\n+    // Optimize common case.\n+    if paths.len() == 1 {\n+        return paths[0].clone();\n+    }\n+    let mut num_common_components = 0;\n+    let first_path_components = paths[0].components();\n+    // Store path component references in a Vec so we can iterate it multiple times.\n+    let mut all_paths_components: Vec<_> = paths[1..].iter().map(|p| p.components()).collect();\n+    'components: for first_path_component in first_path_components {\n+        for components in &mut all_paths_components {\n+            let component = components.next();\n+            if component.is_none() || component.is_some_and(|c| c != first_path_component) {\n+                break 'components;\n+            }\n+        }\n+        // All paths matched in this component.\n+        num_common_components += 1;\n+    }\n+\n+    paths[0].components().take(num_common_components).collect()\n+}\n+\n+pub fn file_picker_multiple_roots(editor: &Editor, roots: Vec<PathBuf>) -> FilePicker {\n+    if roots.is_empty() {\n+        panic!(\"Expected non-empty argument roots.\")",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2021622201",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13242,
        "pr_file": "helix-term/src/ui/mod.rs",
        "discussion_id": "2021622201",
        "commented_code": "@@ -193,21 +193,55 @@ pub struct FilePickerData {\n type FilePicker = Picker<PathBuf, FilePickerData>;\n \n pub fn file_picker(editor: &Editor, root: PathBuf) -> FilePicker {\n+    let roots = vec![root];\n+    file_picker_multiple_roots(editor, roots)\n+}\n+\n+fn longest_common_prefix(paths: &[PathBuf]) -> PathBuf {\n+    if paths.is_empty() {\n+        panic!(\"Got empty paths list\")\n+    }\n+    // Optimize common case.\n+    if paths.len() == 1 {\n+        return paths[0].clone();\n+    }\n+    let mut num_common_components = 0;\n+    let first_path_components = paths[0].components();\n+    // Store path component references in a Vec so we can iterate it multiple times.\n+    let mut all_paths_components: Vec<_> = paths[1..].iter().map(|p| p.components()).collect();\n+    'components: for first_path_component in first_path_components {\n+        for components in &mut all_paths_components {\n+            let component = components.next();\n+            if component.is_none() || component.is_some_and(|c| c != first_path_component) {\n+                break 'components;\n+            }\n+        }\n+        // All paths matched in this component.\n+        num_common_components += 1;\n+    }\n+\n+    paths[0].components().take(num_common_components).collect()\n+}\n+\n+pub fn file_picker_multiple_roots(editor: &Editor, roots: Vec<PathBuf>) -> FilePicker {\n+    if roots.is_empty() {\n+        panic!(\"Expected non-empty argument roots.\")",
        "comment_created_at": "2025-03-31T19:06:48+00:00",
        "comment_author": "nik-rev",
        "comment_body": "it would be better if this added an error to the status line instead of crashing",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2160365474",
    "pr_number": 13403,
    "pr_file": "helix-view/src/handlers/dap.rs",
    "created_at": "2025-06-22T14:27:42+00:00",
    "commented_code": "shell_process_id: None,\n                         }))\n                     }\n+                    Ok(Request::StartDebugging(arguments)) => {\n+                        let debugger = match self.dap_servers.get_client_mut(id) {\n+                            Some(debugger) => debugger,\n+                            None => {\n+                                self.set_error(\"No active debugger found.\");\n+                                return true;\n+                            }\n+                        };\n+                        // Currently we only support starting a child debugger if the parent is using the TCP transport\n+                        let socket = match debugger.socket {\n+                            Some(socket) => socket,\n+                            None => {\n+                                self.set_error(\"Child debugger can only be started if the parent debugger is using TCP transport.\");\n+                                return true;\n+                            }\n+                        };\n+\n+                        let config = debugger.config.clone();\n+\n+                        let result = self\n+                            .dap_servers\n+                            .start_client(Some(socket), &config.expect(\"No config found\"));",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2160365474",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13403,
        "pr_file": "helix-view/src/handlers/dap.rs",
        "discussion_id": "2160365474",
        "commented_code": "@@ -393,10 +438,66 @@ impl Editor {\n                             shell_process_id: None,\n                         }))\n                     }\n+                    Ok(Request::StartDebugging(arguments)) => {\n+                        let debugger = match self.dap_servers.get_client_mut(id) {\n+                            Some(debugger) => debugger,\n+                            None => {\n+                                self.set_error(\"No active debugger found.\");\n+                                return true;\n+                            }\n+                        };\n+                        // Currently we only support starting a child debugger if the parent is using the TCP transport\n+                        let socket = match debugger.socket {\n+                            Some(socket) => socket,\n+                            None => {\n+                                self.set_error(\"Child debugger can only be started if the parent debugger is using TCP transport.\");\n+                                return true;\n+                            }\n+                        };\n+\n+                        let config = debugger.config.clone();\n+\n+                        let result = self\n+                            .dap_servers\n+                            .start_client(Some(socket), &config.expect(\"No config found\"));",
        "comment_created_at": "2025-06-22T14:27:42+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "Instead of an `expect` let's `log::error!` when the config isn't set and `return true`",
        "pr_file_module": null
      }
    ]
  }
]