[
  {
    "discussion_id": "2147321400",
    "pr_number": 13743,
    "pr_file": "helix-stdx/src/rope.rs",
    "created_at": "2025-06-14T20:58:23+00:00",
    "commented_code": "/// let graphemes: Vec<_> = text.graphemes_rev().collect();\n     /// assert_eq!(graphemes.as_slice(), &[\"\ud83d\uddbc\ufe0f\", \"\ud83c\udff4\u200d\u2620\ufe0f\", \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\"]);\n     /// ```\n-    fn graphemes_rev(self) -> RevRopeGraphemes<'a>;\n+    fn graphemes_rev(self) -> RopeGraphemes<'a>;\n+    /// Returns an iterator over the grapheme clusters in the slice at the given byte index.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use ropey::Rope;\n+    /// # use helix_stdx::rope::RopeSliceExt;\n+    /// let text = Rope::from_str(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\ud83c\udff4\u200d\u2620\ufe0f\ud83d\uddbc\ufe0f\");\n+    /// // 14 is the byte index of the pirate flag's starting cluster boundary.\n+    /// let graphemes: Vec<_> = text.slice(..).graphemes_at(14).collect();\n+    /// assert_eq!(graphemes.as_slice(), &[\"\ud83c\udff4\u200d\u2620\ufe0f\", \"\ud83d\uddbc\ufe0f\"]);\n+    /// // 27 is the byte index of the pirate flag's ending cluster boundary.\n+    /// let graphemes: Vec<_> = text.slice(..).graphemes_at(27).reversed().collect();\n+    /// assert_eq!(graphemes.as_slice(), &[\"\ud83c\udff4\u200d\u2620\ufe0f\", \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\"]);\n+    /// ```\n+    fn graphemes_at(self, byte_idx: usize) -> RopeGraphemes<'a>;\n+    /// Returns an iterator over the grapheme clusters in a rope and the byte index where each\n+    /// grapheme cluster starts.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use ropey::Rope;\n+    /// # use helix_stdx::rope::RopeSliceExt;\n+    /// let text = Rope::from_str(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\ud83c\udff4\u200d\u2620\ufe0f\ud83d\uddbc\ufe0f\");\n+    /// let slice = text.slice(..);\n+    /// let graphemes: Vec<_> = slice.grapheme_indices_at(0).collect();\n+    /// assert_eq!(\n+    ///   graphemes.as_slice(),\n+    ///   &[(0, \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\".into()), (14, \"\ud83c\udff4\u200d\u2620\ufe0f\".into()), (27, \"\ud83d\uddbc\ufe0f\".into())]\n+    /// );\n+    /// let graphemes: Vec<_> = slice.grapheme_indices_at(slice.len_bytes()).reversed().collect();\n+    /// assert_eq!(\n+    ///   graphemes.as_slice(),\n+    ///   &[(27, \"\ud83d\uddbc\ufe0f\".into()), (14, \"\ud83c\udff4\u200d\u2620\ufe0f\".into()), (0, \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\".into())]\n+    /// );\n+    /// ```\n+    fn grapheme_indices_at(self, byte_idx: usize) -> RopeGraphemeIndices<'a>;\n+    /// Finds the byte index of the next grapheme boundary after `byte_idx`.\n+    ///\n+    /// If the byte index lies on the last grapheme cluster in the slice then this function\n+    /// returns `RopeSlice::len_bytes`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use ropey::Rope;\n+    /// # use helix_stdx::rope::RopeSliceExt;\n+    /// let text = Rope::from_str(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\ud83c\udff4\u200d\u2620\ufe0f\ud83d\uddbc\ufe0f\");\n+    /// let slice = text.slice(..);\n+    /// let mut byte_idx = 0;\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), Some(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\".into()));\n+    /// byte_idx = slice.next_grapheme_boundary(byte_idx);\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), Some(\"\ud83c\udff4\u200d\u2620\ufe0f\".into()));\n+    /// byte_idx = slice.next_grapheme_boundary(byte_idx);\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), Some(\"\ud83d\uddbc\ufe0f\".into()));\n+    /// byte_idx = slice.next_grapheme_boundary(byte_idx);\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), None);\n+    /// assert_eq!(byte_idx, slice.len_bytes());\n+    /// ```\n+    fn next_grapheme_boundary(self, byte_idx: usize) -> usize {\n+        self.nth_next_grapheme_boundary(byte_idx, 1)\n+    }\n+    /// Finds the byte index of the `n`th grapheme cluster after the given `byte_idx`.\n+    ///\n+    /// If there are more than `n` grapheme clusters after `byte_idx` in the rope then this",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2147321400",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13743,
        "pr_file": "helix-stdx/src/rope.rs",
        "discussion_id": "2147321400",
        "commented_code": "@@ -150,7 +152,111 @@ pub trait RopeSliceExt<'a>: Sized {\n     /// let graphemes: Vec<_> = text.graphemes_rev().collect();\n     /// assert_eq!(graphemes.as_slice(), &[\"\ud83d\uddbc\ufe0f\", \"\ud83c\udff4\u200d\u2620\ufe0f\", \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\"]);\n     /// ```\n-    fn graphemes_rev(self) -> RevRopeGraphemes<'a>;\n+    fn graphemes_rev(self) -> RopeGraphemes<'a>;\n+    /// Returns an iterator over the grapheme clusters in the slice at the given byte index.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use ropey::Rope;\n+    /// # use helix_stdx::rope::RopeSliceExt;\n+    /// let text = Rope::from_str(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\ud83c\udff4\u200d\u2620\ufe0f\ud83d\uddbc\ufe0f\");\n+    /// // 14 is the byte index of the pirate flag's starting cluster boundary.\n+    /// let graphemes: Vec<_> = text.slice(..).graphemes_at(14).collect();\n+    /// assert_eq!(graphemes.as_slice(), &[\"\ud83c\udff4\u200d\u2620\ufe0f\", \"\ud83d\uddbc\ufe0f\"]);\n+    /// // 27 is the byte index of the pirate flag's ending cluster boundary.\n+    /// let graphemes: Vec<_> = text.slice(..).graphemes_at(27).reversed().collect();\n+    /// assert_eq!(graphemes.as_slice(), &[\"\ud83c\udff4\u200d\u2620\ufe0f\", \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\"]);\n+    /// ```\n+    fn graphemes_at(self, byte_idx: usize) -> RopeGraphemes<'a>;\n+    /// Returns an iterator over the grapheme clusters in a rope and the byte index where each\n+    /// grapheme cluster starts.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use ropey::Rope;\n+    /// # use helix_stdx::rope::RopeSliceExt;\n+    /// let text = Rope::from_str(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\ud83c\udff4\u200d\u2620\ufe0f\ud83d\uddbc\ufe0f\");\n+    /// let slice = text.slice(..);\n+    /// let graphemes: Vec<_> = slice.grapheme_indices_at(0).collect();\n+    /// assert_eq!(\n+    ///   graphemes.as_slice(),\n+    ///   &[(0, \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\".into()), (14, \"\ud83c\udff4\u200d\u2620\ufe0f\".into()), (27, \"\ud83d\uddbc\ufe0f\".into())]\n+    /// );\n+    /// let graphemes: Vec<_> = slice.grapheme_indices_at(slice.len_bytes()).reversed().collect();\n+    /// assert_eq!(\n+    ///   graphemes.as_slice(),\n+    ///   &[(27, \"\ud83d\uddbc\ufe0f\".into()), (14, \"\ud83c\udff4\u200d\u2620\ufe0f\".into()), (0, \"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\".into())]\n+    /// );\n+    /// ```\n+    fn grapheme_indices_at(self, byte_idx: usize) -> RopeGraphemeIndices<'a>;\n+    /// Finds the byte index of the next grapheme boundary after `byte_idx`.\n+    ///\n+    /// If the byte index lies on the last grapheme cluster in the slice then this function\n+    /// returns `RopeSlice::len_bytes`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # use ropey::Rope;\n+    /// # use helix_stdx::rope::RopeSliceExt;\n+    /// let text = Rope::from_str(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\ud83c\udff4\u200d\u2620\ufe0f\ud83d\uddbc\ufe0f\");\n+    /// let slice = text.slice(..);\n+    /// let mut byte_idx = 0;\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), Some(\"\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\".into()));\n+    /// byte_idx = slice.next_grapheme_boundary(byte_idx);\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), Some(\"\ud83c\udff4\u200d\u2620\ufe0f\".into()));\n+    /// byte_idx = slice.next_grapheme_boundary(byte_idx);\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), Some(\"\ud83d\uddbc\ufe0f\".into()));\n+    /// byte_idx = slice.next_grapheme_boundary(byte_idx);\n+    /// assert_eq!(slice.graphemes_at(byte_idx).next(), None);\n+    /// assert_eq!(byte_idx, slice.len_bytes());\n+    /// ```\n+    fn next_grapheme_boundary(self, byte_idx: usize) -> usize {\n+        self.nth_next_grapheme_boundary(byte_idx, 1)\n+    }\n+    /// Finds the byte index of the `n`th grapheme cluster after the given `byte_idx`.\n+    ///\n+    /// If there are more than `n` grapheme clusters after `byte_idx` in the rope then this",
        "comment_created_at": "2025-06-14T20:58:23+00:00",
        "comment_author": "DerSaidin",
        "comment_body": "Should be\r\n```\r\nIf there are fewer than `n` grapheme clusters...\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1166185871",
    "pr_number": 6486,
    "pr_file": "helix-view/src/document.rs",
    "created_at": "2023-04-14T01:33:11+00:00",
    "commented_code": "Some(fut.boxed())\n     }\n \n+    pub fn code_actions_on_save(\n+        &self,\n+    ) -> Option<BoxFuture<'static, Result<Vec<helix_lsp::lsp::CodeActionOrCommand>, anyhow::Error>>>\n+    {\n+        let code_actions_on_save = self\n+            .language_config()\n+            .map(|c| c.code_actions_on_save.clone())?;\n+\n+        if code_actions_on_save.is_empty() {\n+            return None;\n+        }\n+\n+        let request = self.code_actions(self.full_range())?;\n+\n+        let fut = async move {\n+            log::debug!(\"Configured code actions on save {:?}\", code_actions_on_save);\n+            let json = request.await?;\n+            let response: Option<helix_lsp::lsp::CodeActionResponse> =\n+                serde_json::from_value(json)?;\n+            let mut code_actions = match response {\n+                Some(value) => value,\n+                None => helix_lsp::lsp::CodeActionResponse::default(),\n+            };\n+            log::debug!(\"Available code actions {:?}\", code_actions);\n+            code_actions.retain(|action| {\n+                matches!(\n+                    action,\n+                    helix_lsp::lsp::CodeActionOrCommand::CodeAction(x) if x.disabled.is_none() &&\n+                        code_actions_on_save.iter().any(|a| match &x.kind {",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1166185871",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 6486,
        "pr_file": "helix-view/src/document.rs",
        "discussion_id": "1166185871",
        "commented_code": "@@ -633,6 +634,88 @@ impl Document {\n         Some(fut.boxed())\n     }\n \n+    pub fn code_actions_on_save(\n+        &self,\n+    ) -> Option<BoxFuture<'static, Result<Vec<helix_lsp::lsp::CodeActionOrCommand>, anyhow::Error>>>\n+    {\n+        let code_actions_on_save = self\n+            .language_config()\n+            .map(|c| c.code_actions_on_save.clone())?;\n+\n+        if code_actions_on_save.is_empty() {\n+            return None;\n+        }\n+\n+        let request = self.code_actions(self.full_range())?;\n+\n+        let fut = async move {\n+            log::debug!(\"Configured code actions on save {:?}\", code_actions_on_save);\n+            let json = request.await?;\n+            let response: Option<helix_lsp::lsp::CodeActionResponse> =\n+                serde_json::from_value(json)?;\n+            let mut code_actions = match response {\n+                Some(value) => value,\n+                None => helix_lsp::lsp::CodeActionResponse::default(),\n+            };\n+            log::debug!(\"Available code actions {:?}\", code_actions);\n+            code_actions.retain(|action| {\n+                matches!(\n+                    action,\n+                    helix_lsp::lsp::CodeActionOrCommand::CodeAction(x) if x.disabled.is_none() &&\n+                        code_actions_on_save.iter().any(|a| match &x.kind {",
        "comment_created_at": "2023-04-14T01:33:11+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "probably a good idea to make this a `HashSet` so we avoid being `O(MN)` here even if `M` and `N` is usually small frserializing to a `HashSet` just takes replacing `Vec` with `HashSet`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1164625038",
    "pr_number": 6197,
    "pr_file": "helix-term/src/ui/editor.rs",
    "created_at": "2023-04-12T20:33:01+00:00",
    "commented_code": ".for_each(|area| surface.set_style(area, ruler_theme))\n     }\n \n+    pub fn cursor_word(doc: &Document, view: &View) -> Option<String> {\n+        let is_word = |c: char| -> bool { c.is_ascii_alphanumeric() || c == '-' || c == '_' };\n+\n+        let text = doc.text().slice(..);\n+        let cursor = doc.selection(view.id).primary().cursor(text);\n+        let cursor_char = text.byte_to_char(cursor);\n+        let char_under_cursor = text.get_char(cursor_char);\n+        if !is_word(char_under_cursor?) {\n+            return None;\n+        }\n+\n+        let start = (0..=cursor_char)\n+            .rev()\n+            .find(|&i| !is_word(text.char(i)))\n+            .map(|i| i + 1)\n+            .unwrap_or(0);\n+        let end = (cursor_char..text.len_chars())\n+            .find(|&i| !is_word(text.char(i)))\n+            .unwrap_or_else(|| text.len_chars());",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1164625038",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 6197,
        "pr_file": "helix-term/src/ui/editor.rs",
        "discussion_id": "1164625038",
        "commented_code": "@@ -264,6 +272,121 @@ impl EditorView {\n             .for_each(|area| surface.set_style(area, ruler_theme))\n     }\n \n+    pub fn cursor_word(doc: &Document, view: &View) -> Option<String> {\n+        let is_word = |c: char| -> bool { c.is_ascii_alphanumeric() || c == '-' || c == '_' };\n+\n+        let text = doc.text().slice(..);\n+        let cursor = doc.selection(view.id).primary().cursor(text);\n+        let cursor_char = text.byte_to_char(cursor);\n+        let char_under_cursor = text.get_char(cursor_char);\n+        if !is_word(char_under_cursor?) {\n+            return None;\n+        }\n+\n+        let start = (0..=cursor_char)\n+            .rev()\n+            .find(|&i| !is_word(text.char(i)))\n+            .map(|i| i + 1)\n+            .unwrap_or(0);\n+        let end = (cursor_char..text.len_chars())\n+            .find(|&i| !is_word(text.char(i)))\n+            .unwrap_or_else(|| text.len_chars());",
        "comment_created_at": "2023-04-12T20:33:01+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "index into the repo repeatetly is pretty inefficient. A rope is a binary tree internally so this is `O(Wlog(N))` . By comparison doing `text.chars_at(cursor_char).take_while(is_word).count()` is just `O(log(N)+W)` (just finding the position once). You can take a look at `set_completion` in commands.rs for an example where we calculate the start of the word (`start_offset`) at the cursor position. The end works similarly",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1164666264",
    "pr_number": 6197,
    "pr_file": "helix-term/src/ui/editor.rs",
    "created_at": "2023-04-12T21:21:37+00:00",
    "commented_code": ".for_each(|area| surface.set_style(area, ruler_theme))\n     }\n \n+    pub fn cursor_word(doc: &Document, view: &View) -> Option<String> {\n+        let is_word = |c: char| -> bool { c.is_ascii_alphanumeric() || c == '-' || c == '_' };\n+\n+        let text = doc.text().slice(..);\n+        let cursor = doc.selection(view.id).primary().cursor(text);\n+        let cursor_char = text.byte_to_char(cursor);\n+        let char_under_cursor = text.get_char(cursor_char);\n+        if !is_word(char_under_cursor?) {\n+            return None;\n+        }\n+\n+        let start = (0..=cursor_char)\n+            .rev()\n+            .find(|&i| !is_word(text.char(i)))\n+            .map(|i| i + 1)\n+            .unwrap_or(0);\n+        let end = (cursor_char..text.len_chars())\n+            .find(|&i| !is_word(text.char(i)))\n+            .unwrap_or_else(|| text.len_chars());\n+\n+        Some(text.slice(start..end).to_string())\n+    }\n+\n+    /// Calculates the ranges of the word under the cursor and returns the result\n+    fn calculate_cursor_word(\n+        doc: &Document,\n+        view: &View,\n+        viewport: Rect,\n+        scope_index: usize,\n+    ) -> Vec<(usize, std::ops::Range<usize>)> {\n+        let text = doc.text().slice(..);\n+        let mut result = Vec::new();\n+\n+        let cursor_word = match Self::cursor_word(doc, view) {\n+            Some(cw) => cw,\n+            None => return result,\n+        };\n+\n+        let is_word_char = |c: Option<char>| -> bool {\n+            if let Some(c) = c {\n+                c.is_ascii_alphanumeric() || c == '-' || c == '_'\n+            } else {\n+                false\n+            }\n+        };\n+\n+        let row = text.char_to_line(view.offset.anchor.min(text.len_chars()));\n+\n+        let line_range = {\n+            // Calculate the lines in view\n+            let last_line = text.len_lines().saturating_sub(1);\n+            let last_visible_line = (row + viewport.height as usize).min(last_line);\n+            let first_visible_line = row;\n+\n+            first_visible_line..last_visible_line\n+        };\n+\n+        for line in line_range {\n+            let current_line = text.line(line);\n+            let current_line = match current_line.as_str() {\n+                Some(l) => l,\n+                None => continue,\n+            };",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1164666264",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 6197,
        "pr_file": "helix-term/src/ui/editor.rs",
        "discussion_id": "1164666264",
        "commented_code": "@@ -264,6 +272,121 @@ impl EditorView {\n             .for_each(|area| surface.set_style(area, ruler_theme))\n     }\n \n+    pub fn cursor_word(doc: &Document, view: &View) -> Option<String> {\n+        let is_word = |c: char| -> bool { c.is_ascii_alphanumeric() || c == '-' || c == '_' };\n+\n+        let text = doc.text().slice(..);\n+        let cursor = doc.selection(view.id).primary().cursor(text);\n+        let cursor_char = text.byte_to_char(cursor);\n+        let char_under_cursor = text.get_char(cursor_char);\n+        if !is_word(char_under_cursor?) {\n+            return None;\n+        }\n+\n+        let start = (0..=cursor_char)\n+            .rev()\n+            .find(|&i| !is_word(text.char(i)))\n+            .map(|i| i + 1)\n+            .unwrap_or(0);\n+        let end = (cursor_char..text.len_chars())\n+            .find(|&i| !is_word(text.char(i)))\n+            .unwrap_or_else(|| text.len_chars());\n+\n+        Some(text.slice(start..end).to_string())\n+    }\n+\n+    /// Calculates the ranges of the word under the cursor and returns the result\n+    fn calculate_cursor_word(\n+        doc: &Document,\n+        view: &View,\n+        viewport: Rect,\n+        scope_index: usize,\n+    ) -> Vec<(usize, std::ops::Range<usize>)> {\n+        let text = doc.text().slice(..);\n+        let mut result = Vec::new();\n+\n+        let cursor_word = match Self::cursor_word(doc, view) {\n+            Some(cw) => cw,\n+            None => return result,\n+        };\n+\n+        let is_word_char = |c: Option<char>| -> bool {\n+            if let Some(c) = c {\n+                c.is_ascii_alphanumeric() || c == '-' || c == '_'\n+            } else {\n+                false\n+            }\n+        };\n+\n+        let row = text.char_to_line(view.offset.anchor.min(text.len_chars()));\n+\n+        let line_range = {\n+            // Calculate the lines in view\n+            let last_line = text.len_lines().saturating_sub(1);\n+            let last_visible_line = (row + viewport.height as usize).min(last_line);\n+            let first_visible_line = row;\n+\n+            first_visible_line..last_visible_line\n+        };\n+\n+        for line in line_range {\n+            let current_line = text.line(line);\n+            let current_line = match current_line.as_str() {\n+                Some(l) => l,\n+                None => continue,\n+            };",
        "comment_created_at": "2023-04-12T21:21:37+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "this is ineffecit. First you are iterating a line range and obtaining a line with `text.line`  which is  `O(logN)`  so this loop is `O(MlogN)` with the `lines` iterator it would be `O(logN + M)`. However you are not actually interested in lines anyway since you are really just obtaining the string. The problem is that `as_str` will return `None` at any line that contains a ropey chunk boundary which could weridly discard lots of matches. There is actually aa way to implement this with a small temporary buffer that doesn't discard any matches at all but that complexity is probably not worth it/required here for now. Instead you can just iterate the chunks directly. That way only words that actually contain a chunk boundary are now shown (which is pretty rare):\r\n\r\n```suggestion\r\n\r\n        for chunk in text.slice(text.line_to_char(line_range.start)..text.line_to_char(line_range.end)).chunks(){\r\n\r\n```\r\n",
        "pr_file_module": null
      }
    ]
  }
]