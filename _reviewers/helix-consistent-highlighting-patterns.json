[
  {
    "discussion_id": "2234156941",
    "pr_number": 14089,
    "pr_file": "runtime/queries/robots.txt/highlights.scm",
    "created_at": "2025-07-27T22:33:26+00:00",
    "commented_code": "+(comment) @comment\n+\n+(directive) @attribute\n+\n+(rule (unknownDirective) @attribute) @diagnostic.error",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2234156941",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 14089,
        "pr_file": "runtime/queries/robots.txt/highlights.scm",
        "discussion_id": "2234156941",
        "commented_code": "@@ -0,0 +1,28 @@\n+(comment) @comment\n+\n+(directive) @attribute\n+\n+(rule (unknownDirective) @attribute) @diagnostic.error",
        "comment_created_at": "2025-07-27T22:33:26+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "```suggestion\r\n(rule (unknownDirective) @attribute) @error\r\n```\r\n\r\nFor syntax errors in the past I believe we used `error` rather than `diagnostic.error`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2202693852",
    "pr_number": 13932,
    "pr_file": "runtime/queries/rust/highlights.scm",
    "created_at": "2025-07-12T14:31:33+00:00",
    "commented_code": "; Functions\n ; -------\n \n+; In here, `bar` is a function, as it is equal to a closure:\n+;\n+; let bar = || 4;\n+(let_declaration\n+  pattern: (identifier) @function\n+  value: (closure_expression))\n+\n+; highlight `baz` in `any_function(foo::bar::baz)` as function\n+; This generically works for an unlimited number of path segments:\n+;\n+; - `f(foo::bar)`\n+; - `f(foo::bar::baz)`\n+; - `f(foo::bar::baz::quux)`\n+;\n+; We know that in the above examples, the last component of each path is a function\n+; as the only other valid thing (following Rust naming conventions) would be a module at\n+; that position, however you cannot pass modules as arguments\n+(call_expression\n+  function: _\n+  arguments: (arguments\n+    (scoped_identifier\n+      path: _\n+      name: (identifier) @function)))\n+\n+; Special handling for point-free functions that are not part of a path\n+; but are just passed as variables to some \"well-known\"\n+; methods, which are known to take a closure as the first argument\n+; \n+; For example, `foo` in `a.map(foo)` is a @function\n+(call_expression\n+  function: (field_expression\n+    value: _\n+    field: (field_identifier) @_method_name)\n+  arguments:\n+    ; first argument is `@function`\n+    (arguments\n+      .\n+      (identifier) @function)\n+  (#any-of? @_method_name\n+  ; methods on `core::iter::Iterator`\n+  \"map\" \"map_while\" \"filter_map\" \"flat_map\" \"map_windows\"",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2202693852",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13932,
        "pr_file": "runtime/queries/rust/highlights.scm",
        "discussion_id": "2202693852",
        "commented_code": "@@ -305,6 +305,153 @@\n ; Functions\n ; -------\n \n+; In here, `bar` is a function, as it is equal to a closure:\n+;\n+; let bar = || 4;\n+(let_declaration\n+  pattern: (identifier) @function\n+  value: (closure_expression))\n+\n+; highlight `baz` in `any_function(foo::bar::baz)` as function\n+; This generically works for an unlimited number of path segments:\n+;\n+; - `f(foo::bar)`\n+; - `f(foo::bar::baz)`\n+; - `f(foo::bar::baz::quux)`\n+;\n+; We know that in the above examples, the last component of each path is a function\n+; as the only other valid thing (following Rust naming conventions) would be a module at\n+; that position, however you cannot pass modules as arguments\n+(call_expression\n+  function: _\n+  arguments: (arguments\n+    (scoped_identifier\n+      path: _\n+      name: (identifier) @function)))\n+\n+; Special handling for point-free functions that are not part of a path\n+; but are just passed as variables to some \"well-known\"\n+; methods, which are known to take a closure as the first argument\n+; \n+; For example, `foo` in `a.map(foo)` is a @function\n+(call_expression\n+  function: (field_expression\n+    value: _\n+    field: (field_identifier) @_method_name)\n+  arguments:\n+    ; first argument is `@function`\n+    (arguments\n+      .\n+      (identifier) @function)\n+  (#any-of? @_method_name\n+  ; methods on `core::iter::Iterator`\n+  \"map\" \"map_while\" \"filter_map\" \"flat_map\" \"map_windows\"",
        "comment_created_at": "2025-07-12T14:31:33+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "It's fine to highlight based on exact function/type names for things like the builtin highlights, but I don't like a huge pattern like this that tries to guess the highlight. We can't figure out whether the identifier is in this situation robustly and I don't want a really big highlight like this that tries to cover common cases - it will seem inconsistent when you write a custom higher order function",
        "pr_file_module": null
      },
      {
        "comment_id": "2202699765",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13932,
        "pr_file": "runtime/queries/rust/highlights.scm",
        "discussion_id": "2202693852",
        "commented_code": "@@ -305,6 +305,153 @@\n ; Functions\n ; -------\n \n+; In here, `bar` is a function, as it is equal to a closure:\n+;\n+; let bar = || 4;\n+(let_declaration\n+  pattern: (identifier) @function\n+  value: (closure_expression))\n+\n+; highlight `baz` in `any_function(foo::bar::baz)` as function\n+; This generically works for an unlimited number of path segments:\n+;\n+; - `f(foo::bar)`\n+; - `f(foo::bar::baz)`\n+; - `f(foo::bar::baz::quux)`\n+;\n+; We know that in the above examples, the last component of each path is a function\n+; as the only other valid thing (following Rust naming conventions) would be a module at\n+; that position, however you cannot pass modules as arguments\n+(call_expression\n+  function: _\n+  arguments: (arguments\n+    (scoped_identifier\n+      path: _\n+      name: (identifier) @function)))\n+\n+; Special handling for point-free functions that are not part of a path\n+; but are just passed as variables to some \"well-known\"\n+; methods, which are known to take a closure as the first argument\n+; \n+; For example, `foo` in `a.map(foo)` is a @function\n+(call_expression\n+  function: (field_expression\n+    value: _\n+    field: (field_identifier) @_method_name)\n+  arguments:\n+    ; first argument is `@function`\n+    (arguments\n+      .\n+      (identifier) @function)\n+  (#any-of? @_method_name\n+  ; methods on `core::iter::Iterator`\n+  \"map\" \"map_while\" \"filter_map\" \"flat_map\" \"map_windows\"",
        "comment_created_at": "2025-07-12T14:37:18+00:00",
        "comment_author": "nik-rev",
        "comment_body": "Are you suggesting to remove this query entirely or would it be ok to strip down the list of hard-coded method names to some very common ones: e.g. `map`, `flat_map`, `filter`?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072620765",
    "pr_number": 13449,
    "pr_file": "runtime/queries/slang/highlights.scm",
    "created_at": "2025-05-04T13:37:16+00:00",
    "commented_code": "+; inherits: c\n+\n+; cpp\n+((identifier) @variable.member\n+  (#match? @variable.member \"^m_.*$\"))\n+\n+(parameter_declaration\n+  declarator: (reference_declarator) @variable.parameter)\n+\n+; function(Foo ...foo)\n+(variadic_parameter_declaration\n+  declarator: (variadic_declarator\n+    (_) @variable.parameter))\n+\n+; int foo = 0\n+(optional_parameter_declaration\n+  declarator: (_) @variable.parameter)\n+\n+;(field_expression) @variable.parameter ;; How to highlight this?\n+((field_expression\n+  (field_identifier) @function.method) @_parent\n+  (#has-parent? @_parent template_method function_declarator))\n+\n+(field_declaration\n+  (field_identifier) @variable.member)\n+\n+(field_initializer\n+  (field_identifier) @property)\n+\n+(function_declarator\n+  declarator: (field_identifier) @function.method)\n+\n+(concept_definition\n+  name: (identifier) @type.definition)\n+\n+(alias_declaration\n+  name: (type_identifier) @type.definition)\n+\n+(namespace_identifier) @module\n+\n+((namespace_identifier) @type\n+  (#match? @type \"^[%u]\"))\n+\n+(case_statement\n+  value: (qualified_identifier\n+    (identifier) @constant))\n+\n+(using_declaration\n+  .\n+  \"using\"\n+  .\n+  \"namespace\"\n+  .\n+  [\n+    (qualified_identifier)\n+    (identifier)\n+  ] @module)\n+\n+(destructor_name\n+  (identifier) @function.method)\n+\n+; functions\n+(function_declarator\n+  (qualified_identifier\n+    (identifier) @function))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function)))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function)))) @_parent\n+  (#has-ancestor? @_parent function_declarator))\n+\n+(function_declarator\n+  (template_function\n+    (identifier) @function))\n+\n+(operator_name) @function\n+\n+\"operator\" @function\n+\n+\"static_assert\" @function.builtin\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (identifier) @function.call))\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call)))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+(call_expression\n+  (template_function\n+    (identifier) @function.call))\n+\n+(call_expression\n+  (qualified_identifier\n+    (template_function\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (template_function\n+        (identifier) @function.call))))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call)))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call))))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+; methods\n+(function_declarator\n+  (template_method\n+    (field_identifier) @function.method))\n+\n+(call_expression\n+  (field_expression\n+    (field_identifier) @function.method.call))",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2072620765",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13449,
        "pr_file": "runtime/queries/slang/highlights.scm",
        "discussion_id": "2072620765",
        "commented_code": "@@ -0,0 +1,398 @@\n+; inherits: c\n+\n+; cpp\n+((identifier) @variable.member\n+  (#match? @variable.member \"^m_.*$\"))\n+\n+(parameter_declaration\n+  declarator: (reference_declarator) @variable.parameter)\n+\n+; function(Foo ...foo)\n+(variadic_parameter_declaration\n+  declarator: (variadic_declarator\n+    (_) @variable.parameter))\n+\n+; int foo = 0\n+(optional_parameter_declaration\n+  declarator: (_) @variable.parameter)\n+\n+;(field_expression) @variable.parameter ;; How to highlight this?\n+((field_expression\n+  (field_identifier) @function.method) @_parent\n+  (#has-parent? @_parent template_method function_declarator))\n+\n+(field_declaration\n+  (field_identifier) @variable.member)\n+\n+(field_initializer\n+  (field_identifier) @property)\n+\n+(function_declarator\n+  declarator: (field_identifier) @function.method)\n+\n+(concept_definition\n+  name: (identifier) @type.definition)\n+\n+(alias_declaration\n+  name: (type_identifier) @type.definition)\n+\n+(namespace_identifier) @module\n+\n+((namespace_identifier) @type\n+  (#match? @type \"^[%u]\"))\n+\n+(case_statement\n+  value: (qualified_identifier\n+    (identifier) @constant))\n+\n+(using_declaration\n+  .\n+  \"using\"\n+  .\n+  \"namespace\"\n+  .\n+  [\n+    (qualified_identifier)\n+    (identifier)\n+  ] @module)\n+\n+(destructor_name\n+  (identifier) @function.method)\n+\n+; functions\n+(function_declarator\n+  (qualified_identifier\n+    (identifier) @function))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function)))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function)))) @_parent\n+  (#has-ancestor? @_parent function_declarator))\n+\n+(function_declarator\n+  (template_function\n+    (identifier) @function))\n+\n+(operator_name) @function\n+\n+\"operator\" @function\n+\n+\"static_assert\" @function.builtin\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (identifier) @function.call))\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call)))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+(call_expression\n+  (template_function\n+    (identifier) @function.call))\n+\n+(call_expression\n+  (qualified_identifier\n+    (template_function\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (template_function\n+        (identifier) @function.call))))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call)))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call))))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+; methods\n+(function_declarator\n+  (template_method\n+    (field_identifier) @function.method))\n+\n+(call_expression\n+  (field_expression\n+    (field_identifier) @function.method.call))",
        "comment_created_at": "2025-05-04T13:37:16+00:00",
        "comment_author": "uncenter",
        "comment_body": "```suggestion\r\n(call_expression\r\n  (qualified_identifier\r\n    (identifier) @function))\r\n\r\n\r\n(call_expression\r\n  (qualified_identifier\r\n    (qualified_identifier\r\n      (identifier) @function)))\r\n\r\n(call_expression\r\n  (qualified_identifier\r\n    (qualified_identifier\r\n      (qualified_identifier\r\n        (identifier) @function))))\r\n\r\n(call_expression\r\n  (template_function\r\n    (identifier) @function))\r\n\r\n(call_expression\r\n  (qualified_identifier\r\n    (template_function\r\n      (identifier) @function)))\r\n\r\n(call_expression\r\n  (qualified_identifier\r\n    (qualified_identifier\r\n      (template_function\r\n        (identifier) @function))))\r\n\r\n(call_expression\r\n  (qualified_identifier\r\n    (qualified_identifier\r\n      (qualified_identifier\r\n        (template_function\r\n          (identifier) @function)))))\r\n\r\n; methods\r\n(function_declarator\r\n  (template_method\r\n    (field_identifier) @function.method))\r\n\r\n(call_expression\r\n  (field_expression\r\n    (field_identifier) @function.method))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072621429",
    "pr_number": 13449,
    "pr_file": "runtime/queries/slang/highlights.scm",
    "created_at": "2025-05-04T13:40:12+00:00",
    "commented_code": "+; inherits: c\n+\n+; cpp\n+((identifier) @variable.member\n+  (#match? @variable.member \"^m_.*$\"))\n+\n+(parameter_declaration\n+  declarator: (reference_declarator) @variable.parameter)\n+\n+; function(Foo ...foo)\n+(variadic_parameter_declaration\n+  declarator: (variadic_declarator\n+    (_) @variable.parameter))\n+\n+; int foo = 0\n+(optional_parameter_declaration\n+  declarator: (_) @variable.parameter)\n+\n+;(field_expression) @variable.parameter ;; How to highlight this?\n+((field_expression\n+  (field_identifier) @function.method) @_parent\n+  (#has-parent? @_parent template_method function_declarator))\n+\n+(field_declaration\n+  (field_identifier) @variable.member)\n+\n+(field_initializer\n+  (field_identifier) @property)\n+\n+(function_declarator\n+  declarator: (field_identifier) @function.method)\n+\n+(concept_definition\n+  name: (identifier) @type.definition)\n+\n+(alias_declaration\n+  name: (type_identifier) @type.definition)\n+\n+(namespace_identifier) @module\n+\n+((namespace_identifier) @type\n+  (#match? @type \"^[%u]\"))\n+\n+(case_statement\n+  value: (qualified_identifier\n+    (identifier) @constant))\n+\n+(using_declaration\n+  .\n+  \"using\"\n+  .\n+  \"namespace\"\n+  .\n+  [\n+    (qualified_identifier)\n+    (identifier)\n+  ] @module)\n+\n+(destructor_name\n+  (identifier) @function.method)\n+\n+; functions\n+(function_declarator\n+  (qualified_identifier\n+    (identifier) @function))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function)))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function)))) @_parent\n+  (#has-ancestor? @_parent function_declarator))\n+\n+(function_declarator\n+  (template_function\n+    (identifier) @function))\n+\n+(operator_name) @function\n+\n+\"operator\" @function\n+\n+\"static_assert\" @function.builtin\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (identifier) @function.call))\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call)))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+(call_expression\n+  (template_function\n+    (identifier) @function.call))\n+\n+(call_expression\n+  (qualified_identifier\n+    (template_function\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (template_function\n+        (identifier) @function.call))))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call)))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call))))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+; methods\n+(function_declarator\n+  (template_method\n+    (field_identifier) @function.method))\n+\n+(call_expression\n+  (field_expression\n+    (field_identifier) @function.method.call))\n+\n+; constructors\n+((function_declarator\n+  (qualified_identifier\n+    (identifier) @constructor))\n+  (#match? @constructor \"^%u\"))\n+\n+((call_expression\n+  function: (identifier) @constructor)\n+  (#match? @constructor \"^%u\"))\n+\n+((call_expression\n+  function: (qualified_identifier\n+    name: (identifier) @constructor))\n+  (#match? @constructor \"^%u\"))\n+\n+((call_expression\n+  function: (field_expression\n+    field: (field_identifier) @constructor))\n+  (#match? @constructor \"^%u\"))\n+\n+; constructing a type in an initializer list: Constructor ():  **SuperType (1)**\n+((field_initializer\n+  (field_identifier) @constructor\n+  (argument_list))\n+  (#match? @constructor \"^%u\"))\n+\n+; Constants\n+(this) @variable.builtin\n+\n+(null\n+  \"nullptr\" @constant.builtin)\n+\n+(true) @boolean\n+\n+(false) @boolean\n+\n+; Literals\n+(raw_string_literal) @string\n+\n+; Keywords\n+[\n+  \"try\"\n+  \"catch\"\n+  \"noexcept\"\n+  \"throw\"\n+] @keyword.exception\n+\n+[\n+  \"decltype\"\n+  \"explicit\"\n+  \"friend\"\n+  \"override\"\n+  \"using\"\n+  \"requires\"\n+  \"constexpr\"\n+] @keyword\n+\n+[\n+  \"class\"\n+  \"namespace\"\n+  \"template\"\n+  \"typename\"\n+  \"concept\"\n+] @keyword.type\n+\n+[\n+  \"co_await\"\n+  \"co_yield\"\n+  \"co_return\"\n+] @keyword.coroutine\n+\n+[\n+  \"public\"\n+  \"private\"\n+  \"protected\"\n+  \"final\"\n+  \"virtual\"\n+] @keyword.modifier\n+\n+[\n+  \"new\"\n+  \"delete\"\n+  \"xor\"\n+  \"bitand\"\n+  \"bitor\"\n+  \"compl\"\n+  \"not\"\n+  \"xor_eq\"\n+  \"and_eq\"\n+  \"or_eq\"\n+  \"not_eq\"\n+  \"and\"\n+  \"or\"\n+] @keyword.operator\n+\n+\"<=>\" @operator\n+\n+\"::\" @punctuation.delimiter\n+\n+(template_argument_list\n+  [\n+    \"<\"\n+    \">\"\n+  ] @punctuation.bracket)\n+\n+(template_parameter_list\n+  [\n+    \"<\"\n+    \">\"\n+  ] @punctuation.bracket)\n+\n+(literal_suffix) @operator\n+\n+; hlsl\n+[\n+  \"in\"\n+  \"out\"\n+  \"inout\"\n+  \"uniform\"\n+  \"shared\"\n+  \"groupshared\"\n+  \"discard\"\n+  \"cbuffer\"\n+  \"row_major\"\n+  \"column_major\"\n+  \"globallycoherent\"\n+  \"centroid\"\n+  \"noperspective\"\n+  \"nointerpolation\"\n+  \"sample\"\n+  \"linear\"\n+  \"snorm\"\n+  \"unorm\"\n+  \"point\"\n+  \"line\"\n+  \"triangleadj\"\n+  \"lineadj\"\n+  \"triangle\"\n+] @keyword.modifier\n+\n+((identifier) @variable.builtin\n+  (#match? @variable.builtin \"^SV_\"))\n+; ((identifier) @variable)\n+\n+(hlsl_attribute) @attribute\n+\n+(hlsl_attribute\n+  [\n+    \"[\"\n+    \"]\"\n+  ] @attribute)\n+\n+\"This\" @type.builtin\n+\n+[\n+  \"interface\"\n+  \"extension\"\n+  \"property\"\n+  \"associatedtype\"\n+  \"where\"\n+\t\"var\"\n+\t\"let\"\n+] @keyword\n+\n+\"__init\" @constructor\n+\n+[\n+  \"__subscript\"\n+  \"get\"\n+  \"set\"\n+] @function.builtin\n+\n+(call_expression) @function.call\n+\n+(call_expression (identifier)) @function.call",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2072621429",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13449,
        "pr_file": "runtime/queries/slang/highlights.scm",
        "discussion_id": "2072621429",
        "commented_code": "@@ -0,0 +1,398 @@\n+; inherits: c\n+\n+; cpp\n+((identifier) @variable.member\n+  (#match? @variable.member \"^m_.*$\"))\n+\n+(parameter_declaration\n+  declarator: (reference_declarator) @variable.parameter)\n+\n+; function(Foo ...foo)\n+(variadic_parameter_declaration\n+  declarator: (variadic_declarator\n+    (_) @variable.parameter))\n+\n+; int foo = 0\n+(optional_parameter_declaration\n+  declarator: (_) @variable.parameter)\n+\n+;(field_expression) @variable.parameter ;; How to highlight this?\n+((field_expression\n+  (field_identifier) @function.method) @_parent\n+  (#has-parent? @_parent template_method function_declarator))\n+\n+(field_declaration\n+  (field_identifier) @variable.member)\n+\n+(field_initializer\n+  (field_identifier) @property)\n+\n+(function_declarator\n+  declarator: (field_identifier) @function.method)\n+\n+(concept_definition\n+  name: (identifier) @type.definition)\n+\n+(alias_declaration\n+  name: (type_identifier) @type.definition)\n+\n+(namespace_identifier) @module\n+\n+((namespace_identifier) @type\n+  (#match? @type \"^[%u]\"))\n+\n+(case_statement\n+  value: (qualified_identifier\n+    (identifier) @constant))\n+\n+(using_declaration\n+  .\n+  \"using\"\n+  .\n+  \"namespace\"\n+  .\n+  [\n+    (qualified_identifier)\n+    (identifier)\n+  ] @module)\n+\n+(destructor_name\n+  (identifier) @function.method)\n+\n+; functions\n+(function_declarator\n+  (qualified_identifier\n+    (identifier) @function))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function)))\n+\n+(function_declarator\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function)))) @_parent\n+  (#has-ancestor? @_parent function_declarator))\n+\n+(function_declarator\n+  (template_function\n+    (identifier) @function))\n+\n+(operator_name) @function\n+\n+\"operator\" @function\n+\n+\"static_assert\" @function.builtin\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (identifier) @function.call))\n+\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (identifier) @function.call)))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+(call_expression\n+  (template_function\n+    (identifier) @function.call))\n+\n+(call_expression\n+  (qualified_identifier\n+    (template_function\n+      (identifier) @function.call)))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (template_function\n+        (identifier) @function.call))))\n+\n+(call_expression\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call)))))\n+\n+((qualified_identifier\n+  (qualified_identifier\n+    (qualified_identifier\n+      (qualified_identifier\n+        (template_function\n+          (identifier) @function.call))))) @_parent\n+  (#has-ancestor? @_parent call_expression))\n+\n+; methods\n+(function_declarator\n+  (template_method\n+    (field_identifier) @function.method))\n+\n+(call_expression\n+  (field_expression\n+    (field_identifier) @function.method.call))\n+\n+; constructors\n+((function_declarator\n+  (qualified_identifier\n+    (identifier) @constructor))\n+  (#match? @constructor \"^%u\"))\n+\n+((call_expression\n+  function: (identifier) @constructor)\n+  (#match? @constructor \"^%u\"))\n+\n+((call_expression\n+  function: (qualified_identifier\n+    name: (identifier) @constructor))\n+  (#match? @constructor \"^%u\"))\n+\n+((call_expression\n+  function: (field_expression\n+    field: (field_identifier) @constructor))\n+  (#match? @constructor \"^%u\"))\n+\n+; constructing a type in an initializer list: Constructor ():  **SuperType (1)**\n+((field_initializer\n+  (field_identifier) @constructor\n+  (argument_list))\n+  (#match? @constructor \"^%u\"))\n+\n+; Constants\n+(this) @variable.builtin\n+\n+(null\n+  \"nullptr\" @constant.builtin)\n+\n+(true) @boolean\n+\n+(false) @boolean\n+\n+; Literals\n+(raw_string_literal) @string\n+\n+; Keywords\n+[\n+  \"try\"\n+  \"catch\"\n+  \"noexcept\"\n+  \"throw\"\n+] @keyword.exception\n+\n+[\n+  \"decltype\"\n+  \"explicit\"\n+  \"friend\"\n+  \"override\"\n+  \"using\"\n+  \"requires\"\n+  \"constexpr\"\n+] @keyword\n+\n+[\n+  \"class\"\n+  \"namespace\"\n+  \"template\"\n+  \"typename\"\n+  \"concept\"\n+] @keyword.type\n+\n+[\n+  \"co_await\"\n+  \"co_yield\"\n+  \"co_return\"\n+] @keyword.coroutine\n+\n+[\n+  \"public\"\n+  \"private\"\n+  \"protected\"\n+  \"final\"\n+  \"virtual\"\n+] @keyword.modifier\n+\n+[\n+  \"new\"\n+  \"delete\"\n+  \"xor\"\n+  \"bitand\"\n+  \"bitor\"\n+  \"compl\"\n+  \"not\"\n+  \"xor_eq\"\n+  \"and_eq\"\n+  \"or_eq\"\n+  \"not_eq\"\n+  \"and\"\n+  \"or\"\n+] @keyword.operator\n+\n+\"<=>\" @operator\n+\n+\"::\" @punctuation.delimiter\n+\n+(template_argument_list\n+  [\n+    \"<\"\n+    \">\"\n+  ] @punctuation.bracket)\n+\n+(template_parameter_list\n+  [\n+    \"<\"\n+    \">\"\n+  ] @punctuation.bracket)\n+\n+(literal_suffix) @operator\n+\n+; hlsl\n+[\n+  \"in\"\n+  \"out\"\n+  \"inout\"\n+  \"uniform\"\n+  \"shared\"\n+  \"groupshared\"\n+  \"discard\"\n+  \"cbuffer\"\n+  \"row_major\"\n+  \"column_major\"\n+  \"globallycoherent\"\n+  \"centroid\"\n+  \"noperspective\"\n+  \"nointerpolation\"\n+  \"sample\"\n+  \"linear\"\n+  \"snorm\"\n+  \"unorm\"\n+  \"point\"\n+  \"line\"\n+  \"triangleadj\"\n+  \"lineadj\"\n+  \"triangle\"\n+] @keyword.modifier\n+\n+((identifier) @variable.builtin\n+  (#match? @variable.builtin \"^SV_\"))\n+; ((identifier) @variable)\n+\n+(hlsl_attribute) @attribute\n+\n+(hlsl_attribute\n+  [\n+    \"[\"\n+    \"]\"\n+  ] @attribute)\n+\n+\"This\" @type.builtin\n+\n+[\n+  \"interface\"\n+  \"extension\"\n+  \"property\"\n+  \"associatedtype\"\n+  \"where\"\n+\t\"var\"\n+\t\"let\"\n+] @keyword\n+\n+\"__init\" @constructor\n+\n+[\n+  \"__subscript\"\n+  \"get\"\n+  \"set\"\n+] @function.builtin\n+\n+(call_expression) @function.call\n+\n+(call_expression (identifier)) @function.call",
        "comment_created_at": "2025-05-04T13:40:12+00:00",
        "comment_author": "uncenter",
        "comment_body": "```suggestion\r\n(call_expression) @function\r\n\r\n(call_expression (identifier)) @function\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1941282960",
    "pr_number": 12768,
    "pr_file": "runtime/queries/rustfmt/highlights.scm",
    "created_at": "2025-02-04T14:29:47+00:00",
    "commented_code": "+; (format_string) @string\n+\n+(escaped) @constant.character.escape\n+\n+[\n+  \"#\"\n+  (type)\n+] @special\n+\n+[\n+  (sign)\n+  (fill)\n+  (align)\n+  (width)\n+] @operator\n+\n+(number) @constant.numeric\n+\n+(colon) @punctuation\n+\n+(identifier) @variable\n+\n+((identifier) @constant\n+ (#match? @constant \"^[A-Z_]+$\"))\n+\n+[\n+  \"{\"\n+  \"}\"\n+] @punctuation.special\n+\n+(ERROR) @error",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1941282960",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12768,
        "pr_file": "runtime/queries/rustfmt/highlights.scm",
        "discussion_id": "1941282960",
        "commented_code": "@@ -0,0 +1,31 @@\n+; (format_string) @string\n+\n+(escaped) @constant.character.escape\n+\n+[\n+  \"#\"\n+  (type)\n+] @special\n+\n+[\n+  (sign)\n+  (fill)\n+  (align)\n+  (width)\n+] @operator\n+\n+(number) @constant.numeric\n+\n+(colon) @punctuation\n+\n+(identifier) @variable\n+\n+((identifier) @constant\n+ (#match? @constant \"^[A-Z_]+$\"))\n+\n+[\n+  \"{\"\n+  \"}\"\n+] @punctuation.special\n+\n+(ERROR) @error",
        "comment_created_at": "2025-02-04T14:29:47+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "Generally we do not highlight `(ERROR)` since it's very noisy when typing. In the future we might introduce configuration for it if it's desired (basically prepending `(ERROR) @error` to `highlights.scm` text) but in the meantime let's remove this pattern",
        "pr_file_module": null
      },
      {
        "comment_id": "1941328954",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12768,
        "pr_file": "runtime/queries/rustfmt/highlights.scm",
        "discussion_id": "1941282960",
        "commented_code": "@@ -0,0 +1,31 @@\n+; (format_string) @string\n+\n+(escaped) @constant.character.escape\n+\n+[\n+  \"#\"\n+  (type)\n+] @special\n+\n+[\n+  (sign)\n+  (fill)\n+  (align)\n+  (width)\n+] @operator\n+\n+(number) @constant.numeric\n+\n+(colon) @punctuation\n+\n+(identifier) @variable\n+\n+((identifier) @constant\n+ (#match? @constant \"^[A-Z_]+$\"))\n+\n+[\n+  \"{\"\n+  \"}\"\n+] @punctuation.special\n+\n+(ERROR) @error",
        "comment_created_at": "2025-02-04T14:50:37+00:00",
        "comment_author": "nik-rev",
        "comment_body": "Ok I removed it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2027446078",
    "pr_number": 13260,
    "pr_file": "runtime/queries/fennel/highlights.scm",
    "created_at": "2025-04-03T17:20:38+00:00",
    "commented_code": "+; Most primitive nodes\n+(shebang) @keyword.directive\n+\n+(comment) @comment @spell\n+\n+(fn_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+(lambda_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+((symbol) @operator\n+  (#any-of? @operator\n+    ; arithmetic\n+    \"+\" \"-\" \"*\" \"/\" \"//\" \"%\" \"^\"\n+    ; comparison\n+    \">\" \"<\" \">=\" \"<=\" \"=\" \"~=\"\n+    ; other\n+    \"#\" \".\" \"?.\" \"..\"))\n+\n+((symbol) @keyword.operator\n+  (#any-of? @keyword.operator\n+    ; comparison\n+    \"not=\"\n+    ; boolean\n+    \"and\" \"or\" \"not\"\n+    ; bitwise\n+    \"lshift\" \"rshift\" \"band\" \"bor\" \"bxor\" \"bnot\"\n+    ; other\n+    \"length\"))\n+\n+(case_guard\n+  call: (_) @keyword.conditional)\n+\n+(case_guard_or_special\n+  call: (_) @keyword.conditional)\n+\n+(case_catch\n+  call: (symbol) @keyword)\n+\n+(import_macros_form\n+  imports: (table_binding\n+    (table_binding_pair\n+      value: (symbol_binding) @function.macro)))\n+\n+\n+((symbol) @keyword.function\n+  (#any-of? @keyword.function \"fn\" \"lambda\" \"\u03bb\" \"hashfn\"))\n+\n+((symbol) @keyword.repeat\n+  (#any-of? @keyword.repeat \"for\" \"each\" \"while\"))\n+\n+((symbol) @keyword.conditional\n+  (#any-of? @keyword.conditional \"if\" \"when\" \"match\" \"case\" \"match-try\" \"case-try\"))",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2027446078",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13260,
        "pr_file": "runtime/queries/fennel/highlights.scm",
        "discussion_id": "2027446078",
        "commented_code": "@@ -0,0 +1,196 @@\n+; Most primitive nodes\n+(shebang) @keyword.directive\n+\n+(comment) @comment @spell\n+\n+(fn_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+(lambda_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+((symbol) @operator\n+  (#any-of? @operator\n+    ; arithmetic\n+    \"+\" \"-\" \"*\" \"/\" \"//\" \"%\" \"^\"\n+    ; comparison\n+    \">\" \"<\" \">=\" \"<=\" \"=\" \"~=\"\n+    ; other\n+    \"#\" \".\" \"?.\" \"..\"))\n+\n+((symbol) @keyword.operator\n+  (#any-of? @keyword.operator\n+    ; comparison\n+    \"not=\"\n+    ; boolean\n+    \"and\" \"or\" \"not\"\n+    ; bitwise\n+    \"lshift\" \"rshift\" \"band\" \"bor\" \"bxor\" \"bnot\"\n+    ; other\n+    \"length\"))\n+\n+(case_guard\n+  call: (_) @keyword.conditional)\n+\n+(case_guard_or_special\n+  call: (_) @keyword.conditional)\n+\n+(case_catch\n+  call: (symbol) @keyword)\n+\n+(import_macros_form\n+  imports: (table_binding\n+    (table_binding_pair\n+      value: (symbol_binding) @function.macro)))\n+\n+\n+((symbol) @keyword.function\n+  (#any-of? @keyword.function \"fn\" \"lambda\" \"\u03bb\" \"hashfn\"))\n+\n+((symbol) @keyword.repeat\n+  (#any-of? @keyword.repeat \"for\" \"each\" \"while\"))\n+\n+((symbol) @keyword.conditional\n+  (#any-of? @keyword.conditional \"if\" \"when\" \"match\" \"case\" \"match-try\" \"case-try\"))",
        "comment_created_at": "2025-04-03T17:20:38+00:00",
        "comment_author": "uncenter",
        "comment_body": "```suggestion\r\n((symbol) @keyword.control.repeat\r\n  (#any-of? @keyword.control.repeat \"for\" \"each\" \"while\"))\r\n\r\n((symbol) @keyword.control.conditional\r\n  (#any-of? @keyword.control.conditional \"if\" \"when\" \"match\" \"case\" \"match-try\" \"case-try\"))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2027460880",
    "pr_number": 13260,
    "pr_file": "runtime/queries/fennel/highlights.scm",
    "created_at": "2025-04-03T17:31:21+00:00",
    "commented_code": "+; Most primitive nodes\n+(shebang) @keyword.directive\n+\n+(comment) @comment @spell\n+\n+(fn_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+(lambda_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+((symbol) @operator\n+  (#any-of? @operator\n+    ; arithmetic\n+    \"+\" \"-\" \"*\" \"/\" \"//\" \"%\" \"^\"\n+    ; comparison\n+    \">\" \"<\" \">=\" \"<=\" \"=\" \"~=\"\n+    ; other\n+    \"#\" \".\" \"?.\" \"..\"))\n+\n+((symbol) @keyword.operator\n+  (#any-of? @keyword.operator\n+    ; comparison\n+    \"not=\"\n+    ; boolean\n+    \"and\" \"or\" \"not\"\n+    ; bitwise\n+    \"lshift\" \"rshift\" \"band\" \"bor\" \"bxor\" \"bnot\"\n+    ; other\n+    \"length\"))\n+\n+(case_guard\n+  call: (_) @keyword.conditional)\n+\n+(case_guard_or_special\n+  call: (_) @keyword.conditional)\n+\n+(case_catch\n+  call: (symbol) @keyword)\n+\n+(import_macros_form\n+  imports: (table_binding\n+    (table_binding_pair\n+      value: (symbol_binding) @function.macro)))\n+\n+\n+((symbol) @keyword.function\n+  (#any-of? @keyword.function \"fn\" \"lambda\" \"\u03bb\" \"hashfn\"))\n+\n+((symbol) @keyword.repeat\n+  (#any-of? @keyword.repeat \"for\" \"each\" \"while\"))\n+\n+((symbol) @keyword.conditional\n+  (#any-of? @keyword.conditional \"if\" \"when\" \"match\" \"case\" \"match-try\" \"case-try\"))\n+\n+((symbol) @keyword\n+  (#any-of? @keyword\n+    \"global\" \"local\" \"let\" \"set\" \"var\" \"comment\" \"do\" \"doc\" \"eval-compiler\" \"lua\" \"macros\" \"unquote\"\n+    \"quote\" \"tset\" \"values\" \"tail!\"))\n+\n+((symbol) @keyword.import\n+  (#any-of? @keyword.import \"require\" \"require-macros\" \"import-macros\" \"include\"))\n+\n+((symbol) @function.macro\n+  (#any-of? @function.macro\n+    \"collect\" \"icollect\" \"fcollect\" \"accumulate\" \"faccumulate\" \"->\" \"->>\" \"-?>\" \"-?>>\" \"?.\" \"doto\"\n+    \"macro\" \"macrodebug\" \"partial\" \"pick-args\" \"pick-values\" \"with-open\"))\n+\n+((symbol) @variable.builtin\n+  (#eq? @variable.builtin \"...\"))\n+\n+((symbol) @constant.builtin\n+  (#eq? @constant.builtin \"_VERSION\"))\n+\n+((symbol) @function.builtin\n+  (#any-of? @function.builtin\n+    \"assert\" \"collectgarbage\" \"dofile\" \"error\" \"getmetatable\" \"ipairs\" \"load\" \"loadfile\" \"next\"\n+    \"pairs\" \"pcall\" \"print\" \"rawequal\" \"rawget\" \"rawlen\" \"rawset\" \"require\" \"select\" \"setmetatable\"\n+    \"tonumber\" \"tostring\" \"type\" \"warn\" \"xpcall\" \"module\" \"setfenv\" \"loadstring\" \"unpack\"))\n+\n+; TODO: Highlight builtin methods (`table.unpack`, etc) as @function.builtin\n+([\n+  (symbol) @module.builtin\n+  (multi_symbol\n+    base: (symbol_fragment) @module.builtin)\n+]\n+  (#any-of? @module.builtin\n+    \"vim\" \"_G\" \"_ENV\" \"debug\" \"io\" \"jit\" \"math\" \"os\" \"package\" \"string\" \"table\" \"utf8\"))\n+\n+([\n+  (symbol) @variable.builtin\n+  (multi_symbol\n+    .\n+    (symbol_fragment) @variable.builtin)\n+]\n+  (#eq? @variable.builtin \"arg\"))\n+(symbol_option) @keyword.directive\n+\n+(escape_sequence) @string.escape\n+\n+(multi_symbol\n+  \".\" @punctuation.delimiter\n+  member: (symbol_fragment) @variable.member)\n+\n+(list\n+  call: (symbol) @function.call)\n+\n+(list\n+  call: (multi_symbol\n+    member: (symbol_fragment) @function.call .))\n+\n+(multi_symbol_method\n+  \":\" @punctuation.delimiter\n+  method: (symbol_fragment) @function.method.call)",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2027460880",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13260,
        "pr_file": "runtime/queries/fennel/highlights.scm",
        "discussion_id": "2027460880",
        "commented_code": "@@ -0,0 +1,196 @@\n+; Most primitive nodes\n+(shebang) @keyword.directive\n+\n+(comment) @comment @spell\n+\n+(fn_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+(lambda_form\n+  name: [\n+    (symbol) @function\n+    (multi_symbol\n+      member: (symbol_fragment) @function .)\n+  ])\n+\n+((symbol) @operator\n+  (#any-of? @operator\n+    ; arithmetic\n+    \"+\" \"-\" \"*\" \"/\" \"//\" \"%\" \"^\"\n+    ; comparison\n+    \">\" \"<\" \">=\" \"<=\" \"=\" \"~=\"\n+    ; other\n+    \"#\" \".\" \"?.\" \"..\"))\n+\n+((symbol) @keyword.operator\n+  (#any-of? @keyword.operator\n+    ; comparison\n+    \"not=\"\n+    ; boolean\n+    \"and\" \"or\" \"not\"\n+    ; bitwise\n+    \"lshift\" \"rshift\" \"band\" \"bor\" \"bxor\" \"bnot\"\n+    ; other\n+    \"length\"))\n+\n+(case_guard\n+  call: (_) @keyword.conditional)\n+\n+(case_guard_or_special\n+  call: (_) @keyword.conditional)\n+\n+(case_catch\n+  call: (symbol) @keyword)\n+\n+(import_macros_form\n+  imports: (table_binding\n+    (table_binding_pair\n+      value: (symbol_binding) @function.macro)))\n+\n+\n+((symbol) @keyword.function\n+  (#any-of? @keyword.function \"fn\" \"lambda\" \"\u03bb\" \"hashfn\"))\n+\n+((symbol) @keyword.repeat\n+  (#any-of? @keyword.repeat \"for\" \"each\" \"while\"))\n+\n+((symbol) @keyword.conditional\n+  (#any-of? @keyword.conditional \"if\" \"when\" \"match\" \"case\" \"match-try\" \"case-try\"))\n+\n+((symbol) @keyword\n+  (#any-of? @keyword\n+    \"global\" \"local\" \"let\" \"set\" \"var\" \"comment\" \"do\" \"doc\" \"eval-compiler\" \"lua\" \"macros\" \"unquote\"\n+    \"quote\" \"tset\" \"values\" \"tail!\"))\n+\n+((symbol) @keyword.import\n+  (#any-of? @keyword.import \"require\" \"require-macros\" \"import-macros\" \"include\"))\n+\n+((symbol) @function.macro\n+  (#any-of? @function.macro\n+    \"collect\" \"icollect\" \"fcollect\" \"accumulate\" \"faccumulate\" \"->\" \"->>\" \"-?>\" \"-?>>\" \"?.\" \"doto\"\n+    \"macro\" \"macrodebug\" \"partial\" \"pick-args\" \"pick-values\" \"with-open\"))\n+\n+((symbol) @variable.builtin\n+  (#eq? @variable.builtin \"...\"))\n+\n+((symbol) @constant.builtin\n+  (#eq? @constant.builtin \"_VERSION\"))\n+\n+((symbol) @function.builtin\n+  (#any-of? @function.builtin\n+    \"assert\" \"collectgarbage\" \"dofile\" \"error\" \"getmetatable\" \"ipairs\" \"load\" \"loadfile\" \"next\"\n+    \"pairs\" \"pcall\" \"print\" \"rawequal\" \"rawget\" \"rawlen\" \"rawset\" \"require\" \"select\" \"setmetatable\"\n+    \"tonumber\" \"tostring\" \"type\" \"warn\" \"xpcall\" \"module\" \"setfenv\" \"loadstring\" \"unpack\"))\n+\n+; TODO: Highlight builtin methods (`table.unpack`, etc) as @function.builtin\n+([\n+  (symbol) @module.builtin\n+  (multi_symbol\n+    base: (symbol_fragment) @module.builtin)\n+]\n+  (#any-of? @module.builtin\n+    \"vim\" \"_G\" \"_ENV\" \"debug\" \"io\" \"jit\" \"math\" \"os\" \"package\" \"string\" \"table\" \"utf8\"))\n+\n+([\n+  (symbol) @variable.builtin\n+  (multi_symbol\n+    .\n+    (symbol_fragment) @variable.builtin)\n+]\n+  (#eq? @variable.builtin \"arg\"))\n+(symbol_option) @keyword.directive\n+\n+(escape_sequence) @string.escape\n+\n+(multi_symbol\n+  \".\" @punctuation.delimiter\n+  member: (symbol_fragment) @variable.member)\n+\n+(list\n+  call: (symbol) @function.call)\n+\n+(list\n+  call: (multi_symbol\n+    member: (symbol_fragment) @function.call .))\n+\n+(multi_symbol_method\n+  \":\" @punctuation.delimiter\n+  method: (symbol_fragment) @function.method.call)",
        "comment_created_at": "2025-04-03T17:31:21+00:00",
        "comment_author": "uncenter",
        "comment_body": "```suggestion\r\n(list\r\n  call: (symbol) @function)\r\n\r\n(list\r\n  call: (multi_symbol\r\n    member: (symbol_fragment) @function .))\r\n\r\n(multi_symbol_method\r\n  \":\" @punctuation.delimiter\r\n  method: (symbol_fragment) @function.method)\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1740134717",
    "pr_number": 11611,
    "pr_file": "runtime/queries/prolog/highlights.scm",
    "created_at": "2024-09-01T14:58:02+00:00",
    "commented_code": null,
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1740134717",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11611,
        "pr_file": "runtime/queries/prolog/highlights.scm",
        "discussion_id": "1740134717",
        "commented_code": null,
        "comment_created_at": "2024-09-01T14:58:02+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "The captures need some tweaks to match the scopes we use: https://docs.helix-editor.com/master/themes.html#syntax-highlighting\r\n\r\nFor example `boolean` should be `constant.builtin.boolean`, `number` should be `constant.numeric.integer` or `constant.numeric.float`",
        "pr_file_module": null
      },
      {
        "comment_id": "2004796244",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11611,
        "pr_file": "runtime/queries/prolog/highlights.scm",
        "discussion_id": "1740134717",
        "commented_code": null,
        "comment_created_at": "2025-03-20T04:32:36+00:00",
        "comment_author": "mkorje",
        "comment_body": "I think I've fixed them all.",
        "pr_file_module": null
      },
      {
        "comment_id": "2004896139",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11611,
        "pr_file": "runtime/queries/prolog/highlights.scm",
        "discussion_id": "1740134717",
        "commented_code": null,
        "comment_created_at": "2025-03-20T06:18:33+00:00",
        "comment_author": "mkorje",
        "comment_body": "Though looking at some prolog code the highlighting is fairly incomplete still. I'll have a look at improving this.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2027619669",
    "pr_number": 11611,
    "pr_file": "runtime/queries/prolog/highlights.scm",
    "created_at": "2025-04-03T19:32:04+00:00",
    "commented_code": "+(comment) @comment @spell\n+\n+(atom) @constant\n+\n+((atom) @constant.builtin.boolean\n+  (#eq? @constant.builtin.boolean \"true\"))\n+\n+((atom) @constant.builtin.boolean\n+  (#eq? @constant.builtin.boolean \"false\"))",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2027619669",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11611,
        "pr_file": "runtime/queries/prolog/highlights.scm",
        "discussion_id": "2027619669",
        "commented_code": "@@ -0,0 +1,46 @@\n+(comment) @comment @spell\n+\n+(atom) @constant\n+\n+((atom) @constant.builtin.boolean\n+  (#eq? @constant.builtin.boolean \"true\"))\n+\n+((atom) @constant.builtin.boolean\n+  (#eq? @constant.builtin.boolean \"false\"))",
        "comment_created_at": "2025-04-03T19:32:04+00:00",
        "comment_author": "uncenter",
        "comment_body": "```suggestion\r\n((atom) @constant.builtin.boolean\r\n  (#any-of? @constant.builtin.boolean \"true\" \"false\"))\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1991647454",
    "pr_number": 13081,
    "pr_file": "runtime/queries/tlaplus/highlights.scm",
    "created_at": "2025-03-12T14:37:23+00:00",
    "commented_code": "+; ; Intended for consumption by GitHub and the tree-sitter highlight command\n+; ; Default capture names found here:\n+; ; https://github.com/tree-sitter/tree-sitter/blob/f5d1c0b8609f8697861eab352ead44916c068c74/cli/src/highlight.rs#L150-L171\n+; ; In this file, captures defined earlier take precedence over captures defined later.\n+\n+; TLA\u207a Keywords\n+[\n+  \"ACTION\"\n+  \"ASSUME\"\n+  \"ASSUMPTION\"\n+  \"AXIOM\"\n+  \"BY\"\n+  \"CASE\"\n+  \"CHOOSE\"\n+  \"CONSTANT\"\n+  \"CONSTANTS\"\n+  \"COROLLARY\"\n+  \"DEF\"\n+  \"DEFINE\"\n+  \"DEFS\"\n+  \"ELSE\"\n+  \"EXCEPT\"\n+  \"EXTENDS\"\n+  \"HAVE\"\n+  \"HIDE\"\n+  \"IF\"\n+  \"IN\"\n+  \"INSTANCE\"\n+  \"LAMBDA\"\n+  \"LEMMA\"\n+  \"LET\"\n+  \"LOCAL\"\n+  \"MODULE\"\n+  \"NEW\"\n+  \"OBVIOUS\"\n+  \"OMITTED\"\n+  \"ONLY\"\n+  \"OTHER\"\n+  \"PICK\"\n+  \"PROOF\"\n+  \"PROPOSITION\"\n+  \"PROVE\"\n+  \"QED\"\n+  \"RECURSIVE\"\n+  \"SF_\"\n+  \"STATE\"\n+  \"SUFFICES\"\n+  \"TAKE\"\n+  \"TEMPORAL\"\n+  \"THEN\"\n+  \"THEOREM\"\n+  \"USE\"\n+  \"VARIABLE\"\n+  \"VARIABLES\"\n+  \"WF_\"\n+  \"WITH\"\n+  \"WITNESS\"\n+  (address)\n+  (all_map_to)\n+  (assign)\n+  (case_arrow)\n+  (case_box)\n+  (def_eq)\n+  (exists)\n+  (forall)\n+  (gets)\n+  (label_as)\n+  (maps_to)\n+  (set_in)\n+  (temporal_exists)\n+  (temporal_forall)\n+] @keyword\n+\n+;  PlusCal keywords\n+[\n+  \"algorithm\"\n+  \"assert\"\n+  \"await\"\n+  \"begin\"\n+  \"call\"\n+  \"define\"\n+  \"either\"\n+  \"else\"\n+  \"elsif\"\n+  \"end\"\n+  \"fair\"\n+  \"goto\"\n+  \"if\"\n+  \"macro\"\n+  \"or\"\n+  \"print\"\n+  \"procedure\"\n+  \"process\"\n+  \"variable\"\n+  \"variables\"\n+  \"when\"\n+  \"with\"\n+  \"then\"\n+  (pcal_algorithm_start)\n+  (pcal_end_either)\n+  (pcal_end_if)\n+  (pcal_return)\n+  (pcal_skip)\n+  (pcal_process (\"=\"))\n+  (pcal_with (\"=\"))\n+] @keyword\n+\n+; Literals\n+(binary_number (format) @keyword)\n+(binary_number (value) @number)",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1991647454",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13081,
        "pr_file": "runtime/queries/tlaplus/highlights.scm",
        "discussion_id": "1991647454",
        "commented_code": "@@ -0,0 +1,235 @@\n+; ; Intended for consumption by GitHub and the tree-sitter highlight command\n+; ; Default capture names found here:\n+; ; https://github.com/tree-sitter/tree-sitter/blob/f5d1c0b8609f8697861eab352ead44916c068c74/cli/src/highlight.rs#L150-L171\n+; ; In this file, captures defined earlier take precedence over captures defined later.\n+\n+; TLA\u207a Keywords\n+[\n+  \"ACTION\"\n+  \"ASSUME\"\n+  \"ASSUMPTION\"\n+  \"AXIOM\"\n+  \"BY\"\n+  \"CASE\"\n+  \"CHOOSE\"\n+  \"CONSTANT\"\n+  \"CONSTANTS\"\n+  \"COROLLARY\"\n+  \"DEF\"\n+  \"DEFINE\"\n+  \"DEFS\"\n+  \"ELSE\"\n+  \"EXCEPT\"\n+  \"EXTENDS\"\n+  \"HAVE\"\n+  \"HIDE\"\n+  \"IF\"\n+  \"IN\"\n+  \"INSTANCE\"\n+  \"LAMBDA\"\n+  \"LEMMA\"\n+  \"LET\"\n+  \"LOCAL\"\n+  \"MODULE\"\n+  \"NEW\"\n+  \"OBVIOUS\"\n+  \"OMITTED\"\n+  \"ONLY\"\n+  \"OTHER\"\n+  \"PICK\"\n+  \"PROOF\"\n+  \"PROPOSITION\"\n+  \"PROVE\"\n+  \"QED\"\n+  \"RECURSIVE\"\n+  \"SF_\"\n+  \"STATE\"\n+  \"SUFFICES\"\n+  \"TAKE\"\n+  \"TEMPORAL\"\n+  \"THEN\"\n+  \"THEOREM\"\n+  \"USE\"\n+  \"VARIABLE\"\n+  \"VARIABLES\"\n+  \"WF_\"\n+  \"WITH\"\n+  \"WITNESS\"\n+  (address)\n+  (all_map_to)\n+  (assign)\n+  (case_arrow)\n+  (case_box)\n+  (def_eq)\n+  (exists)\n+  (forall)\n+  (gets)\n+  (label_as)\n+  (maps_to)\n+  (set_in)\n+  (temporal_exists)\n+  (temporal_forall)\n+] @keyword\n+\n+;  PlusCal keywords\n+[\n+  \"algorithm\"\n+  \"assert\"\n+  \"await\"\n+  \"begin\"\n+  \"call\"\n+  \"define\"\n+  \"either\"\n+  \"else\"\n+  \"elsif\"\n+  \"end\"\n+  \"fair\"\n+  \"goto\"\n+  \"if\"\n+  \"macro\"\n+  \"or\"\n+  \"print\"\n+  \"procedure\"\n+  \"process\"\n+  \"variable\"\n+  \"variables\"\n+  \"when\"\n+  \"with\"\n+  \"then\"\n+  (pcal_algorithm_start)\n+  (pcal_end_either)\n+  (pcal_end_if)\n+  (pcal_return)\n+  (pcal_skip)\n+  (pcal_process (\"=\"))\n+  (pcal_with (\"=\"))\n+] @keyword\n+\n+; Literals\n+(binary_number (format) @keyword)\n+(binary_number (value) @number)",
        "comment_created_at": "2025-03-12T14:37:23+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "Some of the captures in this file will need to be adapted to the ones we use: https://docs.helix-editor.com/master/themes.html#syntax-highlighting\r\n\r\nFor example `@number` should become `@constant.numeric` and `@module` should become `@namespace`",
        "pr_file_module": null
      },
      {
        "comment_id": "1993315330",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13081,
        "pr_file": "runtime/queries/tlaplus/highlights.scm",
        "discussion_id": "1991647454",
        "commented_code": "@@ -0,0 +1,235 @@\n+; ; Intended for consumption by GitHub and the tree-sitter highlight command\n+; ; Default capture names found here:\n+; ; https://github.com/tree-sitter/tree-sitter/blob/f5d1c0b8609f8697861eab352ead44916c068c74/cli/src/highlight.rs#L150-L171\n+; ; In this file, captures defined earlier take precedence over captures defined later.\n+\n+; TLA\u207a Keywords\n+[\n+  \"ACTION\"\n+  \"ASSUME\"\n+  \"ASSUMPTION\"\n+  \"AXIOM\"\n+  \"BY\"\n+  \"CASE\"\n+  \"CHOOSE\"\n+  \"CONSTANT\"\n+  \"CONSTANTS\"\n+  \"COROLLARY\"\n+  \"DEF\"\n+  \"DEFINE\"\n+  \"DEFS\"\n+  \"ELSE\"\n+  \"EXCEPT\"\n+  \"EXTENDS\"\n+  \"HAVE\"\n+  \"HIDE\"\n+  \"IF\"\n+  \"IN\"\n+  \"INSTANCE\"\n+  \"LAMBDA\"\n+  \"LEMMA\"\n+  \"LET\"\n+  \"LOCAL\"\n+  \"MODULE\"\n+  \"NEW\"\n+  \"OBVIOUS\"\n+  \"OMITTED\"\n+  \"ONLY\"\n+  \"OTHER\"\n+  \"PICK\"\n+  \"PROOF\"\n+  \"PROPOSITION\"\n+  \"PROVE\"\n+  \"QED\"\n+  \"RECURSIVE\"\n+  \"SF_\"\n+  \"STATE\"\n+  \"SUFFICES\"\n+  \"TAKE\"\n+  \"TEMPORAL\"\n+  \"THEN\"\n+  \"THEOREM\"\n+  \"USE\"\n+  \"VARIABLE\"\n+  \"VARIABLES\"\n+  \"WF_\"\n+  \"WITH\"\n+  \"WITNESS\"\n+  (address)\n+  (all_map_to)\n+  (assign)\n+  (case_arrow)\n+  (case_box)\n+  (def_eq)\n+  (exists)\n+  (forall)\n+  (gets)\n+  (label_as)\n+  (maps_to)\n+  (set_in)\n+  (temporal_exists)\n+  (temporal_forall)\n+] @keyword\n+\n+;  PlusCal keywords\n+[\n+  \"algorithm\"\n+  \"assert\"\n+  \"await\"\n+  \"begin\"\n+  \"call\"\n+  \"define\"\n+  \"either\"\n+  \"else\"\n+  \"elsif\"\n+  \"end\"\n+  \"fair\"\n+  \"goto\"\n+  \"if\"\n+  \"macro\"\n+  \"or\"\n+  \"print\"\n+  \"procedure\"\n+  \"process\"\n+  \"variable\"\n+  \"variables\"\n+  \"when\"\n+  \"with\"\n+  \"then\"\n+  (pcal_algorithm_start)\n+  (pcal_end_either)\n+  (pcal_end_if)\n+  (pcal_return)\n+  (pcal_skip)\n+  (pcal_process (\"=\"))\n+  (pcal_with (\"=\"))\n+] @keyword\n+\n+; Literals\n+(binary_number (format) @keyword)\n+(binary_number (value) @number)",
        "comment_created_at": "2025-03-13T11:23:24+00:00",
        "comment_author": "Ciflire",
        "comment_body": "I believe it should be good now, please tell me if there are any left that i missed.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1942156325",
    "pr_number": 12777,
    "pr_file": "runtime/queries/zig/highlights.scm",
    "created_at": "2025-02-05T02:17:59+00:00",
    "commented_code": "\"threadlocal\"\n ] @keyword.storage.modifier\n \n-; Builtins\n+; Operator\n \n [\n-  \"c\"\n-  \"...\"\n-] @variable.builtin\n-\n-((identifier) @variable.builtin\n-  (#eq? @variable.builtin \"_\"))\n-\n-(calling_convention\n-  (identifier) @variable.builtin)\n-\n-; Modules\n-\n-(variable_declaration\n-  (identifier) @variable ; TODO: module\n-  (builtin_function\n-    (builtin_identifier) @keyword.control.import\n-    (#any-of? @keyword.control.import \"@import\" \"@cImport\")))\n-\n-(variable_declaration\n-  (identifier) @variable ; TODO: module\n-  (field_expression\n-    object: (builtin_function\n-      (builtin_identifier) @keyword.control.import\n-      (#any-of? @keyword.control.import \"@import\" \"@cImport\"))))\n-\n-; Functions\n-\n-(call_expression\n-  function: (field_expression\n-    member: (identifier) @function.method))\n-\n-(call_expression\n-  function: (identifier) @function)\n-\n-(function_declaration\n-  name: (identifier) @function)\n-\n-(builtin_identifier) @function.builtin\n-\n-; Fields\n-\n-(field_initializer\n-  .\n-  (identifier) @variable.other.member)\n-\n-(field_expression\n-  (_)\n-  member: (identifier) @type (#match? @type \"^[A-Z_][a-zA-Z0-9_]*\"))\n-\n-(field_expression\n-  (_)\n-  member: (identifier) @variable.other.member)\n-\n-(container_field\n-  name: (identifier) @variable.other.member)\n-\n-(initializer_list\n-  (assignment_expression\n-      left: (field_expression\n-              .\n-              member: (identifier) @variable.other.member)))\n-\n-; Labels\n-\n-(block_label (identifier) @label)\n-\n-(break_label (identifier) @label)\n+  \"=\"\n+  \"*=\"\n+  \"*%=\"\n+  \"*|=\"\n+  \"/=\"\n+  \"%=\"\n+  \"+=\"\n+  \"+%=\"\n+  \"+|=\"\n+  \"-=\"\n+  \"-%=\"\n+  \"-|=\"\n+  \"<<=\"\n+  \"<<|=\"\n+  \">>=\"\n+  \"&=\"\n+  \"^=\"\n+  \"|=\"\n+  \"!\"\n+  \"~\"\n+  \"-\"\n+  \"-%\"\n+  \"&\"\n+  \"==\"\n+  \"!=\"\n+  \">\"\n+  \">=\"\n+  \"<=\"\n+  \"<\"\n+  \"&\"\n+  \"^\"\n+  \"|\"\n+  \"<<\"\n+  \">>\"\n+  \"<<|\"\n+  \"+\"\n+  \"++\"\n+  \"+%\"\n+  \"-%\"\n+  \"+|\"\n+  \"-|\"\n+  \"*\"\n+  \"/\"\n+  \"%\"\n+  \"**\"\n+  \"*%\"\n+  \"*|\"\n+  \"||\"\n+  \".*\"\n+  \".?\"\n+  \"?\"\n+  \"..\"\n+] @operator\n \n-; Constants\n+; Literals\n \n-((identifier) @constant\n-  (#match? @constant \"^[A-Z][A-Z_0-9]+$\"))\n+(character) @constant.character\n \n [\n-  \"null\"\n-  \"undefined\"\n-] @constant.builtin\n+  (string)\n+  (multiline_string)\n+] @string\n \n-(field_expression\n-  .\n-  member: (identifier) @constant)\n+(integer) @constant.numeric.integer\n \n-(enum_declaration\n-  (container_field\n-    type: (identifier) @constant))\n+(float) @constant.numeric.float\n \n-; Types\n+(boolean) @constant.builtin.boolean\n \n-(parameter\n-  type: (identifier) @type)\n+(escape_sequence) @constant.character.escape\n \n-((identifier) @type\n-  (#match? @type \"^[A-Z_][a-zA-Z0-9_]*\"))\n+; Punctuation\n \n-(variable_declaration\n-  (identifier) @type\n-  \"=\"\n-  [\n-    (struct_declaration)\n-    (enum_declaration)\n-    (union_declaration)\n-    (opaque_declaration)\n-  ])\n+[\n+  \"[\"\n+  \"]\"\n+  \"(\"\n+  \")\"\n+  \"{\"\n+  \"}\"\n+] @punctuation.bracket\n \n [\n-  (builtin_type)\n-  \"anyframe\"\n-] @type.builtin\n+  \";\"\n+  \".\"\n+  \",\"\n+  \":\"\n+  \"=>\"\n+  \"->\"\n+] @punctuation.delimiter\n \n-; Parameters\n+(payload \"|\" @punctuation.bracket)\n \n-(parameter\n-  name: (identifier) @variable.parameter)\n+; Comments\n \n-; Variables\n+((comment) @comment.block.documentation\n+  (#match? @comment.block.documentation \"^//!\"))\n \n-(identifier) @variable\n+(comment) @comment.line",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1942156325",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12777,
        "pr_file": "runtime/queries/zig/highlights.scm",
        "discussion_id": "1942156325",
        "commented_code": "@@ -182,123 +210,105 @@\n   \"threadlocal\"\n ] @keyword.storage.modifier\n \n-; Builtins\n+; Operator\n \n [\n-  \"c\"\n-  \"...\"\n-] @variable.builtin\n-\n-((identifier) @variable.builtin\n-  (#eq? @variable.builtin \"_\"))\n-\n-(calling_convention\n-  (identifier) @variable.builtin)\n-\n-; Modules\n-\n-(variable_declaration\n-  (identifier) @variable ; TODO: module\n-  (builtin_function\n-    (builtin_identifier) @keyword.control.import\n-    (#any-of? @keyword.control.import \"@import\" \"@cImport\")))\n-\n-(variable_declaration\n-  (identifier) @variable ; TODO: module\n-  (field_expression\n-    object: (builtin_function\n-      (builtin_identifier) @keyword.control.import\n-      (#any-of? @keyword.control.import \"@import\" \"@cImport\"))))\n-\n-; Functions\n-\n-(call_expression\n-  function: (field_expression\n-    member: (identifier) @function.method))\n-\n-(call_expression\n-  function: (identifier) @function)\n-\n-(function_declaration\n-  name: (identifier) @function)\n-\n-(builtin_identifier) @function.builtin\n-\n-; Fields\n-\n-(field_initializer\n-  .\n-  (identifier) @variable.other.member)\n-\n-(field_expression\n-  (_)\n-  member: (identifier) @type (#match? @type \"^[A-Z_][a-zA-Z0-9_]*\"))\n-\n-(field_expression\n-  (_)\n-  member: (identifier) @variable.other.member)\n-\n-(container_field\n-  name: (identifier) @variable.other.member)\n-\n-(initializer_list\n-  (assignment_expression\n-      left: (field_expression\n-              .\n-              member: (identifier) @variable.other.member)))\n-\n-; Labels\n-\n-(block_label (identifier) @label)\n-\n-(break_label (identifier) @label)\n+  \"=\"\n+  \"*=\"\n+  \"*%=\"\n+  \"*|=\"\n+  \"/=\"\n+  \"%=\"\n+  \"+=\"\n+  \"+%=\"\n+  \"+|=\"\n+  \"-=\"\n+  \"-%=\"\n+  \"-|=\"\n+  \"<<=\"\n+  \"<<|=\"\n+  \">>=\"\n+  \"&=\"\n+  \"^=\"\n+  \"|=\"\n+  \"!\"\n+  \"~\"\n+  \"-\"\n+  \"-%\"\n+  \"&\"\n+  \"==\"\n+  \"!=\"\n+  \">\"\n+  \">=\"\n+  \"<=\"\n+  \"<\"\n+  \"&\"\n+  \"^\"\n+  \"|\"\n+  \"<<\"\n+  \">>\"\n+  \"<<|\"\n+  \"+\"\n+  \"++\"\n+  \"+%\"\n+  \"-%\"\n+  \"+|\"\n+  \"-|\"\n+  \"*\"\n+  \"/\"\n+  \"%\"\n+  \"**\"\n+  \"*%\"\n+  \"*|\"\n+  \"||\"\n+  \".*\"\n+  \".?\"\n+  \"?\"\n+  \"..\"\n+] @operator\n \n-; Constants\n+; Literals\n \n-((identifier) @constant\n-  (#match? @constant \"^[A-Z][A-Z_0-9]+$\"))\n+(character) @constant.character\n \n [\n-  \"null\"\n-  \"undefined\"\n-] @constant.builtin\n+  (string)\n+  (multiline_string)\n+] @string\n \n-(field_expression\n-  .\n-  member: (identifier) @constant)\n+(integer) @constant.numeric.integer\n \n-(enum_declaration\n-  (container_field\n-    type: (identifier) @constant))\n+(float) @constant.numeric.float\n \n-; Types\n+(boolean) @constant.builtin.boolean\n \n-(parameter\n-  type: (identifier) @type)\n+(escape_sequence) @constant.character.escape\n \n-((identifier) @type\n-  (#match? @type \"^[A-Z_][a-zA-Z0-9_]*\"))\n+; Punctuation\n \n-(variable_declaration\n-  (identifier) @type\n-  \"=\"\n-  [\n-    (struct_declaration)\n-    (enum_declaration)\n-    (union_declaration)\n-    (opaque_declaration)\n-  ])\n+[\n+  \"[\"\n+  \"]\"\n+  \"(\"\n+  \")\"\n+  \"{\"\n+  \"}\"\n+] @punctuation.bracket\n \n [\n-  (builtin_type)\n-  \"anyframe\"\n-] @type.builtin\n+  \";\"\n+  \".\"\n+  \",\"\n+  \":\"\n+  \"=>\"\n+  \"->\"\n+] @punctuation.delimiter\n \n-; Parameters\n+(payload \"|\" @punctuation.bracket)\n \n-(parameter\n-  name: (identifier) @variable.parameter)\n+; Comments\n \n-; Variables\n+((comment) @comment.block.documentation\n+  (#match? @comment.block.documentation \"^//!\"))\n \n-(identifier) @variable\n+(comment) @comment.line",
        "comment_created_at": "2025-02-05T02:17:59+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "I think these two should be reversed? Now the less specific highlight should be higher in the file - I think `comment.line` will always overwrite `comment.block.documentation` here",
        "pr_file_module": null
      },
      {
        "comment_id": "1942157861",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12777,
        "pr_file": "runtime/queries/zig/highlights.scm",
        "discussion_id": "1942156325",
        "commented_code": "@@ -182,123 +210,105 @@\n   \"threadlocal\"\n ] @keyword.storage.modifier\n \n-; Builtins\n+; Operator\n \n [\n-  \"c\"\n-  \"...\"\n-] @variable.builtin\n-\n-((identifier) @variable.builtin\n-  (#eq? @variable.builtin \"_\"))\n-\n-(calling_convention\n-  (identifier) @variable.builtin)\n-\n-; Modules\n-\n-(variable_declaration\n-  (identifier) @variable ; TODO: module\n-  (builtin_function\n-    (builtin_identifier) @keyword.control.import\n-    (#any-of? @keyword.control.import \"@import\" \"@cImport\")))\n-\n-(variable_declaration\n-  (identifier) @variable ; TODO: module\n-  (field_expression\n-    object: (builtin_function\n-      (builtin_identifier) @keyword.control.import\n-      (#any-of? @keyword.control.import \"@import\" \"@cImport\"))))\n-\n-; Functions\n-\n-(call_expression\n-  function: (field_expression\n-    member: (identifier) @function.method))\n-\n-(call_expression\n-  function: (identifier) @function)\n-\n-(function_declaration\n-  name: (identifier) @function)\n-\n-(builtin_identifier) @function.builtin\n-\n-; Fields\n-\n-(field_initializer\n-  .\n-  (identifier) @variable.other.member)\n-\n-(field_expression\n-  (_)\n-  member: (identifier) @type (#match? @type \"^[A-Z_][a-zA-Z0-9_]*\"))\n-\n-(field_expression\n-  (_)\n-  member: (identifier) @variable.other.member)\n-\n-(container_field\n-  name: (identifier) @variable.other.member)\n-\n-(initializer_list\n-  (assignment_expression\n-      left: (field_expression\n-              .\n-              member: (identifier) @variable.other.member)))\n-\n-; Labels\n-\n-(block_label (identifier) @label)\n-\n-(break_label (identifier) @label)\n+  \"=\"\n+  \"*=\"\n+  \"*%=\"\n+  \"*|=\"\n+  \"/=\"\n+  \"%=\"\n+  \"+=\"\n+  \"+%=\"\n+  \"+|=\"\n+  \"-=\"\n+  \"-%=\"\n+  \"-|=\"\n+  \"<<=\"\n+  \"<<|=\"\n+  \">>=\"\n+  \"&=\"\n+  \"^=\"\n+  \"|=\"\n+  \"!\"\n+  \"~\"\n+  \"-\"\n+  \"-%\"\n+  \"&\"\n+  \"==\"\n+  \"!=\"\n+  \">\"\n+  \">=\"\n+  \"<=\"\n+  \"<\"\n+  \"&\"\n+  \"^\"\n+  \"|\"\n+  \"<<\"\n+  \">>\"\n+  \"<<|\"\n+  \"+\"\n+  \"++\"\n+  \"+%\"\n+  \"-%\"\n+  \"+|\"\n+  \"-|\"\n+  \"*\"\n+  \"/\"\n+  \"%\"\n+  \"**\"\n+  \"*%\"\n+  \"*|\"\n+  \"||\"\n+  \".*\"\n+  \".?\"\n+  \"?\"\n+  \"..\"\n+] @operator\n \n-; Constants\n+; Literals\n \n-((identifier) @constant\n-  (#match? @constant \"^[A-Z][A-Z_0-9]+$\"))\n+(character) @constant.character\n \n [\n-  \"null\"\n-  \"undefined\"\n-] @constant.builtin\n+  (string)\n+  (multiline_string)\n+] @string\n \n-(field_expression\n-  .\n-  member: (identifier) @constant)\n+(integer) @constant.numeric.integer\n \n-(enum_declaration\n-  (container_field\n-    type: (identifier) @constant))\n+(float) @constant.numeric.float\n \n-; Types\n+(boolean) @constant.builtin.boolean\n \n-(parameter\n-  type: (identifier) @type)\n+(escape_sequence) @constant.character.escape\n \n-((identifier) @type\n-  (#match? @type \"^[A-Z_][a-zA-Z0-9_]*\"))\n+; Punctuation\n \n-(variable_declaration\n-  (identifier) @type\n-  \"=\"\n-  [\n-    (struct_declaration)\n-    (enum_declaration)\n-    (union_declaration)\n-    (opaque_declaration)\n-  ])\n+[\n+  \"[\"\n+  \"]\"\n+  \"(\"\n+  \")\"\n+  \"{\"\n+  \"}\"\n+] @punctuation.bracket\n \n [\n-  (builtin_type)\n-  \"anyframe\"\n-] @type.builtin\n+  \";\"\n+  \".\"\n+  \",\"\n+  \":\"\n+  \"=>\"\n+  \"->\"\n+] @punctuation.delimiter\n \n-; Parameters\n+(payload \"|\" @punctuation.bracket)\n \n-(parameter\n-  name: (identifier) @variable.parameter)\n+; Comments\n \n-; Variables\n+((comment) @comment.block.documentation\n+  (#match? @comment.block.documentation \"^//!\"))\n \n-(identifier) @variable\n+(comment) @comment.line",
        "comment_created_at": "2025-02-05T02:20:24+00:00",
        "comment_author": "gabydd",
        "comment_body": "ah yeah missed that fixed",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1831867675",
    "pr_number": 11980,
    "pr_file": "runtime/queries/zig/highlights.scm",
    "created_at": "2024-11-06T23:53:56+00:00",
    "commented_code": "-[\n-  (container_doc_comment)\n-  (doc_comment)\n-] @comment.documentation\n+; Comments\n \n-[\n-  (line_comment)\n-] @comment.line\n+((comment) @comment.block.documentation\n+  (#lua-match? @comment.block.documentation \"^//!\"))",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1831867675",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11980,
        "pr_file": "runtime/queries/zig/highlights.scm",
        "discussion_id": "1831867675",
        "commented_code": "@@ -1,231 +1,294 @@\n-[\n-  (container_doc_comment)\n-  (doc_comment)\n-] @comment.documentation\n+; Comments\n \n-[\n-  (line_comment)\n-] @comment.line\n+((comment) @comment.block.documentation\n+  (#lua-match? @comment.block.documentation \"^//!\"))",
        "comment_created_at": "2024-11-06T23:53:56+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "```suggestion\r\n  (#match? @comment.block.documentation \"^//!\"))\r\n```\r\n\r\n`#lua-match?` is neovim specific but this regex will work for `#match?`",
        "pr_file_module": null
      }
    ]
  }
]