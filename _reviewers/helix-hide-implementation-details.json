[
  {
    "discussion_id": "1390498408",
    "pr_number": 8675,
    "pr_file": "helix-term/src/commands/engine/scheme.rs",
    "created_at": "2023-11-12T22:42:07+00:00",
    "commented_code": "+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1390498408",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390498408",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(",
        "comment_created_at": "2023-11-12T22:42:07+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "update is really only meant for live previews. I don't think we need to expose it to plugins. This would make the API a lot easier to use and removes the need to duplicate typable commands.\r\n\r\nIn general I would prefer to not expose implementation details like this. Instead of having the mindest of: What does helix look like internally lets create an API for that. We should look at it from the perspective of: What should a scripting API ideally look like (and make the internals work to fit that API within reason)",
        "pr_file_module": null
      },
      {
        "comment_id": "1430665518",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390498408",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(",
        "comment_created_at": "2023-12-18T21:29:34+00:00",
        "comment_author": "mattwparas",
        "comment_body": "To explain some context - at the time of writing originally, I did not quite understand the nuance between `Update` and `Validate` - but what you're saying makes sense.\r\n\r\nI think all of the functions exposed to the plugin will just have `PromptEvent::Validate` as the third argument baked in, that way we won't have to pass that around everywhere.",
        "pr_file_module": null
      },
      {
        "comment_id": "1495236454",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390498408",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(",
        "comment_created_at": "2024-02-20T04:42:04+00:00",
        "comment_author": "mattwparas",
        "comment_body": "Update - validate is baked in, the API doesn't expose this",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1390500250",
    "pr_number": 8675,
    "pr_file": "helix-term/src/commands/engine/scheme.rs",
    "created_at": "2023-11-12T22:53:58+00:00",
    "commented_code": "+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1390500250",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390500250",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);",
        "comment_created_at": "2023-11-12T22:53:58+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "we already have `swap_view_right` bultin commands. \r\n\r\nThis command is the same if ther are only two splits (and if there aren't its sort of odd what about moving it the to the middle and so forth).\r\n\r\nIf equivalent functionality doesn't exist in helix yet I would prefer to not add them in this PR and instead do that seperatly. There is probablby a discussion about naming (split/view vs window) here and also a question whether it wouldn't be better to make the existing builtin commands return a bool somehow (so you could write to loop you wrote here in userspace)",
        "pr_file_module": null
      },
      {
        "comment_id": "1430666019",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390500250",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);",
        "comment_created_at": "2023-12-18T21:30:15+00:00",
        "comment_author": "mattwparas",
        "comment_body": "Agreed - I'll take this out, was a proof of concept - I like the idea of exposing the built ins to have the boolean so this can be implemented outside of rust",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1390500504",
    "pr_number": 8675,
    "pr_file": "helix-term/src/commands/engine/scheme.rs",
    "created_at": "2023-11-12T22:55:05+00:00",
    "commented_code": "+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(\n+        \"PromptEvent::Update\",\n+        PromptEvent::Update.into_steelval().unwrap(),\n+    );\n+\n+    // Register everything in the typable command list. Now these are all available\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_editor_api(engine: &mut Engine, _api: EditorApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/editor\");\n+\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper7<(\n+            Context<'_>,\n+            helix_view::Editor,\n+            helix_view::Editor,\n+            Context<'static>,\n+        )>,\n+        helix_view::Editor,\n+    >::register_fn(&mut module, \"cx-editor!\", get_editor);\n+\n+    module.register_fn(\"set-scratch-buffer-name!\", set_scratch_buffer_name);\n+\n+    module.register_fn(\"editor-focus\", current_focus);\n+    module.register_fn(\"editor->doc-id\", get_document_id);\n+    module.register_fn(\"doc-id->usize\", document_id_to_usize);",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1390500504",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390500504",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(\n+        \"PromptEvent::Update\",\n+        PromptEvent::Update.into_steelval().unwrap(),\n+    );\n+\n+    // Register everything in the typable command list. Now these are all available\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_editor_api(engine: &mut Engine, _api: EditorApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/editor\");\n+\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper7<(\n+            Context<'_>,\n+            helix_view::Editor,\n+            helix_view::Editor,\n+            Context<'static>,\n+        )>,\n+        helix_view::Editor,\n+    >::register_fn(&mut module, \"cx-editor!\", get_editor);\n+\n+    module.register_fn(\"set-scratch-buffer-name!\", set_scratch_buffer_name);\n+\n+    module.register_fn(\"editor-focus\", current_focus);\n+    module.register_fn(\"editor->doc-id\", get_document_id);\n+    module.register_fn(\"doc-id->usize\", document_id_to_usize);",
        "comment_created_at": "2023-11-12T22:55:05+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "this is an implementation detail I would definitly not want to expose. Either we expose that document ids are numbers and only return them as such (with the note that IDs are absolutly not stable and can not be relied upon and may even be reused in a singel session) or only as an opaque type",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1390519327",
    "pr_number": 8675,
    "pr_file": "helix-term/src/commands/engine/scheme.rs",
    "created_at": "2023-11-13T00:31:00+00:00",
    "commented_code": "+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(\n+        \"PromptEvent::Update\",\n+        PromptEvent::Update.into_steelval().unwrap(),\n+    );\n+\n+    // Register everything in the typable command list. Now these are all available\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_editor_api(engine: &mut Engine, _api: EditorApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/editor\");\n+\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper7<(\n+            Context<'_>,\n+            helix_view::Editor,\n+            helix_view::Editor,\n+            Context<'static>,\n+        )>,\n+        helix_view::Editor,\n+    >::register_fn(&mut module, \"cx-editor!\", get_editor);\n+\n+    module.register_fn(\"set-scratch-buffer-name!\", set_scratch_buffer_name);\n+\n+    module.register_fn(\"editor-focus\", current_focus);\n+    module.register_fn(\"editor->doc-id\", get_document_id);\n+    module.register_fn(\"doc-id->usize\", document_id_to_usize);\n+    module.register_fn(\"editor-switch!\", switch);\n+    module.register_fn(\"editor-set-focus!\", Editor::focus);\n+    module.register_fn(\"editor-mode\", editor_get_mode);\n+    module.register_fn(\"editor-set-mode!\", editor_set_mode);\n+    module.register_fn(\"editor-doc-in-view?\", is_document_in_view);\n+\n+    // TODO: These are some horrendous type annotations, however... they do work.\n+    // If the type annotations are a bit more ergonomic, we might be able to get away with this\n+    // (i.e. if they're sensible enough)\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper8<(\n+            helix_view::Editor,\n+            DocumentId,\n+            Document,\n+            Document,\n+            helix_view::Editor,\n+        )>,\n+        Document,\n+    >::register_fn(&mut module, \"editor->get-document\", get_document);\n+\n+    // Check if the doc exists first\n+    module.register_fn(\"editor-doc-exists?\", document_exists);\n+    module.register_fn(\"Document-path\", document_path);\n+    module.register_fn(\"Document-focused-at\", document_focused_at);\n+    module.register_fn(\"editor-all-documents\", editor_all_documents);\n+\n+    module.register_fn(\"helix.context?\", is_context);\n+    module.register_type::<DocumentId>(\"DocumentId?\");\n+\n+    module.register_fn(\"editor-cursor\", Editor::cursor);\n+\n+    module.register_fn(\"cx->cursor\", |cx: &mut Context| cx.editor.cursor());",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1390519327",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390519327",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(\n+        \"PromptEvent::Update\",\n+        PromptEvent::Update.into_steelval().unwrap(),\n+    );\n+\n+    // Register everything in the typable command list. Now these are all available\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_editor_api(engine: &mut Engine, _api: EditorApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/editor\");\n+\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper7<(\n+            Context<'_>,\n+            helix_view::Editor,\n+            helix_view::Editor,\n+            Context<'static>,\n+        )>,\n+        helix_view::Editor,\n+    >::register_fn(&mut module, \"cx-editor!\", get_editor);\n+\n+    module.register_fn(\"set-scratch-buffer-name!\", set_scratch_buffer_name);\n+\n+    module.register_fn(\"editor-focus\", current_focus);\n+    module.register_fn(\"editor->doc-id\", get_document_id);\n+    module.register_fn(\"doc-id->usize\", document_id_to_usize);\n+    module.register_fn(\"editor-switch!\", switch);\n+    module.register_fn(\"editor-set-focus!\", Editor::focus);\n+    module.register_fn(\"editor-mode\", editor_get_mode);\n+    module.register_fn(\"editor-set-mode!\", editor_set_mode);\n+    module.register_fn(\"editor-doc-in-view?\", is_document_in_view);\n+\n+    // TODO: These are some horrendous type annotations, however... they do work.\n+    // If the type annotations are a bit more ergonomic, we might be able to get away with this\n+    // (i.e. if they're sensible enough)\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper8<(\n+            helix_view::Editor,\n+            DocumentId,\n+            Document,\n+            Document,\n+            helix_view::Editor,\n+        )>,\n+        Document,\n+    >::register_fn(&mut module, \"editor->get-document\", get_document);\n+\n+    // Check if the doc exists first\n+    module.register_fn(\"editor-doc-exists?\", document_exists);\n+    module.register_fn(\"Document-path\", document_path);\n+    module.register_fn(\"Document-focused-at\", document_focused_at);\n+    module.register_fn(\"editor-all-documents\", editor_all_documents);\n+\n+    module.register_fn(\"helix.context?\", is_context);\n+    module.register_type::<DocumentId>(\"DocumentId?\");\n+\n+    module.register_fn(\"editor-cursor\", Editor::cursor);\n+\n+    module.register_fn(\"cx->cursor\", |cx: &mut Context| cx.editor.cursor());",
        "comment_created_at": "2023-11-13T00:31:00+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "this is an instance of exposing too many implementation details.\r\n\r\nAs I said in the other comment, context should be somekind of hidden global (which can have different capabilities depending on callsite).\r\n\r\nThe user should only know that he can do X/Y at a certain callsite. the existance of context and editor struct is an implementation detail that plugins should not be aware of",
        "pr_file_module": null
      },
      {
        "comment_id": "1430668445",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390519327",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(\n+        \"PromptEvent::Update\",\n+        PromptEvent::Update.into_steelval().unwrap(),\n+    );\n+\n+    // Register everything in the typable command list. Now these are all available\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_editor_api(engine: &mut Engine, _api: EditorApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/editor\");\n+\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper7<(\n+            Context<'_>,\n+            helix_view::Editor,\n+            helix_view::Editor,\n+            Context<'static>,\n+        )>,\n+        helix_view::Editor,\n+    >::register_fn(&mut module, \"cx-editor!\", get_editor);\n+\n+    module.register_fn(\"set-scratch-buffer-name!\", set_scratch_buffer_name);\n+\n+    module.register_fn(\"editor-focus\", current_focus);\n+    module.register_fn(\"editor->doc-id\", get_document_id);\n+    module.register_fn(\"doc-id->usize\", document_id_to_usize);\n+    module.register_fn(\"editor-switch!\", switch);\n+    module.register_fn(\"editor-set-focus!\", Editor::focus);\n+    module.register_fn(\"editor-mode\", editor_get_mode);\n+    module.register_fn(\"editor-set-mode!\", editor_set_mode);\n+    module.register_fn(\"editor-doc-in-view?\", is_document_in_view);\n+\n+    // TODO: These are some horrendous type annotations, however... they do work.\n+    // If the type annotations are a bit more ergonomic, we might be able to get away with this\n+    // (i.e. if they're sensible enough)\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper8<(\n+            helix_view::Editor,\n+            DocumentId,\n+            Document,\n+            Document,\n+            helix_view::Editor,\n+        )>,\n+        Document,\n+    >::register_fn(&mut module, \"editor->get-document\", get_document);\n+\n+    // Check if the doc exists first\n+    module.register_fn(\"editor-doc-exists?\", document_exists);\n+    module.register_fn(\"Document-path\", document_path);\n+    module.register_fn(\"Document-focused-at\", document_focused_at);\n+    module.register_fn(\"editor-all-documents\", editor_all_documents);\n+\n+    module.register_fn(\"helix.context?\", is_context);\n+    module.register_type::<DocumentId>(\"DocumentId?\");\n+\n+    module.register_fn(\"editor-cursor\", Editor::cursor);\n+\n+    module.register_fn(\"cx->cursor\", |cx: &mut Context| cx.editor.cursor());",
        "comment_created_at": "2023-12-18T21:33:34+00:00",
        "comment_author": "mattwparas",
        "comment_body": "So just to clarify - don't expose the editor struct at all, any details go directly through the context?\r\n\r\nI'm fine with that, just confirming the intent here.",
        "pr_file_module": null
      },
      {
        "comment_id": "1435302642",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 8675,
        "pr_file": "helix-term/src/commands/engine/scheme.rs",
        "discussion_id": "1390519327",
        "commented_code": "@@ -0,0 +1,2003 @@\n+use helix_core::{\n+    extensions::steel_implementations::{rope_module, SteelRopeSlice},\n+    graphemes,\n+    path::expand_tilde,\n+    regex::Regex,\n+    shellwords::Shellwords,\n+    syntax::Configuration,\n+    Range, Selection, Tendril,\n+};\n+use helix_event::register_hook;\n+use helix_loader::merge_toml_values;\n+use helix_lsp::lsp::CompletionItem;\n+use helix_view::{\n+    document::Mode,\n+    editor::{Action, ConfigEvent},\n+    extension::document_id_to_usize,\n+    input::KeyEvent,\n+    Document, DocumentId, Editor, Theme,\n+};\n+use once_cell::sync::Lazy;\n+use serde_json::Value;\n+use steel::{\n+    gc::unsafe_erased_pointers::CustomReference,\n+    rerrs::ErrorKind,\n+    rvals::{as_underlying_type, AsRefMutSteelValFromRef, FromSteelVal, IntoSteelVal},\n+    steel_vm::{engine::Engine, register_fn::RegisterFn},\n+    steelerr, SteelErr, SteelVal,\n+};\n+\n+use std::{borrow::Cow, cell::RefCell, collections::HashMap, ops::Deref, path::PathBuf, rc::Rc};\n+use std::{\n+    collections::HashSet,\n+    sync::{Arc, RwLock},\n+};\n+\n+use steel::{rvals::Custom, steel_vm::builtin::BuiltInModule};\n+\n+use crate::{\n+    commands::insert,\n+    compositor::{self, Component, Compositor},\n+    config::Config,\n+    events::{OnModeSwitch, PostCommand, PostInsertChar},\n+    job::{self, Callback},\n+    keymap::{self, merge_keys, KeyTrie, KeymapResult},\n+    ui::{self, Popup, Prompt, PromptEvent},\n+};\n+\n+use components::SteelDynamicComponent;\n+\n+use super::{components, shell_impl, Context, MappableCommand, TYPABLE_COMMAND_LIST};\n+use insert::{insert_char, insert_string};\n+\n+thread_local! {\n+    pub static ENGINE: std::rc::Rc<std::cell::RefCell<steel::steel_vm::engine::Engine>> = configure_engine();\n+}\n+\n+enum CoreModules {\n+    Document(DocumentApi),\n+    Editor(EditorApi),\n+    Component(ComponentApi),\n+    TypedCommands(TypedCommandsApi),\n+    StaticCommands(StaticCommandsApi),\n+}\n+\n+// APIs / Modules that need to be accepted by the plugin system\n+// Without these, the core functionality cannot operate\n+pub struct DocumentApi;\n+pub struct EditorApi;\n+pub struct ComponentApi;\n+pub struct TypedCommandsApi;\n+pub struct StaticCommandsApi;\n+\n+pub struct KeyMapApi {\n+    get_keymap: fn() -> EmbeddedKeyMap,\n+    default_keymap: fn() -> EmbeddedKeyMap,\n+    empty_keymap: fn() -> EmbeddedKeyMap,\n+    string_to_embedded_keymap: fn(String) -> EmbeddedKeyMap,\n+    merge_keybindings: fn(&mut EmbeddedKeyMap, EmbeddedKeyMap),\n+    is_keymap: fn(SteelVal) -> bool,\n+    deep_copy_keymap: fn(EmbeddedKeyMap) -> EmbeddedKeyMap,\n+}\n+\n+impl KeyMapApi {\n+    fn new() -> Self {\n+        KeyMapApi {\n+            get_keymap,\n+            default_keymap,\n+            empty_keymap,\n+            string_to_embedded_keymap,\n+            merge_keybindings,\n+            is_keymap,\n+            deep_copy_keymap,\n+        }\n+    }\n+}\n+\n+thread_local! {\n+    pub static BUFFER_OR_EXTENSION_KEYBINDING_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static REVERSE_BUFFER_MAP: SteelVal =\n+        SteelVal::boxed(SteelVal::empty_hashmap());\n+\n+    pub static GLOBAL_KEYBINDING_MAP: SteelVal = get_keymap().into_steelval().unwrap();\n+\n+    static THEME_MAP: ThemeContainer = ThemeContainer::new();\n+\n+    static LANGUAGE_CONFIGURATIONS: LanguageConfigurationContainer = LanguageConfigurationContainer::new();\n+}\n+\n+// Any configurations that we'd like to overlay from the toml\n+struct LanguageConfigurationContainer {\n+    configuration: Rc<RefCell<Option<toml::Value>>>,\n+}\n+\n+impl LanguageConfigurationContainer {\n+    fn new() -> Self {\n+        Self {\n+            configuration: Rc::new(RefCell::new(None)),\n+        }\n+    }\n+}\n+\n+impl Custom for LanguageConfigurationContainer {}\n+\n+impl LanguageConfigurationContainer {\n+    fn add_configuration(&self, config_as_string: String) -> Result<(), String> {\n+        let left = self\n+            .configuration\n+            .replace(Some(toml::Value::Boolean(false)));\n+\n+        if let Some(left) = left {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string());\n+\n+            // panic!(\"{:#?}\", right);\n+\n+            match right {\n+                Ok(right) => {\n+                    self.configuration\n+                        .replace(Some(merge_toml_values(left, right, 3)));\n+\n+                    Ok(())\n+                }\n+                Err(e) => Err(e),\n+            }\n+        } else {\n+            let right = serde_json::from_str(&config_as_string).map_err(|err| err.to_string())?;\n+\n+            self.configuration.replace(Some(right));\n+\n+            Ok(())\n+        }\n+    }\n+\n+    fn as_language_configuration(&self) -> Option<Result<Configuration, toml::de::Error>> {\n+        if let Some(right) = self.configuration.borrow().clone() {\n+            let config = helix_loader::config::user_lang_config();\n+\n+            let res = config\n+                .map(|left| merge_toml_values(left, right, 3))\n+                .and_then(|x| x.try_into());\n+\n+            Some(res)\n+            // )\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn get_language_configuration() -> Option<Result<Configuration, toml::de::Error>> {\n+        LANGUAGE_CONFIGURATIONS.with(|x| x.as_language_configuration())\n+    }\n+}\n+\n+struct ThemeContainer {\n+    themes: Rc<RefCell<HashMap<String, Theme>>>,\n+}\n+\n+impl Custom for ThemeContainer {}\n+\n+impl ThemeContainer {\n+    fn new() -> Self {\n+        Self {\n+            themes: Rc::new(RefCell::new(HashMap::new())),\n+        }\n+    }\n+\n+    fn get(name: &str) -> Option<Theme> {\n+        THEME_MAP.with(|x| x.themes.borrow().get(name).cloned())\n+    }\n+\n+    fn names() -> Vec<String> {\n+        THEME_MAP.with(|x| x.themes.borrow().keys().cloned().collect())\n+    }\n+\n+    fn register(name: String, theme: Theme) {\n+        THEME_MAP.with(|x| x.themes.borrow_mut().insert(name, theme));\n+    }\n+}\n+\n+fn load_language_configuration_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/languages\".to_string());\n+\n+    module.register_fn(\n+        \"register-language-configuration!\",\n+        |language_configuration: String| -> Result<(), String> {\n+            LANGUAGE_CONFIGURATIONS.with(|x| x.add_configuration(language_configuration))\n+        },\n+    );\n+\n+    module.register_fn(\"flush-configuration\", refresh_language_configuration);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_theme_api(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/themes\");\n+\n+    module.register_fn(\n+        \"register-theme!\",\n+        |name: String, theme_as_json_string: String| -> Result<(), String> {\n+            Ok(ThemeContainer::register(\n+                name,\n+                serde_json::from_str(&theme_as_json_string).map_err(|err| err.to_string())?,\n+            ))\n+        },\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_keymap_api(engine: &mut Engine, api: KeyMapApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/keymaps\");\n+\n+    module.register_fn(\"helix-current-keymap\", api.get_keymap);\n+    module.register_fn(\"helix-empty-keymap\", api.empty_keymap);\n+    module.register_fn(\"helix-default-keymap\", api.default_keymap);\n+    module.register_fn(\"helix-merge-keybindings\", api.merge_keybindings);\n+    module.register_fn(\"helix-string->keymap\", api.string_to_embedded_keymap);\n+    module.register_fn(\"keymap?\", api.is_keymap);\n+\n+    module.register_fn(\"helix-deep-copy-keymap\", api.deep_copy_keymap);\n+\n+    // Alternatively, could store these values in a steel module, like so:\n+    // let keymap_core_map = helix_loader::runtime_file(&PathBuf::from(\"steel\").join(\"keymap.scm\"));\n+    // let require_module = format!(\"(require {})\", keymap_core_map.to_str().unwrap());\n+    // engine.run(&require_module).unwrap();\n+\n+    // This should be associated with a corresponding scheme module to wrap this up\n+    module.register_value(\n+        \"*buffer-or-extension-keybindings*\",\n+        BUFFER_OR_EXTENSION_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+    module.register_value(\n+        \"*reverse-buffer-map*\",\n+        REVERSE_BUFFER_MAP.with(|x| x.clone()),\n+    );\n+\n+    module.register_value(\n+        \"*global-keybinding-map*\",\n+        GLOBAL_KEYBINDING_MAP.with(|x| x.clone()),\n+    );\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_static_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/static\");\n+\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, &[], PromptEvent::Validate)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    // Register everything in the static command list as well\n+    // These just accept the context, no arguments\n+    for command in MappableCommand::STATIC_COMMAND_LIST {\n+        if let MappableCommand::Static { name, fun, .. } = command {\n+            module.register_fn(name, fun);\n+        }\n+    }\n+\n+    // Adhoc static commands that probably needs evaluating\n+    module.register_fn(\"insert_char\", insert_char);\n+    module.register_fn(\"insert_string\", insert_string);\n+    module.register_fn(\"current_selection\", get_selection);\n+    module.register_fn(\"current-highlighted-text!\", get_highlighted_text);\n+    module.register_fn(\"get-current-line-number\", current_line_number);\n+    module.register_fn(\"current-selection-object\", current_selection);\n+    module.register_fn(\"set-current-selection-object!\", set_selection);\n+    module.register_fn(\"run-in-engine!\", run_in_engine);\n+    module.register_fn(\"get-helix-scm-path\", get_helix_scm_path);\n+    module.register_fn(\"get-init-scm-path\", get_init_scm_path);\n+    module.register_fn(\"get-helix-cwd\", get_helix_cwd);\n+    module.register_fn(\"search-in-directory\", search_in_directory);\n+    module.register_fn(\"regex-selection\", regex_selection);\n+    module.register_fn(\"replace-selection-with\", replace_selection);\n+    module.register_fn(\"show-completion-prompt-with\", show_completion_prompt);\n+    module.register_fn(\"move-window-far-left\", move_window_to_the_left);\n+    module.register_fn(\"move-window-far-right\", move_window_to_the_right);\n+\n+    module.register_fn(\"block-on-shell-command\", run_shell_command_text);\n+\n+    module.register_fn(\"cx->current-file\", current_path);\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_typed_commands(engine: &mut Engine) {\n+    let mut module = BuiltInModule::new(\"helix/core/typable\".to_string());\n+\n+    {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            set_options(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(\"set-options\", func);\n+    }\n+\n+    module.register_value(\n+        \"PromptEvent::Validate\",\n+        PromptEvent::Validate.into_steelval().unwrap(),\n+    );\n+    module.register_value(\n+        \"PromptEvent::Update\",\n+        PromptEvent::Update.into_steelval().unwrap(),\n+    );\n+\n+    // Register everything in the typable command list. Now these are all available\n+    for command in TYPABLE_COMMAND_LIST {\n+        let func = |cx: &mut Context, args: &[Cow<str>], event: PromptEvent| {\n+            let mut cx = compositor::Context {\n+                editor: cx.editor,\n+                scroll: None,\n+                jobs: cx.jobs,\n+            };\n+\n+            (command.fun)(&mut cx, args, event)\n+        };\n+\n+        module.register_fn(command.name, func);\n+    }\n+\n+    engine.register_module(module);\n+}\n+\n+fn load_editor_api(engine: &mut Engine, _api: EditorApi) {\n+    let mut module = BuiltInModule::new(\"helix/core/editor\");\n+\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper7<(\n+            Context<'_>,\n+            helix_view::Editor,\n+            helix_view::Editor,\n+            Context<'static>,\n+        )>,\n+        helix_view::Editor,\n+    >::register_fn(&mut module, \"cx-editor!\", get_editor);\n+\n+    module.register_fn(\"set-scratch-buffer-name!\", set_scratch_buffer_name);\n+\n+    module.register_fn(\"editor-focus\", current_focus);\n+    module.register_fn(\"editor->doc-id\", get_document_id);\n+    module.register_fn(\"doc-id->usize\", document_id_to_usize);\n+    module.register_fn(\"editor-switch!\", switch);\n+    module.register_fn(\"editor-set-focus!\", Editor::focus);\n+    module.register_fn(\"editor-mode\", editor_get_mode);\n+    module.register_fn(\"editor-set-mode!\", editor_set_mode);\n+    module.register_fn(\"editor-doc-in-view?\", is_document_in_view);\n+\n+    // TODO: These are some horrendous type annotations, however... they do work.\n+    // If the type annotations are a bit more ergonomic, we might be able to get away with this\n+    // (i.e. if they're sensible enough)\n+    RegisterFn::<\n+        _,\n+        steel::steel_vm::register_fn::MarkerWrapper8<(\n+            helix_view::Editor,\n+            DocumentId,\n+            Document,\n+            Document,\n+            helix_view::Editor,\n+        )>,\n+        Document,\n+    >::register_fn(&mut module, \"editor->get-document\", get_document);\n+\n+    // Check if the doc exists first\n+    module.register_fn(\"editor-doc-exists?\", document_exists);\n+    module.register_fn(\"Document-path\", document_path);\n+    module.register_fn(\"Document-focused-at\", document_focused_at);\n+    module.register_fn(\"editor-all-documents\", editor_all_documents);\n+\n+    module.register_fn(\"helix.context?\", is_context);\n+    module.register_type::<DocumentId>(\"DocumentId?\");\n+\n+    module.register_fn(\"editor-cursor\", Editor::cursor);\n+\n+    module.register_fn(\"cx->cursor\", |cx: &mut Context| cx.editor.cursor());",
        "comment_created_at": "2023-12-22T19:23:38+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "yeah don't expose theses structs at all. These should not be `editor-cursor` and `cx->cursor` but instead just `active-cursor` and the internal structs are handled in the background. ",
        "pr_file_module": null
      }
    ]
  }
]