[
  {
    "discussion_id": "2008622484",
    "pr_number": 13133,
    "pr_file": "helix-stdx/src/date.rs",
    "created_at": "2025-03-22T02:32:17+00:00",
    "commented_code": "+/// Formats a timestamp into a human-readable relative time string.\n+///\n+/// # Arguments\n+///\n+/// * `seconds` - Seconds since UNIX epoch (UTC)\n+/// * `offset` - Timezone offset in seconds\n+///\n+/// # Returns\n+///\n+/// A String representing the relative time (e.g., \"4 years ago\")\n+pub fn format_relative_time(seconds: i64, offset: i32) -> String {\n+    let now = std::time::SystemTime::now()",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2008622484",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13133,
        "pr_file": "helix-stdx/src/date.rs",
        "discussion_id": "2008622484",
        "commented_code": "@@ -0,0 +1,55 @@\n+/// Formats a timestamp into a human-readable relative time string.\n+///\n+/// # Arguments\n+///\n+/// * `seconds` - Seconds since UNIX epoch (UTC)\n+/// * `offset` - Timezone offset in seconds\n+///\n+/// # Returns\n+///\n+/// A String representing the relative time (e.g., \"4 years ago\")\n+pub fn format_relative_time(seconds: i64, offset: i32) -> String {\n+    let now = std::time::SystemTime::now()",
        "comment_created_at": "2025-03-22T02:32:17+00:00",
        "comment_author": "RoloEdits",
        "comment_body": "This is a syscall every render. We had this with canonicalizing paths https://github.com/helix-editor/helix/pull/12385 that was changed for the same thing. \r\n\r\nHighlighted `SystemTime`:\r\n![image](https://github.com/user-attachments/assets/391962bd-ffc2-465c-b3cf-97545d3fbd4b)\r\n\r\n(getting a deje vu writing this lol)\r\n\r\nThis is not as egregious as the path one but perhaps enough to warrant an need to opt into the relative time? (I definitely like the feature of it)",
        "pr_file_module": null
      },
      {
        "comment_id": "2008626192",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13133,
        "pr_file": "helix-stdx/src/date.rs",
        "discussion_id": "2008622484",
        "commented_code": "@@ -0,0 +1,55 @@\n+/// Formats a timestamp into a human-readable relative time string.\n+///\n+/// # Arguments\n+///\n+/// * `seconds` - Seconds since UNIX epoch (UTC)\n+/// * `offset` - Timezone offset in seconds\n+///\n+/// # Returns\n+///\n+/// A String representing the relative time (e.g., \"4 years ago\")\n+pub fn format_relative_time(seconds: i64, offset: i32) -> String {\n+    let now = std::time::SystemTime::now()",
        "comment_created_at": "2025-03-22T02:48:54+00:00",
        "comment_author": "nik-rev",
        "comment_body": "How expensive is a syscall every render? As in, does it add any noticeable delay?\n\nI would definitely like to optimize this. \n\nFor example, we could get the time when the editor was launched, then track how long the editor is alive for using the editor's internal state, then calculate the current time in this manner",
        "pr_file_module": null
      },
      {
        "comment_id": "2008630007",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13133,
        "pr_file": "helix-stdx/src/date.rs",
        "discussion_id": "2008622484",
        "commented_code": "@@ -0,0 +1,55 @@\n+/// Formats a timestamp into a human-readable relative time string.\n+///\n+/// # Arguments\n+///\n+/// * `seconds` - Seconds since UNIX epoch (UTC)\n+/// * `offset` - Timezone offset in seconds\n+///\n+/// # Returns\n+///\n+/// A String representing the relative time (e.g., \"4 years ago\")\n+pub fn format_relative_time(seconds: i64, offset: i32) -> String {\n+    let now = std::time::SystemTime::now()",
        "comment_created_at": "2025-03-22T03:01:29+00:00",
        "comment_author": "RoloEdits",
        "comment_body": "I don't think I have noticed anything via my awful human senses, but it definitely stands out among other operations being performed.\r\n\r\nI do wonder if there is a simple way to cache this. My initial thought was similar to yours, and run the syscall once and then start an Instance timer at the same time and store this as a singleton. Then you could just add the time since the \"current\" time given in the initial call.",
        "pr_file_module": null
      },
      {
        "comment_id": "2008636200",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13133,
        "pr_file": "helix-stdx/src/date.rs",
        "discussion_id": "2008622484",
        "commented_code": "@@ -0,0 +1,55 @@\n+/// Formats a timestamp into a human-readable relative time string.\n+///\n+/// # Arguments\n+///\n+/// * `seconds` - Seconds since UNIX epoch (UTC)\n+/// * `offset` - Timezone offset in seconds\n+///\n+/// # Returns\n+///\n+/// A String representing the relative time (e.g., \"4 years ago\")\n+pub fn format_relative_time(seconds: i64, offset: i32) -> String {\n+    let now = std::time::SystemTime::now()",
        "comment_created_at": "2025-03-22T03:34:23+00:00",
        "comment_author": "RoloEdits",
        "comment_body": "Throwing this together quickly seems like it could do the job? Its not sub millisecond accurate or anything, but close enough to be useful for its purposes? Might be able to get it closer if you tweaked some things around, but having a ~1 range I think is fine?\r\n\r\n```rust\r\nstruct EditorTime {\r\n    pub start: SystemTime,\r\n    pub since: Instant,\r\n}\r\n\r\nimpl EditorTime {\r\n    fn duration_since_start(&self) -> i64 {\r\n        let since = self\r\n            .start\r\n            .duration_since(std::time::UNIX_EPOCH)\r\n            .map(|d| d.as_secs() as i64)\r\n            .unwrap_or(0);\r\n\r\n        since + self.since.elapsed().as_secs() as i64\r\n    }\r\n}\r\n\r\nstatic BlameTime: LazyLock<EditorTime> = LazyLock::new(|| {\r\n    let start = std::time::SystemTime::now();\r\n    let since = Instant::now();\r\n    EditorTime { start, since }\r\n});\r\n\r\npub fn format_relative_time(seconds: i64, offset: i32) -> String {\r\n    let _now = std::time::SystemTime::now()\r\n        .duration_since(std::time::UNIX_EPOCH)\r\n        .map(|d| d.as_secs() as i64)\r\n        .unwrap_or(0);\r\n\r\n    let now = BlameTime.duration_since_start();\r\n\r\n    log::error!(\"_now: {_now}, now: {now}\");\r\n\r\n    ...\r\n}\r\n\r\n```\r\n\r\n```text\r\n_now: 1742614182, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614182\r\n_now: 1742614183, now: 1742614183\r\n_now: 1742614183, now: 1742614183\r\n_now: 1742614183, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614183\r\n_now: 1742614184, now: 1742614184\r\n_now: 1742614184, now: 1742614184\r\n_now: 1742614184, now: 1742614184\r\n_now: 1742614184, now: 1742614184\r\n_now: 1742614184, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614184\r\n_now: 1742614185, now: 1742614185\r\n_now: 1742614186, now: 1742614185\r\n_now: 1742614186, now: 1742614185\r\n_now: 1742614186, now: 1742614185\r\n_now: 1742614186, now: 1742614185\r\n_now: 1742614186, now: 1742614186\r\n````",
        "pr_file_module": null
      },
      {
        "comment_id": "2008636762",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13133,
        "pr_file": "helix-stdx/src/date.rs",
        "discussion_id": "2008622484",
        "commented_code": "@@ -0,0 +1,55 @@\n+/// Formats a timestamp into a human-readable relative time string.\n+///\n+/// # Arguments\n+///\n+/// * `seconds` - Seconds since UNIX epoch (UTC)\n+/// * `offset` - Timezone offset in seconds\n+///\n+/// # Returns\n+///\n+/// A String representing the relative time (e.g., \"4 years ago\")\n+pub fn format_relative_time(seconds: i64, offset: i32) -> String {\n+    let now = std::time::SystemTime::now()",
        "comment_created_at": "2025-03-22T03:37:13+00:00",
        "comment_author": "nik-rev",
        "comment_body": "Ok, implementing this was really easy. Kudos for noticing this!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2018950622",
    "pr_number": 11798,
    "pr_file": "helix-term/src/ui/editor.rs",
    "created_at": "2025-03-28T16:08:16+00:00",
    "commented_code": "theme: &Theme,\n     ) {\n         let editor_rulers = &editor.config().rulers;\n+        let ruler_style = &editor.config().ruler_style;\n+        let ruler_char = editor.config().ruler_char.to_string();",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2018950622",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11798,
        "pr_file": "helix-term/src/ui/editor.rs",
        "discussion_id": "2018950622",
        "commented_code": "@@ -252,8 +254,16 @@ impl EditorView {\n         theme: &Theme,\n     ) {\n         let editor_rulers = &editor.config().rulers;\n+        let ruler_style = &editor.config().ruler_style;\n+        let ruler_char = editor.config().ruler_char.to_string();",
        "comment_created_at": "2025-03-28T16:08:16+00:00",
        "comment_author": "nik-rev",
        "comment_body": "```suggestion\r\n        let ruler_char = editor.config().ruler_char;\r\n```\r\nthis creates an extra allocation on each render",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1957105883",
    "pr_number": 12855,
    "pr_file": "helix-term/src/commands.rs",
    "created_at": "2025-02-15T12:20:28+00:00",
    "commented_code": "struct GlobalSearchConfig {\n         smart_case: bool,\n         file_picker_config: helix_view::editor::FilePickerConfig,\n+        directory_style: Style,\n+        number_style: Style,\n+        colon_style: Style,\n     }\n \n     let config = cx.editor.config();\n     let config = GlobalSearchConfig {\n         smart_case: config.search.smart_case,\n         file_picker_config: config.file_picker.clone(),\n+        directory_style: cx.editor.theme.get(\"ui.text.directory\"),\n+        number_style: cx.editor.theme.get(\"constant.numeric\"),\n+        colon_style: cx.editor.theme.get(\"punctuation\"),\n     };\n \n     let columns = [\n-        PickerColumn::new(\"path\", |item: &FileResult, _| {\n+        PickerColumn::new(\"path\", |item: &FileResult, config: &GlobalSearchConfig| {\n             let path = helix_stdx::path::get_relative_path(&item.path);\n-            format!(\"{}:{}\", path.to_string_lossy(), item.line_num + 1).into()\n+\n+            let directories = path\n+                .parent()\n+                .filter(|p| !p.as_os_str().is_empty())\n+                .map(|p| p.to_string_lossy().to_string() + \"/\")\n+                .unwrap_or_default();",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1957105883",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12855,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1957105883",
        "commented_code": "@@ -2404,18 +2407,41 @@ fn global_search(cx: &mut Context) {\n     struct GlobalSearchConfig {\n         smart_case: bool,\n         file_picker_config: helix_view::editor::FilePickerConfig,\n+        directory_style: Style,\n+        number_style: Style,\n+        colon_style: Style,\n     }\n \n     let config = cx.editor.config();\n     let config = GlobalSearchConfig {\n         smart_case: config.search.smart_case,\n         file_picker_config: config.file_picker.clone(),\n+        directory_style: cx.editor.theme.get(\"ui.text.directory\"),\n+        number_style: cx.editor.theme.get(\"constant.numeric\"),\n+        colon_style: cx.editor.theme.get(\"punctuation\"),\n     };\n \n     let columns = [\n-        PickerColumn::new(\"path\", |item: &FileResult, _| {\n+        PickerColumn::new(\"path\", |item: &FileResult, config: &GlobalSearchConfig| {\n             let path = helix_stdx::path::get_relative_path(&item.path);\n-            format!(\"{}:{}\", path.to_string_lossy(), item.line_num + 1).into()\n+\n+            let directories = path\n+                .parent()\n+                .filter(|p| !p.as_os_str().is_empty())\n+                .map(|p| p.to_string_lossy().to_string() + \"/\")\n+                .unwrap_or_default();",
        "comment_created_at": "2025-02-15T12:20:28+00:00",
        "comment_author": "poliorcetics",
        "comment_body": "```suggestion\r\n            let directories = path\r\n                .parent()\r\n                .filter(|p| !p.as_os_str().is_empty())\r\n                .map(|p| format!(\"{}{}\", p.display(), std::path::MAIN_SEPARATOR))\r\n                .unwrap_or_default();\r\n```\r\n\r\nAlso, I wonder, do we need the owned `to_string()` allocations ? `Span` contains a `Cow<str>` so can we get away with less allocations ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1957333220",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12855,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1957105883",
        "commented_code": "@@ -2404,18 +2407,41 @@ fn global_search(cx: &mut Context) {\n     struct GlobalSearchConfig {\n         smart_case: bool,\n         file_picker_config: helix_view::editor::FilePickerConfig,\n+        directory_style: Style,\n+        number_style: Style,\n+        colon_style: Style,\n     }\n \n     let config = cx.editor.config();\n     let config = GlobalSearchConfig {\n         smart_case: config.search.smart_case,\n         file_picker_config: config.file_picker.clone(),\n+        directory_style: cx.editor.theme.get(\"ui.text.directory\"),\n+        number_style: cx.editor.theme.get(\"constant.numeric\"),\n+        colon_style: cx.editor.theme.get(\"punctuation\"),\n     };\n \n     let columns = [\n-        PickerColumn::new(\"path\", |item: &FileResult, _| {\n+        PickerColumn::new(\"path\", |item: &FileResult, config: &GlobalSearchConfig| {\n             let path = helix_stdx::path::get_relative_path(&item.path);\n-            format!(\"{}:{}\", path.to_string_lossy(), item.line_num + 1).into()\n+\n+            let directories = path\n+                .parent()\n+                .filter(|p| !p.as_os_str().is_empty())\n+                .map(|p| p.to_string_lossy().to_string() + \"/\")\n+                .unwrap_or_default();",
        "comment_created_at": "2025-02-16T13:57:08+00:00",
        "comment_author": "iliekturtles",
        "comment_body": "The following will handle splitting the directory and file, do no extra allocations (beyond `to_string_lossy`), and will handle the condition when the directory portion is empty or root.\r\n\r\nI haven't tested on Windows. The `p.as_os_str() != std::path::MAIN_SEPARATOR_STR` should probably be an ends-with check instead.\r\n\r\nI also noticed that `Path` has a `display` method. Any idea why the original code used `to_string_lossy` instead of `display`?\r\n\r\n```rust\r\n    let p = std::path::Path::new(\"/path/f.txt\");\r\n\r\n    let parent = p.parent()\r\n        .filter(|p| !p.as_os_str().is_empty() && p.as_os_str() != std::path::MAIN_SEPARATOR_STR);\r\n    let directory = parent\r\n        .map(std::path::Path::to_string_lossy)\r\n        .unwrap_or_default();\r\n    let s = parent\r\n        .and(Some(std::path::MAIN_SEPARATOR_STR))\r\n        .unwrap_or_default();\r\n    let file = p\r\n        .file_name()\r\n        .map(std::ffi::OsStr::to_string_lossy)\r\n        .unwrap_or_default();\r\n    let line = 45;\r\n\r\n    println!(\"{directory}{s}{file}:{line}\");\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1957367267",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12855,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1957105883",
        "commented_code": "@@ -2404,18 +2407,41 @@ fn global_search(cx: &mut Context) {\n     struct GlobalSearchConfig {\n         smart_case: bool,\n         file_picker_config: helix_view::editor::FilePickerConfig,\n+        directory_style: Style,\n+        number_style: Style,\n+        colon_style: Style,\n     }\n \n     let config = cx.editor.config();\n     let config = GlobalSearchConfig {\n         smart_case: config.search.smart_case,\n         file_picker_config: config.file_picker.clone(),\n+        directory_style: cx.editor.theme.get(\"ui.text.directory\"),\n+        number_style: cx.editor.theme.get(\"constant.numeric\"),\n+        colon_style: cx.editor.theme.get(\"punctuation\"),\n     };\n \n     let columns = [\n-        PickerColumn::new(\"path\", |item: &FileResult, _| {\n+        PickerColumn::new(\"path\", |item: &FileResult, config: &GlobalSearchConfig| {\n             let path = helix_stdx::path::get_relative_path(&item.path);\n-            format!(\"{}:{}\", path.to_string_lossy(), item.line_num + 1).into()\n+\n+            let directories = path\n+                .parent()\n+                .filter(|p| !p.as_os_str().is_empty())\n+                .map(|p| p.to_string_lossy().to_string() + \"/\")\n+                .unwrap_or_default();",
        "comment_created_at": "2025-02-16T16:44:40+00:00",
        "comment_author": "nik-rev",
        "comment_body": "> Also, I wonder, do we need the owned `to_string()` allocations ? `Span` contains a `Cow<str>` so can we get away with less allocations ?\r\n\r\nThat works! Also good that it considers Windows now as well.",
        "pr_file_module": null
      },
      {
        "comment_id": "1957367630",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12855,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1957105883",
        "commented_code": "@@ -2404,18 +2407,41 @@ fn global_search(cx: &mut Context) {\n     struct GlobalSearchConfig {\n         smart_case: bool,\n         file_picker_config: helix_view::editor::FilePickerConfig,\n+        directory_style: Style,\n+        number_style: Style,\n+        colon_style: Style,\n     }\n \n     let config = cx.editor.config();\n     let config = GlobalSearchConfig {\n         smart_case: config.search.smart_case,\n         file_picker_config: config.file_picker.clone(),\n+        directory_style: cx.editor.theme.get(\"ui.text.directory\"),\n+        number_style: cx.editor.theme.get(\"constant.numeric\"),\n+        colon_style: cx.editor.theme.get(\"punctuation\"),\n     };\n \n     let columns = [\n-        PickerColumn::new(\"path\", |item: &FileResult, _| {\n+        PickerColumn::new(\"path\", |item: &FileResult, config: &GlobalSearchConfig| {\n             let path = helix_stdx::path::get_relative_path(&item.path);\n-            format!(\"{}:{}\", path.to_string_lossy(), item.line_num + 1).into()\n+\n+            let directories = path\n+                .parent()\n+                .filter(|p| !p.as_os_str().is_empty())\n+                .map(|p| p.to_string_lossy().to_string() + \"/\")\n+                .unwrap_or_default();",
        "comment_created_at": "2025-02-16T16:46:46+00:00",
        "comment_author": "nik-rev",
        "comment_body": "> The following will handle splitting the directory and file, do no extra allocations (beyond `to_string_lossy`), and will handle the condition when the directory portion is empty or root.\r\n> \r\n> I haven't tested on Windows. The `p.as_os_str() != std::path::MAIN_SEPARATOR_STR` should probably be an ends-with check instead.\r\n> \r\n> I also noticed that `Path` has a `display` method. Any idea why the original code used `to_string_lossy` instead of `display`?\r\n> \r\n> ```rust\r\n>     let p = std::path::Path::new(\"/path/f.txt\");\r\n> \r\n>     let parent = p.parent()\r\n>         .filter(|p| !p.as_os_str().is_empty() && p.as_os_str() != std::path::MAIN_SEPARATOR_STR);\r\n>     let directory = parent\r\n>         .map(std::path::Path::to_string_lossy)\r\n>         .unwrap_or_default();\r\n>     let s = parent\r\n>         .and(Some(std::path::MAIN_SEPARATOR_STR))\r\n>         .unwrap_or_default();\r\n>     let file = p\r\n>         .file_name()\r\n>         .map(std::ffi::OsStr::to_string_lossy)\r\n>         .unwrap_or_default();\r\n>     let line = 45;\r\n> \r\n>     println!(\"{directory}{s}{file}:{line}\");\r\n> ```\r\n\r\nLooks like we must split the `path` into 2 owned variables (corresponding to the filename itself, as well as the parents of the file). We can't return non-owned `Cow`s from the closure from my testing",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1927473238",
    "pr_number": 12578,
    "pr_file": "helix-term/src/ui/mod.rs",
    "created_at": "2025-01-23T18:31:05+00:00",
    "commented_code": "}\n     }\n \n+    pub fn language_servers(editor: &Editor, input: &str) -> Vec<Completion> {\n+        let language_servers = doc!(editor)\n+            .language_servers()\n+            .map(|ls| ls.name().to_string());\n+\n+        fuzzy_match(input, language_servers, false)\n+            .into_iter()\n+            .map(|(name, _)| ((0..), Span::raw(name)))",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1927473238",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12578,
        "pr_file": "helix-term/src/ui/mod.rs",
        "discussion_id": "1927473238",
        "commented_code": "@@ -339,6 +339,17 @@ pub mod completers {\n         }\n     }\n \n+    pub fn language_servers(editor: &Editor, input: &str) -> Vec<Completion> {\n+        let language_servers = doc!(editor)\n+            .language_servers()\n+            .map(|ls| ls.name().to_string());\n+\n+        fuzzy_match(input, language_servers, false)\n+            .into_iter()\n+            .map(|(name, _)| ((0..), Span::raw(name)))",
        "comment_created_at": "2025-01-23T18:31:05+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "The `to_string()` can move from the `map` in `let language_servers` to the `map` here on L349. That way we allocate only for names that match the input.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2072619974",
    "pr_number": 13466,
    "pr_file": "helix-view/src/expansion.rs",
    "created_at": "2025-05-04T13:33:40+00:00",
    "commented_code": "}\n         }\n         Variable::LineEnding => Ok(Cow::Borrowed(doc.line_ending.as_str())),\n+        Variable::Language => Ok(Cow::Owned(\n+            doc.language_name().unwrap_or(\"text\").to_string(),\n+        )),",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2072619974",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13466,
        "pr_file": "helix-view/src/expansion.rs",
        "discussion_id": "2072619974",
        "commented_code": "@@ -215,5 +220,8 @@ fn expand_variable(editor: &Editor, variable: Variable) -> Result<Cow<'static, s\n             }\n         }\n         Variable::LineEnding => Ok(Cow::Borrowed(doc.line_ending.as_str())),\n+        Variable::Language => Ok(Cow::Owned(\n+            doc.language_name().unwrap_or(\"text\").to_string(),\n+        )),",
        "comment_created_at": "2025-05-04T13:33:40+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "```suggestion\r\n        Variable::Language => Ok(match doc.language_name() {\r\n            Some(lang) => Cow::Owned(lang.to_owned()),\r\n            None => Cow::Borrowed(\"text\"),\r\n        }),\r\n```\r\n\r\nmight as well avoid that extra allocation when there is no lang, even though it's small",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1957109682",
    "pr_number": 12806,
    "pr_file": "helix-term/src/ui/mod.rs",
    "created_at": "2025-02-15T12:43:13+00:00",
    "commented_code": "cx.push_layer(Box::new(prompt));\n }\n \n+pub fn get_relative_dir(path: &Path) -> Cow<'static, str> {\n+    let path = helix_stdx::path::get_relative_path(path);\n+    if path.components().next().is_none() {\n+        \"./\".into()\n+    } else {\n+        let mut str = path.to_string_lossy().into_owned();\n+        if path.is_dir() {\n+            str.push('/');\n+        }\n+\n+        str.into()\n+    }\n+}",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1957109682",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12806,
        "pr_file": "helix-term/src/ui/mod.rs",
        "discussion_id": "1957109682",
        "commented_code": "@@ -185,6 +186,20 @@ pub fn raw_regex_prompt(\n     cx.push_layer(Box::new(prompt));\n }\n \n+pub fn get_relative_dir(path: &Path) -> Cow<'static, str> {\n+    let path = helix_stdx::path::get_relative_path(path);\n+    if path.components().next().is_none() {\n+        \"./\".into()\n+    } else {\n+        let mut str = path.to_string_lossy().into_owned();\n+        if path.is_dir() {\n+            str.push('/');\n+        }\n+\n+        str.into()\n+    }\n+}",
        "comment_created_at": "2025-02-15T12:43:13+00:00",
        "comment_author": "poliorcetics",
        "comment_body": "isn't this always called with a directory as entry (`&root`) ? Could we dispense the FS check (slow) then ?",
        "pr_file_module": null
      },
      {
        "comment_id": "1957227166",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12806,
        "pr_file": "helix-term/src/ui/mod.rs",
        "discussion_id": "1957109682",
        "commented_code": "@@ -185,6 +186,20 @@ pub fn raw_regex_prompt(\n     cx.push_layer(Box::new(prompt));\n }\n \n+pub fn get_relative_dir(path: &Path) -> Cow<'static, str> {\n+    let path = helix_stdx::path::get_relative_path(path);\n+    if path.components().next().is_none() {\n+        \"./\".into()\n+    } else {\n+        let mut str = path.to_string_lossy().into_owned();\n+        if path.is_dir() {\n+            str.push('/');\n+        }\n+\n+        str.into()\n+    }\n+}",
        "comment_created_at": "2025-02-16T02:33:55+00:00",
        "comment_author": "paholg",
        "comment_body": "Makes sense, done.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1587761257",
    "pr_number": 10662,
    "pr_file": "helix-view/src/document.rs",
    "created_at": "2024-05-02T14:44:17+00:00",
    "commented_code": "if let Ok(metadata) = fs::metadata(&path).await {\n                     if let Ok(mtime) = metadata.modified() {\n                         if last_saved_time < mtime {\n-                            bail!(\"file modified by an external process, use :w! to overwrite\");\n+                            let external_content = fs::read(&path).await?;",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1587761257",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 10662,
        "pr_file": "helix-view/src/document.rs",
        "discussion_id": "1587761257",
        "commented_code": "@@ -888,7 +890,21 @@ impl Document {\n                 if let Ok(metadata) = fs::metadata(&path).await {\n                     if let Ok(mtime) = metadata.modified() {\n                         if last_saved_time < mtime {\n-                            bail!(\"file modified by an external process, use :w! to overwrite\");\n+                            let external_content = fs::read(&path).await?;",
        "comment_created_at": "2024-05-02T14:44:17+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "We should avoid reading the entire file into memory at once",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1894083997",
    "pr_number": 12308,
    "pr_file": "helix-term/src/commands/lsp.rs",
    "created_at": "2024-12-20T15:37:13+00:00",
    "commented_code": "Some(callback)\n }\n+\n+pub fn compute_color_swatches_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {\n+    if !editor.config().lsp.display_color_swatches {\n+        return;\n+    }\n+\n+    for (view, _) in editor.tree.views() {\n+        let doc = match editor.documents.get(&view.doc) {\n+            Some(doc) => doc,\n+            None => continue,\n+        };\n+        if let Some(callback) = compute_color_swatches_for_view(view, doc) {\n+            jobs.callback(callback);\n+        }\n+    }\n+}\n+\n+fn compute_color_swatches_for_view(\n+    view: &View,\n+    doc: &Document,\n+) -> Option<std::pin::Pin<Box<impl Future<Output = Result<crate::job::Callback, anyhow::Error>>>>> {\n+    let view_id = view.id;\n+    let doc_id = view.doc;\n+\n+    let language_server = doc\n+        .language_servers_with_feature(LanguageServerFeature::ColorProvider)\n+        .next()?;\n+\n+    let (first_line, last_line) = lsp_annotations_area(view, doc);\n+\n+    let new_doc_color_swatches_id = ColorSwatchesId {\n+        first_line,\n+        last_line,\n+    };\n+\n+    // Don't recompute the color swatches in case nothing has changed about the view\n+    if !doc.color_swatches_outdated\n+        && doc\n+            .color_swatches(view_id)\n+            .map_or(false, |dih| dih.id == new_doc_color_swatches_id)\n+    {\n+        return None;\n+    }\n+\n+    let offset_encoding = language_server.offset_encoding();\n+\n+    let callback = super::make_job_callback(\n+        language_server.text_document_color_swatches(doc.identifier(), None)?,\n+        move |editor, _compositor, response: Option<Vec<lsp::ColorInformation>>| {\n+            // The config was modified or the window was closed while the request was in flight\n+            if !editor.config().lsp.display_color_swatches || editor.tree.try_get(view_id).is_none()\n+            {\n+                return;\n+            }\n+\n+            // Add annotations to relevant document, not the current one (it may have changed in between)\n+            let doc = match editor.documents.get_mut(&doc_id) {\n+                Some(doc) => doc,\n+                None => return,\n+            };\n+\n+            // If we have neither color swatches nor an LSP, empty the color swatches since they're now oudated\n+            let mut swatches = match response {\n+                Some(swatches) if !swatches.is_empty() => swatches,\n+                _ => {\n+                    doc.set_color_swatches(\n+                        view_id,\n+                        DocumentColorSwatches::empty_with_id(new_doc_color_swatches_id),\n+                    );\n+                    doc.color_swatches_outdated = false;\n+                    return;\n+                }\n+            };\n+\n+            // Most language servers will already send them sorted but ensure this is the case to\n+            // avoid errors on our end.\n+            swatches.sort_by_key(|inlay_hint| inlay_hint.range.start);\n+\n+            let mut color_swatches = Vec::new();",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1894083997",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12308,
        "pr_file": "helix-term/src/commands/lsp.rs",
        "discussion_id": "1894083997",
        "commented_code": "@@ -1398,3 +1405,120 @@ fn compute_inlay_hints_for_view(\n \n     Some(callback)\n }\n+\n+pub fn compute_color_swatches_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {\n+    if !editor.config().lsp.display_color_swatches {\n+        return;\n+    }\n+\n+    for (view, _) in editor.tree.views() {\n+        let doc = match editor.documents.get(&view.doc) {\n+            Some(doc) => doc,\n+            None => continue,\n+        };\n+        if let Some(callback) = compute_color_swatches_for_view(view, doc) {\n+            jobs.callback(callback);\n+        }\n+    }\n+}\n+\n+fn compute_color_swatches_for_view(\n+    view: &View,\n+    doc: &Document,\n+) -> Option<std::pin::Pin<Box<impl Future<Output = Result<crate::job::Callback, anyhow::Error>>>>> {\n+    let view_id = view.id;\n+    let doc_id = view.doc;\n+\n+    let language_server = doc\n+        .language_servers_with_feature(LanguageServerFeature::ColorProvider)\n+        .next()?;\n+\n+    let (first_line, last_line) = lsp_annotations_area(view, doc);\n+\n+    let new_doc_color_swatches_id = ColorSwatchesId {\n+        first_line,\n+        last_line,\n+    };\n+\n+    // Don't recompute the color swatches in case nothing has changed about the view\n+    if !doc.color_swatches_outdated\n+        && doc\n+            .color_swatches(view_id)\n+            .map_or(false, |dih| dih.id == new_doc_color_swatches_id)\n+    {\n+        return None;\n+    }\n+\n+    let offset_encoding = language_server.offset_encoding();\n+\n+    let callback = super::make_job_callback(\n+        language_server.text_document_color_swatches(doc.identifier(), None)?,\n+        move |editor, _compositor, response: Option<Vec<lsp::ColorInformation>>| {\n+            // The config was modified or the window was closed while the request was in flight\n+            if !editor.config().lsp.display_color_swatches || editor.tree.try_get(view_id).is_none()\n+            {\n+                return;\n+            }\n+\n+            // Add annotations to relevant document, not the current one (it may have changed in between)\n+            let doc = match editor.documents.get_mut(&doc_id) {\n+                Some(doc) => doc,\n+                None => return,\n+            };\n+\n+            // If we have neither color swatches nor an LSP, empty the color swatches since they're now oudated\n+            let mut swatches = match response {\n+                Some(swatches) if !swatches.is_empty() => swatches,\n+                _ => {\n+                    doc.set_color_swatches(\n+                        view_id,\n+                        DocumentColorSwatches::empty_with_id(new_doc_color_swatches_id),\n+                    );\n+                    doc.color_swatches_outdated = false;\n+                    return;\n+                }\n+            };\n+\n+            // Most language servers will already send them sorted but ensure this is the case to\n+            // avoid errors on our end.\n+            swatches.sort_by_key(|inlay_hint| inlay_hint.range.start);\n+\n+            let mut color_swatches = Vec::new();",
        "comment_created_at": "2024-12-20T15:37:13+00:00",
        "comment_author": "filipdutescu",
        "comment_body": "We already know the sizes of the two vecs. You can initialise them with capacity from the get go",
        "pr_file_module": null
      },
      {
        "comment_id": "1894108281",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12308,
        "pr_file": "helix-term/src/commands/lsp.rs",
        "discussion_id": "1894083997",
        "commented_code": "@@ -1398,3 +1405,120 @@ fn compute_inlay_hints_for_view(\n \n     Some(callback)\n }\n+\n+pub fn compute_color_swatches_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {\n+    if !editor.config().lsp.display_color_swatches {\n+        return;\n+    }\n+\n+    for (view, _) in editor.tree.views() {\n+        let doc = match editor.documents.get(&view.doc) {\n+            Some(doc) => doc,\n+            None => continue,\n+        };\n+        if let Some(callback) = compute_color_swatches_for_view(view, doc) {\n+            jobs.callback(callback);\n+        }\n+    }\n+}\n+\n+fn compute_color_swatches_for_view(\n+    view: &View,\n+    doc: &Document,\n+) -> Option<std::pin::Pin<Box<impl Future<Output = Result<crate::job::Callback, anyhow::Error>>>>> {\n+    let view_id = view.id;\n+    let doc_id = view.doc;\n+\n+    let language_server = doc\n+        .language_servers_with_feature(LanguageServerFeature::ColorProvider)\n+        .next()?;\n+\n+    let (first_line, last_line) = lsp_annotations_area(view, doc);\n+\n+    let new_doc_color_swatches_id = ColorSwatchesId {\n+        first_line,\n+        last_line,\n+    };\n+\n+    // Don't recompute the color swatches in case nothing has changed about the view\n+    if !doc.color_swatches_outdated\n+        && doc\n+            .color_swatches(view_id)\n+            .map_or(false, |dih| dih.id == new_doc_color_swatches_id)\n+    {\n+        return None;\n+    }\n+\n+    let offset_encoding = language_server.offset_encoding();\n+\n+    let callback = super::make_job_callback(\n+        language_server.text_document_color_swatches(doc.identifier(), None)?,\n+        move |editor, _compositor, response: Option<Vec<lsp::ColorInformation>>| {\n+            // The config was modified or the window was closed while the request was in flight\n+            if !editor.config().lsp.display_color_swatches || editor.tree.try_get(view_id).is_none()\n+            {\n+                return;\n+            }\n+\n+            // Add annotations to relevant document, not the current one (it may have changed in between)\n+            let doc = match editor.documents.get_mut(&doc_id) {\n+                Some(doc) => doc,\n+                None => return,\n+            };\n+\n+            // If we have neither color swatches nor an LSP, empty the color swatches since they're now oudated\n+            let mut swatches = match response {\n+                Some(swatches) if !swatches.is_empty() => swatches,\n+                _ => {\n+                    doc.set_color_swatches(\n+                        view_id,\n+                        DocumentColorSwatches::empty_with_id(new_doc_color_swatches_id),\n+                    );\n+                    doc.color_swatches_outdated = false;\n+                    return;\n+                }\n+            };\n+\n+            // Most language servers will already send them sorted but ensure this is the case to\n+            // avoid errors on our end.\n+            swatches.sort_by_key(|inlay_hint| inlay_hint.range.start);\n+\n+            let mut color_swatches = Vec::new();",
        "comment_created_at": "2024-12-20T15:59:00+00:00",
        "comment_author": "nik-rev",
        "comment_body": "thank you for the idea! i added it",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1905598748",
    "pr_number": 12315,
    "pr_file": "helix-view/src/document.rs",
    "created_at": "2025-01-07T15:09:23+00:00",
    "commented_code": "use std::process::Stdio;\n             let text = self.text().clone();\n             let mut process = tokio::process::Command::new(&fmt_cmd);\n+            let cwd = std::env::current_dir().unwrap_or(PathBuf::from(\".\"));\n+            let file_path = cwd.join(self.display_name().to_string());\n+            let doc_path = self.path.clone().unwrap_or(file_path);",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1905598748",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12315,
        "pr_file": "helix-view/src/document.rs",
        "discussion_id": "1905598748",
        "commented_code": "@@ -761,7 +761,13 @@ impl Document {\n             use std::process::Stdio;\n             let text = self.text().clone();\n             let mut process = tokio::process::Command::new(&fmt_cmd);\n+            let cwd = std::env::current_dir().unwrap_or(PathBuf::from(\".\"));\n+            let file_path = cwd.join(self.display_name().to_string());\n+            let doc_path = self.path.clone().unwrap_or(file_path);",
        "comment_created_at": "2025-01-07T15:09:23+00:00",
        "comment_author": "kpbaks",
        "comment_body": "Use `unwrap_or_else(|| cwd.join(self.display_name().to_string());` to avoid the heap allocation on the `Some` branch.",
        "pr_file_module": null
      },
      {
        "comment_id": "1906147163",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12315,
        "pr_file": "helix-view/src/document.rs",
        "discussion_id": "1905598748",
        "commented_code": "@@ -761,7 +761,13 @@ impl Document {\n             use std::process::Stdio;\n             let text = self.text().clone();\n             let mut process = tokio::process::Command::new(&fmt_cmd);\n+            let cwd = std::env::current_dir().unwrap_or(PathBuf::from(\".\"));\n+            let file_path = cwd.join(self.display_name().to_string());\n+            let doc_path = self.path.clone().unwrap_or(file_path);",
        "comment_created_at": "2025-01-07T23:16:41+00:00",
        "comment_author": "robgonnella",
        "comment_body": "Thank you for the review! Updated",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1444120662",
    "pr_number": 9065,
    "pr_file": "helix-term/src/commands.rs",
    "created_at": "2024-01-08T01:57:17+00:00",
    "commented_code": "let primary = selections.primary();\n     // Checks whether there is only one selection with a width of 1\n     if selections.len() == 1 && primary.len() == 1 {\n-        let count = cx.count();\n-        let text_slice = text.slice(..);\n-        // In this case it selects the WORD under the cursor\n-        let current_word = textobject::textobject_word(\n-            text_slice,\n-            primary,\n-            textobject::TextObject::Inside,\n-            count,\n-            true,\n-        );\n-        // Trims some surrounding chars so that the actual file is opened.\n-        let surrounding_chars: &[_] = &['\\'', '\"', '(', ')'];\n         paths.clear();\n-        paths.push(\n-            current_word\n-                .fragment(text_slice)\n-                .trim_matches(surrounding_chars)\n-                .to_string(),\n-        );\n+\n+        let is_valid_path_char = |c: &char| {\n+            let valid_chars: &[char] = if cfg!(target_os = \"windows\") {\n+                &[\n+                    '@', '/', '\\\\', '.', '-', '_', '+', '#', '$', '%', '{', '}', '[', ']', ':',\n+                    '!', '~', '=',\n+                ]\n+            } else {\n+                &['@', '/', '.', '-', '_', '+', '#', '$', '%', '~', '=']\n+            };\n+            valid_chars.contains(c) || c.is_alphabetic()\n+        };\n+\n+        let path = {\n+            let start = {\n+                let cursor_pos = primary.cursor(text.slice(..));\n+\n+                let pre_cursor_pos = cursor_pos.saturating_sub(1);\n+                let post_cursor_pos = cursor_pos.saturating_add(1);\n+\n+                if is_valid_path_char(&text.char(cursor_pos)) {\n+                    text.chars_at(cursor_pos)\n+                } else if is_valid_path_char(&text.char(pre_cursor_pos)) {\n+                    text.chars_at(pre_cursor_pos)\n+                } else {\n+                    text.chars_at(post_cursor_pos)\n+                }\n+            };\n+\n+            let head = start\n+                .clone()\n+                .reversed()\n+                .take_while(is_valid_path_char)\n+                .collect::<String>()\n+                .chars()\n+                .rev()\n+                .collect::<String>();\n+",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1444120662",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 9065,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1444120662",
        "commented_code": "@@ -1176,25 +1176,55 @@ fn goto_file_impl(cx: &mut Context, action: Action) {\n     let primary = selections.primary();\n     // Checks whether there is only one selection with a width of 1\n     if selections.len() == 1 && primary.len() == 1 {\n-        let count = cx.count();\n-        let text_slice = text.slice(..);\n-        // In this case it selects the WORD under the cursor\n-        let current_word = textobject::textobject_word(\n-            text_slice,\n-            primary,\n-            textobject::TextObject::Inside,\n-            count,\n-            true,\n-        );\n-        // Trims some surrounding chars so that the actual file is opened.\n-        let surrounding_chars: &[_] = &['\\'', '\"', '(', ')'];\n         paths.clear();\n-        paths.push(\n-            current_word\n-                .fragment(text_slice)\n-                .trim_matches(surrounding_chars)\n-                .to_string(),\n-        );\n+\n+        let is_valid_path_char = |c: &char| {\n+            let valid_chars: &[char] = if cfg!(target_os = \"windows\") {\n+                &[\n+                    '@', '/', '\\\\', '.', '-', '_', '+', '#', '$', '%', '{', '}', '[', ']', ':',\n+                    '!', '~', '=',\n+                ]\n+            } else {\n+                &['@', '/', '.', '-', '_', '+', '#', '$', '%', '~', '=']\n+            };\n+            valid_chars.contains(c) || c.is_alphabetic()\n+        };\n+\n+        let path = {\n+            let start = {\n+                let cursor_pos = primary.cursor(text.slice(..));\n+\n+                let pre_cursor_pos = cursor_pos.saturating_sub(1);\n+                let post_cursor_pos = cursor_pos.saturating_add(1);\n+\n+                if is_valid_path_char(&text.char(cursor_pos)) {\n+                    text.chars_at(cursor_pos)\n+                } else if is_valid_path_char(&text.char(pre_cursor_pos)) {\n+                    text.chars_at(pre_cursor_pos)\n+                } else {\n+                    text.chars_at(post_cursor_pos)\n+                }\n+            };\n+\n+            let head = start\n+                .clone()\n+                .reversed()\n+                .take_while(is_valid_path_char)\n+                .collect::<String>()\n+                .chars()\n+                .rev()\n+                .collect::<String>();\n+",
        "comment_created_at": "2024-01-08T01:57:17+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "Instead of collecting twice simply find the length (using count and then use `text.slice(cursor-prefix_len..cursor+postfix_len)`..\r\n\r\nThen you can even convert to a Cow<str> (usually for free) without extra work.\r\n\r\nThat will be both faster and less messy",
        "pr_file_module": null
      },
      {
        "comment_id": "1449182100",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 9065,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1444120662",
        "commented_code": "@@ -1176,25 +1176,55 @@ fn goto_file_impl(cx: &mut Context, action: Action) {\n     let primary = selections.primary();\n     // Checks whether there is only one selection with a width of 1\n     if selections.len() == 1 && primary.len() == 1 {\n-        let count = cx.count();\n-        let text_slice = text.slice(..);\n-        // In this case it selects the WORD under the cursor\n-        let current_word = textobject::textobject_word(\n-            text_slice,\n-            primary,\n-            textobject::TextObject::Inside,\n-            count,\n-            true,\n-        );\n-        // Trims some surrounding chars so that the actual file is opened.\n-        let surrounding_chars: &[_] = &['\\'', '\"', '(', ')'];\n         paths.clear();\n-        paths.push(\n-            current_word\n-                .fragment(text_slice)\n-                .trim_matches(surrounding_chars)\n-                .to_string(),\n-        );\n+\n+        let is_valid_path_char = |c: &char| {\n+            let valid_chars: &[char] = if cfg!(target_os = \"windows\") {\n+                &[\n+                    '@', '/', '\\\\', '.', '-', '_', '+', '#', '$', '%', '{', '}', '[', ']', ':',\n+                    '!', '~', '=',\n+                ]\n+            } else {\n+                &['@', '/', '.', '-', '_', '+', '#', '$', '%', '~', '=']\n+            };\n+            valid_chars.contains(c) || c.is_alphabetic()\n+        };\n+\n+        let path = {\n+            let start = {\n+                let cursor_pos = primary.cursor(text.slice(..));\n+\n+                let pre_cursor_pos = cursor_pos.saturating_sub(1);\n+                let post_cursor_pos = cursor_pos.saturating_add(1);\n+\n+                if is_valid_path_char(&text.char(cursor_pos)) {\n+                    text.chars_at(cursor_pos)\n+                } else if is_valid_path_char(&text.char(pre_cursor_pos)) {\n+                    text.chars_at(pre_cursor_pos)\n+                } else {\n+                    text.chars_at(post_cursor_pos)\n+                }\n+            };\n+\n+            let head = start\n+                .clone()\n+                .reversed()\n+                .take_while(is_valid_path_char)\n+                .collect::<String>()\n+                .chars()\n+                .rev()\n+                .collect::<String>();\n+",
        "comment_created_at": "2024-01-11T17:30:03+00:00",
        "comment_author": "TornaxO7",
        "comment_body": "good point!",
        "pr_file_module": null
      }
    ]
  }
]