[
  {
    "discussion_id": "1148508640",
    "pr_number": 6118,
    "pr_file": "helix-term/src/ui/editor.rs",
    "created_at": "2023-03-26T08:49:25+00:00",
    "commented_code": ");\n     }\n \n+    /// Render the sticky context\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn render_sticky_context(\n+        doc: &Document,\n+        view: &View,\n+        surface: &mut Surface,\n+        context: &Option<Vec<StickyNode>>,\n+        doc_annotations: &TextAnnotations,\n+        line_decoration: &mut [Box<dyn LineDecoration + '_>],\n+        translated_positions: &mut [TranslatedPosition],\n+        theme: &Theme,\n+    ) {\n+        if let Some(context) = context {",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1148508640",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 6118,
        "pr_file": "helix-term/src/ui/editor.rs",
        "discussion_id": "1148508640",
        "commented_code": "@@ -706,6 +769,315 @@ impl EditorView {\n         );\n     }\n \n+    /// Render the sticky context\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn render_sticky_context(\n+        doc: &Document,\n+        view: &View,\n+        surface: &mut Surface,\n+        context: &Option<Vec<StickyNode>>,\n+        doc_annotations: &TextAnnotations,\n+        line_decoration: &mut [Box<dyn LineDecoration + '_>],\n+        translated_positions: &mut [TranslatedPosition],\n+        theme: &Theme,\n+    ) {\n+        if let Some(context) = context {",
        "comment_created_at": "2023-03-26T08:49:25+00:00",
        "comment_author": "pickfire",
        "comment_body": "```suggestion\r\n        let Some(context) = context else {\r\n            return;\r\n        }\r\n```\r\nCan do quick return here, reduce indent level.",
        "pr_file_module": null
      },
      {
        "comment_id": "1148550859",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 6118,
        "pr_file": "helix-term/src/ui/editor.rs",
        "discussion_id": "1148508640",
        "commented_code": "@@ -706,6 +769,315 @@ impl EditorView {\n         );\n     }\n \n+    /// Render the sticky context\n+    #[allow(clippy::too_many_arguments)]\n+    pub fn render_sticky_context(\n+        doc: &Document,\n+        view: &View,\n+        surface: &mut Surface,\n+        context: &Option<Vec<StickyNode>>,\n+        doc_annotations: &TextAnnotations,\n+        line_decoration: &mut [Box<dyn LineDecoration + '_>],\n+        translated_positions: &mut [TranslatedPosition],\n+        theme: &Theme,\n+    ) {\n+        if let Some(context) = context {",
        "comment_created_at": "2023-03-26T13:05:46+00:00",
        "comment_author": "SoraTenshi",
        "comment_body": "Oh wow! This is something i actually didn't know you could do!\r\nThanks!",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1157370781",
    "pr_number": 2507,
    "pr_file": "helix-lsp/src/client.rs",
    "created_at": "2023-04-04T14:47:16+00:00",
    "commented_code": ".expect(\"language server not yet initialized!\")\n     }\n \n+    #[inline] // TODO inline?\n+    pub fn supports_feature(&self, feature: LanguageServerFeature) -> bool {\n+        let capabilities = match self.capabilities.get() {\n+            Some(capabilities) => capabilities,\n+            None => return false, // not initialized, TODO unwrap/expect instead?\n+        };",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1157370781",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-lsp/src/client.rs",
        "discussion_id": "1157370781",
        "commented_code": "@@ -268,6 +274,93 @@ impl Client {\n             .expect(\"language server not yet initialized!\")\n     }\n \n+    #[inline] // TODO inline?\n+    pub fn supports_feature(&self, feature: LanguageServerFeature) -> bool {\n+        let capabilities = match self.capabilities.get() {\n+            Some(capabilities) => capabilities,\n+            None => return false, // not initialized, TODO unwrap/expect instead?\n+        };",
        "comment_created_at": "2023-04-04T14:47:16+00:00",
        "comment_author": "pickfire",
        "comment_body": "```suggestion\r\n        let Some(capabilities) = self.capabilities.get() else {\r\n            return false; // not initialized, TODO unwrap/expect instead?\r\n        };\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1157385359",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-lsp/src/client.rs",
        "discussion_id": "1157370781",
        "commented_code": "@@ -268,6 +274,93 @@ impl Client {\n             .expect(\"language server not yet initialized!\")\n     }\n \n+    #[inline] // TODO inline?\n+    pub fn supports_feature(&self, feature: LanguageServerFeature) -> bool {\n+        let capabilities = match self.capabilities.get() {\n+            Some(capabilities) => capabilities,\n+            None => return false, // not initialized, TODO unwrap/expect instead?\n+        };",
        "comment_created_at": "2023-04-04T14:57:12+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "rustfmt won't help us fix this yet but I think the style guide suggests (https://github.com/rust-lang/rust/blob/c8ead2e693a22fe94c6b3edeb3f49c7e6aec3912/src/doc/style-guide/src/statements.md#single-line-let-else-statements):\r\n\r\n```rs\r\nlet Some(capabilities) = self.capabilities.get() else { return false };\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1157484525",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-lsp/src/client.rs",
        "discussion_id": "1157370781",
        "commented_code": "@@ -268,6 +274,93 @@ impl Client {\n             .expect(\"language server not yet initialized!\")\n     }\n \n+    #[inline] // TODO inline?\n+    pub fn supports_feature(&self, feature: LanguageServerFeature) -> bool {\n+        let capabilities = match self.capabilities.get() {\n+            Some(capabilities) => capabilities,\n+            None => return false, // not initialized, TODO unwrap/expect instead?\n+        };",
        "comment_created_at": "2023-04-04T16:15:31+00:00",
        "comment_author": "Philipp-M",
        "comment_body": "Yeah `let .. else` is better, though as the `TODO` notes, I'm not sure if an `expect` or just `Client::capabilities()` may be better here, because this method shouldn't be run if the `Client` isn't initialized yet, and I think this can produce weird issues if features aren't supported (although the client does) but the client isn't initialized, and it's easier to find bugs if helix just terminates? But in that case it has to be guaranteed that the client is indeed initialized. All the other methods that are checking the capabilities are also unwrapping.",
        "pr_file_module": null
      },
      {
        "comment_id": "1157874734",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-lsp/src/client.rs",
        "discussion_id": "1157370781",
        "commented_code": "@@ -268,6 +274,93 @@ impl Client {\n             .expect(\"language server not yet initialized!\")\n     }\n \n+    #[inline] // TODO inline?\n+    pub fn supports_feature(&self, feature: LanguageServerFeature) -> bool {\n+        let capabilities = match self.capabilities.get() {\n+            Some(capabilities) => capabilities,\n+            None => return false, // not initialized, TODO unwrap/expect instead?\n+        };",
        "comment_created_at": "2023-04-04T23:59:33+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "yeah we already unwrap in all other functions I think it's ok to unwrap if you had a doc comment about that above. ",
        "pr_file_module": null
      },
      {
        "comment_id": "1158859696",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-lsp/src/client.rs",
        "discussion_id": "1157370781",
        "commented_code": "@@ -268,6 +274,93 @@ impl Client {\n             .expect(\"language server not yet initialized!\")\n     }\n \n+    #[inline] // TODO inline?\n+    pub fn supports_feature(&self, feature: LanguageServerFeature) -> bool {\n+        let capabilities = match self.capabilities.get() {\n+            Some(capabilities) => capabilities,\n+            None => return false, // not initialized, TODO unwrap/expect instead?\n+        };",
        "comment_created_at": "2023-04-05T18:16:20+00:00",
        "comment_author": "Philipp-M",
        "comment_body": "Done in https://github.com/helix-editor/helix/pull/2507/commits/873c0eef910fc69af43e6431ff40019af03c8b0d",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2105910590",
    "pr_number": 13600,
    "pr_file": "helix-term/src/commands.rs",
    "created_at": "2025-05-24T19:23:11+00:00",
    "commented_code": "}\n \n fn replace_with_yanked_impl(editor: &mut Editor, register: char, count: usize) {\n-    let Some(values) = editor\n-        .registers\n-        .read(register, editor)\n-        .filter(|values| values.len() > 0)\n-    else {\n+    let scrolloff = editor.config().scrolloff;\n+\n+    let Some(values) = editor.registers.read(register, editor) else {\n         return;\n     };\n-    let scrolloff = editor.config().scrolloff;\n-    let (view, doc) = current_ref!(editor);\n+    let yanked = values.map(|value| value.to_string()).collect::<Vec<_>>();\n+    let (view, doc) = current!(editor);\n \n-    let map_value = |value: &Cow<str>| {\n+    replace_impl(&yanked, doc, view, scrolloff, count)\n+}\n+\n+fn replace_impl(\n+    values: &[String],\n+    doc: &mut Document,\n+    view: &mut View,\n+    count: usize,\n+    scrolloff: usize,\n+) {\n+    let map_value = |value: &String| {\n         let value = LINE_ENDING_REGEX.replace_all(value, doc.line_ending.as_str());\n         let mut out = Tendril::from(value.as_ref());\n         for _ in 1..count {\n             out.push_str(&value);\n         }\n         out\n     };\n-    let mut values_rev = values.rev().peekable();\n-    // `values` is asserted to have at least one entry above.\n-    let last = values_rev.peek().unwrap();\n+    let mut values_rev = values.iter().rev().peekable();\n+    let Some(last) = values_rev.peek() else {",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2105910590",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13600,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "2105910590",
        "commented_code": "@@ -4746,32 +4783,38 @@ fn replace_with_yanked(cx: &mut Context) {\n }\n \n fn replace_with_yanked_impl(editor: &mut Editor, register: char, count: usize) {\n-    let Some(values) = editor\n-        .registers\n-        .read(register, editor)\n-        .filter(|values| values.len() > 0)\n-    else {\n+    let scrolloff = editor.config().scrolloff;\n+\n+    let Some(values) = editor.registers.read(register, editor) else {\n         return;\n     };\n-    let scrolloff = editor.config().scrolloff;\n-    let (view, doc) = current_ref!(editor);\n+    let yanked = values.map(|value| value.to_string()).collect::<Vec<_>>();\n+    let (view, doc) = current!(editor);\n \n-    let map_value = |value: &Cow<str>| {\n+    replace_impl(&yanked, doc, view, scrolloff, count)\n+}\n+\n+fn replace_impl(\n+    values: &[String],\n+    doc: &mut Document,\n+    view: &mut View,\n+    count: usize,\n+    scrolloff: usize,\n+) {\n+    let map_value = |value: &String| {\n         let value = LINE_ENDING_REGEX.replace_all(value, doc.line_ending.as_str());\n         let mut out = Tendril::from(value.as_ref());\n         for _ in 1..count {\n             out.push_str(&value);\n         }\n         out\n     };\n-    let mut values_rev = values.rev().peekable();\n-    // `values` is asserted to have at least one entry above.\n-    let last = values_rev.peek().unwrap();\n+    let mut values_rev = values.iter().rev().peekable();\n+    let Some(last) = values_rev.peek() else {",
        "comment_created_at": "2025-05-24T19:23:11+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "Why did you change this from an unwrap? As far as I can see there is still always atleast one value? \r\n\r\nAnd if there isn't I would rather unwrap instead of silently doing nothing (or atleast log an error)",
        "pr_file_module": null
      },
      {
        "comment_id": "2105917161",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13600,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "2105910590",
        "commented_code": "@@ -4746,32 +4783,38 @@ fn replace_with_yanked(cx: &mut Context) {\n }\n \n fn replace_with_yanked_impl(editor: &mut Editor, register: char, count: usize) {\n-    let Some(values) = editor\n-        .registers\n-        .read(register, editor)\n-        .filter(|values| values.len() > 0)\n-    else {\n+    let scrolloff = editor.config().scrolloff;\n+\n+    let Some(values) = editor.registers.read(register, editor) else {\n         return;\n     };\n-    let scrolloff = editor.config().scrolloff;\n-    let (view, doc) = current_ref!(editor);\n+    let yanked = values.map(|value| value.to_string()).collect::<Vec<_>>();\n+    let (view, doc) = current!(editor);\n \n-    let map_value = |value: &Cow<str>| {\n+    replace_impl(&yanked, doc, view, scrolloff, count)\n+}\n+\n+fn replace_impl(\n+    values: &[String],\n+    doc: &mut Document,\n+    view: &mut View,\n+    count: usize,\n+    scrolloff: usize,\n+) {\n+    let map_value = |value: &String| {\n         let value = LINE_ENDING_REGEX.replace_all(value, doc.line_ending.as_str());\n         let mut out = Tendril::from(value.as_ref());\n         for _ in 1..count {\n             out.push_str(&value);\n         }\n         out\n     };\n-    let mut values_rev = values.rev().peekable();\n-    // `values` is asserted to have at least one entry above.\n-    let last = values_rev.peek().unwrap();\n+    let mut values_rev = values.iter().rev().peekable();\n+    let Some(last) = values_rev.peek() else {",
        "comment_created_at": "2025-05-24T19:58:04+00:00",
        "comment_author": "nik-rev",
        "comment_body": "Previously we had `registers.read().filter(|values| values.len() > 0)` and would return if it's empty. So unwrap was ok. This all happened in the body of the same function\r\n\r\nBut now, I've moved `registers.read().filter(|values| values.len() > 0)` *outside* of `replace_impl`. Keeping the unwrap means placing an extra constraint on the caller and I think it'd be better to do the validation inside of `replace_impl`, so I removed call to `.filter`\r\n\r\nThe effect is the same as before: Do nothing if it's empty.\r\n\r\nIt *can* be empty when the register contains nothing. E.g., `\"m<C-R>` would do nothing if `m` is empty.\r\n\r\nThis behaviour (including not logging anything) is consistent with what would happen if you did `\"mp`, `\"mP`, `\"mR` etc if the `m` register is empty",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1895633505",
    "pr_number": 12308,
    "pr_file": "helix-term/src/commands/lsp.rs",
    "created_at": "2024-12-23T11:18:50+00:00",
    "commented_code": "Some(callback)\n }\n+\n+pub fn compute_color_swatches_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {\n+    if !editor.config().lsp.display_color_swatches {\n+        return;\n+    }\n+\n+    for (view, _) in editor.tree.views() {\n+        let doc = match editor.documents.get(&view.doc) {\n+            Some(doc) => doc,\n+            None => continue,\n+        };",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1895633505",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12308,
        "pr_file": "helix-term/src/commands/lsp.rs",
        "discussion_id": "1895633505",
        "commented_code": "@@ -1398,3 +1405,120 @@ fn compute_inlay_hints_for_view(\n \n     Some(callback)\n }\n+\n+pub fn compute_color_swatches_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {\n+    if !editor.config().lsp.display_color_swatches {\n+        return;\n+    }\n+\n+    for (view, _) in editor.tree.views() {\n+        let doc = match editor.documents.get(&view.doc) {\n+            Some(doc) => doc,\n+            None => continue,\n+        };",
        "comment_created_at": "2024-12-23T11:18:50+00:00",
        "comment_author": "TornaxO7",
        "comment_body": "```suggestion\r\n        let Some(doc) = editor.documents.get(&view.doc) else {\r\n            continue;\r\n        };\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1895636406",
    "pr_number": 12308,
    "pr_file": "helix-term/src/commands/lsp.rs",
    "created_at": "2024-12-23T11:22:16+00:00",
    "commented_code": "Some(callback)\n }\n+\n+pub fn compute_color_swatches_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {\n+    if !editor.config().lsp.display_color_swatches {\n+        return;\n+    }\n+\n+    for (view, _) in editor.tree.views() {\n+        let doc = match editor.documents.get(&view.doc) {\n+            Some(doc) => doc,\n+            None => continue,\n+        };\n+        if let Some(callback) = compute_color_swatches_for_view(view, doc) {\n+            jobs.callback(callback);\n+        }\n+    }\n+}\n+\n+fn compute_color_swatches_for_view(\n+    view: &View,\n+    doc: &Document,\n+) -> Option<std::pin::Pin<Box<impl Future<Output = Result<crate::job::Callback, anyhow::Error>>>>> {\n+    let view_id = view.id;\n+    let doc_id = view.doc;\n+\n+    let language_server = doc\n+        .language_servers_with_feature(LanguageServerFeature::ColorProvider)\n+        .next()?;\n+\n+    let (first_line, last_line) = lsp_annotations_area(view, doc);\n+\n+    let new_doc_color_swatches_id = ColorSwatchesId {\n+        first_line,\n+        last_line,\n+    };\n+\n+    // Don't recompute the color swatches in case nothing has changed about the view\n+    if !doc.color_swatches_outdated\n+        && doc\n+            .color_swatches(view_id)\n+            .map_or(false, |dih| dih.id == new_doc_color_swatches_id)\n+    {\n+        return None;\n+    }\n+\n+    let offset_encoding = language_server.offset_encoding();\n+\n+    let callback = super::make_job_callback(\n+        language_server.text_document_color_swatches(doc.identifier(), None)?,\n+        move |editor, _compositor, response: Option<Vec<lsp::ColorInformation>>| {\n+            // The config was modified or the window was closed while the request was in flight\n+            if !editor.config().lsp.display_color_swatches || editor.tree.try_get(view_id).is_none()\n+            {\n+                return;\n+            }\n+\n+            // Add annotations to relevant document, not the current one (it may have changed in between)\n+            let doc = match editor.documents.get_mut(&doc_id) {\n+                Some(doc) => doc,\n+                None => return,\n+            };\n+\n+            // If we have neither color swatches nor an LSP, empty the color swatches since they're now oudated\n+            let mut swatches = match response {\n+                Some(swatches) if !swatches.is_empty() => swatches,\n+                _ => {\n+                    doc.set_color_swatches(\n+                        view_id,\n+                        DocumentColorSwatches::empty_with_id(new_doc_color_swatches_id),\n+                    );\n+                    doc.color_swatches_outdated = false;\n+                    return;\n+                }\n+            };\n+\n+            // Most language servers will already send them sorted but ensure this is the case to\n+            // avoid errors on our end.\n+            swatches.sort_by_key(|inlay_hint| inlay_hint.range.start);\n+\n+            let mut color_swatches = Vec::with_capacity(swatches.len());\n+            let mut colors = Vec::with_capacity(swatches.len());\n+\n+            let doc_text = doc.text();\n+\n+            for swatch in swatches {\n+                let char_idx = match helix_lsp::util::lsp_pos_to_pos(\n+                    doc_text,\n+                    swatch.range.start,\n+                    offset_encoding,\n+                ) {\n+                    Some(pos) => pos,\n+                    // Skip color swatches that have no \"real\" position\n+                    None => continue,\n+                };",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1895636406",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12308,
        "pr_file": "helix-term/src/commands/lsp.rs",
        "discussion_id": "1895636406",
        "commented_code": "@@ -1398,3 +1405,120 @@ fn compute_inlay_hints_for_view(\n \n     Some(callback)\n }\n+\n+pub fn compute_color_swatches_for_all_views(editor: &mut Editor, jobs: &mut crate::job::Jobs) {\n+    if !editor.config().lsp.display_color_swatches {\n+        return;\n+    }\n+\n+    for (view, _) in editor.tree.views() {\n+        let doc = match editor.documents.get(&view.doc) {\n+            Some(doc) => doc,\n+            None => continue,\n+        };\n+        if let Some(callback) = compute_color_swatches_for_view(view, doc) {\n+            jobs.callback(callback);\n+        }\n+    }\n+}\n+\n+fn compute_color_swatches_for_view(\n+    view: &View,\n+    doc: &Document,\n+) -> Option<std::pin::Pin<Box<impl Future<Output = Result<crate::job::Callback, anyhow::Error>>>>> {\n+    let view_id = view.id;\n+    let doc_id = view.doc;\n+\n+    let language_server = doc\n+        .language_servers_with_feature(LanguageServerFeature::ColorProvider)\n+        .next()?;\n+\n+    let (first_line, last_line) = lsp_annotations_area(view, doc);\n+\n+    let new_doc_color_swatches_id = ColorSwatchesId {\n+        first_line,\n+        last_line,\n+    };\n+\n+    // Don't recompute the color swatches in case nothing has changed about the view\n+    if !doc.color_swatches_outdated\n+        && doc\n+            .color_swatches(view_id)\n+            .map_or(false, |dih| dih.id == new_doc_color_swatches_id)\n+    {\n+        return None;\n+    }\n+\n+    let offset_encoding = language_server.offset_encoding();\n+\n+    let callback = super::make_job_callback(\n+        language_server.text_document_color_swatches(doc.identifier(), None)?,\n+        move |editor, _compositor, response: Option<Vec<lsp::ColorInformation>>| {\n+            // The config was modified or the window was closed while the request was in flight\n+            if !editor.config().lsp.display_color_swatches || editor.tree.try_get(view_id).is_none()\n+            {\n+                return;\n+            }\n+\n+            // Add annotations to relevant document, not the current one (it may have changed in between)\n+            let doc = match editor.documents.get_mut(&doc_id) {\n+                Some(doc) => doc,\n+                None => return,\n+            };\n+\n+            // If we have neither color swatches nor an LSP, empty the color swatches since they're now oudated\n+            let mut swatches = match response {\n+                Some(swatches) if !swatches.is_empty() => swatches,\n+                _ => {\n+                    doc.set_color_swatches(\n+                        view_id,\n+                        DocumentColorSwatches::empty_with_id(new_doc_color_swatches_id),\n+                    );\n+                    doc.color_swatches_outdated = false;\n+                    return;\n+                }\n+            };\n+\n+            // Most language servers will already send them sorted but ensure this is the case to\n+            // avoid errors on our end.\n+            swatches.sort_by_key(|inlay_hint| inlay_hint.range.start);\n+\n+            let mut color_swatches = Vec::with_capacity(swatches.len());\n+            let mut colors = Vec::with_capacity(swatches.len());\n+\n+            let doc_text = doc.text();\n+\n+            for swatch in swatches {\n+                let char_idx = match helix_lsp::util::lsp_pos_to_pos(\n+                    doc_text,\n+                    swatch.range.start,\n+                    offset_encoding,\n+                ) {\n+                    Some(pos) => pos,\n+                    // Skip color swatches that have no \"real\" position\n+                    None => continue,\n+                };",
        "comment_created_at": "2024-12-23T11:22:16+00:00",
        "comment_author": "TornaxO7",
        "comment_body": "```suggestion\r\n                let Some(char_idx) = match helix_lsp::util::lsp_pos_to_pos(\r\n                    doc_text,\r\n                    swatch.range.start,\r\n                    offset_encoding,\r\n                )  else {\r\n                    // Skip color swatches that have no \"real\" position\r\n                    continue;\r\n                };\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1181898596",
    "pr_number": 6197,
    "pr_file": "helix-term/src/ui/editor.rs",
    "created_at": "2023-05-01T21:15:06+00:00",
    "commented_code": ".for_each(|area| surface.set_style(area, ruler_theme))\n     }\n \n+    /// Gets the word under the cursor\n+    pub fn cursor_word(doc: &Document, view: &View) -> Option<String> {\n+        let text = doc.text().slice(..);\n+        let cursor = doc.selection(view.id).primary().cursor(text);\n+        let char_under_cursor = text.get_char(cursor);\n+        if !char_under_cursor.map_or(false, char_is_word) {\n+            return None;\n+        }\n+\n+        let chars_at_cursor = text.chars_at(cursor);\n+        let reversed_chars = chars_at_cursor.clone().reversed();\n+        let start = cursor.saturating_sub(reversed_chars.take_while(|c| char_is_word(*c)).count());\n+        let end = cursor + chars_at_cursor.take_while(|c| char_is_word(*c)).count();\n+\n+        Some(text.slice(start..end).to_string())\n+    }\n+\n+    /// Calculates the ranges of the word under the cursor and returns the result\n+    fn calculate_cursor_word(\n+        doc: &Document,\n+        view: &View,\n+        viewport: Rect,\n+        scope_index: usize,\n+    ) -> Vec<(usize, std::ops::Range<usize>)> {\n+        let text = doc.text().slice(..);\n+        let mut result = Vec::new();\n+\n+        let cursor_word = match Self::cursor_word(doc, view) {\n+            Some(cw) => cw,\n+            None => return result,\n+        };",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1181898596",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 6197,
        "pr_file": "helix-term/src/ui/editor.rs",
        "discussion_id": "1181898596",
        "commented_code": "@@ -248,6 +257,103 @@ impl EditorView {\n             .for_each(|area| surface.set_style(area, ruler_theme))\n     }\n \n+    /// Gets the word under the cursor\n+    pub fn cursor_word(doc: &Document, view: &View) -> Option<String> {\n+        let text = doc.text().slice(..);\n+        let cursor = doc.selection(view.id).primary().cursor(text);\n+        let char_under_cursor = text.get_char(cursor);\n+        if !char_under_cursor.map_or(false, char_is_word) {\n+            return None;\n+        }\n+\n+        let chars_at_cursor = text.chars_at(cursor);\n+        let reversed_chars = chars_at_cursor.clone().reversed();\n+        let start = cursor.saturating_sub(reversed_chars.take_while(|c| char_is_word(*c)).count());\n+        let end = cursor + chars_at_cursor.take_while(|c| char_is_word(*c)).count();\n+\n+        Some(text.slice(start..end).to_string())\n+    }\n+\n+    /// Calculates the ranges of the word under the cursor and returns the result\n+    fn calculate_cursor_word(\n+        doc: &Document,\n+        view: &View,\n+        viewport: Rect,\n+        scope_index: usize,\n+    ) -> Vec<(usize, std::ops::Range<usize>)> {\n+        let text = doc.text().slice(..);\n+        let mut result = Vec::new();\n+\n+        let cursor_word = match Self::cursor_word(doc, view) {\n+            Some(cw) => cw,\n+            None => return result,\n+        };",
        "comment_created_at": "2023-05-01T21:15:06+00:00",
        "comment_author": "poliorcetics",
        "comment_body": "```suggestion\r\n        let Some(cursor_word) = Self::cursor_word(doc, view) else {\r\n            return result;\r\n        };\r\n```",
        "pr_file_module": null
      }
    ]
  }
]