[
  {
    "discussion_id": "1917313707",
    "pr_number": 11695,
    "pr_file": "helix-core/src/surround.rs",
    "created_at": "2025-01-15T20:46:40+00:00",
    "commented_code": "Err(Error::PairNotFound)\n }\n \n+pub enum FindType {",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1917313707",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11695,
        "pr_file": "helix-core/src/surround.rs",
        "discussion_id": "1917313707",
        "commented_code": "@@ -154,14 +154,20 @@ fn find_nth_closest_pairs_plain(\n     Err(Error::PairNotFound)\n }\n \n+pub enum FindType {",
        "comment_created_at": "2025-01-15T20:46:40+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "It looks like each of these enum variants are storing the count, right? Let's separate the enum from the count and pass that as a separate parameter even if it means adding `#[allow(clippy::too_many_arguments)]` for some functions",
        "pr_file_module": null
      },
      {
        "comment_id": "1933893163",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 11695,
        "pr_file": "helix-core/src/surround.rs",
        "discussion_id": "1917313707",
        "commented_code": "@@ -154,14 +154,20 @@ fn find_nth_closest_pairs_plain(\n     Err(Error::PairNotFound)\n }\n \n+pub enum FindType {",
        "comment_created_at": "2025-01-29T13:35:42+00:00",
        "comment_author": "thomasschafer",
        "comment_body": "Sounds good, done",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1275509361",
    "pr_number": 6118,
    "pr_file": "helix-term/src/ui/editor.rs",
    "created_at": "2023-07-26T21:40:41+00:00",
    "commented_code": "(true, false) => gutter_selected_style_virtual,\n                 };\n \n+                let mut doc_line = Some(pos.doc_line);\n+                if let Some(current_context) = context\n+                    .as_ref()\n+                    .and_then(|c| c.iter().find(|n| n.visual_line == pos.visual_line))\n+                {\n+                    doc_line = if current_context.indicator.is_some() {\n+                        None\n+                    } else {\n+                        Some(current_context.line)\n+                    };",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1275509361",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 6118,
        "pr_file": "helix-term/src/ui/editor.rs",
        "discussion_id": "1275509361",
        "commented_code": "@@ -608,12 +654,28 @@ impl EditorView {\n                     (true, false) => gutter_selected_style_virtual,\n                 };\n \n+                let mut doc_line = Some(pos.doc_line);\n+                if let Some(current_context) = context\n+                    .as_ref()\n+                    .and_then(|c| c.iter().find(|n| n.visual_line == pos.visual_line))\n+                {\n+                    doc_line = if current_context.indicator.is_some() {\n+                        None\n+                    } else {\n+                        Some(current_context.line)\n+                    };",
        "comment_created_at": "2023-07-26T21:40:41+00:00",
        "comment_author": "poliorcetics",
        "comment_body": "a match would be clearer here IMO",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1141226860",
    "pr_number": 2507,
    "pr_file": "helix-term/src/commands/typed.rs",
    "created_at": "2023-03-19T00:54:42+00:00",
    "commented_code": "if event != PromptEvent::Validate {\n         return Ok(());\n     }\n+    let doc = doc!(cx.editor);\n+    let id_options = doc\n+        .language_servers_with_feature(LanguageServerFeature::WorkspaceCommand)\n+        .find_map(|ls| {\n+            ls.capabilities()\n+                .execute_command_provider\n+                .as_ref()\n+                .map(|options| (ls.id(), options))\n+        });",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1141226860",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 2507,
        "pr_file": "helix-term/src/commands/typed.rs",
        "discussion_id": "1141226860",
        "commented_code": "@@ -1257,26 +1257,26 @@ fn lsp_workspace_command(\n     if event != PromptEvent::Validate {\n         return Ok(());\n     }\n+    let doc = doc!(cx.editor);\n+    let id_options = doc\n+        .language_servers_with_feature(LanguageServerFeature::WorkspaceCommand)\n+        .find_map(|ls| {\n+            ls.capabilities()\n+                .execute_command_provider\n+                .as_ref()\n+                .map(|options| (ls.id(), options))\n+        });",
        "comment_created_at": "2023-03-19T00:54:42+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "```suggestion\r\n    let Some((language_server_id, options)) = doc\r\n        .language_servers_with_feature(LanguageServerFeature::WorkspaceCommand)\r\n        .find_map(|ls| {\r\n            ls.capabilities()\r\n                .execute_command_provider\r\n                .as_ref()\r\n                .map(|options| (ls.id(), options))\r\n        })\r\n    else {\r\n        cx.editor.set_status(\r\n             \"No active language servers for this document support workspace commands\",\r\n        );\r\n        return Ok(());\r\n    };\r\n```\r\n\r\nperfect case for `let .. else` (`id_options` as a variable name confused me)",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2140288923",
    "pr_number": 13742,
    "pr_file": "helix-term/src/commands/lsp.rs",
    "created_at": "2025-06-11T14:05:41+00:00",
    "commented_code": "None => continue,\n                     };\n \n-                let label = match hint.label {\n-                    lsp::InlayHintLabel::String(s) => s,\n-                    lsp::InlayHintLabel::LabelParts(parts) => parts\n-                        .into_iter()\n-                        .map(|p| p.value)\n-                        .collect::<Vec<_>>()\n-                        .join(\"\"),\n+                let label = {",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2140288923",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13742,
        "pr_file": "helix-term/src/commands/lsp.rs",
        "discussion_id": "2140288923",
        "commented_code": "@@ -1367,13 +1368,25 @@ fn compute_inlay_hints_for_view(\n                         None => continue,\n                     };\n \n-                let label = match hint.label {\n-                    lsp::InlayHintLabel::String(s) => s,\n-                    lsp::InlayHintLabel::LabelParts(parts) => parts\n-                        .into_iter()\n-                        .map(|p| p.value)\n-                        .collect::<Vec<_>>()\n-                        .join(\"\"),\n+                let label = {",
        "comment_created_at": "2025-06-11T14:05:41+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "Stylewise we avoid `let` blocks because they lead to increased indentation. It's fine to let `label` be `mut` for this `for` loop scope",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1444120957",
    "pr_number": 9065,
    "pr_file": "helix-term/src/commands.rs",
    "created_at": "2024-01-08T01:58:44+00:00",
    "commented_code": "let primary = selections.primary();\n     // Checks whether there is only one selection with a width of 1\n     if selections.len() == 1 && primary.len() == 1 {\n-        let count = cx.count();\n-        let text_slice = text.slice(..);\n-        // In this case it selects the WORD under the cursor\n-        let current_word = textobject::textobject_word(\n-            text_slice,\n-            primary,\n-            textobject::TextObject::Inside,\n-            count,\n-            true,\n-        );\n-        // Trims some surrounding chars so that the actual file is opened.\n-        let surrounding_chars: &[_] = &['\\'', '\"', '(', ')'];\n         paths.clear();\n-        paths.push(\n-            current_word\n-                .fragment(text_slice)\n-                .trim_matches(surrounding_chars)\n-                .to_string(),\n-        );\n+\n+        let is_valid_path_char = |c: &char| {\n+            let valid_chars: &[char] = if cfg!(target_os = \"windows\") {\n+                &[\n+                    '@', '/', '\\\\', '.', '-', '_', '+', '#', '$', '%', '{', '}', '[', ']', ':',\n+                    '!', '~', '=',\n+                ]\n+            } else {\n+                &['@', '/', '.', '-', '_', '+', '#', '$', '%', '~', '=']\n+            };\n+            valid_chars.contains(c) || c.is_alphabetic()\n+        };\n+\n+        let path = {",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1444120957",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 9065,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1444120957",
        "commented_code": "@@ -1176,25 +1176,55 @@ fn goto_file_impl(cx: &mut Context, action: Action) {\n     let primary = selections.primary();\n     // Checks whether there is only one selection with a width of 1\n     if selections.len() == 1 && primary.len() == 1 {\n-        let count = cx.count();\n-        let text_slice = text.slice(..);\n-        // In this case it selects the WORD under the cursor\n-        let current_word = textobject::textobject_word(\n-            text_slice,\n-            primary,\n-            textobject::TextObject::Inside,\n-            count,\n-            true,\n-        );\n-        // Trims some surrounding chars so that the actual file is opened.\n-        let surrounding_chars: &[_] = &['\\'', '\"', '(', ')'];\n         paths.clear();\n-        paths.push(\n-            current_word\n-                .fragment(text_slice)\n-                .trim_matches(surrounding_chars)\n-                .to_string(),\n-        );\n+\n+        let is_valid_path_char = |c: &char| {\n+            let valid_chars: &[char] = if cfg!(target_os = \"windows\") {\n+                &[\n+                    '@', '/', '\\\\', '.', '-', '_', '+', '#', '$', '%', '{', '}', '[', ']', ':',\n+                    '!', '~', '=',\n+                ]\n+            } else {\n+                &['@', '/', '.', '-', '_', '+', '#', '$', '%', '~', '=']\n+            };\n+            valid_chars.contains(c) || c.is_alphabetic()\n+        };\n+\n+        let path = {",
        "comment_created_at": "2024-01-08T01:58:44+00:00",
        "comment_author": "pascalkuthe",
        "comment_body": "Please don't create such nested assignments. It's hard to read and doesn't fit with the style of the codebase.",
        "pr_file_module": null
      },
      {
        "comment_id": "1449184161",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 9065,
        "pr_file": "helix-term/src/commands.rs",
        "discussion_id": "1444120957",
        "commented_code": "@@ -1176,25 +1176,55 @@ fn goto_file_impl(cx: &mut Context, action: Action) {\n     let primary = selections.primary();\n     // Checks whether there is only one selection with a width of 1\n     if selections.len() == 1 && primary.len() == 1 {\n-        let count = cx.count();\n-        let text_slice = text.slice(..);\n-        // In this case it selects the WORD under the cursor\n-        let current_word = textobject::textobject_word(\n-            text_slice,\n-            primary,\n-            textobject::TextObject::Inside,\n-            count,\n-            true,\n-        );\n-        // Trims some surrounding chars so that the actual file is opened.\n-        let surrounding_chars: &[_] = &['\\'', '\"', '(', ')'];\n         paths.clear();\n-        paths.push(\n-            current_word\n-                .fragment(text_slice)\n-                .trim_matches(surrounding_chars)\n-                .to_string(),\n-        );\n+\n+        let is_valid_path_char = |c: &char| {\n+            let valid_chars: &[char] = if cfg!(target_os = \"windows\") {\n+                &[\n+                    '@', '/', '\\\\', '.', '-', '_', '+', '#', '$', '%', '{', '}', '[', ']', ':',\n+                    '!', '~', '=',\n+                ]\n+            } else {\n+                &['@', '/', '.', '-', '_', '+', '#', '$', '%', '~', '=']\n+            };\n+            valid_chars.contains(c) || c.is_alphabetic()\n+        };\n+\n+        let path = {",
        "comment_created_at": "2024-01-11T17:32:07+00:00",
        "comment_author": "TornaxO7",
        "comment_body": "Sorry! I'm still unfamiliar with the codestyle. It's removed now :+1: ",
        "pr_file_module": null
      }
    ]
  }
]