[
  {
    "discussion_id": "1957107849",
    "pr_number": 12831,
    "pr_file": "flake.nix",
    "created_at": "2025-02-15T12:31:30+00:00",
    "commented_code": "url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reelvalute the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n+        };\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove\n+          pkgs.installShellFiles\n+          pkgs.git\n+        ];\n+\n+        # TODO: Remove entire attr\n+        buildInputs = with rustPlatform; [\n+          cargoSetupHook\n+          cargoBuildHook\n+          cargoInstallHook\n+        ];\n+\n+        # Use Helix's opt profile for the build.\n+        # TODO: s/cargoBuildType/buildType\n+        cargoBuildType = \"opt\";\n+        # END: Funny attrs to reevaluate\n+\n+        name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n+        src = pkgs.lib.sources.cleanSource ./.;\n+\n+        # Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n+        HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n+\n+        # So Helix knows what rev it is.\n+        HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n+\n+        doCheck = false;\n+        strictDeps = true;\n+\n+        # Sets the Helix runtimedir to the grammars\n+        env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n+\n+        # Get all the application stuff in the output directory.\n+        postInstall = ''\n+          mkdir -p $out/lib\n+          installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n+          mkdir -p $out/share/{applications,icons/hicolor/256x256/apps}\n+          cp ${./contrib/Helix.desktop} $out/share/applications\n+          cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps\n+        '';\n+\n+        meta = {\n+          mainProgram = \"hx\";\n+        };\n+      });\n+  in\n     flake-utils.lib.eachDefaultSystem (system: let\n       pkgs = import nixpkgs {\n         inherit system;\n         overlays = [(import rust-overlay)];\n       };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n-        };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n-        ];\n-        ignorePaths = path: type: let\n-          inherit (nixpkgs) lib;\n-          # split the nix store path into its components\n-          components = lib.splitString \"/\" path;\n-          # drop off the `/nix/hash-source` section from the path\n-          relPathComponents = lib.drop 4 components;\n-          # reassemble the path components\n-          relPath = lib.concatStringsSep \"/\" relPathComponents;\n-        in\n-          lib.all (p: ! (lib.hasPrefix p relPath)) pathsToIgnore;\n-      in\n-        builtins.path {\n-          name = \"helix-source\";\n-          path = toString ./.;\n-          # filter out unnecessary paths\n-          filter = ignorePaths;\n-        };\n-      makeOverridableHelix = old: config: let\n-        grammars = pkgs.callPackage ./grammars.nix config;\n-        runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n-          mkdir -p $out\n-          ln -s ${mkRootPath \"runtime\"}/* $out\n-          rm -r $out/grammars\n-          ln -s ${grammars} $out/grammars\n-        '';\n-        helix-wrapped =\n-          pkgs.runCommand\n-          old.name\n-          {\n-            inherit (old) pname version;\n-            meta = old.meta or {};\n-            passthru =\n-              (old.passthru or {})\n-              // {\n-                unwrapped = old;\n-              };\n-            nativeBuildInputs = [pkgs.makeWrapper];\n-            makeWrapperArgs = config.makeWrapperArgs or [];\n-          }\n-          ''\n-            cp -rs --no-preserve=mode,ownership ${old} $out\n-            wrapProgram \"$out/bin/hx\" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME \"${runtimeDir}\"\n-          '';\n-      in\n-        helix-wrapped\n-        // {\n-          override = makeOverridableHelix old;\n-          passthru =\n-            helix-wrapped.passthru\n-            // {\n-              wrapper = old: makeOverridableHelix old config;\n-            };\n-        };\n-      stdenv =\n-        if pkgs.stdenv.isLinux\n-        then pkgs.stdenv\n-        else pkgs.clangStdenv;\n-      rustFlagsEnv = pkgs.lib.optionalString stdenv.isLinux \"-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment --cfg tokio_unstable\";\n-      rustToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n-      craneLibMSRV = (crane.mkLib pkgs).overrideToolchain rustToolchain;\n-      craneLibStable = (crane.mkLib pkgs).overrideToolchain pkgs.pkgsBuildHost.rust-bin.stable.latest.default;\n-      commonArgs = {\n-        inherit stdenv;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./helix-term/Cargo.toml;}) pname;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./Cargo.toml;}) version;\n-        src = filteredSource;\n-        # disable fetching and building of tree-sitter grammars in the helix-term build.rs\n-        HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n-        buildInputs = [stdenv.cc.cc.lib];\n-        nativeBuildInputs = [pkgs.installShellFiles];\n-        # disable tests\n-        doCheck = false;\n-        meta.mainProgram = \"hx\";\n+\n+      # Get Helix's MSRV toolchain to build with by default.\n+      msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n+      msrvPlatform = pkgs.makeRustPlatform {\n+        cargo = msrvToolchain;\n+        rustc = msrvToolchain;\n       };\n-      cargoArtifacts = craneLibMSRV.buildDepsOnly commonArgs;\n     in {\n       packages = {\n-        helix-unwrapped = craneLibStable.buildPackage (commonArgs\n-          // {\n-            cargoArtifacts = craneLibStable.buildDepsOnly commonArgs;\n-            postInstall = ''\n-              mkdir -p $out/share/applications $out/share/icons/hicolor/scalable/apps $out/share/icons/hicolor/256x256/apps\n-              cp contrib/Helix.desktop $out/share/applications\n-              cp logo.svg $out/share/icons/hicolor/scalable/apps/helix.svg\n-              cp contrib/helix.png $out/share/icons/hicolor/256x256/apps\n-              installShellCompletion contrib/completion/hx.{bash,fish,zsh}\n-            '';\n-            # set git revision for nix flake builds, see 'git_hash' in helix-loader/build.rs\n-            HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n-          });\n-        helix = makeOverridableHelix self.packages.${system}.helix-unwrapped {};\n+        # Make MSRV Helix\n+        helix = pkgs.callPackage mkHelix {rustPlatform = msrvPlatform;};\n+\n+        # The default Helix build. Uses the default MSRV Rust toolchain, and the\n+        # default nixpkgs, which is the one in the Flake.lock of Helix.\n+        #\n+        # This can be overridden though to add Cargo Features, flags, and different toolchains.\n         default = self.packages.${system}.helix;\n       };\n \n       checks = {\n-        # Build the crate itself\n-        inherit (self.packages.${system}) helix;\n-\n-        clippy = craneLibMSRV.cargoClippy (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-            cargoClippyExtraArgs = \"--all-targets -- --deny warnings\";\n-          });\n-\n-        fmt = craneLibMSRV.cargoFmt commonArgs;\n-\n-        doc = craneLibMSRV.cargoDoc (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-          });\n-\n-        test = craneLibMSRV.cargoTest (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-          });\n+        helix = self.outputs.packages.${system}.helix.overrideAttrs {\n+          cargoBuildType = \"debug\";\n+        };\n       };\n \n-      devShells.default = pkgs.mkShell {\n-        inputsFrom = builtins.attrValues self.checks.${system};\n-        nativeBuildInputs = with pkgs;\n-          [lld_13 cargo-flamegraph rust-analyzer]\n-          ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) pkgs.cargo-tarpaulin)\n-          ++ (lib.optional stdenv.isLinux pkgs.lldb)\n-          ++ (lib.optional stdenv.isDarwin pkgs.darwin.apple_sdk.frameworks.CoreFoundation);\n-        shellHook = ''\n-          export HELIX_RUNTIME=\"$PWD/runtime\"\n-          export RUST_BACKTRACE=\"1\"\n-          export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${rustFlagsEnv}\"\n-        '';\n-      };\n+      formatter = pkgs.alejandra;\n+\n+      # Devshell behavior is preserved.\n+      devShells.default = let\n+        rustFlagsEnv = pkgs.lib.optionalString pkgs.stdenv.isLinux \"-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment --cfg tokio_unstable\";\n+      in\n+        pkgs.mkShell\n+        {\n+          inputsFrom = builtins.attrValues self.checks.${system};\n+          nativeBuildInputs = with pkgs;\n+            [lld_13 cargo-flamegraph rust-analyzer]\n+            ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) pkgs.cargo-tarpaulin)\n+            ++ (lib.optional stdenv.isLinux pkgs.lldb)\n+            ++ (lib.optional stdenv.isDarwin pkgs.darwin.apple_sdk.frameworks.CoreFoundation);\n+          shellHook = ''\n+            export HELIX_RUNTIME=\"$PWD/runtime\"\n+            export RUST_BACKTRACE=\"1\"\n+            export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${rustFlagsEnv}\"\n+          '';\n+        };\n     })\n     // {\n-      overlays.default = final: prev: {\n-        inherit (self.packages.${final.system}) helix;\n+      overlays = {\n+        default = final: prev: {\n+          helix = final.callPackage mkHelix {};\n+        };\n       };",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1957107849",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12831,
        "pr_file": "flake.nix",
        "discussion_id": "1957107849",
        "commented_code": "@@ -8,183 +8,152 @@\n       url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reelvalute the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n+        };\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove\n+          pkgs.installShellFiles\n+          pkgs.git\n+        ];\n+\n+        # TODO: Remove entire attr\n+        buildInputs = with rustPlatform; [\n+          cargoSetupHook\n+          cargoBuildHook\n+          cargoInstallHook\n+        ];\n+\n+        # Use Helix's opt profile for the build.\n+        # TODO: s/cargoBuildType/buildType\n+        cargoBuildType = \"opt\";\n+        # END: Funny attrs to reevaluate\n+\n+        name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n+        src = pkgs.lib.sources.cleanSource ./.;\n+\n+        # Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n+        HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n+\n+        # So Helix knows what rev it is.\n+        HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n+\n+        doCheck = false;\n+        strictDeps = true;\n+\n+        # Sets the Helix runtimedir to the grammars\n+        env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n+\n+        # Get all the application stuff in the output directory.\n+        postInstall = ''\n+          mkdir -p $out/lib\n+          installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n+          mkdir -p $out/share/{applications,icons/hicolor/256x256/apps}\n+          cp ${./contrib/Helix.desktop} $out/share/applications\n+          cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps\n+        '';\n+\n+        meta = {\n+          mainProgram = \"hx\";\n+        };\n+      });\n+  in\n     flake-utils.lib.eachDefaultSystem (system: let\n       pkgs = import nixpkgs {\n         inherit system;\n         overlays = [(import rust-overlay)];\n       };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n-        };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n-        ];\n-        ignorePaths = path: type: let\n-          inherit (nixpkgs) lib;\n-          # split the nix store path into its components\n-          components = lib.splitString \"/\" path;\n-          # drop off the `/nix/hash-source` section from the path\n-          relPathComponents = lib.drop 4 components;\n-          # reassemble the path components\n-          relPath = lib.concatStringsSep \"/\" relPathComponents;\n-        in\n-          lib.all (p: ! (lib.hasPrefix p relPath)) pathsToIgnore;\n-      in\n-        builtins.path {\n-          name = \"helix-source\";\n-          path = toString ./.;\n-          # filter out unnecessary paths\n-          filter = ignorePaths;\n-        };\n-      makeOverridableHelix = old: config: let\n-        grammars = pkgs.callPackage ./grammars.nix config;\n-        runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n-          mkdir -p $out\n-          ln -s ${mkRootPath \"runtime\"}/* $out\n-          rm -r $out/grammars\n-          ln -s ${grammars} $out/grammars\n-        '';\n-        helix-wrapped =\n-          pkgs.runCommand\n-          old.name\n-          {\n-            inherit (old) pname version;\n-            meta = old.meta or {};\n-            passthru =\n-              (old.passthru or {})\n-              // {\n-                unwrapped = old;\n-              };\n-            nativeBuildInputs = [pkgs.makeWrapper];\n-            makeWrapperArgs = config.makeWrapperArgs or [];\n-          }\n-          ''\n-            cp -rs --no-preserve=mode,ownership ${old} $out\n-            wrapProgram \"$out/bin/hx\" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME \"${runtimeDir}\"\n-          '';\n-      in\n-        helix-wrapped\n-        // {\n-          override = makeOverridableHelix old;\n-          passthru =\n-            helix-wrapped.passthru\n-            // {\n-              wrapper = old: makeOverridableHelix old config;\n-            };\n-        };\n-      stdenv =\n-        if pkgs.stdenv.isLinux\n-        then pkgs.stdenv\n-        else pkgs.clangStdenv;\n-      rustFlagsEnv = pkgs.lib.optionalString stdenv.isLinux \"-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment --cfg tokio_unstable\";\n-      rustToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n-      craneLibMSRV = (crane.mkLib pkgs).overrideToolchain rustToolchain;\n-      craneLibStable = (crane.mkLib pkgs).overrideToolchain pkgs.pkgsBuildHost.rust-bin.stable.latest.default;\n-      commonArgs = {\n-        inherit stdenv;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./helix-term/Cargo.toml;}) pname;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./Cargo.toml;}) version;\n-        src = filteredSource;\n-        # disable fetching and building of tree-sitter grammars in the helix-term build.rs\n-        HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n-        buildInputs = [stdenv.cc.cc.lib];\n-        nativeBuildInputs = [pkgs.installShellFiles];\n-        # disable tests\n-        doCheck = false;\n-        meta.mainProgram = \"hx\";\n+\n+      # Get Helix's MSRV toolchain to build with by default.\n+      msrvToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n+      msrvPlatform = pkgs.makeRustPlatform {\n+        cargo = msrvToolchain;\n+        rustc = msrvToolchain;\n       };\n-      cargoArtifacts = craneLibMSRV.buildDepsOnly commonArgs;\n     in {\n       packages = {\n-        helix-unwrapped = craneLibStable.buildPackage (commonArgs\n-          // {\n-            cargoArtifacts = craneLibStable.buildDepsOnly commonArgs;\n-            postInstall = ''\n-              mkdir -p $out/share/applications $out/share/icons/hicolor/scalable/apps $out/share/icons/hicolor/256x256/apps\n-              cp contrib/Helix.desktop $out/share/applications\n-              cp logo.svg $out/share/icons/hicolor/scalable/apps/helix.svg\n-              cp contrib/helix.png $out/share/icons/hicolor/256x256/apps\n-              installShellCompletion contrib/completion/hx.{bash,fish,zsh}\n-            '';\n-            # set git revision for nix flake builds, see 'git_hash' in helix-loader/build.rs\n-            HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n-          });\n-        helix = makeOverridableHelix self.packages.${system}.helix-unwrapped {};\n+        # Make MSRV Helix\n+        helix = pkgs.callPackage mkHelix {rustPlatform = msrvPlatform;};\n+\n+        # The default Helix build. Uses the default MSRV Rust toolchain, and the\n+        # default nixpkgs, which is the one in the Flake.lock of Helix.\n+        #\n+        # This can be overridden though to add Cargo Features, flags, and different toolchains.\n         default = self.packages.${system}.helix;\n       };\n \n       checks = {\n-        # Build the crate itself\n-        inherit (self.packages.${system}) helix;\n-\n-        clippy = craneLibMSRV.cargoClippy (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-            cargoClippyExtraArgs = \"--all-targets -- --deny warnings\";\n-          });\n-\n-        fmt = craneLibMSRV.cargoFmt commonArgs;\n-\n-        doc = craneLibMSRV.cargoDoc (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-          });\n-\n-        test = craneLibMSRV.cargoTest (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-          });\n+        helix = self.outputs.packages.${system}.helix.overrideAttrs {\n+          cargoBuildType = \"debug\";\n+        };\n       };\n \n-      devShells.default = pkgs.mkShell {\n-        inputsFrom = builtins.attrValues self.checks.${system};\n-        nativeBuildInputs = with pkgs;\n-          [lld_13 cargo-flamegraph rust-analyzer]\n-          ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) pkgs.cargo-tarpaulin)\n-          ++ (lib.optional stdenv.isLinux pkgs.lldb)\n-          ++ (lib.optional stdenv.isDarwin pkgs.darwin.apple_sdk.frameworks.CoreFoundation);\n-        shellHook = ''\n-          export HELIX_RUNTIME=\"$PWD/runtime\"\n-          export RUST_BACKTRACE=\"1\"\n-          export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${rustFlagsEnv}\"\n-        '';\n-      };\n+      formatter = pkgs.alejandra;\n+\n+      # Devshell behavior is preserved.\n+      devShells.default = let\n+        rustFlagsEnv = pkgs.lib.optionalString pkgs.stdenv.isLinux \"-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment --cfg tokio_unstable\";\n+      in\n+        pkgs.mkShell\n+        {\n+          inputsFrom = builtins.attrValues self.checks.${system};\n+          nativeBuildInputs = with pkgs;\n+            [lld_13 cargo-flamegraph rust-analyzer]\n+            ++ (lib.optional (stdenv.isx86_64 && stdenv.isLinux) pkgs.cargo-tarpaulin)\n+            ++ (lib.optional stdenv.isLinux pkgs.lldb)\n+            ++ (lib.optional stdenv.isDarwin pkgs.darwin.apple_sdk.frameworks.CoreFoundation);\n+          shellHook = ''\n+            export HELIX_RUNTIME=\"$PWD/runtime\"\n+            export RUST_BACKTRACE=\"1\"\n+            export RUSTFLAGS=\"''${RUSTFLAGS:-\"\"} ${rustFlagsEnv}\"\n+          '';\n+        };\n     })\n     // {\n-      overlays.default = final: prev: {\n-        inherit (self.packages.${final.system}) helix;\n+      overlays = {\n+        default = final: prev: {\n+          helix = final.callPackage mkHelix {};\n+        };\n       };",
        "comment_created_at": "2025-02-15T12:31:30+00:00",
        "comment_author": "poliorcetics",
        "comment_body": "```suggestion\r\n      overlays.default = final: prev: {\r\n        helix = final.callPackage mkHelix {};\r\n      };\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1958716782",
    "pr_number": 12831,
    "pr_file": "flake.nix",
    "created_at": "2025-02-17T19:42:07+00:00",
    "commented_code": "url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./.gitignore\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.maybeMissing ./.github)\n+        (fs.maybeMissing ./.ignore)\n+        (fs.fileFilter (file: file.hasExt \".svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \".md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \".nix\") ./.)\n+      ]);\n+      \n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove\n+          pkgs.installShellFiles\n+          pkgs.git\n         ];\n-        ignorePaths = path: type: let\n-          inherit (nixpkgs) lib;\n-          # split the nix store path into its components\n-          components = lib.splitString \"/\" path;\n-          # drop off the `/nix/hash-source` section from the path\n-          relPathComponents = lib.drop 4 components;\n-          # reassemble the path components\n-          relPath = lib.concatStringsSep \"/\" relPathComponents;\n-        in\n-          lib.all (p: ! (lib.hasPrefix p relPath)) pathsToIgnore;\n-      in\n-        builtins.path {\n-          name = \"helix-source\";\n-          path = toString ./.;\n-          # filter out unnecessary paths\n-          filter = ignorePaths;\n-        };\n-      makeOverridableHelix = old: config: let\n-        grammars = pkgs.callPackage ./grammars.nix config;\n-        runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n-          mkdir -p $out\n-          ln -s ${mkRootPath \"runtime\"}/* $out\n-          rm -r $out/grammars\n-          ln -s ${grammars} $out/grammars\n-        '';\n-        helix-wrapped =\n-          pkgs.runCommand\n-          old.name\n-          {\n-            inherit (old) pname version;\n-            meta = old.meta or {};\n-            passthru =\n-              (old.passthru or {})\n-              // {\n-                unwrapped = old;\n-              };\n-            nativeBuildInputs = [pkgs.makeWrapper];\n-            makeWrapperArgs = config.makeWrapperArgs or [];\n-          }\n-          ''\n-            cp -rs --no-preserve=mode,ownership ${old} $out\n-            wrapProgram \"$out/bin/hx\" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME \"${runtimeDir}\"\n-          '';\n-      in\n-        helix-wrapped\n-        // {\n-          override = makeOverridableHelix old;\n-          passthru =\n-            helix-wrapped.passthru\n-            // {\n-              wrapper = old: makeOverridableHelix old config;\n-            };\n+\n+        # TODO: Remove entire attr\n+        buildInputs = with rustPlatform; [\n+          cargoSetupHook\n+          cargoBuildHook\n+          cargoInstallHook\n+        ];\n+\n+        # Use Helix's opt profile for the build.\n+        # TODO: s/cargoBuildType/buildType\n+        cargoBuildType = \"opt\";\n+        # END: Funny attrs to reevaluate\n+\n+        name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n+        src = fs.toSource {\n+          root = ./.;\n+          fileset = src;\n         };\n-      stdenv =\n-        if pkgs.stdenv.isLinux\n-        then pkgs.stdenv\n-        else pkgs.clangStdenv;\n-      rustFlagsEnv = pkgs.lib.optionalString stdenv.isLinux \"-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment --cfg tokio_unstable\";\n-      rustToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n-      craneLibMSRV = (crane.mkLib pkgs).overrideToolchain rustToolchain;\n-      craneLibStable = (crane.mkLib pkgs).overrideToolchain pkgs.pkgsBuildHost.rust-bin.stable.latest.default;\n-      commonArgs = {\n-        inherit stdenv;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./helix-term/Cargo.toml;}) pname;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./Cargo.toml;}) version;\n-        src = filteredSource;\n-        # disable fetching and building of tree-sitter grammars in the helix-term build.rs\n+\n+        # Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n         HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n-        buildInputs = [stdenv.cc.cc.lib];\n-        nativeBuildInputs = [pkgs.installShellFiles];\n-        # disable tests\n+\n+        # So Helix knows what rev it is.\n+        HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n+\n         doCheck = false;\n-        meta.mainProgram = \"hx\";\n-      };\n-      cargoArtifacts = craneLibMSRV.buildDepsOnly commonArgs;\n-    in {\n-      packages = {\n-        helix-unwrapped = craneLibStable.buildPackage (commonArgs\n-          // {\n-            cargoArtifacts = craneLibStable.buildDepsOnly commonArgs;\n-            postInstall = ''\n-              mkdir -p $out/share/applications $out/share/icons/hicolor/scalable/apps $out/share/icons/hicolor/256x256/apps\n-              cp contrib/Helix.desktop $out/share/applications\n-              cp logo.svg $out/share/icons/hicolor/scalable/apps/helix.svg\n-              cp contrib/helix.png $out/share/icons/hicolor/256x256/apps\n-              installShellCompletion contrib/completion/hx.{bash,fish,zsh}\n-            '';\n-            # set git revision for nix flake builds, see 'git_hash' in helix-loader/build.rs\n-            HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n-          });\n-        helix = makeOverridableHelix self.packages.${system}.helix-unwrapped {};\n-        default = self.packages.${system}.helix;\n-      };\n+        strictDeps = true;\n \n-      checks = {\n-        # Build the crate itself\n-        inherit (self.packages.${system}) helix;\n+        # Sets the Helix runtimedir to the grammars\n+        env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n \n-        clippy = craneLibMSRV.cargoClippy (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-            cargoClippyExtraArgs = \"--all-targets -- --deny warnings\";\n-          });\n+        # Get all the application stuff in the output directory.\n+        postInstall = ''\n+          mkdir -p $out/lib\n+          installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n+          mkdir -p $out/share/{applications,icons/hicolor/256x256/apps}\n+          cp ${./contrib/Helix.desktop} $out/share/applications\n+          cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps\n+        '';\n \n-        fmt = craneLibMSRV.cargoFmt commonArgs;\n+        meta.mainProgram = \"hx\";\n+      });\n+  in\n+    flake-utils.lib.eachDefaultSystem (system: let\n+      pkgs = import nixpkgs {\n+        inherit system;\n+        overlays = [(import rust-overlay)];\n+      };\n \n-        doc = craneLibMSRV.cargoDoc (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-          });\n+      # Get Helix's MSRV toolchain to build with by default.",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1958716782",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12831,
        "pr_file": "flake.nix",
        "discussion_id": "1958716782",
        "commented_code": "@@ -8,183 +8,166 @@\n       url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./.gitignore\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.maybeMissing ./.github)\n+        (fs.maybeMissing ./.ignore)\n+        (fs.fileFilter (file: file.hasExt \".svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \".md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \".nix\") ./.)\n+      ]);\n+      \n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove\n+          pkgs.installShellFiles\n+          pkgs.git\n         ];\n-        ignorePaths = path: type: let\n-          inherit (nixpkgs) lib;\n-          # split the nix store path into its components\n-          components = lib.splitString \"/\" path;\n-          # drop off the `/nix/hash-source` section from the path\n-          relPathComponents = lib.drop 4 components;\n-          # reassemble the path components\n-          relPath = lib.concatStringsSep \"/\" relPathComponents;\n-        in\n-          lib.all (p: ! (lib.hasPrefix p relPath)) pathsToIgnore;\n-      in\n-        builtins.path {\n-          name = \"helix-source\";\n-          path = toString ./.;\n-          # filter out unnecessary paths\n-          filter = ignorePaths;\n-        };\n-      makeOverridableHelix = old: config: let\n-        grammars = pkgs.callPackage ./grammars.nix config;\n-        runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n-          mkdir -p $out\n-          ln -s ${mkRootPath \"runtime\"}/* $out\n-          rm -r $out/grammars\n-          ln -s ${grammars} $out/grammars\n-        '';\n-        helix-wrapped =\n-          pkgs.runCommand\n-          old.name\n-          {\n-            inherit (old) pname version;\n-            meta = old.meta or {};\n-            passthru =\n-              (old.passthru or {})\n-              // {\n-                unwrapped = old;\n-              };\n-            nativeBuildInputs = [pkgs.makeWrapper];\n-            makeWrapperArgs = config.makeWrapperArgs or [];\n-          }\n-          ''\n-            cp -rs --no-preserve=mode,ownership ${old} $out\n-            wrapProgram \"$out/bin/hx\" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME \"${runtimeDir}\"\n-          '';\n-      in\n-        helix-wrapped\n-        // {\n-          override = makeOverridableHelix old;\n-          passthru =\n-            helix-wrapped.passthru\n-            // {\n-              wrapper = old: makeOverridableHelix old config;\n-            };\n+\n+        # TODO: Remove entire attr\n+        buildInputs = with rustPlatform; [\n+          cargoSetupHook\n+          cargoBuildHook\n+          cargoInstallHook\n+        ];\n+\n+        # Use Helix's opt profile for the build.\n+        # TODO: s/cargoBuildType/buildType\n+        cargoBuildType = \"opt\";\n+        # END: Funny attrs to reevaluate\n+\n+        name = with builtins; (fromTOML (readFile ./helix-term/Cargo.toml)).package.name;\n+        src = fs.toSource {\n+          root = ./.;\n+          fileset = src;\n         };\n-      stdenv =\n-        if pkgs.stdenv.isLinux\n-        then pkgs.stdenv\n-        else pkgs.clangStdenv;\n-      rustFlagsEnv = pkgs.lib.optionalString stdenv.isLinux \"-C link-arg=-fuse-ld=lld -C target-cpu=native -Clink-arg=-Wl,--no-rosegment --cfg tokio_unstable\";\n-      rustToolchain = pkgs.pkgsBuildHost.rust-bin.fromRustupToolchainFile ./rust-toolchain.toml;\n-      craneLibMSRV = (crane.mkLib pkgs).overrideToolchain rustToolchain;\n-      craneLibStable = (crane.mkLib pkgs).overrideToolchain pkgs.pkgsBuildHost.rust-bin.stable.latest.default;\n-      commonArgs = {\n-        inherit stdenv;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./helix-term/Cargo.toml;}) pname;\n-        inherit (craneLibMSRV.crateNameFromCargoToml {cargoToml = ./Cargo.toml;}) version;\n-        src = filteredSource;\n-        # disable fetching and building of tree-sitter grammars in the helix-term build.rs\n+\n+        # Helix attempts to reach out to the network and get the grammars. Nix doesn't allow this.\n         HELIX_DISABLE_AUTO_GRAMMAR_BUILD = \"1\";\n-        buildInputs = [stdenv.cc.cc.lib];\n-        nativeBuildInputs = [pkgs.installShellFiles];\n-        # disable tests\n+\n+        # So Helix knows what rev it is.\n+        HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n+\n         doCheck = false;\n-        meta.mainProgram = \"hx\";\n-      };\n-      cargoArtifacts = craneLibMSRV.buildDepsOnly commonArgs;\n-    in {\n-      packages = {\n-        helix-unwrapped = craneLibStable.buildPackage (commonArgs\n-          // {\n-            cargoArtifacts = craneLibStable.buildDepsOnly commonArgs;\n-            postInstall = ''\n-              mkdir -p $out/share/applications $out/share/icons/hicolor/scalable/apps $out/share/icons/hicolor/256x256/apps\n-              cp contrib/Helix.desktop $out/share/applications\n-              cp logo.svg $out/share/icons/hicolor/scalable/apps/helix.svg\n-              cp contrib/helix.png $out/share/icons/hicolor/256x256/apps\n-              installShellCompletion contrib/completion/hx.{bash,fish,zsh}\n-            '';\n-            # set git revision for nix flake builds, see 'git_hash' in helix-loader/build.rs\n-            HELIX_NIX_BUILD_REV = self.rev or self.dirtyRev or null;\n-          });\n-        helix = makeOverridableHelix self.packages.${system}.helix-unwrapped {};\n-        default = self.packages.${system}.helix;\n-      };\n+        strictDeps = true;\n \n-      checks = {\n-        # Build the crate itself\n-        inherit (self.packages.${system}) helix;\n+        # Sets the Helix runtimedir to the grammars\n+        env.HELIX_DEFAULT_RUNTIME = \"${runtimeDir}\";\n \n-        clippy = craneLibMSRV.cargoClippy (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-            cargoClippyExtraArgs = \"--all-targets -- --deny warnings\";\n-          });\n+        # Get all the application stuff in the output directory.\n+        postInstall = ''\n+          mkdir -p $out/lib\n+          installShellCompletion ${./contrib/completion}/hx.{bash,fish,zsh}\n+          mkdir -p $out/share/{applications,icons/hicolor/256x256/apps}\n+          cp ${./contrib/Helix.desktop} $out/share/applications\n+          cp ${./contrib/helix.png} $out/share/icons/hicolor/256x256/apps\n+        '';\n \n-        fmt = craneLibMSRV.cargoFmt commonArgs;\n+        meta.mainProgram = \"hx\";\n+      });\n+  in\n+    flake-utils.lib.eachDefaultSystem (system: let\n+      pkgs = import nixpkgs {\n+        inherit system;\n+        overlays = [(import rust-overlay)];\n+      };\n \n-        doc = craneLibMSRV.cargoDoc (commonArgs\n-          // {\n-            inherit cargoArtifacts;\n-          });\n+      # Get Helix's MSRV toolchain to build with by default.",
        "comment_created_at": "2025-02-17T19:42:07+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "For the build of `packages.helix` we can use the latest stable - that's what we do in the release builds as well. We only need the MSRV toolchain for the development shell",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1972724742",
    "pr_number": 12831,
    "pr_file": "flake.nix",
    "created_at": "2025-02-27T02:22:39+00:00",
    "commented_code": "url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.fileFilter (file: pkgs.lib.strings.hasInfix \".git\" file.name) ./.)\n+        (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n+      ]);\n+\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove\n+          pkgs.installShellFiles\n+          pkgs.git\n         ];\n-        ignorePaths = path: type: let\n-          inherit (nixpkgs) lib;\n-          # split the nix store path into its components\n-          components = lib.splitString \"/\" path;\n-          # drop off the `/nix/hash-source` section from the path\n-          relPathComponents = lib.drop 4 components;\n-          # reassemble the path components\n-          relPath = lib.concatStringsSep \"/\" relPathComponents;\n-        in\n-          lib.all (p: ! (lib.hasPrefix p relPath)) pathsToIgnore;\n-      in\n-        builtins.path {\n-          name = \"helix-source\";\n-          path = toString ./.;\n-          # filter out unnecessary paths\n-          filter = ignorePaths;\n-        };\n-      makeOverridableHelix = old: config: let\n-        grammars = pkgs.callPackage ./grammars.nix config;\n-        runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n-          mkdir -p $out\n-          ln -s ${mkRootPath \"runtime\"}/* $out\n-          rm -r $out/grammars\n-          ln -s ${grammars} $out/grammars\n-        '';\n-        helix-wrapped =\n-          pkgs.runCommand\n-          old.name\n-          {\n-            inherit (old) pname version;\n-            meta = old.meta or {};\n-            passthru =\n-              (old.passthru or {})\n-              // {\n-                unwrapped = old;\n-              };\n-            nativeBuildInputs = [pkgs.makeWrapper];\n-            makeWrapperArgs = config.makeWrapperArgs or [];\n-          }\n-          ''\n-            cp -rs --no-preserve=mode,ownership ${old} $out\n-            wrapProgram \"$out/bin/hx\" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME \"${runtimeDir}\"\n-          '';\n-      in\n-        helix-wrapped\n-        // {\n-          override = makeOverridableHelix old;\n-          passthru =\n-            helix-wrapped.passthru\n-            // {\n-              wrapper = old: makeOverridableHelix old config;\n-            };\n+\n+        # TODO: Remove entire attr\n+        buildInputs = with rustPlatform; [\n+          cargoSetupHook\n+          cargoBuildHook\n+          cargoInstallHook\n+        ];\n+\n+        # Use Helix's opt profile for the build.\n+        # TODO: s/cargoBuildType/buildType\n+        cargoBuildType = \"opt\";",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1972724742",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12831,
        "pr_file": "flake.nix",
        "discussion_id": "1972724742",
        "commented_code": "@@ -8,183 +8,167 @@\n       url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.fileFilter (file: pkgs.lib.strings.hasInfix \".git\" file.name) ./.)\n+        (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n+      ]);\n+\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove\n+          pkgs.installShellFiles\n+          pkgs.git\n         ];\n-        ignorePaths = path: type: let\n-          inherit (nixpkgs) lib;\n-          # split the nix store path into its components\n-          components = lib.splitString \"/\" path;\n-          # drop off the `/nix/hash-source` section from the path\n-          relPathComponents = lib.drop 4 components;\n-          # reassemble the path components\n-          relPath = lib.concatStringsSep \"/\" relPathComponents;\n-        in\n-          lib.all (p: ! (lib.hasPrefix p relPath)) pathsToIgnore;\n-      in\n-        builtins.path {\n-          name = \"helix-source\";\n-          path = toString ./.;\n-          # filter out unnecessary paths\n-          filter = ignorePaths;\n-        };\n-      makeOverridableHelix = old: config: let\n-        grammars = pkgs.callPackage ./grammars.nix config;\n-        runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n-          mkdir -p $out\n-          ln -s ${mkRootPath \"runtime\"}/* $out\n-          rm -r $out/grammars\n-          ln -s ${grammars} $out/grammars\n-        '';\n-        helix-wrapped =\n-          pkgs.runCommand\n-          old.name\n-          {\n-            inherit (old) pname version;\n-            meta = old.meta or {};\n-            passthru =\n-              (old.passthru or {})\n-              // {\n-                unwrapped = old;\n-              };\n-            nativeBuildInputs = [pkgs.makeWrapper];\n-            makeWrapperArgs = config.makeWrapperArgs or [];\n-          }\n-          ''\n-            cp -rs --no-preserve=mode,ownership ${old} $out\n-            wrapProgram \"$out/bin/hx\" ''${makeWrapperArgs[@]} --set HELIX_RUNTIME \"${runtimeDir}\"\n-          '';\n-      in\n-        helix-wrapped\n-        // {\n-          override = makeOverridableHelix old;\n-          passthru =\n-            helix-wrapped.passthru\n-            // {\n-              wrapper = old: makeOverridableHelix old config;\n-            };\n+\n+        # TODO: Remove entire attr\n+        buildInputs = with rustPlatform; [\n+          cargoSetupHook\n+          cargoBuildHook\n+          cargoInstallHook\n+        ];\n+\n+        # Use Helix's opt profile for the build.\n+        # TODO: s/cargoBuildType/buildType\n+        cargoBuildType = \"opt\";",
        "comment_created_at": "2025-02-27T02:22:39+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "```suggestion\r\n        cargoBuildType = \"release\";\r\n```\r\n\r\nYeah let's switch back to `release`. The LTO stuff (I assume) seems to be way more expensive than I thought. I'm seeing ~60s to build on `release` and ~330s to build on `opt` :/",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1972725457",
    "pr_number": 12831,
    "pr_file": "flake.nix",
    "created_at": "2025-02-27T02:23:27+00:00",
    "commented_code": "url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.fileFilter (file: pkgs.lib.strings.hasInfix \".git\" file.name) ./.)\n+        (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n+      ]);\n+\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1972725457",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12831,
        "pr_file": "flake.nix",
        "discussion_id": "1972725457",
        "commented_code": "@@ -8,183 +8,167 @@\n       url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.fileFilter (file: pkgs.lib.strings.hasInfix \".git\" file.name) ./.)\n+        (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n+      ]);\n+\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove",
        "comment_created_at": "2025-02-27T02:23:27+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "Should we use `rustc` and `cargo` from the attrs passed to `mkHelix` instead? I'm seeing a deprecation warning on accessing these",
        "pr_file_module": null
      },
      {
        "comment_id": "1972734472",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12831,
        "pr_file": "flake.nix",
        "discussion_id": "1972725457",
        "commented_code": "@@ -8,183 +8,167 @@\n       url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.fileFilter (file: pkgs.lib.strings.hasInfix \".git\" file.name) ./.)\n+        (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n+      ]);\n+\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove",
        "comment_created_at": "2025-02-27T02:36:02+00:00",
        "comment_author": "RossSmyth",
        "comment_body": "No as they are not spliced in properly if you do that. The alternative is to change the `callPackage` invocations to be something like \r\n```nix\r\npkgs.callPackage mkHelix {\r\n    rustPlatform = msrvPlatform;\r\n    rustc = msrvToolchain.rustc; \r\n    cargo = msrvToolchain.cargo;\r\n};\r\n```",
        "pr_file_module": null
      },
      {
        "comment_id": "1972735899",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12831,
        "pr_file": "flake.nix",
        "discussion_id": "1972725457",
        "commented_code": "@@ -8,183 +8,167 @@\n       url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.fileFilter (file: pkgs.lib.strings.hasInfix \".git\" file.name) ./.)\n+        (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n+      ]);\n+\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove",
        "comment_created_at": "2025-02-27T02:38:18+00:00",
        "comment_author": "the-mikedavis",
        "comment_body": "For the package build (not the shell) we don't need to follow the MSRV, it's ok to build with latest stable. We do roughly the same in CI - the build workflow for PRs checks with the MSRV and then the release workflow uses whatever is the latest stable",
        "pr_file_module": null
      },
      {
        "comment_id": "1972762397",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12831,
        "pr_file": "flake.nix",
        "discussion_id": "1972725457",
        "commented_code": "@@ -8,183 +8,167 @@\n       url = \"github:oxalica/rust-overlay\";\n       inputs.nixpkgs.follows = \"nixpkgs\";\n     };\n-    crane.url = \"github:ipetkov/crane\";\n   };\n \n   outputs = {\n     self,\n     nixpkgs,\n-    crane,\n     flake-utils,\n     rust-overlay,\n     ...\n-  }:\n-    flake-utils.lib.eachDefaultSystem (system: let\n-      pkgs = import nixpkgs {\n-        inherit system;\n-        overlays = [(import rust-overlay)];\n-      };\n-      mkRootPath = rel:\n-        builtins.path {\n-          path = \"${toString ./.}/${rel}\";\n-          name = rel;\n+  }: let\n+    mkHelix = {\n+      pkgs,\n+      rustPlatform,\n+      stdenv,\n+      ...\n+    }: let\n+      fs = pkgs.lib.fileset;\n+\n+      src = fs.difference (fs.gitTracked ./.) (fs.unions [\n+        ./.envrc\n+        ./rustfmt.toml\n+        ./screenshot.png\n+        ./book\n+        ./docs\n+        ./flake.lock\n+        (fs.fileFilter (file: pkgs.lib.strings.hasInfix \".git\" file.name) ./.)\n+        (fs.fileFilter (file: file.hasExt \"svg\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"md\") ./.)\n+        (fs.fileFilter (file: file.hasExt \"nix\") ./.)\n+      ]);\n+\n+      # Next we actually need to build the grammars and the runtime directory\n+      # that they reside in. It is built by calling the derivation in the\n+      # grammars.nix file, then taking the runtime directory in the git repo\n+      # and hooking symlinks up to it.\n+      grammars = pkgs.callPackage ./grammars.nix {};\n+      runtimeDir = pkgs.runCommand \"helix-runtime\" {} ''\n+        mkdir -p $out\n+        ln -s ${./runtime}/* $out\n+        rm -r $out/grammars\n+        ln -s ${grammars} $out/grammars\n+      '';\n+    in\n+      # Currently rustPlatform.buildRustPackage doesn't have the finalAttrs pattern\n+      # hooked up. To get around this while having good customization, mkDerivation is\n+      # used instead.\n+      stdenv.mkDerivation (self: {\n+        # START: Reevaluate the below attrs when\n+        # https://github.com/NixOS/nixpkgs/pull/354999\n+        # or\n+        # https://github.com/NixOS/nixpkgs/pull/194475\n+        # Are merged.\n+\n+        # TODO: Probably change to cargoLock\n+        cargoDeps = rustPlatform.importCargoLock {\n+          lockFile = ./Cargo.lock;\n         };\n-      filteredSource = let\n-        pathsToIgnore = [\n-          \".envrc\"\n-          \".ignore\"\n-          \".github\"\n-          \".gitignore\"\n-          \"logo_dark.svg\"\n-          \"logo_light.svg\"\n-          \"rust-toolchain.toml\"\n-          \"rustfmt.toml\"\n-          \"runtime\"\n-          \"screenshot.png\"\n-          \"book\"\n-          \"docs\"\n-          \"README.md\"\n-          \"CHANGELOG.md\"\n-          \"shell.nix\"\n-          \"default.nix\"\n-          \"grammars.nix\"\n-          \"flake.nix\"\n-          \"flake.lock\"\n+\n+        nativeBuildInputs = [\n+          rustPlatform.rust.rustc # TODO: Remove\n+          rustPlatform.rust.cargo # TODO: Remove",
        "comment_created_at": "2025-02-27T03:15:59+00:00",
        "comment_author": "RossSmyth",
        "comment_body": "This is not for Helix, but rather for me (or anyone else who overrides the toolchain) so that when I override the toolchain that the correct Cargo and Rustc are used for the entire build.",
        "pr_file_module": null
      }
    ]
  }
]