[
  {
    "discussion_id": "1915432190",
    "pr_number": 12527,
    "pr_file": "book/src/commands.md",
    "created_at": "2025-01-14T18:47:18+00:00",
    "commented_code": "# Commands\n \n - [Typable commands](#typable-commands)\n+  - [Command mode syntax](#command-mode-syntax)\n+    - [Quoting](#quoting)\n+    - [Expansions](#expansions)\n+    - [Flags](#flags)\n+    - [Exceptions](#exceptions)\n+  - [Built-ins](#built-ins)\n - [Static commands](#static-commands)\n \n ## Typable commands\n \n-Typable commands are used from command mode and may take arguments. Command mode can be activated by pressing `:`. The built-in typable commands are:\n+Typable commands are used from command mode and may take arguments. Command mode can be activated by pressing `:`.\n+\n+### Command mode syntax\n+\n+Command mode has rules for parsing the command line to evaluate quotes and expansions and split the line into positional arguments and flags. Most commands use these rules but some commands have custom parsing rules (see [Exceptions](#exceptions) below).\n+\n+#### Quoting\n+\n+By default command arguments are split on tabs and space characters. `:open README.md CHANGELOG.md` for example should open two files, `README.md` and `CHANGELOG.md`. Arguments that contain spaces can be surrounded in single quotes (`'`) or backticks (`` ` ``) to prevent the space from separating the argument, like `:open 'a b.txt'`.\n+\n+Double quotes may be used the same way, but double quotes _expand_ their inner content. `:echo \"%{cursor_line}\"` for example may print `1` since the variable expansion within is expanded. `:echo '%{cursor_line}'` prints `%{cursor_line}` literally though. Content within single quotes or backticks is interpreted as-is.\n+\n+On Unix systems the backslash character may be used to escape certain characters depending on where it is used. Within an argument which isn't surround in quotes, the backslash can be used to escape the space or tab characters: `:open a\\ b.txt` is equivalent to `:open 'a b.txt'`. The backslash may also be used to escape quote characters (`'`, `` ` ``, `\"`) or the percent token (`%`) when used at the beginning of an argument. `:echo \\%%sh{foo}` for example prints `%sh{foo}` instead of invoking a `foo` shell command and `:echo \\\"quote` prints `\"quote`. The backslash character is treated literally in any other situation on Unix systems and always on Windows: `:echo \n` always prints `\n`.\n+\n+#### Expansions\n+\n+Expansions are patterns that Helix recognizes and replaces within the command line. Helix recognizes anything starting with a percent token (`%`) as an expansion, for example `%sh{echo hi!}`.\n+\n+Expansions take the form `%[<kind>]<open><contents><close>`. In `%sh{echo hi!}`, for example, the kind is `sh` - the shell expansion - and the contents are \"echo hi!\", with `{` and `}` acting as opening and closing delimiters. The following open/close characters are recognized as expansion delimiter pairs: `(`/`)`, `[`/`]`, `{`/`}` and `<`/`>`. Any grapheme cluster can be used as both open and close delimiters instead however: `%{cursor_line}` is equivalent to `%|cursor_line|`, `%\"cursor_line\"` and even `%\ud83c\udff4\u200d\u2620\ufe0fcursor_line\ud83c\udff4\u200d\u2620\ufe0f`.\n+\n+When no `<kind>` is provided, Helix will expand a **variable**. For example `%{cursor_line}` can be used as an argument to provide the currently focused document's primary selection cursor line as an argument. `:echo %{cursor_line}` for instance may print `1` to the statusline.\n+\n+The following variables are supported:\n+\n+| Name | Description |\n+|---   |---          |\n+| `cursor_line` | The one-indexed line number of the primary cursor in the currently focused document. |",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1915432190",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12527,
        "pr_file": "book/src/commands.md",
        "discussion_id": "1915432190",
        "commented_code": "@@ -1,11 +1,87 @@\n # Commands\n \n - [Typable commands](#typable-commands)\n+  - [Command mode syntax](#command-mode-syntax)\n+    - [Quoting](#quoting)\n+    - [Expansions](#expansions)\n+    - [Flags](#flags)\n+    - [Exceptions](#exceptions)\n+  - [Built-ins](#built-ins)\n - [Static commands](#static-commands)\n \n ## Typable commands\n \n-Typable commands are used from command mode and may take arguments. Command mode can be activated by pressing `:`. The built-in typable commands are:\n+Typable commands are used from command mode and may take arguments. Command mode can be activated by pressing `:`.\n+\n+### Command mode syntax\n+\n+Command mode has rules for parsing the command line to evaluate quotes and expansions and split the line into positional arguments and flags. Most commands use these rules but some commands have custom parsing rules (see [Exceptions](#exceptions) below).\n+\n+#### Quoting\n+\n+By default command arguments are split on tabs and space characters. `:open README.md CHANGELOG.md` for example should open two files, `README.md` and `CHANGELOG.md`. Arguments that contain spaces can be surrounded in single quotes (`'`) or backticks (`` ` ``) to prevent the space from separating the argument, like `:open 'a b.txt'`.\n+\n+Double quotes may be used the same way, but double quotes _expand_ their inner content. `:echo \"%{cursor_line}\"` for example may print `1` since the variable expansion within is expanded. `:echo '%{cursor_line}'` prints `%{cursor_line}` literally though. Content within single quotes or backticks is interpreted as-is.\n+\n+On Unix systems the backslash character may be used to escape certain characters depending on where it is used. Within an argument which isn't surround in quotes, the backslash can be used to escape the space or tab characters: `:open a\\ b.txt` is equivalent to `:open 'a b.txt'`. The backslash may also be used to escape quote characters (`'`, `` ` ``, `\"`) or the percent token (`%`) when used at the beginning of an argument. `:echo \\%%sh{foo}` for example prints `%sh{foo}` instead of invoking a `foo` shell command and `:echo \\\"quote` prints `\"quote`. The backslash character is treated literally in any other situation on Unix systems and always on Windows: `:echo \\n` always prints `\\n`.\n+\n+#### Expansions\n+\n+Expansions are patterns that Helix recognizes and replaces within the command line. Helix recognizes anything starting with a percent token (`%`) as an expansion, for example `%sh{echo hi!}`.\n+\n+Expansions take the form `%[<kind>]<open><contents><close>`. In `%sh{echo hi!}`, for example, the kind is `sh` - the shell expansion - and the contents are \"echo hi!\", with `{` and `}` acting as opening and closing delimiters. The following open/close characters are recognized as expansion delimiter pairs: `(`/`)`, `[`/`]`, `{`/`}` and `<`/`>`. Any grapheme cluster can be used as both open and close delimiters instead however: `%{cursor_line}` is equivalent to `%|cursor_line|`, `%\"cursor_line\"` and even `%\ud83c\udff4\u200d\u2620\ufe0fcursor_line\ud83c\udff4\u200d\u2620\ufe0f`.\n+\n+When no `<kind>` is provided, Helix will expand a **variable**. For example `%{cursor_line}` can be used as an argument to provide the currently focused document's primary selection cursor line as an argument. `:echo %{cursor_line}` for instance may print `1` to the statusline.\n+\n+The following variables are supported:\n+\n+| Name | Description |\n+|---   |---          |\n+| `cursor_line` | The one-indexed line number of the primary cursor in the currently focused document. |",
        "comment_created_at": "2025-01-14T18:47:18+00:00",
        "comment_author": "nik-rev",
        "comment_body": "People who don't write code may not know what \"one-indexed\" means, so maybe something more explicit here?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1945513006",
    "pr_number": 12527,
    "pr_file": "book/src/command-line.md",
    "created_at": "2025-02-06T21:45:24+00:00",
    "commented_code": "+# Command line\n+\n+- [Quoting](#quoting)\n+- [Flags](#flags)\n+- [Expansions](#expansions)\n+- [Exceptions](#exceptions)\n+\n+The command line is used for executing [typable commands](./commands.md#typable-commands) like `:write` or `:quit`. Press `:` to activate the command line.\n+\n+Typable commands optionally accept arguments. `:write` for example accepts an optional path to write the file contents. The command line also supports a quoting syntax for arguments, flags to modify command behaviors, and _expansions_ - a way to insert values from the editor. Most commands support these features but some have custom parsing rules (see the [exceptions](#exceptions) below).\n+\n+## Quoting\n+\n+By default, command arguments are split on tabs and space characters. `:open README.md CHANGELOG.md` for example should open two files, `README.md` and `CHANGELOG.md`. Arguments that contain spaces can be surrounded in single quotes (`'`) or backticks (`` ` ``) to prevent the space from separating the argument, like `:open 'a b.txt'`.\n+\n+Double quotes may be used the same way, but double quotes _expand_ their inner content. `:echo \"%{cursor_line}\"` for example may print `1` because of the expansion for the `cursor_line` variable. `:echo '%{cursor_line}'` though prints `%{cursor_line}` literally: content within single quotes or backticks is interpreted as-is.\n+\n+On Unix systems the backslash character may be used to escape certain characters depending on where it is used. Within an argument which isn't surround in quotes, the backslash can be used to escape the space or tab characters: `:open a\\ b.txt` is equivalent to `:open 'a b.txt'`. The backslash may also be used to escape quote characters (`'`, `` ` ``, `\"`) or the percent token (`%`) when used at the beginning of an argument. `:echo \\%%sh{foo}` for example prints `%sh{foo}` instead of invoking a `foo` shell command and `:echo \\\"quote` prints `\"quote`. The backslash character is treated literally in any other situation on Unix systems and always on Windows: `:echo \n` always prints `\n`.\n+\n+## Flags\n+\n+Command flags are optional switches that can be used to alter the behavior of a command. For example the `:sort` command accepts an optional `--reverse` (or `-r` for short) flag which causes the sort command to reverse the sorting direction. Typing the `-` character shows completions for the current command's flags, if any.\n+\n+The `--` flag specifies the end of flags. All arguments after `--` are treated as positional arguments: `:open -- -a.txt` opens a file called `-a.txt`.\n+\n+## Expansions\n+\n+Expansions are patterns that Helix recognizes and replaces within the command line. Helix recognizes anything starting with a percent token (`%`) as an expansion, for example `%sh{echo hi!}`.",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "1945513006",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 12527,
        "pr_file": "book/src/command-line.md",
        "discussion_id": "1945513006",
        "commented_code": "@@ -0,0 +1,76 @@\n+# Command line\n+\n+- [Quoting](#quoting)\n+- [Flags](#flags)\n+- [Expansions](#expansions)\n+- [Exceptions](#exceptions)\n+\n+The command line is used for executing [typable commands](./commands.md#typable-commands) like `:write` or `:quit`. Press `:` to activate the command line.\n+\n+Typable commands optionally accept arguments. `:write` for example accepts an optional path to write the file contents. The command line also supports a quoting syntax for arguments, flags to modify command behaviors, and _expansions_ - a way to insert values from the editor. Most commands support these features but some have custom parsing rules (see the [exceptions](#exceptions) below).\n+\n+## Quoting\n+\n+By default, command arguments are split on tabs and space characters. `:open README.md CHANGELOG.md` for example should open two files, `README.md` and `CHANGELOG.md`. Arguments that contain spaces can be surrounded in single quotes (`'`) or backticks (`` ` ``) to prevent the space from separating the argument, like `:open 'a b.txt'`.\n+\n+Double quotes may be used the same way, but double quotes _expand_ their inner content. `:echo \"%{cursor_line}\"` for example may print `1` because of the expansion for the `cursor_line` variable. `:echo '%{cursor_line}'` though prints `%{cursor_line}` literally: content within single quotes or backticks is interpreted as-is.\n+\n+On Unix systems the backslash character may be used to escape certain characters depending on where it is used. Within an argument which isn't surround in quotes, the backslash can be used to escape the space or tab characters: `:open a\\ b.txt` is equivalent to `:open 'a b.txt'`. The backslash may also be used to escape quote characters (`'`, `` ` ``, `\"`) or the percent token (`%`) when used at the beginning of an argument. `:echo \\%%sh{foo}` for example prints `%sh{foo}` instead of invoking a `foo` shell command and `:echo \\\"quote` prints `\"quote`. The backslash character is treated literally in any other situation on Unix systems and always on Windows: `:echo \\n` always prints `\\n`.\n+\n+## Flags\n+\n+Command flags are optional switches that can be used to alter the behavior of a command. For example the `:sort` command accepts an optional `--reverse` (or `-r` for short) flag which causes the sort command to reverse the sorting direction. Typing the `-` character shows completions for the current command's flags, if any.\n+\n+The `--` flag specifies the end of flags. All arguments after `--` are treated as positional arguments: `:open -- -a.txt` opens a file called `-a.txt`.\n+\n+## Expansions\n+\n+Expansions are patterns that Helix recognizes and replaces within the command line. Helix recognizes anything starting with a percent token (`%`) as an expansion, for example `%sh{echo hi!}`.",
        "comment_created_at": "2025-02-06T21:45:24+00:00",
        "comment_author": "david-crespo",
        "comment_body": "It does work better as a separate doc. How about adding a more realistic example here to help people's imaginations? I like the blame example from #11164:\r\n\r\n```\r\n:echo %sh{git blame -L %{cursor_line},+1 %{buffer_name}}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2094194848",
    "pr_number": 13133,
    "pr_file": "book/src/editor.md",
    "created_at": "2025-05-17T19:34:22+00:00",
    "commented_code": "[^2]: You may also have to activate them in the language server config for them to appear, not just in Helix. Inlay hints in Helix are still being improved on and may be a little bit laggy/janky under some circumstances. Please report any bugs you see so we can fix them!\n \n+### `[editor.inline-blame]` Section\n+\n+Inline blame is virtual text that appears at the end of a line, displaying information about the most recent commit that affected this line.\n+\n+| Key     | Description                                | Default |\n+| ------- | ------------------------------------------ | ------- |\n+| `behaviour` | Choose when to show inline blame | `\"hidden\"` |\n+| `compute` | Choose when inline blame should be computed | `\"on-demand\"` |\n+| `format` | The format in which to show the inline blame | `\"{author}, {time-ago} \u2022 {message} \u2022 {commit}\"` |\n+\n+The `behaviour` can be one of the following:\n+- `\"all-lines\"`: Inline blame is on every line.\n+- `\"cursor-line\"`: Inline blame is only on the line of the primary cursor.\n+- `\"hidden\"`: Inline blame is not shown.\n+\n+Inline blame will only show if the blame for the file has already been computed.\n+\n+The `compute` key determines under which circumstances the blame is computed, and can be one of the following:\n+- `\"on-demand\"`: Blame for the file is computed only when explicitly requested, such as when using `space + B` to blame the line of the cursor. There may be a little delay when loading the blame. When opening new files, even with `behaviour` not set to `\"hidden\"`, the inline blame won't show. It needs to be computed first in order to become available. This computation can be manually triggered by requesting it with `space + B`.\n+- `\"background\"`: Blame for the file is loaded in the background. This will have zero effect on performance of the Editor, but will use a little bit extra resources. Directly requesting the blame with `space + B` will be instant. Inline blame will show as soon as the blame is available when loading new files.\n+\n+`inline-blame-format` allows customization of the blame message, and can be set to any string. Variables can be used like so: `{variable}`. These are the available variables:",
    "repo_full_name": "helix-editor/helix",
    "discussion_comments": [
      {
        "comment_id": "2094194848",
        "repo_full_name": "helix-editor/helix",
        "pr_number": 13133,
        "pr_file": "book/src/editor.md",
        "discussion_id": "2094194848",
        "commented_code": "@@ -165,6 +166,50 @@ The following statusline elements can be configured:\n \n [^2]: You may also have to activate them in the language server config for them to appear, not just in Helix. Inlay hints in Helix are still being improved on and may be a little bit laggy/janky under some circumstances. Please report any bugs you see so we can fix them!\n \n+### `[editor.inline-blame]` Section\n+\n+Inline blame is virtual text that appears at the end of a line, displaying information about the most recent commit that affected this line.\n+\n+| Key     | Description                                | Default |\n+| ------- | ------------------------------------------ | ------- |\n+| `behaviour` | Choose when to show inline blame | `\"hidden\"` |\n+| `compute` | Choose when inline blame should be computed | `\"on-demand\"` |\n+| `format` | The format in which to show the inline blame | `\"{author}, {time-ago} \u2022 {message} \u2022 {commit}\"` |\n+\n+The `behaviour` can be one of the following:\n+- `\"all-lines\"`: Inline blame is on every line.\n+- `\"cursor-line\"`: Inline blame is only on the line of the primary cursor.\n+- `\"hidden\"`: Inline blame is not shown.\n+\n+Inline blame will only show if the blame for the file has already been computed.\n+\n+The `compute` key determines under which circumstances the blame is computed, and can be one of the following:\n+- `\"on-demand\"`: Blame for the file is computed only when explicitly requested, such as when using `space + B` to blame the line of the cursor. There may be a little delay when loading the blame. When opening new files, even with `behaviour` not set to `\"hidden\"`, the inline blame won't show. It needs to be computed first in order to become available. This computation can be manually triggered by requesting it with `space + B`.\n+- `\"background\"`: Blame for the file is loaded in the background. This will have zero effect on performance of the Editor, but will use a little bit extra resources. Directly requesting the blame with `space + B` will be instant. Inline blame will show as soon as the blame is available when loading new files.\n+\n+`inline-blame-format` allows customization of the blame message, and can be set to any string. Variables can be used like so: `{variable}`. These are the available variables:",
        "comment_created_at": "2025-05-17T19:34:22+00:00",
        "comment_author": "uncenter",
        "comment_body": "```suggestion\r\nSet a format string for `format` to customize the blame message displayed. Variables are text placeholders wrapped in curly braces (`{variable}`). The following variables are available:\r\n```",
        "pr_file_module": null
      }
    ]
  }
]