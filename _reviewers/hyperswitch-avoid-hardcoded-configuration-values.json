[
  {
    "discussion_id": "2329933009",
    "pr_number": 9304,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/chargebee.rs",
    "created_at": "2025-09-08T11:17:51+00:00",
    "commented_code": "}\n }\n \n+#[cfg(feature = \"v1\")]\n+impl ConnectorIntegration<\n+        hyperswitch_domain_models::router_flow_types::subscriptions::CreateCustomer,\n+        hyperswitch_domain_models::router_request_types::subscriptions::CreateCustomerRequest,\n+        hyperswitch_domain_models::router_response_types::subscriptions::CreateCustomerResponse,\n+    > for Chargebee\n+{\n+    fn get_headers(\n+        &self,\n+        req: &hyperswitch_domain_models::types::CreateCustomerRouterData,\n+        connectors: &Connectors,\n+    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n+        self.build_headers(req, connectors)\n+    }\n+\n+    fn get_url(\n+        &self,\n+        _req: &hyperswitch_domain_models::types::CreateCustomerRouterData,\n+        connectors: &Connectors,\n+    ) -> CustomResult<String, errors::ConnectorError> {\n+        let url = self\n+            .base_url(connectors)\n+            .to_string()\n+            .replace(\"$\", \"hyperswitch-juspay-test\"); // TODO: replace with metadata.site",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2329933009",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9304,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/chargebee.rs",
        "discussion_id": "2329933009",
        "commented_code": "@@ -664,6 +667,195 @@ impl\n     }\n }\n \n+#[cfg(feature = \"v1\")]\n+impl ConnectorIntegration<\n+        hyperswitch_domain_models::router_flow_types::subscriptions::CreateCustomer,\n+        hyperswitch_domain_models::router_request_types::subscriptions::CreateCustomerRequest,\n+        hyperswitch_domain_models::router_response_types::subscriptions::CreateCustomerResponse,\n+    > for Chargebee\n+{\n+    fn get_headers(\n+        &self,\n+        req: &hyperswitch_domain_models::types::CreateCustomerRouterData,\n+        connectors: &Connectors,\n+    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n+        self.build_headers(req, connectors)\n+    }\n+\n+    fn get_url(\n+        &self,\n+        _req: &hyperswitch_domain_models::types::CreateCustomerRouterData,\n+        connectors: &Connectors,\n+    ) -> CustomResult<String, errors::ConnectorError> {\n+        let url = self\n+            .base_url(connectors)\n+            .to_string()\n+            .replace(\"$\", \"hyperswitch-juspay-test\"); // TODO: replace with metadata.site",
        "comment_created_at": "2025-09-08T11:17:51+00:00",
        "comment_author": "jagan-jaya",
        "comment_body": "do not hardcode the value here",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2354582811",
    "pr_number": 9233,
    "pr_file": "crates/router/src/core/revenue_recovery/types.rs",
    "created_at": "2025-09-17T07:29:17+00:00",
    "commented_code": "\"Failed to check for existing calculate workflow process tracker entry\",\n                 )?;\n \n-            match existing_entry {\n-                Some(existing_process) => {\n-                    router_env::logger::error!(\n-                        \"Found existing CALCULATE_WORKFLOW task with  id: {}\",\n-                        existing_process.id\n-                    );\n-                }\n-                None => {\n-                    // No entry exists - create a new one\n-                    router_env::logger::info!(\n+            // No entry exists - create a new one\n+            router_env::logger::info!(\n                     \"No existing CALCULATE_WORKFLOW task found for payment_intent_id: {}, creating new entry scheduled for 1 hour from now\",\n                     id.get_string_repr()\n                 );\n \n-                    let tag = [\"PCR\"];\n-                    let task = \"CALCULATE_WORKFLOW\";\n-                    let runner = storage::ProcessTrackerRunner::PassiveRecoveryWorkflow;\n-\n-                    let process_tracker_entry = storage::ProcessTrackerNew::new(\n-                        &process_tracker_id,\n-                        task,\n-                        runner,\n-                        tag,\n-                        process.tracking_data.clone(),\n-                        Some(process.retry_count),\n-                        schedule_time,\n-                        common_types::consts::API_VERSION,\n-                    )\n-                    .change_context(errors::RecoveryError::ProcessTrackerFailure)\n-                    .attach_printable(\n-                        \"Failed to construct calculate workflow process tracker entry\",\n-                    )?;\n-\n-                    // Insert into process tracker with status New\n-                    db.as_scheduler()\n-                        .insert_process(process_tracker_entry)\n-                        .await\n-                        .change_context(errors::RecoveryError::ProcessTrackerFailure)\n-                        .attach_printable(\n-                            \"Failed to enter calculate workflow process_tracker_entry in DB\",\n-                        )?;\n-\n-                    router_env::logger::info!(\n-                    \"Successfully created new CALCULATE_WORKFLOW task for payment_intent_id: {}\",\n-                    id.get_string_repr()\n-                );\n-                }\n-            }\n+            let tag = [\"PCR\"];\n+            let runner = storage::ProcessTrackerRunner::PassiveRecoveryWorkflow;\n+\n+            let process_tracker_entry = storage::ProcessTrackerNew::new(\n+                &process_tracker_id,\n+                task,\n+                runner,\n+                tag,\n+                process.tracking_data.clone(),\n+                Some(process.retry_count),\n+                schedule_time,\n+                common_types::consts::API_VERSION,\n+            )\n+            .change_context(errors::RecoveryError::ProcessTrackerFailure)\n+            .attach_printable(\"Failed to construct calculate workflow process tracker entry\")?;",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2354582811",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9233,
        "pr_file": "crates/router/src/core/revenue_recovery/types.rs",
        "discussion_id": "2354582811",
        "commented_code": "@@ -1244,72 +1244,41 @@ pub async fn reopen_calculate_workflow_on_payment_failure(\n                     \"Failed to check for existing calculate workflow process tracker entry\",\n                 )?;\n \n-            match existing_entry {\n-                Some(existing_process) => {\n-                    router_env::logger::error!(\n-                        \"Found existing CALCULATE_WORKFLOW task with  id: {}\",\n-                        existing_process.id\n-                    );\n-                }\n-                None => {\n-                    // No entry exists - create a new one\n-                    router_env::logger::info!(\n+            // No entry exists - create a new one\n+            router_env::logger::info!(\n                     \"No existing CALCULATE_WORKFLOW task found for payment_intent_id: {}, creating new entry scheduled for 1 hour from now\",\n                     id.get_string_repr()\n                 );\n \n-                    let tag = [\"PCR\"];\n-                    let task = \"CALCULATE_WORKFLOW\";\n-                    let runner = storage::ProcessTrackerRunner::PassiveRecoveryWorkflow;\n-\n-                    let process_tracker_entry = storage::ProcessTrackerNew::new(\n-                        &process_tracker_id,\n-                        task,\n-                        runner,\n-                        tag,\n-                        process.tracking_data.clone(),\n-                        Some(process.retry_count),\n-                        schedule_time,\n-                        common_types::consts::API_VERSION,\n-                    )\n-                    .change_context(errors::RecoveryError::ProcessTrackerFailure)\n-                    .attach_printable(\n-                        \"Failed to construct calculate workflow process tracker entry\",\n-                    )?;\n-\n-                    // Insert into process tracker with status New\n-                    db.as_scheduler()\n-                        .insert_process(process_tracker_entry)\n-                        .await\n-                        .change_context(errors::RecoveryError::ProcessTrackerFailure)\n-                        .attach_printable(\n-                            \"Failed to enter calculate workflow process_tracker_entry in DB\",\n-                        )?;\n-\n-                    router_env::logger::info!(\n-                    \"Successfully created new CALCULATE_WORKFLOW task for payment_intent_id: {}\",\n-                    id.get_string_repr()\n-                );\n-                }\n-            }\n+            let tag = [\"PCR\"];\n+            let runner = storage::ProcessTrackerRunner::PassiveRecoveryWorkflow;\n+\n+            let process_tracker_entry = storage::ProcessTrackerNew::new(\n+                &process_tracker_id,\n+                task,\n+                runner,\n+                tag,\n+                process.tracking_data.clone(),\n+                Some(process.retry_count),\n+                schedule_time,\n+                common_types::consts::API_VERSION,\n+            )\n+            .change_context(errors::RecoveryError::ProcessTrackerFailure)\n+            .attach_printable(\"Failed to construct calculate workflow process tracker entry\")?;",
        "comment_created_at": "2025-09-17T07:29:17+00:00",
        "comment_author": "aniketburman014",
        "comment_body": "Can we have the buffer time for schedule_time from config rather than hardcoding it to 1 hr ? ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2328441835",
    "pr_number": 9289,
    "pr_file": "crates/external_services/src/superposition/superposition.rs",
    "created_at": "2025-09-07T02:07:01+00:00",
    "commented_code": "+use masking::{ExposeInterface, Secret};\n+\n+use super::interface::{ConfigContext, SuperpositionError};\n+\n+/// Configuration for Superposition integration\n+#[derive(Debug, Clone, serde::Deserialize)]\n+pub struct SuperpositionClientConfig {\n+    /// Whether Superposition is enabled\n+    pub enabled: bool,\n+    /// Superposition API endpoint\n+    pub endpoint: String,\n+    /// Authentication token for Superposition\n+    pub token: Secret<String>,\n+    /// Organization ID in Superposition\n+    pub org_id: String,\n+    /// Workspace ID in Superposition\n+    pub workspace_id: String,\n+}\n+\n+impl Default for SuperpositionClientConfig {\n+    fn default() -> Self {\n+        Self {\n+            enabled: false,\n+            endpoint: String::new(),\n+            token: Secret::new(String::new()),\n+            org_id: String::new(),\n+            workspace_id: String::new(),\n+        }\n+    }\n+}\n+\n+/// Superposition client wrapper\n+pub struct SuperpositionClient {\n+    #[cfg(feature = \"superposition\")]\n+    client: open_feature::Client,\n+    #[cfg(not(feature = \"superposition\"))]\n+    _phantom: std::marker::PhantomData<()>,\n+}\n+\n+impl std::fmt::Debug for SuperpositionClient {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"SuperpositionClient\")\n+            .finish_non_exhaustive()\n+    }\n+}\n+\n+impl SuperpositionClient {\n+    /// Create a new Superposition client\n+    pub async fn new(config: SuperpositionClientConfig) -> Result<Self, SuperpositionError> {\n+        #[cfg(feature = \"superposition\")]\n+        {\n+            // Initialize OpenFeature client with Superposition provider\n+            use superposition_provider::{\n+                PollingStrategy, RefreshStrategy, SuperpositionProvider,\n+                SuperpositionProviderOptions,\n+            };\n+\n+            let provider_options = SuperpositionProviderOptions {\n+                endpoint: config.endpoint.clone(),\n+                token: config.token.expose(),\n+                org_id: config.org_id.clone(),\n+                workspace_id: config.workspace_id.clone(),\n+                fallback_config: None,\n+                evaluation_cache: None,\n+                refresh_strategy: RefreshStrategy::Polling(PollingStrategy {\n+                    interval: 15,\n+                    timeout: None,\n+                }),\n+                experimentation_options: None,\n+            };\n+\n+            // Create provider and set up OpenFeature\n+            let provider = SuperpositionProvider::new(provider_options);\n+\n+            router_env::logger::info!(\n+                \"SUPERPOSITION_CLIENT: Created provider, initializing OpenFeature API...\"\n+            );\n+\n+            // Initialize OpenFeature API and set provider\n+            let mut api = open_feature::OpenFeature::singleton_mut().await;\n+            api.set_provider(provider).await;\n+\n+            router_env::logger::info!(\"SUPERPOSITION_CLIENT: Provider set, creating client and waiting for initialization...\");\n+\n+            // Create client and wait for initialization (as per Superposition examples)\n+            let client = api.create_client();\n+            tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2328441835",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9289,
        "pr_file": "crates/external_services/src/superposition/superposition.rs",
        "discussion_id": "2328441835",
        "commented_code": "@@ -0,0 +1,255 @@\n+use masking::{ExposeInterface, Secret};\n+\n+use super::interface::{ConfigContext, SuperpositionError};\n+\n+/// Configuration for Superposition integration\n+#[derive(Debug, Clone, serde::Deserialize)]\n+pub struct SuperpositionClientConfig {\n+    /// Whether Superposition is enabled\n+    pub enabled: bool,\n+    /// Superposition API endpoint\n+    pub endpoint: String,\n+    /// Authentication token for Superposition\n+    pub token: Secret<String>,\n+    /// Organization ID in Superposition\n+    pub org_id: String,\n+    /// Workspace ID in Superposition\n+    pub workspace_id: String,\n+}\n+\n+impl Default for SuperpositionClientConfig {\n+    fn default() -> Self {\n+        Self {\n+            enabled: false,\n+            endpoint: String::new(),\n+            token: Secret::new(String::new()),\n+            org_id: String::new(),\n+            workspace_id: String::new(),\n+        }\n+    }\n+}\n+\n+/// Superposition client wrapper\n+pub struct SuperpositionClient {\n+    #[cfg(feature = \"superposition\")]\n+    client: open_feature::Client,\n+    #[cfg(not(feature = \"superposition\"))]\n+    _phantom: std::marker::PhantomData<()>,\n+}\n+\n+impl std::fmt::Debug for SuperpositionClient {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"SuperpositionClient\")\n+            .finish_non_exhaustive()\n+    }\n+}\n+\n+impl SuperpositionClient {\n+    /// Create a new Superposition client\n+    pub async fn new(config: SuperpositionClientConfig) -> Result<Self, SuperpositionError> {\n+        #[cfg(feature = \"superposition\")]\n+        {\n+            // Initialize OpenFeature client with Superposition provider\n+            use superposition_provider::{\n+                PollingStrategy, RefreshStrategy, SuperpositionProvider,\n+                SuperpositionProviderOptions,\n+            };\n+\n+            let provider_options = SuperpositionProviderOptions {\n+                endpoint: config.endpoint.clone(),\n+                token: config.token.expose(),\n+                org_id: config.org_id.clone(),\n+                workspace_id: config.workspace_id.clone(),\n+                fallback_config: None,\n+                evaluation_cache: None,\n+                refresh_strategy: RefreshStrategy::Polling(PollingStrategy {\n+                    interval: 15,\n+                    timeout: None,\n+                }),\n+                experimentation_options: None,\n+            };\n+\n+            // Create provider and set up OpenFeature\n+            let provider = SuperpositionProvider::new(provider_options);\n+\n+            router_env::logger::info!(\n+                \"SUPERPOSITION_CLIENT: Created provider, initializing OpenFeature API...\"\n+            );\n+\n+            // Initialize OpenFeature API and set provider\n+            let mut api = open_feature::OpenFeature::singleton_mut().await;\n+            api.set_provider(provider).await;\n+\n+            router_env::logger::info!(\"SUPERPOSITION_CLIENT: Provider set, creating client and waiting for initialization...\");\n+\n+            // Create client and wait for initialization (as per Superposition examples)\n+            let client = api.create_client();\n+            tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;",
        "comment_created_at": "2025-09-07T02:07:01+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Why is this number hardcoded? Can we consider moving it to config?",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2003983858",
    "pr_number": 7062,
    "pr_file": "crates/router/src/core/payments/flows/session_flow.rs",
    "created_at": "2025-03-19T18:20:38+00:00",
    "commented_code": "})\n }\n \n+pub trait AmazonPayDeliveryOptionsTrait {\n+    type Error;\n+\n+    fn parse_delivery_options_request(\n+        delivery_options_request: &[serde_json::Value],\n+    ) -> Result<Vec<payment_types::AmazonPayDeliveryOptions>, Self::Error>;\n+\n+    fn validate_is_default_count(\n+        delivery_options: Vec<payment_types::AmazonPayDeliveryOptions>,\n+    ) -> Result<(), Self::Error>;\n+\n+    fn validate_currency(\n+        delivery_options: Vec<payment_types::AmazonPayDeliveryOptions>,\n+    ) -> Result<(), Self::Error>;\n+\n+    fn insert_display_amount(\n+        delivery_options: &mut Vec<payment_types::AmazonPayDeliveryOptions>,\n+        router_data: &types::PaymentsSessionRouterData,\n+    ) -> Result<(), Report<Self::Error>>;\n+}\n+\n+impl AmazonPayDeliveryOptionsTrait for payment_types::AmazonPayDeliveryOptions {\n+    type Error = errors::ApiErrorResponse;\n+\n+    fn parse_delivery_options_request(\n+        delivery_options_request: &[serde_json::Value],\n+    ) -> Result<Vec<Self>, Self::Error> {\n+        delivery_options_request\n+            .iter()\n+            .map(|option| {\n+                serde_json::from_value(option.clone()).map_err(|_| {\n+                    errors::ApiErrorResponse::InvalidDataFormat {\n+                        field_name: \"delivery_options\".to_string(),\n+                        expected_format: \"Valid AmazonPayDeliveryOptions JSON\".to_string(),\n+                    }\n+                })\n+            })\n+            .collect()\n+    }\n+\n+    fn validate_is_default_count(delivery_options: Vec<Self>) -> Result<(), Self::Error> {\n+        let is_default_count = i32::try_from(\n+            delivery_options.iter().filter(|opt| opt.is_default).count(),\n+        )\n+        .map_err(|_| errors::ApiErrorResponse::InvalidDataValue {\n+            field_name: \"is_default\",\n+        })?;\n+\n+        if is_default_count != 1 {\n+            return Err(errors::ApiErrorResponse::InvalidDataValue {\n+                field_name: \"is_default\",\n+            });\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn validate_currency(delivery_options: Vec<Self>) -> Result<(), Self::Error> {\n+        for option in &delivery_options {\n+            if option.price.currency_code != common_enums::Currency::USD {",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2003983858",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 7062,
        "pr_file": "crates/router/src/core/payments/flows/session_flow.rs",
        "discussion_id": "2003983858",
        "commented_code": "@@ -1256,6 +1256,189 @@ fn create_paypal_sdk_session_token(\n     })\n }\n \n+pub trait AmazonPayDeliveryOptionsTrait {\n+    type Error;\n+\n+    fn parse_delivery_options_request(\n+        delivery_options_request: &[serde_json::Value],\n+    ) -> Result<Vec<payment_types::AmazonPayDeliveryOptions>, Self::Error>;\n+\n+    fn validate_is_default_count(\n+        delivery_options: Vec<payment_types::AmazonPayDeliveryOptions>,\n+    ) -> Result<(), Self::Error>;\n+\n+    fn validate_currency(\n+        delivery_options: Vec<payment_types::AmazonPayDeliveryOptions>,\n+    ) -> Result<(), Self::Error>;\n+\n+    fn insert_display_amount(\n+        delivery_options: &mut Vec<payment_types::AmazonPayDeliveryOptions>,\n+        router_data: &types::PaymentsSessionRouterData,\n+    ) -> Result<(), Report<Self::Error>>;\n+}\n+\n+impl AmazonPayDeliveryOptionsTrait for payment_types::AmazonPayDeliveryOptions {\n+    type Error = errors::ApiErrorResponse;\n+\n+    fn parse_delivery_options_request(\n+        delivery_options_request: &[serde_json::Value],\n+    ) -> Result<Vec<Self>, Self::Error> {\n+        delivery_options_request\n+            .iter()\n+            .map(|option| {\n+                serde_json::from_value(option.clone()).map_err(|_| {\n+                    errors::ApiErrorResponse::InvalidDataFormat {\n+                        field_name: \"delivery_options\".to_string(),\n+                        expected_format: \"Valid AmazonPayDeliveryOptions JSON\".to_string(),\n+                    }\n+                })\n+            })\n+            .collect()\n+    }\n+\n+    fn validate_is_default_count(delivery_options: Vec<Self>) -> Result<(), Self::Error> {\n+        let is_default_count = i32::try_from(\n+            delivery_options.iter().filter(|opt| opt.is_default).count(),\n+        )\n+        .map_err(|_| errors::ApiErrorResponse::InvalidDataValue {\n+            field_name: \"is_default\",\n+        })?;\n+\n+        if is_default_count != 1 {\n+            return Err(errors::ApiErrorResponse::InvalidDataValue {\n+                field_name: \"is_default\",\n+            });\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn validate_currency(delivery_options: Vec<Self>) -> Result<(), Self::Error> {\n+        for option in &delivery_options {\n+            if option.price.currency_code != common_enums::Currency::USD {",
        "comment_created_at": "2025-03-19T18:20:38+00:00",
        "comment_author": "ShankarSinghC",
        "comment_body": "Why are we only checking for USD ? if we are doing it because amazon pay supports only USD, even in that case we should have a application config that will contain the amazon pay supported currencies and that config should be used to compare with the currency in delivery option.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2013903612",
    "pr_number": 7062,
    "pr_file": "crates/router/src/core/payments/flows/session_flow.rs",
    "created_at": "2025-03-26T11:04:11+00:00",
    "commented_code": "})\n }\n \n+fn create_amazon_pay_session_token(\n+    router_data: &types::PaymentsSessionRouterData,\n+    state: &routes::SessionState,\n+) -> RouterResult<types::PaymentsSessionRouterData> {\n+    let amazon_pay_session_token_data = router_data\n+        .connector_wallets_details\n+        .clone()\n+        .parse_value::<payment_types::AmazonPaySessionTokenData>(\"AmazonPaySessionTokenData\")\n+        .change_context(errors::ConnectorError::NoConnectorWalletDetails)\n+        .change_context(errors::ApiErrorResponse::InvalidDataFormat {\n+            field_name: \"connector_wallets_details\".to_string(),\n+            expected_format: \"amazon_pay_metadata_format\".to_string(),\n+        })?;\n+    let amazon_pay_metadata = amazon_pay_session_token_data.data;\n+    let merchant_id = amazon_pay_metadata.merchant_id;\n+    let store_id = amazon_pay_metadata.store_id;\n+    let amazonpay_supported_currencies =\n+        &state\n+            .conf\n+            .pm_filters\n+            .0\n+            .get(\"amazonpay\")\n+            .and_then(|payment_method_filters| {\n+                payment_method_filters\n+                    .0\n+                    .iter()\n+                    .find_map(|(key, currency_country_filter)| match key {\n+                        settings::PaymentMethodFilterKey::PaymentMethodType(\n+                            enums::PaymentMethodType::AmazonPay,\n+                        ) => currency_country_filter.currency.as_ref(),\n+                        _ => None,\n+                    })\n+            });\n+    // currently supports only the US region hence USD is the only supported currency",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2013903612",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 7062,
        "pr_file": "crates/router/src/core/payments/flows/session_flow.rs",
        "discussion_id": "2013903612",
        "commented_code": "@@ -1256,6 +1256,140 @@ fn create_paypal_sdk_session_token(\n     })\n }\n \n+fn create_amazon_pay_session_token(\n+    router_data: &types::PaymentsSessionRouterData,\n+    state: &routes::SessionState,\n+) -> RouterResult<types::PaymentsSessionRouterData> {\n+    let amazon_pay_session_token_data = router_data\n+        .connector_wallets_details\n+        .clone()\n+        .parse_value::<payment_types::AmazonPaySessionTokenData>(\"AmazonPaySessionTokenData\")\n+        .change_context(errors::ConnectorError::NoConnectorWalletDetails)\n+        .change_context(errors::ApiErrorResponse::InvalidDataFormat {\n+            field_name: \"connector_wallets_details\".to_string(),\n+            expected_format: \"amazon_pay_metadata_format\".to_string(),\n+        })?;\n+    let amazon_pay_metadata = amazon_pay_session_token_data.data;\n+    let merchant_id = amazon_pay_metadata.merchant_id;\n+    let store_id = amazon_pay_metadata.store_id;\n+    let amazonpay_supported_currencies =\n+        &state\n+            .conf\n+            .pm_filters\n+            .0\n+            .get(\"amazonpay\")\n+            .and_then(|payment_method_filters| {\n+                payment_method_filters\n+                    .0\n+                    .iter()\n+                    .find_map(|(key, currency_country_filter)| match key {\n+                        settings::PaymentMethodFilterKey::PaymentMethodType(\n+                            enums::PaymentMethodType::AmazonPay,\n+                        ) => currency_country_filter.currency.as_ref(),\n+                        _ => None,\n+                    })\n+            });\n+    // currently supports only the US region hence USD is the only supported currency",
        "comment_created_at": "2025-03-26T11:04:11+00:00",
        "comment_author": "sai-harsha-vardhan",
        "comment_body": "If it always need to support USD only, why do we need to get config from conf?",
        "pr_file_module": null
      },
      {
        "comment_id": "2014601518",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 7062,
        "pr_file": "crates/router/src/core/payments/flows/session_flow.rs",
        "discussion_id": "2013903612",
        "commented_code": "@@ -1256,6 +1256,140 @@ fn create_paypal_sdk_session_token(\n     })\n }\n \n+fn create_amazon_pay_session_token(\n+    router_data: &types::PaymentsSessionRouterData,\n+    state: &routes::SessionState,\n+) -> RouterResult<types::PaymentsSessionRouterData> {\n+    let amazon_pay_session_token_data = router_data\n+        .connector_wallets_details\n+        .clone()\n+        .parse_value::<payment_types::AmazonPaySessionTokenData>(\"AmazonPaySessionTokenData\")\n+        .change_context(errors::ConnectorError::NoConnectorWalletDetails)\n+        .change_context(errors::ApiErrorResponse::InvalidDataFormat {\n+            field_name: \"connector_wallets_details\".to_string(),\n+            expected_format: \"amazon_pay_metadata_format\".to_string(),\n+        })?;\n+    let amazon_pay_metadata = amazon_pay_session_token_data.data;\n+    let merchant_id = amazon_pay_metadata.merchant_id;\n+    let store_id = amazon_pay_metadata.store_id;\n+    let amazonpay_supported_currencies =\n+        &state\n+            .conf\n+            .pm_filters\n+            .0\n+            .get(\"amazonpay\")\n+            .and_then(|payment_method_filters| {\n+                payment_method_filters\n+                    .0\n+                    .iter()\n+                    .find_map(|(key, currency_country_filter)| match key {\n+                        settings::PaymentMethodFilterKey::PaymentMethodType(\n+                            enums::PaymentMethodType::AmazonPay,\n+                        ) => currency_country_filter.currency.as_ref(),\n+                        _ => None,\n+                    })\n+            });\n+    // currently supports only the US region hence USD is the only supported currency",
        "comment_created_at": "2025-03-26T16:51:57+00:00",
        "comment_author": "Anurag-05-prog",
        "comment_body": "We can do hardcode `USD` for now but in future we'll have EUR also as a supported currency (which will go in a separate PR).",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2266371532",
    "pr_number": 8848,
    "pr_file": "crates/router/src/core/revenue_recovery.rs",
    "created_at": "2025-08-11T11:10:28+00:00",
    "commented_code": "Ok(())\n }\n \n+pub async fn perform_calculate_workflow(\n+    state: &SessionState,\n+    process: &storage::ProcessTracker,\n+    tracking_data: &pcr::RevenueRecoveryWorkflowTrackingData,\n+    revenue_recovery_payment_data: &pcr::RevenueRecoveryPaymentData,\n+    payment_intent: &PaymentIntent,\n+) -> Result<(), sch_errors::ProcessTrackerError> {\n+    let db = &*state.store;\n+    let merchant_id = revenue_recovery_payment_data.merchant_account.get_id();\n+    let profile_id = revenue_recovery_payment_data.profile.get_id();\n+    let billing_mca_id = revenue_recovery_payment_data.billing_mca.get_id();\n+\n+    logger::info!(\n+        process_id = %process.id,\n+        payment_id = %tracking_data.global_payment_id.get_string_repr(),\n+        \"Starting CALCULATE_WORKFLOW...\"\n+    );\n+\n+    // 1. Extract customer_id and token_list from tracking_data\n+    let customer_id = payment_intent\n+        .extract_connector_customer_id_from_payment_intent()\n+        .map_err(|_| sch_errors::ProcessTrackerError::MissingRequiredField)?;\n+\n+    let merchant_context_from_revenue_recovery_payment_data =\n+        domain::MerchantContext::NormalMerchant(Box::new(domain::Context(\n+            revenue_recovery_payment_data.merchant_account.clone(),\n+            revenue_recovery_payment_data.key_store.clone(),\n+        )));\n+\n+    // 2. Get best available token\n+    let best_token_result = match workflows::revenue_recovery::get_best_psp_token_available(\n+        state,\n+        &customer_id,\n+        &payment_intent.id,\n+        merchant_context_from_revenue_recovery_payment_data,\n+    )\n+    .await\n+    {\n+        Ok(token_opt) => token_opt,\n+        Err(e) => {\n+            logger::error!(\n+                error = ?e,\n+                customer_id = %customer_id,\n+                \"Failed to get best PSP token\"\n+            );\n+            None\n+        }\n+    };\n+\n+    match best_token_result {\n+        Some(scheduled_token) => {\n+            logger::info!(\n+                process_id = %process.id,\n+                customer_id = %customer_id,\n+                \"Found best available token, creating EXECUTE_WORKFLOW task\"\n+            );\n+\n+            // 3. If token found: create EXECUTE_WORKFLOW task and finish CALCULATE_WORKFLOW\n+            insert_execute_pcr_task_to_pt(\n+                &tracking_data.billing_mca_id,\n+                state,\n+                &tracking_data.merchant_id,\n+                payment_intent,\n+                &tracking_data.profile_id,\n+                &tracking_data.payment_attempt_id,\n+                storage::ProcessTrackerRunner::PassiveRecoveryWorkflow,\n+                tracking_data.revenue_recovery_retry,\n+                scheduled_token,\n+            )\n+            .await?;\n+\n+            db.as_scheduler()\n+                .finish_process_with_business_status(\n+                    process.clone(),\n+                    business_status::CALCULATE_WORKFLOW_SCHEDULED,\n+                )\n+                .await\n+                .map_err(|e| {\n+                    logger::error!(\n+                        process_id = %process.id,\n+                        error = ?e,\n+                        \"Failed to update CALCULATE_WORKFLOW status to complete\"\n+                    );\n+                    sch_errors::ProcessTrackerError::ProcessUpdateFailed\n+                })?;\n+\n+            logger::info!(\n+                process_id = %process.id,\n+                customer_id = %customer_id,\n+                \"CALCULATE_WORKFLOW completed successfully\"\n+            );\n+        }\n+\n+        None => {\n+            // Update scheduled time to scheduled time + 15 minutes\n+            // here scheduled_time is the wait time 15 mintutes is a buffer time that we are adding\n+            logger::info!(\n+                process_id = %process.id,\n+                customer_id = %customer_id,\n+                \"No token but time available, rescheduling for scheduled time + 15 mins\"\n+            );\n+\n+            let scheduled_token = match storage::revenue_recovery_redis_operation::\n+                RedisTokenManager::get_payment_processor_token_with_schedule_time(state, &customer_id)\n+                .await {\n+                    Ok(scheduled_token_opt) => scheduled_token_opt,\n+                    Err(e) => {\n+                        logger::error!(\n+                            error = ?e,\n+                            customer_id = %customer_id,\n+                            \"Failed to get PSP token status\"\n+                        );\n+                        None\n+                    }\n+                };\n+\n+            match scheduled_token {\n+                Some(scheduled_token) => {\n+                    let new_schedule_time = scheduled_token\n+                        .scheduled_at\n+                        .unwrap_or(common_utils::date_time::now())\n+                        + time::Duration::minutes(15);",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2266371532",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8848,
        "pr_file": "crates/router/src/core/revenue_recovery.rs",
        "discussion_id": "2266371532",
        "commented_code": "@@ -284,6 +434,353 @@ pub async fn perform_payments_sync(\n     Ok(())\n }\n \n+pub async fn perform_calculate_workflow(\n+    state: &SessionState,\n+    process: &storage::ProcessTracker,\n+    tracking_data: &pcr::RevenueRecoveryWorkflowTrackingData,\n+    revenue_recovery_payment_data: &pcr::RevenueRecoveryPaymentData,\n+    payment_intent: &PaymentIntent,\n+) -> Result<(), sch_errors::ProcessTrackerError> {\n+    let db = &*state.store;\n+    let merchant_id = revenue_recovery_payment_data.merchant_account.get_id();\n+    let profile_id = revenue_recovery_payment_data.profile.get_id();\n+    let billing_mca_id = revenue_recovery_payment_data.billing_mca.get_id();\n+\n+    logger::info!(\n+        process_id = %process.id,\n+        payment_id = %tracking_data.global_payment_id.get_string_repr(),\n+        \"Starting CALCULATE_WORKFLOW...\"\n+    );\n+\n+    // 1. Extract customer_id and token_list from tracking_data\n+    let customer_id = payment_intent\n+        .extract_connector_customer_id_from_payment_intent()\n+        .map_err(|_| sch_errors::ProcessTrackerError::MissingRequiredField)?;\n+\n+    let merchant_context_from_revenue_recovery_payment_data =\n+        domain::MerchantContext::NormalMerchant(Box::new(domain::Context(\n+            revenue_recovery_payment_data.merchant_account.clone(),\n+            revenue_recovery_payment_data.key_store.clone(),\n+        )));\n+\n+    // 2. Get best available token\n+    let best_token_result = match workflows::revenue_recovery::get_best_psp_token_available(\n+        state,\n+        &customer_id,\n+        &payment_intent.id,\n+        merchant_context_from_revenue_recovery_payment_data,\n+    )\n+    .await\n+    {\n+        Ok(token_opt) => token_opt,\n+        Err(e) => {\n+            logger::error!(\n+                error = ?e,\n+                customer_id = %customer_id,\n+                \"Failed to get best PSP token\"\n+            );\n+            None\n+        }\n+    };\n+\n+    match best_token_result {\n+        Some(scheduled_token) => {\n+            logger::info!(\n+                process_id = %process.id,\n+                customer_id = %customer_id,\n+                \"Found best available token, creating EXECUTE_WORKFLOW task\"\n+            );\n+\n+            // 3. If token found: create EXECUTE_WORKFLOW task and finish CALCULATE_WORKFLOW\n+            insert_execute_pcr_task_to_pt(\n+                &tracking_data.billing_mca_id,\n+                state,\n+                &tracking_data.merchant_id,\n+                payment_intent,\n+                &tracking_data.profile_id,\n+                &tracking_data.payment_attempt_id,\n+                storage::ProcessTrackerRunner::PassiveRecoveryWorkflow,\n+                tracking_data.revenue_recovery_retry,\n+                scheduled_token,\n+            )\n+            .await?;\n+\n+            db.as_scheduler()\n+                .finish_process_with_business_status(\n+                    process.clone(),\n+                    business_status::CALCULATE_WORKFLOW_SCHEDULED,\n+                )\n+                .await\n+                .map_err(|e| {\n+                    logger::error!(\n+                        process_id = %process.id,\n+                        error = ?e,\n+                        \"Failed to update CALCULATE_WORKFLOW status to complete\"\n+                    );\n+                    sch_errors::ProcessTrackerError::ProcessUpdateFailed\n+                })?;\n+\n+            logger::info!(\n+                process_id = %process.id,\n+                customer_id = %customer_id,\n+                \"CALCULATE_WORKFLOW completed successfully\"\n+            );\n+        }\n+\n+        None => {\n+            // Update scheduled time to scheduled time + 15 minutes\n+            // here scheduled_time is the wait time 15 mintutes is a buffer time that we are adding\n+            logger::info!(\n+                process_id = %process.id,\n+                customer_id = %customer_id,\n+                \"No token but time available, rescheduling for scheduled time + 15 mins\"\n+            );\n+\n+            let scheduled_token = match storage::revenue_recovery_redis_operation::\n+                RedisTokenManager::get_payment_processor_token_with_schedule_time(state, &customer_id)\n+                .await {\n+                    Ok(scheduled_token_opt) => scheduled_token_opt,\n+                    Err(e) => {\n+                        logger::error!(\n+                            error = ?e,\n+                            customer_id = %customer_id,\n+                            \"Failed to get PSP token status\"\n+                        );\n+                        None\n+                    }\n+                };\n+\n+            match scheduled_token {\n+                Some(scheduled_token) => {\n+                    let new_schedule_time = scheduled_token\n+                        .scheduled_at\n+                        .unwrap_or(common_utils::date_time::now())\n+                        + time::Duration::minutes(15);",
        "comment_created_at": "2025-08-11T11:10:28+00:00",
        "comment_author": "jarnura",
        "comment_body": "don't hard code time like this, make this as configurable one",
        "pr_file_module": null
      }
    ]
  }
]