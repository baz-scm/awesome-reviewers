[
  {
    "discussion_id": "2273579620",
    "pr_number": 8628,
    "pr_file": "crates/router/src/core/payments.rs",
    "created_at": "2025-08-13T14:01:18+00:00",
    "commented_code": "}\n \n #[cfg(feature = \"v1\")]\n-pub async fn decide_action_type(\n+pub struct ActionTypesBuilder {\n+    action_types: Vec<ActionType>,\n+}\n+\n+#[cfg(feature = \"v1\")]\n+impl ActionTypesBuilder {\n+    pub fn new() -> Self {\n+        Self {\n+            action_types: Vec::new(),\n+        }\n+    }\n+\n+    pub fn with_mandate_flow(\n+        mut self,\n+        is_mandate_flow: bool,\n+        connector_mandate_details: &Result<\n+            Option<diesel_models::PaymentsMandateReference>,\n+            error_stack::Report<common_utils::errors::ParsingError>,\n+        >,\n+    ) -> Self {\n+        if is_mandate_flow {\n+            self.action_types.extend(\n+                connector_mandate_details\n+                    .as_ref()\n+                    .ok()\n+                    .map(|details| ActionType::ConnectorMandate(details.to_owned())),\n+            );\n+        }\n+        self\n+    }\n+\n+    pub async fn with_network_tokenization(\n+        mut self,\n+        state: &SessionState,\n+        is_network_token_with_ntid_flow: IsNtWithNtiFlow,\n+        is_nt_with_ntid_supported_connector: bool,\n+        payment_method_info: &domain::PaymentMethod,\n+    ) -> Self {\n+        match is_network_token_with_ntid_flow {\n+            IsNtWithNtiFlow::NtWithNtiSupported(network_transaction_id)\n+                if is_nt_with_ntid_supported_connector =>\n+            {\n+                self.action_types.extend(\n+                    network_tokenization::do_status_check_for_network_token(\n+                        state,\n+                        payment_method_info,\n+                    )\n+                    .await\n+                    .ok()\n+                    .map(|(token_exp_month, token_exp_year)| {\n+                        ActionType::NetworkTokenWithNetworkTransactionId(NTWithNTIRef {\n+                            token_exp_month,\n+                            token_exp_year,\n+                            network_transaction_id,\n+                        })\n+                    }),\n+                );\n+            }\n+            _ => (),\n+        }\n+        self\n+    }\n+\n+    pub fn with_card_network_transaction_id(\n+        mut self,\n+        is_card_with_ntid_flow: bool,\n+        payment_method_info: &domain::PaymentMethod,\n+    ) -> Self {\n+        if is_card_with_ntid_flow {\n+            self.action_types.extend(\n+                payment_method_info\n+                    .network_transaction_id\n+                    .as_ref()\n+                    .map(|ntid| ActionType::CardWithNetworkTransactionId(ntid.clone())),\n+            );\n+        }\n+        self\n+    }\n+\n+    pub fn build(self) -> Vec<ActionType> {\n+        self.action_types\n+    }\n+}\n+\n+#[cfg(feature = \"v1\")]\n+pub async fn get_all_action_types(\n     state: &SessionState,\n     is_connector_agnostic_mit_enabled: Option<bool>,\n     is_network_tokenization_enabled: bool,\n     payment_method_info: &domain::PaymentMethod,\n-    filtered_nt_supported_connectors: Vec<api::ConnectorRoutingData>, //network tokenization supported connectors\n-) -> Option<ActionType> {\n-    match (\n-        is_network_token_with_network_transaction_id_flow(\n-            is_connector_agnostic_mit_enabled,\n-            is_network_tokenization_enabled,\n+    connector: api::ConnectorData,\n+) -> Vec<ActionType> {\n+    let merchant_connector_id = connector.merchant_connector_id.as_ref();\n+\n+    //fetch connectors that support ntid flow\n+    let ntid_supported_connectors = &state\n+        .conf\n+        .network_transaction_id_supported_connectors\n+        .connector_list;\n+\n+    //fetch connectors that support network tokenization flow\n+    let network_tokenization_supported_connectors = &state\n+        .conf\n+        .network_tokenization_supported_connectors\n+        .connector_list;\n+\n+    let is_network_token_with_ntid_flow = is_network_token_with_network_transaction_id_flow(\n+        is_connector_agnostic_mit_enabled,\n+        is_network_tokenization_enabled,\n+        payment_method_info,\n+    );\n+    let is_card_with_ntid_flow = is_network_transaction_id_flow(\n+        state,\n+        is_connector_agnostic_mit_enabled,\n+        connector.connector_name,\n+        payment_method_info,\n+    );\n+    let connector_mandate_details = &payment_method_info\n+        .connector_mandate_details\n+        .clone()\n+        .map(|details| {\n+            details\n+                .parse_value::<diesel_models::PaymentsMandateReference>(\"connector_mandate_details\")\n+        })\n+        .transpose();\n+\n+    let is_mandate_flow = connector_mandate_details\n+        .as_ref()\n+        .ok()",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2273579620",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8628,
        "pr_file": "crates/router/src/core/payments.rs",
        "discussion_id": "2273579620",
        "commented_code": "@@ -8522,40 +8608,154 @@ pub fn filter_network_tokenization_supported_connectors(\n }\n \n #[cfg(feature = \"v1\")]\n-pub async fn decide_action_type(\n+pub struct ActionTypesBuilder {\n+    action_types: Vec<ActionType>,\n+}\n+\n+#[cfg(feature = \"v1\")]\n+impl ActionTypesBuilder {\n+    pub fn new() -> Self {\n+        Self {\n+            action_types: Vec::new(),\n+        }\n+    }\n+\n+    pub fn with_mandate_flow(\n+        mut self,\n+        is_mandate_flow: bool,\n+        connector_mandate_details: &Result<\n+            Option<diesel_models::PaymentsMandateReference>,\n+            error_stack::Report<common_utils::errors::ParsingError>,\n+        >,\n+    ) -> Self {\n+        if is_mandate_flow {\n+            self.action_types.extend(\n+                connector_mandate_details\n+                    .as_ref()\n+                    .ok()\n+                    .map(|details| ActionType::ConnectorMandate(details.to_owned())),\n+            );\n+        }\n+        self\n+    }\n+\n+    pub async fn with_network_tokenization(\n+        mut self,\n+        state: &SessionState,\n+        is_network_token_with_ntid_flow: IsNtWithNtiFlow,\n+        is_nt_with_ntid_supported_connector: bool,\n+        payment_method_info: &domain::PaymentMethod,\n+    ) -> Self {\n+        match is_network_token_with_ntid_flow {\n+            IsNtWithNtiFlow::NtWithNtiSupported(network_transaction_id)\n+                if is_nt_with_ntid_supported_connector =>\n+            {\n+                self.action_types.extend(\n+                    network_tokenization::do_status_check_for_network_token(\n+                        state,\n+                        payment_method_info,\n+                    )\n+                    .await\n+                    .ok()\n+                    .map(|(token_exp_month, token_exp_year)| {\n+                        ActionType::NetworkTokenWithNetworkTransactionId(NTWithNTIRef {\n+                            token_exp_month,\n+                            token_exp_year,\n+                            network_transaction_id,\n+                        })\n+                    }),\n+                );\n+            }\n+            _ => (),\n+        }\n+        self\n+    }\n+\n+    pub fn with_card_network_transaction_id(\n+        mut self,\n+        is_card_with_ntid_flow: bool,\n+        payment_method_info: &domain::PaymentMethod,\n+    ) -> Self {\n+        if is_card_with_ntid_flow {\n+            self.action_types.extend(\n+                payment_method_info\n+                    .network_transaction_id\n+                    .as_ref()\n+                    .map(|ntid| ActionType::CardWithNetworkTransactionId(ntid.clone())),\n+            );\n+        }\n+        self\n+    }\n+\n+    pub fn build(self) -> Vec<ActionType> {\n+        self.action_types\n+    }\n+}\n+\n+#[cfg(feature = \"v1\")]\n+pub async fn get_all_action_types(\n     state: &SessionState,\n     is_connector_agnostic_mit_enabled: Option<bool>,\n     is_network_tokenization_enabled: bool,\n     payment_method_info: &domain::PaymentMethod,\n-    filtered_nt_supported_connectors: Vec<api::ConnectorRoutingData>, //network tokenization supported connectors\n-) -> Option<ActionType> {\n-    match (\n-        is_network_token_with_network_transaction_id_flow(\n-            is_connector_agnostic_mit_enabled,\n-            is_network_tokenization_enabled,\n+    connector: api::ConnectorData,\n+) -> Vec<ActionType> {\n+    let merchant_connector_id = connector.merchant_connector_id.as_ref();\n+\n+    //fetch connectors that support ntid flow\n+    let ntid_supported_connectors = &state\n+        .conf\n+        .network_transaction_id_supported_connectors\n+        .connector_list;\n+\n+    //fetch connectors that support network tokenization flow\n+    let network_tokenization_supported_connectors = &state\n+        .conf\n+        .network_tokenization_supported_connectors\n+        .connector_list;\n+\n+    let is_network_token_with_ntid_flow = is_network_token_with_network_transaction_id_flow(\n+        is_connector_agnostic_mit_enabled,\n+        is_network_tokenization_enabled,\n+        payment_method_info,\n+    );\n+    let is_card_with_ntid_flow = is_network_transaction_id_flow(\n+        state,\n+        is_connector_agnostic_mit_enabled,\n+        connector.connector_name,\n+        payment_method_info,\n+    );\n+    let connector_mandate_details = &payment_method_info\n+        .connector_mandate_details\n+        .clone()\n+        .map(|details| {\n+            details\n+                .parse_value::<diesel_models::PaymentsMandateReference>(\"connector_mandate_details\")\n+        })\n+        .transpose();\n+\n+    let is_mandate_flow = connector_mandate_details\n+        .as_ref()\n+        .ok()",
        "comment_created_at": "2025-08-13T14:01:18+00:00",
        "comment_author": "ShankarSinghC",
        "comment_body": "You can do flatten here to avoid `details.clone().map(|d| d.contains_key(merchant_id))`",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2314352595",
    "pr_number": 9075,
    "pr_file": "crates/router/src/core/payment_methods/migration.rs",
    "created_at": "2025-09-01T16:55:11+00:00",
    "commented_code": "+use actix_multipart::form::{self, bytes, text};\n+use api_models::payment_methods as pm_api;\n+use common_utils::{errors::CustomResult, id_type};\n+use csv::Reader;\n+use error_stack::ResultExt;\n+use hyperswitch_domain_models::{\n+    api::ApplicationResponse, errors::api_error_response as errors, merchant_context,\n+    payment_methods::PaymentMethodUpdate,\n+};\n+use masking::PeekInterface;\n+use rdkafka::message::ToBytes;\n+use router_env::logger;\n+\n+use crate::{core::errors::StorageErrorExt, routes::SessionState};\n+\n+type PmMigrationResult<T> = CustomResult<ApplicationResponse<T>, errors::ApiErrorResponse>;\n+\n+#[cfg(feature = \"v1\")]\n+pub async fn update_payment_methods(\n+    state: &SessionState,\n+    payment_methods: Vec<pm_api::UpdatePaymentMethodRecord>,\n+    merchant_id: &id_type::MerchantId,\n+    merchant_context: &merchant_context::MerchantContext,\n+) -> PmMigrationResult<Vec<pm_api::PaymentMethodUpdateResponse>> {\n+    let mut result = Vec::with_capacity(payment_methods.len());\n+\n+    for record in payment_methods {\n+        let update_res =\n+            update_payment_method_record(state, record.clone(), merchant_id, merchant_context)\n+                .await;\n+        let res = match update_res {\n+            Ok(ApplicationResponse::Json(response)) => Ok(response),\n+            Err(e) => Err(e.to_string()),\n+            _ => Err(\"Failed to update payment method\".to_string()),\n+        };\n+\n+        result.push(pm_api::PaymentMethodUpdateResponse::from((res, record)));\n+    }\n+    Ok(ApplicationResponse::Json(result))\n+}\n+\n+#[cfg(feature = \"v1\")]\n+pub async fn update_payment_method_record(\n+    state: &SessionState,\n+    req: pm_api::UpdatePaymentMethodRecord,\n+    merchant_id: &id_type::MerchantId,\n+    merchant_context: &merchant_context::MerchantContext,\n+) -> CustomResult<\n+    ApplicationResponse<pm_api::PaymentMethodRecordUpdateResponse>,\n+    errors::ApiErrorResponse,\n+> {\n+    use std::collections::HashMap;\n+\n+    use common_enums::enums;\n+    use common_utils::pii;\n+    use hyperswitch_domain_models::mandates::{\n+        CommonMandateReference, PaymentsMandateReference, PaymentsMandateReferenceRecord,\n+        PayoutsMandateReference, PayoutsMandateReferenceRecord,\n+    };\n+\n+    let db = &*state.store;\n+    let payment_method_id = req.payment_method_id.clone();\n+    let network_transaction_id = req.network_transaction_id.clone();\n+    let status = req.status;\n+\n+    let payment_method = db\n+        .find_payment_method(\n+            &state.into(),\n+            merchant_context.get_merchant_key_store(),\n+            &payment_method_id,\n+            merchant_context.get_merchant_account().storage_scheme,\n+        )\n+        .await\n+        .to_not_found_response(errors::ApiErrorResponse::PaymentMethodNotFound)?;\n+\n+    if payment_method.merchant_id != *merchant_id {\n+        return Err(errors::ApiErrorResponse::InternalServerError).attach_printable(\n+    \"Merchant ID in the request does not match the Merchant ID in the payment method record.\".to_string()\n+);\n+    }\n+\n+    let mandate_details = payment_method\n+        .get_common_mandate_reference()\n+        .change_context(errors::ApiErrorResponse::InternalServerError)\n+        .attach_printable(\"Failed to deserialize to Payment Mandate Reference \")?;\n+\n+    let updated_connector_mandate_details =\n+        match (&req.payment_instrument_id, &req.merchant_connector_id) {\n+            (Some(payment_instrument_id), Some(merchant_connector_id)) => {\n+                let mca = db\n+                    .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n+                        &state.into(),\n+                        merchant_context.get_merchant_account().get_id(),\n+                        merchant_connector_id,\n+                        merchant_context.get_merchant_key_store(),\n+                    )\n+                    .await\n+                    .change_context(errors::ApiErrorResponse::InternalServerError)\n+                    .attach_printable(\"Failed to fetch merchant connector account\")?;\n+                let is_mca_connector_type_payout =\n+                    matches!(mca.connector_type, enums::ConnectorType::PayoutProcessor);\n+                if is_mca_connector_type_payout {\n+                    // Handle PayoutsMandateReference\n+                    let mut existing_payouts_mandate = mandate_details\n+                        .payouts\n+                        .unwrap_or_else(|| PayoutsMandateReference(HashMap::new()));\n+\n+                    // Create new payout mandate record\n+                    let new_payout_record = PayoutsMandateReferenceRecord {\n+                        transfer_method_id: Some(payment_instrument_id.peek().to_string()),\n+                    };\n+\n+                    // Check if record exists for this merchant_connector_id\n+                    if let Some(existing_record) =\n+                        existing_payouts_mandate.0.get_mut(merchant_connector_id)\n+                    {\n+                        // Update only fields that have values in new record\n+                        if let Some(transfer_method_id) = &new_payout_record.transfer_method_id {\n+                            existing_record.transfer_method_id = Some(transfer_method_id.clone());\n+                        }\n+                    } else {\n+                        // Insert new record in connector_mandate_details\n+                        existing_payouts_mandate\n+                            .0\n+                            .insert(merchant_connector_id.clone(), new_payout_record);\n+                    }\n+\n+                    // Create updated CommonMandateReference preserving payments section\n+                    CommonMandateReference {\n+                        payments: mandate_details.payments,\n+                        payouts: Some(existing_payouts_mandate),\n+                    }\n+                } else {\n+                    // Handle PaymentsMandateReference\n+                    let mut existing_payments_mandate = mandate_details\n+                        .payments\n+                        .unwrap_or_else(|| PaymentsMandateReference(HashMap::new()));\n+\n+                    // Check if record exists for this merchant_connector_id\n+                    if let Some(existing_record) =\n+                        existing_payments_mandate.0.get_mut(merchant_connector_id)\n+                    {\n+                        existing_record.connector_mandate_id =\n+                            payment_instrument_id.peek().to_string();\n+                    } else {\n+                        // Insert new record in connector_mandate_details\n+                        existing_payments_mandate.0.insert(\n+                            merchant_connector_id.clone(),\n+                            PaymentsMandateReferenceRecord {\n+                                connector_mandate_id: payment_instrument_id.peek().to_string(),\n+                                payment_method_type: None,\n+                                original_payment_authorized_amount: None,\n+                                original_payment_authorized_currency: None,\n+                                mandate_metadata: None,\n+                                connector_mandate_status: None,\n+                                connector_mandate_request_reference_id: None,\n+                            },\n+                        );\n+                    }",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2314352595",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9075,
        "pr_file": "crates/router/src/core/payment_methods/migration.rs",
        "discussion_id": "2314352595",
        "commented_code": "@@ -0,0 +1,249 @@\n+use actix_multipart::form::{self, bytes, text};\n+use api_models::payment_methods as pm_api;\n+use common_utils::{errors::CustomResult, id_type};\n+use csv::Reader;\n+use error_stack::ResultExt;\n+use hyperswitch_domain_models::{\n+    api::ApplicationResponse, errors::api_error_response as errors, merchant_context,\n+    payment_methods::PaymentMethodUpdate,\n+};\n+use masking::PeekInterface;\n+use rdkafka::message::ToBytes;\n+use router_env::logger;\n+\n+use crate::{core::errors::StorageErrorExt, routes::SessionState};\n+\n+type PmMigrationResult<T> = CustomResult<ApplicationResponse<T>, errors::ApiErrorResponse>;\n+\n+#[cfg(feature = \"v1\")]\n+pub async fn update_payment_methods(\n+    state: &SessionState,\n+    payment_methods: Vec<pm_api::UpdatePaymentMethodRecord>,\n+    merchant_id: &id_type::MerchantId,\n+    merchant_context: &merchant_context::MerchantContext,\n+) -> PmMigrationResult<Vec<pm_api::PaymentMethodUpdateResponse>> {\n+    let mut result = Vec::with_capacity(payment_methods.len());\n+\n+    for record in payment_methods {\n+        let update_res =\n+            update_payment_method_record(state, record.clone(), merchant_id, merchant_context)\n+                .await;\n+        let res = match update_res {\n+            Ok(ApplicationResponse::Json(response)) => Ok(response),\n+            Err(e) => Err(e.to_string()),\n+            _ => Err(\"Failed to update payment method\".to_string()),\n+        };\n+\n+        result.push(pm_api::PaymentMethodUpdateResponse::from((res, record)));\n+    }\n+    Ok(ApplicationResponse::Json(result))\n+}\n+\n+#[cfg(feature = \"v1\")]\n+pub async fn update_payment_method_record(\n+    state: &SessionState,\n+    req: pm_api::UpdatePaymentMethodRecord,\n+    merchant_id: &id_type::MerchantId,\n+    merchant_context: &merchant_context::MerchantContext,\n+) -> CustomResult<\n+    ApplicationResponse<pm_api::PaymentMethodRecordUpdateResponse>,\n+    errors::ApiErrorResponse,\n+> {\n+    use std::collections::HashMap;\n+\n+    use common_enums::enums;\n+    use common_utils::pii;\n+    use hyperswitch_domain_models::mandates::{\n+        CommonMandateReference, PaymentsMandateReference, PaymentsMandateReferenceRecord,\n+        PayoutsMandateReference, PayoutsMandateReferenceRecord,\n+    };\n+\n+    let db = &*state.store;\n+    let payment_method_id = req.payment_method_id.clone();\n+    let network_transaction_id = req.network_transaction_id.clone();\n+    let status = req.status;\n+\n+    let payment_method = db\n+        .find_payment_method(\n+            &state.into(),\n+            merchant_context.get_merchant_key_store(),\n+            &payment_method_id,\n+            merchant_context.get_merchant_account().storage_scheme,\n+        )\n+        .await\n+        .to_not_found_response(errors::ApiErrorResponse::PaymentMethodNotFound)?;\n+\n+    if payment_method.merchant_id != *merchant_id {\n+        return Err(errors::ApiErrorResponse::InternalServerError).attach_printable(\n+    \"Merchant ID in the request does not match the Merchant ID in the payment method record.\".to_string()\n+);\n+    }\n+\n+    let mandate_details = payment_method\n+        .get_common_mandate_reference()\n+        .change_context(errors::ApiErrorResponse::InternalServerError)\n+        .attach_printable(\"Failed to deserialize to Payment Mandate Reference \")?;\n+\n+    let updated_connector_mandate_details =\n+        match (&req.payment_instrument_id, &req.merchant_connector_id) {\n+            (Some(payment_instrument_id), Some(merchant_connector_id)) => {\n+                let mca = db\n+                    .find_by_merchant_connector_account_merchant_id_merchant_connector_id(\n+                        &state.into(),\n+                        merchant_context.get_merchant_account().get_id(),\n+                        merchant_connector_id,\n+                        merchant_context.get_merchant_key_store(),\n+                    )\n+                    .await\n+                    .change_context(errors::ApiErrorResponse::InternalServerError)\n+                    .attach_printable(\"Failed to fetch merchant connector account\")?;\n+                let is_mca_connector_type_payout =\n+                    matches!(mca.connector_type, enums::ConnectorType::PayoutProcessor);\n+                if is_mca_connector_type_payout {\n+                    // Handle PayoutsMandateReference\n+                    let mut existing_payouts_mandate = mandate_details\n+                        .payouts\n+                        .unwrap_or_else(|| PayoutsMandateReference(HashMap::new()));\n+\n+                    // Create new payout mandate record\n+                    let new_payout_record = PayoutsMandateReferenceRecord {\n+                        transfer_method_id: Some(payment_instrument_id.peek().to_string()),\n+                    };\n+\n+                    // Check if record exists for this merchant_connector_id\n+                    if let Some(existing_record) =\n+                        existing_payouts_mandate.0.get_mut(merchant_connector_id)\n+                    {\n+                        // Update only fields that have values in new record\n+                        if let Some(transfer_method_id) = &new_payout_record.transfer_method_id {\n+                            existing_record.transfer_method_id = Some(transfer_method_id.clone());\n+                        }\n+                    } else {\n+                        // Insert new record in connector_mandate_details\n+                        existing_payouts_mandate\n+                            .0\n+                            .insert(merchant_connector_id.clone(), new_payout_record);\n+                    }\n+\n+                    // Create updated CommonMandateReference preserving payments section\n+                    CommonMandateReference {\n+                        payments: mandate_details.payments,\n+                        payouts: Some(existing_payouts_mandate),\n+                    }\n+                } else {\n+                    // Handle PaymentsMandateReference\n+                    let mut existing_payments_mandate = mandate_details\n+                        .payments\n+                        .unwrap_or_else(|| PaymentsMandateReference(HashMap::new()));\n+\n+                    // Check if record exists for this merchant_connector_id\n+                    if let Some(existing_record) =\n+                        existing_payments_mandate.0.get_mut(merchant_connector_id)\n+                    {\n+                        existing_record.connector_mandate_id =\n+                            payment_instrument_id.peek().to_string();\n+                    } else {\n+                        // Insert new record in connector_mandate_details\n+                        existing_payments_mandate.0.insert(\n+                            merchant_connector_id.clone(),\n+                            PaymentsMandateReferenceRecord {\n+                                connector_mandate_id: payment_instrument_id.peek().to_string(),\n+                                payment_method_type: None,\n+                                original_payment_authorized_amount: None,\n+                                original_payment_authorized_currency: None,\n+                                mandate_metadata: None,\n+                                connector_mandate_status: None,\n+                                connector_mandate_request_reference_id: None,\n+                            },\n+                        );\n+                    }",
        "comment_created_at": "2025-09-01T16:55:11+00:00",
        "comment_author": "kashif-m",
        "comment_body": "Writing it this way would be more clear -\r\n\r\n```suggestion\r\nmatch mca.connector_type {\r\n    enums::ConnectorType::PayoutProcessor => {\r\n        let mut existing_payouts_mandate = mandate_details\r\n            .payouts\r\n            .unwrap_or_else(|| PayoutsMandateReference(HashMap::new()));\r\n\r\n        if let Some(existing_record) = existing_payouts_mandate.0.get_mut(merchant_connector_id) {\r\n            existing_record.transfer_method_id =\r\n                Some(payment_instrument_id.peek().to_string());\r\n        } else {\r\n            existing_payouts_mandate.0.insert(\r\n                merchant_connector_id.clone(),\r\n                PayoutsMandateReferenceRecord {\r\n                    transfer_method_id: Some(payment_instrument_id.peek().to_string()),\r\n                },\r\n            );\r\n        }\r\n        mandate_details.payouts = Some(existing_payouts_mandate);\r\n    }\r\n\r\n    _ => {\r\n        let mut existing_payments_mandate = mandate_details\r\n            .payments\r\n            .unwrap_or_else(|| PaymentsMandateReference(HashMap::new()));\r\n\r\n        if let Some(existing_record) = existing_payments_mandate.0.get_mut(merchant_connector_id) {\r\n            existing_record.connector_mandate_id =\r\n                payment_instrument_id.peek().to_string();\r\n        } else {\r\n            existing_payments_mandate.0.insert(\r\n                merchant_connector_id.clone(),\r\n                PaymentsMandateReferenceRecord {\r\n                    connector_mandate_id: payment_instrument_id.peek().to_string(),\r\n                    payment_method_type: None,\r\n                    original_payment_authorized_amount: None,\r\n                    original_payment_authorized_currency: None,\r\n                    mandate_metadata: None,\r\n                    connector_mandate_status: None,\r\n                    connector_mandate_request_reference_id: None,\r\n                },\r\n            );\r\n        }\r\n        mandate_details.payments = Some(existing_payments_mandate);\r\n    }\r\n}\r\n```",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2293354796",
    "pr_number": 9031,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/worldpayvantiv.rs",
    "created_at": "2025-08-22T10:28:10+00:00",
    "commented_code": "fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n         Some(&WORLDPAYVANTIV_SUPPORTED_WEBHOOK_FLOWS)\n     }\n+    #[cfg(feature = \"v1\")]\n+    fn generate_connector_request_reference_id(\n+        &self,\n+        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n+        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n+        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n+    ) -> String {\n+        if is_config_enabled_to_send_payment_id_as_connector_request_id\n+            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n+        {\n+            payment_attempt.payment_id.get_string_repr().to_owned()\n+        } else {\n+            connector_utils::generate_12_digit_number().to_string()",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2293354796",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9031,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/worldpayvantiv.rs",
        "discussion_id": "2293354796",
        "commented_code": "@@ -1694,4 +1694,31 @@ impl ConnectorSpecifications for Worldpayvantiv {\n     fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n         Some(&WORLDPAYVANTIV_SUPPORTED_WEBHOOK_FLOWS)\n     }\n+    #[cfg(feature = \"v1\")]\n+    fn generate_connector_request_reference_id(\n+        &self,\n+        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n+        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n+        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n+    ) -> String {\n+        if is_config_enabled_to_send_payment_id_as_connector_request_id\n+            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n+        {\n+            payment_attempt.payment_id.get_string_repr().to_owned()\n+        } else {\n+            connector_utils::generate_12_digit_number().to_string()",
        "comment_created_at": "2025-08-22T10:28:10+00:00",
        "comment_author": "deepanshu-iiitu",
        "comment_body": "Make this 28",
        "pr_file_module": null
      },
      {
        "comment_id": "2293363439",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9031,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/worldpayvantiv.rs",
        "discussion_id": "2293354796",
        "commented_code": "@@ -1694,4 +1694,31 @@ impl ConnectorSpecifications for Worldpayvantiv {\n     fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n         Some(&WORLDPAYVANTIV_SUPPORTED_WEBHOOK_FLOWS)\n     }\n+    #[cfg(feature = \"v1\")]\n+    fn generate_connector_request_reference_id(\n+        &self,\n+        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n+        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n+        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n+    ) -> String {\n+        if is_config_enabled_to_send_payment_id_as_connector_request_id\n+            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n+        {\n+            payment_attempt.payment_id.get_string_repr().to_owned()\n+        } else {\n+            connector_utils::generate_12_digit_number().to_string()",
        "comment_created_at": "2025-08-22T10:32:09+00:00",
        "comment_author": "deepanshu-iiitu",
        "comment_body": "A new generic function to generate alphanumeric string of input length n",
        "pr_file_module": null
      },
      {
        "comment_id": "2293470412",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9031,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/worldpayvantiv.rs",
        "discussion_id": "2293354796",
        "commented_code": "@@ -1694,4 +1694,31 @@ impl ConnectorSpecifications for Worldpayvantiv {\n     fn get_supported_webhook_flows(&self) -> Option<&'static [common_enums::EventClass]> {\n         Some(&WORLDPAYVANTIV_SUPPORTED_WEBHOOK_FLOWS)\n     }\n+    #[cfg(feature = \"v1\")]\n+    fn generate_connector_request_reference_id(\n+        &self,\n+        payment_intent: &hyperswitch_domain_models::payments::PaymentIntent,\n+        payment_attempt: &hyperswitch_domain_models::payments::payment_attempt::PaymentAttempt,\n+        is_config_enabled_to_send_payment_id_as_connector_request_id: bool,\n+    ) -> String {\n+        if is_config_enabled_to_send_payment_id_as_connector_request_id\n+            && payment_intent.is_payment_id_from_merchant.unwrap_or(false)\n+        {\n+            payment_attempt.payment_id.get_string_repr().to_owned()\n+        } else {\n+            connector_utils::generate_12_digit_number().to_string()",
        "comment_created_at": "2025-08-22T11:28:05+00:00",
        "comment_author": "AkshayaFoiger",
        "comment_body": "Can I use a generic macro nanoid!() for the same",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2291026031",
    "pr_number": 8970,
    "pr_file": "crates/common_utils/src/ext_traits.rs",
    "created_at": "2025-08-21T13:13:17+00:00",
    "commented_code": "where\n         T: serde::de::DeserializeOwned,\n     {\n-        let debug = format!(\n-            \"Unable to parse {type_name} from serde_json::Value: {:?}\",\n-            &self\n-        );\n-        serde_json::from_value::<T>(self)\n+        serde_json::from_value::<T>(self.clone())",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2291026031",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8970,
        "pr_file": "crates/common_utils/src/ext_traits.rs",
        "discussion_id": "2291026031",
        "commented_code": "@@ -219,13 +233,15 @@ impl ValueExt for serde_json::Value {\n     where\n         T: serde::de::DeserializeOwned,\n     {\n-        let debug = format!(\n-            \"Unable to parse {type_name} from serde_json::Value: {:?}\",\n-            &self\n-        );\n-        serde_json::from_value::<T>(self)\n+        serde_json::from_value::<T>(self.clone())",
        "comment_created_at": "2025-08-21T13:13:17+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Is there an option for us to avoid the clone here and do the clone within the `attach_printable_lazy()` closure?",
        "pr_file_module": null
      },
      {
        "comment_id": "2292846898",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8970,
        "pr_file": "crates/common_utils/src/ext_traits.rs",
        "discussion_id": "2291026031",
        "commented_code": "@@ -219,13 +233,15 @@ impl ValueExt for serde_json::Value {\n     where\n         T: serde::de::DeserializeOwned,\n     {\n-        let debug = format!(\n-            \"Unable to parse {type_name} from serde_json::Value: {:?}\",\n-            &self\n-        );\n-        serde_json::from_value::<T>(self)\n+        serde_json::from_value::<T>(self.clone())",
        "comment_created_at": "2025-08-22T06:42:19+00:00",
        "comment_author": "AnuthaDev",
        "comment_body": "We could do a `T::deserialize(&self)`, but reading through the serde documentation, passing an owned value allows serde to use a previously allocated buffer. If we pass a reference it cannot do so, ultimately defeating the purpose of removing the clone.\r\n\r\nApart from this I couldn't really find a way.",
        "pr_file_module": null
      }
    ]
  }
]