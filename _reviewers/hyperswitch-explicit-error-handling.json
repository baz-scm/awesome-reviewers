[
  {
    "discussion_id": "2335636492",
    "pr_number": 9233,
    "pr_file": "crates/api_models/src/revenue_recovery_data_backfill.rs",
    "created_at": "2025-09-10T05:56:11+00:00",
    "commented_code": "+use std::{fs::File, io::BufReader};\n+\n+use actix_multipart::form::{tempfile::TempFile, MultipartForm};\n+use actix_web::{HttpResponse, ResponseError};\n+use common_utils::events::ApiEventMetric;\n+use csv::Reader;\n+use serde::{Deserialize, Serialize};\n+\n+#[derive(Debug, Deserialize, Serialize)]\n+pub struct RevenueRecoveryBackfillRequest {\n+    #[serde(rename = \"Binnumber\")]\n+    pub bin_number: String,\n+    #[serde(rename = \"Cardtype\")]\n+    pub card_type: String,\n+    #[serde(rename = \"CustomerID_resp\")]\n+    pub customer_id_resp: String,\n+    #[serde(rename = \"cnpTxnId\")]\n+    pub cnp_txn_id: String,\n+    #[serde(rename = \"Token\")]\n+    pub token: String,\n+    #[serde(rename = \"ExpiryDate\")]\n+    pub exp_date: String,\n+    #[serde(rename = \"CreditCardType.x\")]\n+    pub credit_card_type_x: String,\n+    #[serde(rename = \"type\")]\n+    pub type_field: String,\n+    #[serde(rename = \"product_name\")]\n+    pub product_name: String,\n+    #[serde(rename = \"clean_bank_name\")]\n+    pub clean_bank_name: String,\n+    #[serde(rename = \"country_name\")]\n+    pub country_name: String,\n+}\n+\n+#[derive(Debug, Serialize)]\n+pub struct PaymentMethodDataBackfillResponse {\n+    pub processed_records: usize,\n+    pub failed_records: usize,\n+}\n+\n+impl ApiEventMetric for PaymentMethodDataBackfillResponse {\n+    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> {\n+        Some(common_utils::events::ApiEventsType::Miscellaneous)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize)]\n+pub enum BackfillError {\n+    InvalidCardType(String),\n+    DatabaseError(String),\n+    RedisError(String),\n+    CsvParsingError(String),\n+    FileProcessingError(String),\n+}\n+\n+impl std::fmt::Display for BackfillError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Self::InvalidCardType(msg) => write!(f, \"Invalid card type: {}\", msg),\n+            Self::DatabaseError(msg) => write!(f, \"Database error: {}\", msg),\n+            Self::RedisError(msg) => write!(f, \"Redis error: {}\", msg),\n+            Self::CsvParsingError(msg) => write!(f, \"CSV parsing error: {}\", msg),\n+            Self::FileProcessingError(msg) => write!(f, \"File processing error: {}\", msg),\n+        }\n+    }\n+}\n+\n+impl std::error::Error for BackfillError {}\n+\n+impl ResponseError for BackfillError {\n+    fn error_response(&self) -> HttpResponse {\n+        HttpResponse::BadRequest().json(serde_json::json!({\n+            \"error\": self.to_string()\n+        }))\n+    }\n+}\n+\n+#[derive(Debug, MultipartForm)]\n+pub struct RevenueRecoveryDataBackfillForm {\n+    #[multipart(rename = \"file\")]\n+    pub file: TempFile,\n+}\n+\n+impl RevenueRecoveryDataBackfillForm {\n+    pub fn validate_and_get_records(\n+        &self,\n+    ) -> Result<Vec<RevenueRecoveryBackfillRequest>, BackfillError> {\n+        // Step 1: Open the file\n+        let file = File::open(self.file.file.path())\n+            .map_err(|e| BackfillError::FileProcessingError(e.to_string()))?;\n+\n+        let mut csv_reader = Reader::from_reader(BufReader::new(file));\n+\n+        // Step 2: Parse CSV into typed records\n+        let mut records = Vec::new();\n+        for record in csv_reader\n+            .deserialize::<RevenueRecoveryBackfillRequest>()\n+            .flatten()",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2335636492",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9233,
        "pr_file": "crates/api_models/src/revenue_recovery_data_backfill.rs",
        "discussion_id": "2335636492",
        "commented_code": "@@ -0,0 +1,105 @@\n+use std::{fs::File, io::BufReader};\n+\n+use actix_multipart::form::{tempfile::TempFile, MultipartForm};\n+use actix_web::{HttpResponse, ResponseError};\n+use common_utils::events::ApiEventMetric;\n+use csv::Reader;\n+use serde::{Deserialize, Serialize};\n+\n+#[derive(Debug, Deserialize, Serialize)]\n+pub struct RevenueRecoveryBackfillRequest {\n+    #[serde(rename = \"Binnumber\")]\n+    pub bin_number: String,\n+    #[serde(rename = \"Cardtype\")]\n+    pub card_type: String,\n+    #[serde(rename = \"CustomerID_resp\")]\n+    pub customer_id_resp: String,\n+    #[serde(rename = \"cnpTxnId\")]\n+    pub cnp_txn_id: String,\n+    #[serde(rename = \"Token\")]\n+    pub token: String,\n+    #[serde(rename = \"ExpiryDate\")]\n+    pub exp_date: String,\n+    #[serde(rename = \"CreditCardType.x\")]\n+    pub credit_card_type_x: String,\n+    #[serde(rename = \"type\")]\n+    pub type_field: String,\n+    #[serde(rename = \"product_name\")]\n+    pub product_name: String,\n+    #[serde(rename = \"clean_bank_name\")]\n+    pub clean_bank_name: String,\n+    #[serde(rename = \"country_name\")]\n+    pub country_name: String,\n+}\n+\n+#[derive(Debug, Serialize)]\n+pub struct PaymentMethodDataBackfillResponse {\n+    pub processed_records: usize,\n+    pub failed_records: usize,\n+}\n+\n+impl ApiEventMetric for PaymentMethodDataBackfillResponse {\n+    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> {\n+        Some(common_utils::events::ApiEventsType::Miscellaneous)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize)]\n+pub enum BackfillError {\n+    InvalidCardType(String),\n+    DatabaseError(String),\n+    RedisError(String),\n+    CsvParsingError(String),\n+    FileProcessingError(String),\n+}\n+\n+impl std::fmt::Display for BackfillError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Self::InvalidCardType(msg) => write!(f, \"Invalid card type: {}\", msg),\n+            Self::DatabaseError(msg) => write!(f, \"Database error: {}\", msg),\n+            Self::RedisError(msg) => write!(f, \"Redis error: {}\", msg),\n+            Self::CsvParsingError(msg) => write!(f, \"CSV parsing error: {}\", msg),\n+            Self::FileProcessingError(msg) => write!(f, \"File processing error: {}\", msg),\n+        }\n+    }\n+}\n+\n+impl std::error::Error for BackfillError {}\n+\n+impl ResponseError for BackfillError {\n+    fn error_response(&self) -> HttpResponse {\n+        HttpResponse::BadRequest().json(serde_json::json!({\n+            \"error\": self.to_string()\n+        }))\n+    }\n+}\n+\n+#[derive(Debug, MultipartForm)]\n+pub struct RevenueRecoveryDataBackfillForm {\n+    #[multipart(rename = \"file\")]\n+    pub file: TempFile,\n+}\n+\n+impl RevenueRecoveryDataBackfillForm {\n+    pub fn validate_and_get_records(\n+        &self,\n+    ) -> Result<Vec<RevenueRecoveryBackfillRequest>, BackfillError> {\n+        // Step 1: Open the file\n+        let file = File::open(self.file.file.path())\n+            .map_err(|e| BackfillError::FileProcessingError(e.to_string()))?;\n+\n+        let mut csv_reader = Reader::from_reader(BufReader::new(file));\n+\n+        // Step 2: Parse CSV into typed records\n+        let mut records = Vec::new();\n+        for record in csv_reader\n+            .deserialize::<RevenueRecoveryBackfillRequest>()\n+            .flatten()",
        "comment_created_at": "2025-09-10T05:56:11+00:00",
        "comment_author": "srujanchikke",
        "comment_body": "What happens when deserialization of one record fails ?\r\n",
        "pr_file_module": null
      },
      {
        "comment_id": "2336818347",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9233,
        "pr_file": "crates/api_models/src/revenue_recovery_data_backfill.rs",
        "discussion_id": "2335636492",
        "commented_code": "@@ -0,0 +1,105 @@\n+use std::{fs::File, io::BufReader};\n+\n+use actix_multipart::form::{tempfile::TempFile, MultipartForm};\n+use actix_web::{HttpResponse, ResponseError};\n+use common_utils::events::ApiEventMetric;\n+use csv::Reader;\n+use serde::{Deserialize, Serialize};\n+\n+#[derive(Debug, Deserialize, Serialize)]\n+pub struct RevenueRecoveryBackfillRequest {\n+    #[serde(rename = \"Binnumber\")]\n+    pub bin_number: String,\n+    #[serde(rename = \"Cardtype\")]\n+    pub card_type: String,\n+    #[serde(rename = \"CustomerID_resp\")]\n+    pub customer_id_resp: String,\n+    #[serde(rename = \"cnpTxnId\")]\n+    pub cnp_txn_id: String,\n+    #[serde(rename = \"Token\")]\n+    pub token: String,\n+    #[serde(rename = \"ExpiryDate\")]\n+    pub exp_date: String,\n+    #[serde(rename = \"CreditCardType.x\")]\n+    pub credit_card_type_x: String,\n+    #[serde(rename = \"type\")]\n+    pub type_field: String,\n+    #[serde(rename = \"product_name\")]\n+    pub product_name: String,\n+    #[serde(rename = \"clean_bank_name\")]\n+    pub clean_bank_name: String,\n+    #[serde(rename = \"country_name\")]\n+    pub country_name: String,\n+}\n+\n+#[derive(Debug, Serialize)]\n+pub struct PaymentMethodDataBackfillResponse {\n+    pub processed_records: usize,\n+    pub failed_records: usize,\n+}\n+\n+impl ApiEventMetric for PaymentMethodDataBackfillResponse {\n+    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> {\n+        Some(common_utils::events::ApiEventsType::Miscellaneous)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize)]\n+pub enum BackfillError {\n+    InvalidCardType(String),\n+    DatabaseError(String),\n+    RedisError(String),\n+    CsvParsingError(String),\n+    FileProcessingError(String),\n+}\n+\n+impl std::fmt::Display for BackfillError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Self::InvalidCardType(msg) => write!(f, \"Invalid card type: {}\", msg),\n+            Self::DatabaseError(msg) => write!(f, \"Database error: {}\", msg),\n+            Self::RedisError(msg) => write!(f, \"Redis error: {}\", msg),\n+            Self::CsvParsingError(msg) => write!(f, \"CSV parsing error: {}\", msg),\n+            Self::FileProcessingError(msg) => write!(f, \"File processing error: {}\", msg),\n+        }\n+    }\n+}\n+\n+impl std::error::Error for BackfillError {}\n+\n+impl ResponseError for BackfillError {\n+    fn error_response(&self) -> HttpResponse {\n+        HttpResponse::BadRequest().json(serde_json::json!({\n+            \"error\": self.to_string()\n+        }))\n+    }\n+}\n+\n+#[derive(Debug, MultipartForm)]\n+pub struct RevenueRecoveryDataBackfillForm {\n+    #[multipart(rename = \"file\")]\n+    pub file: TempFile,\n+}\n+\n+impl RevenueRecoveryDataBackfillForm {\n+    pub fn validate_and_get_records(\n+        &self,\n+    ) -> Result<Vec<RevenueRecoveryBackfillRequest>, BackfillError> {\n+        // Step 1: Open the file\n+        let file = File::open(self.file.file.path())\n+            .map_err(|e| BackfillError::FileProcessingError(e.to_string()))?;\n+\n+        let mut csv_reader = Reader::from_reader(BufReader::new(file));\n+\n+        // Step 2: Parse CSV into typed records\n+        let mut records = Vec::new();\n+        for record in csv_reader\n+            .deserialize::<RevenueRecoveryBackfillRequest>()\n+            .flatten()",
        "comment_created_at": "2025-09-10T13:44:02+00:00",
        "comment_author": "AdityaKumaar21",
        "comment_body": "if one record fails it will skip it and continue",
        "pr_file_module": null
      },
      {
        "comment_id": "2336893155",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9233,
        "pr_file": "crates/api_models/src/revenue_recovery_data_backfill.rs",
        "discussion_id": "2335636492",
        "commented_code": "@@ -0,0 +1,105 @@\n+use std::{fs::File, io::BufReader};\n+\n+use actix_multipart::form::{tempfile::TempFile, MultipartForm};\n+use actix_web::{HttpResponse, ResponseError};\n+use common_utils::events::ApiEventMetric;\n+use csv::Reader;\n+use serde::{Deserialize, Serialize};\n+\n+#[derive(Debug, Deserialize, Serialize)]\n+pub struct RevenueRecoveryBackfillRequest {\n+    #[serde(rename = \"Binnumber\")]\n+    pub bin_number: String,\n+    #[serde(rename = \"Cardtype\")]\n+    pub card_type: String,\n+    #[serde(rename = \"CustomerID_resp\")]\n+    pub customer_id_resp: String,\n+    #[serde(rename = \"cnpTxnId\")]\n+    pub cnp_txn_id: String,\n+    #[serde(rename = \"Token\")]\n+    pub token: String,\n+    #[serde(rename = \"ExpiryDate\")]\n+    pub exp_date: String,\n+    #[serde(rename = \"CreditCardType.x\")]\n+    pub credit_card_type_x: String,\n+    #[serde(rename = \"type\")]\n+    pub type_field: String,\n+    #[serde(rename = \"product_name\")]\n+    pub product_name: String,\n+    #[serde(rename = \"clean_bank_name\")]\n+    pub clean_bank_name: String,\n+    #[serde(rename = \"country_name\")]\n+    pub country_name: String,\n+}\n+\n+#[derive(Debug, Serialize)]\n+pub struct PaymentMethodDataBackfillResponse {\n+    pub processed_records: usize,\n+    pub failed_records: usize,\n+}\n+\n+impl ApiEventMetric for PaymentMethodDataBackfillResponse {\n+    fn get_api_event_type(&self) -> Option<common_utils::events::ApiEventsType> {\n+        Some(common_utils::events::ApiEventsType::Miscellaneous)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize)]\n+pub enum BackfillError {\n+    InvalidCardType(String),\n+    DatabaseError(String),\n+    RedisError(String),\n+    CsvParsingError(String),\n+    FileProcessingError(String),\n+}\n+\n+impl std::fmt::Display for BackfillError {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Self::InvalidCardType(msg) => write!(f, \"Invalid card type: {}\", msg),\n+            Self::DatabaseError(msg) => write!(f, \"Database error: {}\", msg),\n+            Self::RedisError(msg) => write!(f, \"Redis error: {}\", msg),\n+            Self::CsvParsingError(msg) => write!(f, \"CSV parsing error: {}\", msg),\n+            Self::FileProcessingError(msg) => write!(f, \"File processing error: {}\", msg),\n+        }\n+    }\n+}\n+\n+impl std::error::Error for BackfillError {}\n+\n+impl ResponseError for BackfillError {\n+    fn error_response(&self) -> HttpResponse {\n+        HttpResponse::BadRequest().json(serde_json::json!({\n+            \"error\": self.to_string()\n+        }))\n+    }\n+}\n+\n+#[derive(Debug, MultipartForm)]\n+pub struct RevenueRecoveryDataBackfillForm {\n+    #[multipart(rename = \"file\")]\n+    pub file: TempFile,\n+}\n+\n+impl RevenueRecoveryDataBackfillForm {\n+    pub fn validate_and_get_records(\n+        &self,\n+    ) -> Result<Vec<RevenueRecoveryBackfillRequest>, BackfillError> {\n+        // Step 1: Open the file\n+        let file = File::open(self.file.file.path())\n+            .map_err(|e| BackfillError::FileProcessingError(e.to_string()))?;\n+\n+        let mut csv_reader = Reader::from_reader(BufReader::new(file));\n+\n+        // Step 2: Parse CSV into typed records\n+        let mut records = Vec::new();\n+        for record in csv_reader\n+            .deserialize::<RevenueRecoveryBackfillRequest>()\n+            .flatten()",
        "comment_created_at": "2025-09-10T14:08:17+00:00",
        "comment_author": "srujanchikke",
        "comment_body": "shouldn't we log why that record is failing ?\r\n",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2290982657",
    "pr_number": 8705,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/trustpayments/transformers.rs",
    "created_at": "2025-08-21T12:57:33+00:00",
    "commented_code": "+use cards;\n use common_enums::enums;\n use common_utils::types::StringMinorUnit;\n+use error_stack::ResultExt;\n use hyperswitch_domain_models::{\n     payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n-    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n+    types::{\n+        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n+        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n+    },\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{ExposeInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::{self, RefundsRequestData, RouterData as RouterDataExt},\n+};\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsSettleStatus {\n+    #[serde(rename = \"0\")]\n+    PendingSettlement,\n+    #[serde(rename = \"1\")]\n+    Settled,\n+    #[serde(rename = \"2\")]\n+    SettlementFailed,\n+    #[serde(rename = \"3\")]\n+    Voided,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsCredentialsOnFile {\n+    #[serde(rename = \"0\")]\n+    NoStoredCredentials,\n+    #[serde(rename = \"1\")]\n+    CardholderInitiatedTransaction,\n+    #[serde(rename = \"2\")]\n+    MerchantInitiatedTransaction,\n+}\n+\n+impl TrustpaymentsCredentialsOnFile {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::NoStoredCredentials => \"0\",\n+            Self::CardholderInitiatedTransaction => \"1\",\n+            Self::MerchantInitiatedTransaction => \"2\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+impl TrustpaymentsSettleStatus {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::PendingSettlement => \"0\",\n+            Self::Settled => \"1\",\n+            Self::SettlementFailed => \"2\",\n+            Self::Voided => \"3\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsSettleStatus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsErrorCode {\n+    #[serde(rename = \"0\")]\n+    Success,\n+\n+    #[serde(rename = \"30000\")]\n+    InvalidCredentials,\n+    #[serde(rename = \"30001\")]\n+    AuthenticationFailed,\n+    #[serde(rename = \"30002\")]\n+    InvalidSiteReference,\n+    #[serde(rename = \"30003\")]\n+    AccessDenied,\n+    #[serde(rename = \"30004\")]\n+    InvalidUsernameOrPassword,\n+    #[serde(rename = \"30005\")]\n+    AccountSuspended,\n+    #[serde(rename = \"50000\")]\n+    MissingRequiredField,\n+    #[serde(rename = \"50001\")]\n+    InvalidFieldFormat,\n+    #[serde(rename = \"50002\")]\n+    InvalidFieldValue,\n+    #[serde(rename = \"50003\")]\n+    FieldTooLong,\n+    #[serde(rename = \"50004\")]\n+    FieldTooShort,\n+    #[serde(rename = \"50005\")]\n+    InvalidCurrency,\n+    #[serde(rename = \"50006\")]\n+    InvalidAmount,\n+    #[serde(rename = \"60000\")]\n+    GeneralProcessingError,\n+    #[serde(rename = \"60001\")]\n+    SystemError,\n+    #[serde(rename = \"60002\")]\n+    CommunicationError,\n+    #[serde(rename = \"60003\")]\n+    Timeout,\n+    #[serde(rename = \"60004\")]\n+    Processing,\n+    #[serde(rename = \"60005\")]\n+    InvalidRequest,\n+    #[serde(rename = \"60019\")]\n+    NoSearchableFilter,\n+    #[serde(rename = \"70000\")]\n+    InvalidCardNumber,\n+    #[serde(rename = \"70001\")]\n+    InvalidExpiryDate,\n+    #[serde(rename = \"70002\")]\n+    InvalidSecurityCode,\n+    #[serde(rename = \"70003\")]\n+    InvalidCardType,\n+    #[serde(rename = \"70004\")]\n+    CardExpired,\n+    #[serde(rename = \"70005\")]\n+    InsufficientFunds,\n+    #[serde(rename = \"70006\")]\n+    CardDeclined,\n+    #[serde(rename = \"70007\")]\n+    CardRestricted,\n+    #[serde(rename = \"70008\")]\n+    InvalidMerchant,\n+    #[serde(rename = \"70009\")]\n+    TransactionNotPermitted,\n+    #[serde(rename = \"70010\")]\n+    ExceedsWithdrawalLimit,\n+    #[serde(rename = \"70011\")]\n+    SecurityViolation,\n+    #[serde(rename = \"70012\")]\n+    LostOrStolenCard,\n+    #[serde(rename = \"70013\")]\n+    SuspectedFraud,\n+    #[serde(rename = \"70014\")]\n+    ContactCardIssuer,\n+    #[serde(rename = \"70015\")]\n+    InvalidAmountValue,\n+    #[serde(untagged)]\n+    Unknown(String),\n+}\n+\n+impl TrustpaymentsErrorCode {\n+    pub fn as_str(&self) -> &str {\n+        match self {\n+            Self::Success => \"0\",\n+            Self::InvalidCredentials => \"30000\",\n+            Self::AuthenticationFailed => \"30001\",\n+            Self::InvalidSiteReference => \"30002\",\n+            Self::AccessDenied => \"30003\",\n+            Self::InvalidUsernameOrPassword => \"30004\",\n+            Self::AccountSuspended => \"30005\",\n+            Self::MissingRequiredField => \"50000\",\n+            Self::InvalidFieldFormat => \"50001\",\n+            Self::InvalidFieldValue => \"50002\",\n+            Self::FieldTooLong => \"50003\",\n+            Self::FieldTooShort => \"50004\",\n+            Self::InvalidCurrency => \"50005\",\n+            Self::InvalidAmount => \"50006\",\n+            Self::GeneralProcessingError => \"60000\",\n+            Self::SystemError => \"60001\",\n+            Self::CommunicationError => \"60002\",\n+            Self::Timeout => \"60003\",\n+            Self::Processing => \"60004\",\n+            Self::InvalidRequest => \"60005\",\n+            Self::NoSearchableFilter => \"60019\",\n+            Self::InvalidCardNumber => \"70000\",\n+            Self::InvalidExpiryDate => \"70001\",\n+            Self::InvalidSecurityCode => \"70002\",\n+            Self::InvalidCardType => \"70003\",\n+            Self::CardExpired => \"70004\",\n+            Self::InsufficientFunds => \"70005\",\n+            Self::CardDeclined => \"70006\",\n+            Self::CardRestricted => \"70007\",\n+            Self::InvalidMerchant => \"70008\",\n+            Self::TransactionNotPermitted => \"70009\",\n+            Self::ExceedsWithdrawalLimit => \"70010\",\n+            Self::SecurityViolation => \"70011\",\n+            Self::LostOrStolenCard => \"70012\",\n+            Self::SuspectedFraud => \"70013\",\n+            Self::ContactCardIssuer => \"70014\",\n+            Self::InvalidAmountValue => \"70015\",\n+            Self::Unknown(code) => code,\n+        }\n+    }\n+\n+    pub fn is_success(&self) -> bool {\n+        matches!(self, Self::Success)\n+    }\n+\n+    pub fn get_attempt_status(\n+        &self,\n+        capture_method: Option<common_enums::CaptureMethod>,\n+    ) -> common_enums::AttemptStatus {\n+        match self {\n+            Self::Success => match capture_method {\n+                Some(common_enums::CaptureMethod::Manual) => {\n+                    common_enums::AttemptStatus::Authorized\n+                }\n+                _ => common_enums::AttemptStatus::Charged,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2290982657",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8705,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/trustpayments/transformers.rs",
        "discussion_id": "2290982657",
        "commented_code": "@@ -1,49 +1,318 @@\n+use cards;\n use common_enums::enums;\n use common_utils::types::StringMinorUnit;\n+use error_stack::ResultExt;\n use hyperswitch_domain_models::{\n     payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n-    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n+    types::{\n+        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n+        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n+    },\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{ExposeInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::{self, RefundsRequestData, RouterData as RouterDataExt},\n+};\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsSettleStatus {\n+    #[serde(rename = \"0\")]\n+    PendingSettlement,\n+    #[serde(rename = \"1\")]\n+    Settled,\n+    #[serde(rename = \"2\")]\n+    SettlementFailed,\n+    #[serde(rename = \"3\")]\n+    Voided,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsCredentialsOnFile {\n+    #[serde(rename = \"0\")]\n+    NoStoredCredentials,\n+    #[serde(rename = \"1\")]\n+    CardholderInitiatedTransaction,\n+    #[serde(rename = \"2\")]\n+    MerchantInitiatedTransaction,\n+}\n+\n+impl TrustpaymentsCredentialsOnFile {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::NoStoredCredentials => \"0\",\n+            Self::CardholderInitiatedTransaction => \"1\",\n+            Self::MerchantInitiatedTransaction => \"2\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+impl TrustpaymentsSettleStatus {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::PendingSettlement => \"0\",\n+            Self::Settled => \"1\",\n+            Self::SettlementFailed => \"2\",\n+            Self::Voided => \"3\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsSettleStatus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsErrorCode {\n+    #[serde(rename = \"0\")]\n+    Success,\n+\n+    #[serde(rename = \"30000\")]\n+    InvalidCredentials,\n+    #[serde(rename = \"30001\")]\n+    AuthenticationFailed,\n+    #[serde(rename = \"30002\")]\n+    InvalidSiteReference,\n+    #[serde(rename = \"30003\")]\n+    AccessDenied,\n+    #[serde(rename = \"30004\")]\n+    InvalidUsernameOrPassword,\n+    #[serde(rename = \"30005\")]\n+    AccountSuspended,\n+    #[serde(rename = \"50000\")]\n+    MissingRequiredField,\n+    #[serde(rename = \"50001\")]\n+    InvalidFieldFormat,\n+    #[serde(rename = \"50002\")]\n+    InvalidFieldValue,\n+    #[serde(rename = \"50003\")]\n+    FieldTooLong,\n+    #[serde(rename = \"50004\")]\n+    FieldTooShort,\n+    #[serde(rename = \"50005\")]\n+    InvalidCurrency,\n+    #[serde(rename = \"50006\")]\n+    InvalidAmount,\n+    #[serde(rename = \"60000\")]\n+    GeneralProcessingError,\n+    #[serde(rename = \"60001\")]\n+    SystemError,\n+    #[serde(rename = \"60002\")]\n+    CommunicationError,\n+    #[serde(rename = \"60003\")]\n+    Timeout,\n+    #[serde(rename = \"60004\")]\n+    Processing,\n+    #[serde(rename = \"60005\")]\n+    InvalidRequest,\n+    #[serde(rename = \"60019\")]\n+    NoSearchableFilter,\n+    #[serde(rename = \"70000\")]\n+    InvalidCardNumber,\n+    #[serde(rename = \"70001\")]\n+    InvalidExpiryDate,\n+    #[serde(rename = \"70002\")]\n+    InvalidSecurityCode,\n+    #[serde(rename = \"70003\")]\n+    InvalidCardType,\n+    #[serde(rename = \"70004\")]\n+    CardExpired,\n+    #[serde(rename = \"70005\")]\n+    InsufficientFunds,\n+    #[serde(rename = \"70006\")]\n+    CardDeclined,\n+    #[serde(rename = \"70007\")]\n+    CardRestricted,\n+    #[serde(rename = \"70008\")]\n+    InvalidMerchant,\n+    #[serde(rename = \"70009\")]\n+    TransactionNotPermitted,\n+    #[serde(rename = \"70010\")]\n+    ExceedsWithdrawalLimit,\n+    #[serde(rename = \"70011\")]\n+    SecurityViolation,\n+    #[serde(rename = \"70012\")]\n+    LostOrStolenCard,\n+    #[serde(rename = \"70013\")]\n+    SuspectedFraud,\n+    #[serde(rename = \"70014\")]\n+    ContactCardIssuer,\n+    #[serde(rename = \"70015\")]\n+    InvalidAmountValue,\n+    #[serde(untagged)]\n+    Unknown(String),\n+}\n+\n+impl TrustpaymentsErrorCode {\n+    pub fn as_str(&self) -> &str {\n+        match self {\n+            Self::Success => \"0\",\n+            Self::InvalidCredentials => \"30000\",\n+            Self::AuthenticationFailed => \"30001\",\n+            Self::InvalidSiteReference => \"30002\",\n+            Self::AccessDenied => \"30003\",\n+            Self::InvalidUsernameOrPassword => \"30004\",\n+            Self::AccountSuspended => \"30005\",\n+            Self::MissingRequiredField => \"50000\",\n+            Self::InvalidFieldFormat => \"50001\",\n+            Self::InvalidFieldValue => \"50002\",\n+            Self::FieldTooLong => \"50003\",\n+            Self::FieldTooShort => \"50004\",\n+            Self::InvalidCurrency => \"50005\",\n+            Self::InvalidAmount => \"50006\",\n+            Self::GeneralProcessingError => \"60000\",\n+            Self::SystemError => \"60001\",\n+            Self::CommunicationError => \"60002\",\n+            Self::Timeout => \"60003\",\n+            Self::Processing => \"60004\",\n+            Self::InvalidRequest => \"60005\",\n+            Self::NoSearchableFilter => \"60019\",\n+            Self::InvalidCardNumber => \"70000\",\n+            Self::InvalidExpiryDate => \"70001\",\n+            Self::InvalidSecurityCode => \"70002\",\n+            Self::InvalidCardType => \"70003\",\n+            Self::CardExpired => \"70004\",\n+            Self::InsufficientFunds => \"70005\",\n+            Self::CardDeclined => \"70006\",\n+            Self::CardRestricted => \"70007\",\n+            Self::InvalidMerchant => \"70008\",\n+            Self::TransactionNotPermitted => \"70009\",\n+            Self::ExceedsWithdrawalLimit => \"70010\",\n+            Self::SecurityViolation => \"70011\",\n+            Self::LostOrStolenCard => \"70012\",\n+            Self::SuspectedFraud => \"70013\",\n+            Self::ContactCardIssuer => \"70014\",\n+            Self::InvalidAmountValue => \"70015\",\n+            Self::Unknown(code) => code,\n+        }\n+    }\n+\n+    pub fn is_success(&self) -> bool {\n+        matches!(self, Self::Success)\n+    }\n+\n+    pub fn get_attempt_status(\n+        &self,\n+        capture_method: Option<common_enums::CaptureMethod>,\n+    ) -> common_enums::AttemptStatus {\n+        match self {\n+            Self::Success => match capture_method {\n+                Some(common_enums::CaptureMethod::Manual) => {\n+                    common_enums::AttemptStatus::Authorized\n+                }\n+                _ => common_enums::AttemptStatus::Charged,",
        "comment_created_at": "2025-08-21T12:57:33+00:00",
        "comment_author": "swangi-kumari",
        "comment_body": "Only AttemptStatus::Automatic should be charged here.\r\n\r\nWe should not use _=>\r\n_=> means (ManualMultiple,Scheduled SequentialAutomatic, and Automatic) \r\nall these should not be charged, \r\n\r\nIf connector supports this method then map it accordingly and for the capture method which connector does not support we should throw error. ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2290984001",
    "pr_number": 8705,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/trustpayments/transformers.rs",
    "created_at": "2025-08-21T12:58:06+00:00",
    "commented_code": "+use cards;\n use common_enums::enums;\n use common_utils::types::StringMinorUnit;\n+use error_stack::ResultExt;\n use hyperswitch_domain_models::{\n     payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n-    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n+    types::{\n+        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n+        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n+    },\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{ExposeInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::{self, RefundsRequestData, RouterData as RouterDataExt},\n+};\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsSettleStatus {\n+    #[serde(rename = \"0\")]\n+    PendingSettlement,\n+    #[serde(rename = \"1\")]\n+    Settled,\n+    #[serde(rename = \"2\")]\n+    SettlementFailed,\n+    #[serde(rename = \"3\")]\n+    Voided,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsCredentialsOnFile {\n+    #[serde(rename = \"0\")]\n+    NoStoredCredentials,\n+    #[serde(rename = \"1\")]\n+    CardholderInitiatedTransaction,\n+    #[serde(rename = \"2\")]\n+    MerchantInitiatedTransaction,\n+}\n+\n+impl TrustpaymentsCredentialsOnFile {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::NoStoredCredentials => \"0\",\n+            Self::CardholderInitiatedTransaction => \"1\",\n+            Self::MerchantInitiatedTransaction => \"2\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+impl TrustpaymentsSettleStatus {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::PendingSettlement => \"0\",\n+            Self::Settled => \"1\",\n+            Self::SettlementFailed => \"2\",\n+            Self::Voided => \"3\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsSettleStatus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsErrorCode {\n+    #[serde(rename = \"0\")]\n+    Success,\n+\n+    #[serde(rename = \"30000\")]\n+    InvalidCredentials,\n+    #[serde(rename = \"30001\")]\n+    AuthenticationFailed,\n+    #[serde(rename = \"30002\")]\n+    InvalidSiteReference,\n+    #[serde(rename = \"30003\")]\n+    AccessDenied,\n+    #[serde(rename = \"30004\")]\n+    InvalidUsernameOrPassword,\n+    #[serde(rename = \"30005\")]\n+    AccountSuspended,\n+    #[serde(rename = \"50000\")]\n+    MissingRequiredField,\n+    #[serde(rename = \"50001\")]\n+    InvalidFieldFormat,\n+    #[serde(rename = \"50002\")]\n+    InvalidFieldValue,\n+    #[serde(rename = \"50003\")]\n+    FieldTooLong,\n+    #[serde(rename = \"50004\")]\n+    FieldTooShort,\n+    #[serde(rename = \"50005\")]\n+    InvalidCurrency,\n+    #[serde(rename = \"50006\")]\n+    InvalidAmount,\n+    #[serde(rename = \"60000\")]\n+    GeneralProcessingError,\n+    #[serde(rename = \"60001\")]\n+    SystemError,\n+    #[serde(rename = \"60002\")]\n+    CommunicationError,\n+    #[serde(rename = \"60003\")]\n+    Timeout,\n+    #[serde(rename = \"60004\")]\n+    Processing,\n+    #[serde(rename = \"60005\")]\n+    InvalidRequest,\n+    #[serde(rename = \"60019\")]\n+    NoSearchableFilter,\n+    #[serde(rename = \"70000\")]\n+    InvalidCardNumber,\n+    #[serde(rename = \"70001\")]\n+    InvalidExpiryDate,\n+    #[serde(rename = \"70002\")]\n+    InvalidSecurityCode,\n+    #[serde(rename = \"70003\")]\n+    InvalidCardType,\n+    #[serde(rename = \"70004\")]\n+    CardExpired,\n+    #[serde(rename = \"70005\")]\n+    InsufficientFunds,\n+    #[serde(rename = \"70006\")]\n+    CardDeclined,\n+    #[serde(rename = \"70007\")]\n+    CardRestricted,\n+    #[serde(rename = \"70008\")]\n+    InvalidMerchant,\n+    #[serde(rename = \"70009\")]\n+    TransactionNotPermitted,\n+    #[serde(rename = \"70010\")]\n+    ExceedsWithdrawalLimit,\n+    #[serde(rename = \"70011\")]\n+    SecurityViolation,\n+    #[serde(rename = \"70012\")]\n+    LostOrStolenCard,\n+    #[serde(rename = \"70013\")]\n+    SuspectedFraud,\n+    #[serde(rename = \"70014\")]\n+    ContactCardIssuer,\n+    #[serde(rename = \"70015\")]\n+    InvalidAmountValue,\n+    #[serde(untagged)]\n+    Unknown(String),\n+}\n+\n+impl TrustpaymentsErrorCode {\n+    pub fn as_str(&self) -> &str {\n+        match self {\n+            Self::Success => \"0\",\n+            Self::InvalidCredentials => \"30000\",\n+            Self::AuthenticationFailed => \"30001\",\n+            Self::InvalidSiteReference => \"30002\",\n+            Self::AccessDenied => \"30003\",\n+            Self::InvalidUsernameOrPassword => \"30004\",\n+            Self::AccountSuspended => \"30005\",\n+            Self::MissingRequiredField => \"50000\",\n+            Self::InvalidFieldFormat => \"50001\",\n+            Self::InvalidFieldValue => \"50002\",\n+            Self::FieldTooLong => \"50003\",\n+            Self::FieldTooShort => \"50004\",\n+            Self::InvalidCurrency => \"50005\",\n+            Self::InvalidAmount => \"50006\",\n+            Self::GeneralProcessingError => \"60000\",\n+            Self::SystemError => \"60001\",\n+            Self::CommunicationError => \"60002\",\n+            Self::Timeout => \"60003\",\n+            Self::Processing => \"60004\",\n+            Self::InvalidRequest => \"60005\",\n+            Self::NoSearchableFilter => \"60019\",\n+            Self::InvalidCardNumber => \"70000\",\n+            Self::InvalidExpiryDate => \"70001\",\n+            Self::InvalidSecurityCode => \"70002\",\n+            Self::InvalidCardType => \"70003\",\n+            Self::CardExpired => \"70004\",\n+            Self::InsufficientFunds => \"70005\",\n+            Self::CardDeclined => \"70006\",\n+            Self::CardRestricted => \"70007\",\n+            Self::InvalidMerchant => \"70008\",\n+            Self::TransactionNotPermitted => \"70009\",\n+            Self::ExceedsWithdrawalLimit => \"70010\",\n+            Self::SecurityViolation => \"70011\",\n+            Self::LostOrStolenCard => \"70012\",\n+            Self::SuspectedFraud => \"70013\",\n+            Self::ContactCardIssuer => \"70014\",\n+            Self::InvalidAmountValue => \"70015\",\n+            Self::Unknown(code) => code,\n+        }\n+    }\n+\n+    pub fn is_success(&self) -> bool {\n+        matches!(self, Self::Success)\n+    }\n+\n+    pub fn get_attempt_status(\n+        &self,\n+        capture_method: Option<common_enums::CaptureMethod>,\n+    ) -> common_enums::AttemptStatus {\n+        match self {\n+            Self::Success => match capture_method {\n+                Some(common_enums::CaptureMethod::Manual) => {\n+                    common_enums::AttemptStatus::Authorized\n+                }\n+                _ => common_enums::AttemptStatus::Charged,\n+            },\n+            Self::InvalidCredentials\n+            | Self::AuthenticationFailed\n+            | Self::InvalidSiteReference\n+            | Self::AccessDenied\n+            | Self::InvalidUsernameOrPassword\n+            | Self::AccountSuspended => common_enums::AttemptStatus::Failure,\n+            Self::Processing => common_enums::AttemptStatus::Pending,\n+            _ => common_enums::AttemptStatus::Failure,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2290984001",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8705,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/trustpayments/transformers.rs",
        "discussion_id": "2290984001",
        "commented_code": "@@ -1,49 +1,318 @@\n+use cards;\n use common_enums::enums;\n use common_utils::types::StringMinorUnit;\n+use error_stack::ResultExt;\n use hyperswitch_domain_models::{\n     payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n-    types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n+    types::{\n+        PaymentsAuthorizeRouterData, PaymentsCancelRouterData, PaymentsCaptureRouterData,\n+        PaymentsSyncRouterData, RefundSyncRouterData, RefundsRouterData,\n+    },\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{ExposeInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n+use crate::{\n+    types::{RefundsResponseRouterData, ResponseRouterData},\n+    utils::{self, RefundsRequestData, RouterData as RouterDataExt},\n+};\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsSettleStatus {\n+    #[serde(rename = \"0\")]\n+    PendingSettlement,\n+    #[serde(rename = \"1\")]\n+    Settled,\n+    #[serde(rename = \"2\")]\n+    SettlementFailed,\n+    #[serde(rename = \"3\")]\n+    Voided,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsCredentialsOnFile {\n+    #[serde(rename = \"0\")]\n+    NoStoredCredentials,\n+    #[serde(rename = \"1\")]\n+    CardholderInitiatedTransaction,\n+    #[serde(rename = \"2\")]\n+    MerchantInitiatedTransaction,\n+}\n+\n+impl TrustpaymentsCredentialsOnFile {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::NoStoredCredentials => \"0\",\n+            Self::CardholderInitiatedTransaction => \"1\",\n+            Self::MerchantInitiatedTransaction => \"2\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsCredentialsOnFile {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+impl TrustpaymentsSettleStatus {\n+    pub fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::PendingSettlement => \"0\",\n+            Self::Settled => \"1\",\n+            Self::SettlementFailed => \"2\",\n+            Self::Voided => \"3\",\n+        }\n+    }\n+}\n+\n+impl std::fmt::Display for TrustpaymentsSettleStatus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.as_str())\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]\n+pub enum TrustpaymentsErrorCode {\n+    #[serde(rename = \"0\")]\n+    Success,\n+\n+    #[serde(rename = \"30000\")]\n+    InvalidCredentials,\n+    #[serde(rename = \"30001\")]\n+    AuthenticationFailed,\n+    #[serde(rename = \"30002\")]\n+    InvalidSiteReference,\n+    #[serde(rename = \"30003\")]\n+    AccessDenied,\n+    #[serde(rename = \"30004\")]\n+    InvalidUsernameOrPassword,\n+    #[serde(rename = \"30005\")]\n+    AccountSuspended,\n+    #[serde(rename = \"50000\")]\n+    MissingRequiredField,\n+    #[serde(rename = \"50001\")]\n+    InvalidFieldFormat,\n+    #[serde(rename = \"50002\")]\n+    InvalidFieldValue,\n+    #[serde(rename = \"50003\")]\n+    FieldTooLong,\n+    #[serde(rename = \"50004\")]\n+    FieldTooShort,\n+    #[serde(rename = \"50005\")]\n+    InvalidCurrency,\n+    #[serde(rename = \"50006\")]\n+    InvalidAmount,\n+    #[serde(rename = \"60000\")]\n+    GeneralProcessingError,\n+    #[serde(rename = \"60001\")]\n+    SystemError,\n+    #[serde(rename = \"60002\")]\n+    CommunicationError,\n+    #[serde(rename = \"60003\")]\n+    Timeout,\n+    #[serde(rename = \"60004\")]\n+    Processing,\n+    #[serde(rename = \"60005\")]\n+    InvalidRequest,\n+    #[serde(rename = \"60019\")]\n+    NoSearchableFilter,\n+    #[serde(rename = \"70000\")]\n+    InvalidCardNumber,\n+    #[serde(rename = \"70001\")]\n+    InvalidExpiryDate,\n+    #[serde(rename = \"70002\")]\n+    InvalidSecurityCode,\n+    #[serde(rename = \"70003\")]\n+    InvalidCardType,\n+    #[serde(rename = \"70004\")]\n+    CardExpired,\n+    #[serde(rename = \"70005\")]\n+    InsufficientFunds,\n+    #[serde(rename = \"70006\")]\n+    CardDeclined,\n+    #[serde(rename = \"70007\")]\n+    CardRestricted,\n+    #[serde(rename = \"70008\")]\n+    InvalidMerchant,\n+    #[serde(rename = \"70009\")]\n+    TransactionNotPermitted,\n+    #[serde(rename = \"70010\")]\n+    ExceedsWithdrawalLimit,\n+    #[serde(rename = \"70011\")]\n+    SecurityViolation,\n+    #[serde(rename = \"70012\")]\n+    LostOrStolenCard,\n+    #[serde(rename = \"70013\")]\n+    SuspectedFraud,\n+    #[serde(rename = \"70014\")]\n+    ContactCardIssuer,\n+    #[serde(rename = \"70015\")]\n+    InvalidAmountValue,\n+    #[serde(untagged)]\n+    Unknown(String),\n+}\n+\n+impl TrustpaymentsErrorCode {\n+    pub fn as_str(&self) -> &str {\n+        match self {\n+            Self::Success => \"0\",\n+            Self::InvalidCredentials => \"30000\",\n+            Self::AuthenticationFailed => \"30001\",\n+            Self::InvalidSiteReference => \"30002\",\n+            Self::AccessDenied => \"30003\",\n+            Self::InvalidUsernameOrPassword => \"30004\",\n+            Self::AccountSuspended => \"30005\",\n+            Self::MissingRequiredField => \"50000\",\n+            Self::InvalidFieldFormat => \"50001\",\n+            Self::InvalidFieldValue => \"50002\",\n+            Self::FieldTooLong => \"50003\",\n+            Self::FieldTooShort => \"50004\",\n+            Self::InvalidCurrency => \"50005\",\n+            Self::InvalidAmount => \"50006\",\n+            Self::GeneralProcessingError => \"60000\",\n+            Self::SystemError => \"60001\",\n+            Self::CommunicationError => \"60002\",\n+            Self::Timeout => \"60003\",\n+            Self::Processing => \"60004\",\n+            Self::InvalidRequest => \"60005\",\n+            Self::NoSearchableFilter => \"60019\",\n+            Self::InvalidCardNumber => \"70000\",\n+            Self::InvalidExpiryDate => \"70001\",\n+            Self::InvalidSecurityCode => \"70002\",\n+            Self::InvalidCardType => \"70003\",\n+            Self::CardExpired => \"70004\",\n+            Self::InsufficientFunds => \"70005\",\n+            Self::CardDeclined => \"70006\",\n+            Self::CardRestricted => \"70007\",\n+            Self::InvalidMerchant => \"70008\",\n+            Self::TransactionNotPermitted => \"70009\",\n+            Self::ExceedsWithdrawalLimit => \"70010\",\n+            Self::SecurityViolation => \"70011\",\n+            Self::LostOrStolenCard => \"70012\",\n+            Self::SuspectedFraud => \"70013\",\n+            Self::ContactCardIssuer => \"70014\",\n+            Self::InvalidAmountValue => \"70015\",\n+            Self::Unknown(code) => code,\n+        }\n+    }\n+\n+    pub fn is_success(&self) -> bool {\n+        matches!(self, Self::Success)\n+    }\n+\n+    pub fn get_attempt_status(\n+        &self,\n+        capture_method: Option<common_enums::CaptureMethod>,\n+    ) -> common_enums::AttemptStatus {\n+        match self {\n+            Self::Success => match capture_method {\n+                Some(common_enums::CaptureMethod::Manual) => {\n+                    common_enums::AttemptStatus::Authorized\n+                }\n+                _ => common_enums::AttemptStatus::Charged,\n+            },\n+            Self::InvalidCredentials\n+            | Self::AuthenticationFailed\n+            | Self::InvalidSiteReference\n+            | Self::AccessDenied\n+            | Self::InvalidUsernameOrPassword\n+            | Self::AccountSuspended => common_enums::AttemptStatus::Failure,\n+            Self::Processing => common_enums::AttemptStatus::Pending,\n+            _ => common_enums::AttemptStatus::Failure,",
        "comment_created_at": "2025-08-21T12:58:06+00:00",
        "comment_author": "swangi-kumari",
        "comment_body": "Default should not be mapped to failure, it should be pending ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2291007404",
    "pr_number": 8705,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/trustpayments/transformers.rs",
    "created_at": "2025-08-21T13:06:54+00:00",
    "commented_code": "fn try_from(\n         item: &TrustpaymentsRouterData<&PaymentsAuthorizeRouterData>,\n     ) -> Result<Self, Self::Error> {\n+        let auth = TrustpaymentsAuthType::try_from(&item.router_data.connector_auth_type)?;\n+\n+        if matches!(\n+            item.router_data.auth_type,\n+            enums::AuthenticationType::ThreeDs\n+        ) {\n+            return Err(errors::ConnectorError::NotImplemented(\n+                utils::get_unimplemented_payment_method_error_message(\"trustpayments\"),\n+            )\n+            .into());\n+        }\n+\n         match item.router_data.request.payment_method_data.clone() {\n-            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n-                \"Card payment method not implemented\".to_string(),\n+            PaymentMethodData::Card(req_card) => {\n+                let card = req_card.clone();\n+\n+                let request_types = match item.router_data.request.capture_method {\n+                    Some(common_enums::CaptureMethod::Automatic) | None => vec![\"AUTH\".to_string()],\n+                    Some(common_enums::CaptureMethod::Manual) => vec![\"AUTH\".to_string()],\n+                    Some(common_enums::CaptureMethod::ManualMultiple)\n+                    | Some(common_enums::CaptureMethod::Scheduled)\n+                    | Some(common_enums::CaptureMethod::SequentialAutomatic) => {\n+                        return Err(errors::ConnectorError::NotSupported {\n+                            message: \"Capture method not supported by TrustPayments\".to_string(),\n+                            connector: \"TrustPayments\",\n+                        }\n+                        .into());\n+                    }\n+                };\n+\n+                Ok(Self {\n+                    alias: auth.username.expose(),\n+                    version: \"1.00\".to_string(),\n+                    request: vec![TrustpaymentsPaymentRequestData {\n+                        accounttypedescription: \"ECOM\".to_string(),\n+                        baseamount: item.amount.to_string(),\n+                        billingfirstname: item\n+                            .router_data\n+                            .get_optional_billing_first_name()\n+                            .map(|name| name.expose()),\n+                        billinglastname: item\n+                            .router_data\n+                            .get_optional_billing_last_name()\n+                            .map(|name| name.expose()),\n+                        currencyiso3a: item.router_data.request.currency.to_string(),\n+                        expirydate: Secret::new(format!(\n+                            \"{:02}/{:02}\",\n+                            card.card_exp_month.clone().expose(),\n+                            card.card_exp_year.clone().expose()\n+                        )),\n+                        orderreference: item.router_data.connector_request_reference_id.clone(),\n+                        pan: card.card_number.clone(),\n+                        requesttypedescriptions: request_types,\n+                        securitycode: card.card_cvc.clone(),\n+                        sitereference: auth.site_reference.expose(),\n+                        credentialsonfile:\n+                            TrustpaymentsCredentialsOnFile::CardholderInitiatedTransaction\n+                                .to_string(),\n+                    }],\n+                })\n+            }\n+            _ => Err(errors::ConnectorError::NotImplemented(\n+                \"Payment method not supported\".to_string(),\n             )\n             .into()),\n-            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n         }\n     }\n }\n \n-//TODO: Fill the struct with respective fields\n-// Auth Struct\n pub struct TrustpaymentsAuthType {\n-    pub(super) api_key: Secret<String>,\n+    pub(super) username: Secret<String>,\n+    pub(super) password: Secret<String>,\n+    pub(super) site_reference: Secret<String>,\n+}\n+\n+impl TrustpaymentsAuthType {\n+    pub fn get_basic_auth_header(&self) -> String {\n+        use base64::Engine;\n+        let credentials = format!(\n+            \"{}:{}\",\n+            self.username.clone().expose(),\n+            self.password.clone().expose()\n+        );\n+        let encoded = base64::engine::general_purpose::STANDARD.encode(credentials.as_bytes());\n+        format!(\"Basic {encoded}\")\n+    }\n }\n \n impl TryFrom<&ConnectorAuthType> for TrustpaymentsAuthType {\n     type Error = error_stack::Report<errors::ConnectorError>;\n     fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n         match auth_type {\n-            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n-                api_key: api_key.to_owned(),\n+            ConnectorAuthType::SignatureKey {\n+                api_key,\n+                key1,\n+                api_secret,\n+            } => Ok(Self {\n+                username: api_key.to_owned(),\n+                password: key1.to_owned(),\n+                site_reference: api_secret.to_owned(),\n             }),\n             _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n         }\n     }\n }\n-// PaymentsResponse\n-//TODO: Append the remaining status flags\n-#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize, PartialEq)]\n-#[serde(rename_all = \"lowercase\")]\n-pub enum TrustpaymentsPaymentStatus {\n-    Succeeded,\n-    Failed,\n-    #[default]\n-    Processing,\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n+pub struct TrustpaymentsPaymentsResponse {\n+    #[serde(alias = \"response\")]\n+    pub responses: Vec<TrustpaymentsPaymentResponseData>,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n+pub struct TrustpaymentsPaymentResponseData {\n+    pub errorcode: TrustpaymentsErrorCode,\n+    pub errormessage: String,\n+    pub authcode: Option<String>,\n+    pub baseamount: Option<String>,\n+    pub currencyiso3a: Option<String>,\n+    pub transactionreference: Option<String>,\n+    pub settlestatus: Option<TrustpaymentsSettleStatus>,\n+    pub requesttypedescription: String,\n+    pub securityresponsesecuritycode: Option<String>,\n }\n \n-impl From<TrustpaymentsPaymentStatus> for common_enums::AttemptStatus {\n-    fn from(item: TrustpaymentsPaymentStatus) -> Self {\n-        match item {\n-            TrustpaymentsPaymentStatus::Succeeded => Self::Charged,\n-            TrustpaymentsPaymentStatus::Failed => Self::Failure,\n-            TrustpaymentsPaymentStatus::Processing => Self::Authorizing,\n+impl TrustpaymentsPaymentResponseData {\n+    pub fn get_payment_status(\n+        &self,\n+        capture_method: Option<common_enums::CaptureMethod>,\n+    ) -> common_enums::AttemptStatus {\n+        match self.errorcode {\n+            TrustpaymentsErrorCode::Success => {\n+                if self.authcode.is_some() {\n+                    match &self.settlestatus {\n+                        Some(TrustpaymentsSettleStatus::PendingSettlement) => {\n+                            match capture_method {\n+                                Some(common_enums::CaptureMethod::Manual) => {\n+                                    common_enums::AttemptStatus::Authorized\n+                                }\n+                                _ => common_enums::AttemptStatus::Charged,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2291007404",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8705,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/trustpayments/transformers.rs",
        "discussion_id": "2291007404",
        "commented_code": "@@ -53,77 +322,424 @@ impl TryFrom<&TrustpaymentsRouterData<&PaymentsAuthorizeRouterData>>\n     fn try_from(\n         item: &TrustpaymentsRouterData<&PaymentsAuthorizeRouterData>,\n     ) -> Result<Self, Self::Error> {\n+        let auth = TrustpaymentsAuthType::try_from(&item.router_data.connector_auth_type)?;\n+\n+        if matches!(\n+            item.router_data.auth_type,\n+            enums::AuthenticationType::ThreeDs\n+        ) {\n+            return Err(errors::ConnectorError::NotImplemented(\n+                utils::get_unimplemented_payment_method_error_message(\"trustpayments\"),\n+            )\n+            .into());\n+        }\n+\n         match item.router_data.request.payment_method_data.clone() {\n-            PaymentMethodData::Card(_) => Err(errors::ConnectorError::NotImplemented(\n-                \"Card payment method not implemented\".to_string(),\n+            PaymentMethodData::Card(req_card) => {\n+                let card = req_card.clone();\n+\n+                let request_types = match item.router_data.request.capture_method {\n+                    Some(common_enums::CaptureMethod::Automatic) | None => vec![\"AUTH\".to_string()],\n+                    Some(common_enums::CaptureMethod::Manual) => vec![\"AUTH\".to_string()],\n+                    Some(common_enums::CaptureMethod::ManualMultiple)\n+                    | Some(common_enums::CaptureMethod::Scheduled)\n+                    | Some(common_enums::CaptureMethod::SequentialAutomatic) => {\n+                        return Err(errors::ConnectorError::NotSupported {\n+                            message: \"Capture method not supported by TrustPayments\".to_string(),\n+                            connector: \"TrustPayments\",\n+                        }\n+                        .into());\n+                    }\n+                };\n+\n+                Ok(Self {\n+                    alias: auth.username.expose(),\n+                    version: \"1.00\".to_string(),\n+                    request: vec![TrustpaymentsPaymentRequestData {\n+                        accounttypedescription: \"ECOM\".to_string(),\n+                        baseamount: item.amount.to_string(),\n+                        billingfirstname: item\n+                            .router_data\n+                            .get_optional_billing_first_name()\n+                            .map(|name| name.expose()),\n+                        billinglastname: item\n+                            .router_data\n+                            .get_optional_billing_last_name()\n+                            .map(|name| name.expose()),\n+                        currencyiso3a: item.router_data.request.currency.to_string(),\n+                        expirydate: Secret::new(format!(\n+                            \"{:02}/{:02}\",\n+                            card.card_exp_month.clone().expose(),\n+                            card.card_exp_year.clone().expose()\n+                        )),\n+                        orderreference: item.router_data.connector_request_reference_id.clone(),\n+                        pan: card.card_number.clone(),\n+                        requesttypedescriptions: request_types,\n+                        securitycode: card.card_cvc.clone(),\n+                        sitereference: auth.site_reference.expose(),\n+                        credentialsonfile:\n+                            TrustpaymentsCredentialsOnFile::CardholderInitiatedTransaction\n+                                .to_string(),\n+                    }],\n+                })\n+            }\n+            _ => Err(errors::ConnectorError::NotImplemented(\n+                \"Payment method not supported\".to_string(),\n             )\n             .into()),\n-            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n         }\n     }\n }\n \n-//TODO: Fill the struct with respective fields\n-// Auth Struct\n pub struct TrustpaymentsAuthType {\n-    pub(super) api_key: Secret<String>,\n+    pub(super) username: Secret<String>,\n+    pub(super) password: Secret<String>,\n+    pub(super) site_reference: Secret<String>,\n+}\n+\n+impl TrustpaymentsAuthType {\n+    pub fn get_basic_auth_header(&self) -> String {\n+        use base64::Engine;\n+        let credentials = format!(\n+            \"{}:{}\",\n+            self.username.clone().expose(),\n+            self.password.clone().expose()\n+        );\n+        let encoded = base64::engine::general_purpose::STANDARD.encode(credentials.as_bytes());\n+        format!(\"Basic {encoded}\")\n+    }\n }\n \n impl TryFrom<&ConnectorAuthType> for TrustpaymentsAuthType {\n     type Error = error_stack::Report<errors::ConnectorError>;\n     fn try_from(auth_type: &ConnectorAuthType) -> Result<Self, Self::Error> {\n         match auth_type {\n-            ConnectorAuthType::HeaderKey { api_key } => Ok(Self {\n-                api_key: api_key.to_owned(),\n+            ConnectorAuthType::SignatureKey {\n+                api_key,\n+                key1,\n+                api_secret,\n+            } => Ok(Self {\n+                username: api_key.to_owned(),\n+                password: key1.to_owned(),\n+                site_reference: api_secret.to_owned(),\n             }),\n             _ => Err(errors::ConnectorError::FailedToObtainAuthType.into()),\n         }\n     }\n }\n-// PaymentsResponse\n-//TODO: Append the remaining status flags\n-#[derive(Debug, Clone, Copy, Default, Serialize, Deserialize, PartialEq)]\n-#[serde(rename_all = \"lowercase\")]\n-pub enum TrustpaymentsPaymentStatus {\n-    Succeeded,\n-    Failed,\n-    #[default]\n-    Processing,\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n+pub struct TrustpaymentsPaymentsResponse {\n+    #[serde(alias = \"response\")]\n+    pub responses: Vec<TrustpaymentsPaymentResponseData>,\n+}\n+\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\n+pub struct TrustpaymentsPaymentResponseData {\n+    pub errorcode: TrustpaymentsErrorCode,\n+    pub errormessage: String,\n+    pub authcode: Option<String>,\n+    pub baseamount: Option<String>,\n+    pub currencyiso3a: Option<String>,\n+    pub transactionreference: Option<String>,\n+    pub settlestatus: Option<TrustpaymentsSettleStatus>,\n+    pub requesttypedescription: String,\n+    pub securityresponsesecuritycode: Option<String>,\n }\n \n-impl From<TrustpaymentsPaymentStatus> for common_enums::AttemptStatus {\n-    fn from(item: TrustpaymentsPaymentStatus) -> Self {\n-        match item {\n-            TrustpaymentsPaymentStatus::Succeeded => Self::Charged,\n-            TrustpaymentsPaymentStatus::Failed => Self::Failure,\n-            TrustpaymentsPaymentStatus::Processing => Self::Authorizing,\n+impl TrustpaymentsPaymentResponseData {\n+    pub fn get_payment_status(\n+        &self,\n+        capture_method: Option<common_enums::CaptureMethod>,\n+    ) -> common_enums::AttemptStatus {\n+        match self.errorcode {\n+            TrustpaymentsErrorCode::Success => {\n+                if self.authcode.is_some() {\n+                    match &self.settlestatus {\n+                        Some(TrustpaymentsSettleStatus::PendingSettlement) => {\n+                            match capture_method {\n+                                Some(common_enums::CaptureMethod::Manual) => {\n+                                    common_enums::AttemptStatus::Authorized\n+                                }\n+                                _ => common_enums::AttemptStatus::Charged,",
        "comment_created_at": "2025-08-21T13:06:54+00:00",
        "comment_author": "swangi-kumari",
        "comment_body": "Don't use default, handle all CaptureMethod",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2328438165",
    "pr_number": 9289,
    "pr_file": "crates/external_services/src/superposition/service.rs",
    "created_at": "2025-09-07T01:50:47+00:00",
    "commented_code": "+use std::sync::Arc;\n+\n+use common_utils::errors::CustomResult;\n+use error_stack::ResultExt;\n+\n+use super::{\n+    interface::{ConfigContext, SuperpositionError, SuperpositionInterface},\n+    superposition::{SuperpositionClient, SuperpositionClientConfig},\n+};\n+\n+/// Configuration for the superposition service\n+pub type SuperpositionConfig = SuperpositionClientConfig;\n+\n+/// Main superposition service implementation  \n+#[derive(Debug)]\n+pub struct SuperpositionService {\n+    superposition_client: Option<Arc<SuperpositionClient>>,\n+}\n+\n+impl SuperpositionService {\n+    /// Create a new configuration service\n+    pub async fn new(config: SuperpositionConfig) -> CustomResult<Self, SuperpositionError> {\n+        let superposition_client = if config.enabled {\n+            Some(Arc::new(\n+                SuperpositionClient::new(config).await.change_context(\n+                    SuperpositionError::ClientError(\n+                        \"Failed to initialize Superposition client\".to_string(),\n+                    ),\n+                )?,\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        Ok(Self {\n+            superposition_client,\n+        })\n+    }\n+}\n+\n+#[async_trait::async_trait]\n+impl SuperpositionInterface for SuperpositionService {\n+    async fn get_config_string(\n+        &self,\n+        key: &str,\n+        context: Option<ConfigContext>,\n+        default_value: String,\n+    ) -> CustomResult<String, SuperpositionError> {\n+        if let Some(superposition_client) = &self.superposition_client {\n+            match superposition_client\n+                .get_string_value(key, context.as_ref())\n+                .await\n+            {\n+                Ok(value) => return Ok(value),\n+                Err(_) => {} // Continue to default",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2328438165",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9289,
        "pr_file": "crates/external_services/src/superposition/service.rs",
        "discussion_id": "2328438165",
        "commented_code": "@@ -0,0 +1,96 @@\n+use std::sync::Arc;\n+\n+use common_utils::errors::CustomResult;\n+use error_stack::ResultExt;\n+\n+use super::{\n+    interface::{ConfigContext, SuperpositionError, SuperpositionInterface},\n+    superposition::{SuperpositionClient, SuperpositionClientConfig},\n+};\n+\n+/// Configuration for the superposition service\n+pub type SuperpositionConfig = SuperpositionClientConfig;\n+\n+/// Main superposition service implementation  \n+#[derive(Debug)]\n+pub struct SuperpositionService {\n+    superposition_client: Option<Arc<SuperpositionClient>>,\n+}\n+\n+impl SuperpositionService {\n+    /// Create a new configuration service\n+    pub async fn new(config: SuperpositionConfig) -> CustomResult<Self, SuperpositionError> {\n+        let superposition_client = if config.enabled {\n+            Some(Arc::new(\n+                SuperpositionClient::new(config).await.change_context(\n+                    SuperpositionError::ClientError(\n+                        \"Failed to initialize Superposition client\".to_string(),\n+                    ),\n+                )?,\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        Ok(Self {\n+            superposition_client,\n+        })\n+    }\n+}\n+\n+#[async_trait::async_trait]\n+impl SuperpositionInterface for SuperpositionService {\n+    async fn get_config_string(\n+        &self,\n+        key: &str,\n+        context: Option<ConfigContext>,\n+        default_value: String,\n+    ) -> CustomResult<String, SuperpositionError> {\n+        if let Some(superposition_client) = &self.superposition_client {\n+            match superposition_client\n+                .get_string_value(key, context.as_ref())\n+                .await\n+            {\n+                Ok(value) => return Ok(value),\n+                Err(_) => {} // Continue to default",
        "comment_created_at": "2025-09-07T01:50:47+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Let's not completely ignore errors, let's log them at least.\r\nSame applies for the other methods implemented below.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2306676291",
    "pr_number": 9021,
    "pr_file": "crates/router/src/services/api.rs",
    "created_at": "2025-08-28T08:37:43+00:00",
    "commented_code": "pub type BoxedVaultConnectorIntegrationInterface<T, Req, Res> =\n     BoxedConnectorIntegrationInterface<T, common_types::VaultConnectorFlowData, Req, Res>;\n \n+/// Handle UCS webhook response processing\n+fn handle_ucs_response<T, Req, Resp>(\n+    router_data: types::RouterData<T, Req, Resp>,\n+    transform_data_bytes: Vec<u8>,\n+) -> CustomResult<types::RouterData<T, Req, Resp>, errors::ConnectorError>\n+where\n+    T: Clone + Debug + 'static,\n+    Req: Debug + Clone + 'static,\n+    Resp: Debug + Clone + 'static,\n+{\n+    let webhook_transform_data: crate::core::unified_connector_service::WebhookTransformData =\n+        serde_json::from_slice(&transform_data_bytes)\n+            .change_context(errors::ConnectorError::ResponseDeserializationFailed)\n+            .attach_printable(\"Failed to deserialize UCS webhook transform data\")?;\n+\n+    let webhook_content = webhook_transform_data\n+        .webhook_content\n+        .ok_or(errors::ConnectorError::ResponseDeserializationFailed)\n+        .attach_printable(\"UCS webhook transform data missing webhook_content\")?;\n+\n+    let payment_get_response = match webhook_content.content {\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::PaymentsResponse(payments_response)) => {\n+            payments_response\n+        },\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::RefundsResponse(_)) => {\n+            return Err(errors::ConnectorError::ProcessingStepFailed(Some(\"UCS webhook contains refund response but payment processing was expected\".to_string().into())).into());",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2306676291",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9021,
        "pr_file": "crates/router/src/services/api.rs",
        "discussion_id": "2306676291",
        "commented_code": "@@ -127,6 +127,64 @@ pub type BoxedBillingConnectorPaymentsSyncIntegrationInterface<T, Req, Res> =\n pub type BoxedVaultConnectorIntegrationInterface<T, Req, Res> =\n     BoxedConnectorIntegrationInterface<T, common_types::VaultConnectorFlowData, Req, Res>;\n \n+/// Handle UCS webhook response processing\n+fn handle_ucs_response<T, Req, Resp>(\n+    router_data: types::RouterData<T, Req, Resp>,\n+    transform_data_bytes: Vec<u8>,\n+) -> CustomResult<types::RouterData<T, Req, Resp>, errors::ConnectorError>\n+where\n+    T: Clone + Debug + 'static,\n+    Req: Debug + Clone + 'static,\n+    Resp: Debug + Clone + 'static,\n+{\n+    let webhook_transform_data: crate::core::unified_connector_service::WebhookTransformData =\n+        serde_json::from_slice(&transform_data_bytes)\n+            .change_context(errors::ConnectorError::ResponseDeserializationFailed)\n+            .attach_printable(\"Failed to deserialize UCS webhook transform data\")?;\n+\n+    let webhook_content = webhook_transform_data\n+        .webhook_content\n+        .ok_or(errors::ConnectorError::ResponseDeserializationFailed)\n+        .attach_printable(\"UCS webhook transform data missing webhook_content\")?;\n+\n+    let payment_get_response = match webhook_content.content {\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::PaymentsResponse(payments_response)) => {\n+            payments_response\n+        },\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::RefundsResponse(_)) => {\n+            return Err(errors::ConnectorError::ProcessingStepFailed(Some(\"UCS webhook contains refund response but payment processing was expected\".to_string().into())).into());",
        "comment_created_at": "2025-08-28T08:37:43+00:00",
        "comment_author": "jarnura",
        "comment_body": "Use ? to throw error, don't use return",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2306676681",
    "pr_number": 9021,
    "pr_file": "crates/router/src/services/api.rs",
    "created_at": "2025-08-28T08:37:52+00:00",
    "commented_code": "pub type BoxedVaultConnectorIntegrationInterface<T, Req, Res> =\n     BoxedConnectorIntegrationInterface<T, common_types::VaultConnectorFlowData, Req, Res>;\n \n+/// Handle UCS webhook response processing\n+fn handle_ucs_response<T, Req, Resp>(\n+    router_data: types::RouterData<T, Req, Resp>,\n+    transform_data_bytes: Vec<u8>,\n+) -> CustomResult<types::RouterData<T, Req, Resp>, errors::ConnectorError>\n+where\n+    T: Clone + Debug + 'static,\n+    Req: Debug + Clone + 'static,\n+    Resp: Debug + Clone + 'static,\n+{\n+    let webhook_transform_data: crate::core::unified_connector_service::WebhookTransformData =\n+        serde_json::from_slice(&transform_data_bytes)\n+            .change_context(errors::ConnectorError::ResponseDeserializationFailed)\n+            .attach_printable(\"Failed to deserialize UCS webhook transform data\")?;\n+\n+    let webhook_content = webhook_transform_data\n+        .webhook_content\n+        .ok_or(errors::ConnectorError::ResponseDeserializationFailed)\n+        .attach_printable(\"UCS webhook transform data missing webhook_content\")?;\n+\n+    let payment_get_response = match webhook_content.content {\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::PaymentsResponse(payments_response)) => {\n+            payments_response\n+        },\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::RefundsResponse(_)) => {\n+            return Err(errors::ConnectorError::ProcessingStepFailed(Some(\"UCS webhook contains refund response but payment processing was expected\".to_string().into())).into());\n+        },\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::DisputesResponse(_)) => {\n+            return Err(errors::ConnectorError::ProcessingStepFailed(Some(\"UCS webhook contains dispute response but payment processing was expected\".to_string().into())).into());\n+        },\n+        None => {\n+            return Err(errors::ConnectorError::ResponseDeserializationFailed)",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2306676681",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9021,
        "pr_file": "crates/router/src/services/api.rs",
        "discussion_id": "2306676681",
        "commented_code": "@@ -127,6 +127,64 @@ pub type BoxedBillingConnectorPaymentsSyncIntegrationInterface<T, Req, Res> =\n pub type BoxedVaultConnectorIntegrationInterface<T, Req, Res> =\n     BoxedConnectorIntegrationInterface<T, common_types::VaultConnectorFlowData, Req, Res>;\n \n+/// Handle UCS webhook response processing\n+fn handle_ucs_response<T, Req, Resp>(\n+    router_data: types::RouterData<T, Req, Resp>,\n+    transform_data_bytes: Vec<u8>,\n+) -> CustomResult<types::RouterData<T, Req, Resp>, errors::ConnectorError>\n+where\n+    T: Clone + Debug + 'static,\n+    Req: Debug + Clone + 'static,\n+    Resp: Debug + Clone + 'static,\n+{\n+    let webhook_transform_data: crate::core::unified_connector_service::WebhookTransformData =\n+        serde_json::from_slice(&transform_data_bytes)\n+            .change_context(errors::ConnectorError::ResponseDeserializationFailed)\n+            .attach_printable(\"Failed to deserialize UCS webhook transform data\")?;\n+\n+    let webhook_content = webhook_transform_data\n+        .webhook_content\n+        .ok_or(errors::ConnectorError::ResponseDeserializationFailed)\n+        .attach_printable(\"UCS webhook transform data missing webhook_content\")?;\n+\n+    let payment_get_response = match webhook_content.content {\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::PaymentsResponse(payments_response)) => {\n+            payments_response\n+        },\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::RefundsResponse(_)) => {\n+            return Err(errors::ConnectorError::ProcessingStepFailed(Some(\"UCS webhook contains refund response but payment processing was expected\".to_string().into())).into());\n+        },\n+        Some(unified_connector_service_client::payments::webhook_response_content::Content::DisputesResponse(_)) => {\n+            return Err(errors::ConnectorError::ProcessingStepFailed(Some(\"UCS webhook contains dispute response but payment processing was expected\".to_string().into())).into());\n+        },\n+        None => {\n+            return Err(errors::ConnectorError::ResponseDeserializationFailed)",
        "comment_created_at": "2025-08-28T08:37:52+00:00",
        "comment_author": "jarnura",
        "comment_body": "Use ? to throw error, don't use return",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2013713676",
    "pr_number": 7062,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/amazonpay/transformers.rs",
    "created_at": "2025-03-26T09:29:51+00:00",
    "commented_code": "-use common_enums::enums;\n-use common_utils::types::StringMinorUnit;\n+use std::collections::HashMap;\n+\n+use common_enums::{enums, CaptureMethod};\n+use common_utils::{errors::CustomResult, types::StringMajorUnit};\n use hyperswitch_domain_models::{\n-    payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n     types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{PeekInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::{\n-    types::{RefundsResponseRouterData, ResponseRouterData},\n-    utils::PaymentsAuthorizeRequestData,\n-};\n+use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n \n-//TODO: Fill the struct with respective fields\n pub struct AmazonpayRouterData<T> {\n-    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub amount: StringMajorUnit,\n     pub router_data: T,\n }\n \n-impl<T> From<(StringMinorUnit, T)> for AmazonpayRouterData<T> {\n-    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n-        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+impl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n+    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n         Self {\n             amount,\n             router_data: item,\n         }\n     }\n }\n \n-//TODO: Fill the struct with respective fields\n #[derive(Default, Debug, Serialize, PartialEq)]\n-pub struct AmazonpayPaymentsRequest {\n-    amount: StringMinorUnit,\n-    card: AmazonpayCard,\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AmazonpayFinalizeRequest {\n+    charge_amount: ChargeAmount,\n+    total_order_amount: Option<TotalOrderAmount>,\n+    shipping_address: AddressDetails,\n+    payment_intent: PaymentIntent,\n }\n \n-#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n-pub struct AmazonpayCard {\n-    number: cards::CardNumber,\n-    expiry_month: Secret<String>,\n-    expiry_year: Secret<String>,\n-    cvc: Secret<String>,\n-    complete: bool,\n+#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ChargeAmount {\n+    amount: StringMajorUnit,\n+    currency_code: common_enums::Currency,\n }\n \n-impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayPaymentsRequest {\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct TotalOrderAmount {\n+    amount: Option<StringMajorUnit>,\n+    currency_code: Option<common_enums::Currency>,\n+    can_handle_pending_authorization: Option<bool>,\n+    supplementary_data: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Deserialize, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AddressDetails {\n+    name: Option<String>,\n+    address_line_1: Option<String>,\n+    address_line_2: Option<String>,\n+    address_line_3: Option<String>,\n+    city: Option<String>,\n+    state_or_region: Option<String>,\n+    postal_code: Option<String>,\n+    country_code: Option<common_enums::CountryAlpha2>,\n+    phone_number: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub enum PaymentIntent {\n+    #[default]\n+    AuthorizeWithCapture,\n+}\n+\n+fn get_amazonpay_capture_type(\n+    item: Option<CaptureMethod>,\n+) -> CustomResult<Option<PaymentIntent>, errors::ConnectorError> {\n+    match item {\n+        Some(CaptureMethod::Automatic) => Ok(Some(PaymentIntent::AuthorizeWithCapture)),\n+        Some(_) => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n+        None => Err(errors::ConnectorError::MissingRequiredField {\n+            field_name: \"capture_method\",\n+        }\n+        .into()),\n+    }\n+}\n+\n+impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayFinalizeRequest {\n     type Error = error_stack::Report<errors::ConnectorError>;\n     fn try_from(\n         item: &AmazonpayRouterData<&PaymentsAuthorizeRouterData>,\n     ) -> Result<Self, Self::Error> {\n-        match item.router_data.request.payment_method_data.clone() {\n-            PaymentMethodData::Card(req_card) => {\n-                let card = AmazonpayCard {\n-                    number: req_card.card_number,\n-                    expiry_month: req_card.card_exp_month,\n-                    expiry_year: req_card.card_exp_year,\n-                    cvc: req_card.card_cvc,\n-                    complete: item.router_data.request.is_auto_capture()?,\n-                };\n-                Ok(Self {\n-                    amount: item.amount.clone(),\n-                    card,\n-                })\n+        let charge_amount = ChargeAmount {\n+            amount: item.amount.clone(),\n+            currency_code: common_enums::Currency::USD,\n+        };\n+        let shipping_address_details = item.router_data.address.get_shipping();\n+        let shipping_address = if let Some(shipping) = shipping_address_details {\n+            if let Some(address_details) = shipping.address.as_ref() {\n+                AddressDetails {\n+                    name: address_details\n+                        .get_optional_full_name()\n+                        .map(|secret_name| secret_name.peek().to_string()),\n+                    address_line_1: address_details\n+                        .line1\n+                        .clone()\n+                        .map(|l1| l1.peek().to_string()),\n+                    address_line_2: address_details\n+                        .line2\n+                        .clone()\n+                        .map(|l2| l2.peek().to_string()),\n+                    address_line_3: address_details\n+                        .line3\n+                        .clone()\n+                        .map(|l3| l3.peek().to_string()),\n+                    city: address_details.city.clone(),\n+                    state_or_region: address_details\n+                        .state\n+                        .clone()\n+                        .map(|state| state.peek().to_string()),\n+                    postal_code: address_details\n+                        .zip\n+                        .clone()\n+                        .map(|zip| zip.peek().to_string()),\n+                    country_code: address_details.country,\n+                    phone_number: shipping\n+                        .phone\n+                        .as_ref()\n+                        .and_then(|phone| phone.number.as_ref())\n+                        .map(|phone_number| phone_number.peek().to_string()),\n+                }\n+            } else {\n+                AddressDetails::default()\n             }\n-            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        } else {\n+            AddressDetails::default()\n+        };\n+        let payment_intent = get_amazonpay_capture_type(item.router_data.request.capture_method)?\n+            .unwrap_or_default();",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2013713676",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 7062,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/amazonpay/transformers.rs",
        "discussion_id": "2013713676",
        "commented_code": "@@ -1,121 +1,457 @@\n-use common_enums::enums;\n-use common_utils::types::StringMinorUnit;\n+use std::collections::HashMap;\n+\n+use common_enums::{enums, CaptureMethod};\n+use common_utils::{errors::CustomResult, types::StringMajorUnit};\n use hyperswitch_domain_models::{\n-    payment_method_data::PaymentMethodData,\n     router_data::{ConnectorAuthType, RouterData},\n     router_flow_types::refunds::{Execute, RSync},\n     router_request_types::ResponseId,\n     router_response_types::{PaymentsResponseData, RefundsResponseData},\n     types::{PaymentsAuthorizeRouterData, RefundsRouterData},\n };\n use hyperswitch_interfaces::errors;\n-use masking::Secret;\n+use masking::{PeekInterface, Secret};\n use serde::{Deserialize, Serialize};\n \n-use crate::{\n-    types::{RefundsResponseRouterData, ResponseRouterData},\n-    utils::PaymentsAuthorizeRequestData,\n-};\n+use crate::types::{RefundsResponseRouterData, ResponseRouterData};\n \n-//TODO: Fill the struct with respective fields\n pub struct AmazonpayRouterData<T> {\n-    pub amount: StringMinorUnit, // The type of amount that a connector accepts, for example, String, i64, f64, etc.\n+    pub amount: StringMajorUnit,\n     pub router_data: T,\n }\n \n-impl<T> From<(StringMinorUnit, T)> for AmazonpayRouterData<T> {\n-    fn from((amount, item): (StringMinorUnit, T)) -> Self {\n-        //Todo :  use utils to convert the amount to the type of amount that a connector accepts\n+impl<T> From<(StringMajorUnit, T)> for AmazonpayRouterData<T> {\n+    fn from((amount, item): (StringMajorUnit, T)) -> Self {\n         Self {\n             amount,\n             router_data: item,\n         }\n     }\n }\n \n-//TODO: Fill the struct with respective fields\n #[derive(Default, Debug, Serialize, PartialEq)]\n-pub struct AmazonpayPaymentsRequest {\n-    amount: StringMinorUnit,\n-    card: AmazonpayCard,\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AmazonpayFinalizeRequest {\n+    charge_amount: ChargeAmount,\n+    total_order_amount: Option<TotalOrderAmount>,\n+    shipping_address: AddressDetails,\n+    payment_intent: PaymentIntent,\n }\n \n-#[derive(Default, Debug, Serialize, Eq, PartialEq)]\n-pub struct AmazonpayCard {\n-    number: cards::CardNumber,\n-    expiry_month: Secret<String>,\n-    expiry_year: Secret<String>,\n-    cvc: Secret<String>,\n-    complete: bool,\n+#[derive(Default, Debug, Clone, Serialize, Deserialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ChargeAmount {\n+    amount: StringMajorUnit,\n+    currency_code: common_enums::Currency,\n }\n \n-impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayPaymentsRequest {\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct TotalOrderAmount {\n+    amount: Option<StringMajorUnit>,\n+    currency_code: Option<common_enums::Currency>,\n+    can_handle_pending_authorization: Option<bool>,\n+    supplementary_data: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Deserialize, Serialize, PartialEq)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct AddressDetails {\n+    name: Option<String>,\n+    address_line_1: Option<String>,\n+    address_line_2: Option<String>,\n+    address_line_3: Option<String>,\n+    city: Option<String>,\n+    state_or_region: Option<String>,\n+    postal_code: Option<String>,\n+    country_code: Option<common_enums::CountryAlpha2>,\n+    phone_number: Option<String>,\n+}\n+\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub enum PaymentIntent {\n+    #[default]\n+    AuthorizeWithCapture,\n+}\n+\n+fn get_amazonpay_capture_type(\n+    item: Option<CaptureMethod>,\n+) -> CustomResult<Option<PaymentIntent>, errors::ConnectorError> {\n+    match item {\n+        Some(CaptureMethod::Automatic) => Ok(Some(PaymentIntent::AuthorizeWithCapture)),\n+        Some(_) => Err(errors::ConnectorError::CaptureMethodNotSupported.into()),\n+        None => Err(errors::ConnectorError::MissingRequiredField {\n+            field_name: \"capture_method\",\n+        }\n+        .into()),\n+    }\n+}\n+\n+impl TryFrom<&AmazonpayRouterData<&PaymentsAuthorizeRouterData>> for AmazonpayFinalizeRequest {\n     type Error = error_stack::Report<errors::ConnectorError>;\n     fn try_from(\n         item: &AmazonpayRouterData<&PaymentsAuthorizeRouterData>,\n     ) -> Result<Self, Self::Error> {\n-        match item.router_data.request.payment_method_data.clone() {\n-            PaymentMethodData::Card(req_card) => {\n-                let card = AmazonpayCard {\n-                    number: req_card.card_number,\n-                    expiry_month: req_card.card_exp_month,\n-                    expiry_year: req_card.card_exp_year,\n-                    cvc: req_card.card_cvc,\n-                    complete: item.router_data.request.is_auto_capture()?,\n-                };\n-                Ok(Self {\n-                    amount: item.amount.clone(),\n-                    card,\n-                })\n+        let charge_amount = ChargeAmount {\n+            amount: item.amount.clone(),\n+            currency_code: common_enums::Currency::USD,\n+        };\n+        let shipping_address_details = item.router_data.address.get_shipping();\n+        let shipping_address = if let Some(shipping) = shipping_address_details {\n+            if let Some(address_details) = shipping.address.as_ref() {\n+                AddressDetails {\n+                    name: address_details\n+                        .get_optional_full_name()\n+                        .map(|secret_name| secret_name.peek().to_string()),\n+                    address_line_1: address_details\n+                        .line1\n+                        .clone()\n+                        .map(|l1| l1.peek().to_string()),\n+                    address_line_2: address_details\n+                        .line2\n+                        .clone()\n+                        .map(|l2| l2.peek().to_string()),\n+                    address_line_3: address_details\n+                        .line3\n+                        .clone()\n+                        .map(|l3| l3.peek().to_string()),\n+                    city: address_details.city.clone(),\n+                    state_or_region: address_details\n+                        .state\n+                        .clone()\n+                        .map(|state| state.peek().to_string()),\n+                    postal_code: address_details\n+                        .zip\n+                        .clone()\n+                        .map(|zip| zip.peek().to_string()),\n+                    country_code: address_details.country,\n+                    phone_number: shipping\n+                        .phone\n+                        .as_ref()\n+                        .and_then(|phone| phone.number.as_ref())\n+                        .map(|phone_number| phone_number.peek().to_string()),\n+                }\n+            } else {\n+                AddressDetails::default()\n             }\n-            _ => Err(errors::ConnectorError::NotImplemented(\"Payment method\".to_string()).into()),\n+        } else {\n+            AddressDetails::default()\n+        };\n+        let payment_intent = get_amazonpay_capture_type(item.router_data.request.capture_method)?\n+            .unwrap_or_default();",
        "comment_created_at": "2025-03-26T09:29:51+00:00",
        "comment_author": "AkshayaFoiger",
        "comment_body": "Remove `unwrap_or_default()`. We must throw an error if the capture method is not automatic.  ",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2290789457",
    "pr_number": 8959,
    "pr_file": "crates/injector/src/injector.rs",
    "created_at": "2025-08-21T11:45:43+00:00",
    "commented_code": "+#[cfg(feature = \"v2\")]\n+pub mod core {\n+    use std::collections::HashMap;\n+\n+    use api_models::injector::{ContentType, InjectorRequest, InjectorResponse};\n+    use async_trait::async_trait;\n+    use common_utils::request::{Method, RequestBuilder, RequestContent};\n+    use error_stack::ResultExt;\n+    use external_services::http_client;\n+    use hyperswitch_domain_models::injector;\n+    use hyperswitch_interfaces::types::Proxy;\n+    use masking::{self, ExposeInterface};\n+    use nom::{\n+        bytes::complete::{tag, take_while1},\n+        character::complete::{char, multispace0},\n+        sequence::{delimited, preceded, terminated},\n+        IResult,\n+    };\n+    use router_env::{instrument, logger, tracing};\n+    use serde_json::Value;\n+    use thiserror::Error;\n+\n+    #[derive(Error, Debug)]\n+    pub enum InjectorError {\n+        #[error(\"Token replacement failed: {0}\")]\n+        TokenReplacementFailed(String),\n+        #[error(\"HTTP request failed\")]\n+        HttpRequestFailed,\n+        #[error(\"Serialization error: {0}\")]\n+        SerializationError(String),\n+        #[error(\"Invalid template: {0}\")]\n+        InvalidTemplate(String),\n+    }\n+\n+    #[instrument(skip_all)]\n+    pub async fn injector_core(\n+        request: InjectorRequest,\n+    ) -> error_stack::Result<InjectorResponse, InjectorError> {\n+        logger::info!(\"Starting injector_core processing\");\n+        let injector = Injector::new();\n+        injector.injector_core(request).await\n+    }\n+\n+    /// Represents a token reference found in a template string\n+    #[derive(Debug)]\n+    pub struct TokenReference {\n+        /// The field name to be replaced (without the {{$}} wrapper)\n+        pub field: String,\n+    }\n+\n+    /// Parses a single token reference from a string using nom parser combinators\n+    ///\n+    /// Expects tokens in the format `{{$field_name}}` where field_name contains\n+    /// only alphanumeric characters and underscores.\n+    pub fn parse_token(input: &str) -> IResult<&str, TokenReference> {\n+        let (input, field) = delimited(\n+            tag(\"{{\"),\n+            preceded(\n+                multispace0,\n+                preceded(\n+                    char('$'),\n+                    terminated(\n+                        take_while1(|c: char| c.is_alphanumeric() || c == '_'),\n+                        multispace0,\n+                    ),\n+                ),\n+            ),\n+            tag(\"}}\"),\n+        )(input)?;\n+        Ok((\n+            input,\n+            TokenReference {\n+                field: field.to_string(),\n+            },\n+        ))\n+    }\n+\n+    /// Finds all token references in a string using nom parser\n+    ///\n+    /// Scans through the entire input string and extracts all valid token references.\n+    /// Returns a vector of TokenReference structs containing the field names.\n+    pub fn find_all_tokens(input: &str) -> Vec<TokenReference> {\n+        let mut tokens = Vec::new();\n+        let mut current_input = input;\n+\n+        while !current_input.is_empty() {\n+            if let Ok((remaining, token_ref)) = parse_token(current_input) {\n+                tokens.push(token_ref);\n+                current_input = remaining;\n+            } else {\n+                // Move forward one character if no token found\n+                if let Some((_, rest)) = current_input.split_at_checked(1) {\n+                    current_input = rest;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        tokens\n+    }\n+\n+    /// Recursively searches for a field in vault data JSON structure\n+    ///\n+    /// Performs a depth-first search through the JSON object hierarchy to find\n+    /// a field with the specified name. Returns the first matching value found.\n+    pub fn find_field_recursively_in_vault_data(\n+        obj: &serde_json::Map<String, Value>,\n+        field_name: &str,\n+    ) -> Option<Value> {\n+        obj.get(field_name).cloned().or_else(|| {\n+            obj.values()\n+                .filter_map(|val| {\n+                    if let Value::Object(inner_obj) = val {\n+                        find_field_recursively_in_vault_data(inner_obj, field_name)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .next()\n+        })\n+    }\n+\n+    #[async_trait]\n+    pub trait TokenInjector {\n+        async fn injector_core(\n+            &self,\n+            request: InjectorRequest,\n+        ) -> error_stack::Result<InjectorResponse, InjectorError>;\n+    }\n+\n+    pub struct Injector;\n+\n+    impl Injector {\n+        pub fn new() -> Self {\n+            Self\n+        }\n+\n+        /// Processes a string template and replaces token references with vault data\n+        #[instrument(skip_all)]\n+        pub fn interpolate_string_template_with_vault_data(\n+            &self,\n+            template: String,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<String, InjectorError> {\n+            // Find all tokens using nom parser\n+            let tokens = find_all_tokens(&template);\n+            let mut result = template;\n+\n+            for token_ref in tokens {\n+                let extracted_field_value = self.extract_field_from_vault_data(\n+                    vault_data,\n+                    &token_ref.field,\n+                    vault_connector,\n+                )?;\n+                let token_str = match extracted_field_value {\n+                    Value::String(token_value) => token_value,\n+                    _ => serde_json::to_string(&extracted_field_value).unwrap_or_default(),\n+                };\n+\n+                // Replace the token in the result string\n+                let token_pattern = format!(\"{{{{${}}}}}\", token_ref.field);\n+                result = result.replace(&token_pattern, &token_str);\n+            }\n+\n+            Ok(result)\n+        }\n+\n+        #[instrument(skip_all)]\n+        pub fn interpolate_token_references_with_vault_data(\n+            &self,\n+            value: Value,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match value {\n+                Value::Object(obj) => {\n+                    let new_obj = obj\n+                        .into_iter()\n+                        .map(|(key, val)| {\n+                            self.interpolate_token_references_with_vault_data(\n+                                val,\n+                                vault_data,\n+                                vault_connector,\n+                            )\n+                            .map(|processed| (key, processed))\n+                        })\n+                        .collect::<error_stack::Result<serde_json::Map<_, _>, InjectorError>>()?;\n+                    Ok(Value::Object(new_obj))\n+                }\n+                Value::String(s) => {\n+                    let processed_string = self.interpolate_string_template_with_vault_data(\n+                        s,\n+                        vault_data,\n+                        vault_connector,\n+                    )?;\n+                    Ok(Value::String(processed_string))\n+                }\n+                _ => Ok(value),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn extract_field_from_vault_data(\n+            &self,\n+            vault_data: &Value,\n+            field_name: &str,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::debug!(\n+                \"Extracting field '{}' from vault data using vault type {:?}\",\n+                field_name,\n+                vault_connector\n+            );\n+\n+            match vault_data {\n+                Value::Object(obj) => {\n+                    let raw_value = find_field_recursively_in_vault_data(obj, field_name)\n+                        .ok_or_else(|| {\n+                            error_stack::Report::new(InjectorError::TokenReplacementFailed(\n+                                format!(\"Field '{field_name}' not found\"),\n+                            ))\n+                        })?;\n+\n+                    // Apply vault-specific token transformation\n+                    self.apply_vault_specific_transformation(raw_value, vault_connector, field_name)\n+                }\n+                _ => Err(error_stack::Report::new(\n+                    InjectorError::TokenReplacementFailed(\n+                        \"Vault data is not a valid JSON object\".to_string(),\n+                    ),\n+                )),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn apply_vault_specific_transformation(\n+            &self,\n+            extracted_field_value: Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+            field_name: &str,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match vault_connector {\n+                injector::types::VaultConnectors::VGS => {\n+                    logger::debug!(\n+                        \"VGS vault: Using direct token replacement for field '{}'\",\n+                        field_name\n+                    );\n+                    Ok(extracted_field_value)\n+                }\n+            }\n+        }\n+\n+        /// Makes an HTTP request to the connector endpoint\n+        ///\n+        /// Note: We cannot reuse the existing `call_connector_api` function from router services\n+        /// because it requires `SessionState` and is tightly coupled to the router's infrastructure.\n+        /// The injector crate is designed to be lightweight and independent, operating with\n+        /// minimal dependencies and without router-specific state management.\n+        #[instrument(skip_all)]\n+        async fn make_http_request(\n+            &self,\n+            config: &injector::ConnectionConfig,\n+            payload: &str,\n+            content_type: &ContentType,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::info!(\n+                method = ?config.http_method,\n+                base_url = %config.base_url,\n+                endpoint = %config.endpoint_path,\n+                content_type = ?content_type,\n+                payload_length = payload.len(),\n+                headers_count = config.headers.len(),\n+                \"Making HTTP request to connector\"\n+            );\n+            // Validate inputs first\n+            if config.endpoint_path.is_empty() {\n+                logger::error!(\"Endpoint path is empty\");\n+                return Err(error_stack::Report::new(InjectorError::InvalidTemplate(",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2290789457",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8959,
        "pr_file": "crates/injector/src/injector.rs",
        "discussion_id": "2290789457",
        "commented_code": "@@ -0,0 +1,791 @@\n+#[cfg(feature = \"v2\")]\n+pub mod core {\n+    use std::collections::HashMap;\n+\n+    use api_models::injector::{ContentType, InjectorRequest, InjectorResponse};\n+    use async_trait::async_trait;\n+    use common_utils::request::{Method, RequestBuilder, RequestContent};\n+    use error_stack::ResultExt;\n+    use external_services::http_client;\n+    use hyperswitch_domain_models::injector;\n+    use hyperswitch_interfaces::types::Proxy;\n+    use masking::{self, ExposeInterface};\n+    use nom::{\n+        bytes::complete::{tag, take_while1},\n+        character::complete::{char, multispace0},\n+        sequence::{delimited, preceded, terminated},\n+        IResult,\n+    };\n+    use router_env::{instrument, logger, tracing};\n+    use serde_json::Value;\n+    use thiserror::Error;\n+\n+    #[derive(Error, Debug)]\n+    pub enum InjectorError {\n+        #[error(\"Token replacement failed: {0}\")]\n+        TokenReplacementFailed(String),\n+        #[error(\"HTTP request failed\")]\n+        HttpRequestFailed,\n+        #[error(\"Serialization error: {0}\")]\n+        SerializationError(String),\n+        #[error(\"Invalid template: {0}\")]\n+        InvalidTemplate(String),\n+    }\n+\n+    #[instrument(skip_all)]\n+    pub async fn injector_core(\n+        request: InjectorRequest,\n+    ) -> error_stack::Result<InjectorResponse, InjectorError> {\n+        logger::info!(\"Starting injector_core processing\");\n+        let injector = Injector::new();\n+        injector.injector_core(request).await\n+    }\n+\n+    /// Represents a token reference found in a template string\n+    #[derive(Debug)]\n+    pub struct TokenReference {\n+        /// The field name to be replaced (without the {{$}} wrapper)\n+        pub field: String,\n+    }\n+\n+    /// Parses a single token reference from a string using nom parser combinators\n+    ///\n+    /// Expects tokens in the format `{{$field_name}}` where field_name contains\n+    /// only alphanumeric characters and underscores.\n+    pub fn parse_token(input: &str) -> IResult<&str, TokenReference> {\n+        let (input, field) = delimited(\n+            tag(\"{{\"),\n+            preceded(\n+                multispace0,\n+                preceded(\n+                    char('$'),\n+                    terminated(\n+                        take_while1(|c: char| c.is_alphanumeric() || c == '_'),\n+                        multispace0,\n+                    ),\n+                ),\n+            ),\n+            tag(\"}}\"),\n+        )(input)?;\n+        Ok((\n+            input,\n+            TokenReference {\n+                field: field.to_string(),\n+            },\n+        ))\n+    }\n+\n+    /// Finds all token references in a string using nom parser\n+    ///\n+    /// Scans through the entire input string and extracts all valid token references.\n+    /// Returns a vector of TokenReference structs containing the field names.\n+    pub fn find_all_tokens(input: &str) -> Vec<TokenReference> {\n+        let mut tokens = Vec::new();\n+        let mut current_input = input;\n+\n+        while !current_input.is_empty() {\n+            if let Ok((remaining, token_ref)) = parse_token(current_input) {\n+                tokens.push(token_ref);\n+                current_input = remaining;\n+            } else {\n+                // Move forward one character if no token found\n+                if let Some((_, rest)) = current_input.split_at_checked(1) {\n+                    current_input = rest;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        tokens\n+    }\n+\n+    /// Recursively searches for a field in vault data JSON structure\n+    ///\n+    /// Performs a depth-first search through the JSON object hierarchy to find\n+    /// a field with the specified name. Returns the first matching value found.\n+    pub fn find_field_recursively_in_vault_data(\n+        obj: &serde_json::Map<String, Value>,\n+        field_name: &str,\n+    ) -> Option<Value> {\n+        obj.get(field_name).cloned().or_else(|| {\n+            obj.values()\n+                .filter_map(|val| {\n+                    if let Value::Object(inner_obj) = val {\n+                        find_field_recursively_in_vault_data(inner_obj, field_name)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .next()\n+        })\n+    }\n+\n+    #[async_trait]\n+    pub trait TokenInjector {\n+        async fn injector_core(\n+            &self,\n+            request: InjectorRequest,\n+        ) -> error_stack::Result<InjectorResponse, InjectorError>;\n+    }\n+\n+    pub struct Injector;\n+\n+    impl Injector {\n+        pub fn new() -> Self {\n+            Self\n+        }\n+\n+        /// Processes a string template and replaces token references with vault data\n+        #[instrument(skip_all)]\n+        pub fn interpolate_string_template_with_vault_data(\n+            &self,\n+            template: String,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<String, InjectorError> {\n+            // Find all tokens using nom parser\n+            let tokens = find_all_tokens(&template);\n+            let mut result = template;\n+\n+            for token_ref in tokens {\n+                let extracted_field_value = self.extract_field_from_vault_data(\n+                    vault_data,\n+                    &token_ref.field,\n+                    vault_connector,\n+                )?;\n+                let token_str = match extracted_field_value {\n+                    Value::String(token_value) => token_value,\n+                    _ => serde_json::to_string(&extracted_field_value).unwrap_or_default(),\n+                };\n+\n+                // Replace the token in the result string\n+                let token_pattern = format!(\"{{{{${}}}}}\", token_ref.field);\n+                result = result.replace(&token_pattern, &token_str);\n+            }\n+\n+            Ok(result)\n+        }\n+\n+        #[instrument(skip_all)]\n+        pub fn interpolate_token_references_with_vault_data(\n+            &self,\n+            value: Value,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match value {\n+                Value::Object(obj) => {\n+                    let new_obj = obj\n+                        .into_iter()\n+                        .map(|(key, val)| {\n+                            self.interpolate_token_references_with_vault_data(\n+                                val,\n+                                vault_data,\n+                                vault_connector,\n+                            )\n+                            .map(|processed| (key, processed))\n+                        })\n+                        .collect::<error_stack::Result<serde_json::Map<_, _>, InjectorError>>()?;\n+                    Ok(Value::Object(new_obj))\n+                }\n+                Value::String(s) => {\n+                    let processed_string = self.interpolate_string_template_with_vault_data(\n+                        s,\n+                        vault_data,\n+                        vault_connector,\n+                    )?;\n+                    Ok(Value::String(processed_string))\n+                }\n+                _ => Ok(value),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn extract_field_from_vault_data(\n+            &self,\n+            vault_data: &Value,\n+            field_name: &str,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::debug!(\n+                \"Extracting field '{}' from vault data using vault type {:?}\",\n+                field_name,\n+                vault_connector\n+            );\n+\n+            match vault_data {\n+                Value::Object(obj) => {\n+                    let raw_value = find_field_recursively_in_vault_data(obj, field_name)\n+                        .ok_or_else(|| {\n+                            error_stack::Report::new(InjectorError::TokenReplacementFailed(\n+                                format!(\"Field '{field_name}' not found\"),\n+                            ))\n+                        })?;\n+\n+                    // Apply vault-specific token transformation\n+                    self.apply_vault_specific_transformation(raw_value, vault_connector, field_name)\n+                }\n+                _ => Err(error_stack::Report::new(\n+                    InjectorError::TokenReplacementFailed(\n+                        \"Vault data is not a valid JSON object\".to_string(),\n+                    ),\n+                )),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn apply_vault_specific_transformation(\n+            &self,\n+            extracted_field_value: Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+            field_name: &str,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match vault_connector {\n+                injector::types::VaultConnectors::VGS => {\n+                    logger::debug!(\n+                        \"VGS vault: Using direct token replacement for field '{}'\",\n+                        field_name\n+                    );\n+                    Ok(extracted_field_value)\n+                }\n+            }\n+        }\n+\n+        /// Makes an HTTP request to the connector endpoint\n+        ///\n+        /// Note: We cannot reuse the existing `call_connector_api` function from router services\n+        /// because it requires `SessionState` and is tightly coupled to the router's infrastructure.\n+        /// The injector crate is designed to be lightweight and independent, operating with\n+        /// minimal dependencies and without router-specific state management.\n+        #[instrument(skip_all)]\n+        async fn make_http_request(\n+            &self,\n+            config: &injector::ConnectionConfig,\n+            payload: &str,\n+            content_type: &ContentType,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::info!(\n+                method = ?config.http_method,\n+                base_url = %config.base_url,\n+                endpoint = %config.endpoint_path,\n+                content_type = ?content_type,\n+                payload_length = payload.len(),\n+                headers_count = config.headers.len(),\n+                \"Making HTTP request to connector\"\n+            );\n+            // Validate inputs first\n+            if config.endpoint_path.is_empty() {\n+                logger::error!(\"Endpoint path is empty\");\n+                return Err(error_stack::Report::new(InjectorError::InvalidTemplate(",
        "comment_created_at": "2025-08-21T11:45:43+00:00",
        "comment_author": "jarnura",
        "comment_body": "instead of return use ? pattern to throw errors",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2290793217",
    "pr_number": 8959,
    "pr_file": "crates/injector/src/injector.rs",
    "created_at": "2025-08-21T11:46:56+00:00",
    "commented_code": "+#[cfg(feature = \"v2\")]\n+pub mod core {\n+    use std::collections::HashMap;\n+\n+    use api_models::injector::{ContentType, InjectorRequest, InjectorResponse};\n+    use async_trait::async_trait;\n+    use common_utils::request::{Method, RequestBuilder, RequestContent};\n+    use error_stack::ResultExt;\n+    use external_services::http_client;\n+    use hyperswitch_domain_models::injector;\n+    use hyperswitch_interfaces::types::Proxy;\n+    use masking::{self, ExposeInterface};\n+    use nom::{\n+        bytes::complete::{tag, take_while1},\n+        character::complete::{char, multispace0},\n+        sequence::{delimited, preceded, terminated},\n+        IResult,\n+    };\n+    use router_env::{instrument, logger, tracing};\n+    use serde_json::Value;\n+    use thiserror::Error;\n+\n+    #[derive(Error, Debug)]\n+    pub enum InjectorError {\n+        #[error(\"Token replacement failed: {0}\")]\n+        TokenReplacementFailed(String),\n+        #[error(\"HTTP request failed\")]\n+        HttpRequestFailed,\n+        #[error(\"Serialization error: {0}\")]\n+        SerializationError(String),\n+        #[error(\"Invalid template: {0}\")]\n+        InvalidTemplate(String),\n+    }\n+\n+    #[instrument(skip_all)]\n+    pub async fn injector_core(\n+        request: InjectorRequest,\n+    ) -> error_stack::Result<InjectorResponse, InjectorError> {\n+        logger::info!(\"Starting injector_core processing\");\n+        let injector = Injector::new();\n+        injector.injector_core(request).await\n+    }\n+\n+    /// Represents a token reference found in a template string\n+    #[derive(Debug)]\n+    pub struct TokenReference {\n+        /// The field name to be replaced (without the {{$}} wrapper)\n+        pub field: String,\n+    }\n+\n+    /// Parses a single token reference from a string using nom parser combinators\n+    ///\n+    /// Expects tokens in the format `{{$field_name}}` where field_name contains\n+    /// only alphanumeric characters and underscores.\n+    pub fn parse_token(input: &str) -> IResult<&str, TokenReference> {\n+        let (input, field) = delimited(\n+            tag(\"{{\"),\n+            preceded(\n+                multispace0,\n+                preceded(\n+                    char('$'),\n+                    terminated(\n+                        take_while1(|c: char| c.is_alphanumeric() || c == '_'),\n+                        multispace0,\n+                    ),\n+                ),\n+            ),\n+            tag(\"}}\"),\n+        )(input)?;\n+        Ok((\n+            input,\n+            TokenReference {\n+                field: field.to_string(),\n+            },\n+        ))\n+    }\n+\n+    /// Finds all token references in a string using nom parser\n+    ///\n+    /// Scans through the entire input string and extracts all valid token references.\n+    /// Returns a vector of TokenReference structs containing the field names.\n+    pub fn find_all_tokens(input: &str) -> Vec<TokenReference> {\n+        let mut tokens = Vec::new();\n+        let mut current_input = input;\n+\n+        while !current_input.is_empty() {\n+            if let Ok((remaining, token_ref)) = parse_token(current_input) {\n+                tokens.push(token_ref);\n+                current_input = remaining;\n+            } else {\n+                // Move forward one character if no token found\n+                if let Some((_, rest)) = current_input.split_at_checked(1) {\n+                    current_input = rest;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        tokens\n+    }\n+\n+    /// Recursively searches for a field in vault data JSON structure\n+    ///\n+    /// Performs a depth-first search through the JSON object hierarchy to find\n+    /// a field with the specified name. Returns the first matching value found.\n+    pub fn find_field_recursively_in_vault_data(\n+        obj: &serde_json::Map<String, Value>,\n+        field_name: &str,\n+    ) -> Option<Value> {\n+        obj.get(field_name).cloned().or_else(|| {\n+            obj.values()\n+                .filter_map(|val| {\n+                    if let Value::Object(inner_obj) = val {\n+                        find_field_recursively_in_vault_data(inner_obj, field_name)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .next()\n+        })\n+    }\n+\n+    #[async_trait]\n+    pub trait TokenInjector {\n+        async fn injector_core(\n+            &self,\n+            request: InjectorRequest,\n+        ) -> error_stack::Result<InjectorResponse, InjectorError>;\n+    }\n+\n+    pub struct Injector;\n+\n+    impl Injector {\n+        pub fn new() -> Self {\n+            Self\n+        }\n+\n+        /// Processes a string template and replaces token references with vault data\n+        #[instrument(skip_all)]\n+        pub fn interpolate_string_template_with_vault_data(\n+            &self,\n+            template: String,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<String, InjectorError> {\n+            // Find all tokens using nom parser\n+            let tokens = find_all_tokens(&template);\n+            let mut result = template;\n+\n+            for token_ref in tokens {\n+                let extracted_field_value = self.extract_field_from_vault_data(\n+                    vault_data,\n+                    &token_ref.field,\n+                    vault_connector,\n+                )?;\n+                let token_str = match extracted_field_value {\n+                    Value::String(token_value) => token_value,\n+                    _ => serde_json::to_string(&extracted_field_value).unwrap_or_default(),\n+                };\n+\n+                // Replace the token in the result string\n+                let token_pattern = format!(\"{{{{${}}}}}\", token_ref.field);\n+                result = result.replace(&token_pattern, &token_str);\n+            }\n+\n+            Ok(result)\n+        }\n+\n+        #[instrument(skip_all)]\n+        pub fn interpolate_token_references_with_vault_data(\n+            &self,\n+            value: Value,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match value {\n+                Value::Object(obj) => {\n+                    let new_obj = obj\n+                        .into_iter()\n+                        .map(|(key, val)| {\n+                            self.interpolate_token_references_with_vault_data(\n+                                val,\n+                                vault_data,\n+                                vault_connector,\n+                            )\n+                            .map(|processed| (key, processed))\n+                        })\n+                        .collect::<error_stack::Result<serde_json::Map<_, _>, InjectorError>>()?;\n+                    Ok(Value::Object(new_obj))\n+                }\n+                Value::String(s) => {\n+                    let processed_string = self.interpolate_string_template_with_vault_data(\n+                        s,\n+                        vault_data,\n+                        vault_connector,\n+                    )?;\n+                    Ok(Value::String(processed_string))\n+                }\n+                _ => Ok(value),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn extract_field_from_vault_data(\n+            &self,\n+            vault_data: &Value,\n+            field_name: &str,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::debug!(\n+                \"Extracting field '{}' from vault data using vault type {:?}\",\n+                field_name,\n+                vault_connector\n+            );\n+\n+            match vault_data {\n+                Value::Object(obj) => {\n+                    let raw_value = find_field_recursively_in_vault_data(obj, field_name)\n+                        .ok_or_else(|| {\n+                            error_stack::Report::new(InjectorError::TokenReplacementFailed(\n+                                format!(\"Field '{field_name}' not found\"),\n+                            ))\n+                        })?;\n+\n+                    // Apply vault-specific token transformation\n+                    self.apply_vault_specific_transformation(raw_value, vault_connector, field_name)\n+                }\n+                _ => Err(error_stack::Report::new(\n+                    InjectorError::TokenReplacementFailed(\n+                        \"Vault data is not a valid JSON object\".to_string(),\n+                    ),\n+                )),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn apply_vault_specific_transformation(\n+            &self,\n+            extracted_field_value: Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+            field_name: &str,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match vault_connector {\n+                injector::types::VaultConnectors::VGS => {\n+                    logger::debug!(\n+                        \"VGS vault: Using direct token replacement for field '{}'\",\n+                        field_name\n+                    );\n+                    Ok(extracted_field_value)\n+                }\n+            }\n+        }\n+\n+        /// Makes an HTTP request to the connector endpoint\n+        ///\n+        /// Note: We cannot reuse the existing `call_connector_api` function from router services\n+        /// because it requires `SessionState` and is tightly coupled to the router's infrastructure.\n+        /// The injector crate is designed to be lightweight and independent, operating with\n+        /// minimal dependencies and without router-specific state management.\n+        #[instrument(skip_all)]\n+        async fn make_http_request(\n+            &self,\n+            config: &injector::ConnectionConfig,\n+            payload: &str,\n+            content_type: &ContentType,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::info!(\n+                method = ?config.http_method,\n+                base_url = %config.base_url,\n+                endpoint = %config.endpoint_path,\n+                content_type = ?content_type,\n+                payload_length = payload.len(),\n+                headers_count = config.headers.len(),\n+                \"Making HTTP request to connector\"\n+            );\n+            // Validate inputs first\n+            if config.endpoint_path.is_empty() {\n+                logger::error!(\"Endpoint path is empty\");\n+                return Err(error_stack::Report::new(InjectorError::InvalidTemplate(\n+                    \"Endpoint path cannot be empty\".to_string(),\n+                )));\n+            }\n+\n+            // Construct URL safely by joining base URL with endpoint path\n+            let url = config.base_url.join(&config.endpoint_path).map_err(|e| {\n+                logger::error!(\"Failed to join base URL with endpoint path: {}\", e);\n+                error_stack::Report::new(InjectorError::InvalidTemplate(format!(\n+                    \"Invalid URL construction: {e}\"\n+                )))\n+            })?;\n+\n+            logger::debug!(\"Constructed URL: {}\", url);\n+\n+            // Convert headers to common_utils Headers format safely\n+            let headers: Vec<(String, masking::Maskable<String>)> = config\n+                .headers\n+                .clone()\n+                .into_iter()\n+                .map(|(k, v)| (k, masking::Maskable::new_normal(v.expose().clone())))\n+                .collect();\n+\n+            // Determine method and request content\n+            let method = match config.http_method {\n+                injector::HttpMethod::GET => Method::Get,\n+                injector::HttpMethod::POST => Method::Post,\n+                injector::HttpMethod::PUT => Method::Put,\n+                injector::HttpMethod::PATCH => Method::Patch,\n+                injector::HttpMethod::DELETE => Method::Delete,\n+            };\n+\n+            // Determine request content based on content type with error handling\n+            let request_content = match content_type {\n+                ContentType::ApplicationJson => {\n+                    // Try to parse as JSON, fallback to raw string\n+                    match serde_json::from_str::<Value>(payload) {\n+                        Ok(json) => Some(RequestContent::Json(Box::new(json))),\n+                        Err(e) => {\n+                            logger::debug!(\n+                                \"Failed to parse payload as JSON: {}, falling back to raw bytes\",\n+                                e\n+                            );\n+                            Some(RequestContent::RawBytes(payload.as_bytes().to_vec()))\n+                        }\n+                    }\n+                }\n+                ContentType::ApplicationXWwwFormUrlencoded => {\n+                    // Parse form data safely\n+                    let form_data: HashMap<String, String> =\n+                        url::form_urlencoded::parse(payload.as_bytes())\n+                            .into_owned()\n+                            .collect();\n+                    Some(RequestContent::FormUrlEncoded(Box::new(form_data)))\n+                }\n+                ContentType::ApplicationXml | ContentType::TextXml => {\n+                    Some(RequestContent::RawBytes(payload.as_bytes().to_vec()))\n+                }\n+                ContentType::TextPlain => {\n+                    Some(RequestContent::RawBytes(payload.as_bytes().to_vec()))\n+                }\n+            };\n+\n+            // Build request safely\n+            let mut request_builder = RequestBuilder::new()\n+                .method(method)\n+                .url(url.as_str())\n+                .headers(headers);\n+\n+            if let Some(content) = request_content {\n+                request_builder = request_builder.set_body(content);\n+            }\n+\n+            // Add certificate configuration if provided\n+            if let Some(cert_content) = &config.client_cert {\n+                logger::debug!(\"Adding client certificate content\");\n+                request_builder = request_builder.add_certificate(Some(cert_content.clone()));\n+            }\n+\n+            if let Some(key_content) = &config.client_key {\n+                logger::debug!(\"Adding client private key content\");\n+                request_builder = request_builder.add_certificate_key(Some(key_content.clone()));\n+            }\n+\n+            if let Some(ca_content) = &config.ca_cert {\n+                logger::debug!(\"Adding CA certificate content\");\n+                request_builder = request_builder.add_ca_certificate_pem(Some(ca_content.clone()));\n+            }\n+\n+            // Log certificate configuration (but not the actual content)\n+            logger::info!(\n+                has_client_cert = config.client_cert.is_some(),\n+                has_client_key = config.client_key.is_some(),\n+                has_ca_cert = config.ca_cert.is_some(),\n+                insecure = config.insecure.unwrap_or(false),\n+                cert_format = ?config.cert_format,\n+                \"Certificate configuration applied\"\n+            );\n+\n+            let request = request_builder.build();\n+\n+            let proxy = if let Some(proxy_url) = &config.proxy_url {\n+                logger::debug!(\"Using proxy: {}\", proxy_url);\n+                // Determine if it's HTTP or HTTPS proxy based on URL scheme\n+                if proxy_url.scheme() == \"https\" {\n+                    Proxy {\n+                        http_url: None,\n+                        https_url: Some(proxy_url.to_string()),\n+                        idle_pool_connection_timeout: Some(90),\n+                        bypass_proxy_hosts: None,\n+                    }\n+                } else {\n+                    Proxy {\n+                        http_url: Some(proxy_url.to_string()),\n+                        https_url: None,\n+                        idle_pool_connection_timeout: Some(90),\n+                        bypass_proxy_hosts: None,\n+                    }\n+                }\n+            } else {\n+                logger::debug!(\"No proxy configured, using direct connection\");\n+                Proxy::default()\n+            };\n+\n+            // Send request using external_services http_client\n+            logger::debug!(\"Sending HTTP request to connector\");\n+            let response = http_client::send_request(&proxy, request, None)\n+                .await\n+                .change_context(InjectorError::HttpRequestFailed)?;\n+\n+            logger::info!(\n+                status_code = response.status().as_u16(),\n+                \"Received response from connector\"\n+            );\n+\n+            let response_text = response\n+                .text()\n+                .await\n+                .change_context(InjectorError::HttpRequestFailed)?;\n+\n+            // Validate response text length to prevent potential memory issues\n+            if response_text.len() > 10_000_000 {\n+                // 10MB limit\n+                logger::error!(\n+                    response_length = response_text.len(),\n+                    \"Response from connector is too large, potential DoS or memory exhaustion\"\n+                );\n+                return Err(error_stack::Report::new(InjectorError::HttpRequestFailed));",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2290793217",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8959,
        "pr_file": "crates/injector/src/injector.rs",
        "discussion_id": "2290793217",
        "commented_code": "@@ -0,0 +1,791 @@\n+#[cfg(feature = \"v2\")]\n+pub mod core {\n+    use std::collections::HashMap;\n+\n+    use api_models::injector::{ContentType, InjectorRequest, InjectorResponse};\n+    use async_trait::async_trait;\n+    use common_utils::request::{Method, RequestBuilder, RequestContent};\n+    use error_stack::ResultExt;\n+    use external_services::http_client;\n+    use hyperswitch_domain_models::injector;\n+    use hyperswitch_interfaces::types::Proxy;\n+    use masking::{self, ExposeInterface};\n+    use nom::{\n+        bytes::complete::{tag, take_while1},\n+        character::complete::{char, multispace0},\n+        sequence::{delimited, preceded, terminated},\n+        IResult,\n+    };\n+    use router_env::{instrument, logger, tracing};\n+    use serde_json::Value;\n+    use thiserror::Error;\n+\n+    #[derive(Error, Debug)]\n+    pub enum InjectorError {\n+        #[error(\"Token replacement failed: {0}\")]\n+        TokenReplacementFailed(String),\n+        #[error(\"HTTP request failed\")]\n+        HttpRequestFailed,\n+        #[error(\"Serialization error: {0}\")]\n+        SerializationError(String),\n+        #[error(\"Invalid template: {0}\")]\n+        InvalidTemplate(String),\n+    }\n+\n+    #[instrument(skip_all)]\n+    pub async fn injector_core(\n+        request: InjectorRequest,\n+    ) -> error_stack::Result<InjectorResponse, InjectorError> {\n+        logger::info!(\"Starting injector_core processing\");\n+        let injector = Injector::new();\n+        injector.injector_core(request).await\n+    }\n+\n+    /// Represents a token reference found in a template string\n+    #[derive(Debug)]\n+    pub struct TokenReference {\n+        /// The field name to be replaced (without the {{$}} wrapper)\n+        pub field: String,\n+    }\n+\n+    /// Parses a single token reference from a string using nom parser combinators\n+    ///\n+    /// Expects tokens in the format `{{$field_name}}` where field_name contains\n+    /// only alphanumeric characters and underscores.\n+    pub fn parse_token(input: &str) -> IResult<&str, TokenReference> {\n+        let (input, field) = delimited(\n+            tag(\"{{\"),\n+            preceded(\n+                multispace0,\n+                preceded(\n+                    char('$'),\n+                    terminated(\n+                        take_while1(|c: char| c.is_alphanumeric() || c == '_'),\n+                        multispace0,\n+                    ),\n+                ),\n+            ),\n+            tag(\"}}\"),\n+        )(input)?;\n+        Ok((\n+            input,\n+            TokenReference {\n+                field: field.to_string(),\n+            },\n+        ))\n+    }\n+\n+    /// Finds all token references in a string using nom parser\n+    ///\n+    /// Scans through the entire input string and extracts all valid token references.\n+    /// Returns a vector of TokenReference structs containing the field names.\n+    pub fn find_all_tokens(input: &str) -> Vec<TokenReference> {\n+        let mut tokens = Vec::new();\n+        let mut current_input = input;\n+\n+        while !current_input.is_empty() {\n+            if let Ok((remaining, token_ref)) = parse_token(current_input) {\n+                tokens.push(token_ref);\n+                current_input = remaining;\n+            } else {\n+                // Move forward one character if no token found\n+                if let Some((_, rest)) = current_input.split_at_checked(1) {\n+                    current_input = rest;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        tokens\n+    }\n+\n+    /// Recursively searches for a field in vault data JSON structure\n+    ///\n+    /// Performs a depth-first search through the JSON object hierarchy to find\n+    /// a field with the specified name. Returns the first matching value found.\n+    pub fn find_field_recursively_in_vault_data(\n+        obj: &serde_json::Map<String, Value>,\n+        field_name: &str,\n+    ) -> Option<Value> {\n+        obj.get(field_name).cloned().or_else(|| {\n+            obj.values()\n+                .filter_map(|val| {\n+                    if let Value::Object(inner_obj) = val {\n+                        find_field_recursively_in_vault_data(inner_obj, field_name)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .next()\n+        })\n+    }\n+\n+    #[async_trait]\n+    pub trait TokenInjector {\n+        async fn injector_core(\n+            &self,\n+            request: InjectorRequest,\n+        ) -> error_stack::Result<InjectorResponse, InjectorError>;\n+    }\n+\n+    pub struct Injector;\n+\n+    impl Injector {\n+        pub fn new() -> Self {\n+            Self\n+        }\n+\n+        /// Processes a string template and replaces token references with vault data\n+        #[instrument(skip_all)]\n+        pub fn interpolate_string_template_with_vault_data(\n+            &self,\n+            template: String,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<String, InjectorError> {\n+            // Find all tokens using nom parser\n+            let tokens = find_all_tokens(&template);\n+            let mut result = template;\n+\n+            for token_ref in tokens {\n+                let extracted_field_value = self.extract_field_from_vault_data(\n+                    vault_data,\n+                    &token_ref.field,\n+                    vault_connector,\n+                )?;\n+                let token_str = match extracted_field_value {\n+                    Value::String(token_value) => token_value,\n+                    _ => serde_json::to_string(&extracted_field_value).unwrap_or_default(),\n+                };\n+\n+                // Replace the token in the result string\n+                let token_pattern = format!(\"{{{{${}}}}}\", token_ref.field);\n+                result = result.replace(&token_pattern, &token_str);\n+            }\n+\n+            Ok(result)\n+        }\n+\n+        #[instrument(skip_all)]\n+        pub fn interpolate_token_references_with_vault_data(\n+            &self,\n+            value: Value,\n+            vault_data: &Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match value {\n+                Value::Object(obj) => {\n+                    let new_obj = obj\n+                        .into_iter()\n+                        .map(|(key, val)| {\n+                            self.interpolate_token_references_with_vault_data(\n+                                val,\n+                                vault_data,\n+                                vault_connector,\n+                            )\n+                            .map(|processed| (key, processed))\n+                        })\n+                        .collect::<error_stack::Result<serde_json::Map<_, _>, InjectorError>>()?;\n+                    Ok(Value::Object(new_obj))\n+                }\n+                Value::String(s) => {\n+                    let processed_string = self.interpolate_string_template_with_vault_data(\n+                        s,\n+                        vault_data,\n+                        vault_connector,\n+                    )?;\n+                    Ok(Value::String(processed_string))\n+                }\n+                _ => Ok(value),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn extract_field_from_vault_data(\n+            &self,\n+            vault_data: &Value,\n+            field_name: &str,\n+            vault_connector: &injector::types::VaultConnectors,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::debug!(\n+                \"Extracting field '{}' from vault data using vault type {:?}\",\n+                field_name,\n+                vault_connector\n+            );\n+\n+            match vault_data {\n+                Value::Object(obj) => {\n+                    let raw_value = find_field_recursively_in_vault_data(obj, field_name)\n+                        .ok_or_else(|| {\n+                            error_stack::Report::new(InjectorError::TokenReplacementFailed(\n+                                format!(\"Field '{field_name}' not found\"),\n+                            ))\n+                        })?;\n+\n+                    // Apply vault-specific token transformation\n+                    self.apply_vault_specific_transformation(raw_value, vault_connector, field_name)\n+                }\n+                _ => Err(error_stack::Report::new(\n+                    InjectorError::TokenReplacementFailed(\n+                        \"Vault data is not a valid JSON object\".to_string(),\n+                    ),\n+                )),\n+            }\n+        }\n+\n+        #[instrument(skip_all)]\n+        fn apply_vault_specific_transformation(\n+            &self,\n+            extracted_field_value: Value,\n+            vault_connector: &injector::types::VaultConnectors,\n+            field_name: &str,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            match vault_connector {\n+                injector::types::VaultConnectors::VGS => {\n+                    logger::debug!(\n+                        \"VGS vault: Using direct token replacement for field '{}'\",\n+                        field_name\n+                    );\n+                    Ok(extracted_field_value)\n+                }\n+            }\n+        }\n+\n+        /// Makes an HTTP request to the connector endpoint\n+        ///\n+        /// Note: We cannot reuse the existing `call_connector_api` function from router services\n+        /// because it requires `SessionState` and is tightly coupled to the router's infrastructure.\n+        /// The injector crate is designed to be lightweight and independent, operating with\n+        /// minimal dependencies and without router-specific state management.\n+        #[instrument(skip_all)]\n+        async fn make_http_request(\n+            &self,\n+            config: &injector::ConnectionConfig,\n+            payload: &str,\n+            content_type: &ContentType,\n+        ) -> error_stack::Result<Value, InjectorError> {\n+            logger::info!(\n+                method = ?config.http_method,\n+                base_url = %config.base_url,\n+                endpoint = %config.endpoint_path,\n+                content_type = ?content_type,\n+                payload_length = payload.len(),\n+                headers_count = config.headers.len(),\n+                \"Making HTTP request to connector\"\n+            );\n+            // Validate inputs first\n+            if config.endpoint_path.is_empty() {\n+                logger::error!(\"Endpoint path is empty\");\n+                return Err(error_stack::Report::new(InjectorError::InvalidTemplate(\n+                    \"Endpoint path cannot be empty\".to_string(),\n+                )));\n+            }\n+\n+            // Construct URL safely by joining base URL with endpoint path\n+            let url = config.base_url.join(&config.endpoint_path).map_err(|e| {\n+                logger::error!(\"Failed to join base URL with endpoint path: {}\", e);\n+                error_stack::Report::new(InjectorError::InvalidTemplate(format!(\n+                    \"Invalid URL construction: {e}\"\n+                )))\n+            })?;\n+\n+            logger::debug!(\"Constructed URL: {}\", url);\n+\n+            // Convert headers to common_utils Headers format safely\n+            let headers: Vec<(String, masking::Maskable<String>)> = config\n+                .headers\n+                .clone()\n+                .into_iter()\n+                .map(|(k, v)| (k, masking::Maskable::new_normal(v.expose().clone())))\n+                .collect();\n+\n+            // Determine method and request content\n+            let method = match config.http_method {\n+                injector::HttpMethod::GET => Method::Get,\n+                injector::HttpMethod::POST => Method::Post,\n+                injector::HttpMethod::PUT => Method::Put,\n+                injector::HttpMethod::PATCH => Method::Patch,\n+                injector::HttpMethod::DELETE => Method::Delete,\n+            };\n+\n+            // Determine request content based on content type with error handling\n+            let request_content = match content_type {\n+                ContentType::ApplicationJson => {\n+                    // Try to parse as JSON, fallback to raw string\n+                    match serde_json::from_str::<Value>(payload) {\n+                        Ok(json) => Some(RequestContent::Json(Box::new(json))),\n+                        Err(e) => {\n+                            logger::debug!(\n+                                \"Failed to parse payload as JSON: {}, falling back to raw bytes\",\n+                                e\n+                            );\n+                            Some(RequestContent::RawBytes(payload.as_bytes().to_vec()))\n+                        }\n+                    }\n+                }\n+                ContentType::ApplicationXWwwFormUrlencoded => {\n+                    // Parse form data safely\n+                    let form_data: HashMap<String, String> =\n+                        url::form_urlencoded::parse(payload.as_bytes())\n+                            .into_owned()\n+                            .collect();\n+                    Some(RequestContent::FormUrlEncoded(Box::new(form_data)))\n+                }\n+                ContentType::ApplicationXml | ContentType::TextXml => {\n+                    Some(RequestContent::RawBytes(payload.as_bytes().to_vec()))\n+                }\n+                ContentType::TextPlain => {\n+                    Some(RequestContent::RawBytes(payload.as_bytes().to_vec()))\n+                }\n+            };\n+\n+            // Build request safely\n+            let mut request_builder = RequestBuilder::new()\n+                .method(method)\n+                .url(url.as_str())\n+                .headers(headers);\n+\n+            if let Some(content) = request_content {\n+                request_builder = request_builder.set_body(content);\n+            }\n+\n+            // Add certificate configuration if provided\n+            if let Some(cert_content) = &config.client_cert {\n+                logger::debug!(\"Adding client certificate content\");\n+                request_builder = request_builder.add_certificate(Some(cert_content.clone()));\n+            }\n+\n+            if let Some(key_content) = &config.client_key {\n+                logger::debug!(\"Adding client private key content\");\n+                request_builder = request_builder.add_certificate_key(Some(key_content.clone()));\n+            }\n+\n+            if let Some(ca_content) = &config.ca_cert {\n+                logger::debug!(\"Adding CA certificate content\");\n+                request_builder = request_builder.add_ca_certificate_pem(Some(ca_content.clone()));\n+            }\n+\n+            // Log certificate configuration (but not the actual content)\n+            logger::info!(\n+                has_client_cert = config.client_cert.is_some(),\n+                has_client_key = config.client_key.is_some(),\n+                has_ca_cert = config.ca_cert.is_some(),\n+                insecure = config.insecure.unwrap_or(false),\n+                cert_format = ?config.cert_format,\n+                \"Certificate configuration applied\"\n+            );\n+\n+            let request = request_builder.build();\n+\n+            let proxy = if let Some(proxy_url) = &config.proxy_url {\n+                logger::debug!(\"Using proxy: {}\", proxy_url);\n+                // Determine if it's HTTP or HTTPS proxy based on URL scheme\n+                if proxy_url.scheme() == \"https\" {\n+                    Proxy {\n+                        http_url: None,\n+                        https_url: Some(proxy_url.to_string()),\n+                        idle_pool_connection_timeout: Some(90),\n+                        bypass_proxy_hosts: None,\n+                    }\n+                } else {\n+                    Proxy {\n+                        http_url: Some(proxy_url.to_string()),\n+                        https_url: None,\n+                        idle_pool_connection_timeout: Some(90),\n+                        bypass_proxy_hosts: None,\n+                    }\n+                }\n+            } else {\n+                logger::debug!(\"No proxy configured, using direct connection\");\n+                Proxy::default()\n+            };\n+\n+            // Send request using external_services http_client\n+            logger::debug!(\"Sending HTTP request to connector\");\n+            let response = http_client::send_request(&proxy, request, None)\n+                .await\n+                .change_context(InjectorError::HttpRequestFailed)?;\n+\n+            logger::info!(\n+                status_code = response.status().as_u16(),\n+                \"Received response from connector\"\n+            );\n+\n+            let response_text = response\n+                .text()\n+                .await\n+                .change_context(InjectorError::HttpRequestFailed)?;\n+\n+            // Validate response text length to prevent potential memory issues\n+            if response_text.len() > 10_000_000 {\n+                // 10MB limit\n+                logger::error!(\n+                    response_length = response_text.len(),\n+                    \"Response from connector is too large, potential DoS or memory exhaustion\"\n+                );\n+                return Err(error_stack::Report::new(InjectorError::HttpRequestFailed));",
        "comment_created_at": "2025-08-21T11:46:56+00:00",
        "comment_author": "jarnura",
        "comment_body": "instead of return use ? pattern to throw errors",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2297912617",
    "pr_number": 8959,
    "pr_file": "crates/injector/src/injector.rs",
    "created_at": "2025-08-25T12:00:04+00:00",
    "commented_code": "+pub mod core {\n+    use std::collections::HashMap;\n+\n+    use async_trait::async_trait;\n+    use common_utils::request::{Method, RequestBuilder, RequestContent};\n+    use error_stack::ResultExt;\n+    use masking::{self, ExposeInterface};\n+    use nom::{\n+        bytes::complete::{tag, take_while1},\n+        character::complete::{char, multispace0},\n+        sequence::{delimited, preceded, terminated},\n+        IResult,\n+    };\n+    use router_env::{instrument, logger, tracing};\n+    use serde_json::Value;\n+    use thiserror::Error;\n+\n+    use crate as injector_types;\n+    use crate::{ContentType, InjectorRequest, InjectorResponse};\n+\n+    impl From<injector_types::HttpMethod> for Method {\n+        fn from(method: injector_types::HttpMethod) -> Self {\n+            match method {\n+                injector_types::HttpMethod::GET => Method::Get,\n+                injector_types::HttpMethod::POST => Method::Post,\n+                injector_types::HttpMethod::PUT => Method::Put,\n+                injector_types::HttpMethod::PATCH => Method::Patch,\n+                injector_types::HttpMethod::DELETE => Method::Delete,\n+            }\n+        }\n+    }\n+\n+    /// Proxy configuration structure (copied from hyperswitch_interfaces to make injector standalone)\n+    #[derive(Debug, serde::Deserialize, Clone)]\n+    #[serde(default)]\n+    pub struct Proxy {\n+        /// The URL of the HTTP proxy server.\n+        pub http_url: Option<String>,\n+        /// The URL of the HTTPS proxy server.\n+        pub https_url: Option<String>,\n+        /// The timeout duration (in seconds) for idle connections in the proxy pool.\n+        pub idle_pool_connection_timeout: Option<u64>,\n+        /// A comma-separated list of hosts that should bypass the proxy.\n+        pub bypass_proxy_hosts: Option<String>,\n+    }\n+\n+    impl Default for Proxy {\n+        fn default() -> Self {\n+            Self {\n+                http_url: Default::default(),\n+                https_url: Default::default(),\n+                idle_pool_connection_timeout: Some(90),\n+                bypass_proxy_hosts: Default::default(),\n+            }\n+        }\n+    }\n+\n+    /// Simplified HTTP client for injector (copied from external_services to make injector standalone)\n+    /// This is a minimal implementation that covers the essential functionality needed by injector\n+    #[instrument(skip_all)]\n+    pub async fn send_request(\n+        client_proxy: &Proxy,\n+        request: common_utils::request::Request,\n+        _option_timeout_secs: Option<u64>,\n+    ) -> error_stack::Result<reqwest::Response, InjectorError> {\n+        logger::info!(\"Making HTTP request using standalone injector HTTP client\");\n+\n+        // Create reqwest client with proxy configuration\n+        let mut client_builder = reqwest::Client::builder();\n+\n+        // Configure proxy if provided\n+        if let Some(proxy_url) = &client_proxy.https_url {\n+            let proxy = reqwest::Proxy::https(proxy_url).map_err(|e| {\n+                logger::error!(\"Failed to configure HTTPS proxy: {}\", e);\n+                error_stack::Report::new(InjectorError::HttpRequestFailed)\n+            })?;\n+            client_builder = client_builder.proxy(proxy);\n+        }\n+\n+        if let Some(proxy_url) = &client_proxy.http_url {\n+            let proxy = reqwest::Proxy::http(proxy_url).map_err(|e| {\n+                logger::error!(\"Failed to configure HTTP proxy: {}\", e);\n+                error_stack::Report::new(InjectorError::HttpRequestFailed)\n+            })?;\n+            client_builder = client_builder.proxy(proxy);\n+        }\n+\n+        let client = client_builder.build().map_err(|e| {\n+            logger::error!(\"Failed to build HTTP client: {}\", e);\n+            error_stack::Report::new(InjectorError::HttpRequestFailed)\n+        })?;\n+\n+        // Build the request\n+        let method = match request.method {\n+            Method::Get => reqwest::Method::GET,\n+            Method::Post => reqwest::Method::POST,\n+            Method::Put => reqwest::Method::PUT,\n+            Method::Patch => reqwest::Method::PATCH,\n+            Method::Delete => reqwest::Method::DELETE,\n+        };\n+\n+        let mut req_builder = client.request(method, &request.url);\n+\n+        // Add headers\n+        for (key, value) in &request.headers {\n+            let header_value = match value {\n+                masking::Maskable::Masked(secret) => secret.clone().expose(),\n+                masking::Maskable::Normal(normal) => normal.clone(),\n+            };\n+            req_builder = req_builder.header(key, header_value);\n+        }\n+\n+        // Add body if present\n+        if let Some(body) = request.body {\n+            match body {\n+                RequestContent::Json(payload) => {\n+                    req_builder = req_builder.json(&payload);\n+                }\n+                RequestContent::FormUrlEncoded(payload) => {\n+                    req_builder = req_builder.form(&payload);\n+                }\n+                RequestContent::RawBytes(payload) => {\n+                    req_builder = req_builder.body(payload);\n+                }\n+                _ => {\n+                    logger::warn!(\"Unsupported request content type, using raw bytes\");",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2297912617",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8959,
        "pr_file": "crates/injector/src/injector.rs",
        "discussion_id": "2297912617",
        "commented_code": "@@ -0,0 +1,887 @@\n+pub mod core {\n+    use std::collections::HashMap;\n+\n+    use async_trait::async_trait;\n+    use common_utils::request::{Method, RequestBuilder, RequestContent};\n+    use error_stack::ResultExt;\n+    use masking::{self, ExposeInterface};\n+    use nom::{\n+        bytes::complete::{tag, take_while1},\n+        character::complete::{char, multispace0},\n+        sequence::{delimited, preceded, terminated},\n+        IResult,\n+    };\n+    use router_env::{instrument, logger, tracing};\n+    use serde_json::Value;\n+    use thiserror::Error;\n+\n+    use crate as injector_types;\n+    use crate::{ContentType, InjectorRequest, InjectorResponse};\n+\n+    impl From<injector_types::HttpMethod> for Method {\n+        fn from(method: injector_types::HttpMethod) -> Self {\n+            match method {\n+                injector_types::HttpMethod::GET => Method::Get,\n+                injector_types::HttpMethod::POST => Method::Post,\n+                injector_types::HttpMethod::PUT => Method::Put,\n+                injector_types::HttpMethod::PATCH => Method::Patch,\n+                injector_types::HttpMethod::DELETE => Method::Delete,\n+            }\n+        }\n+    }\n+\n+    /// Proxy configuration structure (copied from hyperswitch_interfaces to make injector standalone)\n+    #[derive(Debug, serde::Deserialize, Clone)]\n+    #[serde(default)]\n+    pub struct Proxy {\n+        /// The URL of the HTTP proxy server.\n+        pub http_url: Option<String>,\n+        /// The URL of the HTTPS proxy server.\n+        pub https_url: Option<String>,\n+        /// The timeout duration (in seconds) for idle connections in the proxy pool.\n+        pub idle_pool_connection_timeout: Option<u64>,\n+        /// A comma-separated list of hosts that should bypass the proxy.\n+        pub bypass_proxy_hosts: Option<String>,\n+    }\n+\n+    impl Default for Proxy {\n+        fn default() -> Self {\n+            Self {\n+                http_url: Default::default(),\n+                https_url: Default::default(),\n+                idle_pool_connection_timeout: Some(90),\n+                bypass_proxy_hosts: Default::default(),\n+            }\n+        }\n+    }\n+\n+    /// Simplified HTTP client for injector (copied from external_services to make injector standalone)\n+    /// This is a minimal implementation that covers the essential functionality needed by injector\n+    #[instrument(skip_all)]\n+    pub async fn send_request(\n+        client_proxy: &Proxy,\n+        request: common_utils::request::Request,\n+        _option_timeout_secs: Option<u64>,\n+    ) -> error_stack::Result<reqwest::Response, InjectorError> {\n+        logger::info!(\"Making HTTP request using standalone injector HTTP client\");\n+\n+        // Create reqwest client with proxy configuration\n+        let mut client_builder = reqwest::Client::builder();\n+\n+        // Configure proxy if provided\n+        if let Some(proxy_url) = &client_proxy.https_url {\n+            let proxy = reqwest::Proxy::https(proxy_url).map_err(|e| {\n+                logger::error!(\"Failed to configure HTTPS proxy: {}\", e);\n+                error_stack::Report::new(InjectorError::HttpRequestFailed)\n+            })?;\n+            client_builder = client_builder.proxy(proxy);\n+        }\n+\n+        if let Some(proxy_url) = &client_proxy.http_url {\n+            let proxy = reqwest::Proxy::http(proxy_url).map_err(|e| {\n+                logger::error!(\"Failed to configure HTTP proxy: {}\", e);\n+                error_stack::Report::new(InjectorError::HttpRequestFailed)\n+            })?;\n+            client_builder = client_builder.proxy(proxy);\n+        }\n+\n+        let client = client_builder.build().map_err(|e| {\n+            logger::error!(\"Failed to build HTTP client: {}\", e);\n+            error_stack::Report::new(InjectorError::HttpRequestFailed)\n+        })?;\n+\n+        // Build the request\n+        let method = match request.method {\n+            Method::Get => reqwest::Method::GET,\n+            Method::Post => reqwest::Method::POST,\n+            Method::Put => reqwest::Method::PUT,\n+            Method::Patch => reqwest::Method::PATCH,\n+            Method::Delete => reqwest::Method::DELETE,\n+        };\n+\n+        let mut req_builder = client.request(method, &request.url);\n+\n+        // Add headers\n+        for (key, value) in &request.headers {\n+            let header_value = match value {\n+                masking::Maskable::Masked(secret) => secret.clone().expose(),\n+                masking::Maskable::Normal(normal) => normal.clone(),\n+            };\n+            req_builder = req_builder.header(key, header_value);\n+        }\n+\n+        // Add body if present\n+        if let Some(body) = request.body {\n+            match body {\n+                RequestContent::Json(payload) => {\n+                    req_builder = req_builder.json(&payload);\n+                }\n+                RequestContent::FormUrlEncoded(payload) => {\n+                    req_builder = req_builder.form(&payload);\n+                }\n+                RequestContent::RawBytes(payload) => {\n+                    req_builder = req_builder.body(payload);\n+                }\n+                _ => {\n+                    logger::warn!(\"Unsupported request content type, using raw bytes\");",
        "comment_created_at": "2025-08-25T12:00:04+00:00",
        "comment_author": "prasunna09",
        "comment_body": "throw an error instead of warning",
        "pr_file_module": null
      }
    ]
  }
]