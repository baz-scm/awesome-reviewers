[
  {
    "discussion_id": "2354853818",
    "pr_number": 9083,
    "pr_file": "crates/router/src/core/payments/transformers.rs",
    "created_at": "2025-09-17T09:13:08+00:00",
    "commented_code": "type Error = error_stack::Report<errors::ApiErrorResponse>;\n \n     fn try_from(additional_data: PaymentAdditionalData<'_, F>) -> Result<Self, Self::Error> {\n-        todo!()\n+        use masking::ExposeOptionInterface;",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2354853818",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9083,
        "pr_file": "crates/router/src/core/payments/transformers.rs",
        "discussion_id": "2354853818",
        "commented_code": "@@ -4550,7 +4722,57 @@ impl<F: Clone> TryFrom<PaymentAdditionalData<'_, F>> for types::PaymentsCancelDa\n     type Error = error_stack::Report<errors::ApiErrorResponse>;\n \n     fn try_from(additional_data: PaymentAdditionalData<'_, F>) -> Result<Self, Self::Error> {\n-        todo!()\n+        use masking::ExposeOptionInterface;",
        "comment_created_at": "2025-09-17T09:13:08+00:00",
        "comment_author": "prasunna09",
        "comment_body": "move it to the top where all imports are present",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2286405045",
    "pr_number": 8831,
    "pr_file": "crates/diesel_models/src/query/hyperswitch_ai_interaction.rs",
    "created_at": "2025-08-19T21:44:45+00:00",
    "commented_code": "+use diesel::{associations::HasTable, ExpressionMethods};\n+\n+use crate::{\n+    hyperswitch_ai_interaction::*, query::generics, schema::hyperswitch_ai_interaction::dsl,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2286405045",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8831,
        "pr_file": "crates/diesel_models/src/query/hyperswitch_ai_interaction.rs",
        "discussion_id": "2286405045",
        "commented_code": "@@ -0,0 +1,30 @@\n+use diesel::{associations::HasTable, ExpressionMethods};\n+\n+use crate::{\n+    hyperswitch_ai_interaction::*, query::generics, schema::hyperswitch_ai_interaction::dsl,",
        "comment_created_at": "2025-08-19T21:44:45+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Nit: Try to avoid wildcard imports.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2288303823",
    "pr_number": 8831,
    "pr_file": "crates/common_utils/src/consts.rs",
    "created_at": "2025-08-20T14:06:26+00:00",
    "commented_code": "/// API client request timeout for ai service (in seconds)\n pub const REQUEST_TIME_OUT_FOR_AI_SERVICE: u64 = 120;\n+\n+/// Default limit for list operations (can be used across different entities)\n+pub const DEFAULT_LIST_LIMIT: i64 = 100;\n+\n+/// Default offset for list operations (can be used across different entities)\n+pub const DEFAULT_LIST_OFFSET: i64 = 0;",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2288303823",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8831,
        "pr_file": "crates/common_utils/src/consts.rs",
        "discussion_id": "2288303823",
        "commented_code": "@@ -197,3 +197,9 @@ pub const REQUEST_TIME_OUT: u64 = 30;\n \n /// API client request timeout for ai service (in seconds)\n pub const REQUEST_TIME_OUT_FOR_AI_SERVICE: u64 = 120;\n+\n+/// Default limit for list operations (can be used across different entities)\n+pub const DEFAULT_LIST_LIMIT: i64 = 100;\n+\n+/// Default offset for list operations (can be used across different entities)\n+pub const DEFAULT_LIST_OFFSET: i64 = 0;",
        "comment_created_at": "2025-08-20T14:06:26+00:00",
        "comment_author": "SanchithHegde",
        "comment_body": "Since this is not being used anywhere other than the chat related code, should we consider moving these constants to the chat module?",
        "pr_file_module": null
      },
      {
        "comment_id": "2292365455",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8831,
        "pr_file": "crates/common_utils/src/consts.rs",
        "discussion_id": "2288303823",
        "commented_code": "@@ -197,3 +197,9 @@ pub const REQUEST_TIME_OUT: u64 = 30;\n \n /// API client request timeout for ai service (in seconds)\n pub const REQUEST_TIME_OUT_FOR_AI_SERVICE: u64 = 120;\n+\n+/// Default limit for list operations (can be used across different entities)\n+pub const DEFAULT_LIST_LIMIT: i64 = 100;\n+\n+/// Default offset for list operations (can be used across different entities)\n+pub const DEFAULT_LIST_OFFSET: i64 = 0;",
        "comment_created_at": "2025-08-21T23:44:50+00:00",
        "comment_author": "apoorvdixit88",
        "comment_body": "Since every time we create something new, we usually move it to the respective domain/module, I thought of keeping this as a default so that there\u2019s a baseline value to consider. This way, it can be utilised in cases where the value isn\u2019t supposed to be new feature-specific, rather than duplicating defaults across modules.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "1933755523",
    "pr_number": 7133,
    "pr_file": "crates/router/src/core/payments/helpers.rs",
    "created_at": "2025-01-29T11:59:52+00:00",
    "commented_code": "Ok(())\n }\n+\n+pub fn get_meta_tags_html(payment_details: &api_models::payments::PaymentLinkDetails) -> String {\n+    format!(\n+        r#\"<meta property=\"og:title\" content=\"Payment request from {0}\"/>\n+        <meta property=\"og:description\" content=\"{1}\"/>\"#,\n+        payment_details.merchant_name.clone(),\n+        payment_details\n+            .merchant_description\n+            .clone()\n+            .unwrap_or_default()\n+    )\n+}\n+\n+pub fn is_secure_payment_link_request(\n+    request_headers: &header::HeaderMap,\n+    payment_link: &PaymentLink,\n+    payment_link_config: &api_models::admin::PaymentLinkConfig,\n+) -> RouterResult<bool> {\n+    match request_headers\n+        .get(\"sec-fetch-dest\")\n+        .and_then(|v| v.to_str().ok())\n+    {\n+        Some(\"iframe\") => {\n+            let link_id = payment_link.payment_link_id.clone();\n+            let allowed_domains = payment_link_config\n+                .allowed_domains\n+                .clone()\n+                .ok_or(report!(errors::ApiErrorResponse::InvalidRequestUrl))\n+                .attach_printable_lazy(|| {\n+                    format!(\n+                        \"Payment link was not generated for {}\nmissing allowed_domains\",\n+                        link_id\n+                    )\n+                })?;\n+\n+            // Validate origin / referer",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "1933755523",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 7133,
        "pr_file": "crates/router/src/core/payments/helpers.rs",
        "discussion_id": "1933755523",
        "commented_code": "@@ -6389,3 +6394,180 @@ pub async fn validate_allowed_payment_method_types_request(\n \n     Ok(())\n }\n+\n+pub fn get_meta_tags_html(payment_details: &api_models::payments::PaymentLinkDetails) -> String {\n+    format!(\n+        r#\"<meta property=\"og:title\" content=\"Payment request from {0}\"/>\n+        <meta property=\"og:description\" content=\"{1}\"/>\"#,\n+        payment_details.merchant_name.clone(),\n+        payment_details\n+            .merchant_description\n+            .clone()\n+            .unwrap_or_default()\n+    )\n+}\n+\n+pub fn is_secure_payment_link_request(\n+    request_headers: &header::HeaderMap,\n+    payment_link: &PaymentLink,\n+    payment_link_config: &api_models::admin::PaymentLinkConfig,\n+) -> RouterResult<bool> {\n+    match request_headers\n+        .get(\"sec-fetch-dest\")\n+        .and_then(|v| v.to_str().ok())\n+    {\n+        Some(\"iframe\") => {\n+            let link_id = payment_link.payment_link_id.clone();\n+            let allowed_domains = payment_link_config\n+                .allowed_domains\n+                .clone()\n+                .ok_or(report!(errors::ApiErrorResponse::InvalidRequestUrl))\n+                .attach_printable_lazy(|| {\n+                    format!(\n+                        \"Payment link was not generated for {}\\nmissing allowed_domains\",\n+                        link_id\n+                    )\n+                })?;\n+\n+            // Validate origin / referer",
        "comment_created_at": "2025-01-29T11:59:52+00:00",
        "comment_author": "kashif-m",
        "comment_body": "Move validation bits to validator.rs",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2334227086",
    "pr_number": 9306,
    "pr_file": "crates/injector/src/vault_metadata.rs",
    "created_at": "2025-09-09T16:53:48+00:00",
    "commented_code": "+use std::collections::HashMap;\n+\n+use base64::Engine;\n+use masking::{ExposeInterface, Secret};\n+use router_env::logger;\n+use url::Url;\n+\n+use crate::{ConnectionConfig, VaultConnectors};\n+\n+const BASE64_ENGINE: base64::engine::GeneralPurpose = base64::engine::general_purpose::STANDARD;\n+pub const EXTERNAL_VAULT_METADATA_HEADER: &str = \"x-external-vault-metadata\";",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2334227086",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9306,
        "pr_file": "crates/injector/src/vault_metadata.rs",
        "discussion_id": "2334227086",
        "commented_code": "@@ -0,0 +1,535 @@\n+use std::collections::HashMap;\n+\n+use base64::Engine;\n+use masking::{ExposeInterface, Secret};\n+use router_env::logger;\n+use url::Url;\n+\n+use crate::{ConnectionConfig, VaultConnectors};\n+\n+const BASE64_ENGINE: base64::engine::GeneralPurpose = base64::engine::general_purpose::STANDARD;\n+pub const EXTERNAL_VAULT_METADATA_HEADER: &str = \"x-external-vault-metadata\";",
        "comment_created_at": "2025-09-09T16:53:48+00:00",
        "comment_author": "Sakilmostak",
        "comment_body": "nit: move them to a common consts file",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2285283012",
    "pr_number": 8986,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/aci.rs",
    "created_at": "2025-08-19T13:29:15+00:00",
    "commented_code": "impl ConnectorIntegration<RSync, RefundsData, RefundsResponseData> for Aci {}\n \n+impl ConnectorIntegration<PreAuthentication, AuthenticationData, AuthenticationResponseData>\n+    for Aci\n+{\n+    fn get_headers(\n+        &self,\n+        req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        _connectors: &Connectors,\n+    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n+        let mut header = vec![(\n+            headers::CONTENT_TYPE.to_string(),\n+            self.common_get_content_type().to_string().into(),\n+        )];\n+        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n+        header.append(&mut api_key);\n+        Ok(header)\n+    }\n+\n+    fn get_content_type(&self) -> &'static str {\n+        self.common_get_content_type()\n+    }\n+\n+    fn get_url(\n+        &self,\n+        _req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        connectors: &Connectors,\n+    ) -> CustomResult<String, errors::ConnectorError> {\n+        Ok(format!(\"{}v1/threeDSecure\", self.base_url(connectors)))\n+    }\n+\n+    fn get_request_body(\n+        &self,\n+        req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        _connectors: &Connectors,\n+    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n+        let connector_req = aci::AciStandalone3DSRequest::try_from(req)?;\n+        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n+    }\n+\n+    fn build_request(\n+        &self,\n+        req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        connectors: &Connectors,\n+    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n+        Ok(Some(\n+            RequestBuilder::new()\n+                .method(Method::Post)\n+                .url(&self.get_url(req, connectors)?)\n+                .attach_default_headers()\n+                .headers(self.get_headers(req, connectors)?)\n+                .set_body(self.get_request_body(req, connectors)?)\n+                .build(),\n+        ))\n+    }\n+\n+    fn handle_response(\n+        &self,\n+        data: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        event_builder: Option<&mut ConnectorEvent>,\n+        res: Response,\n+    ) -> CustomResult<\n+        RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        errors::ConnectorError,\n+    > {\n+        let response: aci::AciStandalone3DSResponse = res\n+            .response\n+            .parse_struct(\"AciStandalone3DSResponse\")\n+            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n+\n+        event_builder.map(|i| i.set_response_body(&response));\n+        router_env::logger::info!(connector_response=?response);\n+\n+        let response_data = if response.redirect.is_some() {",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2285283012",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 8986,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/aci.rs",
        "discussion_id": "2285283012",
        "commented_code": "@@ -651,6 +753,269 @@ impl ConnectorIntegration<Execute, RefundsData, RefundsResponseData> for Aci {\n \n impl ConnectorIntegration<RSync, RefundsData, RefundsResponseData> for Aci {}\n \n+impl ConnectorIntegration<PreAuthentication, AuthenticationData, AuthenticationResponseData>\n+    for Aci\n+{\n+    fn get_headers(\n+        &self,\n+        req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        _connectors: &Connectors,\n+    ) -> CustomResult<Vec<(String, masking::Maskable<String>)>, errors::ConnectorError> {\n+        let mut header = vec![(\n+            headers::CONTENT_TYPE.to_string(),\n+            self.common_get_content_type().to_string().into(),\n+        )];\n+        let mut api_key = self.get_auth_header(&req.connector_auth_type)?;\n+        header.append(&mut api_key);\n+        Ok(header)\n+    }\n+\n+    fn get_content_type(&self) -> &'static str {\n+        self.common_get_content_type()\n+    }\n+\n+    fn get_url(\n+        &self,\n+        _req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        connectors: &Connectors,\n+    ) -> CustomResult<String, errors::ConnectorError> {\n+        Ok(format!(\"{}v1/threeDSecure\", self.base_url(connectors)))\n+    }\n+\n+    fn get_request_body(\n+        &self,\n+        req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        _connectors: &Connectors,\n+    ) -> CustomResult<RequestContent, errors::ConnectorError> {\n+        let connector_req = aci::AciStandalone3DSRequest::try_from(req)?;\n+        Ok(RequestContent::FormUrlEncoded(Box::new(connector_req)))\n+    }\n+\n+    fn build_request(\n+        &self,\n+        req: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        connectors: &Connectors,\n+    ) -> CustomResult<Option<Request>, errors::ConnectorError> {\n+        Ok(Some(\n+            RequestBuilder::new()\n+                .method(Method::Post)\n+                .url(&self.get_url(req, connectors)?)\n+                .attach_default_headers()\n+                .headers(self.get_headers(req, connectors)?)\n+                .set_body(self.get_request_body(req, connectors)?)\n+                .build(),\n+        ))\n+    }\n+\n+    fn handle_response(\n+        &self,\n+        data: &RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        event_builder: Option<&mut ConnectorEvent>,\n+        res: Response,\n+    ) -> CustomResult<\n+        RouterData<PreAuthentication, AuthenticationData, AuthenticationResponseData>,\n+        errors::ConnectorError,\n+    > {\n+        let response: aci::AciStandalone3DSResponse = res\n+            .response\n+            .parse_struct(\"AciStandalone3DSResponse\")\n+            .change_context(errors::ConnectorError::ResponseDeserializationFailed)?;\n+\n+        event_builder.map(|i| i.set_response_body(&response));\n+        router_env::logger::info!(connector_response=?response);\n+\n+        let response_data = if response.redirect.is_some() {",
        "comment_created_at": "2025-08-19T13:29:15+00:00",
        "comment_author": "ImSagnik007",
        "comment_body": "We generally keep type transformations in `transformers.rs`. Could we move this there and implement it using `TryFrom` for consistency? You can follow the `handle_response` function of `trustpay.rs` for any flow for reference.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2352420899",
    "pr_number": 9123,
    "pr_file": "crates/router/src/core/subscription/utils.rs",
    "created_at": "2025-09-16T12:55:57+00:00",
    "commented_code": "+use api_models::{customers::CustomerRequest, subscription::CreateSubscriptionRequest};\n+use common_utils::id_type::GenerateId;\n+use hyperswitch_domain_models::{\n+    api::ApplicationResponse, merchant_context::MerchantContext,\n+    router_request_types::CustomerDetails,\n+};\n+\n+use crate::{\n+    core::customers::create_customer,\n+    db::{\n+        errors::{self, StorageErrorExt},\n+        StorageInterface,\n+    },\n+    routes::SessionState,\n+    types::{api::CustomerResponse, transformers::ForeignInto},\n+};\n+\n+pub async fn get_or_create_customer(\n+    state: SessionState,\n+    customer_request: Option<CustomerRequest>,\n+    merchant_context: MerchantContext,\n+) -> errors::CustomerResponse<CustomerResponse> {",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2352420899",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9123,
        "pr_file": "crates/router/src/core/subscription/utils.rs",
        "discussion_id": "2352420899",
        "commented_code": "@@ -0,0 +1,74 @@\n+use api_models::{customers::CustomerRequest, subscription::CreateSubscriptionRequest};\n+use common_utils::id_type::GenerateId;\n+use hyperswitch_domain_models::{\n+    api::ApplicationResponse, merchant_context::MerchantContext,\n+    router_request_types::CustomerDetails,\n+};\n+\n+use crate::{\n+    core::customers::create_customer,\n+    db::{\n+        errors::{self, StorageErrorExt},\n+        StorageInterface,\n+    },\n+    routes::SessionState,\n+    types::{api::CustomerResponse, transformers::ForeignInto},\n+};\n+\n+pub async fn get_or_create_customer(\n+    state: SessionState,\n+    customer_request: Option<CustomerRequest>,\n+    merchant_context: MerchantContext,\n+) -> errors::CustomerResponse<CustomerResponse> {",
        "comment_created_at": "2025-09-16T12:55:57+00:00",
        "comment_author": "hrithikesh026",
        "comment_body": "There already a similar function that does this.\r\nhttps://github.com/juspay/hyperswitch/blob/d4e717aff94abd99dd9038420fe83e10627946ae/crates/router/src/core/payouts/helpers.rs#L775",
        "pr_file_module": null
      },
      {
        "comment_id": "2354792453",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9123,
        "pr_file": "crates/router/src/core/subscription/utils.rs",
        "discussion_id": "2352420899",
        "commented_code": "@@ -0,0 +1,74 @@\n+use api_models::{customers::CustomerRequest, subscription::CreateSubscriptionRequest};\n+use common_utils::id_type::GenerateId;\n+use hyperswitch_domain_models::{\n+    api::ApplicationResponse, merchant_context::MerchantContext,\n+    router_request_types::CustomerDetails,\n+};\n+\n+use crate::{\n+    core::customers::create_customer,\n+    db::{\n+        errors::{self, StorageErrorExt},\n+        StorageInterface,\n+    },\n+    routes::SessionState,\n+    types::{api::CustomerResponse, transformers::ForeignInto},\n+};\n+\n+pub async fn get_or_create_customer(\n+    state: SessionState,\n+    customer_request: Option<CustomerRequest>,\n+    merchant_context: MerchantContext,\n+) -> errors::CustomerResponse<CustomerResponse> {",
        "comment_created_at": "2025-09-17T08:49:21+00:00",
        "comment_author": "prajjwalkumar17",
        "comment_body": "So there are mainly two reasons to not use that function (which is present in `payouts/helpers`):\r\n--> We have created subscription's util function in such a way that it returns us with `CustomerResponse`, which we directly populate in our response, again this can be justified by writing a `try_from`, after which still codebit will increase instead of that I used `create_customer` functionality which is present in `core/customers` which isn't used by this function and the code is again duplicated there.\r\n\r\n--> rather than using a `payouts/helper` function which might/might_not change in future(which is highly unlikely still) as we are not maintainers of that file, so it can be changed without a review from us, which I wouldn't want to.\r\n\r\nIf required this functionality can be refactored to a common place say `core/customer` or something in future then we can write try_froms if required.",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2334150012",
    "pr_number": 9122,
    "pr_file": "crates/router/src/core/payment_methods.rs",
    "created_at": "2025-09-09T16:17:50+00:00",
    "commented_code": "#[allow(clippy::too_many_arguments)]\n #[instrument(skip_all)]\n pub async fn retrieve_payment_method_with_token(\n-    _state: &SessionState,\n-    _merchant_key_store: &domain::MerchantKeyStore,\n-    _token_data: &storage::PaymentTokenData,\n-    _payment_intent: &PaymentIntent,\n-    _card_token_data: Option<&domain::CardToken>,\n-    _customer: &Option<domain::Customer>,\n-    _storage_scheme: common_enums::enums::MerchantStorageScheme,\n-    _mandate_id: Option<api_models::payments::MandateIds>,\n-    _payment_method_info: Option<domain::PaymentMethod>,\n-    _business_profile: &domain::Profile,\n+    state: &SessionState,\n+    merchant_key_store: &domain::MerchantKeyStore,\n+    token_data: &storage::PaymentTokenData,\n+    payment_intent: &PaymentIntent,\n+    payment_attempt: &PaymentAttempt,\n+    card_token_data: Option<&domain::CardToken>,\n ) -> RouterResult<storage::PaymentMethodDataWithId> {\n-    todo!()\n+    let token = match token_data {\n+        storage::PaymentTokenData::TemporaryGeneric(generic_token) => {\n+            retrieve_payment_method_with_temporary_token(\n+                state,\n+                &generic_token.token,\n+                payment_intent,\n+                payment_attempt,\n+                merchant_key_store,\n+                card_token_data,\n+            )\n+            .await?\n+            .map(\n+                |(payment_method_data, payment_method)| storage::PaymentMethodDataWithId {\n+                    payment_method_data: Some(payment_method_data),\n+                    payment_method: Some(payment_method),\n+                    payment_method_id: None,\n+                },\n+            )\n+            .unwrap_or_default()\n+        }\n+        _ => Err(errors::ApiErrorResponse::NotImplemented {\n+            message: errors::NotImplementedMessage::Reason(\n+                \"PermanentCard and AuthBankDebit Token not implemented\".to_string(),\n+            ),\n+        })?,\n+    };\n+    Ok(token)\n+}\n+\n+#[cfg(feature = \"v2\")]\n+pub async fn retrieve_payment_method_with_temporary_token(\n+    state: &SessionState,\n+    token: &str,\n+    payment_intent: &PaymentIntent,\n+    payment_attempt: &PaymentAttempt,\n+    merchant_key_store: &domain::MerchantKeyStore,\n+    card_token_data: Option<&domain::CardToken>,\n+) -> RouterResult<Option<(domain::PaymentMethodData, enums::PaymentMethod)>> {\n+    let (pm, supplementary_data) =\n+        vault::Vault::get_payment_method_data_from_locker(state, token, merchant_key_store)\n+            .await\n+            .attach_printable(\n+                \"Payment method for given token not found or there was a problem fetching it\",\n+            )?;\n+\n+    when(\n+        supplementary_data\n+            .customer_id\n+            .ne(&payment_intent.customer_id),\n+        || {\n+            Err(errors::ApiErrorResponse::PreconditionFailed { message: \"customer associated with payment method and customer passed in payment are not same\".into() })\n+        },\n+    )?;\n+\n+    Ok::<_, error_stack::Report<errors::ApiErrorResponse>>(match pm {\n+        Some(domain::PaymentMethodData::Card(card)) => {\n+            let mut updated_card = card.clone();\n+            let mut is_card_updated = false;\n+\n+            // The card_holder_name from locker retrieved card is considered if it is a non-empty string or else card_holder_name is picked\n+            // from payment_method_data.card_token object\n+            let name_on_card =\n+                card_token_data.and_then(|token_data| token_data.card_holder_name.clone());\n+\n+            if let Some(name) = name_on_card.clone() {\n+                if !name.peek().is_empty() {\n+                    is_card_updated = true;\n+                    updated_card.nick_name = name_on_card;\n+                }\n+            }\n+\n+            if let Some(token_data) = card_token_data {\n+                if let Some(cvc) = token_data.card_cvc.clone() {\n+                    is_card_updated = true;\n+                    updated_card.card_cvc = cvc;\n+                }\n+            }\n+\n+            // populate additional card details from payment_attempt.payment_method_data (additional_payment_data) if not present in the locker\n+            if updated_card.card_issuer.is_none()\n+                || updated_card.card_network.is_none()\n+                || updated_card.card_type.is_none()\n+                || updated_card.card_issuing_country.is_none()\n+            {\n+                let additional_payment_method_data: Option<\n+                    api_models::payments::AdditionalPaymentData,\n+                > = payment_attempt\n+                    .payment_method_data\n+                    .clone()\n+                    .and_then(|data| match data.peek() {\n+                        serde_json::Value::Null => None, // This is to handle the case when the payment_method_data is null\n+                        _ => Some(data.parse_value(\"AdditionalPaymentData\")),\n+                    })\n+                    .transpose()\n+                    .map_err(|err| logger::error!(\"Failed to parse AdditionalPaymentData {err:?}\"))\n+                    .ok()\n+                    .flatten();\n+                if let Some(api_models::payments::AdditionalPaymentData::Card(card)) =\n+                    additional_payment_method_data\n+                {\n+                    is_card_updated = true;\n+                    updated_card.card_issuer = updated_card.card_issuer.or(card.card_issuer);\n+                    updated_card.card_network = updated_card.card_network.or(card.card_network);\n+                    updated_card.card_type = updated_card.card_type.or(card.card_type);\n+                    updated_card.card_issuing_country = updated_card\n+                        .card_issuing_country\n+                        .or(card.card_issuing_country);\n+                };\n+            };\n+\n+            if is_card_updated {\n+                let updated_pm = domain::PaymentMethodData::Card(updated_card);\n+                vault::Vault::store_payment_method_data_in_locker(\n+                    state,\n+                    Some(token.to_owned()),\n+                    &updated_pm,\n+                    payment_intent.customer_id.to_owned(),\n+                    enums::PaymentMethod::Card,\n+                    merchant_key_store,\n+                )\n+                .await?;\n+\n+                Some((updated_pm, enums::PaymentMethod::Card))\n+            } else {\n+                Some((\n+                    domain::PaymentMethodData::Card(card),\n+                    enums::PaymentMethod::Card,\n+                ))\n+            }\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::Wallet(_)) => {\n+            Some((the_pm, enums::PaymentMethod::Wallet))\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::BankTransfer(_)) => {\n+            Some((the_pm, enums::PaymentMethod::BankTransfer))\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::BankRedirect(_)) => {\n+            Some((the_pm, enums::PaymentMethod::BankRedirect))\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::BankDebit(_)) => {\n+            Some((the_pm, enums::PaymentMethod::BankDebit))\n+        }\n+\n+        Some(_) => Err(errors::ApiErrorResponse::InternalServerError)\n+            .attach_printable(\"Payment method received from locker is unsupported by locker\")?,\n+\n+        None => None,\n+    })\n }",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2334150012",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9122,
        "pr_file": "crates/router/src/core/payment_methods.rs",
        "discussion_id": "2334150012",
        "commented_code": "@@ -518,18 +518,165 @@ pub async fn add_payment_method_status_update_task(\n #[allow(clippy::too_many_arguments)]\n #[instrument(skip_all)]\n pub async fn retrieve_payment_method_with_token(\n-    _state: &SessionState,\n-    _merchant_key_store: &domain::MerchantKeyStore,\n-    _token_data: &storage::PaymentTokenData,\n-    _payment_intent: &PaymentIntent,\n-    _card_token_data: Option<&domain::CardToken>,\n-    _customer: &Option<domain::Customer>,\n-    _storage_scheme: common_enums::enums::MerchantStorageScheme,\n-    _mandate_id: Option<api_models::payments::MandateIds>,\n-    _payment_method_info: Option<domain::PaymentMethod>,\n-    _business_profile: &domain::Profile,\n+    state: &SessionState,\n+    merchant_key_store: &domain::MerchantKeyStore,\n+    token_data: &storage::PaymentTokenData,\n+    payment_intent: &PaymentIntent,\n+    payment_attempt: &PaymentAttempt,\n+    card_token_data: Option<&domain::CardToken>,\n ) -> RouterResult<storage::PaymentMethodDataWithId> {\n-    todo!()\n+    let token = match token_data {\n+        storage::PaymentTokenData::TemporaryGeneric(generic_token) => {\n+            retrieve_payment_method_with_temporary_token(\n+                state,\n+                &generic_token.token,\n+                payment_intent,\n+                payment_attempt,\n+                merchant_key_store,\n+                card_token_data,\n+            )\n+            .await?\n+            .map(\n+                |(payment_method_data, payment_method)| storage::PaymentMethodDataWithId {\n+                    payment_method_data: Some(payment_method_data),\n+                    payment_method: Some(payment_method),\n+                    payment_method_id: None,\n+                },\n+            )\n+            .unwrap_or_default()\n+        }\n+        _ => Err(errors::ApiErrorResponse::NotImplemented {\n+            message: errors::NotImplementedMessage::Reason(\n+                \"PermanentCard and AuthBankDebit Token not implemented\".to_string(),\n+            ),\n+        })?,\n+    };\n+    Ok(token)\n+}\n+\n+#[cfg(feature = \"v2\")]\n+pub async fn retrieve_payment_method_with_temporary_token(\n+    state: &SessionState,\n+    token: &str,\n+    payment_intent: &PaymentIntent,\n+    payment_attempt: &PaymentAttempt,\n+    merchant_key_store: &domain::MerchantKeyStore,\n+    card_token_data: Option<&domain::CardToken>,\n+) -> RouterResult<Option<(domain::PaymentMethodData, enums::PaymentMethod)>> {\n+    let (pm, supplementary_data) =\n+        vault::Vault::get_payment_method_data_from_locker(state, token, merchant_key_store)\n+            .await\n+            .attach_printable(\n+                \"Payment method for given token not found or there was a problem fetching it\",\n+            )?;\n+\n+    when(\n+        supplementary_data\n+            .customer_id\n+            .ne(&payment_intent.customer_id),\n+        || {\n+            Err(errors::ApiErrorResponse::PreconditionFailed { message: \"customer associated with payment method and customer passed in payment are not same\".into() })\n+        },\n+    )?;\n+\n+    Ok::<_, error_stack::Report<errors::ApiErrorResponse>>(match pm {\n+        Some(domain::PaymentMethodData::Card(card)) => {\n+            let mut updated_card = card.clone();\n+            let mut is_card_updated = false;\n+\n+            // The card_holder_name from locker retrieved card is considered if it is a non-empty string or else card_holder_name is picked\n+            // from payment_method_data.card_token object\n+            let name_on_card =\n+                card_token_data.and_then(|token_data| token_data.card_holder_name.clone());\n+\n+            if let Some(name) = name_on_card.clone() {\n+                if !name.peek().is_empty() {\n+                    is_card_updated = true;\n+                    updated_card.nick_name = name_on_card;\n+                }\n+            }\n+\n+            if let Some(token_data) = card_token_data {\n+                if let Some(cvc) = token_data.card_cvc.clone() {\n+                    is_card_updated = true;\n+                    updated_card.card_cvc = cvc;\n+                }\n+            }\n+\n+            // populate additional card details from payment_attempt.payment_method_data (additional_payment_data) if not present in the locker\n+            if updated_card.card_issuer.is_none()\n+                || updated_card.card_network.is_none()\n+                || updated_card.card_type.is_none()\n+                || updated_card.card_issuing_country.is_none()\n+            {\n+                let additional_payment_method_data: Option<\n+                    api_models::payments::AdditionalPaymentData,\n+                > = payment_attempt\n+                    .payment_method_data\n+                    .clone()\n+                    .and_then(|data| match data.peek() {\n+                        serde_json::Value::Null => None, // This is to handle the case when the payment_method_data is null\n+                        _ => Some(data.parse_value(\"AdditionalPaymentData\")),\n+                    })\n+                    .transpose()\n+                    .map_err(|err| logger::error!(\"Failed to parse AdditionalPaymentData {err:?}\"))\n+                    .ok()\n+                    .flatten();\n+                if let Some(api_models::payments::AdditionalPaymentData::Card(card)) =\n+                    additional_payment_method_data\n+                {\n+                    is_card_updated = true;\n+                    updated_card.card_issuer = updated_card.card_issuer.or(card.card_issuer);\n+                    updated_card.card_network = updated_card.card_network.or(card.card_network);\n+                    updated_card.card_type = updated_card.card_type.or(card.card_type);\n+                    updated_card.card_issuing_country = updated_card\n+                        .card_issuing_country\n+                        .or(card.card_issuing_country);\n+                };\n+            };\n+\n+            if is_card_updated {\n+                let updated_pm = domain::PaymentMethodData::Card(updated_card);\n+                vault::Vault::store_payment_method_data_in_locker(\n+                    state,\n+                    Some(token.to_owned()),\n+                    &updated_pm,\n+                    payment_intent.customer_id.to_owned(),\n+                    enums::PaymentMethod::Card,\n+                    merchant_key_store,\n+                )\n+                .await?;\n+\n+                Some((updated_pm, enums::PaymentMethod::Card))\n+            } else {\n+                Some((\n+                    domain::PaymentMethodData::Card(card),\n+                    enums::PaymentMethod::Card,\n+                ))\n+            }\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::Wallet(_)) => {\n+            Some((the_pm, enums::PaymentMethod::Wallet))\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::BankTransfer(_)) => {\n+            Some((the_pm, enums::PaymentMethod::BankTransfer))\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::BankRedirect(_)) => {\n+            Some((the_pm, enums::PaymentMethod::BankRedirect))\n+        }\n+\n+        Some(the_pm @ domain::PaymentMethodData::BankDebit(_)) => {\n+            Some((the_pm, enums::PaymentMethod::BankDebit))\n+        }\n+\n+        Some(_) => Err(errors::ApiErrorResponse::InternalServerError)\n+            .attach_printable(\"Payment method received from locker is unsupported by locker\")?,\n+\n+        None => None,\n+    })\n }",
        "comment_created_at": "2025-09-09T16:17:50+00:00",
        "comment_author": "Sakilmostak",
        "comment_body": "why do we need a separate function for v2 when there is no difference with v1. You can make this a common method (moving it into payment_method) and use it in both places",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2351901142",
    "pr_number": 9351,
    "pr_file": "crates/hyperswitch_connectors/src/utils.rs",
    "created_at": "2025-09-16T10:34:17+00:00",
    "commented_code": "}\n }\n \n+impl ForeignTryFrom<String> for NewZealandStatesAbbreviation {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn foreign_try_from(value: String) -> Result<Self, Self::Error> {\n+        let state_abbreviation_check =\n+            StringExt::<Self>::parse_enum(value.clone(), \"NewZealandStatesAbbreviation\");\n+        match state_abbreviation_check {\n+            Ok(state_abbreviation) => Ok(state_abbreviation),\n+            Err(_) => {\n+                let state = normalize_string(value).map_err(|_e| {\n+                    error_stack::Report::new(errors::ConnectorError::InvalidDataFormat {\n+                        field_name: \"address.state\",\n+                    })\n+                })?;",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2351901142",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9351,
        "pr_file": "crates/hyperswitch_connectors/src/utils.rs",
        "discussion_id": "2351901142",
        "commented_code": "@@ -3579,6 +3816,274 @@ impl ForeignTryFrom<String> for NetherlandsStatesAbbreviation {\n     }\n }\n \n+impl ForeignTryFrom<String> for NewZealandStatesAbbreviation {\n+    type Error = error_stack::Report<errors::ConnectorError>;\n+    fn foreign_try_from(value: String) -> Result<Self, Self::Error> {\n+        let state_abbreviation_check =\n+            StringExt::<Self>::parse_enum(value.clone(), \"NewZealandStatesAbbreviation\");\n+        match state_abbreviation_check {\n+            Ok(state_abbreviation) => Ok(state_abbreviation),\n+            Err(_) => {\n+                let state = normalize_string(value).map_err(|_e| {\n+                    error_stack::Report::new(errors::ConnectorError::InvalidDataFormat {\n+                        field_name: \"address.state\",\n+                    })\n+                })?;",
        "comment_created_at": "2025-09-16T10:34:17+00:00",
        "comment_author": "jagan-jaya",
        "comment_body": "```suggestion\r\n        let state_abbreviation_check =\r\n            StringExt::<Self>::parse_enum(value.clone(), \"NewZealandStatesAbbreviation\");\r\n        match state_abbreviation_check {\r\n            Ok(state_abbreviation) => Ok(state_abbreviation),\r\n            Err(_) => {\r\n                let state = normalize_string(value).map_err(|_e| {\r\n                    error_stack::Report::new(errors::ConnectorError::InvalidDataFormat {\r\n                        field_name: \"address.state\",\r\n                    })\r\n                })?;\r\n```\r\nmove this logic to a common function as it is repeated in other places",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2332361238",
    "pr_number": 9274,
    "pr_file": "crates/router/src/types/api/connector_mapping.rs",
    "created_at": "2025-09-09T07:52:45+00:00",
    "commented_code": "merchant_connector_id: connector_id,\n         })\n     }\n+    #[cfg(feature = \"v1\")]\n+    pub fn get_external_vault_connector_by_name(\n+        _connectors: &Connectors,\n+        connector: String,\n+        connector_type: GetToken,\n+        connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n+    ) -> CustomResult<Self, errors::ApiErrorResponse> {\n+        let connector_enum = Self::convert_connector(&connector)?;\n+        let external_vault_connector_name =\n+            enums::VaultConnectors::from_str(&connector.to_string())\n+                .change_context(errors::ConnectorError::InvalidConnectorName)\n+                .change_context(errors::ApiErrorResponse::InternalServerError)\n+                .attach_printable_lazy(|| {\n+                    format!(\"unable to parse external vault connector name {connector:?}\")\n+                })?;\n+        let connector_name = enums::Connector::from(external_vault_connector_name);\n+        Ok(Self {\n+            connector: connector_enum,\n+            connector_name,\n+            get_token: connector_type,\n+            merchant_connector_id: connector_id,\n+        })\n+    }",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2332361238",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9274,
        "pr_file": "crates/router/src/types/api/connector_mapping.rs",
        "discussion_id": "2332361238",
        "commented_code": "@@ -99,6 +99,29 @@ impl ConnectorData {\n             merchant_connector_id: connector_id,\n         })\n     }\n+    #[cfg(feature = \"v1\")]\n+    pub fn get_external_vault_connector_by_name(\n+        _connectors: &Connectors,\n+        connector: String,\n+        connector_type: GetToken,\n+        connector_id: Option<common_utils::id_type::MerchantConnectorAccountId>,\n+    ) -> CustomResult<Self, errors::ApiErrorResponse> {\n+        let connector_enum = Self::convert_connector(&connector)?;\n+        let external_vault_connector_name =\n+            enums::VaultConnectors::from_str(&connector.to_string())\n+                .change_context(errors::ConnectorError::InvalidConnectorName)\n+                .change_context(errors::ApiErrorResponse::InternalServerError)\n+                .attach_printable_lazy(|| {\n+                    format!(\"unable to parse external vault connector name {connector:?}\")\n+                })?;\n+        let connector_name = enums::Connector::from(external_vault_connector_name);\n+        Ok(Self {\n+            connector: connector_enum,\n+            connector_name,\n+            get_token: connector_type,\n+            merchant_connector_id: connector_id,\n+        })\n+    }",
        "comment_created_at": "2025-09-09T07:52:45+00:00",
        "comment_author": "Sakilmostak",
        "comment_body": "why do we need a separate implementation for this? I can see connector name is the only parameter which is different. It is taken as string, but string can be converted to Connector enum. Instead of having new implementation, convert string to enum and use common method",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2334105831",
    "pr_number": 9122,
    "pr_file": "crates/router/src/core/payment_methods.rs",
    "created_at": "2025-09-09T15:59:25+00:00",
    "commented_code": "#[allow(clippy::too_many_arguments)]\n #[instrument(skip_all)]\n pub async fn retrieve_payment_method_with_token(\n-    _state: &SessionState,\n-    _merchant_key_store: &domain::MerchantKeyStore,\n-    _token_data: &storage::PaymentTokenData,\n-    _payment_intent: &PaymentIntent,\n-    _card_token_data: Option<&domain::CardToken>,\n-    _customer: &Option<domain::Customer>,\n-    _storage_scheme: common_enums::enums::MerchantStorageScheme,\n-    _mandate_id: Option<api_models::payments::MandateIds>,\n-    _payment_method_info: Option<domain::PaymentMethod>,\n-    _business_profile: &domain::Profile,\n+    state: &SessionState,\n+    merchant_key_store: &domain::MerchantKeyStore,\n+    token_data: &storage::PaymentTokenData,\n+    payment_intent: &PaymentIntent,\n+    payment_attempt: &PaymentAttempt,\n+    card_token_data: Option<&domain::CardToken>,\n ) -> RouterResult<storage::PaymentMethodDataWithId> {\n-    todo!()\n+    let token = match token_data {\n+        storage::PaymentTokenData::TemporaryGeneric(generic_token) => {\n+            retrieve_payment_method_with_temporary_token(\n+                state,\n+                &generic_token.token,\n+                payment_intent,\n+                payment_attempt,\n+                merchant_key_store,\n+                card_token_data,\n+            )\n+            .await?\n+            .map(\n+                |(payment_method_data, payment_method)| storage::PaymentMethodDataWithId {\n+                    payment_method_data: Some(payment_method_data),\n+                    payment_method: Some(payment_method),\n+                    payment_method_id: None,\n+                },\n+            )\n+            .unwrap_or_default()\n+        }\n+        _ => Err(errors::ApiErrorResponse::NotImplemented {",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2334105831",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9122,
        "pr_file": "crates/router/src/core/payment_methods.rs",
        "discussion_id": "2334105831",
        "commented_code": "@@ -518,18 +518,165 @@ pub async fn add_payment_method_status_update_task(\n #[allow(clippy::too_many_arguments)]\n #[instrument(skip_all)]\n pub async fn retrieve_payment_method_with_token(\n-    _state: &SessionState,\n-    _merchant_key_store: &domain::MerchantKeyStore,\n-    _token_data: &storage::PaymentTokenData,\n-    _payment_intent: &PaymentIntent,\n-    _card_token_data: Option<&domain::CardToken>,\n-    _customer: &Option<domain::Customer>,\n-    _storage_scheme: common_enums::enums::MerchantStorageScheme,\n-    _mandate_id: Option<api_models::payments::MandateIds>,\n-    _payment_method_info: Option<domain::PaymentMethod>,\n-    _business_profile: &domain::Profile,\n+    state: &SessionState,\n+    merchant_key_store: &domain::MerchantKeyStore,\n+    token_data: &storage::PaymentTokenData,\n+    payment_intent: &PaymentIntent,\n+    payment_attempt: &PaymentAttempt,\n+    card_token_data: Option<&domain::CardToken>,\n ) -> RouterResult<storage::PaymentMethodDataWithId> {\n-    todo!()\n+    let token = match token_data {\n+        storage::PaymentTokenData::TemporaryGeneric(generic_token) => {\n+            retrieve_payment_method_with_temporary_token(\n+                state,\n+                &generic_token.token,\n+                payment_intent,\n+                payment_attempt,\n+                merchant_key_store,\n+                card_token_data,\n+            )\n+            .await?\n+            .map(\n+                |(payment_method_data, payment_method)| storage::PaymentMethodDataWithId {\n+                    payment_method_data: Some(payment_method_data),\n+                    payment_method: Some(payment_method),\n+                    payment_method_id: None,\n+                },\n+            )\n+            .unwrap_or_default()\n+        }\n+        _ => Err(errors::ApiErrorResponse::NotImplemented {",
        "comment_created_at": "2025-09-09T15:59:25+00:00",
        "comment_author": "Sakilmostak",
        "comment_body": "don't use wildcard, put the variant explicitly",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2318130988",
    "pr_number": 9130,
    "pr_file": "crates/router/src/core/payments.rs",
    "created_at": "2025-09-03T08:04:37+00:00",
    "commented_code": "}\n }\n \n+fn is_google_pay_pre_decrypt_type_connector_tokenization(\n+    payment_method_type: Option<storage::enums::PaymentMethodType>,\n+    payment_method_token: Option<&PaymentMethodToken>,\n+    google_pay_pre_decrypt_flow_filter: Option<GooglePayPreDecryptFlow>,\n+) -> bool {\n+    match (payment_method_type, payment_method_token) {\n+        (\n+            Some(storage::enums::PaymentMethodType::GooglePay),\n+            Some(PaymentMethodToken::GooglePayDecrypt(..)),\n+        ) => !matches!(\n+            google_pay_pre_decrypt_flow_filter,\n+            Some(GooglePayPreDecryptFlow::NetworkTokenization)\n+        ),\n+        _ => true,",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2318130988",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9130,
        "pr_file": "crates/router/src/core/payments.rs",
        "discussion_id": "2318130988",
        "commented_code": "@@ -6894,6 +6901,23 @@ fn is_apple_pay_pre_decrypt_type_connector_tokenization(\n     }\n }\n \n+fn is_google_pay_pre_decrypt_type_connector_tokenization(\n+    payment_method_type: Option<storage::enums::PaymentMethodType>,\n+    payment_method_token: Option<&PaymentMethodToken>,\n+    google_pay_pre_decrypt_flow_filter: Option<GooglePayPreDecryptFlow>,\n+) -> bool {\n+    match (payment_method_type, payment_method_token) {\n+        (\n+            Some(storage::enums::PaymentMethodType::GooglePay),\n+            Some(PaymentMethodToken::GooglePayDecrypt(..)),\n+        ) => !matches!(\n+            google_pay_pre_decrypt_flow_filter,\n+            Some(GooglePayPreDecryptFlow::NetworkTokenization)\n+        ),\n+        _ => true,",
        "comment_created_at": "2025-09-03T08:04:37+00:00",
        "comment_author": "Sakilmostak",
        "comment_body": "dont use a wildcard matching, explicitly put all the cases or you can use a `if let` statement in this case",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2351390658",
    "pr_number": 9367,
    "pr_file": "crates/hyperswitch_connectors/src/connectors/aci/transformers.rs",
    "created_at": "2025-09-16T08:16:57+00:00",
    "commented_code": "}\n }\n \n+#[derive(Debug, Serialize, Deserialize)]\n+#[serde(rename_all = \"UPPERCASE\")]\n+pub enum AciRecurringType {\n+    Initial,\n+    Repeated,\n+    RegistrationBased,\n+}\n+\n+fn get_str(key: &str, metadata: &serde_json::Value) -> Option<String> {",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2351390658",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9367,
        "pr_file": "crates/hyperswitch_connectors/src/connectors/aci/transformers.rs",
        "discussion_id": "2351390658",
        "commented_code": "@@ -94,6 +94,38 @@ impl TryFrom<&ConnectorAuthType> for AciAuthType {\n     }\n }\n \n+#[derive(Debug, Serialize, Deserialize)]\n+#[serde(rename_all = \"UPPERCASE\")]\n+pub enum AciRecurringType {\n+    Initial,\n+    Repeated,\n+    RegistrationBased,\n+}\n+\n+fn get_str(key: &str, metadata: &serde_json::Value) -> Option<String> {",
        "comment_created_at": "2025-09-16T08:16:57+00:00",
        "comment_author": "dgeee13",
        "comment_body": "this utility fn`get_str`  is not needed separately, you can directly use `get` \nhttps://docs.rs/std_tools/latest/std_tools/struct.Map.html#method.get",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2329455838",
    "pr_number": 9083,
    "pr_file": "crates/router/src/core/payments/operations/payment_cancel_v2.rs",
    "created_at": "2025-09-08T08:01:59+00:00",
    "commented_code": "+use std::marker::PhantomData;\n+\n+use api_models::enums::FrmSuggestion;\n+use async_trait::async_trait;\n+use common_enums;\n+use common_utils::{ext_traits::AsyncExt, id_type::GlobalPaymentId};\n+use error_stack::ResultExt;\n+use router_env::{instrument, tracing};\n+\n+use super::{\n+    BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest,\n+    ValidateStatusForOperation,\n+};\n+use crate::{\n+    core::{\n+        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n+        payments::{helpers, operations},\n+    },\n+    routes::{app::ReqState, SessionState},\n+    types::{\n+        api::{self, ConnectorCallType, PaymentIdTypeExt},\n+        domain,\n+        storage::{self, enums},\n+        PaymentsCancelData,\n+    },\n+    utils::OptionExt,\n+};\n+\n+/// Operation name for payment cancellation\n+const PAYMENT_CANCEL_OPERATION: &str = \"cancel\";\n+\n+#[derive(Debug, Clone, Copy)]\n+pub struct PaymentsCancel;\n+\n+type BoxedCancelOperation<'b, F> = BoxedOperation<\n+    'b,\n+    F,\n+    api::PaymentsCancelRequest,\n+    hyperswitch_domain_models::payments::PaymentCancelData<F>,\n+>;\n+\n+// Manual Operation trait implementation for V2\n+impl<F: Send + Clone + Sync> Operation<F, api::PaymentsCancelRequest> for &PaymentsCancel {\n+    type Data = hyperswitch_domain_models::payments::PaymentCancelData<F>;\n+\n+    fn to_validate_request(\n+        &self,\n+    ) -> RouterResult<&(dyn ValidateRequest<F, api::PaymentsCancelRequest, Self::Data> + Send + Sync)>\n+    {\n+        Ok(*self)\n+    }\n+\n+    fn to_get_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn GetTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(*self)\n+    }\n+\n+    fn to_domain(&self) -> RouterResult<&(dyn Domain<F, api::PaymentsCancelRequest, Self::Data>)> {\n+        Ok(*self)\n+    }\n+\n+    fn to_update_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn UpdateTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(*self)\n+    }\n+}\n+\n+#[automatically_derived]\n+impl<F: Send + Clone + Sync> Operation<F, api::PaymentsCancelRequest> for PaymentsCancel {\n+    type Data = hyperswitch_domain_models::payments::PaymentCancelData<F>;\n+\n+    fn to_validate_request(\n+        &self,\n+    ) -> RouterResult<&(dyn ValidateRequest<F, api::PaymentsCancelRequest, Self::Data> + Send + Sync)>\n+    {\n+        Ok(self)\n+    }\n+\n+    fn to_get_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn GetTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(self)\n+    }\n+\n+    fn to_domain(&self) -> RouterResult<&dyn Domain<F, api::PaymentsCancelRequest, Self::Data>> {\n+        Ok(self)\n+    }\n+\n+    fn to_update_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn UpdateTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(self)\n+    }\n+}\n+\n+#[cfg(feature = \"v2\")]\n+impl<F: Send + Clone + Sync>\n+    ValidateRequest<\n+        F,\n+        api::PaymentsCancelRequest,\n+        hyperswitch_domain_models::payments::PaymentCancelData<F>,\n+    > for PaymentsCancel\n+{\n+    #[instrument(skip_all)]\n+    fn validate_request(\n+        &self,\n+        _request: &api::PaymentsCancelRequest,\n+        merchant_context: &domain::MerchantContext,\n+    ) -> RouterResult<operations::ValidateResult> {\n+        Ok(operations::ValidateResult {\n+            merchant_id: merchant_context.get_merchant_account().get_id().to_owned(),\n+            storage_scheme: merchant_context.get_merchant_account().storage_scheme,\n+            requeue: false,\n+        })\n+    }\n+}\n+\n+#[cfg(feature = \"v2\")]\n+#[async_trait]\n+impl<F: Send + Clone + Sync>\n+    GetTracker<\n+        F,\n+        hyperswitch_domain_models::payments::PaymentCancelData<F>,\n+        api::PaymentsCancelRequest,\n+    > for PaymentsCancel\n+{\n+    #[instrument(skip_all)]\n+    async fn get_trackers<'a>(\n+        &'a self,\n+        state: &'a SessionState,\n+        payment_id: &common_utils::id_type::GlobalPaymentId,\n+        request: &api::PaymentsCancelRequest,\n+        merchant_context: &domain::MerchantContext,\n+        profile: &domain::Profile,\n+        _header_payload: &hyperswitch_domain_models::payments::HeaderPayload,\n+    ) -> RouterResult<\n+        operations::GetTrackerResponse<hyperswitch_domain_models::payments::PaymentCancelData<F>>,\n+    > {\n+        let db = &*state.store;\n+        let key_manager_state = &state.into();\n+\n+        let merchant_id = merchant_context.get_merchant_account().get_id();\n+        let storage_scheme = merchant_context.get_merchant_account().storage_scheme;\n+        let payment_intent = db\n+            .find_payment_intent_by_id(\n+                key_manager_state,\n+                payment_id,\n+                merchant_context.get_merchant_key_store(),\n+                storage_scheme,\n+            )\n+            .await\n+            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n+\n+        helpers::validate_payment_status_against_not_allowed_statuses(\n+            payment_intent.status,\n+            &[\n+                enums::IntentStatus::Failed,\n+                enums::IntentStatus::Succeeded,\n+                enums::IntentStatus::Cancelled,\n+                enums::IntentStatus::Processing,\n+                enums::IntentStatus::RequiresMerchantAction,\n+            ],\n+            PAYMENT_CANCEL_OPERATION,\n+        )?;\n+\n+        let active_attempt_id = payment_intent.active_attempt_id.as_ref().ok_or_else(|| {\n+            errors::ApiErrorResponse::InvalidRequestData {\n+                message: \"Payment cancellation not possible - no active payment attempt found\"\n+                    .to_string(),\n+            }\n+        })?;\n+\n+        let mut payment_attempt = db\n+            .find_payment_attempt_by_id(\n+                key_manager_state,\n+                merchant_context.get_merchant_key_store(),\n+                active_attempt_id,\n+                storage_scheme,\n+            )\n+            .await\n+            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n+\n+        let amount = payment_attempt.amount_details.get_net_amount();\n+\n+        payment_attempt\n+            .cancellation_reason\n+            .clone_from(&request.cancellation_reason);\n+\n+        let creds_identifier = request\n+            .merchant_connector_details\n+            .as_ref()\n+            .map(|mcd| mcd.creds_identifier.to_owned());\n+        request\n+            .merchant_connector_details\n+            .to_owned()",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2329455838",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9083,
        "pr_file": "crates/router/src/core/payments/operations/payment_cancel_v2.rs",
        "discussion_id": "2329455838",
        "commented_code": "@@ -0,0 +1,393 @@\n+use std::marker::PhantomData;\n+\n+use api_models::enums::FrmSuggestion;\n+use async_trait::async_trait;\n+use common_enums;\n+use common_utils::{ext_traits::AsyncExt, id_type::GlobalPaymentId};\n+use error_stack::ResultExt;\n+use router_env::{instrument, tracing};\n+\n+use super::{\n+    BoxedOperation, Domain, GetTracker, Operation, UpdateTracker, ValidateRequest,\n+    ValidateStatusForOperation,\n+};\n+use crate::{\n+    core::{\n+        errors::{self, CustomResult, RouterResult, StorageErrorExt},\n+        payments::{helpers, operations},\n+    },\n+    routes::{app::ReqState, SessionState},\n+    types::{\n+        api::{self, ConnectorCallType, PaymentIdTypeExt},\n+        domain,\n+        storage::{self, enums},\n+        PaymentsCancelData,\n+    },\n+    utils::OptionExt,\n+};\n+\n+/// Operation name for payment cancellation\n+const PAYMENT_CANCEL_OPERATION: &str = \"cancel\";\n+\n+#[derive(Debug, Clone, Copy)]\n+pub struct PaymentsCancel;\n+\n+type BoxedCancelOperation<'b, F> = BoxedOperation<\n+    'b,\n+    F,\n+    api::PaymentsCancelRequest,\n+    hyperswitch_domain_models::payments::PaymentCancelData<F>,\n+>;\n+\n+// Manual Operation trait implementation for V2\n+impl<F: Send + Clone + Sync> Operation<F, api::PaymentsCancelRequest> for &PaymentsCancel {\n+    type Data = hyperswitch_domain_models::payments::PaymentCancelData<F>;\n+\n+    fn to_validate_request(\n+        &self,\n+    ) -> RouterResult<&(dyn ValidateRequest<F, api::PaymentsCancelRequest, Self::Data> + Send + Sync)>\n+    {\n+        Ok(*self)\n+    }\n+\n+    fn to_get_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn GetTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(*self)\n+    }\n+\n+    fn to_domain(&self) -> RouterResult<&(dyn Domain<F, api::PaymentsCancelRequest, Self::Data>)> {\n+        Ok(*self)\n+    }\n+\n+    fn to_update_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn UpdateTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(*self)\n+    }\n+}\n+\n+#[automatically_derived]\n+impl<F: Send + Clone + Sync> Operation<F, api::PaymentsCancelRequest> for PaymentsCancel {\n+    type Data = hyperswitch_domain_models::payments::PaymentCancelData<F>;\n+\n+    fn to_validate_request(\n+        &self,\n+    ) -> RouterResult<&(dyn ValidateRequest<F, api::PaymentsCancelRequest, Self::Data> + Send + Sync)>\n+    {\n+        Ok(self)\n+    }\n+\n+    fn to_get_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn GetTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(self)\n+    }\n+\n+    fn to_domain(&self) -> RouterResult<&dyn Domain<F, api::PaymentsCancelRequest, Self::Data>> {\n+        Ok(self)\n+    }\n+\n+    fn to_update_tracker(\n+        &self,\n+    ) -> RouterResult<&(dyn UpdateTracker<F, Self::Data, api::PaymentsCancelRequest> + Send + Sync)>\n+    {\n+        Ok(self)\n+    }\n+}\n+\n+#[cfg(feature = \"v2\")]\n+impl<F: Send + Clone + Sync>\n+    ValidateRequest<\n+        F,\n+        api::PaymentsCancelRequest,\n+        hyperswitch_domain_models::payments::PaymentCancelData<F>,\n+    > for PaymentsCancel\n+{\n+    #[instrument(skip_all)]\n+    fn validate_request(\n+        &self,\n+        _request: &api::PaymentsCancelRequest,\n+        merchant_context: &domain::MerchantContext,\n+    ) -> RouterResult<operations::ValidateResult> {\n+        Ok(operations::ValidateResult {\n+            merchant_id: merchant_context.get_merchant_account().get_id().to_owned(),\n+            storage_scheme: merchant_context.get_merchant_account().storage_scheme,\n+            requeue: false,\n+        })\n+    }\n+}\n+\n+#[cfg(feature = \"v2\")]\n+#[async_trait]\n+impl<F: Send + Clone + Sync>\n+    GetTracker<\n+        F,\n+        hyperswitch_domain_models::payments::PaymentCancelData<F>,\n+        api::PaymentsCancelRequest,\n+    > for PaymentsCancel\n+{\n+    #[instrument(skip_all)]\n+    async fn get_trackers<'a>(\n+        &'a self,\n+        state: &'a SessionState,\n+        payment_id: &common_utils::id_type::GlobalPaymentId,\n+        request: &api::PaymentsCancelRequest,\n+        merchant_context: &domain::MerchantContext,\n+        profile: &domain::Profile,\n+        _header_payload: &hyperswitch_domain_models::payments::HeaderPayload,\n+    ) -> RouterResult<\n+        operations::GetTrackerResponse<hyperswitch_domain_models::payments::PaymentCancelData<F>>,\n+    > {\n+        let db = &*state.store;\n+        let key_manager_state = &state.into();\n+\n+        let merchant_id = merchant_context.get_merchant_account().get_id();\n+        let storage_scheme = merchant_context.get_merchant_account().storage_scheme;\n+        let payment_intent = db\n+            .find_payment_intent_by_id(\n+                key_manager_state,\n+                payment_id,\n+                merchant_context.get_merchant_key_store(),\n+                storage_scheme,\n+            )\n+            .await\n+            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n+\n+        helpers::validate_payment_status_against_not_allowed_statuses(\n+            payment_intent.status,\n+            &[\n+                enums::IntentStatus::Failed,\n+                enums::IntentStatus::Succeeded,\n+                enums::IntentStatus::Cancelled,\n+                enums::IntentStatus::Processing,\n+                enums::IntentStatus::RequiresMerchantAction,\n+            ],\n+            PAYMENT_CANCEL_OPERATION,\n+        )?;\n+\n+        let active_attempt_id = payment_intent.active_attempt_id.as_ref().ok_or_else(|| {\n+            errors::ApiErrorResponse::InvalidRequestData {\n+                message: \"Payment cancellation not possible - no active payment attempt found\"\n+                    .to_string(),\n+            }\n+        })?;\n+\n+        let mut payment_attempt = db\n+            .find_payment_attempt_by_id(\n+                key_manager_state,\n+                merchant_context.get_merchant_key_store(),\n+                active_attempt_id,\n+                storage_scheme,\n+            )\n+            .await\n+            .to_not_found_response(errors::ApiErrorResponse::PaymentNotFound)?;\n+\n+        let amount = payment_attempt.amount_details.get_net_amount();\n+\n+        payment_attempt\n+            .cancellation_reason\n+            .clone_from(&request.cancellation_reason);\n+\n+        let creds_identifier = request\n+            .merchant_connector_details\n+            .as_ref()\n+            .map(|mcd| mcd.creds_identifier.to_owned());\n+        request\n+            .merchant_connector_details\n+            .to_owned()",
        "comment_created_at": "2025-09-08T08:01:59+00:00",
        "comment_author": "prasunna09",
        "comment_body": "seems like this creds_identifier is not being used anywhere.\r\nremove it if not required",
        "pr_file_module": null
      }
    ]
  },
  {
    "discussion_id": "2349265154",
    "pr_number": 9274,
    "pr_file": "crates/router/src/core/utils.rs",
    "created_at": "2025-09-15T14:49:36+00:00",
    "commented_code": "}\n }\n \n-#[cfg(feature = \"v2\")]\n+// #[cfg(feature = \"v2\")]\n+// pub async fn construct_vault_router_data<F>(\n+//     state: &SessionState,\n+//     merchant_account: &domain::MerchantAccount,\n+//     merchant_connector_account: &domain::MerchantConnectorAccountTypeDetails,\n+//     payment_method_vaulting_data: Option<\n+//         hyperswitch_domain_models::vault::PaymentMethodVaultingData,\n+//     >,\n+//     connector_vault_id: Option<String>,\n+//     connector_customer_id: Option<String>,\n+// ) -> RouterResult<VaultRouterDataV2<F>> {\n+//     let connector_name = merchant_connector_account\n+//         .get_connector_name()\n+//         .ok_or(errors::ApiErrorResponse::InternalServerError)\n+//         .attach_printable(\"Connector name not present for external vault\")?; // always get the connector name from the merchant_connector_account\n+//     let connector_auth_type = merchant_connector_account\n+//         .get_connector_account_details()\n+//         .change_context(errors::ApiErrorResponse::InternalServerError)?;\n+\n+//     let resource_common_data = VaultConnectorFlowData {\n+//         merchant_id: merchant_account.get_id().to_owned(),\n+//     };\n+\n+//     let router_data = types::RouterDataV2 {\n+//         flow: PhantomData,\n+//         resource_common_data,\n+//         tenant_id: state.tenant.tenant_id.clone(),\n+//         connector_auth_type,\n+//         request: types::VaultRequestData {\n+//             payment_method_vaulting_data,\n+//             connector_vault_id,\n+//             connector_customer_id,\n+//         },\n+//         response: Ok(types::VaultResponseData::default()),\n+//     };\n+\n+//     Ok(router_data)\n+// }",
    "repo_full_name": "juspay/hyperswitch",
    "discussion_comments": [
      {
        "comment_id": "2349265154",
        "repo_full_name": "juspay/hyperswitch",
        "pr_number": 9274,
        "pr_file": "crates/router/src/core/utils.rs",
        "discussion_id": "2349265154",
        "commented_code": "@@ -2373,25 +2372,61 @@ pub(crate) fn validate_profile_id_from_auth_layer<T: GetProfileId + std::fmt::De\n     }\n }\n \n-#[cfg(feature = \"v2\")]\n+// #[cfg(feature = \"v2\")]\n+// pub async fn construct_vault_router_data<F>(\n+//     state: &SessionState,\n+//     merchant_account: &domain::MerchantAccount,\n+//     merchant_connector_account: &domain::MerchantConnectorAccountTypeDetails,\n+//     payment_method_vaulting_data: Option<\n+//         hyperswitch_domain_models::vault::PaymentMethodVaultingData,\n+//     >,\n+//     connector_vault_id: Option<String>,\n+//     connector_customer_id: Option<String>,\n+// ) -> RouterResult<VaultRouterDataV2<F>> {\n+//     let connector_name = merchant_connector_account\n+//         .get_connector_name()\n+//         .ok_or(errors::ApiErrorResponse::InternalServerError)\n+//         .attach_printable(\"Connector name not present for external vault\")?; // always get the connector name from the merchant_connector_account\n+//     let connector_auth_type = merchant_connector_account\n+//         .get_connector_account_details()\n+//         .change_context(errors::ApiErrorResponse::InternalServerError)?;\n+\n+//     let resource_common_data = VaultConnectorFlowData {\n+//         merchant_id: merchant_account.get_id().to_owned(),\n+//     };\n+\n+//     let router_data = types::RouterDataV2 {\n+//         flow: PhantomData,\n+//         resource_common_data,\n+//         tenant_id: state.tenant.tenant_id.clone(),\n+//         connector_auth_type,\n+//         request: types::VaultRequestData {\n+//             payment_method_vaulting_data,\n+//             connector_vault_id,\n+//             connector_customer_id,\n+//         },\n+//         response: Ok(types::VaultResponseData::default()),\n+//     };\n+\n+//     Ok(router_data)\n+// }",
        "comment_created_at": "2025-09-15T14:49:36+00:00",
        "comment_author": "Sakilmostak",
        "comment_body": "remove the commented code if not intended for future implementation",
        "pr_file_module": null
      }
    ]
  }
]